--[连续升级]1
--[管理工具版本号]10.34.10
--本脚本支持从ZLHIS+ v10.34.10 升级到 v10.34.20
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--82934:冉俊明,2015-04-09,病人预交记录中增加"结算性质"字段，同时修正升级数据
Alter Table 病人预交记录 Add(结算性质 Number(2));

--81899:许华峰,2015-03-31,增加索引，按报到时间过滤数据
Create Index 病人医嘱发送_IX_报到时间 On 病人医嘱发送(报到时间) Pctfree 5 Tablespace zl9Indexcis nologging;

--82209:刘硕,2015-03-16,手麻排序
alter table 病人手麻记录 add 手术次序 number(2);

--82620:刘兴洪,2015-03-11,收费轧帐按收费类别轧帐
ALTER TABLE 人员收缴记录 Add(类别 number(2));

--82736:张德婷,2015-03-06,输液配置中心增加审核原因
alter table 病人医嘱记录
 add 药师审核原因 varchar2(500);

--82528:马政,2015-03-05,收费价目调价审核改进
Create table 收费调价记录(
       id NUMBER(18),
       原价ID NUMBER(18),
       收费细目id NUMBER(18),
       原价 NUMBER(16,7),
       现价 NUMBER(16,7),
       缺省价格 NUMBER(16,7),       
       收入项目id NUMBER(18),
       加班加价率 NUMBER(16,5),
       附术收费率 NUMBER(16,5),
       变动原因  NUMBER(3),
       调价说明 VARCHAR2(100),
       调价ID NUMBER(18),
       填制人 VARCHAR2(20),
       填制日期 date,
       执行日期 DATE,
       终止日期 DATE,
       NO VARCHAR2(8),
       序号 NUMBER(5),
       审核人 VARCHAR2(20),
       审核日期  DATE,
       审核标志 number(1),
       说明 varchar2(200)
       ) TABLESPACE zl9BaseItem;

Alter Table 收费调价记录 Add Constraint 收费调价记录_PK Primary Key (ID) Using Index Tablespace zl9Indexcis;

Create Index 收费调价记录_IX_收费细目id On 收费调价记录(收费细目id) Tablespace zl9Indexhis;

Create Index 收费调价记录_IX_收入项目id On 收费调价记录(收入项目id) Tablespace zl9Indexhis;

Create Index 收费调价记录_IX_审核标志 On 收费调价记录(审核标志) Tablespace zl9Indexhis;

Create Index 收费调价记录_IX_填制日期 On 收费调价记录(填制日期) Tablespace zl9Indexhis;

--66870:刘尔旋,2015-02-11,挂号时间段增加提前时间
Alter Table 时间段 Add 提前时间 Date;

Alter Table 时间段 Add 提前颜色 Varchar2(20);

--81970:刘硕,2015-01-29,升级改进
alter Table 上机人员表 add 系统升级锁定 number(1);

--82172:胡俊勇,2015-01-28,输血申请单修改
Create Table 输血性质(编码 Varchar2(2),名称  Varchar2(50),简码 Varchar2(25), 缺省标志 Number(1)) Tablespace zl9BaseItem;
Alter Table 输血性质 Add Constraint 输血性质_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;
Alter Table 输血性质 Add Constraint 输血性质_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--80773:李业庆,2015-01-05,删除输液配药记录和医嘱发送记录的外键关联
Alter Table 输液配药记录 Drop Constraint 输液配药记录_Fk_发送号;

--81829:李业庆,2015-02-04,病人实际取药确认模式
Alter Table 药品收发记录 Add 是否未取药 Number(1);
Alter Table 药品收发记录 Add 取药确认人员 VARCHAR2(20);
Alter Table 药品收发记录 Add 取药时间 Date;

--82528:马政,2015-03-05,收费价目调价审核改进
Alter Table 收费调价记录 Add Constraint 收费调价记录_FK_收费细目id Foreign Key (收费细目id) References 收费项目目录(id) On Delete Cascade;
Alter Table 收费调价记录 Add Constraint 收费调价记录_FK_收入项目id Foreign Key (收入项目id) References 收入项目(id) On Delete Cascade;

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--76300:张德婷,2015-03-23,修改来源科室
Update zlParameters
Set 参数名 = '来源病区', 参数说明 = '设置输液配置中心允许接收的哪些病区的输液医嘱。'
Where 系统 = &n_System And 模块 = 1345 And 参数名 = '来源科室';

Declare
  v_Temp  Varchar2(500);
  v_Para  Varchar2(500);
  v_Data  Varchar2(200);
  n_Id    Number(18);
  n_Count Number(18);
Begin
  Select 参数值 Into v_Temp From zlParameters Where 系统 = &n_System And 模块 = 1345 And 参数名 = '来源病区';

  If v_Temp Is Not Null Then
    v_Temp:=v_Temp || ',';
    While Instr(v_Temp, ',') > 0 Loop
      v_Data := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    
      Select Count(部门id) Into n_Count From 部门性质说明 Where 部门id = To_Number(v_Data) And 工作性质 = '护理';
      If n_Count > 0 Then
        n_Id := v_Data;
      Else
        Select 病区id Into n_Id From 病区科室对应 Where 科室id = To_Number(v_Data) and rownum=1;
      End If;
    
      v_Para := v_Para || n_Id || ',';
    End Loop;
  
    Update zlParameters Set 参数值 = v_Para Where 系统 = &n_System And 模块 = 1345 And 参数名 = '来源病区';
  End If;
End;
/

--82990:李南春,2015-03-12,补结算支付方式控制
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1124, 0, 0, 0, 0, 15,'补结算类别设置', Null, Null, '设置保险补充结算支持的支付方式:支付方式1|支付方式2|...'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1124 And 参数名 = '补结算类别设置');

Insert Into 结算场合 Value(编码, 名称, 简码)
Select LPad(当前编码 + 1, 长度, '0') As 编码, '补结算', 'BJS'
From  (Select  nvl(Max(to_number(编码)),0)  AS 当前编码,max(length(编码)) AS 长度 From 结算场合) 
Where Rownum < 2 And Not Exists (Select 1 From 结算场合 Where 名称 = '补结算');

--82592:冉俊明,2015-04-09,收费财务监控模块性能问题调整预交款数据处理规则，数据修正
--82934:冉俊明,2015-04-09,病人预交记录中增加"结算性质"字段，同时修正升级数据
--耗时说明:该数据修正脚本在15分钟内执行完成，测试环境如下:
--1.硬件环境
--     IBM 3650 M4,cpu E5-2620 2.1GHz,2*6核，32G内存
--     V3700存储,SAS硬盘,10K RPM,Raid 10
--2.软件环境
--     Windows 2008,Oracle 10.2.0.4 64bit
--     日志文件500M/个，Log Buffer设置为500M,PGA为9G,SGA为自动管理，最大25G
--3.数据环境
--     XX医院运行10年的数据
--     住院费用记录1亿条，门诊费用记录2千万条，预交记录1千1百万条
Declare
  --功能：修正使用预交款的记录
  --该游标用于获取使用预交款的结算记录
  Cursor c_结算数据 Is
    Select 结帐id, 操作员编号, 操作员姓名, 收款时间, 缴款组id, 结算性质
    From (With 结算记录 As (Select Distinct 结帐id
                        From 病人预交记录
                        Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(冲预交, 0) <> 0)
           Select /*+ FULL(A)*/ a.Id As 结帐id, Max(a.操作员编号) As 操作员编号, Max(a.操作员姓名) As 操作员姓名, Max(a.收费时间) As 收款时间, Max(a.缴款组id) As 缴款组id,
                  2 As 结算性质
           From 病人结帐记录 A, 结算记录 B
           Where a.Id = b.结帐id
           Group By a.Id
           Union All
           Select /*+ FULL(A)*/ a.结帐id, Max(a.操作员编号), Max(a.操作员姓名), Max(a.登记时间), Max(a.缴款组id), 5
           From 住院费用记录 A, 结算记录 B
           Where a.结帐id = b.结帐id And a.记帐费用 = 0
           Group By a.结帐id
           Union All
           Select /*+ FULL(A)*/ a.结帐id, Max(a.操作员编号), Max(a.操作员姓名), Max(a.登记时间), Max(a.缴款组id),
                  Decode(Mod(Max(记录性质), 10), 1, 3, Mod(Max(记录性质), 10))
           From 门诊费用记录 A, 结算记录 B
           Where a.结帐id = b.结帐id And a.记帐费用 = 0
           Group By a.结帐id);


  Type t_结帐id Is Table Of 病人预交记录.结帐id%Type;
  Type t_收款时间 Is Table Of 病人预交记录.收款时间%Type;
  Type t_操作员编号 Is Table Of 病人预交记录.操作员编号%Type;
  Type t_操作员姓名 Is Table Of 病人预交记录.操作员姓名%Type;
  Type t_缴款组id Is Table Of 病人预交记录.缴款组id%Type;
  Type t_结算性质 Is Table Of 病人预交记录.结算性质%Type;
  c_结帐id     t_结帐id;
  c_收款时间   t_收款时间;
  c_操作员编号 t_操作员编号;
  c_操作员姓名 t_操作员姓名;
  c_缴款组id   t_缴款组id;
  c_结算性质   t_结算性质;
  n_Array_Size Number := 10000; --每批读取一万个结帐ID,多了可能PGA不够
  I            Number(8) := 0; --每修正10万结帐ID提交一次,多了可能Undo不够,少了提交过于频繁
  J            Number(16) := 0;
  v_内容       Zlupgradeconfig.内容%Type;
Begin
  Begin
    Select 内容 Into v_内容 From Zlupgradeconfig Where 项目 = User || '_病人预交记录修正_20150409_1';
  Exception
    When Others Then
      v_内容 := Null;
  End;
  If Nvl(v_内容, 'RJM') = '成功' Then
    --数据已修正成功
    Return;
  End If;

  --为减少耗时，不备份数据
  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_病人预交记录修正_20150409_1';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_病人预交记录修正_20150409_1', Null);
  End If;

  Open c_结算数据;
  Loop
    Fetch c_结算数据 Bulk Collect
      Into c_结帐id, c_操作员编号, c_操作员姓名, c_收款时间, c_缴款组id, c_结算性质 Limit n_Array_Size;
    Exit When c_结帐id.Count = 0;
  
    --1第二次及之后使用预交款
    Forall K In 1 .. c_结帐id.Count
      Update 病人预交记录 A
      Set 收款时间 = Nvl(c_收款时间(K), 收款时间), 操作员编号 = Nvl(c_操作员编号(K), 操作员编号), 操作员姓名 = Nvl(c_操作员姓名(K), 操作员姓名),
          缴款组id = Nvl(c_缴款组id(K), 缴款组id), 结算性质 = Nvl(c_结算性质(K), 结算性质)
      Where 结帐id = c_结帐id(K) And 记录性质 = 11;
  
    --2第一次使用预交款
    ----2.1新增预交记录
    Forall K In 1 .. c_结帐id.Count
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 科室id, 缴款单位, 单位开户行, 单位帐号, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交,
         结帐id, 缴款, 找补, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 校对标志, 待转出, 结算性质)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 科室id, 缴款单位, 单位开户行, 单位帐号, 摘要, Null, 结算方式, 结算号码,
               Nvl(c_收款时间(K), 收款时间), Nvl(c_操作员编号(K), 操作员编号), Nvl(c_操作员姓名(K), 操作员姓名), 冲预交, 结帐id, 缴款, 找补,
               Nvl(c_缴款组id(K), 缴款组id), 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 校对标志, 待转出, Nvl(c_结算性质(K), 结算性质)
        From 病人预交记录
        Where 结帐id = c_结帐id(K) And 记录性质 = 1 And Nvl(冲预交, 0) <> 0;
  
    ----2.2将原预交记录的冲预交标记为0
    Forall K In 1 .. c_结帐id.Count
      Update 病人预交记录
      Set 冲预交 = 0, 结算性质 = Nvl(c_结算性质(K), 结算性质)
      Where 结帐id = c_结帐id(K) And 记录性质 = 1;
  
    J := J + c_结帐id.Count;
    If I = 10 Then
      Update Zlupgradeconfig Set 内容 = '已处理' || J || '个结帐ID' Where 项目 = User || '_病人预交记录修正_20150409_1';
      Commit;
      I := 0;
    Else
      I := I + 1;
    End If;
  End Loop;
  Update Zlupgradeconfig Set 内容 = '共处理了' || J || '个结帐ID,正在关闭游标' Where 项目 = User || '_病人预交记录修正_20150409_1';
  Commit;
  Close c_结算数据;

  Update Zlupgradeconfig Set 内容 = '成功' Where 项目 = User || '_病人预交记录修正_20150409_1';
  Commit;
End;
/

Declare
  --功能：修正结帐作废记录与预交记录操作员不一致的记录
  --该游标用于获取结帐作废记录与预交记录操作员不一致的结帐作废记录
  Cursor c_结算数据 Is
    Select ID, a.操作员编号, a.操作员姓名, a.收费时间, a.缴款组id
    From 病人结帐记录 A
    Where 记录状态 = 2 And Exists (Select 1 From 病人预交记录 Where 结帐id = a.Id And 操作员姓名 <> a.操作员姓名);

  Type t_结帐id Is Table Of 病人预交记录.结帐id%Type;
  Type t_收款时间 Is Table Of 病人预交记录.收款时间%Type;
  Type t_操作员编号 Is Table Of 病人预交记录.操作员编号%Type;
  Type t_操作员姓名 Is Table Of 病人预交记录.操作员姓名%Type;
  Type t_缴款组id Is Table Of 病人预交记录.缴款组id%Type;
  c_结帐id     t_结帐id;
  c_收款时间   t_收款时间;
  c_操作员编号 t_操作员编号;
  c_操作员姓名 t_操作员姓名;
  c_缴款组id   t_缴款组id;
  n_Array_Size Number := 10000; --每批读取一万个结帐ID,多了可能PGA不够
  I            Number(8) := 0; --每修正10万结帐ID提交一次,多了可能Undo不够,少了提交过于频繁
  v_内容       Zlupgradeconfig.内容%Type;
Begin
  Begin
    Select 内容 Into v_内容 From Zlupgradeconfig Where 项目 = User || '_病人预交记录修正_20150409_2';
  Exception
    When Others Then
      v_内容 := Null;
  End;
  If Nvl(v_内容, 'RJM') = '成功' Then
    --数据已修正成功
    Return;
  End If;

  --为减少耗时，不备份数据 

  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_病人预交记录修正_20150409_2';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_病人预交记录修正_20150409_2', Null);
  End If;

  Open c_结算数据();
  Loop
    Fetch c_结算数据 Bulk Collect
      Into c_结帐id, c_操作员编号, c_操作员姓名, c_收款时间, c_缴款组id Limit n_Array_Size;
    Exit When c_结帐id.Count = 0;
  
    --排除使用预交款记录，因为使用预交款的在前面已修正
    Forall K In 1 .. c_结帐id.Count
      Update 病人预交记录
      Set 收款时间 = Nvl(c_收款时间(K), 收款时间), 操作员编号 = Nvl(c_操作员编号(K), 操作员编号), 操作员姓名 = Nvl(c_操作员姓名(K), 操作员姓名),
          缴款组id = Nvl(c_缴款组id(K), 缴款组id)
      Where 结帐id = c_结帐id(K) And 记录性质 Not In (1, 11);
  
    If I = 10 Then
      Commit;
      I := 0;
    Else
      I := I + 1;
    End If;
  End Loop;
  Close c_结算数据;

  Update Zlupgradeconfig Set 内容 = '成功' Where 项目 = User || '_病人预交记录修正_20150409_2';
  Commit;
End;
/

Declare
  --功能：升级“结算性质”字段
  --预交款填NULL,2-结帐,3-收费,4-挂号,5-就诊卡,6-补充医保结算
  --该游标用于升级结算性质字段,记录性质为1和11的已在前面修正
  Cursor c_结算数据 Is
    Select Rowid, Mod(记录性质, 10) As 结算性质 From 病人预交记录 Where 记录性质 Not In (1, 11);

  Type t_结算性质 Is Table Of 病人预交记录.结算性质%Type;
  c_结算性质 t_结算性质;

  c_Rowid      t_Strlist := t_Strlist();
  n_Array_Size Number := 10000; --每批一万,多了可能PGA不够
  I            Number(8) := 0; --每修正10万条记录提交一次,多了可能Undo不够,少了提交过于频繁
  J            Number(16) := 0;
  v_内容       Zlupgradeconfig.内容%Type;
Begin
  Begin
    Select 内容 Into v_内容 From Zlupgradeconfig Where 项目 = User || '_病人预交记录修正_20150409_3';
  Exception
    When Others Then
      v_内容 := Null;
  End;
  If Nvl(v_内容, 'RJM') = '成功' Then
    --数据已修正成功
    Return;
  End If;

  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_病人预交记录修正_20150409_3';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_病人预交记录修正_20150409_3', Null);
  End If;

  Open c_结算数据();
  Loop
    Fetch c_结算数据 Bulk Collect
      Into c_Rowid, c_结算性质 Limit n_Array_Size;
    Exit When c_Rowid.Count = 0;
  
    Forall K In 1 .. c_Rowid.Count
      Update 病人预交记录 Set 结算性质 = c_结算性质(K) Where Rowid = c_Rowid(K);
  
    J := J + c_Rowid.Count;
    If I = 10 Then
      Update Zlupgradeconfig Set 内容 = '已处理' || J || '个结帐ID' Where 项目 = User || '_病人预交记录修正_20150409_3';
      Commit;
      I := 0;
    Else
      I := I + 1;
    End If;
  End Loop;
  Close c_结算数据;

  Update Zlupgradeconfig Set 内容 = '成功' Where 项目 = User || '_病人预交记录修正_20150409_3';
  Commit;
End;
/

--82528:马政,2015-03-05,收费价目调价审核改进
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1009, 1, 0, 0, 0, 3, '调价需要审核', '0', '0',
         '控制收费细目调价时,是否需要审核流程,0-不需要,1-需要;默认不需要审核流程，默认值是0'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1009 And 参数名 = '调价需要审核');

--82828:胡俊勇,2015-02-28,输血申请单调整
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System,1253,0,0,1,0,56,'输血申请注意事项',NULL,NULL,'输血申请单填写时下方的注意事项文字说明。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1253 And 参数名 = '输血申请注意事项');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System,1252,0,0,1,0,53,'输血申请注意事项',NULL,NULL,'输血申请单填写时下方的注意事项文字说明。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1252 And 参数名 = '输血申请注意事项');

--82701:马政,2015-02-27,定价采购调整
Update Zlparameters
Set 参数说明 = '外购是否允许修改采购价及采购金额信息'
Where 系统 = &n_System And 模块 = 1712 And 参数名 = '定价采购';

--72892:李南春,2015-02-27,自助机有效挂号时间
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 1, 0, 0, 32,'自助机有效挂号时间', Null, '', '只有在有效时间内，才允许在自助机上面挂号，为空或是开始结束时间相等表示不启用时间限制'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1802 And 参数名 = '自助机有效挂号时间');

--80178:李南春,2015-02-27,已过期挂号数不纳入剩余挂号数
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 31,'已过期挂号数不纳入剩余挂号数', Null, '0', '已过期挂号数不纳入剩余挂号数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1802 And 参数名 = '已过期挂号数不纳入剩余挂号数');

--82713:许华峰,2015-02-12,显示大图，对大图大小进行控制
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1291, 0, 1, 1, 1, 50, '大图显示范围限制', '0', '0',
           '缩略图中显示的大图太大时，是否按一定的大小进行控制'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '大图显示范围限制' And 模块 = 1291 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1291, 0, 1, 1, 1, 51, '大图显示最大分辨率', '800*600', '800*600',
           '缩略图中显示的大图太大时，按此大小计算，按原图比例显示'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '大图显示最大分辨率' And 模块 = 1291 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 1, 1, 1, 106, '大图显示范围限制', '0', '0',
           '缩略图中显示的大图太大时，是否按一定的大小进行控制'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '大图显示范围限制' And 模块 = 1291 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 1, 1, 1, 107, '大图显示最大分辨率', '800*600', '800*600',
           '缩略图中显示的大图太大时，按此大小计算，按原图比例显示'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '大图显示最大分辨率' And 模块 = 1291 And 系统 = &n_System);
    
--82343:冉俊明,2015-02-02,保险补充结算缺省模块参数的设置
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1124, 1, 0, 0, 0, 13, '使用加减切换支付方式', null, '1',
           '在进行缴款时,使用加减符号来切换支付方式'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '使用加减切换支付方式' And 模块 = 1124 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1124, 0, 0, 0, 0, 14, '药品摆药退费方式', null, '1',
           '药品摆药后的退费方式:0-不检查;1-禁止退费;2-提醒退费'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '药品摆药退费方式' And 模块 = 1124 And 系统 = &n_System);

--75744:谢荣,2015-01-30,自助取号功能
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 1, 0, 0, 28, '预约功能设置', '1|1', '1|1',
           '启用自助预约（1.启用 0.不启用）|启用自助取号(1.启用 0.不启用)'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '凭条功能设置' And 模块 = 1802 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 29, '预约功能图标', Null, '',
           '自助预约图像标识(显示图像;按下图像)||自助取号图像标识(显示图像;按下图像)'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '预约功能图标' And 模块 = 1802 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 30, '取号发票打印方式', Null, '',
           '0-不打印 1-自动打印 2-选择打印'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '取号发票打印方式' And 模块 = 1802 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 1, 0, 0, 28, '预约功能设置', '1|1', '1|1',
           '启用自助预约（1.启用 0.不启用）|启用自助取号(1.启用 0.不启用)'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '凭条功能设置' And 模块 = 1803 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 29, '预约功能图标', Null, '',
           '自助预约图像标识(显示图像;按下图像)||自助取号图像标识(显示图像;按下图像)'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '预约功能图标' And 模块 = 1803 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 30, '取号发票打印方式', Null, '',
           '0-不打印 1-自动打印 2-选择打印'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '取号发票打印方式' And 模块 = 1803 And 系统 = &n_System);

--82172:胡俊勇,2015-01-28,输血申请单修改
Insert Into zlBaseCode(系统,表名,固定,说明,分类) Values( &n_System,'输血性质',0,'用于描述输血量或血液来源等指标','医疗工作' );

Insert Into 输血性质(编码,名称,简码,缺省标志)  
select * from (Select '01','常规','CG',1 From Dual Union All
Select '02','紧急','JJ',null From Dual Union All
Select '03','大量','DL',null From Dual Union All  
Select '04','特殊供血者','TSGXZ',null From Dual Union All
Select '05','其他','QT',null From Dual) where not exists (select 1 from 输血性质 having count(1)>=1);

--81782:梁唐彬,2015-01-26,静配中心不接收的TPN医嘱也可发送到静配中心配液
Update Zlparameters
Set 参数说明 = '配置中心不接收的静脉营养医嘱在病区配置,如果启用则发送输液药品时允许置换静脉营养医嘱的药房，否则只能发送到输液配制中心去，0-不启用，1-启用'
Where 系统 = &n_System And 模块 = 1253 And 参数名 = '配置中心不接收的静脉营养医嘱在病区配置';

--81901:田林,2015-01-23,将影像执行间过滤参数放到系统参数里
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 1, 1, 0, 1, 46, '影像执行间过滤', '', '', '影像执行间过滤选择情况'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1290 And 参数名 = '影像执行间过滤');
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 1, 1, 0, 1, 49, '影像执行间过滤', '', '', '影像执行间过滤选择情况'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1291 And 参数名 = '影像执行间过滤');

--81445:马政,2015-01-14,注册证有效期检查
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1712, 0, 0, 1, 0, 19, '生产日期效期检查', '0', '0', '生产日期大于注册证效期检查'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1712 And 参数名 = '生产日期效期检查');

--81549:胡俊勇,2015-01-13,长嘱口服药发送时间限制
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System,1254,0,0,1,0,72,'长嘱口服药发送结束时间','0','0','发送长嘱口服药时是否用指定缺省值，参数格式：1|14:00:00 竖线分割，第一位表示是否启用，时间点当启用后才有效'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1254 And 参数名 = '长嘱口服药发送结束时间');

--81630:刘尔旋,2015-01-12,挂号非严格控制时发卡
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 63, '非严格控制时始终发卡', '0', '0', '0-不启用,按照正常发卡规则处理; 1-启用,非严格控制时始终为发卡'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1111 And 参数名 = '非严格控制时始终发卡');

--81600:梁唐彬,2015-01-09,参数医嘱过滤方式历史数据未删除导致进入医生站报错
Delete Zltools.Zluserparas
Where 参数id In (Select ID From Zlparameters Where 参数名 = '医嘱过滤方式' And 系统 = &n_System And 模块 = 1253);

--80448:张险华,2015-01-05,共享病历连续预览
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1251, 0, 0, 1, 1, 5, '共享病历连读预览', -1, '-1', '-1表示共享病历全部读取 0表示仅读当前选中病历 >0表示读取选中病历前后N天内的共享病历'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1251 And 参数名 = '共享病历连读预览');

--82158:李业庆,2015-01-26,TPN处置方式
delete from zlparameters where 系统= &n_System and 模块=1345 and 参数号=22;

Update zlParameters
Set 模块 = 1345, 参数号 = 22
Where 系统 = &n_System And 模块 = 1253 And 参数名 = '配置中心不接收的静脉营养医嘱在病区配置';

Update zlParameters
Set 模块 = 1345, 参数号 = 23
Where 系统 = &n_System And 模块 = 1253 And 参数名 = '特殊性质药品允许发送到配制中心';

--81829:李业庆,2015-02-04,病人实际取药确认模式
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 0, 1, 1, 52,'启用病人实际取药确认模式', Null, '0', '是否启用病人实际取药确认模式：0-不启用，1-启用'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1341 And 参数名 = '启用病人实际取药确认模式');

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--82620:刘兴洪,2015-03-11,收费轧帐按收费类别轧帐
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1506, '基本', User, 'Zl_Rollingcurtain_Lastdate', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1506 And 功能 = '基本' And Upper(对象) = Upper('Zl_Rollingcurtain_Lastdate'));

--82736:张德婷,2015-03-06,输液配置中心增加审核原因
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, 'Zl_病人医嘱记录_SaveReason', 'EXECUTE'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1345 And 功能 = '基本' And 对象 = 'Zl_病人医嘱记录_SaveReason');

--82528:马政,2015-03-05,收费价目调价审核改进
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1009,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '收费价目调价审核',14,'有权限时收费项目管理中可以审核调价单。',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1009, '基本', User, '收费调价记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1009 And 功能 = '基本' And Upper(对象) = Upper('收费调价记录'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1009, '价目管理', User, 'Zl_收费调价记录_Insert', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1009 And 功能 = '价目管理' And Upper(对象) = Upper('Zl_收费调价记录_Insert'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1009, '价目管理', User, 'Zl_收费调价记录_Verify', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1009 And 功能 = '价目管理' And Upper(对象) = Upper('Zl_收费调价记录_Verify'));  

--82181:许华峰,2015-02-28,更新影像报告的报告人
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像报告保存_更新报告人', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像报告保存_更新报告人'));
		 
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'ZL_影像报告保存_更新报告人', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像报告保存_更新报告人'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'ZL_影像报告保存_更新报告人', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像报告保存_更新报告人'));

--82420:张险华,2015-02-03,终末质控增加所有科室权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
  Select &n_System, 2221, '所有科室', 3, '允许选择所有科室',1 From Dual
  Where Not Exists (Select 1
         From zlProgFuncs
         Where 系统 = &n_System And 序号 = 2221 And 功能 = '所有科室');

--82363:张险华,2015-02-03,智能病历检索功能中增加打印权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
  Select &n_System, 2210, '打印', 1, '对文档进行打印操作',0 From Dual
  Where Not Exists (Select 1
         From zlProgFuncs
         Where 系统 = &n_System And 序号 = 2210 And 功能 = '打印');

--82311:胡俊勇,2015-02-02,输血申请单指示显示
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'医嘱下达',User,'Zl_Fun_Bloodapplyrate','EXECUTE' From Dual;

--75744:谢荣,2015-01-30,自助取号功能
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1803,'基本',USER,'凭条打印记录','SELECT');

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1803,'基本',USER,'Zl_凭条打印记录_Update','EXECUTE');

--82172:胡俊勇,2015-01-28,输血申请单修改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1252,'基本',User,'输血性质','SELECT');

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1253,'基本',User,'输血性质','SELECT');

--81857:冉俊明,2015-01-19,删除不用的功能权限（记录修改）
Delete zlProgFuncs Where 系统 = &n_System And 序号 = 1121 And 功能 = '记录修改';

--80940:刘尔旋,2015-01-14,费用接口新增挂号接口
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '挂号安排计划','SELECT' From Dual Union All 
Select '挂号安排','SELECT' From Dual Union All 
Select '挂号计划时段','SELECT' From Dual Union All 
Select '挂号安排时段','SELECT' From Dual Union All 
Select '费用补充记录','SELECT' From Dual Union All 
Select '合作单位计划控制','SELECT' From Dual Union All 
Select '合作单位安排控制','SELECT' From Dual Union All 
Select '挂号序号状态','SELECT' From Dual Union All 
Select 'zl_挂号序号状态_Lock','EXECUTE' From Dual Union All 
Select 'zl_病人挂号记录_Delete','EXECUTE' From Dual Union All 
Select 'zl_预约挂号接收_Insert','EXECUTE' From Dual Union All 
Select 'zl_病人挂号汇总_Update','EXECUTE' From Dual Union All 
Select 'zl_三方机构挂号_Insert','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--81829:李业庆,2015-02-04,病人实际取药确认模式
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1341,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '取药确认',29,'有该权限时，可以在退药业务时对未进行取药的处方进行取药确认操作。',1 From Dual Union All
Select 功能,排列,说明,缺省值 From ZLPROGFUNCS Where 1 = 0) A;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1341, '退药', User, 'Zl_药品收发记录_确认取药', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1341 And 功能 = '退药' And Upper(对象) = Upper('Zl_药品收发记录_确认取药'));

--82528:马政,2015-03-05,收费价目调价审核改进
Insert Into zlRoleGrant(系统, 序号, 角色, 功能)
Select 系统, 序号, 角色, '收费价目调价审核' From zlRoleGrant Where 系统 = &n_System And 序号 = 1009 And 功能 = '价目管理';

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--83794:马政,2015-04-07,卫材数量金额差价为零时调价
Create Or Replace Procedure Zl_材料收发记录_Adjust
(
  调价id_In   In Number, --调价记录的ID 
  定价_In     In Number := 0, --是否转为定价销售（更新材料特性、收费细目中的变价） 
  材料id_In   In Number := 0, --当不为0时表示是成本价调价，不处理售价相关内容 
  Billinfo_In In Varchar2 := Null --用于时价卫材按批次调价。格式:"批次1,现价1|批次2,现价2|....."
) As
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别 
  n_调价单据号 药品收发记录.Id%Type; --调价单号 
  d_生效日期   Date; --调价生效时间 
  n_执行调价   Number(1); --调价时刻到了 
  n_实价材料   Number(1); --时价药品 
  n_收费细目id Number(18); --收费细目ID 
  d_审核日期   药品收发记录.审核日期%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_序号       Integer(8);
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_时价分批   Number(1);

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, n_调价单据号 NO, Rownum 序号, n_入出类别id 入出类别id, m.材料id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, q.产地, s.上次产地) 产地, 1 付数, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率,
           Nvl(s.零售价, 0) As 库存零售价, s.实际金额 As 库存金额, s.实际差价 As 库存差价, '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id,
           1 入出系数, a.Id 价格id, s.上次生产日期, s.灭菌效期, s.批准文号, s.上次供应商id
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 Q
    Where s.药品id = m.材料id And m.材料id = q.Id And m.材料id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate;

  Cursor c_时价按批次调价 --时价卫材按批次调价
  Is
    Select 1 记录状态, 13 单据, n_调价单据号 NO, n_序号 + Rownum 序号, n_入出类别id 入出类别id, s.药品id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, b.产地, s.上次产地) 产地, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价, s.实际金额 As 库存金额,
           s.实际差价 As 库存差价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = m.材料id And m.材料id = a.收费细目id And a.收费细目id = b.Id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;
Begin

  If 材料id_In <> 0 Then
    --成本价调价 
    Zl_材料收发记录_成本价调价(材料id_In);
    Return;
  End If;

  --取入出类别ID 
  Select 类别id Into n_入出类别id From 药品单据性质 Where 单据 = 13;

  --取序列 
  Select 药品收发记录_Id.Nextval Into n_调价单据号 From Dual;
  --取调价记录生效日期 
  Select 收费细目id, 执行日期 Into n_收费细目id, d_生效日期 From 收费价目 Where ID = 调价id_In;
  --取该材料是否是时价药品 
  Select Nvl(是否变价, 0) Into n_实价材料 From 收费项目目录 Where ID = n_收费细目id;

  If Sysdate >= d_生效日期 Then
    n_执行调价 := 1;
  Else
    n_执行调价 := 0;
  End If;

  If n_执行调价 = 1 Then
    d_审核日期 := Sysdate;
    --普通调价处理
    If Billinfo_In = '' Or Billinfo_In Is Null Then
      --非时价药品调价 
      For c_调价 In c_Price Loop
        If Nvl(c_调价.填写数量, 0) = 0 And Nvl(c_调价.库存金额, 0) = 0 And Nvl(c_调价.库存差价, 0) = 0 Then
          Null;
        Elsif Nvl(c_调价.填写数量, 0) = 0 And (Nvl(c_调价.库存金额, 0) <> 0 Or Nvl(c_调价.库存差价, 0) <> 0) Then
          --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据 
          --产生调价影响记录 
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
             库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, c_调价.成本价, c_调价.成本金额, c_调价.零售价, c_调价.扣率, c_调价.摘要, c_调价.填制人,
             c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期, c_调价.批准文号, c_调价.上次供应商id,
             c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存 ，只有时价卫材才更新零售价
          Update 药品库存
          Set 零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        Else
          If n_实价材料 = 1 Then
            If c_调价.库存零售价 = 0 Then
              n_零售价 := c_调价.库存金额 / c_调价.填写数量;
            Else
              n_零售价 := c_调价.库存零售价;
            End If;
          Else
            n_零售价 := c_调价.成本价;
          End If;
          n_零售金额 := Round((c_调价.零售价 - n_零售价) * c_调价.填写数量, 2);
        
          --产生调价影响记录 
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, c_调价.成本价, c_调价.成本金额, c_调价.零售价, c_调价.扣率, n_零售金额, n_零售金额, c_调价.摘要,
             c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期, c_调价.批准文号,
             c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存 
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
              零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
            Values
              (c_调价.库房id, c_调价.药品id, c_调价.批次, 1, 0, 0, n_零售金额, n_零售金额, c_调价.效期, c_调价. 灭菌效期, c_调价.上次供应商id, c_调价.成本价,
               c_调价.批号, c_调价.上次生产日期, c_调价.产地, c_调价.批准文号,
               Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null));
          End If;
        End If;
      End Loop;
    Else
      --时价分批调价处理
      n_序号 := 0;
      --时价药品按批次调价
      v_Infotmp := Billinfo_In || '|';
      While v_Infotmp Is Not Null Loop
        --分解单据ID串
        v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
        n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
        n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
        v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
      
        For v_时价按批次调价 In c_时价按批次调价 Loop
          If v_时价按批次调价.填写数量 <> 0 Then
            n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
          Else
            n_原价 := v_时价按批次调价.成本价;
          End If;
        
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          If Nvl(v_时价按批次调价.填写数量, 0) = 0 And Nvl(v_时价按批次调价.库存金额, 0) = 0 And Nvl(v_时价按批次调价.库存差价, 0) = 0 Then
            Null;
          Elsif Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
            --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据

            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
               库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期,
               v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            --更新库存零售价,只有时价分批药品才能更新零售价字段    
            Update 药品库存
            Set 零售价 = Decode(v_时价按批次调价.时价, 1, Decode(Nvl(v_时价按批次调价.批次, 0), 0, Null, v_时价按批次调价.零售价), Null)
            Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(v_时价按批次调价.批次, 0);
          Else
            n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
            n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
               填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人,
               v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期, v_时价按批次调价.库存金额,
               v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            If v_时价按批次调价.时价 = 1 And Nvl(v_时价按批次调价.批次, 0) > 0 Then
              n_时价分批 := 1;
            Else
              n_时价分批 := 0;
            End If;
          
            If Nvl(v_时价按批次调价.批次, 0) = 0 Then
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And (批次 Is Null Or 批次 = 0);
            Else
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
                  零售价 = Decode(n_时价分批, 1, v_时价按批次调价.零售价, 零售价)
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And 批次 = v_时价按批次调价.批次;
            End If;
          
            If Sql%RowCount = 0 Then
              Insert Into 药品库存
                (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
              Values
                (v_时价按批次调价.库房id, v_时价按批次调价.药品id, v_时价按批次调价.批次, 1, 0, 0, n_零售金额, n_零售金额,
                 Decode(n_时价分批, 1, v_时价按批次调价.零售价, Null));
            End If;
          End If;
        End Loop;
      End Loop;
    End If;
  
    Update 药品收发记录 Set 审核人 = User, 审核日期 = Sysdate Where 价格id = 调价id_In;
    Update 收费价目 Set 变动原因 = 1 Where ID = 调价id_In;
  
    --更新药品目录、收费细目中的变价 
    If 定价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 0 Where ID = n_收费细目id;
    End If;
    --成本价调价 
    Zl_材料收发记录_成本价调价(n_收费细目id);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_Adjust;
/

--83794:马政,2015-04-07,卫材数量金额差价为零时调价
Create Or Replace Procedure Zl_材料收发记录_成本价调价(材料id_In In 药品收发记录.药品id%Type) As
  v_No         药品收发记录.No%Type;
  v_应付id     应付记录.Id%Type; --应付记录的ID 
  v_应付单据号 应付记录.No%Type;
  d_调价时间   Date;
  n_序号       Number(8);
  n_库房id     药品收发记录.库房id%Type;
  n_入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数   药品收发记录.入出系数%Type;
  n_收发id     药品收发记录.Id%Type;
  n_调整额     药品收发记录.零售金额%Type;
  n_原成本价   药品收发记录.成本价%Type;
  n_新成本价   药品收发记录.成本价%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  v_调价id     成本价调价信息.Id%Type;
  v_调价汇总号 成本价调价信息.调价汇总号%Type;
  n_Count      Number(1) := 0;

  Cursor c_Stock Is --当前库存 
    Select 上次供应商id, a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) As 批次, a.上次批号, a.效期, a.上次产地, a.灭菌效期,
           Decode(Sign(Nvl(a.批次, 0)), 1, a.上次采购价, (a.实际金额 - a.实际差价) / a.实际数量) As 原成本价
    From 药品库存 A
    Where a.性质 = 1 And Nvl(a.实际数量, 0) <> 0 And a.药品id = 材料id_In
    Order By a.库房id;

  v_Stock c_Stock%RowType;
Begin
  d_调价时间 := Sysdate;
  n_库房id   := 0;

  --判断是否存在无库存调价 
  Begin
    Select ID, 新成本价, 调价汇总号
    Into v_调价id, n_新成本价, v_调价汇总号
    From 成本价调价信息
    Where 执行日期 Is Null And Nvl(库房id, 0) = 0 And 药品id = 材料id_In;
  Exception
    When Others Then
      v_调价id   := 0;
      n_新成本价 := Null;
  End;

  --无库存调价 
  If v_调价id > 0 Then
    --根据当前库存重新产生调价信息 
    For v_Stock In c_Stock Loop
      Zl_材料成本调价_Insert(v_Stock.上次供应商id, v_Stock.库房id, v_Stock.材料id, v_Stock.批次, v_Stock.上次批号, v_Stock.原成本价, n_新成本价,
                       Null, Null, 0, 0, v_调价汇总号);
      n_Count := n_Count + 1;
    End Loop;
  
    If n_Count > 0 Then
      --如果当前有库存记录，则删除无库存调价记录 
      Delete 成本价调价信息 Where ID = v_调价id;
    Else
      Update 成本价调价信息 Set 执行日期 = d_调价时间 Where ID = v_调价id;
    
      Update 材料特性 Set 成本价 = n_新成本价 Where 材料id = 材料id_In And 成本价 <> n_新成本价;
    End If;
  End If;

  --取库存差价调整的入出类别ID 
  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 33 And Rownum < 2;

  For c_成本调整 In (Select a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) 批次, a.上次供应商id, a.实际数量, a.实际金额, a.实际差价, a.上次产地 As 产地,
                        a.上次批号 As 批号, a.灭菌效期, a.效期, a.上次生产日期 As 生产日期, a.批准文号, b.原成本价, b.新成本价, b.发票号, b.发票日期, b.发票金额,
                        Nvl(a.上次采购价, 0) As 上次采购价, b.Id As 调价id
                 From 药品库存 A, 成本价调价信息 B
                 Where a.药品id = b.药品id And Nvl(a.上次供应商id, 0) = Nvl(b.供药单位id, 0) And a.库房id = b.库房id And
                       Nvl(a.批次, 0) = Nvl(b.批次, 0) And a.性质 = 1 And b.执行日期 Is Null And a.药品id = 材料id_In
                 Order By a.库房id) Loop
    If n_库房id <> c_成本调整.库房id Then
      n_序号   := 1;
      n_库房id := c_成本调整.库房id;
      v_No     := Nextno(71, n_库房id);
    Else
      n_序号 := n_序号 + 1;
    End If;
  
    Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
  
    If Nvl(c_成本调整.实际数量, 0) = 0 And Nvl(c_成本调整.实际金额, 0) = 0 And Nvl(c_成本调整.实际差价, 0) = 0 Then
      --数量,金额、差价都为0，则表示数据是填单下可用数量出库产生的单据，此单据还没有审核，因此只需要更新调价信息，其他不更新
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Elsif Nvl(c_成本调整.实际数量, 0) = 0 And (Nvl(c_成本调整.实际金额, 0) <> 0 Or Nvl(c_成本调整.实际差价, 0) <> 0) Then
      --数量=0 金额或差价<>0时只更新库存表中对应的平均成本价和特性表中成本价，并产生成本价修正数据但是差价差=0，只记录最新成本价
      --产生调价记录，只记录最新成本价
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, 0, c_成本调整.实际金额, c_成本调整.实际差价, 0, '卫生材料成本价调价', Zl_Username, d_调价时间, Zl_Username, d_调价时间,
         c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, c_成本调整.原成本价);
      --更新库存      
      Update 药品库存
      Set 平均成本价 = c_成本调整.新成本价, 上次采购价 = c_成本调整.新成本价
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = c_成本调整.批次 And 性质 = 1;
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Else
      --调整相应的库存:原成本金额-实新成本金额 
      n_调整额   := (c_成本调整.实际金额 - c_成本调整.实际差价) - Round(c_成本调整.新成本价 * c_成本调整.实际数量, 2);
      n_原成本价 := (c_成本调整.实际金额 - c_成本调整.实际差价) / c_成本调整.实际数量;
    
      If n_原成本价 <= 0 Then
        n_原成本价 := c_成本调整.上次采购价;
      End If;
    
      --目前：收发记录对应: 
      -- 扣率--> 原成本价 
      -- 单量-->新成本价 
      -- 填写数量-->库存实际数量 
      -- 零售价-->库存实际金额 
      -- 成本价-->库存实际差价 
      -- 差价-->本次调整额 
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, c_成本调整.实际数量, c_成本调整.实际金额, c_成本调整.实际差价, n_调整额, '卫生材料成本价调价', Zl_Username, d_调价时间,
         Zl_Username, d_调价时间, c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, n_原成本价);
    
      --更新库存 
      Update 药品库存
      Set 实际差价 = Nvl(实际差价, 0) + n_调整额
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 灭菌效期)
        Values
          (c_成本调整.库房id, c_成本调整.材料id, c_成本调整.批次, 1, n_调整额, c_成本调整.批号, c_成本调整.效期, c_成本调整.产地, c_成本调整.上次供应商id, c_成本调整.生产日期,
           c_成本调整.批准文号, c_成本调整.灭菌效期);
      End If;
    
      Update 药品库存
      Set 上次采购价 = c_成本调整.新成本价
      Where 药品id = c_成本调整.材料id And 上次采购价 <> c_成本调整.新成本价;
    
      Update 材料特性
      Set 成本价 = c_成本调整.新成本价
      Where 材料id = c_成本调整.材料id And 成本价 <> c_成本调整.新成本价;
    
      --重新计算库存表中的平均成本价 
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 库房id = c_成本调整.库房id And 性质 = 1 And
            Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_成本调整.材料id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 药品id = c_成本调整.材料id And 库房id = c_成本调整.库房id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
      End If;
    
      --更新成本价调价信息 
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 原成本价 = n_原成本价, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地,
          批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    End If;
  End Loop;

  --产生应付记录 
  For c_应付 In (Select Distinct a.供药单位id, a.药品id, a.发票号, a.发票日期, a.发票金额, b.名称, b.计算单位, b.规格
               From 成本价调价信息 A, 收费项目目录 B
               Where a.药品id = b.Id And Nvl(a.应付款变动, 0) = 1 And Nvl(a.供药单位id, 0) <> 0 And a.药品id = 材料id_In
               Order By a.供药单位id) Loop
  
    v_应付单据号 := Nextno(67);
  
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 发票号, 发票日期, 发票金额, 品名, 规格, 填制人, 填制日期, 审核人, 审核日期, 摘要)
    Values
      (v_应付id, 1, 1, c_应付.供药单位id, v_应付单据号, 5, c_应付.发票号, c_应付.发票日期, c_应付.发票金额, c_应付.名称, c_应付.规格, Zl_Username, d_调价时间,
       Zl_Username, d_调价时间, '成本价调价自动产生应付款变动记录');
  
    If Nvl(c_应付.供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(c_应付.发票金额, 0) Where 单位id = c_应付.供药单位id And 性质 = 1;
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (c_应付.供药单位id, 1, Nvl(c_应付.发票金额, 0));
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_成本价调价;
/

--83328:刘尔旋,2015-03-27,新增安排时默认禁用合作单位
Create Or Replace Procedure Zl_挂号安排_Insert
(
  Id_In           挂号安排.Id%Type,
  号码_In         挂号安排.号码%Type,
  号类_In         挂号安排.号类%Type,
  科室id_In       挂号安排.科室id%Type,
  项目id_In       挂号安排.项目id%Type,
  医生_In         挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病案必须_In     挂号安排.病案必须%Type,
  周日_In         挂号安排.周日%Type,
  周一_In         挂号安排.周一%Type,
  周二_In         挂号安排.周二%Type,
  周三_In         挂号安排.周三%Type,
  周四_In         挂号安排.周四%Type,
  周五_In         挂号安排.周五%Type,
  周六_In         挂号安排.周六%Type,
  限号控制_In     Varchar2,
  分诊方式_In     挂号安排.分诊方式%Type,
  诊室_In         Varchar2,
  开始时间_In     挂号安排.开始时间%Type,
  终止时间_In     挂号安排.终止时间%Type,
  新增_In         Number,
  序号控制_In     挂号安排.序号控制%Type,
  处理类型_In     Number := 0,
  默认时间间隔_In 挂号安排.默认时段间隔%Type := 0
) As
  -----------------------------------------------------------
  --参数：
  --  诊室_IN=以';'号分隔的多个诊室名称
  --  限号控制_IN:|周一,22(限号),13(限约)|周二,20(限号),11(限约)....
  --  处理类型_IN:修改安排时 对时段数据的处理 0--不处理 1--删除时段信息
  --  默认时间间隔_In:为安排设置时段时默认的时间段间隔
  -----------------------------------------------------------
  v_诊室  Varchar2(1000);
  n_Count Number(18);
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_序号       Number(18);
  v_操作员姓名 挂号安排计划.审核人%Type;
  n_限号数     挂号安排限制.限号数%Type;
  n_限约数     挂号安排限制.限约数%Type;
  v_限制项目   挂号安排限制.限制项目%Type;
  v_限制控制   Varchar2(4000);
  v_当前项目   Varchar2(4000);

Begin
  Begin
    If Nvl(医生id_In, 0) <> 0 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生id = 医生id_In And ID + 0 <> Id_In;
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生姓名 = 医生_In And Nvl(医生id, 0) = 0 And ID + 0 <> Id_In;
    End If;
  Exception
    When Others Then
      n_序号 := 1;
  End;

  If 新增_In = 1 Then
    --新增挂号安排
    Begin
      Select b.姓名 Into v_操作员姓名 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
    Exception
      When Others Then
        Null;
    End;
    Insert Into 挂号安排
      (ID, 号码, 号类, 科室id, 项目id, 医生姓名, 医生id, 序号, 病案必须, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 开始时间, 终止时间, 序号控制, 默认时段间隔)
    Values
      (Id_In, 号码_In, 号类_In, 科室id_In, 项目id_In, 医生_In, Decode(医生id_In, 0, Null, 医生id_In), n_序号, 病案必须_In, 周日_In, 周一_In,
       周二_In, 周三_In, 周四_In, 周五_In, 周六_In, 分诊方式_In, 开始时间_In, 终止时间_In, 序号控制_In, 默认时间间隔_In);
    For r_合作单位 In (Select 名称 From 挂号合作单位) Loop
      Insert Into 合作单位安排控制
        (合作单位, 安排id, 限制项目, 序号, 数量)
        Select r_合作单位.名称, Id_In, '周日', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周一', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周二', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周三', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周四', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周五', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周六', 0, 0 From Dual;
    End Loop;
  
  Else
    --修改指定ID的挂号安排
    --1.先检查是否存在计划,存在计划，不能更改
    Begin
      Select Count(*) Into n_Count From 挂号安排计划 Where 安排id = Id_In;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]该安排已经制定了相关的计划,,不能再修改![ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(处理类型_In, 0) = 1 Then
      Delete 挂号安排时段 Where 安排id = Id_In;
    Else
      --针对存在时段这种情况需要先处理排班修改后的时段 在后再修改安排
      Delete 挂号安排时段
      Where 安排id = Id_In And 星期 In (Select 星期
                                    From (Select Case 周一
                                                     When 周一_In Then
                                                      Null
                                                     Else
                                                      '周一'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周二
                                                     When 周二_In Then
                                                      Null
                                                     Else
                                                      '周二'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周三
                                                     When 周三_In Then
                                                      Null
                                                     Else
                                                      '周三'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周四
                                                     When 周四_In Then
                                                      Null
                                                     Else
                                                      '周四'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周五
                                                     When 周五_In Then
                                                      Null
                                                     Else
                                                      '周五'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周六
                                                     When 周六_In Then
                                                      Null
                                                     Else
                                                      '周六'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周日
                                                     When 周日_In Then
                                                      Null
                                                     Else
                                                      '周日'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In) A
                                    Where a.星期 Is Not Null);
    End If;
  
    Update 挂号安排
    Set 号码 = 号码_In, 号类 = 号类_In, 科室id = 科室id_In, 项目id = 项目id_In, 医生姓名 = 医生_In, 医生id = Decode(医生id_In, 0, Null, 医生id_In),
        序号 = n_序号, 病案必须 = 病案必须_In, 周日 = 周日_In, 周一 = 周一_In, 周二 = 周二_In, 周三 = 周三_In, 周四 = 周四_In, 周五 = 周五_In, 周六 = 周六_In,
        开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 分诊方式 = 分诊方式_In, 序号控制 = 序号控制_In,
        默认时段间隔 = Decode(Nvl(默认时间间隔_In, 0), 0, 默认时段间隔, 默认时间间隔_In)
    Where ID = Id_In;
  
    Delete 挂号安排限制 Where 安排id = Id_In;
  End If;

  v_限制控制 := 限号控制_In || '|';
  While v_限制控制 Is Not Null Loop
    v_当前项目 := Substr(v_限制控制, 1, Instr(v_限制控制, '|') - 1);
    v_限制项目 := Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1);
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_限号数   := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    n_限约数   := To_Number(Substr(v_当前项目, Instr(v_当前项目, ',') + 1));
    If Nvl(n_限号数, 0) <> 0 Then
      Insert Into 挂号安排限制
        (安排id, 限制项目, 限号数, 限约数)
      Values
        (Id_In, v_限制项目, Decode(n_限号数, 0, Null, n_限号数), Decode(n_限约数, 0, Null, n_限约数));
    End If;
    v_限制控制 := Substr(v_限制控制, Instr(v_限制控制, '|') + 1);
  End Loop;

  If 新增_In = 0 Then
  
    --挂号安排诊室处理
    Delete From 挂号安排诊室 Where 号表id = Id_In;
  End If;

  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ';';
    While v_诊室 Is Not Null Loop
      Insert Into 挂号安排诊室 (号表id, 门诊诊室) Values (Id_In, Substr(v_诊室, 1, Instr(v_诊室, ';') - 1));
      v_诊室 := Substr(v_诊室, Instr(v_诊室, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Insert;
/

--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
Create Or Replace Procedure Zl_病人变动记录_Nurse
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  护理id_In     病人变动记录.护理等级id%Type,
  生效时间_In   病人变动记录.开始时间%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：更改病人护理等级
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
        Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间) From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In)) A, 病人变动记录 B

    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 生效时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo c_Oldinfo%RowType;
  r_Endinfo c_Endinfo%RowType;

  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Count   Number;
  v_Date Date;
  v_Error   Varchar2(255);
  Err_Custom Exception;
Begin
  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%RowCount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  Select Count(*) Into v_count From 病人变动记录 Where 病人ID=病人ID_in And 主页ID=主页id_In And 开始时间 Is null And 终止时间 Is Null;
  If v_count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id = 护理id_In;
  If v_Count > 0 Then
    v_Error := '操作失败,当前该病人的护理等级和即将调整的护理等级相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
 
  For r_Fee In (Select No
                From 住院费用记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= 生效时间_In And 收费类别 = 'H'
                Group By NO, 序号, Mod(记录性质, 10)
                Having Sum(结帐金额) <> 0) Loop
    v_Error := '变动时间之后已有已结帐的自动记帐费用,不能更改护理等级！';
    Raise Err_Custom;
  End Loop;

  --取消上次变动
  If r_Oldinfo.终止时间 Is not NULL then
    --如果将来已经有了护理记录变动，则不允许再产生护理变动。需要回退将来的变动的解决。
    Select Max(开始时间) Into v_Date From 病人变动记录 Where 病人ID=病人ID_in And 主页ID=主页id_In And 开始时间>生效时间_In And 开始原因=6;
    If v_Date Is Not Null Then
      v_Error := '本次护理等级变动时间必须大于最后一次护理等级变动的生效时间:' || To_char(v_Date,'yyyy-mm-dd hh24:mi:ss') || '。';
      Raise Err_Custom;
    End If;
    v_终止时间:=r_Oldinfo.终止时间;
    v_终止原因:=r_Oldinfo.终止原因;
    v_终止人员:=r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 6, 终止人员 = 操作员姓名_In ,上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因=v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录 Set 护理等级id=护理id_In,上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间>生效时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 6, 终止人员 = 操作员姓名_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;
  --产生新变动
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,终止时间,终止原因,终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 6, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id, r_Oldinfo.医疗小组id, 护理id_In,
       r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情,
       操作员编号_In, 操作员姓名_In,v_终止时间,v_终止原因,v_终止人员);
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;

  Update 病案主页 Set 护理等级id = 护理id_In Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_Nurse;
/

--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
Create Or Replace Procedure Zl_病人变动记录_Changeunit
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转入病区id_In 病人变动记录.病区id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：病人转病区登记
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select 科室id From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;

  r_Oldinfo c_Oldinfo%Rowtype;
  v_Count   Number;
  v_年龄    病人信息.年龄%Type;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Open c_Oldinfo; --必须先打开
  --首先判断该病人是否处于等待转病区或入病区状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转病区状态或尚未入病区,不能转病区。';
    Raise Err_Custom;
  End If;

  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 当前病区id = 转入病区id_In;
  If v_Count > 0 Then
    v_Error := '操作失败,当前该病人所在的病区和即将转入的病区相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --产生新变动
  Fetch c_Oldinfo
    Into r_Oldinfo;

  If c_Oldinfo%Rowcount = 0 Then
    Close c_Oldinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --不填写开始时间和终止时间
  Insert Into 病人变动记录
    (Id, 病人id, 主页id, 开始时间, 开始原因, 病区id, 科室id, 操作员编号, 操作员姓名)
  Values
    (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, Null, 15, 转入病区id_In, r_Oldinfo.科室id, 操作员编号_In, 操作员姓名_In);

  Update 病案主页 Set 状态 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Changeunit;
/

--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
Create Or Replace Procedure Zl_病人变动记录_Change
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转入科室id_In 病人变动记录.科室id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：病人转科登记
  -----------------------------------------------------------
  v_Count  Number;
  v_科室id 病人临床路径.科室id%Type;
  v_年龄   病人信息.年龄%Type;
  v_姓名   病人信息.姓名%Type;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能转科。';
    Raise Err_Custom;
  End If;

  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院科室id = 转入科室id_In;
  If v_Count > 0 Then
    v_Error := '操作失败,当前该病人所在的科室和即将转入的科室相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --一次住院只有一个路径，临床路径正在执行时不允许转科(除非是从ICU转出或转入)
  Select Nvl(Max(科室id), 0)
  Into v_科室id
  From 病人临床路径 a
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.状态 = 1;
  If v_科室id <> 0 Then
    Select Count(*)
    Into v_Count
    From 部门性质说明 c
    Where (c.部门id = v_科室id Or c.部门id = 转入科室id_In) And c.工作性质 = 'ICU';
    If v_Count = 0 Then
      v_Error := '该病人的临床路径正在执行中,不能转科。';
      Raise Err_Custom;
    End If;
  End If;

  --检查未校对的医嘱，或已校对但未发送的临嘱
  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And Nvl(婴儿, 0) = 0 And
          Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --修改病人临床路径表中的科室ID
  Update 病人临床路径 Set 科室id = 转入科室id_In Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;

  --不填写开始时间和终止时间
  Insert Into 病人变动记录
    (Id, 病人id, 主页id, 开始时间, 开始原因, 病区id, 科室id, 操作员编号, 操作员姓名)
  Values
    (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, Null, 3, Null, 转入科室id_In, 操作员编号_In, 操作员姓名_In);

  Update 病案主页 Set 状态 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Change;
/

--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
Create Or Replace Procedure Zl_病人变动记录_Inunit
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       Varchar2,
  病区id_In     病案主页.当前病区id%Type,
  护理等级id_In 病案主页.护理等级id%Type,
  当前病况_In   病案主页.当前病况%Type,
  是否陪伴_In   病案主页.是否陪伴%Type,
  责任护士_In   病案主页.责任护士%Type,
  入病区时间_In 病人变动记录.开始时间%Type,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  主床位_In     病案主页.出院病床%Type
) As
  -----------------------------------------------------------
  --说明：完成病人入病区处理
  --参数：
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In;
  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入病区时间_In;

  r_Futureinfo   c_Futureinfo %Rowtype;
  b_Isdel        Boolean;
  r_Endinfo      c_Endinfo%Rowtype;
  r_Oldinfo      c_Oldinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;
  v_床号     Varchar2(255);
  v_当前床号 床位状况记录.床号%Type;
  v_等级id   床位状况记录.等级id%Type;
  v_病区id   病案主页.当前病区id%Type;
  v_科室id   病案主页.出院科室id%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Count    Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Open c_Oldinfo; --必须先打开

  --入病区
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;

  If v_Count = 0 Then
    v_Error := '病人当前不处于转病区状态,可能已经撤转病区，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Begin
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;
  Exception
    When Others Then
      v_病区id := 0;
  End;
  --v_病区id=0说明病人可能是转科状态
  If v_病区id = 0 Then
    v_Error := '病人当前不处于转病区状态，而是处于转科状态，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If v_病区id <> 病区id_In Then
    v_Error := '当前该病人即将入住的病区和变动记录中实际要入住病区不符,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  --产生新变动
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In,
      护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In, 责任护士 = 责任护士_In, 是否陪伴 = 是否陪伴_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In)
  Where 病人id = 病人id_In;

  --更新在院病人
  v_科室id := 0;
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0) Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Select 出院科室id Into v_科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
  Exception
    When Others Then
      v_科室id := 0;
  End;
  If v_科室id > 0 Then
    Insert Into 在院病人 (病人id, 科室id, 病区id) Values (病人id_In, v_科室id, Nvl(病区id_In, 0));
  End If;

  --退除病人当前床位
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --记录上一步的终止操作人员
  If r_Oldinfo.终止时间 Is Not Null Then
    v_变动终止时间 := r_Oldinfo.终止时间;
    v_变动终止原因 := r_Oldinfo.终止原因;
    v_变动终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
  End If;

  Delete From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;

  --新的床位记录
  If 床号_In Is Null Then
    --仅家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师,
       当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
      b_Isdel := True;
    End If;
  
    v_Count := 0;
    v_床号  := 床号_In || ',';
  
    While v_床号 Is Not Null Loop
      v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_当前床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_当前床号
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 科室id, 医疗小组id, 床位等级id, 床号, 经治医师, 主治医师, 主任医师, 操作员编号, 操作员姓名, 终止时间, 终止原因,
               终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               r_Futureinfo.科室id, r_Futureinfo.医疗小组id, v_等级id, v_当前床号, r_Futureinfo.经治医师, r_Futureinfo.主治医师,
               r_Futureinfo.主任医师, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
               r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
    
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      v_Count := v_Count + 1;
    End Loop;
  End If;
  --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
  Update 病人变动记录
  Set 病区id = 病区id_In, 责任护士 = 责任护士_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 当前病况_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Close c_Oldinfo;
  Close c_Endinfo;
  --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
  Update 病人医嘱记录
  Set 执行科室id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Oldinfo.病区id And 医嘱状态 Not In (4, 8, 9);
  --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
  Update 住院费用记录
  Set 执行部门id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Oldinfo.病区id And 记录状态 = 0;
  --已发送且未执行且未记帐审核或未收费的医嘱发送记录，如果执行科室是原病区的，应更新为当前病区
  Update 病人医嘱发送 a
  Set a.执行部门id = 病区id_In
  Where a.执行部门id = r_Oldinfo.病区id And a.执行状态 = 0 And Exists
   (Select 1
         From 住院费用记录 b
         Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 0 And 病人id = 病人id_In And 主页id = 主页id_In);

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Inunit;
/

--80722:刘鹏飞,2015-03-19,病人变动时当前状态合法性检查
Create Or Replace Procedure Zl_病人变动记录_Bedlevel
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       病人变动记录.床号%Type,
  等级id_In     病人变动记录.床位等级id%Type,
  生效时间_In   病人变动记录.开始时间%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：更改床位等级
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 生效时间_In;

  Cursor c_Endinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%Rowtype;
  r_Endinfo  c_Endinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  If Nvl(r_Endinfo.床号, '') <> 床号_In Then
    v_Error := '发现病人的床号已经发生变化,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If r_Endinfo.床位等级id = 等级id_In Then
    v_Error := '操作失败,当前该病人的床位等级和即将调整的床位等级相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 5, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 5, 终止人员 = 操作员姓名_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --产生新变动
  While c_Oldinfo%Found Loop
    If r_Oldinfo.床号 = 床号_In Then
      Update 床位状况记录 Set 等级id = 等级id_In Where 病区id = r_Oldinfo.病区id And 床号 = 床号_In;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 5, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, 等级id_In, 床号_In, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
         r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
      --更新将来的记录
      Update 病人变动记录
      Set 床位等级id = 等级id_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In;
    Else
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 5, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
    End If;
  
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Bedlevel;
/

--82383:刘鹏飞,2015-03-18,床位对换及换床目标床位有效性检查
Create Or Replace Procedure Zl_病人变动记录_Move
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  换床时间_In   病人变动记录.开始时间%Type,
  床号_In       Varchar2,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  病区id_In     病人变动记录.病区id%Type,
  主床位_In     病人信息.当前床号%Type,
  对换病人id_In 病案主页.病人id%Type := Null
) As
  -----------------------------------------------------------
  --说明：病人换床
  --参数：
  --       床号=Null:家庭病床;"床号1,床号2,....床号n"
  --       对换病人ID_IN 床位对换必须传入病人ID
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 换床时间_In;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 换床时间_In;

  r_Futureinfo c_Futureinfo %Rowtype;
  b_Isdel      Boolean;
  r_Oldinfo    c_Oldinfo%Rowtype;
  v_终止原因   病人变动记录.终止原因%Type;
  v_终止时间   病人变动记录.终止时间%Type;
  v_终止人员   病人变动记录.终止人员%Type;

  v_床号串 Varchar2(255);
  v_床号   Varchar2(255);
  v_等级id 床位状况记录.等级id%Type;
  v_年龄   病人信息.年龄%Type;
  n_病人id 病案主页.病人id%Type;
  n_病区id 病案主页.当前病区id%Type;

  v_Tmp   Number;
  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(状态, 0) = 0;

  If v_Count = 0 Then
    v_Error := '病人当前不处于正常住院状态,可能尚未入科,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select 当前病区id Into n_病区id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;

  If n_病区id <> 病区id_In Then
    v_Error := '当前操作病区与病人实际病区不一致,病人病区已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人后再试！';
    Raise Err_Custom;
  End If;

  --退除病人原床位
  v_Count := 0;
  For r_Bedrow In c_Bedinfo Loop
    v_Count := v_Count + 1;
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;
  If 对换病人id_In Is Not Null And v_Count > 1 Then
    v_Error := '操作失败,床位为' || v_床号 || '的病人为包床病人，不允许进行床位对换！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
    Raise Err_Custom;
  End If;

  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  For r_Fee In (Select No
                From 住院费用记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= 换床时间_In And 收费类别 = 'J'
                Group By No, 序号, Mod(记录性质, 10)
                Having Sum(结帐金额) <> 0) Loop
    v_Error := '变动时间之后已有已结帐的自动记帐费用,不能进行换床操作！';
    Raise Err_Custom;
  End Loop;

  --取消上批变动记录
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 换床时间_In, 终止原因 = 4, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 换床时间_In, 终止原因 = 4, 终止人员 = 操作员姓名_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --新增病人床位
  If 床号_In Is Null Then
    --家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 换床时间_In, 4, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id,
       Null, Null, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In,
       v_终止时间, v_终止原因, v_终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 换床时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In;
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    If v_Count > 1 And 对换病人id_In Is Not Null Then
      v_Error := '操作失败,床位对换不允许包床！' || Chr(13) || Chr(10) || '这可能是调用过程传参错误,请与开发商联系！';
      Raise Err_Custom;
    End If;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 换床时间_In;
      b_Isdel := True;
    End If;
  
    --入住一张或多张病床病床
    v_床号串 := 床号_In || ',';
  
    While v_床号串 Is Not Null Loop
      v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
    
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 换床时间_In, 4, Decode(主床位_In, v_床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, v_等级id, v_床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
         r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
    
      --换床检查床位是否为空：床位对换如果目标床位不为空，则检查是否是床位对换的病人
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号 And 状态 = '空床';
      If 对换病人id_In Is Null Then
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
          Raise Err_Custom;
        End If;
      Else
        If v_Count = 0 Then
          Select Max(病人id) Into n_病人id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号;
          If n_病人id Is Null Then
            v_Error := '操作失败,床位 ' || v_床号 || ' 不是有效的床位！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
            Raise Err_Custom;
          End If;
          If n_病人id <> 对换病人id_In Then
            v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床,且对换床位的病人发生了变化！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_床号, 病区id = 病区id_In
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               病区id_In, r_Futureinfo.科室id, r_Futureinfo.医疗小组id, r_Futureinfo.护理等级id, v_等级id, v_床号, r_Futureinfo.责任护士,
               r_Futureinfo.经治医师, r_Futureinfo.主治医师, r_Futureinfo.主任医师, r_Futureinfo.病情, r_Futureinfo.操作员编号,
               r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因, r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
    
      v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
    End Loop;
  End If;
  Close c_Oldinfo;

  --病人信息、病案主页

  Update 病案主页
  Set 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息
  Set 当前床号 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 年龄 = v_年龄
  Where 病人id = 病人id_In;

  --在院病人
  Update 在院病人 Set 病区id = 病区id_In Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Move;
/

--83270:冉俊明,2015-03-18,划价单修改费别时，实收金额未进行小数处理
Create Or Replace Procedure Zl_门诊划价_Recalcmoney
(
  病人id_In   门诊费用记录.病人id%Type,
  费别_In     门诊费用记录.费别%Type,
  Nos_In      门诊费用记录.No%Type := Null,
  记录性质_In 门诊费用记录.记录性质 %Type := 1
) As
  --功能：重新根据指定费别调整病人费用的实收金额
  --参数：
  --   病人id_In:1-门诊病人,2-住院病人
  --    Nos_In:可以传入指定的单据,分别用逗号分离:
  --    记录性质:1-门诊收费;2-门诊记帐
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_从项汇总折扣 Number(2);
  n_Count        Number(18);
  n_实收金额     Number(16, 5);
  n_折扣前金额   Number(16, 5);
  n_费别性质     费别.属性%Type;
  v_实收金额     Varchar2(100);
  n_Dec          Number(2);
Begin
  n_从项汇总折扣 := Nvl(Zl_Getsysparameter(93), 0);
  n_Dec          := Nvl(Zl_Getsysparameter(9), 2);

  For v_调整 In (Select /*+ rule */
               Distinct NO
               From 门诊费用记录 A, Table(f_Str2list(Nvl(Nos_In, 'lxh'))) J
               Where a.病人id = 病人id_In And 记录性质 = 记录性质_In And a.记录状态 = 0 And
                     (a.No || '' = j.Column_Value Or Nvl(Nos_In, 'lxh') = 'lxh') And Nvl(费别, ' ') <> Nvl(费别_In, ' ')) Loop
    --单张单据调整:
    For v_单据 In (Select a.Id, a.序号, a.从属父号, a.价格父号, a.应收金额, a.实收金额, b.屏蔽费别, a.收费细目id, 收入项目id, a.付数 * a.数次 As 数量, a.执行部门id
                 From 门诊费用记录 A, 收费项目目录 B
                 Where a.记录性质 = 记录性质_In And a.记录状态 = 0 And a.No = v_调整.No And a.收费细目id = b.Id) Loop
      --如果主项屏蔽费别,则汇总计算折扣参数无效,不汇总计算
      If n_从项汇总折扣 = 1 Then
        If Nvl(v_单据.从属父号, 0) > 0 Then
          --从项是否屏蔽费别
          Select Nvl(b.屏蔽费别, 0)
          Into n_Count
          From 门诊费用记录 A, 收费项目目录 B
          Where a.记录性质 = 记录性质_In And a.记录状态 = 0 And a.No = v_调整.No And 序号 = Nvl(v_单据.从属父号, 0) And a.收费细目id = b.Id;
          If Nvl(n_Count, 0) = 1 And Nvl(v_单据.屏蔽费别, 0) = 0 Then
            --主项屏蔽费别,按正常费别打折(从项)
            v_实收金额 := Zl_Actualmoney(费别_In, v_单据.收费细目id, v_单据.收入项目id, Nvl(v_单据.应收金额, 0), v_单据.数量, v_单据.执行部门id);
            n_实收金额 := Round(To_Number(Substr(v_实收金额, Instr(v_实收金额, ':') + 1)), n_Dec);
          
            Update 门诊费用记录 Set 实收金额 = n_实收金额 Where ID = v_单据.Id And 记录状态 = 0;
          End If;
        Else
        
          Select Count(*), Nvl(Sum(应收金额), 0)
          Into n_Count, n_折扣前金额
          From 门诊费用记录 A
          Where a.记录性质 = 记录性质_In And a.记录状态 = 0 And a.No = v_调整.No And 从属父号 = v_单据.序号;
        
          If Nvl(n_Count, 0) > 0 Then
            --有从项,则根据从项汇总打折来计算
            v_实收金额 := Zl_Actualmoney(费别_In, v_单据.收费细目id, v_单据.收入项目id, n_折扣前金额, v_单据.数量, v_单据.执行部门id);
          
            n_实收金额 := To_Number(Substr(v_实收金额, Instr(v_实收金额, ':') + 1));
            n_实收金额 := Round(Nvl(n_实收金额, 0) - Nvl(n_折扣前金额, 0), n_Dec);
          
            Update 门诊费用记录 Set 实收金额 = n_实收金额 + Nvl(应收金额, 0) Where ID = v_单据.Id And 记录状态 = 0;
          Elsif Nvl(v_单据.屏蔽费别, 0) = 0 Then
            --没有从项
            v_实收金额 := Zl_Actualmoney(费别_In, v_单据.收费细目id, v_单据.收入项目id, Nvl(v_单据.应收金额, 0), v_单据.数量, v_单据.执行部门id);
            n_实收金额 := Round(To_Number(Substr(v_实收金额, Instr(v_实收金额, ':') + 1)), n_Dec);
          
            Update 门诊费用记录 Set 实收金额 = n_实收金额 Where ID = v_单据.Id And 记录状态 = 0;
          End If;
        End If;
      Else
        If Nvl(v_单据.屏蔽费别, 0) = 0 Then
          v_实收金额 := Zl_Actualmoney(费别_In, v_单据.收费细目id, v_单据.收入项目id, Nvl(v_单据.应收金额, 0), v_单据.数量, v_单据.执行部门id);
          n_实收金额 := Round(To_Number(Substr(v_实收金额, Instr(v_实收金额, ':') + 1)), n_Dec);
          Update 门诊费用记录 Set 实收金额 = n_实收金额 Where ID = v_单据.Id And 记录状态 = 0;
        End If;
      End If;
    End Loop;
    Update 门诊费用记录 A Set 费别 = 费别_In Where a.记录性质 = 记录性质_In And a.记录状态 = 0 And a.No = v_调整.No;
  End Loop;

  Select Max(属性) Into n_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  If Nvl(n_费别性质, 0) <> 2 Then
    Update 病人信息 Set 费别 = 费别_In Where 病人id = 病人id_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价_Recalcmoney;
/

--83258:刘尔旋,2015-03-27,服务窗支持失效号挂号
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <RQ>2013-11-21 09:00</RQ>     //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码         挂号安排.号码%Type;
  d_日期         Date;
  n_操作类型     Number(3);
  n_序号控制     Number(3);
  n_存在         Number(3);
  n_分时段       Number(3);
  n_限号数       挂号安排限制.限号数%Type;
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  n_号序         挂号序号状态.序号%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  n_状态         挂号序号状态.状态%Type;
  v_合作单位     合作单位安排控制.合作单位%Type;
  n_合约模式     Number(3);
  n_启用合作单位 Number(3);
  v_Temp         Varchar2(32767); --临时XML
  v_Optemp       Varchar2(300);
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_Optemp := Zl_Identity(1);
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_Optemp From Dual;
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_操作员姓名 From Dual;
  If n_操作类型 = 0 Then
    --解锁
    Begin
      Select 1
      Into n_Exists
      From 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码 And
            Rownum < 2;
    Exception
      When Others Then
        n_Exists := 0;
    End;
    If n_Exists = 1 Then
      Delete 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码;
      v_Temp := '<HX>' || n_号序 || '</HX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      v_Temp := '<ERROR><MSG>没有发现需要解锁的序号</MSG></ERROR>';
      Raise Err_Item;
    End If;
  End If;

  If n_操作类型 = 1 Then
    --锁号
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    Begin
      Select 序号控制, ID
      Into n_序号控制, n_计划id
      From (Select 序号控制, ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_日期 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If n_序号控制 = 1 Then
      If Nvl(n_计划id, 0) <> 0 Then
        Begin
          Select 1 Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位计划控制
          Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号计划时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '<ERROR><MSG>传入时间' || d_日期 || '的序号已被使用</MSG></ERROR>';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号计划时段
                       Where 计划id = n_计划id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
              
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 序号 = 0 And 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位计划控制 A
                         Where 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      Else
        Begin
          Select 1 Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位安排控制
          Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号安排时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '<ERROR><MSG>传入时间' || d_日期 || '的序号已被使用</MSG></ERROR>';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号安排时段
                       Where 安排id = n_安排id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 序号 = 0 And 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位安排控制 A
                         Where 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Lockno;
/

--83213:马政,2015-03-17,财务审核可用数量错误
Create Or Replace Procedure Zl_材料外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  零售差价_In   In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  注册证号_In   In 药品收发记录.注册证号%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  高值材料_In   In Varchar2 := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  内部条码_In   In 药品收发记录.内部条码%Type := Null,
  费用id_In     In 药品收发记录.费用id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  财务审核_In   In Number := 0,
  批准文号_In   In 药品收发记录.批准文号%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No         应付记录.No%Type; --应付记录的NO 
  v_商品名     收费项目目录.名称%Type; --通用名称 
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID 
  n_应付id     应付记录.Id%Type; --应付记录的ID 
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID 
  n_入出系数   药品收发记录.入出系数%Type; --入出系数 
  n_批次       药品收发记录.批次%Type := Null; --批次 
  n_库房分批   Integer; --是否分批核算    1:分批；0：不分批 
  n_在用分批   Integer; --是否在用分批       1:分批；0：不分批 
  v_可用数量   药品库存.可用数量%Type;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  --取该材料的名称 
  v_产地 := '';
  Select 名称, 规格, 计算单位 Into v_商品名, v_规格, v_单位 From 收费项目目录 Where ID = 材料id_In;

  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  --财务审核直接用传过来的批次
  If 财务审核_In = 0 Then
    If 费用id_In > 0 And 批次_In > 0 Then
      n_批次 := 批次_In;
    Else
      If n_在用分批 = 0 Then
        If n_库房分批 = 1 Then
          Begin
            Select Distinct 0
            Into n_库房分批
            From 部门性质说明
            Where ((工作性质 Like '发料部门') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
          Exception
            When Others Then
              n_库房分批 := 1;
          End;
        
          If n_库房分批 = 1 Then
            n_批次 := v_Lngid;
          End If;
        End If;
      Else
        n_批次 := v_Lngid;
      End If;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 30 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额,
     扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 发药方式, 配药人, 配药日期, 注册证号, 用法, 商品条码, 内部条码, 费用id, 批准文号)
  Values
    (v_Lngid, 1, 15, No_In, 序号_In, 库房id_In, 供药单位id_In, n_入出类别id, n_入出系数, 材料id_In, Decode(退货_In, -1, 批次_In, n_批次), 产地_In,
     批号_In, 生产日期_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In, 扣率_In, 零售价_In,
     退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, Decode(退货_In, -1, 1, 0), 核查人_In, 核查日期_In, 注册证号_In, 零售差价_In,
     商品条码_In, 内部条码_In, 费用id_In, 批准文号_In);

  --高值材料信息 
  If Length(高值材料_In) > 0 Then
    Insert Into 收发记录补充信息
      (收发id, 科室, 病人姓名, 住院号, 床号)
    Values
      (v_Lngid, Substr(高值材料_In, 1, Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 1) + 1, Instr(高值材料_In, ',', 1, 2) - Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 2) + 1, Instr(高值材料_In, ',', 1, 3) - Instr(高值材料_In, ',', 1, 2) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 3) + 1, Length(高值材料_In)));
  End If;

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
  
    Select 应付记录_Id.Nextval Into n_应付id From Dual;
  
    --如果是第一笔明细,则产生应付记录的NO 
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量,
       采购价, 采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码)
    Values
      (n_应付id, 0, 1, 材料id_In, 序号_In, 供药单位id_In, v_No, 5, v_Lngid, No_In, 退货_In * 零售金额_In, 随货单号_In, 发票号_In, 发票日期_In,
       退货_In * Decode(发票号_In, Null, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 库房id_In, 发票代码_In);
  End If;

  --退货时下可用数量 
  If 退货_In = -1 And 费用id_In <> 2 Then
    --检查库存 
    Begin
      Select Nvl(可用数量, 0)
      Into v_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
    Exception
      When Others Then
        v_可用数量 := 0;
    End;
  
    If v_可用数量 - 实际数量_In < 0 Then
      v_Err_Msg := '[ZLSOFT]第' || 序号_In || '行的可用数量不够,请检查[ZLSOFT]';
      Raise Err_Item;
    End If;
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - 实际数量_In
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Insert;
/

--83262:王振涛,2015-03-17,过程已变更，同步修改
Create Or Replace Procedure Zl_检验试剂记录_Bill
(
  医嘱id_In In 检验标本记录.医嘱id%Type,
  No_In     In 住院费用记录.No%Type
) As
  Cursor C_Stuff Is
    Select C.名称, A.*, To_Number(Trim(To_Char(B.数量 / Decode(剂量系数, Null, 1, 0, 1, 剂量系数), '999999999999.0000'))) As 数量,
           C.计算单位, D.收入项目id, E.收据费目, B.执行科室id, D.现价
    From 材料特性 A,
         (Select 材料id, 执行科室id, Sum(数量) As 数量
           From 检验试剂记录 X, (Select Distinct 执行科室id From 病人医嘱记录 Where 相关id = 医嘱id_In) Y
           Where X.医嘱id = 医嘱id_In
           Group By 材料id, 执行科室id) B, 收费项目目录 C, 收费价目 D, 收入项目 E
    Where A.材料id = B.材料id And C.Id = A.材料id And D.收入项目id = E.Id And D.执行日期 <= Sysdate And
          (D.终止日期 Is Null Or D.终止日期 >= Sysdate) And D.收费细目id = A.材料id;

  Cursor C_Patient Is
    Select A.病人id, A.姓名, A.性别, A.年龄, A.费别, A.当前床号, B.主页id, B.病人科室id, B.开嘱科室id, B.开嘱医生,
           Decode(B.主页id, Null, A.门诊号, 0, A.门诊号, A.住院号) As 标识号, Decode(A.当前病区id, Null, B.病人科室id, A.当前病区id) As 病区id
    From 病人信息 A, 病人医嘱记录 B
    Where A.病人id = B.病人id And B.Id = 医嘱id_In;

  R_Stuff   C_Stuff%Rowtype;
  R_Patient C_Patient%Rowtype;

  V_类别id 药品单据性质.类别id%Type;

  V_Temp     Varchar2(255);
  V_人员编号 人员表.编号%Type;
  V_人员姓名 人员表.姓名%Type;
  V_当前时间 Date;
  V_序号     Number(18);
  V_Error    Varchar2(255);
  Err_Custom Exception;

  V_是否变价 Number(1);
  V_在用分批 Number(1);
  V_检查方式 药品出库检查.检查方式%Type;
  V_可用数量 药品库存.可用数量%Type;
Begin
  --当前操作人员
  V_Temp     := Zl_Identity;
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1);
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1);
  V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1);
  V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1);

  V_当前时间 := Sysdate;

  V_类别id := 0;
  Begin
    Select 类别id Into V_类别id From 药品单据性质 Where 单据 = 9;
  Exception
    When Others Then
      Null;
  End;

  If V_类别id <= 0 Then
    V_Error := '在生成卫材单据时不能确定单据的入出类别,请先到入出类别中设置！';
    Raise Err_Custom;
  End If;

  Open C_Patient;
  Fetch C_Patient
    Into R_Patient;

  V_序号 := 0;
  For R_Stuff In C_Stuff Loop
  
    V_检查方式 := 0;
    Begin
      Select Nvl(检查方式, 0) Into V_检查方式 From 药品出库检查 Where 库房id = R_Stuff.执行科室id;
    Exception
      When Others Then
        V_检查方式 := 0;
    End;
  
    If V_检查方式 = 2 And R_Stuff.数量 > 0 Then
    
      V_是否变价 := 0;
      V_在用分批 := 0;
      Begin
        Select Nvl(B.是否变价, 0), Nvl(A.在用分批, 0)
        Into V_是否变价, V_在用分批
        From 材料特性 A, 收费项目目录 B
        Where A.材料id = B.Id And A.材料id = R_Stuff.材料id;
      Exception
        When Others Then
          Null;
      End;
    
      V_可用数量 := 0;
    
      If Nvl(V_在用分批, 0) = 0 Then
        Begin
          Select Nvl(A.可用数量, 0)
          Into V_可用数量
          From 药品库存 A
          Where A.药品id = R_Stuff.材料id And A.库房id = R_Stuff.执行科室id;
        Exception
          When Others Then
            V_可用数量 := 0;
        End;
      Else
      
        Begin
          Select Nvl(Sum(A.可用数量), 0)
          Into V_可用数量
          From 药品库存 A
          Where 性质 = 1 And (效期 Is Null Or 效期 > Trunc(Sysdate)) And A.药品id = R_Stuff.材料id And A.库房id = R_Stuff.执行科室id;
        Exception
          When Others Then
            V_可用数量 := 0;
        End;
      End If;
    
      If R_Stuff.数量 > V_可用数量 Then
        V_Error := R_Stuff.名称 || '库存不足，禁止操作！';
        Raise Err_Custom;
      End If;
    End If;
  
    V_序号 := V_序号 + 1;
  
    If R_Patient.主页id Is Null Then
      Zl_门诊记帐记录_Insert(No_In, V_序号, R_Patient.病人id, R_Patient.标识号, R_Patient.姓名, R_Patient.性别, R_Patient.年龄,
                       R_Patient.费别, 0, 0, R_Patient.病人科室id, R_Patient.开嘱科室id, R_Patient.开嘱医生, Null, R_Stuff.材料id, '4',
                       R_Stuff.计算单位, 1, R_Stuff.数量, 0, R_Stuff.执行科室id, Null, R_Stuff.收入项目id, R_Stuff.收据费目, R_Stuff.现价,
                       R_Stuff.现价 * R_Stuff.数量, 0, V_当前时间, V_当前时间, Null, 0, V_人员编号, V_人员姓名,  Null, Null, 医嘱id_In);
    Else
      Zl_住院记帐记录_Insert(No_In, V_序号, R_Patient.病人id, R_Patient.主页id, R_Patient.标识号, R_Patient.姓名, R_Patient.性别,
                       R_Patient.年龄, R_Patient.当前床号, R_Patient.费别, R_Patient.病区id, R_Patient.病人科室id, 0, 0,
                       R_Patient.开嘱科室id, R_Patient.开嘱医生, Null, R_Stuff.材料id, '4', R_Stuff.计算单位, Null, Null, Null, 1,
                       R_Stuff.数量, 0, R_Stuff.执行科室id, Null, R_Stuff.收入项目id, R_Stuff.收据费目, R_Stuff.现价,
                       R_Stuff.现价 * R_Stuff.数量, 0, Null, V_当前时间, V_当前时间, Null, 0, V_人员编号, V_人员姓名, 0, V_类别id, Null, Null,
                       Null, 医嘱id_In);
    End If;
  
  End Loop;

  Close C_Patient;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检验试剂记录_Bill;
/

--82209:刘硕,2015-03-16,手麻排序
Create Or Replace Procedure Zl_病人手麻记录_三方insert
(
  病人id_In           病人手麻记录.病人id%Type,
  主页id_In           病人手麻记录.主页id%Type,
  记录来源_In         病人手麻记录.记录来源%Type,
  数据来源_In         病人手麻记录.数据来源%Type,
  手术日期_In         病人手麻记录.手术日期%Type,
  手术开始时间_In     病人手麻记录.手术开始时间%Type,
  手术结束时间_In     病人手麻记录.手术结束时间%Type,
  拟行手术_In         病人手麻记录.拟行手术%Type,
  手术操作id_In       病人手麻记录.手术操作id%Type,
  诊疗项目id_In       病人手麻记录.诊疗项目id%Type,
  已行手术_In         病人手麻记录.已行手术%Type,
  主刀医师_In         病人手麻记录.主刀医师%Type,
  助产护士_In         病人手麻记录.助产护士%Type,
  第一助手_In         病人手麻记录.第一助手%Type,
  第二助手_In         病人手麻记录.第二助手%Type,
  手术护士_In         病人手麻记录.手术护士%Type,
  麻醉开始时间_In     病人手麻记录.麻醉开始时间%Type,
  麻醉结束时间_In     病人手麻记录.麻醉结束时间%Type,
  麻醉方式_In         病人手麻记录.麻醉方式%Type,
  麻醉类型_In         病人手麻记录.麻醉类型%Type,
  麻醉质量_In         病人手麻记录.麻醉质量%Type,
  输液总量_In         病人手麻记录.输液总量%Type,
  麻醉医师_In         病人手麻记录.麻醉医师%Type,
  输氧开始时间_In     病人手麻记录.输氧开始时间%Type,
  输氧结束时间_In     病人手麻记录.输氧结束时间%Type,
  切口_In             病人手麻记录.切口%Type,
  愈合_In             病人手麻记录.愈合%Type,
  记录日期_In         病人手麻记录.记录日期%Type,
  手术情况_In         病人手麻记录.手术情况%Type := Null,
  Asa分级_In          病人手麻记录.Asa分级%Type := Null,
  再次手术_In         病人手麻记录.再次手术%Type := Null,
  Nnis分级_In         病人手麻记录.Nnis分级%Type := Null,
  手术级别_In         病人手麻记录.手术级别%Type := Null,
  准备天数_In         病人手麻记录.准备天数%Type := Null,
  抗菌用药时间_In     病人手麻记录.抗菌用药时间%Type := Null,
  切口部位_In         病人手麻记录.切口部位%Type := Null,
  切口感染_In         病人手麻记录.切口感染%Type := Null,
  并发症_In           病人手麻记录.并发症%Type := Null,
  重返计划_In         病人手麻记录.重返计划%Type := Null,
  重返目的_In         病人手麻记录.重返目的%Type := Null,
  术前抗菌用药_In     病人手麻记录.术前抗菌用药%Type := Null,
  抗菌用药天数_In     病人手麻记录.抗菌用药天数%Type := Null,
  非预期的二次手术_In 病人手麻记录.非预期的二次手术%Type := Null,
  麻醉并发症_In       病人手麻记录.麻醉并发症%Type := Null,
  术中异物遗留_In     病人手麻记录.术中异物遗留%Type := Null,
  手术并发症_In       病人手麻记录.手术并发症%Type := Null,
  术后出血或血肿_In   病人手麻记录.术后出血或血肿%Type := Null,
  手术伤口裂开_In     病人手麻记录.手术伤口裂开%Type := Null,
  术后深静脉血栓_In   病人手麻记录.术后深静脉血栓%Type := Null,
  术后生理代谢紊乱_In 病人手麻记录.术后生理代谢紊乱%Type := Null,
  术后呼吸衰竭_In     病人手麻记录.术后呼吸衰竭%Type := Null,
  术后肺栓塞_In       病人手麻记录.术后肺栓塞%Type := Null,
  术后败血症_In       病人手麻记录.术后败血症%Type := Null,
  术后髋关节骨折_In   病人手麻记录.术后髋关节骨折%Type := Null,
  手术次序_In         病人手麻记录.手术次序%Type:=Null
) Is
  --功能：三方手麻上传数据到病人手麻数据的接口过程，包含检查外壳
  N_Return    Number(1);
  N_Id        病人手麻记录.Id%Type;
  D_入院时间  Date;
  D_出院时间  Date;
  D_Now       Date;
  N_产科      Number(1) := 0;
  N_科室id    部门表.Id%Type;
  N_性别      Number(1);
  V_Tmp       Varchar2(500);
  N_Errnumber Number(2);
  Err_Custom Exception;
  V_Error Varchar2(2000);

  Procedure Checknull
  (
    V_Input      Varchar2,
    V_Infoname   Varchar2,
    N_Onlyreturn Number := 0
  ) Is
    --检查接口数据是否为空，为空则抛出异常  n_OnlyReturn 1：只返回结果，不抛出异常，0-为空则抛出异常
  Begin
    N_Return := 0;
    If Trim(V_Input) || ' ' = ' ' Then
      If N_Onlyreturn = 0 Then
        V_Error := V_Infoname || '为空！';
        Raise Err_Custom;
      Else
        N_Return := 0;
      End If;
    Else
      N_Return := 1;
    End If;
  End;

  Procedure Checkvaluerange
  (
    V_Input     Varchar2,
    V_Valuerang Varchar2,
    V_Infoname  Varchar2
  ) Is
    --检查接口数据值域是否正确，不正确则抛出异常  
  Begin
    If Instr(',' || V_Valuerang || ',', V_Input) = 0 Then
      V_Error := V_Infoname || '值域为' || V_Valuerang || '！';
      Raise Err_Custom;
    End If;
  End;

  Procedure Checkdatarange
  (
    D_Input        Date,
    V_Infoname     Varchar2,
    N_Canbenull    Number := 0,
    N_Notcheck出院 Number := 0
  ) Is
    --检查接口数据时间类型的是否在入出院时间内，不在则抛出异常  N_Notcheck出院：不检查出院时间
  Begin
    N_Return := 0;
    If D_Input Is Not Null Then
      If N_Notcheck出院 = 0 Then
        If Not D_Input Between D_入院时间 And D_出院时间 Then
          V_Error := V_Infoname || '不在病人入出院时间之内！';
          Raise Err_Custom;
        End If;
      Else
        If D_Input < D_入院时间 Then
          V_Error := V_Infoname || '小于病人入院时间！';
          Raise Err_Custom;
        End If;
      End If;
    Else
      If N_Canbenull = 0 Then
        V_Error := V_Infoname || '为空！';
        Raise Err_Custom;
      End If;
    End If;
  End;

Begin
  -----------------------------------------------------------
  --1、简单数据合法性检查（非空与值域检查，不涉及业务检查）
  ----------------------------------------------------------------

  --病人ID，主页ID,记录来源，数据来源 不为空
  Checknull(病人id_In || ' ', '病人ID');
  Checknull(主页id_In || ' ', '主页id');
  Checknull(记录来源_In || ' ', '记录来源');
  Checknull(数据来源_In || ' ', '数据来源');
  -----获取病人信息与参数信息
  Select Sysdate Into D_Now From Dual;
  N_Errnumber := 1;
  Select Nvl(出院日期, D_Now), 入院日期, 出院科室id
  Into D_出院时间, D_入院时间, N_科室id
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  N_Errnumber := 2;
  Select Decode(性别, '男', 1, '女', 2, 0) Into N_性别 From 病人信息 Where 病人id = 病人id_In;
  N_Errnumber := 0;
  Select Count(1) Into N_产科 From 部门性质说明 Where 部门id = N_科室id And 工作性质 = '产科';
  --入院时间不能为空
  Checknull(Trim(D_入院时间) || ' ', '病人入院日期');
  --手术日期_In，手术名称（已行手术_In）
  Checknull(手术日期_In || ' ', '手术日期');
  Checknull(已行手术_In || ' ', '手术名称(已行手术)');
  --助手医生(第二助手_In or 第一助手_In)不为空时，主刀医生不为空
  Checknull(Trim(第一助手_In || 第二助手_In) || ' ', Null, 1);
  If N_Return = 1 Then
    --第二助手不为空时，第一助手不能为空
    Checknull(Trim(第二助手_In) || ' ', Null, 1);
    If N_Return = 1 Then
      Checknull(Trim(第一助手_In) || ' ', '第二助手不为空时,第一助手');
    End If;
    --助手医生(第一助手_In)不为空时，主刀医生不为空
    Checknull(Trim(主刀医师_In) || ' ', '第一助手不为空时，主刀医生');
  Else
    If N_产科 = 1 Then
      Checknull(Trim(主刀医师_In || 助产护士_In) || ' ', '主刀医师与助产护士同时');
    Else
      Checknull(Trim(主刀医师_In) || ' ', '主刀医生');
    End If;
  End If;
  --麻醉医师不为空时，麻醉类型不为空
  Checknull(Trim(麻醉医师_In) || ' ', Null, 1);
  If N_Return = 1 Then
    Checknull(Trim(麻醉类型_In) || ' ', '麻醉医师不为空时，麻醉类型');
  End If;
  --记录日期不为空
  Checknull(记录日期_In || ' ', '记录日期');
  --输氧开始时间不能小于输氧结束时间
  Checknull(Trim(输氧开始时间_In || 输氧结束时间_In) || ' ', Null, 1);
  If N_Return = 1 Then
    Checknull(输氧开始时间_In || ' ', '输氧结束时间不为空，输氧开始时间');
    If Not 输氧结束时间_In Is Null Then
      If 输氧结束时间_In < 输氧开始时间_In Then
        V_Error := '输氧结束时间小于输氧开始时间！';
        Raise Err_Custom;
      End If;
    End If;
  End If;
  --切口愈合必须同时为空或同时不为空
  Checknull(Trim(切口_In || 愈合_In) || ' ', Null, 1);
  If N_Return = 1 Then
    If Trim(切口_In) = '0' And 愈合_In Is Not Null Then
      V_Error := '切口为0时愈合应为空值！';
      Raise Err_Custom;
    End If;
    Checkvaluerange(',' || Trim(切口_In) || ',', 'Ⅰ,Ⅱ,Ⅲ,IV', '切口');
    Checkvaluerange(',' || Trim(愈合_In) || ',', '甲,乙,丙,其他', '切口');
  End If;
  --Checkvaluerange(',' || Upper(Trim(Asa分级_In)) || ',', '甲,乙,丙,其他', '切口');
  --手术级别的值域为0,1,2,3,4
  Checkvaluerange(',' || Nvl(手术级别_In, 0) || ',', '0,1,2,3,4', '手术级别');
  --值域为0,1
  --再次手术,重返计划,并发症,切口感染，术前抗菌用药，非预期的二次手术 
  --麻醉并发症,术中异物遗留,手术并发症,术后出血或血肿,手术伤口裂开
  --术后深静脉血栓,术后生理代谢紊乱,术后呼吸衰竭,术后肺栓塞
  --术后败血症,术后髋关节骨折
  Checkvaluerange(',' || Nvl(再次手术_In, 0) || ',', '0,1', '再次手术');
  Checkvaluerange(',' || Nvl(重返计划_In, 0) || ',', '0,1', '重返计划');
  Checkvaluerange(',' || Nvl(并发症_In, 0) || ',', '0,1', '并发症');
  Checkvaluerange(',' || Nvl(切口感染_In, 0) || ',', '0,1', '切口感染');
  Checkvaluerange(',' || Nvl(术前抗菌用药_In, 0) || ',', '0,1', '术前抗菌用药');
  Checkvaluerange(',' || Nvl(非预期的二次手术_In, 0) || ',', '0,1', '非预期的二次手术');
  Checkvaluerange(',' || Nvl(麻醉并发症_In, 0) || ',', '0,1', '麻醉并发症');
  Checkvaluerange(',' || Nvl(术中异物遗留_In, 0) || ',', '0,1', '术中异物遗留');
  Checkvaluerange(',' || Nvl(手术并发症_In, 0) || ',', '0,1', '手术并发症');
  Checkvaluerange(',' || Nvl(术后出血或血肿_In, 0) || ',', '0,1', '术后出血或血肿');
  Checkvaluerange(',' || Nvl(手术伤口裂开_In, 0) || ',', '0,1', '手术伤口裂开');
  Checkvaluerange(',' || Nvl(术后深静脉血栓_In, 0) || ',', '0,1', '术后深静脉血栓');
  Checkvaluerange(',' || Nvl(术后生理代谢紊乱_In, 0) || ',', '0,1', '术后生理代谢紊乱');
  Checkvaluerange(',' || Nvl(术后呼吸衰竭_In, 0) || ',', '0,1', '术后呼吸衰竭');
  Checkvaluerange(',' || Nvl(术后肺栓塞_In, 0) || ',', '0,1', '术后肺栓塞');
  Checkvaluerange(',' || Nvl(术后败血症_In, 0) || ',', '0,1', '术后败血症');
  Checkvaluerange(',' || Nvl(术后髋关节骨折_In, 0) || ',', '0,1', '术后髋关节骨折');
  --抗菌用药天数 ,输液总量,准备天数大于0
  If Nvl(输液总量_In, 1) < 0 Then
    V_Error := '输液总量不能为负值！';
    Raise Err_Custom;
  End If;

  If Nvl(抗菌用药天数_In, 1) < 0 Then
    V_Error := '抗菌用药天数不能为负值！';
    Raise Err_Custom;
  End If;

  If Nvl(准备天数_In, 1) < 0 Then
    V_Error := '准备天数不能为负值！';
    Raise Err_Custom;
  End If;
  ----------------------------------------------------------------
  ---2、复杂数据合法性检查（涉及病人相关信息，以及业务流程）
  ----------------------------------------------------------------
  --必须在入出院时间范围内，且不能为空
  --手术日期，手术开始时间，手术结束时间
  Checkdatarange(手术日期_In, '手术日期');
  Checkdatarange(手术开始时间_In, '手术开始时间');
  Checkdatarange(手术结束时间_In, '手术结束时间');
  --手术结束时间必须大于开始时间
  If 手术结束时间_In < 手术开始时间_In Then
    V_Error := '手术结束时间必须大于手术开始时间！';
    Raise Err_Custom;
  End If;
  --必须在入出院时间范围内，可以为空
  --麻醉开始时间，麻醉结束时间，输氧开始时间，输氧结束时间，抗菌用药时间(不检查出院时间）
  Checkdatarange(麻醉开始时间_In, '麻醉开始时间', 1);
  Checkdatarange(麻醉结束时间_In, '麻醉结束时间', 1);
  Checkdatarange(输氧开始时间_In, '输氧开始时间', 1);
  Checkdatarange(输氧结束时间_In, '输氧结束时间', 1);
  Checkdatarange(抗菌用药时间_In, '抗菌用药时间', 1, 1);
  --项目的有效性检查
  If 诊疗项目id_In Is Not Null Then
    N_Errnumber := 3;
    Select 名称
    Into V_Tmp
    From 诊疗项目目录
    Where 类别 = 'F' And 服务对象 In (2, 3) And Nvl(适用性别, 0) In (0, N_性别) And
          (撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or 撤档时间 Is Null) And ID = 诊疗项目id_In;
    N_Errnumber := 0;
    If 已行手术_In Not Like '%' || V_Tmp || '%' Then
      V_Error := '手术项目名称与数据库名称不一致！';
      Raise Err_Custom;
    End If;
  End If;

  If 手术操作id_In Is Not Null Then
    N_Errnumber := 4;
    Select 名称
    Into V_Tmp
    From 疾病编码目录
    Where 类别 = 'S' And (性别限制 = N_性别 Or 性别限制 Is Null Or N_性别 = 0) And
          (撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or 撤档时间 Is Null) And ID = 手术操作id_In;
    N_Errnumber := 0;
    If 已行手术_In Not Like '%' || V_Tmp || '%' Then
      V_Error := '手术操作名称与数据库名称不一致！';
      Raise Err_Custom;
    End If;
  End If;
  If 麻醉方式_In Is Not Null Then
    N_Errnumber := 5;
    Select A.名称
    Into V_Tmp
    From 诊疗项目目录 A
    Where A.类别 = 'G' And (A.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or A.撤档时间 Is Null) And A.Id = 麻醉方式_In;
    N_Errnumber := 0;
  End If;
  ---差异，为了提交VSS
  Select 病人手麻记录_Id.Nextval Into N_Id From Dual;
  Zl_病人手麻记录_Insert(N_Id, 病人id_In, 主页id_In, 记录来源_In,手术次序_In, 手术日期_In, 手术开始时间_In, 手术结束时间_In, 拟行手术_In, 手术操作id_In, 诊疗项目id_In,
                   已行手术_In, 主刀医师_In, 助产护士_In, 第一助手_In, 第二助手_In, 手术护士_In, 麻醉开始时间_In, 麻醉结束时间_In, 麻醉方式_In, 麻醉类型_In, 麻醉质量_In,
                   输液总量_In, 麻醉医师_In, 输氧开始时间_In, 输氧结束时间_In, 切口_In, 愈合_In, 记录日期_In, 手术情况_In, Asa分级_In, 再次手术_In, Nnis分级_In,
                   手术级别_In, 准备天数_In, 抗菌用药时间_In, 切口部位_In, 切口感染_In, 并发症_In, 重返计划_In, 重返目的_In, 术前抗菌用药_In, 抗菌用药天数_In,
                   非预期的二次手术_In, 麻醉并发症_In, 术中异物遗留_In, 手术并发症_In, 术后出血或血肿_In, 手术伤口裂开_In, 术后深静脉血栓_In, 术后生理代谢紊乱_In, 术后呼吸衰竭_In,
                   术后肺栓塞_In, 术后败血症_In, 术后髋关节骨折_In, 数据来源_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
  When Others Then
    If N_Errnumber <> 0 Then
      If N_Errnumber = 1 Then
        V_Error := '未找到病人！';
      Elsif N_Errnumber = 2 Then
        V_Error := '病人未进行病人信息登记！';
      Elsif N_Errnumber = 3 Then
        V_Error := '手术项目已经撤档或适用性别与当前病人不符合！';
      Elsif N_Errnumber = 4 Then
        V_Error := '手术操作已经撤档或适用性别与当前病人不符合！';
      Elsif N_Errnumber = 5 Then
        V_Error := '麻醉方式已经撤档！';
      End If;
      Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
    Else
      zl_ErrorCenter(SQLCode, SQLErrM);
    End If;
End Zl_病人手麻记录_三方insert;
/

--82209:刘硕,2015-03-16,手麻排序
Create Or Replace Procedure Zl_病人手麻记录_Insert
(
  Id_In               病人手麻记录.Id%Type,
  病人id_In           病人手麻记录.病人id%Type,
  主页id_In           病人手麻记录.主页id%Type,
  记录来源_In         病人手麻记录.记录来源%Type,
  手术次序_In         病人手麻记录.手术次序%Type,
  手术日期_In         病人手麻记录.手术日期%Type,
  手术开始时间_In     病人手麻记录.手术开始时间%Type,
  手术结束时间_In     病人手麻记录.手术结束时间%Type,
  拟行手术_In         病人手麻记录.拟行手术%Type,
  手术操作id_In       病人手麻记录.手术操作id%Type,
  诊疗项目id_In       病人手麻记录.诊疗项目id%Type,
  已行手术_In         病人手麻记录.已行手术%Type,
  主刀医师_In         病人手麻记录.主刀医师%Type,
  助产护士_In         病人手麻记录.助产护士%Type,
  第一助手_In         病人手麻记录.第一助手%Type,
  第二助手_In         病人手麻记录.第二助手%Type,
  手术护士_In         病人手麻记录.手术护士%Type,
  麻醉开始时间_In     病人手麻记录.麻醉开始时间%Type,
  麻醉结束时间_In     病人手麻记录.麻醉结束时间%Type,
  麻醉方式_In         病人手麻记录.麻醉方式%Type,
  麻醉类型_In         病人手麻记录.麻醉类型%Type,
  麻醉质量_In         病人手麻记录.麻醉质量%Type,
  输液总量_In         病人手麻记录.输液总量%Type,
  麻醉医师_In         病人手麻记录.麻醉医师%Type,
  输氧开始时间_In     病人手麻记录.输氧开始时间%Type,
  输氧结束时间_In     病人手麻记录.输氧结束时间%Type,
  切口_In             病人手麻记录.切口%Type,
  愈合_In             病人手麻记录.愈合%Type,
  记录日期_In         病人手麻记录.记录日期%Type,
  手术情况_In         病人手麻记录.手术情况%Type := Null,
  Asa分级_In          病人手麻记录.Asa分级%Type := Null,
  再次手术_In         病人手麻记录.再次手术%Type := Null,
  Nnis分级_In         病人手麻记录.Nnis分级%Type := Null,
  手术级别_In         病人手麻记录.手术级别%Type := Null,
  准备天数_In         病人手麻记录.准备天数%Type := Null,
  抗菌用药时间_In     病人手麻记录.抗菌用药时间%Type := Null,
  切口部位_In         病人手麻记录.切口部位%Type := Null,
  切口感染_In         病人手麻记录.切口感染%Type := Null,
  并发症_In           病人手麻记录.并发症%Type := Null,
  重返计划_In         病人手麻记录.重返计划%Type := Null,
  重返目的_In         病人手麻记录.重返目的%Type := Null,
  术前抗菌用药_In     病人手麻记录.术前抗菌用药%Type := Null,
  抗菌用药天数_In     病人手麻记录.抗菌用药天数%Type := Null,
  非预期的二次手术_In 病人手麻记录.非预期的二次手术%Type := Null,
  麻醉并发症_In       病人手麻记录.麻醉并发症%Type := Null,
  术中异物遗留_In     病人手麻记录.术中异物遗留%Type := Null,
  手术并发症_In       病人手麻记录.手术并发症%Type := Null,
  术后出血或血肿_In   病人手麻记录.术后出血或血肿%Type := Null,
  手术伤口裂开_In     病人手麻记录.手术伤口裂开%Type := Null,
  术后深静脉血栓_In   病人手麻记录.术后深静脉血栓%Type := Null,
  术后生理代谢紊乱_In 病人手麻记录.术后生理代谢紊乱%Type := Null,
  术后呼吸衰竭_In     病人手麻记录.术后呼吸衰竭%Type := Null,
  术后肺栓塞_In       病人手麻记录.术后肺栓塞%Type := Null,
  术后败血症_In       病人手麻记录.术后败血症%Type := Null,
  术后髋关节骨折_In   病人手麻记录.术后髋关节骨折%Type := Null,
  数据来源_In         病人手麻记录.数据来源%Type := Null
) Is
  --功能：插入病人手麻记录
  V_Temp     Varchar2(255);
  V_人员编号 人员表.编号%Type;
  V_人员姓名 人员表.姓名%Type;
Begin
  --当前操作人员
  V_Temp     := Zl_Identity;
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1);
  V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1);
  V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1);
  V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1);

  Insert Into 病人手麻记录
    (Id, 病人id, 主页id, 记录来源, 手术次序, 手术日期, 手术开始时间, 手术结束时间, 拟行手术, 手术操作id, 诊疗项目id, 已行手术, 主刀医师, 助产护士, 第一助手, 第二助手, 手术护士, 麻醉开始时间,
     麻醉结束时间, 麻醉方式, 麻醉类型, 麻醉质量, 输液总量, 麻醉医师, 输氧开始时间, 输氧结束时间, 切口, 愈合, 记录日期, 记录人, 手术情况, Asa分级, 再次手术, Nnis分级, 手术级别, 准备天数,
     抗菌用药时间, 切口部位, 切口感染, 并发症, 重返计划, 重返目的, 术前抗菌用药, 抗菌用药天数, 非预期的二次手术, 麻醉并发症, 术中异物遗留, 手术并发症, 术后出血或血肿, 手术伤口裂开, 术后深静脉血栓,
     术后生理代谢紊乱, 术后呼吸衰竭, 术后肺栓塞, 术后败血症, 术后髋关节骨折, 数据来源)
  Values
    (Id_In, 病人id_In, 主页id_In, 记录来源_In, 手术次序_In, 手术日期_In, 手术开始时间_In, 手术结束时间_In, 拟行手术_In, 手术操作id_In, 诊疗项目id_In, 已行手术_In,
     主刀医师_In, 助产护士_In, 第一助手_In, 第二助手_In, 手术护士_In, 麻醉开始时间_In, 麻醉结束时间_In, 麻醉方式_In, 麻醉类型_In, 麻醉质量_In, 输液总量_In, 麻醉医师_In,
     输氧开始时间_In, 输氧结束时间_In, 切口_In, 愈合_In, 记录日期_In, V_人员姓名, 手术情况_In, Asa分级_In, 再次手术_In, Nnis分级_In, 手术级别_In, 准备天数_In,
     抗菌用药时间_In, 切口部位_In, 切口感染_In, 并发症_In, 重返计划_In, 重返目的_In, 术前抗菌用药_In, 抗菌用药天数_In, 非预期的二次手术_In, 麻醉并发症_In, 术中异物遗留_In,
     手术并发症_In, 术后出血或血肿_In, 手术伤口裂开_In, 术后深静脉血栓_In, 术后生理代谢紊乱_In, 术后呼吸衰竭_In, 术后肺栓塞_In, 术后败血症_In, 术后髋关节骨折_In, 数据来源_In);
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人手麻记录_Insert;
/


--82209:刘硕,2015-03-16,手麻记录排序
Create Or Replace Procedure Zl_病人手麻记录_Update
(
  Id_In               病人手麻记录.Id%Type,
  病人id_In           病人手麻记录.病人id%Type,
  主页id_In           病人手麻记录.主页id%Type,
  记录来源_In         病人手麻记录.记录来源%Type,
  手术次序_In         病人手麻记录.手术次序%Type,
  手术日期_In         病人手麻记录.手术日期%Type,
  手术开始时间_In     病人手麻记录.手术开始时间%Type,
  手术结束时间_In     病人手麻记录.手术结束时间%Type,
  拟行手术_In         病人手麻记录.拟行手术%Type,
  手术操作id_In       病人手麻记录.手术操作id%Type,
  诊疗项目id_In       病人手麻记录.诊疗项目id%Type,
  已行手术_In         病人手麻记录.已行手术%Type,
  主刀医师_In         病人手麻记录.主刀医师%Type,
  助产护士_In         病人手麻记录.助产护士%Type,
  第一助手_In         病人手麻记录.第一助手%Type,
  第二助手_In         病人手麻记录.第二助手%Type,
  手术护士_In         病人手麻记录.手术护士%Type,
  麻醉开始时间_In     病人手麻记录.麻醉开始时间%Type,
  麻醉结束时间_In     病人手麻记录.麻醉结束时间%Type,
  麻醉方式_In         病人手麻记录.麻醉方式%Type,
  麻醉类型_In         病人手麻记录.麻醉类型%Type,
  麻醉质量_In         病人手麻记录.麻醉质量%Type,
  输液总量_In         病人手麻记录.输液总量%Type,
  麻醉医师_In         病人手麻记录.麻醉医师%Type,
  输氧开始时间_In     病人手麻记录.输氧开始时间%Type,
  输氧结束时间_In     病人手麻记录.输氧结束时间%Type,
  切口_In             病人手麻记录.切口%Type,
  愈合_In             病人手麻记录.愈合%Type,
  手术情况_In         病人手麻记录.手术情况%Type := Null,
  Asa分级_In          病人手麻记录.Asa分级%Type := Null,
  再次手术_In         病人手麻记录.再次手术%Type := Null,
  Nnis分级_In         病人手麻记录.Nnis分级%Type := Null,
  手术级别_In         病人手麻记录.手术级别%Type := Null,
  准备天数_In         病人手麻记录.准备天数%Type := Null,
  抗菌用药时间_In     病人手麻记录.抗菌用药时间%Type := Null,
  切口部位_In         病人手麻记录.切口部位%Type := Null,
  切口感染_In         病人手麻记录.切口感染%Type := Null,
  并发症_In           病人手麻记录.并发症%Type := Null,
  重返计划_In         病人手麻记录.重返计划%Type := Null,
  重返目的_In         病人手麻记录.重返目的%Type := Null,
  术前抗菌用药_In     病人手麻记录.术前抗菌用药%Type := Null,
  抗菌用药天数_In     病人手麻记录.抗菌用药天数%Type := Null,
  非预期的二次手术_In 病人手麻记录.非预期的二次手术%Type := Null,
  麻醉并发症_In       病人手麻记录.麻醉并发症%Type := Null,
  术中异物遗留_In     病人手麻记录.术中异物遗留%Type := Null,
  手术并发症_In       病人手麻记录.手术并发症%Type := Null,
  术后出血或血肿_In   病人手麻记录.术后出血或血肿%Type := Null,
  手术伤口裂开_In     病人手麻记录.手术伤口裂开%Type := Null,
  术后深静脉血栓_In   病人手麻记录.术后深静脉血栓%Type := Null,
  术后生理代谢紊乱_In 病人手麻记录.术后生理代谢紊乱%Type := Null,
  术后呼吸衰竭_In     病人手麻记录.术后呼吸衰竭%Type := Null,
  术后肺栓塞_In       病人手麻记录.术后肺栓塞%Type := Null,
  术后败血症_In       病人手麻记录.术后败血症%Type := Null,
  术后髋关节骨折_In   病人手麻记录.术后髋关节骨折%Type := Null,
  数据来源_In         病人手麻记录.数据来源%Type := Null
) Is
  --功能：插入病人手麻记录 
  N_Count    Number(8);
  V_Temp     Varchar2(255);
  V_人员编号 人员表.编号%Type;
  V_人员姓名 人员表.姓名%Type;
Begin
  --先判断当前手术是指定的来源的手术，是则更新，否则新增
  Select Count(1) Into N_Count From 病人手麻记录 Where Id = Id_In And 记录来源 = 记录来源_In;
  If N_Count = 1 Then
    Update 病人手麻记录
    Set 手术次序 = 手术次序_In, 手术日期 = 手术日期_In, 手术开始时间 = 手术开始时间_In, 手术结束时间 = 手术结束时间_In, 拟行手术 = 拟行手术_In, 手术操作id = 手术操作id_In,
        诊疗项目id = 诊疗项目id_In, 已行手术 = 已行手术_In, 主刀医师 = 主刀医师_In, 助产护士 = 助产护士_In, 第一助手 = 第一助手_In, 第二助手 = 第二助手_In,
        手术护士 = 手术护士_In, 麻醉开始时间 = 麻醉开始时间_In, 麻醉结束时间 = 麻醉开始时间_In, 麻醉方式 = 麻醉方式_In, 麻醉类型 = 麻醉类型_In, 麻醉质量 = 麻醉质量_In,
        输液总量 = 输液总量_In, 麻醉医师 = 麻醉医师_In, 输氧开始时间 = 输氧开始时间_In, 输氧结束时间 = 输氧结束时间_In, 切口 = 切口_In, 愈合 = 愈合_In, 手术情况 = 手术情况_In,
        Asa分级 = Asa分级_In, 再次手术 = 再次手术_In, Nnis分级 = Nnis分级_In, 手术级别 = 手术级别_In, 准备天数 = 准备天数_In, 抗菌用药时间 = 抗菌用药时间_In,
        切口部位 = 切口部位_In, 切口感染 = 切口感染_In, 并发症 = 并发症_In, 重返计划 = 重返计划_In, 重返目的 = 重返目的_In, 术前抗菌用药 = 术前抗菌用药_In,
        抗菌用药天数 = 抗菌用药天数_In, 非预期的二次手术 = 非预期的二次手术_In, 麻醉并发症 = 麻醉并发症_In, 术中异物遗留 = 术中异物遗留_In, 手术并发症 = 手术并发症_In,
        术后出血或血肿 = 术后出血或血肿_In, 手术伤口裂开 = 手术伤口裂开_In, 术后深静脉血栓 = 术后深静脉血栓_In, 术后生理代谢紊乱 = 术后生理代谢紊乱_In, 术后呼吸衰竭 = 术后呼吸衰竭_In,
        术后肺栓塞 = 术后肺栓塞_In, 术后败血症 = 术后败血症_In, 术后髋关节骨折 = 术后髋关节骨折_In, 数据来源 = 数据来源_In
    Where Id = Id_In;
  Else
    --当前操作人员 
    V_Temp     := Zl_Identity;
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1);
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1);
    V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1);
    V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1);
  
    Insert Into 病人手麻记录
      (Id, 病人id, 主页id, 记录来源, 手术次序, 手术日期, 手术开始时间, 手术结束时间, 拟行手术, 手术操作id, 诊疗项目id, 已行手术, 主刀医师, 助产护士, 第一助手, 第二助手, 手术护士, 麻醉开始时间,
       麻醉结束时间, 麻醉方式, 麻醉类型, 麻醉质量, 输液总量, 麻醉医师, 输氧开始时间, 输氧结束时间, 切口, 愈合, 记录日期, 记录人, 手术情况, Asa分级, 再次手术, Nnis分级, 手术级别, 准备天数,
       抗菌用药时间, 切口部位, 切口感染, 并发症, 重返计划, 重返目的, 术前抗菌用药, 抗菌用药天数, 非预期的二次手术, 麻醉并发症, 术中异物遗留, 手术并发症, 术后出血或血肿, 手术伤口裂开, 术后深静脉血栓,
       术后生理代谢紊乱, 术后呼吸衰竭, 术后肺栓塞, 术后败血症, 术后髋关节骨折, 数据来源)
      Select 病人手麻记录_Id.Nextval, 病人id_In, 主页id_In, 记录来源_In, 手术次序_In, 手术日期_In, 手术开始时间_In, 手术结束时间_In, 拟行手术_In, 手术操作id_In,
             诊疗项目id_In, 已行手术_In, 主刀医师_In, 助产护士_In, 第一助手_In, 第二助手_In, 手术护士_In, 麻醉开始时间_In, 麻醉结束时间_In, 麻醉方式_In, 麻醉类型_In,
             麻醉质量_In, 输液总量_In, 麻醉医师_In, 输氧开始时间_In, 输氧结束时间_In, 切口_In, 愈合_In, Sysdate, V_人员姓名, 手术情况_In, Asa分级_In, 再次手术_In,
             Nnis分级_In, 手术级别_In, 准备天数_In, 抗菌用药时间_In, 切口部位_In, 切口感染_In, 并发症_In, 重返计划_In, 重返目的_In, 术前抗菌用药_In, 抗菌用药天数_In,
             非预期的二次手术_In, 麻醉并发症_In, 术中异物遗留_In, 手术并发症_In, 术后出血或血肿_In, 手术伤口裂开_In, 术后深静脉血栓_In, 术后生理代谢紊乱_In, 术后呼吸衰竭_In,
             术后肺栓塞_In, 术后败血症_In, 术后髋关节骨折_In, 数据来源_In
      From Dual;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人手麻记录_Update;
/

--82936:刘兴洪,2015-03-13,获取医嘱费用时包含附加费用及医保补结算问题
Create Or Replace Procedure Zl_Third_Paymentinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取指定单据交易信息 
  --入参:Xml_In: 
  --<IN>
  --    <DJ>单据号,性质|....</DJ> //可以传入多个单据
  --    <JSKLB>结算卡类别</JSKLB>
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<DJ>  //如果为空表示没有找到数据
  --    <DJH>单据号</DJH>
  --    <JLXZ>记录性质</JLXZ>   
  --    <YSJE>应收金额</YSJE>
  --    <SSJE>实收金额</SSJE>
  --    <FYMC>收据费目</FYMC> //(多个用逗号分离 )
  --    <JSKZF>结算卡支付</JSKZF> //:0-不是结算卡支付;1-结算卡支付(入参中:JSKLB判断,存在该类别支付的,返回1,否则返回0)
  --    <FKSJ>付款时间</FKSJ>
  --    <JYLSH>交易流水号</JYLSH> //(非结算卡支付的，不返回)
  --    <YXTK>是否允许退款</YXTK>            //0不允许1允许
  --    <YBJS>医保是否结算</YBJS>   //1-已结算;0-未结算
  --    <KP>是否开票</KP>  1是0否
  --    <JZTFSM>禁止退款说明</JZTFSM>
  --</DJ>
  --<ERROR><MSG></MSG></ERROR>          //错误情况返回
  --</OUTPUT>
  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet      Xmltype; --模板XML 
  v_No           Varchar2(4000);
  v_结算卡类别   Varchar2(100);
  n_结算卡类别id 医疗卡类别.Id%Type;

  n_Temp       Number(18);
  v_Temp       Varchar2(32767); --临时XML 
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_医保结算   Number(2);
  n_允许退款   Number(2);
  v_说明       Varchar2(100);
  n_补结算     Number(18);
  n_已开医嘱   Number(2);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/DJ'), Extractvalue(Value(A), 'IN/JSKLB')
  Into v_No, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_No Is Null Then
    v_Err_Msg := '不能找到指定的收费单据(当前单据为空)';
    Raise Err_Item;
  End If;
  If v_结算卡类别 Is Not Null Then
    v_Err_Msg := Null;
    Begin
      n_结算卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_结算卡类别id := 0;
    End;
    If Nvl(n_结算卡类别id, 0) = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_结算卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := v_结算卡类别 || '不存在!';
      End;
    Else
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_结算卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_结算卡类别id;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  For c_收费单 In (Select /*+ rule*/
                 记录性质, NO, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Max(收款时间) As 收款时间, Max(结帐id) As 结帐id, Max(是否退款) As 是否退款,
                 Max(是否打印) As 是否打印, Max(记录状态) As 记录状态, f_List2str(Cast(Collect(收据费目) As t_Strlist)) As 收据费目,
                 Max(挂号单) As 挂号单
                
                From (Select 记录性质, NO, 收据费目, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额,
                              To_Char(Max(登记时间), 'yyyy-mm-dd hh24:mi:ss') As 收款时间, Max(结帐id) As 结帐id,
                              Max(Decode(Nvl(a.执行状态, 0), 1, 0, 1)) As 是否退款, Max(Decode(a.实际票号, Null, 0, 1)) 是否打印,
                              Max(a.记录状态) As 记录状态, Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', ''))) As 挂号单
                       From 门诊费用记录 A, Table(f_Str2list2(v_No, '|', ',')) B
                       Where a.No = b.C1 And a.记录性质 = b.C2 And 记录状态 In (1, 3)
                       Group By 记录性质, NO, 收据费目
                       Order By 记录性质, NO, 收据费目)
                Group By 记录性质, NO) Loop
    n_Temp := 0;
    If n_结算卡类别id <> 0 Then
      Begin
        Select 交易流水号, 1
        Into v_交易流水号, n_Temp
        From 病人预交记录
        Where 卡类别id = n_结算卡类别id And 结帐id = Nvl(c_收费单.结帐id, 0);
      Exception
        When Others Then
          n_Temp := 0;
      End;
    
    End If;
    Begin
      Select Count(*) Into n_补结算 From 费用补充记录 Where 收费结帐id = Nvl(c_收费单.结帐id, 0) And Rownum < 2;
    Exception
      When Others Then
        n_补结算 := 0;
    End;
  
    Select Decode(Nvl(Count(*), 0), 0, 0, 1)
    Into n_医保结算
    From 保险结算记录
    Where 性质 = 1 And 记录id = Nvl(c_收费单.结帐id, 0);
  
    n_允许退款 := Nvl(c_收费单.是否退款, 0);
    n_已开医嘱 := 0;
  
    If c_收费单.挂号单 Is Not Null Then
      Begin
        Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = c_收费单.挂号单;
      Exception
        When Others Then
          n_已开医嘱 := 0;
      End;
      If Nvl(n_已开医嘱, 0) = 1 Then
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_已开医嘱, 0) = 1 Then
      v_说明 := '挂号单已开医嘱';
    Elsif Nvl(n_允许退款, 0) = 0 Then
      v_说明 := '单据已经执行';
    End If;
    If Nvl(n_医保结算, 0) = 1 Then
      v_说明     := '单据已经医保结算';
      n_允许退款 := 0;
    End If;
    If Nvl(n_补结算, 0) <> 0 Then
      v_说明     := '单据已经补充结算';
      n_允许退款 := 0;
      n_医保结算 := 1;
    
    End If;
  
    If Nvl(n_允许退款, 0) = 1 Then
      --检查是否有可退数量
      Select Decode(Nvl(Count(*), 0), 0, 0, 1)
      Into n_允许退款
      From (Select 序号, Sum(Nvl(付数, 0) * 数次) As 数量
             From 门诊费用记录 A
             Where NO = c_收费单.No And Mod(记录性质, 10) = c_收费单.记录性质 And 价格父号 Is Null Having Sum(Nvl(付数, 0) * 数次) <> 0
             Group By 序号);
      If Nvl(c_收费单.记录状态, 0) = 3 And n_允许退款 = 0 Then
        v_说明     := '单据已全退';
        n_允许退款 := 0;
      Elsif Nvl(c_收费单.记录状态, 0) = 3 Then
        v_说明     := '单据已部分退费';
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_允许退款, 0) = 1 And Nvl(c_收费单.是否打印, 0) = 1 Then
      v_说明     := '单据已开发票';
      n_允许退款 := 0;
    End If;
  
    v_Temp := '<DJH>' || c_收费单.No || '</DJH>';
    v_Temp := v_Temp || '<JLXZ>' || c_收费单.记录性质 || '</JLXZ>';
    v_Temp := v_Temp || '<YSJE>' || c_收费单.应收金额 || '</YSJE>';
    v_Temp := v_Temp || '<SSJE>' || c_收费单.实收金额 || '</SSJE>';
    v_Temp := v_Temp || '<FYMC>' || c_收费单.收据费目 || '</FYMC>';
    v_Temp := v_Temp || '<FKSJ>' || c_收费单.收款时间 || '</FKSJ>';
    v_Temp := v_Temp || '<JSKZF>' || n_Temp || '</JSKZF>';
    v_Temp := v_Temp || '<JYLSH>' || Nvl(v_交易流水号, '') || '</JYLSH>';
    v_Temp := v_Temp || '<YXTK>' || Nvl(n_允许退款, 0) || '</YXTK>';
    v_Temp := v_Temp || '<YBJS>' || n_医保结算 || '</YBJS>';
    v_Temp := v_Temp || '<KP>' || Nvl(c_收费单.是否打印, 0) || '</KP>';
    v_Temp := v_Temp || '<JZTFSM>' || v_说明 || '</JZTFSM>';
  
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
  
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Paymentinfo;
/

--82620:刘兴洪,2015-03-11,收费轧帐按收费类别轧帐
Create Or Replace Procedure Zl_收费员轧帐记录_Cancel
(
  Id_In       In 人员收缴记录.Id%Type,
  作废人_In   In 人员收缴记录.作废人%Type,
  作废时间_In In 人员收缴记录.作废时间%Type
) Is
  --------------------------------------------------------------------------------------------
  --功能:收费员轧帐记录作废
  --------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;

  n_Count    Number(18);
  v_No       人员收缴记录.No%Type;
  n_收款     Number(2);
  d_截止时间 人员收缴记录.终止时间%Type;
  v_收款员   人员收缴记录.收款员%Type;
  n_类别     人员收缴记录.类别%Type;
Begin
  --并发检查,是否当前时间范围内已经有轧帐记录
  Begin
    Select NO, 收款员, Decode(小组收款时间, Null, 0, 1) + Decode(财务收款时间, Null, 0, 1), 类别
    Into v_No, v_收款员, n_收款, n_类别
    From 人员收缴记录
    Where ID = Id_In;
  Exception
    When Others Then
      v_No := Null;
  End;
  If v_No Is Null Then
    v_Err_Msg := '未找到需要作废的轧帐记录,请检查！';
    Raise Err_Item;
  End If;

  --检查是否最后一次轧帐记录
  Select Count(*)
  Into n_Count
  From 人员收缴记录
  Where 登记时间 > (Select 登记时间 From 人员收缴记录 Where ID = Id_In) And 记录性质 = 1 And ID + 0 <> Id_In And Rownum < 2 And
        收款员 || '' = v_收款员 And 作废时间 Is Null And Instr(',0,' || n_类别 || ',', ',' || Nvl(类别, 0) || ',') > 0;

  If n_Count >= 1 Then
    --是不是最后一次的轧帐记录
    v_Err_Msg := '轧帐单号为:' || v_No || '的轧帐记录不是你最后一次的轧帐记录,不允许作废!';
    Raise Err_Item;
  End If;

  Update 人员收缴记录 Set 作废人 = 作废人_In, 作废时间 = 作废时间_In Where ID = Id_In And 作废时间 Is Null;
  If Sql%NotFound Then
    v_Err_Msg := '轧帐单号为:' || v_No || '的轧帐记录已经被他人作废,不允许再作废操作!';
    Raise Err_Item;
  End If;
  Insert Into 人员收缴对照
    (收缴id, 性质, 记录id)
    Select Id_In, 8, 记录id From 人员收缴对照 Where 收缴id = Id_In And 性质 = 7;
  --恢复最后一次有效的轧帐时间
  Select Max(终止时间)
  Into d_截止时间
  From 人员收缴记录
  Where 登记时间 <= (Select 登记时间 From 人员收缴记录 Where ID = Id_In) And ID + 0 <> Id_In And 作废时间 Is Null And 收款员 || '' = v_收款员;
  If d_截止时间 Is Null Then
    --取上岗领用备用金的时间
    Select Min(登记时间)
    Into d_截止时间
    From 人员暂存记录
    Where 收款员 = v_收款员 And 记录性质 = 1 And 收回时间 Is Null;
  End If;
  Update 人员缴款余额 Set 上次轧帐时间 = d_截止时间 Where 收款员 = v_收款员 And 性质 = 1;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费员轧帐记录_Cancel;
/

--82620:刘兴洪,2015-03-19,收费轧帐按收费类别轧帐
Create Or Replace Function Zl_Rollingcurtain_Lastdate
(
  收款员_In 人员收缴记录.收款员%Type,
  类别_In   人员收缴记录.类别%Type
) Return Date Is
  d_规零时间 Date;
  d_终止时间 Date;

Begin
  --------------------------------------------------------------------------------
  --功能:获取指定用户的最后一次有效的轧帐时间
  --入参:类别_In:0-所有类别(按全额轧帐),1-收费,2-预交,3-结帐,4-挂号,5-就诊卡
  --     收款员_IN:具体的收费人员
  --获取规则:
  --    1.如果当前按指定类别轧帐时,则按下规则处理(以终止时间为准):
  --      1) 如果存在有效的轧帐记录时
  --          a)如果当前轧帐人员不存在所有类别的轧帐记录的,则以最后一次轧帐时间为准
  --          b)如果当前轧帐人员存在所有类别的轧帐记录且最后一次轧帐记录的终止时间>当前类别的最后一次轧帐记录的终卡时间的,则以所有类别的最后一次轧帐记录的终止时间为准
  --          c)如果当前轧帐人员存在所有类别的轧帐记录且最后一次轧帐记录的终止时间<当前类别的最后一次轧帐记录的终卡时间的,则以当前类别的最后一次轧帐记录的终卡时间为准
  --      2)如果不存在有效轧帐记录时
  --          a)如果当前轧帐人员存在按所有类别轧帐的有效记录时,则以最后一次轧帐记录的终止时间为准
  --          b)如果不存在按所有类别轧帐的有效记录时,按下面的3以下规则处理
  --    2.如果当前按所有类别轧帐时,则按以下规则处理
  --          a)如果存在按所有类别轧帐的有效记录时,则以最后一次轧帐记录的终止时间为准
  --          b)如果不存在按所有类别轧帐的有效记录时,按下面的3以下规则处理
  --    3.如果存在轧帐规零记录,则以轧帐规零记录的登记时间为准
  --    4.未轧过的,缺省为领取备用金时间
  --    5.如果未领用备用金的,返回NULL,由界面处理(缺省时间为当前时间-1个月的且允许更改上次转帐时间)
  --------------------------------------------------------------------------------

  Select Max(Decode(记录性质, 6, 登记时间, Null)), Max(Decode(记录性质, 1, 终止时间, Null))
  Into d_规零时间, d_终止时间
  From 人员收缴记录 A
  Where 收款员 = 收款员_In And 作废时间 Is Null And
        (记录性质 = 6 Or ((a.记录性质 = 1 And Nvl(类别, 0) = 0) Or (a.记录性质 = 1 And Nvl(类别, 0) = Nvl(类别_In, 0))));
  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;
  If d_规零时间 Is Not Null Then
    Return d_规零时间;
  End If;

  --取备用金的时间
  Select Min(领用时间)
  Into d_终止时间
  From 人员暂存记录
  Where 收款员 = 收款员_In And (记录性质 = 1 Or 记录性质 = 11) And 收回时间 Is Null;
  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;

  --当前时间减少1个月
  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;

  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Rollingcurtain_Lastdate;
/

--83072:刘尔旋,2015-03-11,自定义标识获取
Create Or Replace Procedure Zl_Third_Custom_Findcards
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取医疗卡类别(用户自定义）
  --入参:Xml_In:
  --  <IN>
  --       <SFZ>身份证号</SFZ >不传入时,表示查询全部启用的医疗卡类别ID
  --  </IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --    <LIST>
  --        <JZK>
  --            <LB>卡类别</LB>
  --            <KH>卡号</KH>
  --        </JZK>
  --        <JZK>
  --            ...
  --        </JZK>
  --    </LIST>
  --    如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
Begin
  Null;
Exception
  When Others Then
    Null;
End Zl_Third_Custom_Findcards;
/

--83258:刘尔旋,2015-03-25,自定义函数默认返回值
--83072:刘尔旋,2015-03-11,自定义获取病人标识
Create Or Replace Function Zl_Third_Custom_Getpati
(
  卡类别_In Varchar2,
  卡号_In   Varchar2
) Return Number As
  --------------------------------------------------------------------------------------------------
  --功能:获取病人ID(用户自定义）
  --入参:
  --  卡类别_In : 卡类别名称
  --  卡号_In   : 卡号
  --返回:病人ID
  --------------------------------------------------------------------------------------------------
Begin
  Return 0;
End;
/

--82950:刘尔旋,2015-03-10,新增退费检查接口
Create Or Replace Procedure Zl_Third_Registdelcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号检查
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP'))
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
  If v_Type = 'Num' Then
    --传入的是卡类别ID
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
  Else
    --传入的是卡类别名称
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
  End If;
  --结算方式的判断，目前仅支持支付宝，后续扩展
  If Instr(v_结算方式, '支付宝') = 0 Or v_结算方式 Is Null Then
    v_Err_Msg := '目前三方退号过程暂不支持除支付宝以外的结算方式!';
    Raise Err_Item;
  End If;
  Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
  If n_实收金额 <> n_挂号金额 Then
    v_Err_Msg := '传入的退款金额与实际挂号金额不符，请检查!';
    Raise Err_Item;
  End If;
  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdelcheck;
/


--83258:刘尔旋,2015-03-23,退费检查接口性能问题
--82950:刘尔旋,2015-03-04,新增退费检查接口
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP'))
  Into n_病人id, n_退款总额, v_摘要, n_检查发票
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--83020:刘尔旋,2015-03-10,时段信息过短的问题
CREATE OR REPLACE Procedure Zl_挂号计划时段_Insert
(
	计划id_In 挂号计划时段.计划id%Type,
	星期_In   挂号计划时段.星期%Type,
	时段_In   Varchar2,
	应用于_In Number := 0
)
--时段_IN:序号,开始时间,结束时间,限制数量,预约标志|...
 As
	v_Err_Msg Varchar2(100);
	Err_Item Exception;
	v_时段     Varchar2(5000);
	n_序号     挂号计划时段.序号%Type;
	d_开始时间 挂号计划时段.开始时间%Type;
	d_结束时间 挂号计划时段.结束时间%Type;
	n_限制数量 挂号计划时段.限制数量%Type;
	n_是否预约 挂号计划时段.是否预约%Type;
	v_当前序号 Varchar2(100);
Begin
	--检查是否存在挂号计划时段信息
	v_时段 := 时段_In || ' |';
	While v_时段 Is Not Null Loop
		v_当前序号 := Substr(v_时段, 1, Instr(v_时段, '|') - 1);
		n_序号     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		d_开始时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'hh24:mi:ss');
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		d_结束时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'hh24:mi:ss');
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		n_限制数量 := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		n_是否预约 := To_Number(v_当前序号);
		Update 挂号计划时段
		Set 序号 = n_序号, 开始时间 = d_开始时间, 结束时间 = d_结束时间, 限制数量 = n_限制数量, 是否预约 = n_是否预约
		Where 计划id = 计划id_In And 星期 = 星期_In And 序号 = n_序号;
		If Sql% Notfound Then
			Insert Into 挂号计划时段　
				(计划id, 序号, 星期, 开始时间, 结束时间, 是否预约, 限制数量) 　
			Values
				(计划id_In, n_序号, 星期_In, d_开始时间, d_结束时间, n_是否预约, n_限制数量);
		End If;
		v_时段 := Substr(v_时段, Instr(v_时段, '|') + 1);
	End Loop;
	If Nvl(应用于_In, 0) = 1 Then
		Null; --本医生
	Elsif Nvl(应用于_In, 0) = 2 Then
		Null;
		--本科室
	Elsif Nvl(应用于_In, 0) = 3 Then
		Null;
		--所有
	End If;
Exception
	When Err_Item Then
		Raise_Application_Error(-20101, v_Err_Msg);
	When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号计划时段_Insert;
/

--83020:刘尔旋,2015-03-10,时段字符长度过短的问题
CREATE OR REPLACE Procedure Zl_挂号安排时段_Insert
(
	安排id_In 挂号安排时段.安排id%Type,
	星期_In   挂号安排时段.星期%Type,
	时段_In   Varchar2,
	应用于_In Number := 0
)
--时段_IN:序号,开始时间,结束时间,限制数量,预约标志|...
 As
	v_Err_Msg Varchar2(100);
	Err_Item Exception;
	v_时段     Varchar2(5000);
	n_序号     挂号安排时段.序号%Type;
	d_开始时间 挂号安排时段.开始时间%Type;
	d_结束时间 挂号安排时段.结束时间%Type;
	n_限制数量 挂号安排时段.限制数量%Type;
	n_是否预约 挂号安排时段.是否预约%Type;
	v_当前序号 Varchar2(100);
Begin
	--检查是否存在挂号安排时段信息
	v_时段 := 时段_In || ' |';
	While v_时段 Is Not Null Loop
		v_当前序号 := Substr(v_时段, 1, Instr(v_时段, '|') - 1);
		n_序号     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		d_开始时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'hh24:mi:ss');
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		d_结束时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'hh24:mi:ss');
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		n_限制数量 := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
		v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
		n_是否预约 := To_Number(v_当前序号);
		Update 挂号安排时段
		Set 序号 = n_序号, 开始时间 = d_开始时间, 结束时间 = d_结束时间, 限制数量 = n_限制数量, 是否预约 = n_是否预约
		Where 安排id = 安排id_In And 星期 = 星期_In And 序号 = n_序号;
		If Sql% Notfound Then
			Insert Into 挂号安排时段　
				(安排id, 序号, 星期, 开始时间, 结束时间, 是否预约, 限制数量) 　
			Values
				(安排id_In, n_序号, 星期_In, d_开始时间, d_结束时间, n_是否预约, n_限制数量);
		End If;
		v_时段 := Substr(v_时段, Instr(v_时段, '|') + 1);
	End Loop;
	If Nvl(应用于_In, 0) = 1 Then
		Null; --本医生
	Elsif Nvl(应用于_In, 0) = 2 Then
		Null;
		--本科室
	Elsif Nvl(应用于_In, 0) = 3 Then
		Null;
		--所有
	End If;
Exception
	When Err_Item Then
		Raise_Application_Error(-20101, v_Err_Msg);
	When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号安排时段_Insert;
/

--82768:曾超,2015-03-09,支持分钟
Create Or Replace Function Zl_Get_Reference
(
  Type_In       In Number, --0=参考 1=参考ID 2=危急参考 3=危急参考下限 4=危急参考上限 
  项目id_In     In Number,
  标本类型_In   In Varchar2,
  性别_In       In Number,
  出生日期_In   In Date,
  仪器id_In     In Number := Null,
  年龄_In       In Varchar2 := Null,
  申请科室id_In In Number := Null
) Return Varchar2 As

  Cursor V_Reference_Type Is
    Select A.Id,
           Trim(To_Char(A.参考低值, C.格式)) || '～' || Trim(To_Char(A.参考高值, C.格式)) ||
            Decode(A.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || A.临床特征) As 结果参考, B.结果类型, B.取值序列,
           Trim(To_Char(A.警示下限, C.格式)) || '～' || Trim(To_Char(A.警示上限, C.格式)) ||
            Decode(A.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || A.临床特征) As 危急参考, A.警示下限, A.警示上限, Nvl(B.多参考, 0) 多参考
    From 检验项目参考 A, 检验项目 B,
         (Select '9999990' ||
                   Decode(Max(Nvl(C.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式

           From 检验仪器项目 C, 检验项目 D
           Where D.诊治项目id = 项目id_In And D.诊治项目id = C.项目id(+)) C
    Where A.项目id = 项目id_In And A.项目id = B.诊治项目id;

  V_Return Varchar2(4000);
  V_Sql    Varchar2(4000);

  Type C_Type Is Ref Cursor; --声明REF游标类型 
  R_Emp V_Reference_Type%Rowtype; --声明一个行类型变量 
  Cur   C_Type; --声明REF游标类型的变量 

  V_结果类型 Number(1);

  V_年数     Number(18);
  V_月数     Number(18);
  V_日数     Number(18);
  V_小时     Number(18);
  V_出生日期 Date;
  V_Pos      Number(4);
  V_多参考   Number(4);
  V_Value    Number(18);
  V_Valuerec Varchar2(255);
  V_年龄     Varchar2(50);
  V_结果参考 Varchar2(1000);
  V_参考id   Number(18);
  V_危紧参考 Varchar2(1000);
  V_警示下限 Varchar2(1000);
  V_警示上限 Varchar2(1000);
  D_Sysdate  Date;

  V_项目id_Bound   检验项目参考.项目id%Type;
  V_标本类型_Bound 检验项目参考.标本类型%Type;
  V_性别域1_Bound  检验项目参考.性别域%Type;
  V_性别域2_Bound  检验项目参考.性别域%Type;
  V_性别域3_Bound  检验项目参考.性别域%Type;
  V_仪器id_Bound   检验项目参考.仪器id%Type;

  V_年龄单位日_Bound   检验项目参考.年龄单位%Type;
  V_年龄单位月_Bound   检验项目参考.年龄单位%Type;
  V_年龄单位小时_Bound 检验项目参考.年龄单位%Type;
  V_年龄单位年_Bound   检验项目参考.年龄单位%Type;

  V_年龄单位日1_Bound   检验项目参考.年龄单位%Type;
  V_年龄单位月1_Bound   检验项目参考.年龄单位%Type;
  V_年龄单位小时1_Bound 检验项目参考.年龄单位%Type;
  V_年龄单位年1_Bound   检验项目参考.年龄单位%Type;

  V_临床特征_Bound   检验项目参考.临床特征%Type;
  V_申请科室id_Bound 检验项目参考.申请科室id%Type;

  Function Sub_Is_Number(V_In In Varchar2) Return Boolean Is
    N_Tmp Number;
  Begin
    N_Tmp := To_Number(V_In);
    If N_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;

  Function Zlsplit
  (
    V_Str       In Varchar2,
    V_Delimiter In Varchar2,
    V_Number    In Number
  ) Return Varchar2 Is
    V_Record     Varchar2(1000);
    V_Currrecord Varchar2(1000);
    V_Currnum    Number;
  Begin
    V_Record  := V_Str || V_Delimiter;
    V_Currnum := 0;
    While V_Record Is Not Null Loop
      V_Currrecord := Substr(V_Record, 1, Instr(V_Record, V_Delimiter) - 1);
      If V_Currnum = V_Number Then
        Return(V_Currrecord);
      End If;
    
      V_Currnum := V_Currnum + 1;
      V_Record  := Replace(V_Delimiter || V_Record, V_Delimiter || V_Currrecord || V_Delimiter);
    End Loop;
  
    Return('');
  End Zlsplit;
  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar(10);
  Begin
    Strnum := '';
    For Intbit In 1 .. 10 Loop
      If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
        Exit;
      End If;
      Strnum := Strnum || Substr(Vstr, Intbit, 1);
      Null;
    End Loop;
    Result := To_Number(Strnum);
    Return(Result);
  End Zlval;

Begin
  D_Sysdate := Sysdate;

  V_Sql := ' Select a.id,Trim(To_Char(A.参考低值, C.格式)) || ''～'' || Trim(To_Char(A.参考高值, C.格式)) || ' ||
           ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 结果参考, B.结果类型, B.取值序列, ' ||
           ' Trim(To_Char(A.警示下限, C.格式)) || ''～'' || Trim(To_Char(A.警示上限, C.格式)) || ' || ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 危急参考,a.警示下限,a.警示上限,
             nvl(b.多参考,0) 多参考 ' || ' From 检验项目参考 A, 检验项目 B, ' || ' (Select ''9999990'' || ' ||
           ' Decode(Max(Nvl(C.小数位数, -1)), 0, '''', -1, ''.00'', Substr(''.000000'', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式 ' ||
           ' From 检验仪器项目 C, 检验项目 D ' || ' Where D.诊治项目ID = :项目ID And D.诊治项目ID = C.项目ID(+)) C ' ||
           ' Where A.项目ID = :项目ID And A.项目ID = B.诊治项目ID ';

  V_项目id_Bound := 项目id_In;

  V_年龄 := 年龄_In;
  If V_年龄 = '岁' Then
    V_年龄 := Null;
  End If;

  If V_年龄 = '月' Then
    V_年龄 := Null;
  End If;

  If V_年龄 = '小时' Then
    V_年龄 := Null;
  End If;

  If V_年龄 = '天' Then
    V_年龄 := Null;
  End If;

  If Nvl(标本类型_In, '') <> '' Or 标本类型_In Is Not Null Then
    V_Sql := V_Sql || ' And A.标本类型 = :标本类型 ';
  Else
    V_Sql := V_Sql || ' And (A.标本类型 = :标本类型 or 1=1) ';
  End If;
  V_标本类型_Bound := 标本类型_In;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    --V_Sql := V_Sql || ' And A.性别域 = Nvl(' || 性别_In || ', 1) '; 
    V_Sql := V_Sql || ' And decode(A.性别域,null,:性别,0,:性别,A.性别域) = Nvl(:性别, 1) ';
  
  Else
    V_Sql := V_Sql || ' And (decode(A.性别域,null,:性别1,0,:性别2,A.性别域) = Nvl(:性别3, 1) or 1 = 1) ';
  End If;
  V_性别域1_Bound := 性别_In;
  V_性别域2_Bound := 性别_In;
  V_性别域3_Bound := 性别_In;

  If Nvl(仪器id_In, '') <> '' Or 仪器id_In Is Not Null Then
    V_Sql := V_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null) ';
  Else
    V_Sql := V_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null or 1=1) ';
  End If;
  V_仪器id_Bound := 仪器id_In;

  If Nvl(V_年龄, '') <> '' Or V_年龄 Is Not Null Then
    If Instr(V_年龄, '岁') > 0 Or Instr(V_年龄, '月') > 0 Or Instr(V_年龄, '天') > 0 Or Instr(V_年龄, '小时') > 0 Or
       Sub_Is_Number(V_年龄) Then
      --处理日期 
      V_出生日期 := 出生日期_In;
      V_年龄     := V_年龄;
      If Instr(V_年龄, '岁') > 0 Then
        V_年龄 := Substr(V_年龄, 1, Instr(V_年龄, '岁'));
      Elsif Instr(V_年龄, '月') > 0 Then
        V_年龄 := Substr(V_年龄, 1, Instr(V_年龄, '月'));
      Elsif Instr(V_年龄, '小时') > 0 Then
        V_年龄 := Substr(V_年龄, 1, Instr(V_年龄, '小时') + 1);
      End If;
      If V_年龄 Is Not Null And (V_年龄 = '成人' Or V_年龄 = '婴儿' Or V_年龄 = '岁') = False Then
        If Substr(V_年龄, 1, 1) = '*' Then
          V_出生日期 := Add_Months(D_Sysdate, -216);
        Else
          If Substr(V_年龄, Length(V_年龄)) = '月' Then
            V_出生日期 := Add_Months(D_Sysdate, -1 * Nvl(Zlval(V_年龄), 0));
          Else
            If Substr(V_年龄, Length(V_年龄)) = '天' Then
              V_出生日期 := D_Sysdate - Nvl(Zlval(V_年龄), 0);
            Else
              If Substr(V_年龄, Length(V_年龄) - 1) = '小时' Then
                If Nvl(Zlval(V_年龄), 0) <> 0 Then
                  V_出生日期 := D_Sysdate - Nvl(Zlval(V_年龄), 0) / 24;
                End If;
              Else
                V_出生日期 := Add_Months(D_Sysdate, -12 * Nvl(Zlval(V_年龄), 0)) - 1;
              End If;
            End If;
          End If;
        End If;
      End If;
      If Not (V_出生日期 Is Null) Then
        V_年数 := Round(Months_Between(D_Sysdate, V_出生日期) / 12 - 0.5);
        V_月数 := Round(Months_Between(D_Sysdate, V_出生日期) - 0.5);
        V_日数 := Round(D_Sysdate - V_出生日期 - 0.5);
        V_小时 := Round((D_Sysdate - (V_出生日期 - 1 / 24)) * 24 - 1);
      End If;
      V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;
  
  Else
    V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  V_年龄单位日_Bound   := V_日数;
  V_年龄单位月_Bound   := V_月数;
  V_年龄单位小时_Bound := V_小时;
  V_年龄单位年_Bound   := V_年数;
  If Instr(V_年龄, '成人') > 0 Or Instr(V_年龄, '婴儿') > 0 Or Instr(V_年龄, '分钟') > 0 Then
    --处理成人和婴儿 
    V_Sql := V_Sql || ' And A.临床特征 =:年龄';
  Else
    V_Sql := V_Sql || ' And (A.临床特征 =:年龄 or 1=1)';
    V_Sql := V_Sql || ' And instr(''婴儿,成人'',nvl(临床特征,'' '')) <= 0  ';
  End If;

  V_临床特征_Bound := Replace(V_年龄, '分钟', '婴儿');

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    V_Sql := V_Sql || ' And (A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) ';
  Else
    V_Sql := V_Sql || ' And ((A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) or 1=1) ';
  End If;
  V_申请科室id_Bound := 申请科室id_In;

  If (Nvl(V_年龄, '') = '' Or V_年龄 Is Null) And (出生日期_In <> '' Or 出生日期_In Is Not Null) Then
    --按出生日期查询 
    If Not (出生日期_In Is Null) Then
      V_年数 := Round(Months_Between(D_Sysdate, 出生日期_In) / 12 - 0.5);
      V_月数 := Round(Months_Between(D_Sysdate, 出生日期_In) - 0.5);
      V_日数 := Round(D_Sysdate - 出生日期_In - 0.5);
      V_小时 := Round((D_Sysdate - (出生日期_In - 1 / 24)) * 24 - 1);
    
      V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;
  
  Else
    V_Sql := V_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  V_年龄单位日1_Bound   := V_日数;
  V_年龄单位月1_Bound   := V_月数;
  V_年龄单位小时1_Bound := V_小时;
  V_年龄单位年1_Bound   := V_年数;

  --加上排序 
  V_Sql := V_Sql || ' Order By a.默认 desc,A.临床特征 ';

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    V_Sql := V_Sql || ' ,a.申请科室ID  ';
  End If;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    V_Sql := V_Sql || ' ,a.性别域 desc  ';
  Else
    V_Sql := V_Sql || ' ,a.性别域 ';
  End If;

  V_Sql := V_Sql || ' ,a.id ';

  V_Return := '';
  Open Cur For V_Sql
    Using V_项目id_Bound, V_项目id_Bound, V_标本类型_Bound, V_性别域1_Bound, V_性别域2_Bound, V_性别域3_Bound, V_仪器id_Bound, V_年龄单位日_Bound, V_年龄单位月_Bound, V_年龄单位小时_Bound, V_年龄单位年_Bound, V_临床特征_Bound, V_申请科室id_Bound, V_年龄单位日1_Bound, V_年龄单位月1_Bound, V_年龄单位小时1_Bound, V_年龄单位年1_Bound;

  Loop
    Fetch Cur
      Into R_Emp;
    Exit When Cur%NotFound;
    If Cur%Rowcount > 0 Then
    
      V_结果类型 := R_Emp.结果类型;
      V_Valuerec := R_Emp.取值序列;
      V_参考id   := R_Emp.Id;
      V_多参考   := R_Emp.多参考;
    
      If Nvl(V_Return, '') = '' Or V_Return Is Null Then
        If Type_In = 2 Then
          V_Return := R_Emp.危急参考;
        Else
          V_Return := R_Emp.结果参考;
        End If;
      Else
        If Type_In = 2 Then
          V_Return := V_Return || Chr(13) || Chr(10) || R_Emp.危急参考;
        Else
          If V_多参考 = 1 Then
            V_Return := V_Return || Chr(13) || Chr(10) || R_Emp.结果参考;
          End If;
        End If;
      End If;
    
      --只增加第一个选出的警示参考 
      If V_警示下限 = '' Or V_警示下限 Is Null Then
        V_警示下限 := R_Emp.警示下限;
      End If;
      If V_警示上限 = '' Or V_警示上限 Is Null Then
        V_警示上限 := R_Emp.警示上限;
      End If;
    End If;
  End Loop;

  If V_Return = '' Or V_Return Is Null Then
    Begin
      Select 结果参考, 结果类型, 取值序列, ID, 危急参考, 警示下限, 警示上限
      Into V_结果参考, V_结果类型, V_Valuerec, V_参考id, V_危紧参考, V_警示下限, V_警示上限
      From (Select A.Id,
                    Trim(To_Char(A.参考低值, C.格式)) || '～' || Trim(To_Char(A.参考高值, C.格式)) ||
                     Decode(A.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || A.临床特征) As 结果参考, B.结果类型, B.取值序列,
                    Trim(To_Char(A.警示下限, C.格式)) || '～' || Trim(To_Char(A.警示上限, C.格式)) ||
                     Decode(A.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || A.临床特征) As 危急参考, A.警示下限, A.警示上限
             From 检验项目参考 A, 检验项目 B,
                  (Select '9999990' ||
                            Decode(Max(Nvl(C.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式
                    From 检验仪器项目 C, 检验项目 D
                    Where D.诊治项目id = 项目id_In And D.诊治项目id = C.项目id(+)) C
             Where A.项目id = 项目id_In And A.项目id = B.诊治项目id
             Order By A.默认 Desc, A.临床特征, A.性别域)
      Where Rownum = 1;
      If Type_In = 2 Then
        V_Return := V_危紧参考;
      Else
        V_Return := V_结果参考;
      End If;
      --只增加第一个选出的警示参考 
      If V_警示下限 = '' Or V_警示下限 Is Null Then
        V_警示下限 := R_Emp.警示下限;
      End If;
      If V_警示上限 = '' Or V_警示上限 Is Null Then
        V_警示上限 := R_Emp.警示上限;
      End If;
    Exception
      When Others Then
        V_Return := Null;
    End;
  End If;
  If V_Return <> '' Or V_Return Is Not Null Then
  
    If V_Return = '～' Then
      V_Return := '';
    Else
      If V_结果类型 = 2 Then
        V_Pos := Instr(V_Return, '～');
      
        Begin
          Select To_Number(Substr(V_Return, 1, V_Pos - 1)) Into V_Value From Dual;
        Exception
          When Others Then
            V_Value := 0;
        End;
        V_Return := Zlsplit(V_Valuerec, ';', V_Value);
      End If;
    End If;
    If Type_In = 0 Then
      Return V_Return;
    Elsif Type_In = 1 Then
      Return V_参考id;
    Elsif Type_In = 2 Then
      Return V_Return;
    Elsif Type_In = 3 Then
      Return V_警示下限;
    Elsif Type_In = 4 Then
      Return V_警示上限;
    End If;
  End If;
  Close Cur; --关闭游标 
  Return V_Return;
End Zl_Get_Reference;
/

--82736:张德婷,2015-03-06,输液配置中心增加审核原因
CREATE OR REPLACE Procedure Zl_病人医嘱记录_SaveReason
(
  医嘱id_In   In 病人医嘱记录.id%Type,
  药师审核原因_In   In 病人医嘱记录.药师审核原因%Type
) Is
Begin
  update 病人医嘱记录 set 药师审核原因=药师审核原因_In where id=医嘱id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_SaveReason;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_医保结算校对_Update
(
  结帐id_In   门诊费用记录.结帐id%Type,
  保险结算_In Varchar2
) As
  --功能:处理医保结算的校对数据
  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_组id       财务缴款分组.Id%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --1.取预交记录需要的相关信息
  Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id
  From 门诊费用记录
  Where 结帐id = 结帐id_In And Rownum = 1 And 记录性质 = 1;

  --回退汇总表
  --只可能产生误差金额的变化,其它的不会变,并且只可能存在一行,仅为了变量处理方便而用游标

  --删除收费结算,保险结算记录
  Delete 病人预交记录 A
  Where 结帐id = 结帐id_In And 记录性质 = 3 And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称　and 性质 In (3, 4)) Or 结算方式 Is Null;

  --2.保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, v_病人id, Null, '保险结算', v_结算方式, v_收款时间, v_操作员编号, v_操作员姓名, v_结算金额, 结帐id_In,
           n_组id, 2, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --3.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医保结算校对_Update;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_医保收费异常_Update
(
  Nos_In          Varchar2,
  更新结算方式_In Integer := 0
) As
  Err_Custom Exception;
  v_Error    Varchar2(255);
  d_Date     Date;
  n_结算序号 Number(18);
  n_结帐金额 门诊费用记录.结帐金额%Type;
Begin
  --功能：更新医保收费的异常单据的登记时间;结算序号
  --更新结算方式_In:0-更新;1-不更新
  d_Date     := Sysdate;
  n_结算序号 := Null;
  For v_医保 In (Select /*+ rule */
                a.结帐id, c.结算序号, Max(Decode(c.结算序号, c.结帐id, Decode(更新结算方式_In, 1, 0, 1), 0)) As 序号, Max(a.操作员编号) As 操作员编号,
                Max(a.操作员姓名) As 操作员姓名
               From 门诊费用记录 A, Table(f_Str2list(Nos_In)) B, 病人预交记录 C
               Where a.No = b.Column_Value And a.记录性质 = 1 And a.记录状态 = 1 And Nvl(a.执行状态, 0) = 9 And a.结帐id = c.结帐id(+)
               Group By a.结帐id, c.结算序号
               Order By 序号, 结帐id) Loop
  
    If n_结算序号 Is Null Then
      If Nvl(v_医保.结帐id, 0) = Nvl(v_医保.结算序号, 0) Then
        Select 病人结帐记录_Id.Nextval Into n_结算序号 From Dual;
      Else
        n_结算序号 := v_医保.结帐id;
      End If;
    End If;
    Update 病人预交记录 Set 结算序号 = n_结算序号, 收款时间 = d_Date Where 结帐id = v_医保.结帐id;
    Update 门诊费用记录 Set 实际票号 = Null, 登记时间 = d_Date Where 结帐id = v_医保.结帐id;
    If Nvl(更新结算方式_In, 0) = 1 Then
      Select Sum(Nvl(冲预交, 0)) Into n_结帐金额 From 病人预交记录 Where 结帐id = v_医保.结帐id;
      Update 病人预交记录 Set 冲预交 = n_结帐金额 Where 结算方式 Is Null And 结帐id = v_医保.结帐id;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
           预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号, 结帐id, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 3, 1, 病人id, 主页id, 科室id, Null, Null, Null, Null, d_Date, v_医保.操作员编号,
                 v_医保.操作员姓名, Null, Null, Null, 缴款组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号, v_医保.结帐id, n_结算序号, 3
          From 病人预交记录
          Where 结帐id = v_医保.结帐id And Rownum = 1;
      
      End If;
      Delete 病人预交记录 Where 结算方式 Is Not Null And 结帐id = v_医保.结帐id;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医保收费异常_Update;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_门诊收费记录_重收
(
  原结帐id_In     门诊费用记录.结帐id%Type,
  冲销id_In       门诊费用记录.结帐id%Type,
  重收结帐id_In   门诊费用记录.结帐id%Type,
  排开医保结算_In Varchar2 := Null
) As
  --排开医保结算_IN:多个用逗号分离(只某些医保结算,允许退现金)
  Cursor c_Fee_Data Is
    Select ID
    From 门诊费用记录 A
    Where 结帐id = 原结帐id_In And Not Exists
     (Select 1
           From 门诊费用记录 B
           Where Mod(b.记录性质, 10) = 1 And a.No = b.No And a.序号 = b.序号 And 结帐id = 冲销id_In)
    Order By ID;

  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_缴款组id   门诊费用记录.缴款组id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  Err_Item Exception;
  v_Err_Msg    Varchar2(255);
  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  n_结算金额   门诊费用记录.实收金额%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_Count      Number(18);
  v_误差费     结算方式.名称%Type;

Begin
  Begin
    Select 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id
    Into v_操作员编号, v_操作员姓名, d_登记时间, n_缴款组id, n_病人id
    From 门诊费用记录
    Where 结帐id = 冲销id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := 'NO';
  End;

  Begin
    Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
  Exception
    When Others Then
      v_误差费 := '误差费';
  End;

  If Nvl(v_Err_Msg, '-') = 'NO' Then
    v_Err_Msg := '由于并发操作,该单据可能已经初他人退费或删除,不能再进行退费操作！';
    Raise Err_Item;
  End If;

  --1.处理界面选择的且是部分退或部分执行的
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位,
     付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态, 执行时间,
     操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
           收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
           执行人, 执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
           缴款组id
    From (Select NO, Max(实际票号) As 实际票号, 11 As 记录性质, 1 As 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式,
                  费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 1 As 付数, Max(发药窗口) As 发药窗口, Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次,
                  Max(加班标志) As 加班标志, Max(附加标志) As 附加标志, 收入项目id, 收据费目, 记帐费用, Avg(标准单价) As 标准单价, Sum(应收金额) As 应收金额,
                  Sum(实收金额) As 实收金额, 开单部门id, 开单人, 执行部门id, Max(划价人) As 划价人, Max(执行人) 执行人, Max(执行状态) As 执行状态, 1 As 费用状态,
                  Max(执行时间) 执行时间, v_操作员编号 As 操作员编号, v_操作员姓名 As 操作员姓名, 发生时间, d_登记时间 As 登记时间, 重收结帐id_In As 结帐id,
                  Sum(结帐金额) As 结帐金额, Max(保险项目否) As 保险项目否, 保险大类id, Sum(统筹金额) As 统筹金额,
                  Max(Decode(记录性质, 1, 摘要, 11, 摘要, Null)) As 摘要, Max(是否上传) As 是否上传, Max(保险编码) As 保险编码, Max(费用类型) As 费用类型,
                  Max(Decode(记录性质, 1, 结论, 11, 结论, Null)) As 结论, n_缴款组id As 缴款组id
           From 门诊费用记录
           Where Mod(记录性质, 10) = 1 And (NO, 序号) In (Select NO, 序号 From 门诊费用记录 Where 结帐id = 冲销id_In)
           Group By NO, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 收入项目id,
                    收据费目, 记帐费用, 开单部门id, 开单人, 执行部门id, 发生时间, 保险大类id
           Having Sum(Nvl(付数, 1) * Nvl(数次, 0)) <> 0);

  For c_冲销 In (Select NO, 序号, 从属父号, 价格父号, 收入项目id, -1 * Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次, Sum(标准单价) As 标准单价,
                      -1 * Sum(应收金额) As 应收金额, -1 * Sum(实收金额) As 实收金额, -1 * Sum(统筹金额) As 统筹金额, -1 * Sum(结帐金额) As 结帐金额
               From 门诊费用记录
               Where 记录性质 = 11 And 结帐id = 重收结帐id_In
               Group By NO, 序号, 从属父号, 价格父号, 收入项目id) Loop
    Update 门诊费用记录
    Set 数次 = Nvl(数次, 0) + Nvl(c_冲销.数次, 0), 实收金额 = Nvl(实收金额, 0) + Nvl(c_冲销.实收金额, 0),
        应收金额 = Nvl(应收金额, 0) + Nvl(c_冲销.应收金额, 0), 结帐金额 = Nvl(结帐金额, 0) + Nvl(c_冲销.结帐金额, 0),
        统筹金额 = Nvl(统筹金额, 0) + Nvl(c_冲销.统筹金额, 0)
    Where NO = c_冲销.No And 序号 = c_冲销.序号 And Nvl(从属父号, -1) = Nvl(c_冲销.从属父号, '-1') And
          Nvl(价格父号, -1) = Nvl(c_冲销.价格父号, '-1') And 收入项目id = c_冲销.收入项目id And 结帐id = 冲销id_In;
  End Loop;

  --2.处理界面未选退费部分,需要全退且产生11的重收记录
  Open c_Fee_Data;
  Loop
    Fetch c_Fee_Data Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --退费记录
    Forall I In 1 .. t_费用id.Count
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
         计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态,
         执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
        Select 病人费用记录_Id.Nextval, a.No, a.实际票号, 1, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
               a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志,
               a.收入项目id, a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, 执行人,
               Nvl(q.执行状态, -1) As 执行状态, 1, a.执行时间, v_操作员编号, v_操作员姓名, a.发生时间, d_登记时间, 冲销id_In, -1 * a.结帐金额, a.保险项目否,
               a.保险大类id, -1 * a.统筹金额, a.摘要, a.是否上传, a.保险编码, a.费用类型, a.结论, n_缴款组id As 缴款组id
        From 门诊费用记录 A,
             (Select j.No, j.序号, Nvl(Max(j.执行状态), 0) - 1 As 执行状态
               From 门诊费用记录 M, 门诊费用记录 J
               Where m.Id = t_费用id(I) And m.No = j.No And m.序号 = j.序号 And Mod(j.记录性质, 10) = 1 And j.记录状态 = 2
               Group By j.No, j.序号) Q
        Where ID = t_费用id(I) And a.No = q.No(+) And a.序号 = q.序号(+);
  
    --将原记录状态由1变为3
    Forall I In 1 .. t_费用id.Count
      Update 门诊费用记录 Set 记录状态 = 3 Where ID = t_费用id(I) And 记录状态 = 1;
  
    --重新收费记录
    If Nvl(重收结帐id_In, 0) <> 0 Then
      Forall I In 1 .. t_费用id.Count
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 11, 1, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
                 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id,
                 划价人, 执行人, 执行状态, 1, 执行时间, v_操作员编号, v_操作员姓名, 发生时间, d_登记时间, 重收结帐id_In, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传,
                 保险编码, 费用类型, 结论, n_缴款组id As 缴款组id
          From 门诊费用记录
          Where ID = t_费用id(I);
    End If;
  End Loop;
  Close c_Fee_Data;

  Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null;
  If n_Count = 0 Then
    --退费结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
             -1 * 冲销id_In, 2, 3
      From 病人预交记录
      Where 结帐id = 原结帐id_In And 结算方式 In (Select 名称 From 结算方式 Where 性质 In (3, 4)) And
            Instr(',' || 排开医保结算_In || ',', ',' || 结算方式 || ',') = 0 And Mod(记录性质, 10) <> 1;
    --将原误差费全部退了
    --Insert Into 病人预交记录
    --  (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志)
    --  Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
    --         -1 * 冲销id_In, 2
    --  From 病人预交记录
    --  Where 结帐id = 原结帐id_In And 结算方式 = v_误差费 And Mod(记录性质, 10) <> 1;
  
    Select Sum(冲预交) Into n_冲销金额 From 病人预交记录 Where 结帐id = 冲销id_In;
    Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 冲销id_In;
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, -1 * (Nvl(n_冲销金额, 0) - Nvl(n_结算金额, 0)),
       冲销id_In, n_缴款组id, -1 * 冲销id_In, 1, 3);
  
  End If;
  If Nvl(重收结帐id_In, 0) <> 0 Then
    Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 重收结帐id_In And 结算方式 Is Null;
    If n_Count = 0 Then
      Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 重收结帐id_In;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额, 重收结帐id_In, n_缴款组id,
         -1 * 冲销id_In, 1, 3);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_重收;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_病人门诊收费_医保更新
(
  结帐id_In   门诊费用记录.结帐id%Type,
  结算序号_In 病人预交记录.结算序号%Type,
  保险结算_In Varchar2
) As
  --功能:重新更新保险结算,分摊到指定的单据上 
  --保险结算_In:为空时,表示只更新预交的标志(以预结算和结算一样时,才会使用此方式) 
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     病人预交记录.缴款组id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式   病人预交记录.结算方式%Type;
  n_结算金额   病人预交记录.冲预交%Type;
  n_剩余额     病人预交记录.冲预交%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  d_Date       门诊费用记录.登记时间%Type;
  v_No         门诊费用记录.No%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_Dec        Number;
  n_单价小数   Number;
  n_结算序号   病人预交记录.结算序号%Type;
Begin

  If 保险结算_In Is Null Then
    --预结算和结算一致时,才会只更新标志 
    If Nvl(结帐id_In, 0) <> 0 Then
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结帐id = 结帐id_In And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4));
    Else
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结算序号 = 结算序号_In And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4));
    End If;
    Return;
  End If;

  If Nvl(结帐id_In, 0) <> 0 Then
    Select a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
    Into v_No, v_操作员编号, v_操作员姓名, n_病人id, d_Date, n_组id, n_结算序号
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.结帐id = 结帐id_In And Rownum = 1;
  Else
    Select a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
    Into v_No, v_操作员编号, v_操作员姓名, n_病人id, d_Date, n_组id, n_结算序号
    From 病人预交记录 B, 门诊费用记录 A
    Where b.结帐id = a.结帐id And b.结算序号 = 结算序号_In And Rownum = 1;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  If Nvl(结帐id_In, 0) <> 0 Then
    --检查是否有结算方式为空的记录 
    Update 病人预交记录 Set 冲预交 = Null Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, Null, Null, d_Date, v_操作员编号, v_操作员姓名, 0, 结帐id_In, n_组id, n_结算序号, 1, 3);
    End If;
    --删除所有医保结算数据(其他结算方式不删除) 
    Delete 病人预交记录 A
    Where 结帐id = 结帐id_In And 结算方式 Is Not Null And Exists
     (Select 1 From 结算方式 Where 性质 In (3, 4) And a.结算方式 = 名称);
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
  End If;

  If Nvl(结算序号_In, 0) <> 0 Then
    For v_结算 In (Select Distinct a.结帐id, a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
                 From 病人预交记录 B, 门诊费用记录 A
                 Where b.结帐id = a.结帐id And b.结算序号 = 结算序号_In) Loop
      --检查是否有结算方式为空的记录 
      Update 病人预交记录 Set 冲预交 = Null Where 结帐id = v_结算.结帐id And 结算方式 Is Null;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_结算.No, 1, n_病人id, Null, Null, v_结算.登记时间, v_结算.操作员编号, v_结算.操作员姓名, 0, v_结算.结帐id,
           v_结算.缴款组id, n_结算序号, 1, 3);
      End If;
      --删除所有医保结算数据(其他结算方式不删除) 
      Delete 病人预交记录 A
      Where 结帐id = v_结算.结帐id And 结算方式 Is Not Null And Exists
       (Select 1 From 结算方式 Where 性质 In (3, 4) And a.结算方式 = 名称);
      Update 保险结算明细 Set 标志 = 2 Where 结帐id = v_结算.结帐id;
    End Loop;
  End If;

  --各个保险结算 
  v_结算内容 := 保险结算_In || '||';
  While v_结算内容 Is Not Null Loop
    v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(结帐id_In, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, '保险结算', v_结算方式, d_Date, v_操作员编号, v_操作员姓名, n_结算金额, 结帐id_In, n_组id,
           n_结算序号, 2, 3);
      Else
      
        n_剩余额 := Nvl(n_结算金额, 0);
        For v_收费 In (Select b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, Max(b.登记时间) As 登记时间,
                            Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                     From 门诊费用记录 B,
                          (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                            From 病人预交记录
                            Where 结算序号 = 结算序号_In
                            Group By 结帐id) A
                     Where b.结帐id = a.结帐id
                     Group By b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名
                     Having Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) <> 0
                     Order By 结帐id, NO) Loop
          If Nvl(v_收费.结帐金额, 0) >= Nvl(n_剩余额, 0) Then
            n_结算金额 := Nvl(n_剩余额, 0);
            n_剩余额   := 0;
          Else
            n_结算金额 := Nvl(v_收费.结帐金额, 0);
            n_剩余额   := Nvl(n_剩余额, 0) - Nvl(v_收费.结帐金额, 0);
          End If;
          n_结帐id     := v_收费.结帐id;
          n_病人id     := v_收费.病人id;
          v_操作员编号 := v_收费.操作员编号;
          v_操作员姓名 := v_收费.操作员姓名;
          d_Date       := v_收费.登记时间;
          v_No         := v_收费.No;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, v_收费.No, 1, v_收费.病人id, '保险结算', v_结算方式, v_收费.登记时间, v_收费.操作员编号, v_收费.操作员姓名, n_结算金额,
             v_收费.结帐id, n_组id, n_结算序号, 2, 3);
          If Nvl(n_剩余额, 0) = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
    End If;
  
    If Nvl(n_剩余额, 0) <> 0 And Nvl(n_结帐id, 0) <> 0 Then
      --返回的金额为零了,所以将剩下部分放在最后一张单据中 
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) + n_剩余额 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, '保险结算', v_结算方式, d_Date, v_操作员编号, v_操作员姓名, n_剩余额, n_结帐id, n_组id,
           n_结算序号, 2, 3);
      End If;
    End If;
    v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
  End Loop;

  --更新结算方式=NULL 的冲预交 
  If Nvl(结帐id_In, 0) <> 0 Then
    For v_收费 In (Select Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                 From 门诊费用记录 B,
                      (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                        From 病人预交记录
                        Where 结帐id = 结帐id_In
                        Group By 结帐id) A
                 Where b.结帐id = a.结帐id Having Sum(Nvl(b.结帐金额, 0)) - Nvl(Max(a.冲预交), 0) <> 0) Loop
    
      Update 病人预交记录 Set 冲预交 = Nvl(v_收费.结帐金额, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, Null, Null, d_Date, v_操作员编号, v_操作员姓名, Nvl(v_收费.结帐金额, 0), n_结帐id,
           n_组id, n_结算序号, 1, 3);
      End If;
    End Loop;
  
  Else
    For v_收费 In (Select b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, b.登记时间,
                        Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                 From 门诊费用记录 B,
                      (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                        From 病人预交记录
                        Where 结算序号 = 结算序号_In
                        Group By 结帐id) A
                 Where b.结帐id = a.结帐id
                 Group By b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, b.登记时间
                 Having Sum(Nvl(b.结帐金额, 0)) - Nvl(Max(a.冲预交), 0) <> 0
                 Order By 结帐id, NO) Loop
      Update 病人预交记录
      Set 冲预交 = Nvl(v_收费.结帐金额, 0)
      Where 结帐id = Nvl(v_收费.结帐id, 0) And 结算方式 Is Null;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_收费.No, 1, v_收费.病人id, Null, Null, v_收费.登记时间, v_收费.操作员编号, v_收费.操作员姓名,
           Nvl(v_收费.结帐金额, 0), v_收费.结帐id, n_组id, n_结算序号, 1, 3);
      End If;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人门诊收费_医保更新;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_结帐缴款记录_Insert
(
  No_In         病人结帐记录.No%Type,
  病人id_In     病人预交记录.病人id%Type,
  主页id_In     病人预交记录.主页id%Type,
  科室id_In     病人预交记录.科室id%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  结算号码_In   病人预交记录.结算号码%Type,
  金额_In       病人预交记录.冲预交%Type,
  结帐id_In     病人预交记录.结帐id%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  收费时间_In   病人预交记录.收款时间%Type,
  保险类别_In   保险帐户.险类%Type,
  保险帐号_In   保险帐户.医保号%Type,
  保险密码_In   保险帐户.密码%Type,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null
) As
  -----------------------------------------------------------
  --功能：处理一行病人结帐时的缴款记录
  --参数：
  --  NO_IN=结帐单相同的NO.
  -----------------------------------------------------------
  n_返回值 人员缴款余额.余额%Type;
  n_组id   财务缴款分组.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id,
     缴款, 找补, 缴款组id, 结算性质)
  Values
    (病人预交记录_Id.Nextval, No_In, Null, 2, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
     Decode(科室id_In, 0, Null, 科室id_In), Null, 结算方式_In, 结算号码_In, '结帐缴款', Decode(保险类别_In, 0, Null, 保险类别_In), 保险密码_In,
     保险帐号_In, 收费时间_In, 操作员编号_In, 操作员姓名_In, 金额_In, 结帐id_In, 缴款_In, 找补_In, n_组id, 2);

  --处理人员缴款余额
  Update 人员缴款余额
  Set 余额 = Nvl(余额, 0) + 金额_In
  Where 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And 性质 = 1
  Returning 余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 金额_In);
    n_返回值 := 金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐缴款记录_Insert;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_简单收费误差_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  误差金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.登记时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  退费_In       Number := 0
) As
  --功能:处理门诊简单收费的误差费
  v_误差费 结算方式.名称%Type;
  n_组id   财务缴款分组.Id%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  If Nvl(误差金额_In, 0) = 0 Then
    Return;
  End If;
  Begin
    Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
  Exception
    When Others Then
      v_误差费 := '误差费';
  End;

  n_组id := Zl_Get组id(操作员姓名_In);

  --处理病人预交记录
  Update 病人预交记录
  Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
  Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
  If Sql%NotFound Then
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, No_In, Decode(退费_In, 0, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), v_误差费, 发生时间_In, 操作员编号_In,
       操作员姓名_In, Nvl(误差金额_In, 0), 结帐id_In, n_组id, 3);
  End If;
  --处理人员缴款余额
  Update 人员缴款余额
  Set 余额 = Nvl(余额, 0) + Nvl(误差金额_In, 0)
  Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_误差费;
  If Sql%NotFound Then
    Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_误差费, 1, Nvl(误差金额_In, 0));
  End If;
  --删除冲预交为零的误差项
  Delete From 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 = v_误差费 And Nvl(冲预交, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_简单收费误差_Insert;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_病人挂号补结算_Delete
(
  单据号_In     门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  冲销id_In     门诊费用记录.结帐id%Type := Null,
  结算序号_In   病人预交记录.结算序号%Type := Null,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  删除门诊号_In Number := 0
) As
  --该游标用于判断是否单独收病历费,及挂号汇总表处理

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id   病人预交记录.结帐id%Type;
  n_冲销id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;

  n_病人id   病人信息.病人id%Type;
  n_退费金额 病人预交记录.冲预交%Type;
  n_挂号id   病人挂号记录.Id%Type;
  n_组id     财务缴款分组.Id%Type;

  n_分诊台签到排队 Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_病人id1        病人信息.病人id%Type;
  d_Temp           Date;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --首先判断要退号/取消预约的记录是否存在

  Begin
    Select a.结帐id, a.病人id
    Into n_结帐id, n_病人id
    From 门诊费用记录 A
    Where a.记录性质 = 4 And a.No = 单据号_In And a.记录状态 = 1 And Rownum < 2;
  Exception
  
    When Others Then
      n_病人id := -1;
  End;
  If Nvl(n_病人id, 0) = -1 Then
    v_Err_Msg := '未找到指定的挂号单:' || 单据号_In || ',可能已经被人退号,不允许再次退号。';
    Raise Err_Item;
  End If;

  --2.挂号处理

  d_Date     := 退号时间_In;
  n_冲销id   := 冲销id_In;
  n_结算序号 := 结算序号_In;

  If d_Date Is Null Then
    d_Date := Sysdate;
  End If;
  If n_冲销id Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_冲销id From Dual;
  End If;

  If n_结算序号 Is Null Then
    n_结算序号 := -1 * n_冲销id;
  End If;
  --更新挂号序号状态
  If Zl_To_Number(Zl_Getsysparameter('已退序号允许挂号', 1111)) = 1 Then
    Delete 挂号序号状态
    Where 状态 = 1 And
          (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
          (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
  Else
    Update 挂号序号状态
    Set 状态 = 4
    Where 状态 = 1 And
          (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
          (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
  End If;

  --病人就诊状态
  If n_病人id Is Not Null Then
    Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理(界面要根据提示来删除)
    If 删除门诊号_In = 1 Then
      Delete 门诊病案记录 Where 病人id = n_病人id;
      Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
      --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
      Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
    End If;
  End If;

  --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
  n_病人id1 := Null;
  Begin
    Select 病人id
    Into n_病人id1
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
  Exception
    When Others Then
      Null;
  End;
  If n_病人id1 Is Not Null Then
    Update 病人信息
    Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
    Where 病人id = n_病人id1;
  End If;

  --门诊费用记录
  --冲销记录
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
     数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
     结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态, 执行状态)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
           收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
           操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_冲销id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要 As 摘要, 附加标志, 保险编码, 费用类型,
           n_组id, 1, 1
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;

  Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  Select Sum(实收金额) Into n_退费金额 From 门诊费用记录 Where 结帐id = n_冲销id;
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 结算序号, 缴款组id, 预交类别, 卡类别id,
     结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算性质)
    Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, Null, d_Date, 操作员编号_In, 操作员姓名_In,
           n_退费金额, n_冲销id, n_结算序号, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 1, 4
    From 病人预交记录 A
    Where a.记录性质 = 4 And a.结帐id = n_结帐id And Rownum = 1;
  If Sql%NotFound Then
    v_Err_Msg := '未找到挂号单为【' || 单据号_In || '】的原始挂号记录!';
    Raise Err_Item;
  End If;
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;

  --病人挂号汇总
  For c_挂号 In (Select a.收费细目id, a.发生时间, a.登记时间, c.接收时间, c.执行部门id, c.执行人, m.Id As 医生id, Nvl(c.号别, b.号码) As 号码, a.结帐id,
                      a.病人id, Decode(c.预约, Null, 0, 0, 0, 1) As 预约
               From 门诊费用记录 A, 病人挂号记录 C, 挂号安排 B, 人员表 M
               Where a.记录性质 = 4 And a.结帐id = n_冲销id And a.从属父号 Is Null And c.执行人 = m.姓名(+) And a.No = c.No And
                     Nvl(c.号别, Nvl(a.计算单位, '-')) = b.号码 And Nvl(a.附加标志, 0) = 0 And Rownum < 2) Loop
    --退非挂号费用,则不处理汇总表数据
  
    If Nvl(c_挂号.预约, 0) <> 0 Then
      d_Temp := Trunc(c_挂号.接收时间);
    Else
      d_Temp := Trunc(c_挂号.发生时间);
    End If;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - Nvl(c_挂号.预约, 0), 已约数 = Nvl(已约数, 0) - Nvl(c_挂号.预约, 0)
    Where 日期 = d_Temp And 科室id = c_挂号.执行部门id And 项目id = c_挂号.收费细目id And Nvl(医生姓名, '医生') = Nvl(c_挂号.执行人, '医生') And
          Nvl(医生id, 0) = Nvl(c_挂号.医生id, 0) And (号码 = c_挂号.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (d_Temp, c_挂号.执行部门id, c_挂号.收费细目id, c_挂号.执行人, Decode(c_挂号.医生id, 0, Null, c_挂号.医生id), c_挂号.号码, -1,
         -1 * Nvl(c_挂号.预约, 0), -1 * Nvl(c_挂号.预约, 0));
    End If;
  End Loop;

  n_挂号生成队列 := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
  If n_挂号生成队列 <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(Zl_Getsysparameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
  End If;

  --医保产生的就诊登记记录
  Delete From 就诊登记记录
  Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
  --病人挂号记录
  Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;

  Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
  If Sql%NotFound Then
    v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
    Raise Err_Item;
  End If;

  Insert Into 病人挂号记录
    (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名, 复诊,
     号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
    Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间, 操作员编号_In,
           操作员姓名_In, 复诊, 号序, 社区, 预约, 摘要 As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 = 3;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号补结算_Delete;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_费用补充记录_补结算作废
(
  No_In         In 费用补充记录.No%Type,
  冲销id_In     In 费用补充记录.结算id%Type,
  结算序号_In   In 费用补充记录.结算序号%Type,
  操作员编号_In In 费用补充记录.操作员编号%Type,
  操作员姓名_In In 费用补充记录.操作员姓名%Type,
  登记时间_In   In 费用补充记录.登记时间%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_Date     Date;
  n_组id     财务缴款分组.Id%Type;
  n_结算id   费用补充记录.结算id%Type;
  n_费用状态 费用补充记录.费用状态%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  n_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    n_Date := Sysdate;
  End If;

  v_Err_Msg := Null;
  Begin
    Select 结算id, 费用状态
    Into n_结算id, n_费用状态
    From 费用补充记录
    Where 记录性质 = 1 And NO = No_In And 记录状态 = 1 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '未找到结算单号为' || No_In || '的结算记录,可能已经被他人作废或重新结算,不允许再继续操作！';
  End;

  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;

  Update 费用补充记录 Set 记录状态 = 3 Where 结算id = n_结算id;

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
    Select 记录性质, NO, 2, 实际票号, 冲销id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名, n_Date As 登记时间,
           n_组id As 缴款组id, 病人id, 结算序号_In As 结算序号, 附加标志
    From 费用补充记录
    Where 结算id = n_结算id;

  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, 结算方式, n_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 冲预交, 冲销id_In As 结帐id, n_组id As 缴款组id, -1 * 冲销id_In As 结算序号, 2 As 校对标志, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
           结算号码, 6
    From 病人预交记录
    Where 结帐id = n_结算id;

  Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = n_结算id;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_补结算作废;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_费用补充结算_完成退费
(
  结算id_In     In 费用补充记录.结算id%Type,
  结算方式_In   Varchar2,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:补结算退费
  --   结算方式_IN:格式为:"结算方式|结算金额|结算号码|结算摘要" ;也允许传入空.
  --   三方卡结算:需传入卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  -- 误差金额_In:存在误差费时,传入
  ------------------------------------------------------------------------------------------------------------------------------

  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  v_误差费   结算方式.名称%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_当前结算 Varchar2(4000);
  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志
    From 费用补充记录 A
    Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  r_Balance  c_Balance%RowType;
  n_未退合计 病人预交记录.冲预交%Type;
  n_Count    Number(18);
Begin
  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
  
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6);
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) - Nvl(误差金额_In, 0)
    Where 结算方式 Is Null And 结帐id = 结算id_In;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, Null, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, -1 * 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         Null, Null, Null, Null, 6);
    End If;
  End If;

  Select Sum(Nvl(冲预交, 0))
  Into n_未退合计
  From 病人预交记录
  Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1;
  If Not 结算方式_In Is Null Then
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_未退合计, 0) <> -1 * Nvl(n_结算金额, 0) Then
      v_Err_Msg := '当前退款合计(' || Nvl(n_结算金额, 0) || ')与未退合计(' || Nvl(n_未退合计, 0) || ')不区配!';
      Raise Err_Item;
    End If;
  
    For c_结算 In (Select 结帐id, 记录性质, 记录状态, NO, Sum(Nvl(冲预交, 0)) As 结算金额
                 From 病人预交记录
                 Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1
                 Group By 结帐id, 记录性质, NO, 记录状态) Loop
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, c_结算.记录性质, c_结算.No, c_结算.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, c_结算.结算金额, c_结算.结帐id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
         卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, Mod(c_结算.记录性质, 10));
    
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) - Nvl(c_结算.结算金额, 0)
      Where 结算方式 Is Null And 结帐id = c_结算.结帐id;
    End Loop;
  End If;

  Select Sum(冲预交) Into n_冲预交 From 病人预交记录 Where 结帐id = r_Balance.结算序号;
  If Nvl(n_冲预交, 0) <> 0 Then
    v_Err_Msg := '医保结算数据与未退结算数据不匹配!';
    Raise Err_Item;
  End If;

  Delete From 病人预交记录
  Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1 And Nvl(冲预交, 0) = 0;

  --1.更新异常状态
  Update 门诊费用记录
  Set 费用状态 = 0
  Where Nvl(费用状态, 0) = 1 And 结帐id In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = r_Balance.结算序号);

  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能补他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志
  Update 病人预交记录 Set 校对标志 = 0 Where 结算序号 = r_Balance.结算序号;

  --3.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_完成退费;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_费用补充结算_Modify
(
  操作类型_In   Number,
  结算id_In     In 费用补充记录.结算id%Type,
  结算方式_In   Varchar2,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null,
  完成结算_In   Number := 0
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:保险补充结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通结算方式:
  --     结算方式_IN:允许传入多个,格式为:结算方式|结算金额|结算号码|结算摘要||.. ;也允许传入空.
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成补充结算;0-未完成补充结算;2-完成了异常作废
  ------------------------------------------------------------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  v_误差费   结算方式.名称%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  l_预交id   t_Numlist := t_Numlist();
  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(4000);
  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号

    From 费用补充记录 A
    Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  r_Balance c_Balance%RowType;

  n_Count Number(18);

Begin
  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6);
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - 误差金额_In Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --0.普通结算方式
  If Nvl(操作类型_In, 0) = 0 Then
    --各个收费结算 :格式为:结算方式|结算金额|结算号码|结算摘要||..
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
           r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
           卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6);
      
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --1.三方卡结算
  If Nvl(操作类型_In, 0) = 1 Then
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
         卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6);
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --2.医保结算
  If Nvl(操作类型_In, 0) = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结算id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
  
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    --先删除结算方式为空的记录
    Delete 病人预交记录 Where 结帐id = 结算id_In And 结算方式 Is Null;
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
    n_冲预交 := 0;
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '保险结算', v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, Nvl(n_结算金额, 0), r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null,
         Null, Null, Null, Null, Null, 6);
      n_冲预交 := n_冲预交 + Nvl(n_结算金额, 0);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
    --处理结算方式为NULL
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '', Null, r_Balance.登记时间,
       r_Balance.操作员编号, r_Balance.操作员姓名, -1 * n_冲预交, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 1, Null, Null,
       Null, Null, Null, Null, 6);
    --医保相关表的处理
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结算id_In;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  If Nvl(完成结算_In, 0) = 2 Then
    --1.更新校对标志
    Update 病人预交记录 Set 校对标志 = 0 Where NO = r_Balance.No;
    Update 费用补充记录 Set 费用状态 = 2 Where NO = r_Balance.No;
    If Sql%NotFound Then
      v_Err_Msg := '未找到医保补结算数据，可能被他人进行了作废操作!';
      Raise Err_Item;
    End If;
    Return;
  End If;

  Select Sum(冲预交) Into n_冲预交 From 病人预交记录 Where 结帐id = 结算id_In;
  If Nvl(n_冲预交, 0) <> 0 Then
    v_Err_Msg := '医保结算数据与退未结算数据不匹配!';
    Raise Err_Item;
  End If;

  Delete 病人预交记录 Where 结帐id = 结算id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结算id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --1.更新异常状态
  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能被他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志
  Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = 结算id_In;
  --3.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_Modify;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_费用补充记录_补结算
(
  No_In          In 费用补充记录.No%Type,
  实际票号_In    In 费用补充记录.实际票号%Type,
  结算id_In      In 费用补充记录.结算id%Type,
  结算序号_In    In 病人预交记录.结算序号%Type,
  收费结帐ids_In Varchar2,
  医保结算_In    Varchar2,
  操作员编号_In  In 费用补充记录.操作员编号%Type,
  操作员姓名_In  In 费用补充记录.操作员姓名%Type,
  登记时间_In    In 费用补充记录.登记时间%Type := Null,
  备注_In        In 费用补充记录.备注%Type := Null,
  附加标志_In    In 费用补充记录.备注%Type := Null,
  费用状态_In    In 费用补充记录.费用状态%Type := 0
) Is
  -- 医保结算_IN:允许传入多个,格式为:结算方式,结算金额|..
  Err_Item Exception;

  v_Err_Msg Varchar2(255);
  n_Date    Date;
  n_病人id  门诊费用记录.病人id%Type;
  n_组id    财务缴款分组.Id%Type;
  n_冲预交  病人预交记录.冲预交%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  n_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    n_Date := Sysdate;
  End If;
  Begin
    Select 病人id
    Into n_病人id
    From 门诊费用记录
    Where 结帐id In (Select Column_Value From Table(f_Num2list(收费结帐ids_In))) And Rownum < 2;
  Exception
    When Others Then
      n_病人id := Null;
  End;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '费用记录中存在未建档病人的费用,不允许继续操作！';
    Raise Err_Item;
  End If;

  If 医保结算_In Is Not Null Then
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
      Select 病人预交记录_Id.Nextval, 6, No_In, 1, n_病人id, Null, Null, 结算方式, n_Date, 操作员编号_In, 操作员姓名_In, 结算金额, 结算id_In, n_组id,
             结算序号_In, 2, Null, Null, Null, Null, Null, Null, 6
      From (Select C1 As 结算方式, To_Number(C2) As 结算金额 From Table(f_Str2list2(医保结算_In, '|', ',')));
  
    Select Sum(To_Number(C2)) Into n_冲预交 From Table(f_Str2list2(医保结算_In, '|', ','));
  End If;
  --增加结算方式为NULL
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质)
  Values
    (病人预交记录_Id.Nextval, 6, No_In, 1, n_病人id, Null, '', Null, n_Date, 操作员编号_In, 操作员姓名_In, -1 * n_冲预交, 结算id_In, n_组id,
     结算序号_In, 1, Null, Null, Null, Null, Null, Null, 6);

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 备注, 附加标志)
    Select 1, No_In, 1, 实际票号_In, 结算id_In, 结帐id, 费用状态_In, 操作员编号_In, 操作员姓名_In, n_Date, n_组id, n_病人id, 结算序号_In, 备注_In,
           附加标志_In
    From (Select Column_Value As 结帐id From Table(f_Num2list(收费结帐ids_In)));
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_补结算;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
Create Or Replace Procedure Zl_病人收费结算_预交_Del
(
  操作类型_In   Number,
  结算序号id_In 病人预交记录.结算序号%Type,
  结算方式_In   Varchar2,
  结算金额_In   病人预交记录.冲预交%Type
) As
  --功能:处理收费时,删除已经收费或冲预交的记录.
  --操作类型_In:0-正常收费;1-冲预交(结算方式为NULL,结算金额<>0)
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --过程变量
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_No         病人预交记录.No%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  d_收款时间   病人预交记录.收款时间%Type;
  n_病人id     病人预交记录.病人id%Type;
  n_组id       财务缴款分组.Id%Type;
  n_剩余未结   病人预交记录.冲预交%Type;
  t_预交id     t_Numlist := t_Numlist();

Begin
  --0.正式结算
  n_剩余未结 := 结算金额_In;
  If 操作类型_In = 0 Then
    For v_预交 In (Select a.Id, a.No, a.结帐id, 冲预交, 病人id, 收款时间, 操作员编号, 操作员姓名, 缴款组id, 卡类别id, 卡号, 结算卡序号, 交易流水号, 交易说明
                 From 病人预交记录 A
                 Where 结算序号 = 结算序号id_In And 结算方式 = 结算方式_In And Nvl(冲预交, 0) <> 0 And 记录性质 = 3 And 记录状态 = 1 And
                       Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0
                 Order By a.No) Loop
    
      Update 病人预交记录
      Set 冲预交 = 冲预交 + Nvl(v_预交.冲预交, 0)
      Where 结算方式 Is Null And NO = v_预交.No And 记录性质 = 3;
      n_剩余未结 := Nvl(n_剩余未结, 0) - Nvl(v_预交.冲预交, 0);
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_预交.No, 1, v_预交.病人id, Null, Null, Null, v_预交.收款时间, v_预交.操作员编号, v_预交.操作员姓名, v_预交.冲预交,
           v_预交.结帐id, v_预交.缴款组id, 结算序号id_In, 1, Null, Null, Null, Null, Null, Null, 3);
      End If;
      t_预交id.Extend;
      t_预交id(t_预交id.Count) := v_预交.Id;
    End Loop;
    If Nvl(n_剩余未结, 0) <> 0 Then
      v_Err_Msg := '结算方式为:' || 结算方式_In || '的结算金额不正确,不能删除,请检查!';
      Raise Err_Item;
    End If;
    --删除所有预交记录
    Forall I In 1 .. t_预交id.Count
      Delete From 病人预交记录 Where ID = t_预交id(I);
  End If;

  --1.冲预交
  If 操作类型_In = 1 Then
    For v_预交 In (Select a.Id, a.记录性质, a.No, a.结帐id, 冲预交, 病人id
                 From 病人预交记录 A
                 Where 结算序号 = 结算序号id_In And 记录性质 In (1, 11)
                 Order By a.No) Loop
    
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id
      Into v_No, n_病人id, d_收款时间, v_操作员编号, v_操作员姓名, n_组id
      From 门诊费用记录
      Where 结帐id = v_预交.结帐id And Rownum = 1 And 记录性质 = 1;
    
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(v_预交.冲预交, 0)
      Where 结算方式 Is Null And NO = v_No And 记录性质 = 3;
    
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, Null, Null, Null, d_收款时间, v_操作员编号, v_操作员姓名, v_预交.冲预交, v_预交.结帐id,
           n_组id, 结算序号id_In, 1, Null, Null, Null, Null, Null, Null, 3);
      End If;
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.冲预交, 0)
      Where 病人id = n_病人id And 类型 = 1 And 性质 = 1;
      If Sql%NotFound Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, Nvl(v_预交.冲预交, 0), 1);
      End If;
    
      If v_预交.记录性质 = 1 Then
        Update 病人预交记录 Set 冲预交 = Null, 结算序号 = Null, 结算性质 = Null Where ID = v_预交.Id;
      Else
        t_预交id.Extend;
        t_预交id(t_预交id.Count) := v_预交.Id;
      End If;
      n_剩余未结 := Nvl(n_剩余未结, 0) - Nvl(v_预交.冲预交, 0);
    
    End Loop;
    If Nvl(n_剩余未结, 0) <> 0 Then
      v_Err_Msg := '结算方式为:' || 结算方式_In || '的结算金额不正确,不能删除,请检查!';
      Raise Err_Item;
    End If;
  
    --删除所有预交记录
    Forall I In 1 .. t_预交id.Count
      Delete From 病人预交记录 Where ID = t_预交id(I);
    Return;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人收费结算_预交_Del;
/

--82528:马政,2015-03-05,收费价目调价审核改进
Create Or Replace Procedure Zl_收费调价记录_Insert
(
  Id_In         In 收费价目.Id%Type,
  原价id_In     In 收费价目.原价id%Type := Null,
  收费细目id_In In 收费价目.收费细目id%Type := Null,
  收入项目id_In In 收费价目.收入项目id%Type := Null,
  原价_In       In 收费价目.原价%Type := Null,
  现价_In       In 收费价目.现价%Type := Null,
  缺省价格_In   In 收费价目.缺省价格%Type := Null,
  附术收费率_In In 收费价目.附术收费率%Type := Null,
  加班加价率_In In 收费价目.加班加价率%Type := Null,
  调价说明_In   In 收费价目.调价说明%Type := Null,
  调价id_In     In 收费价目.调价id%Type := Null,
  填制人_In     In 收费调价记录.填制人%Type := Null,
  填制日期_in    in 收费调价记录.填制日期%type :=null,
  执行日期_In   In 收费价目.执行日期%Type := Null,
  变动原因_In   In 收费价目.变动原因%Type := 1,
  No_In         In 收费价目.No%Type := Null,
  序号_In       In 收费价目.序号%Type := 1
) Is
Begin
  Insert Into 收费调价记录
    (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 填制人,填制日期, 执行日期, 终止日期, NO, 序号,审核标志)
  Values
    (Id_In, 原价id_In, 收费细目id_In, 原价_In, 现价_In, 缺省价格_In, 收入项目id_In, 加班加价率_In, 附术收费率_In, 变动原因_In, 调价说明_In, 调价id_In, 填制人_In,填制日期_in,
     执行日期_In, To_Date('3000-01-01', 'yyyy-mm-dd'), No_In, 序号_In,0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费调价记录_Insert;
/

--82528:马政,2015-03-25,收费价目调价修正
Create Or Replace Procedure Zl_收费调价记录_Verify
(
  Id_In       In 收费调价记录.Id%Type,
  审核标志_In In 收费调价记录.审核标志%Type := 1,
  审核人_In   In 收费调价记录.审核人%Type := Null,
  审核日期_In In 收费调价记录.审核日期%Type := Null,
  说明_In     In 收费调价记录.说明%Type := Null
) Is
  Cursor c_收费调价记录 Is
    Select ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 加班加价率, 附术收费率, 变动原因, 调价说明, 调价id, 填制人 As 调价人, 执行日期, 终止日期, NO, 序号
    From 收费调价记录
    Where ID = Id_In And 审核标志 = 1;

  n_变价     Number;
  n_调价id   收费价目.调价id%Type;
  d_执行日期 收费调价记录.执行日期%Type;
Begin
  --先将原始的调价记录状态改变
  Update 收费调价记录
  Set 审核标志 = 审核标志_In, 审核人 = 审核人_In, 审核日期 = 审核日期_In, 说明 = 说明_In
  Where ID = Id_In And 审核标志 = 0;

  For r_收费调价 In c_收费调价记录 Loop
    If Sysdate - r_收费调价.执行日期 > 0 Then
      d_执行日期 := Sysdate;
      Update 收费调价记录 Set 执行日期 = d_执行日期, 审核日期 = Sysdate Where ID = r_收费调价.Id;
    Else
      d_执行日期 := r_收费调价.执行日期;
    End If;
  
    Select Nvl(是否变价, 0) Into n_变价 From 收费项目目录 Where ID = r_收费调价.收费细目id;
    If n_变价 = 0 Then
      --定价需要先停用原始的价格，然后再产生新的记录
      --由于停用原始价格是所有收入项目一起停用因此只需要停用一次即可
      Begin
        Select 1
        Into n_调价id
        From 收费价目
        Where 收费细目id = r_收费调价.收费细目id And 调价id = r_收费调价.调价id And Rownum <= 1;
      Exception
        When Others Then
          n_调价id := 0;
      End;
      If n_调价id = 0 Then
        Zl_收费价目_Stop(r_收费调价.收费细目id, d_执行日期 - 1 / (24 * 60 * 60));
      End If;
      Zl_收费价目_Insert(r_收费调价.Id, r_收费调价.原价id, r_收费调价.收费细目id, r_收费调价.收入项目id, r_收费调价.原价, r_收费调价.现价, r_收费调价.附术收费率,
                     r_收费调价.加班加价率, r_收费调价.调价说明, r_收费调价.调价id, r_收费调价.调价人, d_执行日期, r_收费调价.变动原因, r_收费调价.No, r_收费调价.序号,
                     r_收费调价.缺省价格);
    Else
      --时价直接修改原始记录即可
      Zl_收费价目_Update(r_收费调价.收费细目id, r_收费调价.收入项目id, r_收费调价.原价, r_收费调价.现价, r_收费调价.附术收费率, r_收费调价.加班加价率, r_收费调价.调价说明,
                     r_收费调价.调价id, r_收费调价.调价人, r_收费调价.缺省价格);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费调价记录_Verify;
/

--80712:胡俊勇,2015-03-05,输血医嘱执行核对
Create Or Replace Procedure Zl_病人医嘱执行_Finish
(
  医嘱id_In       病人医嘱执行.医嘱id%Type,
  发送号_In       病人医嘱执行.发送号%Type,
  阳性_In         病人医嘱发送.结果阳性%Type := Null,
  单独执行_In     Number := 0,
  操作员编号_In   人员表.编号%Type := Null,
  操作员姓名_In   人员表.姓名%Type := Null,
  执行部门id_In   门诊费用记录.执行部门id%Type := 0,
  检验项目记帐_In Number := 0
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态 
) Is
  Cursor C_Advice Is
    Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源, 标本部位, 开始执行时间, 病人id, 主页id, 执行科室id
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  R_Advice C_Advice%RowType;

  V_Date     Date;
  V_开始时间 Date;
  V_核对人   Varchar2(255);
  V_诊疗类别 诊疗项目目录.类别%Type;
  V_操作类型 诊疗项目目录.操作类型%Type;
  V_Temp     Varchar2(255);
  V_费用性质 病人医嘱发送.记录性质%Type;
  V_人员编号 人员表.编号%Type;
  V_人员姓名 人员表.姓名%Type;

Begin

  --如果启用了参数：输血和皮试医嘱执行后需要核对，则输血和皮试医嘱不自动完成 
  Select B.类别, B.操作类型
  Into V_诊疗类别, V_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where A.诊疗项目id = B.Id And A.Id = 医嘱id_In;

  If zl_GetSysParameter(186) = '1' Then
    If V_诊疗类别 = 'E' And V_操作类型 in ('1','8') Or V_诊疗类别 = 'K' Then
      Select Max(核对人) Into V_核对人 From 病人医嘱执行 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
      If V_核对人 Is Null Then
        Return;
      End If;
    End If;
  End If;
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    V_人员编号 := 操作员编号_In;
    V_人员姓名 := 操作员姓名_In;
  Else
    V_Temp     := Zl_Identity;
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1);
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1);
    V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1);
    V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1);
  End If;
  Select Sysdate Into V_Date From Dual;

  --执行状态 
  Open C_Advice;
  Fetch C_Advice
    Into R_Advice;
  Close C_Advice;

  If 检验项目记帐_In = 0 Then
    If (R_Advice.诊疗类别 = 'C' And R_Advice.相关id Is Not Null) Or R_Advice.诊疗类别 = 'D' Then
      If Nvl(单独执行_In, 0) = 1 Then
        --单个检验或检查项目 
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = V_人员姓名, 完成时间 = V_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        --一并的检验项目或多部位的检查项目 
        If R_Advice.诊疗类别 = 'D' Then
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = V_人员姓名, 完成时间 = V_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = R_Advice.组id Or 相关id = R_Advice.组id));
        Else
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = V_人员姓名, 完成时间 = V_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = R_Advice.相关id);
        End If;
      End If;
    Else
      --包含附加手术,检查部位,以及其它独立医嘱;麻醉和中药煎法是单独安排 
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = V_人员姓名, 完成时间 = V_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
      Where 发送号 + 0 = 发送号_In And
            医嘱id In (Select ID
                     From 病人医嘱记录
                     Where (ID = R_Advice.组id Or 相关id = R_Advice.组id) And 诊疗类别 = R_Advice.诊疗类别);
    End If;
  End If;
  If R_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into V_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    V_费用性质 := 1;
  End If;
  --检验自动完成采集
  If V_诊疗类别 = 'E' And V_操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set A.采样人 = Nvl(A.采样人, V_人员姓名), A.采样时间 = Nvl(A.采样时间, V_Date)
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = R_Advice.组id Or 相关id = R_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If V_费用性质 = 1 Then
    Zl_门诊医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, V_人员编号, V_人员姓名, R_Advice.组id, R_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, V_人员编号, V_人员姓名, R_Advice.组id, R_Advice.诊疗类别, 执行部门id_In);
  End If;

  If R_Advice.诊疗类别 = 'F' Then
    If Not R_Advice.标本部位 Is Null Then
      V_开始时间 := To_Date(R_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
    Else
      V_开始时间 := R_Advice.开始执行时间;
    End If;
    Zl_电子病历时机_Insert(R_Advice.病人id, R_Advice.主页id, 2, '手术', R_Advice.执行科室id, V_人员姓名, V_开始时间, V_Date);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Finish;
/

--82950:刘尔旋,2015-03-05,接口退号检查修改
Create Or Replace Procedure Zl_Third_Registdel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示取消挂号成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP'))
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
  If v_Type = 'Num' Then
    --传入的是卡类别ID
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
  Else
    --传入的是卡类别名称
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
  End If;

  Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;
  --获取操作员信息
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  Zl_三方机构挂号_Delete(v_No, v_交易流水号, '移动平台退号');

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdel;
/

--83258:刘尔旋,2015-03-23,退费过程性能问题
--82950:刘尔旋,2015-03-05,接口退费检查修改
Create Or Replace Procedure Zl_Third_Charge_Del
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费交易 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_结帐金额   门诊费用记录.结帐金额%Type;
  n_误差额     病人预交记录.冲预交%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  l_挂号单     t_Strlist := t_Strlist();
  v_挂号单     门诊费用记录.No%Type;
  n_检查发票   Number(3);
  n_是否打印   Number(3);

  n_消费卡id 消费卡目录.Id%Type;
  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);

  d_退费时间 病人预交记录.收款时间%Type;

  v_退费结算 Varchar2(2000);
  v_普通结算 Varchar2(4000);
  n_Temp     Number(18);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Procedure Third_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   2.三方卡退费结算:
    --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
    --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊退费结算_Modify(2, n_病人id, 冲销id_In, v_退费结算, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    
    Xmlexpned_In Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   4-消费卡结算:
    --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||
    --     ②退支票额_In:传入零
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --卡类别ID|卡号|消费卡ID|消费金额||.
    v_退费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 退款金额_In;
    Zl_门诊退费结算_Modify(4, n_病人id, 冲销id_In, v_退费结算, 0, Null, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP'))
  Into n_病人id, n_退款总额, v_摘要, n_检查发票
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --人员id,人员编号,人员姓名 
  v_Temp       := Zl_Identity(1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.先进行退费

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_冲销id, d_退费时间 From Dual;

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
    Begin
      Select 结算序号, 结帐id, 病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录
      Where 结帐id In (Select 结帐id
                     From 门诊费用记录
                     Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', '')))
      Into v_挂号单
      From 门诊费用记录
      Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
    Exception
      When Others Then
        v_挂号单 := Null;
    End;
    If Not v_挂号单 Is Null Then
      l_挂号单.Extend;
      l_挂号单(l_挂号单.Count) := v_挂号单;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    Zl_门诊收费记录_销帐(c_费用.单据号, v_操作员编码, v_操作员姓名, c_费用.退款序号, d_退费时间, v_摘要, n_冲销id);
    n_Count := n_Count + 1;
  End Loop;
  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.处理退费的结算信息

  n_结帐金额 := 0;

  --检查总金额是否正确 
  Select Sum(结帐金额) Into n_结帐金额 From 门诊费用记录 Where 结帐id = n_冲销id;

  n_误差额 := -1 * Nvl(n_结帐金额, 0) - Nvl(n_退款总额, 0);
  If Abs(n_误差额) > 1.00 Then
    v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
    Raise Err_Item;
  End If;

  --2.确定支付方式
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Third_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                               c_结算方式.Expend);
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Square_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                                c_结算方式.Expend);
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Zl_门诊退费结算_Modify(4, n_病人id, n_冲销id, Null, c_结算方式.退款金额, Null, Null, Null, Null, 0, 0, 0, 0);
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定指付方式，不允缴款!';
        Raise Err_Item;
      End If;
      --结算方式|结算金额|结算号码|结算摘要||..
      v_退费结算 := c_结算方式.结算方式 || '|' || c_结算方式.退款金额 || '| |' || Nvl(c_结算方式.摘要, '  ');
      v_普通结算 := Nvl(v_普通结算, '') || '||' || v_退费结算;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  --     ②退支票额_In:传入零
  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式!';
    Raise Err_Item;
  End If;

  --5.普通结算及完成结
  If v_普通结算 Is Not Null Then
    v_普通结算 := Substr(v_普通结算, 3);
  End If;
  Zl_门诊退费结算_Modify(1, n_病人id, n_冲销id, v_普通结算, 0, Null, Null, Null, Null, 0, 0, n_误差额, 2);

  If l_挂号单.Count <> 0 Then
  
    For I In 0 .. l_挂号单.Count Loop
      x_Templet := Xmltype('<IN></IN>');
      v_Temp    := '<GHDH>' || l_挂号单(I) || '</GHDH>';
      v_Temp    := v_Temp || '<JSKLB>' || 4 || '</JSKLB>';
      v_Temp    := v_Temp || '<GHJE>' || 0 || '</GHJE>';
    
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
    End Loop;
  Else
    Xml_Out := x_Templet;
  End If;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    --Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    --Xml_Out := x_Templet;
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Del;
/

--82819:胡俊勇,2015-03-03,医嘱单打印
Create Or Replace Procedure Zl_病人医嘱打印_Insert
(
  病人id_In     病人医嘱记录.病人id%Type,
  主页id_In     病人医嘱记录.主页id%Type,
  婴儿_In       病人医嘱记录.婴儿%Type,
  期效_In       病人医嘱记录.医嘱期效%Type,
  序号_In       病人医嘱记录.序号%Type,
  页号_In       病人医嘱打印.页号%Type,
  行号_In       病人医嘱打印.行号%Type,
  打印模式_In   Number,
  打给药方式_In Number,
  位置_In       Number,
  重整标记_In   Number,
  转科_In       Number,
  行数_In       Number,
  重整日期_In   病案主页.医嘱重整时间%Type := Null
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印 中，页号，行号同时产生，默认一条医嘱只占用一行。
  --参数：行数_In：报表医嘱单一页可以打多少行,打印模式_In：0-校对后打印，1-新开时打印。
  --      序号_In： 病人医嘱打印 表中的最后一条医嘱 页号_In，行号_In 是最后一条记录对应的页号和行号
  --      打给药方式_In：西药中成药的给药方法是否单独打一行，1－单独打一行，0－不打给药方式，
  --      位置_In：转科、出院、死亡医嘱打印位置，0-长期医嘱单上，1-临时医嘱单上，2-两者都打印。
  --      重整标记_In：是否打重整医嘱字样，1－要打，0－不打。转科_n：前一条打印记录是不是转科医嘱，用于判断是否换页打重开字样
  --      行数_In医嘱单报表的行数通常是28行。
) Is
  v_Max_Date Date;
  n_换页打   Number;
  n_打重开   Number;
  n_转科     Number;
  n_页号     Number;
  n_行号     Number;
Begin
  n_页号 := 页号_In;
  n_行号 := 行号_In;
  n_转科 := 转科_In;

  If 期效_In = 0 Then
    n_换页打 := Zl_To_Number(zl_GetSysParameter('重整和术后医嘱换页打印', 1254));
    n_打重开 := Zl_To_Number(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254));
  End If;

  If 重整日期_In Is Null Then
    v_Max_Date := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    v_Max_Date := 重整日期_In;
  End If;

  --插入重整医嘱，只插入一条
  If 重整标记_In = 1 Then
    --生成行号和页号
    If n_行号 = 行数_In Then
      n_行号 := 1;
      n_页号 := n_页号 + 1;
    Else
      n_行号 := n_行号 + 1;
    End If;
    If n_换页打 = 1 Then
      --如果行号为1说明已经是新的一页的第一行,否则换页
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    Insert Into 病人医嘱打印
      (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
    Values
      (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
  End If;

  --转科医嘱换页打医嘱重开字样
  If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
    If 重整标记_In = 1 Then
      --前面打了重整就不换页了
      If n_打重开 = 1 Then
        n_页号 := n_页号 + 1;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      End If;
    Else
      If n_打重开 = 1 Then
        --打重开字样
        If n_行号 = 行数_In Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        Else
          n_行号 := n_行号 + 1;
        End If;
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      Else
        --只是单纯换一页
        n_行号 := 0;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    n_转科 := 0;
  End If;

  --最近次重整后,需要打印的医嘱，考虑换页打印情况转科术后
  ---r_Print.换页 对特殊医嘱标记，4－术后，3－转科
  If v_Max_Date = To_Date('1900-01-01', 'YYYY-MM-DD') Then
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or 位置_In In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (位置_In = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (打印模式_In = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > 序号_In And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And nvl(i.操作类型,'0') Not In ('2', '3') Or
                                 i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 打给药方式_In = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      
        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱，
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  Else
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or 位置_In In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (位置_In = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (打印模式_In = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > 序号_In And Exists
                                               (Select 1
                                                     From 病人医嘱状态 C
                                                     Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or l.诊疗类别 = 'E' And nvl(i.操作类型,'0') Not In ('2', '3') Or
                                 i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 打给药方式_In = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      
        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱    
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--82668:曾超,2015-03-02,优化性能
CREATE OR REPLACE Function Zl_FUN_Get检验图像
(
  Key_In In number,
  Type_In In varchar2,
  Pos_In In Number
  --参数说明：
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
) Return Varchar2 Is
  l_Clob   Clob;
  v_Buffer Varchar2(2000);
  n_Amount Number := 2000;
  n_Offset Number := 1;
Begin

  SELECT 图像点 INTO l_Clob FROM  检验图像结果 WHERE 标本id = Key_In and 图像类型 = Type_In;

  n_Offset := n_Offset + Pos_In * n_Amount;
  Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
  Return v_Buffer;
Exception
  When Others Then
    Return Null;
End Zl_FUN_Get检验图像;
/

--82181:许华峰,2015-02-28,更新影像报告的报告人
Create Or Replace Procedure ZL_影像报告保存_更新报告人
( 
    医嘱id_In   影像检查记录.医嘱id%Type, 
    报告人_In   影像检查记录.报告人%Type
) Is 
--报告人传NULL时，填已有报告人 
Begin 
  Update 影像检查记录 Set 报告人=Nvl(报告人_In,报告人) Where 医嘱ID=医嘱id_In; 
Exception 
    When Others Then 
        zl_ErrorCenter(SQLCode, SQLErrM); 
End ZL_影像报告保存_更新报告人;
/

--77769:冉俊明,2015-03-02,调整医疗小组确定规则。
Create Or Replace Function Zl_医疗小组_Get
(
  开单科室id_In 临床医疗小组.科室id%Type,
  开单人_In     人员表.姓名%Type,
  病人id_In     病人信息.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  发生时间_In   住院费用记录.发生时间%Type
  --功能：获取医疗小组ID
  --     本函数主要供其他过程调用,读取相关的医疗小组的ID
  --     获取规则:
  --     0.当病人在医疗小组A的住院期间，所有发生时间在本期间内时，医疗小组id均为A组的id ；
  --       当病人从医疗小组A转移到医疗小组B后，A组补录病人的费用时，只要费用的发生时间在病人
  --       在医疗小组A的住院期间，则医疗小组id均为A组的id 
  --     老规则：
  --     1.开单人只有一个组;医疗小组ID就为开单人的医疗小组.
  --     2.如果开单人从属多个医疗小组的或不存在开单人时,则缺省取病人所属医疗小组
  --说明：如果当前规则没有取到医疗小组ID，则按老规则再取一次
) Return Number Is
  n_Count Number(18);
  n_组id  Number(18);
Begin
  Begin
    Select 医疗小组id
    Into n_组id
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In 
          And 发生时间_In Between 开始时间 And Nvl(终止时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
  Exception
    When Others Then
      n_组id := Null;
  End;
  If Nvl(n_组id, 0) <> 0 Then
    Return n_组id;
  End If;

  Select Max(a.Id), Count(Distinct a.Id)
  Into n_组id, n_Count
  From 临床医疗小组 A, 医疗小组人员 B, 人员表 C
  Where a.Id = b.小组id And b.人员id = c.Id And a.科室id = 开单科室id_In And c.姓名 = 开单人_In;
  If n_Count = 1 And Nvl(n_组id, 0) <> 0 Then
    Return n_组id;
  End If;

  --取病人信息的医疗小组ID
  Begin
    Select 医疗小组id Into n_组id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  Exception
    When Others Then
      n_组id := Null;
  End;
  Return n_组id;
End Zl_医疗小组_Get;
/

--77769:冉俊明,2015-02-27,调整医疗小组确定规则。
Create Or Replace Procedure Zl_门诊费用转住院_Insert
(
  结算序号_In   病人预交记录.结算序号%Type,
  No_In         住院费用记录.No%Type,
  住院号_In     住院费用记录.标识号%Type, --医保入院补充登记时才传入
  主页id_In     住院费用记录.主页id%Type, --医保入院补充登记时才传入
  入院时间_In   住院费用记录.发生时间%Type,
  入院科室id_In 病人预交记录.科室id%Type,
  退费时间_In   住院费用记录.登记时间%Type, --多张单据退费时,每张单据的退费时间相同,都是系统当前时间
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  入院病区id_In 住院费用记录.病人病区id%Type := Null,
  单据_In       Number := 1,
  三方退费_In   Number := 0
) As
  --单据_In:1-门诊收费单;2-记帐单
  v_Billno   住院费用记录.No%Type;
  n_实收合计 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;

  n_病区id     住院费用记录.病人病区id%Type;
  v_床号       住院费用记录.床号%Type;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  n_开单部门id     部门表.Id%Type;
  n_操作员编号     门诊费用记录.操作员编号%Type;
  v_操作员姓名     门诊费用记录.操作员姓名%Type;
  v_开单人         人员表.姓名%Type;
  n_病人id         病人信息.病人id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_立即销帐       Number(2);
  v_Nos            Varchar2(3000);
  n_结帐id         门诊费用记录.结帐id%Type;
  v_Err_Msg        Varchar2(255);
  n_组id           财务缴款分组.Id%Type;
  Err_Item Exception;
  n_Count Number(18);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If Nvl(主页id_In, 0) <> 0 Then
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 病人id
        Into n_病人id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And Rownum = 1;
      Exception
        When Others Then
          n_病人id := 0;
      End;
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  -- n_门诊转住院先审核 := Zl_To_Number(Zl_Getsysparameter('门诊转住院先审核', 1143));
  n_立即销帐 := Zl_To_Number(zl_GetSysParameter('费用转出立即退费', 1131));
  For r_Nos In (Select Distinct a.No
                From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
    v_Nos := v_Nos || ',' || r_Nos.No;
  End Loop;
  v_Nos := Substr(v_Nos, 2);
  If Nvl(n_立即销帐, 0) = 1 Then
    If Mod(单据_In, 10) = 1 Then
      --转收费单
      --No_In;操作员编号_In,操作员姓名_In,退费时间_In,门诊退费_In(0-门诊转住院立即销帐;1-门诊退费模式),入院科室id_In,主页id_In
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
      Zl_门诊转住院_收费转出(结算序号_In, No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, 三方退费_In, n_结帐id);
    Else
      --转记帐单
      --No_In;操作员编号_In,操作员姓名_In,退费时间_In
      Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
    End If;
  End If;
  --规则
  -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
  -- 2.主页id_In<>0 :
  If Nvl(入院病区id_In, 0) <> 0 Then
    n_病区id := 入院病区id_In;
  Elsif Nvl(主页id_In, 0) <> 0 Then
    Begin
      Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
      Into n_病区id, v_床号
      From 病人信息 A, 病案主页 B
      Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
    Exception
      When Others Then
        n_病区id := Null;
    End;
  End If;

  If Nvl(n_病区id, 0) = 0 Then
    --以入院科室为准
    n_病区id := Nvl(入院科室id_In, 0);
  End If;

  --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
  --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
  Select 病人id, 开单部门id, 开单人
  Into n_病人id, n_开单部门id, v_开单人
  From 门诊费用记录
  Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;

  --5.产生记帐单
  --需要检查是否已经转出
  Select Count(*)
  Into n_Count
  From 门诊费用记录 A
  Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
   (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
  If n_Count >= 1 Then
    v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
    Raise Err_Item;
  End If;
  If Mod(单据_In, 10) = 1 Then
    --收费按照结算序号查出包含NO号进行处理
    n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    For r_Nos In (Select Distinct c.No
                  From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B, 门诊费用记录 C
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id And c.No = a.No And
                        Mod(c.记录性质, 10) = 1 And c.记录状态 In (1, 3)) Loop
      v_Billno := Nextno(14);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And 附加标志 Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
                              保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价,
                              Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                              Max(执行人) As 执行人, 划价人, 记帐单id, 是否急诊, 发生时间, Min(实际票号) As 实际票号, Max(执行状态) As 执行状态
                       From 门诊费用记录
                       Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And 附加标志 Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 记帐单id,
                                是否急诊, 发生时间
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
           记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.婴儿费, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
             开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Nos.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.婴儿费, r_Clinic.收入项目id,
             r_Clinic.收据费目, r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0,
             r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In,
             r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = r_Nos.No And 单据 In (8, 9, 24, 25) And
              费用id In
              (Select ID
               From 门诊费用记录
               Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In
              (Select ID
               From 门诊费用记录
               Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
    End Loop;
  Else
    --记账按照单据NO进行处理
    v_Billno     := Nextno(14);
    n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
  
    Insert Into 住院费用记录
      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
       记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
             Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
             发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
             执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And 附加标志 Not In (8, 9);
  
    If Nvl(n_立即销帐, 0) = 1 Then
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
    End If;
  
    For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                            费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                            Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人, 记帐单id, 发生时间,
                            实际票号, Max(执行状态) As 执行状态
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And 附加标志 Not In (8, 9)
                     Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 记帐单id, 发生时间,
                              实际票号
                     Having Sum(数次) <> 0) Loop
      Select 操作员编号, 操作员姓名
      Into n_操作员编号, v_操作员姓名
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态)
      Values
        (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
         住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
         r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
         r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
         r_Clinic.婴儿费, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
         r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号, v_操作员姓名,
         r_Clinic.记帐单id, '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态);
      If Nvl(n_立即销帐, 0) = 1 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人,
           发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
           r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.婴儿费, r_Clinic.收入项目id, r_Clinic.收据费目,
           r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人,
           r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额);
      End If;
    End Loop;
  
    --8-工本费，9-误差费
    --病人余额
    Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
    Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
      n_返回值 := n_实收合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --病人未结费用
    For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                  From 住院费用记录
                  Where NO = v_Billno And 记录性质 = 2
                  Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
      Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
      End If;
    End Loop;
  
    --6.药品相关数据处理
    For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                  From 住院费用记录 A, 材料特性 B
                  Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
      Update 药品收发记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
      Where NO = No_In And 单据 In (8, 9, 24, 25) And
            费用id In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
      If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
        --更新备货材料
        Update 药品收发记录
        Set 费用id = r_Fee.Id
        Where 单据 = 21 And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
      End If;
      --更新费用审核记录
      Update 费用审核记录
      Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
      Where 费用id In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
      If Sql%NotFound Then
        --未找到数据时，要强制进行对应.
        Insert Into 费用审核记录
          (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
          Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
          From 门诊费用记录
          Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
      End If;
    End Loop;
    Update 未发药品记录
    Set 主页id = 主页id_In, NO = v_Billno
    Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊费用转住院_Insert;
/

--77769:冉俊明,2015-02-27,调整医疗小组获取规则。
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 上次批号, 可用数量, 实际数量, 实际金额, 上次供应商id, 批准文号, 上次产地, 上次生产日期, 灭菌效期, 效期, 零售价, 商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And
          Decode(备货材料_In, 0, 0, Nvl(批次, 0)) = Decode(备货材料_In, 0, 0, Nvl(批次_In, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  n_领药部门id 药品收发记录.对方部门id%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  d_效期       药品收发记录.效期%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_其他出库no 药品收发记录.No%Type;
  v_部门名称   部门表.名称%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_库房id     药品库存.库房id%Type;
  n_Outmode    Number(1);
  v_Dec        Number;
  v_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库序号       药品收发记录.序号%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

Begin

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    --根据执行库房取虚拟库房ID
    Begin
      Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
    Exception
      When Others Then
        n_虚拟库房id := 0;
    End;
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, 操作员姓名_In, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0; --@@@
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
      Open c_Stock(n_Outmode, n_虚拟库房id);
    Else
      n_库房id := 执行部门id_In;
      Open c_Stock(n_Outmode, 执行部门id_In);
    End If;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许(包含备货卫材)。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Or (Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4') Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where NO = No_In And 记录状态 = 1 And 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0);
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, n_序号, 执行部门id_In,
         n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号, d_效期, Decode(v_Count, 1, 1, 付数_In),
         Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价,
         Round(n_当前单价 * n_当前数量, v_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期,
         d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And a.单据 = 21 And b.No = No_In And b.记录性质 = 2;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '床号:' || 床号_In || v_Err_Msg || '住院号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1,
                            100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, v_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0) And NO = No_In And
          Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, n_领药部门id,
         执行部门id_In, 登记时间_In, Decode(划价_In, 1, 0, 1), 0);
    End If;
    Zl_Prescription_Type_ZY_Update(No_In, 2 , 收费细目id_In, 收费类别_In);
    --可能时价药品的库存金额和数量变化了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          --医嘱摆药时是按病人分次计算并提交数据库,因此不同病人使用相同实价药品没有问题。
          --但同一病人同时使用两笔以上相同实价药品则会有问题。
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--77769:冉俊明,2015-02-27,调整医疗小组获取规则。
Create Or Replace Procedure Zl_住院一次费用_Insert
(
  病人id_In 住院费用记录.病人id%Type,
  主页id_In 住院费用记录.主页id%Type
) As
  Cursor c_Money Is
    Select E.姓名, E.性别, E.年龄, E.住院号, D.出院病床, D.入院病区id, D.入院科室id, D.费别, A.类别, C.收费细目id,
           A.计算单位, B.收入项目id, F.收据费目, B.现价, D.入院日期, Nvl(A.执行科室, 0) As 执行科室,
           Nvl(A.屏蔽费别, 0) As 屏蔽费别
    From 收费细目 A, 收费价目 B, 自动计价项目 C, 病案主页 D, 病人信息 E, 收入项目 F
    Where A.ID = B.收费细目id And A.ID = C.收费细目id And C.病区id = D.入院病区id And C.计算标志 = 8 And
          D.入院日期 >= Nvl(C.启用日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And D.主页id = 主页id_In And
          D.病人id = 病人id_In And E.病人id = D.病人id And B.收入项目id = F.ID And
          ((D.入院日期 Between B.执行日期 And B.终止日期) Or (D.入院日期 >= B.执行日期 And B.终止日期 Is Null))
    Order By A.ID, B.收入项目id;

  --功能：对住院病人计算一次性费用。
  v_Billno     住院费用记录.NO%Type;
  v_执行部门id 住院费用记录.执行部门id%Type;
  v_实收金额   住院费用记录.实收金额%Type;
  v_价格父号   住院费用记录.价格父号%Type;
  v_项目id     收费项目目录.ID%Type;

  v_人员编号   住院费用记录.操作员编号%Type;
  v_人员姓名   住院费用记录.操作员姓名%Type;
  v_人员部门id 部门表.ID%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  v_Dec   Number;
  v_Date  Date;
  v_Count Number;
  v_Temp  Varchar2(255);
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查是否是计算一次的项目
  Select Count(*)
  Into v_Count
  From 病案主页 A, 自动计价项目 B
  Where A.病人id = 病人id_In And A.主页id = 主页id_In And A.入院病区id = B.病区id And B.计算标志 = 8 And
        A.入院日期 >= Nvl(B.启用日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
  If v_Count = 0 Then
    Return;
  End If;

  --检查该病人本次住院是否已经计算过
  Select Count(*)
  Into v_Count
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 8;
  If v_Count > 0 Then
    Return;
  End If;

  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  v_Temp       := Zl_Identity;
  v_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名   := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  --取单据号
  v_Billno := Nextno(17);

  --取时间
  Select Sysdate Into v_Date From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --产生费用信息
  v_项目id := Null;
  v_Count  := 1; --序号
  For r_Money In c_Money Loop
    If Nvl(v_项目id, 0) <> r_Money.收费细目id Then
      --求执行部门
      If r_Money.执行科室 = 2 Then
        --入住病区
        v_执行部门id := r_Money.入院病区id;
      Elsif r_Money.执行科室 = 1 Then
        --指定科室
        Begin
          Select 执行部门id Into v_执行部门id From 收费执行部门 Where 收费细目id = r_Money.收费细目id And Rownum < 2;
        Exception
          When Others Then
            v_执行部门id := v_人员部门id;
        End;
      Else
        --未指定或操作员科室
        v_执行部门id := v_人员部门id;
      End If;
      --该项目各后续收入项目的价格父号
      v_价格父号 := v_Count;

    End If;

    --求实收金额
    If r_Money.屏蔽费别 = 1 Then
      v_实收金额 := Round(r_Money.现价, v_Dec);
    Else
      Begin
        Select Round(Round(r_Money.现价, n_单价小数) * 实收比率 / 100, v_Dec)
        Into v_实收金额
        From 费别明细
        Where 收入项目id = r_Money.收入项目id And 费别 = r_Money.费别 And
              Round(r_Money.现价, n_单价小数) Between 应收段首值 And 应收段尾值;
      Exception
        When Others Then
          v_实收金额 := Round(r_Money.现价, v_Dec);
      End;
    End If;
    n_医疗小组id := Zl_医疗小组_Get(v_人员部门id, v_人员姓名, 病人id_In, 主页id_In, r_Money.入院日期);

    --插入费用记录(附加标志=8,记录性质=3)
    Insert Into 住院费用记录
      (ID, 记录性质, NO, 记录状态, 序号, 价格父号, 病人id, 主页id, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 床号,
       病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 附加标志, 收入项目id, 收据费目,
       标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 操作员编号, 操作员姓名,
       医疗小组id)
    Values
      (病人费用记录_Id.Nextval, 3, v_Billno, 1, v_Count,
       Decode(Sign(Nvl(v_项目id, 0) - r_Money.收费细目id), 0, v_价格父号, Null), 病人id_In, 主页id_In, 2, 1,
       r_Money.姓名, r_Money.性别, r_Money.年龄, r_Money.住院号, r_Money.出院病床, r_Money.入院病区id,
       r_Money.入院科室id, r_Money.费别, r_Money.类别, r_Money.收费细目id, r_Money.计算单位, 1, 1, 8, r_Money.收入项目id,
       r_Money.收据费目, Round(r_Money.现价, n_单价小数), Round(r_Money.现价, v_Dec), v_实收金额, v_人员姓名,
       v_人员部门id, v_人员姓名, r_Money.入院日期, v_Date, v_执行部门id, v_人员编号, v_人员姓名, n_医疗小组id);

    v_Count  := v_Count + 1;
    v_项目id := r_Money.收费细目id; --记录上次处理行的项目

    --相关汇总表的处理
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + v_实收金额 Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2;
    If Sql%Rowcount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, v_实收金额, 0);
    End If;

    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + v_实收金额
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Money.入院病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Money.入院科室id, 0) And Nvl(开单部门id, 0) = v_人员部门id And
          Nvl(执行部门id, 0) = v_执行部门id And 收入项目id + 0 = r_Money.收入项目id And 来源途径 = 2;

    If Sql%Rowcount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, r_Money.入院病区id, r_Money.入院科室id, v_人员部门id, v_执行部门id, r_Money.收入项目id,
         2, v_实收金额);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_住院一次费用_Insert;
/

--83391:刘兴洪,2015-03-24,自动计帐费用重复计算的问题
--77769:冉俊明,2015-02-27,调整医疗小组获取规则。
Create Or Replace Procedure Zl1_Autocptone
(
  病人id_In In Number,
  主页id_In In Number,
  期间_In   In Varchar2
) As

  ------------------------------------------------------------------------- 
  --功能说明：完成指定病人指定期间自动计价项目表设置自动计算的项目进行记帐处理 
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志; 
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费 
  --             别等完成费用的正确计算： 
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录; 
  --             作废以前的错误计算的记录; 
  --             统计本次变动(新增和作废)，填写余额表和汇总表; 
  --入口参数： 
  --       病人ID_IN  number    病人身份ID 
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人 
  --       期间_IN  varchar2     需要计算的最小期间 
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程 

  Cursor v_Autocur
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select Distinct 病人id, 主页id, 姓名, 性别, 年龄, 住院号, 费别, 科室id, 病区id, 床号, 附加床位, 收费细目id, 收入项目id, 标志, 标准单价, 开始日期, 终止日期, 天数,
                           数量, 经治医师, 责任护士, 操作员编号, 操作员姓名
           From 病人自动费用
           Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  n_Insure       病案主页.险类%Type;
  v_Billno       Varchar2(8); --费用表实际的自动记帐号码 
  n_Datecount    Integer; --日期计数器 
  d_Datefrom     Date; --开始计算日期 
  d_Dateto       Date; --终止计算日期 
  d_Datelast     Date;
  n_Billcount    Number(5) := 0; --单据序号计数器 
  n_Exsetax      Number(16, 2) := 0; --费用收取比率 
  n_Exsetax_Temp Number(16, 2) := 0; --费用收取比率 
  n_Summoney     Number(16, 2) := 0; --金额 

  Cursor v_Sumcur
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  n_Dec            Number; --金额小数位数 
  d_登记时间       Date; --登记时间 
  d_发生时间       Date; --发生时间 
  n_Dates          Number(3, 1); --当前记录的天数，全天为1 
  n_Do             Number(1);
  n_返回值         病人余额.预交余额%Type;
  n_Delete         Number;
  n_医疗小组id     住院费用记录.医疗小组id%Type;
  n_护理计算标准   Number(2); --护理费计算标准 
  n_收费细目id     Number(18);
  n_Temp           Number(18);
  l_护理id         t_Numlist := t_Numlist();
  l_护理等级       t_Numlist := t_Numlist();
  n_护理项目       Number(2); --1:是护理项目;0-非不护理 
  n_价格           收费价目.现价%Type;
  n_护理已处理     Number(2); --1-护理费已经处理,;0-未处理 
  n_收入项目id     Number(18);
  n_从属项目       Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_Temp           Varchar2(20);
  d_Start_Date     Date;
  d_End_Date       Date;

  --已经计算了的护理类型 
  Type t_护理_Rec Is Record(
    收费细目id 收费项目目录.Id%Type,
    日期       Date);
  Type t_护理 Is Table Of t_护理_Rec;
  c_护理 t_护理 := t_护理();

  n_Count Number(18);

Begin
  Begin
    Select 险类, Nvl(审核标志, 0), Nvl(状态, 0)
    Into n_Insure, n_审核标志, n_住院状态
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  Exception
    When Others Then
      Return;
  End;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 And Nvl(n_审核标志, 0) >= 1 Then
    Return;
  End If;
  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  v_Billno := Nextno(17);

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理计算标准
  From Dual;

  --每天5点以前，将记录时间登记为昨天，否则登记为当时 
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  --锁定该病人的记录,以免重复计算 
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  ----------------------------------------------------------------- 
  d_Datefrom := Sysdate + 1000;
  d_Dateto   := Sysdate - 1000;
  n_Do       := 0;
  -------------------------------------------------------------------- 
  If n_护理计算标准 = 1 Then
    --同天以最高价位的护理费为准,先将其护理等级记住, 
    For v_护理 In (Select Distinct 护理等级id
                 From (Select 护理等级id
                        From 病人变动记录
                        Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In
                        Union All
                        Select i.从项id As 护理等级id
                        From 病人变动记录 B, 收费从属项目 I
                        Where b.护理等级id = i.主项id And 病人id = 病人id_In And 主页id = 主页id_In And b.开始原因 <> 10 And i.固有从属 > 0)) Loop
      If Nvl(v_护理.护理等级id, 0) <> 0 Then
        l_护理id.Extend;
        l_护理id(l_护理id.Count) := v_护理.护理等级id;
      End If;
    End Loop;
  End If;
  ----------------------------------------------------------------- 
  --循环检查计算情况，并增加正确和新计算的记录 
  ----------------------------------------------------------------- 
  For v_Currrow In v_Autocur(期间_In, n_Insure) Loop
  
    n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
  
    If d_Datefrom > v_Currrow.开始日期 Then
      d_Datefrom := v_Currrow.开始日期;
      n_Do       := 1;
      --将本次开始计算时间以后的已计算记录标志修改 
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= v_Currrow.开始日期;
    End If;
  
    If d_Dateto < v_Currrow.终止日期 Then
      If v_Currrow.终止日期 > Trunc(Sysdate) Then
        d_Dateto := Trunc(Sysdate);
      Else
        d_Dateto := v_Currrow.终止日期;
      End If;
    End If;
    n_收费细目id := v_Currrow.收费细目id;
    n_护理项目   := 0;
    --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。 
    If n_护理计算标准 = 1 Then
      --先确定是否护理项目,如果是,则需要重新进行计算 
      Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
    End If;
  
    --提取当前收入项目的收费比率 
    Begin
      Select 实收比率
      Into n_Exsetax
      From (Select 实收比率
             From 费别明细
             Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                   (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
             Union All
             Select 实收比率
             From 费别明细
             Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                   (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
              (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
    Exception
      When Others Then
        n_Exsetax := 100.00;
    End;
  
    n_Exsetax := Nvl(n_Exsetax, 100);
  
    If v_Currrow.终止日期 > Trunc(Sysdate) Then
      n_Count := (Trunc(Sysdate + 0.5) - Trunc(v_Currrow.开始日期)) - 1;
    Else
      d_Start_Date := Trunc(v_Currrow.开始日期);
      d_End_Date   := Trunc(v_Currrow.终止日期 + 0.5);
    
      n_Count := d_End_Date - d_Start_Date;
    
      n_Count := n_Count - 1;
    End If;
  
    For n_Datecount In 0 .. n_Count Loop
    
      d_发生时间 := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
    
      v_Temp := To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss');
    
      n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                      Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
      n_护理已处理 := 0;
      If n_护理项目 = 1 Then
        --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准) 
        n_从属项目 := 1;
        If l_护理等级.Count > 0 Then
          l_护理等级.Delete;
        End If;
        For v_护理 In (Select Distinct 护理等级id
                     From 病人变动记录
                     Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And Trunc(开始时间) = Trunc(d_发生时间)) Loop
          If Nvl(v_护理.护理等级id, 0) <> 0 Then
            l_护理等级.Extend;
            l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
            If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
              n_从属项目 := 0;
            End If;
          End If;
        End Loop;
        If l_护理等级.Count > 1 Then
          --2. 存在两个以上变动,则取价位最高的 
          n_Temp       := v_Currrow.收费细目id;
          n_价格       := Nvl(v_Currrow.标准单价, 0);
          n_收入项目id := v_Currrow.收入项目id;
          --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算 
          If Nvl(n_从属项目, 0) = 1 Then
            n_护理已处理 := 1;
          End If;
          --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的 
          For I In 1 .. c_护理.Count Loop
            If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
              n_护理已处理 := 1;
              Exit;
            End If;
          End Loop;
          If Nvl(n_护理已处理, 0) = 0 Then
            c_护理.Extend;
            c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
            c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
          End If;
          If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
            --3.处理最高价位 
            For v_价位 In (Select /*+ rule */
                          a.Column_Value As 收费细目id, p.现价, p.收入项目id
                         From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                         Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                               Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1) Loop
              If Nvl(v_价位.现价, 0) > n_价格 Then
                n_价格       := Nvl(v_价位.现价, 0);
                n_Temp       := v_价位.收费细目id;
                n_收入项目id := v_价位.收入项目id;
              End If;
            End Loop;
          
            If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              --4. 不等的话,需要重新处理相关费用 
              For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                           From Dual
                           Union All
                           Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                           From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                           Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                 d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate)) Loop
                --确定比例 
                Begin
                  Select 实收比率
                  Into n_Exsetax_Temp
                  From (Select 实收比率
                         From 费别明细
                         Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                               (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                         Union All
                         Select 实收比率
                         From 费别明细
                         Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                               (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                          (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                Exception
                  When Others Then
                    n_Exsetax_Temp := 100.00;
                End;
                n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                --如果已经计算，原记录计算完全正确，则直接修改将标志改正 
                Update 住院费用记录
                Set 附加标志 = 0
                Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And
                      Nvl(加班标志, 0) = v_Currrow.附加床位 And 病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And
                      Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And 收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And
                      发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And 标准单价 = v_费用.单价 And
                      应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                      实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
              
                If Sql%RowCount = 0 Then
                  --如果未计算或计算错误，则增加正确的计算记录 
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                     姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                     收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                    Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                           Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id,
                           v_Currrow.科室id, v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄,
                           v_Currrow.住院号, v_Currrow.床号, v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1,
                           v_费用.数量 * n_Dates, Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                           Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                           j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                           Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                           Decode(v_Currrow.算法, 1,
                                   Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                   v_Currrow.统筹比额, 0), n_医疗小组id
                    From (Select 类别, 计算单位
                           From 收费细目
                           Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                         (Select 收据费目
                           From 收入项目
                           Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                  n_Billcount := n_Billcount + Sql%RowCount;
                End If;
                n_护理已处理 := 1;
              End Loop;
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(n_护理已处理, 0) = 0 Then
        --如果已经计算，原记录计算完全正确，则直接修改将标志改正 
        Update 住院费用记录
        Set 附加标志 = 0
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And
              Nvl(加班标志, 0) = v_Currrow.附加床位 And 病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And
              Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And 收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And
              发生时间 = d_发生时间 And 数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
              应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
              实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
      
        If Sql%RowCount = 0 Then
          --如果未计算或计算错误，则增加正确的计算记录\ 
          Insert Into 住院费用记录
            (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
             年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
             操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
            Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                   Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                   v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                   v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1, v_Currrow.数量 * n_Dates,
                   Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                   Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                   j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                   Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                   Decode(v_Currrow.算法, 1,
                           Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                           2, v_Currrow.统筹比额, 0), n_医疗小组id
            From (Select 类别, 计算单位
                   From 收费细目
                   Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                 (Select 收据费目
                   From 收入项目
                   Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
        
          n_Billcount := n_Billcount + Sql%RowCount;
        End If;
      End If;
    End Loop;
  End Loop;

  If n_Do = 0 Then
    --撤销出院后,如果修改出院时间为入院当天则不产生新费用,但以前的费用要冲销 
    Begin
      Select Trunc(b.上次计算时间)
      Into d_Datelast
      From 病人变动记录 A, 病人变动记录 B
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.终止原因 = 1 And a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 = 1 And
            Trunc(b.开始时间) = Trunc(a.终止时间) And a.附加床位 = 0 And b.附加床位 = 0;
    Exception
      When Others Then
        Null;
    End;
    If d_Datelast Is Not Null Then
      d_Datefrom := d_Datelast;
      d_Dateto   := Sysdate;
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= d_Datefrom;
    End If;
  End If;

  ----------------------------------------------------------------- 
  --作废以前计算的错误记录 
  ----------------------------------------------------------------- 
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  ----------------------------------------------------------------- 
  --填写病人余额 
  ----------------------------------------------------------------- 
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Datefrom);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  ----------------------------------------------------------------- 
  --填写病人汇总费用 
  ----------------------------------------------------------------- 
  n_Delete := 0;
  For v_Currrow In v_Sumcur(v_Billno, d_Datefrom) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;

  ----------------------------------------------------------------- 
  --将所有修改的附加标志还原为正常标志 
  ----------------------------------------------------------------- 
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  ----------------------------------------------------------------- 
  --修改计算时间标志 
  ----------------------------------------------------------------- 
  Update 病人变动记录
  Set 上次计算时间 = Least(d_Dateto, Decode(Sign(Trunc(Sysdate) - Nvl(终止时间, Trunc(Sysdate))), -1, Sysdate, Nvl(终止时间, Sysdate)))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Datefrom;
  Commit; --单个病人提交 
End Zl1_Autocptone;
/

--82610:刘尔旋,2015-02-15,批量换非序号控制号码的问题
Create Or Replace Procedure Zl_病人挂号记录_批量换号
(
  Nos_In        In Varchar2 := Null,
  新号别_In     In 病人挂号记录.号别%Type := Null,
  新医生姓名_In In 挂号安排.医生姓名%Type := Null,
  新医生id_In   In 挂号安排.医生id%Type := Null,
  新科室id_In   In 挂号安排.科室id%Type := Null,
  原医生姓名_In In 挂号安排.医生姓名%Type := Null,
  原医生id_In   In 挂号安排.医生id%Type := Null,
  原号别_In     In 病人挂号记录.号别%Type := Null,
  操作员姓名_In In 挂号序号状态.操作员姓名%Type := Null
  --功能: 完成病人批量换号功能,在挂号项目相同,限号数相同,限约数相同,科室相同的情况下。
  --参数说明:  Nos_In :需要跟换排班的病人挂号记录单据集:格式: M000001|M000002|..........
) As
  --获取对应挂号记录的门诊费用记录信息
  Cursor c_Bill(c_No 病人挂号记录.No%Type) Is
    Select ID, 序号, NO, 发生时间, 执行部门id, 收费细目id, 计算单位
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (0, 1) And NO = c_No
    Order By 序号;
  --获取相应排班的分诊诊室
  Cursor c_平均分诊(c_指定分诊号表id 挂号安排.Id%Type) Is
    Select 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = c_指定分诊号表id;

  --变量定义
  r_平均分诊         挂号安排诊室%RowType;
  r_Bill             c_Bill%RowType;
  v_Nos              Varchar(2000);
  v_No               病人挂号记录.No%Type;
  n_病人id           病人挂号记录.病人id%Type;
  n_原序号           病人挂号记录.号序%Type;
  d_原就诊日期       病人挂号记录.预约时间%Type;
  n_是否已被挂出     Number(1);
  n_记录性质         Number(1);
  n_预约             Number(1);
  n_挂号状态         Number(1); --0-正常挂号:1-预约挂号;2-预约挂号接收
  v_新就诊诊室       病人信息.就诊诊室%Type;
  n_分诊方式         Number(1); --0-不分诊:1-指定分诊:2-动态分诊:3-平均分诊
  n_指定分诊号表id   Number(10);
  n_分诊诊室数量     Number(3);
  n_是否找到分诊诊室 Number(1); --0:未找到:1-找到但分配标识未更改:2-修改第一条数据标识
  n_Index            Number(1); --当前记录集的索引值
  v_现队列名称       排队叫号队列.队列名称%Type;
  n_挂号生成队列     Number;
  n_预约生成队列     Number;
  v_排队号码         排队叫号队列.排队号码%Type;
  n_业务id           病人挂号记录.Id%Type;
  v_Temp             Varchar2(500);
  v_操作员编号       就诊变动记录.操作员编号%Type;
  v_操作员姓名       就诊变动记录.操作员姓名%Type;
  n_医生id           人员表.Id%Type;
  v_Error            Varchar2(255);
  Err_Custom Exception;
Begin
  --检查是否存在该挂号记录
  If Nos_In Is Not Null Then
    v_Nos := Nos_In || '|';
    While v_Nos Is Not Null Loop
      --初始化变量
      n_病人id           := 0;
      n_原序号           := 0;
      d_原就诊日期       := Null;
      n_是否已被挂出     := 0;
      n_记录性质         := 0;
      n_预约             := 0;
      n_挂号状态         := 0;
      v_新就诊诊室       := '';
      n_分诊方式         := 0;
      n_指定分诊号表id   := 0;
      v_现队列名称       := '';
      v_排队号码         := '';
      n_业务id           := 0;
      n_分诊诊室数量     := 0;
      n_挂号生成队列     := 0;
      n_预约生成队列     := 0;
      n_是否找到分诊诊室 := 0;
      n_Index            := 0;
    
      v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
      v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
      --检查是否存在该挂号记录
      Begin
        Select ID, 病人id, 号序, Nvl(预约时间, 发生时间), 记录性质, Nvl(预约, 0)
        Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约
        From 病人挂号记录
        Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1;
      Exception
        When Others Then
          Null;
      End;
      If n_病人id = 0 Then
        v_Error := '没有找到病人的挂号信息';
        Raise Err_Custom;
      End If;
      --判断当前挂号状态
      n_挂号状态 := 0; --正常挂号
      If n_记录性质 = 1 And n_预约 = 1 Then
        n_挂号状态 := 2; --预约接收
      End If;
      If n_记录性质 = 2 And n_预约 = 1 Then
        n_挂号状态 := 1; --预约
      End If;
    
      --检查换号的新号别是否已被挂出
      Begin
        Select a.状态
        Into n_是否已被挂出
        From 挂号序号状态 A
        Where a.日期 = d_原就诊日期 And a.号码 = 新号别_In And a.序号 = n_原序号;
      Exception
        When Others Then
          n_是否已被挂出 := 0;
      End;
      If n_是否已被挂出 > 0 Then
        v_Error := '要换的号别已被挂出';
        Raise Err_Custom;
      End If;
      --预约接收的情况下进行分诊诊室的获取
      If n_挂号状态 = 2 Then
        --获取新号别诊室
        --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
        --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
        --获取分诊方式
        Begin
          Select ID, Nvl(分诊方式, 0) Into n_指定分诊号表id, n_分诊方式 From 挂号安排 Where 号码 = 新号别_In;
        Exception
          When Others Then
            n_分诊方式       := 0;
            n_指定分诊号表id := 0;
        End;
      
        Begin
          If n_分诊方式 = 0 Then
            --不分诊
            v_新就诊诊室 := '';
          End If;
          If n_分诊方式 = 1 Then
            --指定分诊
            Select 门诊诊室 Into v_新就诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
          End If;
          If n_分诊方式 = 2 Then
            --动态分诊
            Select 门诊诊室
            Into v_新就诊诊室
            From (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_指定分诊号表id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                号别 = 新号别_In And 诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num)
            Where Rownum = 1;
          End If;
          If n_分诊方式 = 3 Then
            --平均分诊
            --获取当前安排下的诊室数量
            Select Count(1) Into n_分诊诊室数量 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
          
            Open c_平均分诊(n_指定分诊号表id);
            Loop
              Fetch c_平均分诊
                Into r_平均分诊;
              Exit When c_平均分诊%NotFound;
              n_Index := n_Index + 1;
              --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
              If n_是否找到分诊诊室 = 1 Then
                Update 挂号安排诊室
                Set 当前分配 = 1
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                Exit;
              End If;
            
              If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                v_新就诊诊室 := r_平均分诊.门诊诊室;
                Update 挂号安排诊室
                Set 当前分配 = 0
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                n_是否找到分诊诊室 := 1;
              End If;
            
              If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                n_是否找到分诊诊室 := 2;
                Exit;
              End If;
              If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                --游标已经到了最后,所以需从第一条数据开始修改标识
                If n_Index >= n_分诊诊室数量 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
              End If;
            End Loop;
            Close c_平均分诊;
            --重置索引值
            n_Index := 0;
            --第一次分诊
            If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                n_Index := n_Index + 1;
              
                If n_是否找到分诊诊室 = 1 Then
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End If;
              
                Update 挂号安排诊室
                Set 当前分配 = 0
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                v_新就诊诊室 := r_平均分诊.门诊诊室;
              
                n_是否找到分诊诊室 := 1;
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
              
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              
              End Loop;
              Close c_平均分诊;
            End If;
          
            If n_是否找到分诊诊室 = 2 Then
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                Update 挂号安排诊室
                Set 当前分配 = 1
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                Exit;
              End Loop;
              Close c_平均分诊;
            End If;
          End If;
        Exception
          When Others Then
            v_新就诊诊室 := '';
        End;
      End If;
    
      --更新病人信息的就诊诊室和状态
      Update 病人信息 Set 就诊诊室 = v_新就诊诊室, 就诊状态 = 1 Where 病人id = n_病人id And 就诊状态 In (1, 2);
    
      --打开游标
      Open c_Bill(v_No);
      Loop
        Fetch c_Bill
          Into r_Bill;
        Exit When c_Bill%NotFound;
        If r_Bill.序号 = 1 Then
          --需要确定是否预约挂号 
          --1.如果是预约挂号产生的挂号记录,则需要减已约数
          --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
          --3.如果是正常挂号,则只减已挂数      
          --恢复以前的挂号汇总 
          Update 病人挂号汇总
          Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
              已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
          Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And
                Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And Nvl(医生姓名, '医生') = Nvl(原医生姓名_In, '医生') And
                Nvl(医生id, 0) = Nvl(原医生id_In, 0) And (号码 = r_Bill.计算单位 Or 号码 Is Null);
          If Sql%RowCount = 0 Then
            Insert Into 病人挂号汇总
              (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
            Values
              (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
               r_Bill.计算单位, 0, 0, 0);
          End If;
        
          ----然后再更新挂号汇总 
          Update 病人挂号汇总
          Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
              已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
          Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
                Nvl(医生姓名, '医生') = Nvl(新医生姓名_In, '医生') And Nvl(医生id, 0) = Nvl(新医生id_In, 0) And
                (号码 = 新号别_In Or 号码 Is Null);
          If Sql%RowCount = 0 Then
            Insert Into 病人挂号汇总
              (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
            Values
              (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
               Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
          End If;
        End If;
      
        ---更新挂号记录 
        If n_挂号状态 = 1 Then
          --预约
          Update 门诊费用记录
          Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
              --病人病区id = 科室id_In, 
              执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
          Where ID = r_Bill.Id;
        Else
          --挂号或接收
          Update 门诊费用记录
          Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
              --病人病区id = 科室id_In, 
              执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
          Where ID = r_Bill.Id;
        End If;
      
        --更新病人挂号记录 
        If r_Bill.序号 = 1 Then
          v_Temp := Zl_Identity(1);
          Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
          Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
          Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
          Begin
            Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
          Exception
            When Others Then
              n_医生id := Null;
          End;
          Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                           n_原序号, Null);
          --修改队列信息
          Update 排队叫号队列
          Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
          Where 业务id = n_业务id And 业务类型 = 0;
        
          Update 病人挂号记录
          Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号
          Where NO = r_Bill.No;
          --修改挂号序号状态
          If n_原序号 Is Not Null Then
            --1.恢复以前挂号序号状态
            Delete 挂号序号状态 Where 日期 = d_原就诊日期 And 序号 = n_原序号 And 号码 = 原号别_In;
            --2.新增换号后挂号序号状态 
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 操作员姓名, 状态, 预约, 登记时间)
            Values
              (新号别_In, d_原就诊日期, n_原序号, 操作员姓名_In, Decode(n_挂号状态, 1, 2, 1), Decode(n_挂号状态, 0, 0, 1), Sysdate);
          End If;
        End If;
      End Loop;
      Close c_Bill;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_批量换号;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段
--81907:冉俊明,2015-02-12,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_费用补充记录_Delete
(
  No_In           In 费用补充记录.No%Type,
  冲销id_In       In 费用补充记录.结算id%Type,
  重结id_In       In 费用补充记录.结算id%Type,
  结算序号_In     In 费用补充记录.结算序号%Type,
  退费结帐ids_In  In Varchar2,
  操作员编号_In   In 费用补充记录.操作员编号%Type,
  操作员姓名_In   In 费用补充记录.操作员姓名%Type,
  登记时间_In     In 费用补充记录.登记时间%Type := Null,
  非原样退结算_In In Varchar2 := Null
) Is
  --退费结帐id_In:传入本次退费的结帐ID,多个用逗号分离(123,111...)
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  d_Date     Date;
  n_组id     财务缴款分组.Id%Type;
  n_结算id   费用补充记录.结算id%Type;
  n_费用状态 费用补充记录.费用状态%Type;
  v_实际票号 费用补充记录.实际票号%Type;
  n_病人id   费用补充记录.病人id%Type;
  n_附加标志 费用补充记录.附加标志%Type;
  n_Count    Number(18);
  n_打印id   票据使用明细.Id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  d_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    d_Date := Sysdate;
  End If;

  v_Err_Msg := Null;
  Begin
    Select 结算id, 费用状态, 实际票号, 病人id, 附加标志
    Into n_结算id, n_费用状态, v_实际票号, n_病人id, n_附加标志
    From 费用补充记录
    Where 记录性质 = 1 And NO = No_In And 记录状态 = 1 And Rownum < 2 And Nvl(费用状态, 0) = 0;
  Exception
    When Others Then
      v_Err_Msg := '未找到结算单号为' || No_In || '的结算记录,可能已经被他人作废或重新结算,不允许再继续操作！';
  End;

  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;

  Update 费用补充记录 Set 记录状态 = 3 Where 结算id = n_结算id;

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
    Select 记录性质, NO, 2, 实际票号, 冲销id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名, d_Date As 登记时间,
           n_组id As 缴款组id, 病人id, 结算序号_In As 结算序号, 附加标志
    From 费用补充记录
    Where 结算id = n_结算id;

  --先将医保退回,剩下部分,直接退款(退款界面)
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, 结算方式, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 冲预交, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 2 As 校对标志, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 6
    From 病人预交记录 A
    Where 结帐id = n_结算id And Exists
     (Select 1
           From 结算方式
           Where a.结算方式 = 名称 And 性质 In (3, 4) And Instr(',' || 非原样退结算_In || ',', ',' || 名称 || ',') = 0) And
          Mod(a.记录性质, 10) <> 1;

  --插入病人预交记录.结算方式为空的记录
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, Null, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 退款额, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 1 As 校对标志, Null, Null, Null, Null, Null, Null, 6
    From (Select NO, Max(病人id) As 病人id, Max(主页id) As 主页id, Max(摘要) As 摘要, Sum(冲预交) As 退款额
           From 病人预交记录
           Where 结帐id = 冲销id_In
           Group By NO) A;

  Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = n_结算id;

  Select Count(*)
  Into n_Count
  From (Select a.No, a.记录性质, a.序号, a.收费细目id, Sum(Nvl(a.付数, 1) * a.数次) As 数量
         From 门诊费用记录 A,
              (Select Distinct m.记录性质, m.No
                From 费用补充记录 J, 门诊费用记录 M
                Where j.收费结帐id = m.结帐id And j.No = No_In And Mod(j.记录性质, 0) = 1) B
         Where a.记录性质 = b.记录性质 And a.No = b.No And a.价格父号 Is Null
         Group By a.No, a.记录性质, a.序号, a.收费细目id
         Having Sum(Nvl(a.付数, 1) * a.数次) <> 0);

  If Nvl(n_Count, 0) <> 0 Then
    --部分冲销,需要产生重收记录
    Insert Into 费用补充记录
      (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
      Select 1 As 记录性质, No_In As NO, 1, v_实际票号 As 实际票号, 重结id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号,
             操作员姓名_In As 操作员姓名, d_Date As 登记时间, n_组id As 缴款组id, n_病人id As 病人id, 结算序号_In As 结算序号, n_附加标志 As 附加标志
      From (Select Distinct 收费结帐id As 收费结帐id
             From 费用补充记录 J
             Where j.No = No_In And Mod(j.记录性质, 10) = 1
             Union
             Select Column_Value As 结帐id From Table(f_Num2list(退费结帐ids_In)));
  End If;
  --收回票据
  --获取单据最后一次的打印ID(可能是多张单据收费打印)
  Begin
    Select ID
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --可能以前没有打印,无收回
  If n_打印id Is Not Null Then
    --a.多张单据循环调用时只能收回一次
    Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
    If n_Count = 0 Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
    Else
      --b.部分退费多次收回时,最后一次全退收回要排开已收回的
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
        From 票据使用明细 A
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
         (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_Delete;
/

--81907:冉俊明,2015-02-12,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_门诊收费记录_Reprint
(
  No_In         门诊费用记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  领用id_In     票据使用明细.领用id%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  退费_In       Number := 0,
  票据张数_In   Number := 0,
  收回票据号_In Varchar2 := Null,
  票种_In       Number := 1
) As
  --功能：用于重打收费票据 
  --参数： 
  --      NO_IN         =   要重打的单据号，可能是一起收费的多张单据中的一张。 
  --      票据号        =   用于重打的起始票据号.而该张收费单据可能使用多张票据。 
  --      领用ID        =   如果为0或NULL,表示不严格控制票据。 
  --      退费_IN       =   是否部份退费时调用该过程 
  --      收回票据号_In =   部分退费时,界面选择要收回的票据号,这些票据只收回,不重新发出,传入空表示全部收回并重打 
  --该游标用于范围判断 
  Cursor c_Fact Is
    Select 开始号码, 终止号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;
  v_票据号 票据使用明细.号码%Type;
  n_补打   Number(2);
  n_分单据 Number(2);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  n_分单据 := Zl_Getsysparameter('多张单据收费分别打印', 1121);
  --获取该张单据的最后一次的的打印ID(可能没有) 
  Begin
    Select ID
    Into v_收回id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 票种_In And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      n_补打 := 1;
  End;

  --收回票据(可能以前未控制票据,无法收回) 
  If v_收回id Is Not Null Then
    If 收回票据号_In Is Null Then
      If Nvl(退费_In, 0) = 0 Then
        --a.重打 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Else
        --b.部分退费重打先收回 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      End If;
    Else
      --c.部分退费收回指定的票据号 
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细 A
        Where 打印id = v_收回id And 性质 = 1 And Instr(收回票据号_In, 号码) > 0 And Not Exists
         (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Return;
    End If;
  Else
    n_补打 := 1;
  End If;

  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据并填写票据打印内容 
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  If n_补打 = 1 And n_分单据 = 0 Then
    Insert Into 票据打印内容
      (ID, 数据性质, NO)
      Select Distinct v_打印id, 1, NO
      From (Select Distinct a.No
             From 门诊费用记录 A, 病人预交记录 B
             Where a.结帐id = b.结帐id And b.结算序号 In (Select Distinct a.结算序号
                                                  From 病人预交记录 A, 门诊费用记录 B
                                                  Where b.No = No_In And a.结帐id = b.结帐id));
  
    --门诊费用记录中记录票据号以便显示
    If 票种_In = 1 Or 票种_In = 4 Then
      Update 门诊费用记录
      Set 实际票号 = 票据号_In
      Where Mod(记录性质, 10) = Decode(票种_In, 1, 1, 4) And
            NO In
            (Select Distinct a.No
             From 门诊费用记录 A, 病人预交记录 B
             Where a.结帐id = b.结帐id And b.结算序号 In (Select Distinct a.结算序号
                                                  From 病人预交记录 A, 门诊费用记录 B
                                                  Where b.No = No_In And a.结帐id = b.结帐id));
    End If;
  Else
    Insert Into 票据打印内容
      (ID, 数据性质, NO)
      Select Distinct v_打印id, 1, NO
      From (Select NO
             From 票据打印内容
             Where ID = v_收回id And 数据性质 = 票种_In
             Union All
             Select No_In From Dual);
  
    --门诊费用记录中记录票据号以便显示 
    If 票种_In = 1 Or 票种_In = 4 Then
      Update 门诊费用记录
      Set 实际票号 = 票据号_In
      Where Mod(记录性质, 10) = Decode(票种_In, 1, 1, 4) And
            NO In (Select NO
                   From 票据打印内容
                   Where ID = v_收回id And 数据性质 = 票种_In
                   Union
                   Select No_In From Dual);
    End If;
  End If;
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次,无法完成重打操作！';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    If Nvl(领用id_In, 0) <> 0 Then
      --检查票据范围 
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据:重打时,如果是部份退费重打,则处理为新发生；如果以前没有收回，也处理为新发出。 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 票种_In, v_票据号, 1, Decode(Nvl(退费_In, 0), 0, Decode(v_收回id, Null, 1, 3), 1), 领用id_In, v_打印id,
       使用人_In, 使用时间_In);
  
    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);
  
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;
  Update 票据领用记录 Set 使用时间 = 使用时间_In Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Reprint;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--77769:冉俊明,2015-02-27,调整医疗小组确定规则。
--81907:冉俊明,2015-02-27,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_门诊转住院结帐_结帐作废
(
  No_In         病人结帐记录.No%Type,
  操作员编号_In 病人结帐记录.操作员编号%Type,
  操作员姓名_In 病人结帐记录.操作员姓名%Type,
  作废日期_In   病人结帐记录.收费时间%Type
) As
  --该游标包含误差项目的相关信息
  Cursor c_Erritem Is
    Select a.类别 As 收费类别, a.Id As 收费细目id, a.计算单位, c.Id As 收入项目id, c.收据费目
    From 收费细目 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
          ((Sysdate Between b.执行日期 And b.终止日期) Or (Sysdate >= b.执行日期 And b.终止日期 Is Null));
  r_Erritem c_Erritem%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  Err_Item Exception;
  v_Err_Msg   Varchar2(255);
  v_Temp      Varchar2(255);
  v_实际票号  病人预交记录.实际票号%Type;
  v_误差no    住院费用记录.No%Type;
  v_预交no    病人预交记录.No%Type;
  v_New误差no 住院费用记录.No%Type;

  n_病人id     病人信息.病人id%Type;
  n_人员部门id 部门人员.部门id%Type;

  n_原结帐id 病人结帐记录.Id%Type;
  n_结帐id   病人结帐记录.Id%Type;
  n_打印id   票据打印内容.Id%Type;

  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_来源       Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值     病人余额.预交余额%Type;
  n_组id       财务缴款分组.Id%Type;
  v_现金结算   结算方式.名称%Type;
  n_冲预交     病人预交记录.冲预交%Type;
  n_Temp       病人预交记录.冲预交%Type;
  n_误差金额   病人预交记录.冲预交%Type;
  n_原主页id   病人预交记录.主页id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Begin
    Select 名称 Into v_现金结算 From 结算方式 Where 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      v_现金结算 := '现金';
  End;

  Begin
    Select ID, 病人id, 实际票号
    Into n_原结帐id, n_病人id, v_实际票号
    From 病人结帐记录
    Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, 作废日期_In, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原结帐id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原结帐id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 作废日期_In, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 = 3 And 性质 = 1;
  End If;
  -------------------------------------------------------------------------------------------------------------
  --冲预交处理
  Select Nvl(Sum(冲预交), 0) Into n_冲预交 From 病人预交记录 A Where Mod(a.记录性质, 10) = 1 And a.结帐id = n_原结帐id;

  n_Temp := Zl_Cent_Money(n_冲预交, 3);
  If n_Temp <> n_冲预交 Then
    --算误差费
    n_误差金额 := n_Temp - n_冲预交;
    n_冲预交   := n_Temp;
  End If;
  --先处理医保结算方式

  For v_预交 In (Select a.Id, a.记录性质, a.结算方式, 冲预交, b.性质, a.主页id
               From 病人预交记录 A, 结算方式 B
               Where a.结帐id = n_原结帐id And Mod(a.记录性质, 10) = 2 And a.结算方式 = b.名称(+)) Loop
    If v_预交.性质 >= 3 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 作废日期_In, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where ID = v_预交.Id;
    Else
      n_冲预交 := Nvl(n_冲预交, 0) + Nvl(v_预交.冲预交, 0);
    End If;
    n_原主页id := Nvl(v_预交.主页id, 0);
  End Loop;
  If Nvl(n_原主页id, 0) = 0 Then
    n_原主页id := Null;
  End If;
  n_冲预交 := Nvl(n_冲预交, 0);
  If n_冲预交 <> 0 Then
    --增加"现金冲回"
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 结算性质)
    Values
      (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, n_原主页id, r_Pati.出院科室id, Null, v_现金结算, Null, '结帐作废退款', Null,
       Null, Null, 作废日期_In, 操作员姓名_In, 操作员编号_In, -1 * n_冲预交, n_结帐id, n_组id, 2);
  
    --增加:预交款(现金)
    v_预交no := Nextno(11);
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id,
       预交类别)
    Values
      (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, n_冲预交, v_现金结算, Null, 作废日期_In, Null,
       Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, '2');
  
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + n_冲预交 --注:新的结帐ID产生的是负数金额
    Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 2, 1, n_冲预交, 0);
    End If;
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + n_冲预交
    Where 收款员 = 操作员姓名_In And 结算方式 = v_现金结算 And 性质 = 1
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_现金结算, 1, n_冲预交);
      n_返回值 := -1 * n_冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 结算方式 = v_现金结算 And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;
  --住院费用记录
  --读取原结帐时产生的误差费用,并销帐,然后将销帐记录处理在本次结帐作废中
  Begin
    Select NO, 医疗小组id
    Into v_误差no, n_医疗小组id
    From 住院费用记录
    Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    n_来源 := 2;
  Exception
    When Others Then
      Null;
  End;

  If v_误差no Is Null Then
    Begin
      Select NO
      Into v_误差no
      From 门诊费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    Exception
      When Others Then
        Null;
    End;
    n_来源 := 1;
  End If;

  --a.如果结帐时有误差,则在原误差单据上处理
  If v_误差no Is Not Null Then
    --在原有误差基础上产生新误差费用并结帐
    If n_来源 = 1 Then
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id,
         计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
         执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, Null, 记录性质, 2, 1, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别,
               收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目,
               Decode(n_误差金额, 0, 应收金额, 应收金额 + n_误差金额), Decode(n_误差金额, 0, -1 * 应收金额, -1 * (应收金额 + n_误差金额)),
               Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, -1, 操作员姓名,
               操作员编号, Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
               缴款组id
        From 门诊费用记录
        Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
      --作废结帐时的误差记录
      Update 门诊费用记录
      Set 记录状态 = 3, 执行状态 = 0
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
    Else
      Insert Into 住院费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id,
         费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人,
         发生时间, 登记时间, 执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, NO, Null, 记录性质, 2, 1, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号,
               病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目,
               Decode(n_误差金额, 0, 应收金额, 应收金额 + n_误差金额), Decode(n_误差金额, 0, -1 * 应收金额, -1 * (应收金额 + n_误差金额)),
               Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, -1, 操作员姓名,
               操作员编号, Decode(n_误差金额, 0, -1 * 实收金额, -1 * (实收金额 + n_误差金额)), n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
               缴款组id, 医疗小组id
        From 住院费用记录
        Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    
      --作废结帐时的误差记录
      Update 住院费用记录
      Set 记录状态 = 3, 执行状态 = 0
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) = 9 And 记录性质 = 2 And 记录状态 = 1;
    End If;
  
    Begin
      Select Case
               When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
                3
               When Nvl(Max(住院), 0) = 1 Then
                2
               Else
                1
             End
      Into n_来源
      From (Select 1 As 住院, 0 As 门诊
             From 住院费用记录
             Where 结帐id = n_原结帐id And Rownum = 1
             Union All
             Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原结帐id And Rownum = 1);
    
    Exception
      When Others Then
        n_来源 := 3;
    End;
  
  Else
    Begin
      Select Case
               When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
                3
               When Nvl(Max(住院), 0) = 1 Then
                2
               Else
                1
             End
      Into n_来源
      From (Select 1 As 住院, 0 As 门诊
             From 住院费用记录
             Where 结帐id = n_原结帐id And Rownum = 1
             Union All
             Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原结帐id And Rownum = 1);
    Exception
      When Others Then
        n_来源 := 3;
    End;
  
    --b.作废时新产生的误差
    If n_误差金额 <> 0 Then
      v_Temp       := Zl_Identity;
      n_人员部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
    
      Open c_Erritem;
      Fetch c_Erritem
        Into r_Erritem;
      If c_Erritem%RowCount = 0 Then
        Close c_Erritem;
        v_Err_Msg := '不能正确读取处理费用误差的项目信息，请先检查该项目是否正确设置。';
        Raise Err_Item;
      End If;
    
      If Nvl(n_来源, 1) = 1 Then
        --产生误差单据并结帐此误差费用
        v_New误差no := Nextno(14);
      
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
           执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 记帐单id, 保险项目否, 缴款组id)
        Values
          (病人费用记录_Id.Nextval, v_New误差no, Null, 2, 1, 1, Null, Null, n_病人id, Null, 1, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
           Decode(r_Pati.主页id, Null, r_Pati.门诊号, r_Pati.住院号), r_Pati.付款方式, Nvl(r_Pati.出院科室id, n_人员部门id), r_Pati.费别,
           r_Erritem.收费类别, r_Erritem.收费细目id, r_Erritem.计算单位, 1, Null, 1, Null, 9, 0, 1, r_Erritem.收入项目id, r_Erritem.收据费目,
           -1 * n_误差金额, -1 * n_误差金额, -1 * n_误差金额, Null, n_人员部门id, 操作员姓名_In, 作废日期_In, 作废日期_In, n_人员部门id, 0, 操作员姓名_In,
           操作员编号_In, -1 * n_误差金额, n_结帐id, Decode(r_Pati.险类, Null, Null, 1), Null, 0, n_组id);
      Else
        n_医疗小组id := Zl_医疗小组_Get(n_人员部门id, 操作员姓名_In, n_病人id, r_Pati.主页id, 作废日期_In);
        v_New误差no  := Nextno(14);
      
        --产生误差单据并结帐此误差费用
        Insert Into 住院费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id,
           费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人,
           发生时间, 登记时间, 执行部门id, 执行状态, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 是否上传, 记帐单id, 保险项目否, 缴款组id, 医疗小组id)
        Values
          (病人费用记录_Id.Nextval, v_New误差no, Null, 2, 1, 1, Null, Null, 0, n_病人id, r_Pati.主页id, Null,
           Decode(r_Pati.主页id, Null, 1, 2), r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
           Decode(r_Pati.主页id, Null, r_Pati.门诊号, r_Pati.住院号), r_Pati.出院病床, Nvl(r_Pati.当前病区id, n_人员部门id),
           Nvl(r_Pati.出院科室id, n_人员部门id), r_Pati.费别, r_Erritem.收费类别, r_Erritem.收费细目id, r_Erritem.计算单位, 1, Null, 1, Null,
           9, 0, 1, r_Erritem.收入项目id, r_Erritem.收据费目, -1 * n_误差金额, -1 * n_误差金额, -1 * n_误差金额, Null, n_人员部门id, 操作员姓名_In,
           作废日期_In, 作废日期_In, n_人员部门id, 0, 操作员姓名_In, 操作员编号_In, -1 * n_误差金额, n_结帐id, Decode(r_Pati.险类, Null, Null, 1),
           Null, 0, n_组id, n_医疗小组id);
      
      End If;
      Close c_Erritem;
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) <> 9;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原结帐id And Nvl(附加标志, 0) <> 9;
  End If;

  --相关汇总表处理
  For v_预交 In (Select 病人id, 记录性质, Nvl(预交类别, 2) As 预交类型, 结算方式, 冲预交
               From 病人预交记录
               Where 结帐id = n_结帐id) Loop
    If v_预交.记录性质 In (1, 11) Then
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - v_预交.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = v_预交.病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类型, 2)
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (v_预交.病人id, 1, Nvl(v_预交.预交类型, 2), -1 * v_预交.冲预交, 0);
        n_返回值 := -1 * v_预交.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = v_预交.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + v_预交.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = v_预交.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, v_预交.结算方式, 1, v_预交.冲预交);
        n_返回值 := -1 * v_预交.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = v_预交.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院结帐_结帐作废;
/

--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_病人结帐记录_Reprint
(
  No_In       病人预交记录.NO%Type,
  票据号_In   票据使用明细.号码%Type,
  领用id_In   票据使用明细.领用id%Type,
  使用人_In   票据使用明细.使用人%Type,
  票据张数_In Number,
  票种_In     Number := 0 --0:住院医疗费收据,1-门诊医疗费收据
) As
  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%Rowtype;

  v_收回id 票据打印内容.ID%Type;
  v_打印id 票据打印内容.ID%Type;
  v_票据号 票据使用明细.号码%Type;

  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    Select ID
    Into v_收回id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;
  Select Sysdate Into v_Date From Dual;

  --收回原发出票据(可能以前没有使用票据,无法收回)
  If v_收回id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, v_Date, 使用人_In
      From 票据使用明细
      Where 打印id = v_收回id And 票种 = Decode(票种_In, 0, 3, 1) And 性质 = 1;
  End If;

  --无票据号时,不用处理票据
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  --票据打印内容
  Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id,3, No_In);
  --病人结帐记录中填写开始票据号以便显示
  Update 病人结帐记录 Set 实际票号 = 票据号_In Where 记录状态 = 1 And NO = No_In;

  --并发出票据
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%Rowcount = 0 Then
      v_Error := '无效的票据领用批次，无法完成结帐票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    --检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '该结帐单需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;

    --发出票据
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, Decode(票种_In, 0, 3, 1), v_票据号, 1, Decode(v_收回id, Null, 1, 3), 领用id_In,
       v_打印id, 使用人_In, v_Date);

    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);

    --下一个票据号
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;
  Update 票据领用记录 Set 使用时间 = v_Date Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人结帐记录_Reprint;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_医疗卡记录_Delete
(
  单据号_In     住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  结算方式_In   病人预交记录.结算方式%Type := Null
) As
  --结算方式_IN:指定退回的结算方式名称
  Cursor c_Cardinfo Is
    Select a.Id As 费用id, Nvl(a.记帐费用, 0) As 记帐, a.结帐id, a.实际票号, a.病人id, Nvl(a.主页id, 0) As 主页id,
           Nvl(a.病人病区id, 0) As 病人病区id, Nvl(a.病人科室id, 0) As 病人科室id, Nvl(a.开单部门id, 0) As 开单部门id,
           Nvl(a.执行部门id, 0) As 执行部门id, a.收入项目id, a.实收金额, b.结算方式, b.冲预交, b.卡类别id, b.卡号, b.结算卡序号, b.结算序号, a.结论,
           b.Id As 预交id
    From 住院费用记录 A, 病人预交记录 B
    Where a.记录性质 = 5 And a.记录状态 = 1 And a.No = 单据号_In And a.结帐id = b.结帐id(+);
  r_Cardrow c_Cardinfo%RowType;

  v_费用id   住院费用记录.Id%Type;
  v_结帐id   住院费用记录.结帐id%Type;
  v_打印id   票据打印内容.Id%Type;
  n_返回值   病人余额.费用余额%Type;
  n_卡类别id Number(18);

  v_Date Date;

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  Open c_Cardinfo;
  Fetch c_Cardinfo
    Into r_Cardrow;
  n_组id := Zl_Get组id(操作员姓名_In);

  --首先判断要退卡的记录是否存在
  If c_Cardinfo%RowCount = 0 Then
    Close c_Cardinfo;
    v_Err_Msg := '[ZLSOFT]没有发现要退卡的记录,该记录可能已经退除！[ZLSOFT]';
    Raise Err_Item;
  Else
    Select Sysdate Into v_Date From Dual;
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  
    If r_Cardrow.记帐 = 0 Then
      Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
    End If;
  
    --退除就诊卡费用记录
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 门诊标志, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
       附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额,
       缴款组id, 结论)
      Select v_费用id, NO, 实际票号, 记录性质, 2, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 门诊标志, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
             -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 操作员编号_In, 操作员姓名_In,
             发生时间, v_Date, v_结帐id, Decode(v_结帐id, Null, Null, -结帐金额), n_组id, 结论
      From 住院费用记录
      Where ID = r_Cardrow.费用id;
  
    Update 住院费用记录 Set 记录状态 = 3 Where ID = r_Cardrow.费用id;
  
    --预交款里现收的结算金额
    If r_Cardrow.记帐 = 0 Then
      If 结算方式_In Is Not Null Then
        Insert Into 病人预交记录
          (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式_In, v_Date, 操作员编号_In, 操作员姓名_In, -冲预交, v_结帐id,
                 n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 5
          From 病人预交记录
          Where 记录性质 = 5 And 记录状态 = 1 And 结帐id = r_Cardrow.结帐id;
      Else
        Insert Into 病人预交记录
          (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, v_Date, 操作员编号_In, 操作员姓名_In, -冲预交, v_结帐id,
                 n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 5
          From 病人预交记录
          Where 记录性质 = 5 And 记录状态 = 1 And 结帐id = r_Cardrow.结帐id;
      End If;
      Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 5 And 记录状态 = 1 And 结帐id = r_Cardrow.结帐id;
    
      --Zl_病人卡结算记录_Strike(结帐id_In In Varchar2,  预交id_In 病人预交记录.ID%Type := -1
      Zl_病人卡结算记录_Strike(r_Cardrow.结帐id, r_Cardrow.预交id);
    
    End If;
  
    --退卡收回票据
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 5 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 回收次数, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 5 And 性质 = 1;
    End If;
  
    n_卡类别id := To_Number(Nvl(r_Cardrow.结论, '0'));
    If n_卡类别id = 0 Then
      --取就诊卡
      Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = '就诊卡' And Nvl(是否固定, 0) = 1;
    End If;
  
    --处理相关的变动信息
    --Zl_医疗卡变动_Insert (变动类型_In/病人id_In ,卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 变动时间_In
    --Ic卡号_In, 挂失方式_In)
    --变动类型_In:1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
    Zl_医疗卡变动_Insert(4, r_Cardrow.病人id, n_卡类别id, r_Cardrow.实际票号, r_Cardrow.实际票号, Null, Null, 操作员姓名_In, v_Date, Null,
                    Null);
  
    ----------------------------------------------------------------------------------------------------------------------------------------
  
    --相关汇总表的处理
    If r_Cardrow.记帐 = 1 Then
      --汇总'病人余额'
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + (-1 * r_Cardrow.实收金额)
      Where 性质 = 1 And 病人id = r_Cardrow.病人id And Nvl(类型, 2) = Decode(Nvl(r_Cardrow.主页id, 0), 0, 1, 2)
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Cardrow.病人id, 1, Decode(Nvl(r_Cardrow.主页id, 0), 0, 1, 2), 0, -1 * r_Cardrow.实收金额);
        n_返回值 := -1 * r_Cardrow.实收金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = r_Cardrow.病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --汇总'病人未结费用'
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + (-1 * r_Cardrow.实收金额)
      Where 病人id = r_Cardrow.病人id And Nvl(主页id, 0) = r_Cardrow.主页id And Nvl(病人病区id, 0) = r_Cardrow.病人病区id And
            Nvl(病人科室id, 0) = r_Cardrow.病人科室id And Nvl(开单部门id, 0) = r_Cardrow.开单部门id And
            Nvl(执行部门id, 0) = r_Cardrow.执行部门id And 收入项目id + 0 = r_Cardrow.收入项目id And 来源途径 = 3;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Cardrow.病人id, Decode(r_Cardrow.主页id, 0, Null, r_Cardrow.主页id),
           Decode(r_Cardrow.病人病区id, 0, Null, r_Cardrow.病人病区id), Decode(r_Cardrow.病人科室id, 0, Null, r_Cardrow.病人科室id),
           Decode(r_Cardrow.开单部门id, 0, Null, r_Cardrow.开单部门id), Decode(r_Cardrow.执行部门id, 0, Null, r_Cardrow.执行部门id),
           r_Cardrow.收入项目id, 3, -1 * r_Cardrow.实收金额);
      End If;
    
    Else
      If 结算方式_In Is Not Null Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + (-1 * r_Cardrow.冲预交)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, 结算方式_In, 1, -1 * r_Cardrow.冲预交);
          n_返回值 := -1 * r_Cardrow.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
        End If;
      Else
        If r_Cardrow.结算方式 Is Not Null Then
          --汇总人员缴款余额
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + (-1 * r_Cardrow.冲预交)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Cardrow.结算方式
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, r_Cardrow.结算方式, 1, -1 * r_Cardrow.冲预交);
            n_返回值 := -1 * r_Cardrow.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Cardrow.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End If;
      End If;
      Close c_Cardinfo;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20999, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡记录_Delete;
/

--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_病人预交记录_Delete
(
  Id_In         病人预交记录.Id%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  帐户退费_In   Number := 1,
  冲预交id_In   病人预交记录.Id%Type := Null
) As
  Cursor c_Moneyinfo Is
    Select ID, NO, 金额, 结算方式, 病人id, 预交类别
    From 病人预交记录
    Where ID = Id_In And 记录性质 = 1 And 记录状态 = 1;
  r_Moneyrow c_Moneyinfo%RowType;

  v_打印id   票据打印内容.Id%Type;
  v_性质     结算方式.性质%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;
  n_预交id   病人预交记录.Id%Type;
  v_Date     Date;
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;

  Open c_Moneyinfo;
  Fetch c_Moneyinfo
    Into r_Moneyrow;

  --首先判断要退款的记录是否存在
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Raise Err_Custom;
  Else
    Select Sysdate Into v_Date From Dual;
    If 冲预交id_In Is Not Null Then
      n_预交id := 冲预交id_In;
    Else
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
  
    --预交退款
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持个人帐户退费,正常处理
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要_In, -1 * 金额, 结算方式, 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, 缴款单位,
               单位开户行, 单位帐号, n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    Else
      --不支持时,处理成现金,记录性质为2的摘要填标志,为3的更新新输入的摘要
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, Nvl(摘要_In, '个人帐户退款'), -1 * 金额,
               Decode(结算方式, v_个人帐户, v_现金, 结算方式), 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, Decode(结算方式, v_个人帐户, Null, 缴款单位),
               Decode(结算方式, v_个人帐户, Null, 单位开户行), Decode(结算方式, v_个人帐户, Null, 单位帐号), n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明,
               合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    End If;
  
    Update 病人预交记录 Set 记录状态 = 3, 摘要 = 摘要_In Where ID = Id_In;
  
    --处理相关汇总表
    --人员缴款余额(注意包括处理个人帐户的结算方式)
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持退个人帐户时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    Else
      --不支持时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式)
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式), 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式) And
              Nvl(余额, 0) = 0;
      End If;
    End If;
  
    --病人(预交)余额(不管是退现金还是个人帐户都应该减少)
    --判断要退款的性质
    Select b.性质 Into v_性质 From 病人预交记录 A, 结算方式 B Where a.结算方式 = b.名称(+) And a.Id = Id_In;
    If Nvl(v_性质, 1) <> 5 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 病人id = r_Moneyrow.病人id And Nvl(类型, 2) = Nvl(r_Moneyrow.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, Nvl(r_Moneyrow.预交类别, 2), -r_Moneyrow.金额, 0);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --作废收回票据(可能以前没有使用票据,无法收回)
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = r_Moneyrow.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 2 And 性质 = 1;
    End If;
  
    Close c_Moneyinfo;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20999, '[ZLSOFT]没有发现要退款的预交记录,该记录可能已经退除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Delete;
/

--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_病人预交记录_Reprint
(
  单据号_In 病人预交记录.No%Type,
  票据号_In 票据使用明细.号码%Type,
  领用id_In 票据使用明细.领用id%Type,
  使用人_In 票据使用明细.使用人%Type
) As
  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;

  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Sysdate Into v_Date From Dual;
  Begin
    Select ID
    Into v_收回id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = 单据号_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --重打收回(可能以前没有使用票据,无法收回)
  If v_收回id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, v_Date, 使用人_In
      From 票据使用明细
      Where 打印id = v_收回id And 票种 = 2 And 性质 = 1;
  End If;

  --重新发出票据
  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, 单据号_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 2, 票据号_In, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, v_打印id, v_Date, 使用人_In);
  
    --领用票据当前状态变化
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  
    Update 病人预交记录 Set 实际票号 = 票据号_In Where NO = 单据号_In And 记录性质 = 1;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Reprint;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_医疗卡记录_Insert
(
  --参数：发卡类型=0-发卡,1-补卡,2-换卡(相当于重打)
  --      换卡时,单据号_IN传入的是原发/补卡的单据号。
  --      补卡/换卡后,再换卡时是以最后一次卡号为准。
  发卡类型_In   Number,
  单据号_In     住院费用记录.No%Type,
  病人id_In     住院费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     住院费用记录.标识号%Type,
  费别_In       住院费用记录.费别%Type,
  卡类别id_In   医疗卡类别.Id%Type,
  原卡号_In     病人医疗卡信息.卡号%Type,
  医疗卡号_In   病人医疗卡信息.卡号%Type,
  变动原因_In   病人医疗卡变动.变动原因%Type,
  密码_In       病人信息.卡验证码%Type,
  姓名_In       住院费用记录.姓名%Type,
  性别_In       住院费用记录.性别%Type,
  年龄_In       住院费用记录.年龄%Type,
  病人病区id_In 住院费用记录.病人病区id%Type,
  病人科室id_In 住院费用记录.病人科室id%Type,
  收费细目id_In 住院费用记录.收费细目id%Type,
  收费类别_In   住院费用记录.收费类别%Type,
  计算单位_In   住院费用记录.计算单位%Type,
  收入项目id_In 住院费用记录.收入项目id%Type,
  收据费目_In   住院费用记录.收据费目%Type,
  标准单价_In   住院费用记录.标准单价%Type,
  执行部门id_In 住院费用记录.执行部门id%Type,
  开单部门id_In 住院费用记录.开单部门id%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  加班标志_In   住院费用记录.加班标志%Type,
  发卡时间_In   住院费用记录.登记时间%Type,
  领用id_In     票据使用明细.领用id%Type,
  Ic卡号_In     病人信息.Ic卡号%Type := Null,
  应收金额_In   住院费用记录.应收金额%Type,
  实收金额_In   住院费用记录.实收金额%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  刷卡类别id_In 病人预交记录.卡类别id%Type,
  消费卡_In     Integer := 0,
  刷卡卡号_In   病人医疗卡信息.卡号%Type,
  结帐id_In     病人预交记录.结帐id%Type,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null
  
) As

  Cursor c_Precard Is
    Select ID As 费用id From 住院费用记录 Where 记录性质 = 5 And 实际票号 = 原卡号_In And 病人id = 病人id_In;
  r_Cardrow c_Precard%RowType;

  Cursor c_医疗卡 Is
    Select ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, Nvl(是否刷卡, 0) As 是否刷卡, Nvl(是否自制, 0) As 是否自制,
           Nvl(是否存在帐户, 0) As 是否存在帐户, Nvl(是否全退, 0) As 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, Nvl(是否重复使用, 0) As 是否重复使用
    From 医疗卡类别
    Where ID = 卡类别id_In;
  r_医疗卡 c_医疗卡%RowType;

  v_费用id         住院费用记录.Id%Type;
  v_结帐id         住院费用记录.结帐id%Type;
  v_收回id         票据打印内容.Id%Type;
  v_打印id         票据打印内容.Id%Type;
  n_回收次数       票据使用明细.回收次数%Type;
  n_性质           票据使用明细.性质%Type;
  n_返回值         病人余额.费用余额%Type;
  n_Count          Number(18);
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;
  n_医疗卡重复使用 Number(3);
  Err_Item Exception;
  v_Err_Msg  Varchar2(500);
  n_组id     财务缴款分组.Id%Type;
  n_变动类型 Number;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Open c_医疗卡;
  Fetch c_医疗卡
    Into r_医疗卡;
  If c_医疗卡%RowCount = 0 Then
    Close c_医疗卡;
    v_Err_Msg := '[ZLSOFT]没有发现原医疗卡的相应类别,不能继续操作！[ZLSOFT]';
    Raise Err_Item;
  End If;

  n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
  Close c_医疗卡;
  If Not 结算方式_In Is Null Then
    If Nvl(结帐id_In, 0) <> 0 Then
      v_结帐id := 结帐id_In;
    Else
      Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
    End If;
  End If;
  If 发卡类型_In <> 2 Then
    --发卡和补卡
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  
    Insert Into 住院费用记录
      (ID, 记录性质, 记录状态, NO, 实际票号, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 标识号, 姓名, 性别, 年龄, 费别, 记帐费用, 门诊标志, 加班标志, 开单部门id, 开单人,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 收费细目id, 收费类别, 计算单位, 付数, 数次, 发药窗口, 附加标志, 执行部门id, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 结帐id,
       结帐金额, 缴款组id, 结论)
    Values
      (v_费用id, 5, 1, 单据号_In, 医疗卡号_In, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
       Decode(病人病区id_In, 0, Null, 病人病区id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In), Decode(标识号_In, 0, Null, 标识号_In),
       姓名_In, 性别_In, 年龄_In, 费别_In, Decode(结算方式_In, Null, 1, 0), 3, 加班标志_In, 开单部门id_In, 操作员姓名_In, 操作员编号_In, 操作员姓名_In,
       发卡时间_In, 发卡时间_In, 收费细目id_In, 收费类别_In, 计算单位_In, 1, 1, 医疗卡号_In, 发卡类型_In, 执行部门id_In, 收入项目id_In, 收据费目_In, 标准单价_In,
       应收金额_In, 实收金额_In, v_结帐id, Decode(结算方式_In, Null, Null, 实收金额_In), n_组id, 卡类别id_In);
  
    --如果是现收医疗卡费用，则将结算填入病人预交记录
    If Not 结算方式_In Is Null Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 摘要, 缴款组id, 卡类别id, 卡号, 结算卡序号, 交易流水号,
         交易说明, 结算序号, 合作单位, 结算性质)
      Values
        (n_预交id, 单据号_In, 5, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人科室id_In, 0, Null, 病人科室id_In),
         结算方式_In, 发卡时间_In, 操作员编号_In, 操作员姓名_In, 实收金额_In, v_结帐id, '医疗卡费用', n_组id, Decode(消费卡_In, 0, 刷卡类别id_In, Null),
         刷卡卡号_In, Decode(消费卡_In, 0, Null, 刷卡类别id_In), 交易流水号_In, 交易说明_In, v_结帐id, 合作单位_In, 5);
    
      If 消费卡_In = 1 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 刷卡类别id_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 刷卡类别id_In And 卡号 = 刷卡卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 刷卡类别id_In And 卡号 = 刷卡卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(刷卡类别id_In, n_消费卡id, 结算方式_In, 实收金额_In, 刷卡卡号_In, Null, Null, Null, v_结帐id, n_预交id);
      End If;
    End If;
  
    --发卡使用票据
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
    n_回收次数 := 0;
    If n_医疗卡重复使用 = 1 Then
      Select Nvl(Max(回收次数), 0), Nvl(Max(性质), 0)
      Into n_回收次数, n_性质
      From 票据使用明细
      Where 票种 = 5 And 号码 = 医疗卡号_In;
      If n_回收次数 > 0 Or n_性质 > 0 Then
        n_回收次数 := n_回收次数 + 1;
      End If;
    Else
      --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
      Select Nvl(Max(性质), 0)
      Into n_性质
      From 票据使用明细 A, 票据领用记录 B
      Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
      If n_性质 <> 0 Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || ' 已经使用，不能再进行发卡操作,请检查![ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, 1, 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数), v_打印id, 发卡时间_In, 操作员姓名_In);
    --如果是回收,再发的,则不减剩余数量
    If Nvl(n_回收次数, 0) = 0 Then
      --该批领用状态变化
      Update 票据领用记录
      Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
    End If;
  
    --相关汇总表的处理
    If 结算方式_In Is Null Then
      --汇总'病人余额'
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In
      Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 2) = Decode(Nvl(主页id_In, 0), 0, 1, 2)
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (病人id_In, 1, Decode(Nvl(主页id_In, 0), 0, 1, 2), 0, 实收金额_In);
        n_返回值 := 实收金额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --汇总'病人未结费用'
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + 实收金额_In
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病人病区id_In, 0) And
            Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
            Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 = 3;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Decode(主页id_In, 0, Null, 主页id_In), Decode(病人病区id_In, 0, Null, 病人病区id_In),
           Decode(病人科室id_In, 0, Null, 病人科室id_In), 开单部门id_In, 执行部门id_In, 收入项目id_In, 3, 实收金额_In);
      End If;
    
    Else
      --汇总"人员缴款余额"
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + 实收金额_In
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 实收金额_In);
        n_返回值 := 实收金额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
      End If;
    End If;
  
  Else
    --处理换卡方式
    --首先查找需要换卡的原医疗卡费用记录
    Open c_Precard;
    Fetch c_Precard
      Into r_Cardrow;
  
    If c_Precard%RowCount = 0 Then
      Close c_Precard;
      v_Err_Msg := '[ZLSOFT]没有发现原医疗卡发放记录,换卡操作失败！[ZLSOFT]';
      Raise Err_Item;
    Else
      --仅当有原费用记录时才处理
      --重打收回票据
      Begin
        Select ID
        Into v_收回id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 5 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    
      If v_收回id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 回收次数, 打印id, 发卡时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = v_收回id And 票种 = 5 And 性质 = 1;
      End If;
    
      --重打发出票据
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 5, 单据号_In);
      n_回收次数 := 0;
      If n_医疗卡重复使用 = 1 Then
        Select Nvl(Max(回收次数), 0), Nvl(Max(性质), 0)
        Into n_回收次数, n_性质
        From 票据使用明细
        Where 票种 = 5 And 号码 = 医疗卡号_In;
        If n_回收次数 > 0 Or n_性质 > 0 Then
          n_回收次数 := n_回收次数 + 1;
        End If;
      Else
        --需要检查是否存在票据使用明细，如果存在，肯定会发生错误
        Select Nvl(Max(性质), 0)
        Into n_性质
        From 票据使用明细 A, 票据领用记录 B
        Where a.票种 = 5 And a.号码 = 医疗卡号_In And Nvl(a.领用id, 0) = Nvl(领用id_In, 0) And a.领用id = b.Id;
        If n_性质 <> 0 Then
          v_Err_Msg := '[ZLSOFT]新卡号:' || 医疗卡号_In || ' 已经使用，请换一张新卡,请检查![ZLSOFT]';
          Raise Err_Item;
        End If;
      
      End If;
    
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 5, 医疗卡号_In, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, Decode(n_回收次数, 0, Null, n_回收次数), v_打印id,
         发卡时间_In, 操作员姓名_In);
      --如果是回收,再发的,则不减剩余数量
      If Nvl(n_回收次数, 0) = 0 Then
        --领用状态变化
        Update 票据领用记录
        Set 当前号码 = 医疗卡号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --更改原发卡记录状态
      Update 住院费用记录
      Set 实际票号 = 医疗卡号_In, 发药窗口 = 医疗卡号_In, 附加标志 = 2, 结论 = 卡类别id_In
      Where ID = r_Cardrow.费用id;
      Close c_Precard;
    End If;
  End If;

  --处理相关的变动信息
  --Zl_医疗卡变动_Insert (变动类型_In/病人id_In ,卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 变动时间_In
  --Ic卡号_In, 挂失方式_In)
  --变动类型_In:1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
  n_变动类型 := Case
              When 发卡类型_In = 0 Then
               1
              When 发卡类型_In = 1 Then
               3
              Else
               2
            End;
  Zl_医疗卡变动_Insert(n_变动类型, 病人id_In, 卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 发卡时间_In, Ic卡号_In, Null);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡记录_Insert;
/

--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();

  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And Mod(a.记录性质, 10) = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行) 
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                             a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And Mod(j.记录性质, 10) = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And Mod(j.记录性质, 10) = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             Mod(a.记录性质, 10) = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --该笔项目第几次退费 
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数) 
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        
          --          Update 门诊费用记录 Set 记录状态 = 3 Where ID = r_Bill.Id;
        
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --标记原费用记录 
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(Zl_Getsysparameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理 
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null And
                     (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费 
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费 
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;
Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Custom;
  End If;
  v_操作员编号 := Zl_操作员(1, v_Temp);
  v_操作员姓名 := Zl_操作员(2, v_Temp);

  n_组id := Zl_Get组id(v_操作员姓名);

  d_退号时间 := 退号时间_In;
  If d_退号时间 Is Null Then
    d_退号时间 := Sysdate;
  End If;

  --首先判断要退号/取消预约的记录是否存在
  Begin
    Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0), Decode(记录状态, 0, 1, 0)
    Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
  Exception
    When Others Then
      n_预约挂号 := -1;
  End;

  If n_预约挂号 = -1 Then
    v_Error := '单据可能已经被退号或单据输入错误!';
    Raise Err_Custom;
  End If;

  Begin
    Select 1
    Into n_启用分时段
    From 挂号安排 A, 挂号安排时段 B
    Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --预约检查是否添加合作单位控制
  --如果设置了合作单位控制 则
  Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
  --更新挂号序号状态
  Delete 挂号序号状态
  Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
    If Nvl(n_无效单据, 0) = 0 Then
      --N天内不能取消预约号
      n_Count := Zl_To_Number(Zl_Getsysparameter('N天内不能取消预约号', 1111));
      If n_Count <> 0 Then
        If Trunc(Sysdate - n_Count) < d_登记时间 Then
          v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_状态 := Case n_无效单据
              When 1 Then
               0
              Else
               1
            End;
    --减少已约数
    Open c_Registinfo(n_状态, 2, n_无效单据);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
    End If;
  
    If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
      Update 合作单位挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
            序号 = Nvl(n_号序, 0);
      If Sql%RowCount = 0 Then
        Insert Into 合作单位挂号汇总
          (日期, 号码, 已约数, 合作单位, 序号, 已接数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
      End If;
    End If;
    Close c_Registinfo;
  
    If Nvl(n_无效单据, 0) = 0 Then
      --删除门诊费用记录
      Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
      --如果预约生成队列时需要清除队列
      n_挂号生成队列 := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
      If Nvl(n_挂号生成队列, 0) = 1 Then
        n_预约生成队列 := Zl_To_Number(Zl_Getsysparameter('预约生成队列', 1113));
        If Nvl(n_预约生成队列, 0) = 1 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    End If;
  Else
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  
    --更新挂号序号状态
  
    --病人就诊状态
    Select 病人id Into n_病人id From 门诊费用记录 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
  
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
    End If;
  
    --门诊费用记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
             Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  
    Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    Select 结帐id
    Into n_原结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
  
    Select Count(Distinct 结算方式) Into n_Count From 病人预交记录 Where 结帐id = n_原结帐id;
    If n_Count > 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    n_预交id := 预交id_In;
    If Nvl(预交id_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明, 合作单位,
       结算序号, 卡类别id, 结算性质)
      Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
             交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
      From 病人预交记录
      Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
  
    Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
  
    --退卡收回票据(可能上次挂号使用票据,不能收回)
    Begin
      --从最后一次的打印内容中取
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If n_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
        From 票据使用明细
        Where 打印id = n_打印id And 性质 = 1;
    End If;
  
    --相关汇总表的处理
  
    --病人挂号汇总
    Open c_Registinfo(1, 1);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
        Into n_预约挂号, n_执行状态
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
      --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
      If n_执行状态 > 0 Then
        If n_执行状态 = 1 Then
          v_Error := '该病人已经完成就诊,不能再退号!';
        Else
          v_Error := '该病人正在就诊, 不能退号!';
        End If;
        Raise Err_Custom;
      End If;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
        End If;
      End If;
      Close c_Registinfo;
    End If;
  
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  
    n_挂号生成队列 := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(Zl_Getsysparameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
  End If;

  If Nvl(n_无效单据, 0) = 0 Then
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
    If Sql%NotFound Then
      v_Error := '未找到挂号单据,请检查!';
      Raise Err_Custom;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
      Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
             发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 = 3;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/

--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
Create Or Replace Procedure Zl_病人挂号记录_Reprint
(
  单据号_In   票据打印内容.No%Type,
  票据号_In   票据使用明细.号码%Type,
  领用id_In   票据使用明细.领用id%Type,
  使用人_In   票据使用明细.使用人%Type,
  收费票据_In Number := 0, --是否使用收费票据
  收回票据_In Number := 1 --重打时是否收回票据,退回重打调用时不收回,因为退号时已收回
) As
  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;
  v_Date   Date;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Sysdate Into v_Date From Dual;
  If 收回票据_In = 1 Then
    Begin
      --从最后一次打印的内容中取
      Select ID
      Into v_收回id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  End If;

  --先收回原票据(可能以前未使用票据,不能收回)
  If v_收回id Is Not Null Then
    Begin
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, v_Date, 使用人_In
        From 票据使用明细
        Where 打印id = v_收回id And 性质 = 1;
    Exception
      When Others Then
        Delete From 票据使用明细 Where 打印id = v_收回id And 性质 = 2 And 原因 = 2;
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, v_Date, 使用人_In
          From 票据使用明细
          Where 打印id = v_收回id And 性质 = 1;
    End;
  End If;

  --重新发出票据
  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 4, 单据号_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, Decode(v_收回id, Null, 1, 3), 领用id_In, v_打印id, v_Date,
       使用人_In);
  
    --领用票据当前状态变化
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  
    Update 门诊费用记录 Set 实际票号 = 票据号_In Where 记录性质 = 4 And NO = 单据号_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Reprint;
/

--82684:马政,2015-03-02,成本价调价中差价差算法调整
Create Or Replace Procedure Zl_药品收发记录_成本价调价
(
  药品id_In   In 药品收发记录.药品id%Type,
  执行时间_In In 成本价调价信息.执行日期%Type := Null
) As
  Adjustdate   Date; --调价时间
  n_序号       Number(8);
  n_Stockid    药品收发记录.库房id%Type;
  n_入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数   药品收发记录.入出系数%Type;
  n_收发id     药品收发记录.Id%Type;
  n_调整额     药品收发记录.零售金额%Type;
  n_供应商id   药品收发记录.供药单位id%Type;
  v_No         药品收发记录.No%Type;
  v_应付id     应付记录.Id%Type; --应付记录的ID
  v_应付no     应付记录.No%Type;
  n_原成本价   药品收发记录.成本价%Type;
  n_新成本价   药品收发记录.成本价%Type;
  n_Run        Number(1);
  v_Count      Number(1) := 0;
  v_调价id     成本价调价信息.Id%Type;
  n_平均成本价 药品收发记录.成本价%Type;

  Cursor c_Stock Is --当前库存
    Select 上次供应商id, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.上次批号, a.效期, a.上次产地, a.灭菌效期,
           Decode(Sign(Nvl(a.批次, 0)), 1, a.上次采购价, a.平均成本价) As 原成本价
    From 药品库存 A
    Where a.性质 = 1 And a.药品id = 药品id_In
    Order By a.库房id;

  v_Stock c_Stock%RowType;

  Cursor c_Costadjust Is --成本价调价信息
    Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, a.上次供应商id, Nvl(a.实际数量, 0) As 实际数量, a.实际金额, a.实际差价, a.上次产地 As 产地,
           a.上次批号 As 批号, a.效期, a.上次生产日期 As 生产日期, a.批准文号, a.灭菌效期, a.平均成本价 As 原成本价, b.新成本价, b.发票号, b.发票日期, b.发票金额,
           Nvl(a.上次采购价, 0) As 上次采购价, b.Id As 调价id
    From 药品库存 A, 成本价调价信息 B
    Where a.药品id = b.药品id And Nvl(a.上次供应商id, 0) = Nvl(b.供药单位id, 0) And a.库房id = b.库房id And Nvl(a.批次, 0) = Nvl(b.批次, 0) And
          a.性质 = 1 And b.执行日期 Is Null And a.药品id = 药品id_In
    Order By a.库房id;

  v_Costadjust c_Costadjust%RowType;

  Cursor c_Pay Is --应付管理
    Select Distinct a.供药单位id, a.药品id, a.发票号, a.发票日期, a.发票金额, b.名称, b.计算单位, b.规格
    From 成本价调价信息 A, 收费项目目录 B
    Where a.药品id = b.Id And a.应付款变动 = 1 And a.药品id = 药品id_In And a.供药单位id Is Not Null
    Order By a.供药单位id;

  v_Pay c_Pay%RowType;
Begin
  Adjustdate := Sysdate;
  n_Stockid  := 0;
  n_Run      := 0;

  --判断是否存在无库存调价
  Begin
    Select ID, 新成本价
    Into v_调价id, n_新成本价
    From 成本价调价信息
    Where 执行日期 Is Null And Nvl(库房id, 0) = 0 And 药品id = 药品id_In;
  Exception
    When Others Then
      v_调价id   := 0;
      n_新成本价 := Null;
  End;

  --无库存调价
  If v_调价id > 0 Then
    --根据当前库存重新产生调价信息
    For v_Stock In c_Stock Loop
      Zl_成本价调价信息_Insert(v_Stock.上次供应商id, v_Stock.库房id, v_Stock.药品id, v_Stock.批次, v_Stock.上次批号, v_Stock.效期, v_Stock.上次产地,
                        v_Stock.灭菌效期, v_Stock.原成本价, n_新成本价);
      v_Count := v_Count + 1;
    End Loop;
  
    If v_Count > 0 Then
      --如果当前有库存记录，则删除无库存调价记录
      Delete 成本价调价信息 Where ID = v_调价id;
    Else
      Update 成本价调价信息 Set 执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In) Where ID = v_调价id;
    
      Update 药品规格 Set 成本价 = n_新成本价 Where 药品id = 药品id_In And 成本价 <> n_新成本价;
    End If;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;

  For v_Costadjust In c_Costadjust Loop
    n_Run := 1;
    If n_Stockid <> v_Costadjust.库房id Then
      n_序号    := 1;
      n_Stockid := v_Costadjust.库房id;
      v_No      := Nextno(25, n_Stockid);
    Else
      n_序号 := n_序号 + 1;
    End If;
  
    --产生库存差价调整单
    Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
  
    If v_Costadjust.实际数量 = 0 And (Nvl(v_Costadjust.实际金额, 0) <> 0 Or Nvl(v_Costadjust.实际差价, 0) <> 0) Then
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期)
      Values
        (n_收发id, 1, 5, v_No, n_序号, v_Costadjust.库房id, n_入出类别id, v_Costadjust.上次供应商id, n_入出系数, v_Costadjust.药品id,
         v_Costadjust.批次, v_Costadjust.产地, v_Costadjust.批号, v_Costadjust.效期, 0, v_Costadjust.实际金额, v_Costadjust.实际差价, 0,
         '成本价调价', Zl_Username, Adjustdate, Zl_Username, Adjustdate, v_Costadjust.生产日期, v_Costadjust.批准文号,
         v_Costadjust.新成本价, 1, v_Costadjust.原成本价, v_Costadjust.灭菌效期);
    
      --更新库存
      Zl_药品库存_Update(n_收发id);
    
      Update 药品规格 Set 成本价 = v_Costadjust.新成本价 Where 药品id = v_Costadjust.药品id;
    
      --更新成本价调价信息
      Update 成本价调价信息
      Set 批号 = v_Costadjust.批号, 效期 = v_Costadjust.效期, 产地 = v_Costadjust.产地, 灭菌效期 = v_Costadjust.灭菌效期, 收发id = n_收发id,
          执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In)
      Where ID = v_Costadjust.调价id;
    Else
      --n_调整额   := (v_Costadjust.实际金额 - v_Costadjust.实际差价) - Round(v_Costadjust.新成本价 * v_Costadjust.实际数量, 2);
      n_调整额   := (v_Costadjust.原成本价 - v_Costadjust.新成本价) * v_Costadjust.实际数量;
      n_原成本价 := v_Costadjust.原成本价;
      If n_原成本价 = 0 Then
        n_原成本价 := v_Costadjust.上次采购价;
      End If;
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期)
      Values
        (n_收发id, 1, 5, v_No, n_序号, v_Costadjust.库房id, n_入出类别id, v_Costadjust.上次供应商id, n_入出系数, v_Costadjust.药品id,
         v_Costadjust.批次, v_Costadjust.产地, v_Costadjust.批号, v_Costadjust.效期, v_Costadjust.实际数量, v_Costadjust.实际金额,
         v_Costadjust.实际差价, n_调整额, '成本价调价', Zl_Username, Adjustdate, Zl_Username, Adjustdate, v_Costadjust.生产日期,
         v_Costadjust.批准文号, v_Costadjust.新成本价, 1, n_原成本价, v_Costadjust.灭菌效期);
    
      --更新库存
      Zl_药品库存_Update(n_收发id, 0);
    
      Update 药品规格
      Set 成本价 = v_Costadjust.新成本价
      Where 药品id = v_Costadjust.药品id And 成本价 <> v_Costadjust.新成本价;
    
      --更新成本价调价信息
      Update 成本价调价信息
      Set 批号 = v_Costadjust.批号, 效期 = v_Costadjust.效期, 产地 = v_Costadjust.产地, 灭菌效期 = v_Costadjust.灭菌效期, 原成本价 = n_原成本价,
          收发id = n_收发id, 执行日期 = Decode(执行时间_In, Null, Adjustdate, 执行时间_In)
      Where ID = v_Costadjust.调价id;
    End If;
  End Loop;

  --产生应付记录及修改应付余额
  If n_Run = 1 Then
    For v_Pay In c_Pay Loop
      v_应付no := Nextno(67);
    
      Select 应付记录_Id.Nextval Into v_应付id From Dual;
    
      Insert Into 应付记录
        (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 发票号, 发票日期, 发票金额, 品名, 规格, 填制人, 填制日期, 摘要)
      Values
        (v_应付id, 1, 1, v_Pay.供药单位id, v_应付no, 1, v_Pay.发票号, v_Pay.发票日期, v_Pay.发票金额, v_Pay.名称, v_Pay.规格, Zl_Username,
         Adjustdate, '成本价调价自动产生应付款变动记录');
    
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(v_Pay.发票金额, 0) Where 单位id = v_Pay.供药单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (v_Pay.供药单位id, 1, Nvl(v_Pay.发票金额, 0));
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_成本价调价;
/

--66870:刘尔旋,2015-02-11,挂号时间段新增提前时间
Create Or Replace Procedure Zl_时间段_Insert
(
  时间段_In   时间段.时间段%Type,
  开始时间_In 时间段.开始时间%Type,
  终止时间_In 时间段.终止时间%Type,
  缺省时间_In 时间段.缺省时间%Type := Null,
  提前时间_In 时间段.提前时间%Type := Null,
  提前颜色_In 时间段.提前颜色%Type := Null
) As
Begin
  Update 时间段
  Set 开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 缺省时间 = Nvl(缺省时间_In, 终止时间_In), 提前时间 = 提前时间_In, 提前颜色 = 提前颜色_In
  Where 时间段 = 时间段_In;

  If Sql%RowCount = 0 Then
    Insert Into 时间段
      (时间段, 开始时间, 终止时间, 缺省时间, 提前时间, 提前颜色)
    Values
      (时间段_In, 开始时间_In, 终止时间_In, Nvl(缺省时间_In, 终止时间_In), 提前时间_In, 提前颜色_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_时间段_Insert;
/

--83072:刘尔旋,2015-03-11,自定义获取标识
--82675:刘尔旋,2015-02-11,通过就诊卡号查找病人
Create Or Replace Procedure Zl_Third_Findcards
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:获取医疗卡类别 
  --入参:Xml_In: 
  --  <IN>
  --       <SFZ>身份证号</SFZ >不传入时,表示查询全部启用的医疗卡类别ID
  --  </IN>
  --出参:Xml_Out 
  -- <OUTPUT>
  --    <LIST>
  --        <JZK>
  --            <LB>卡类别</LB>
  --            <KH>卡号</KH>
  --        </JZK>
  --        <JZK>
  --            ...
  --        </JZK>
  --    </LIST>
  --    如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  -- </OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_身份证 Varchar2(50);

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT><LIST></LIST></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/SFZ') Into v_身份证 From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  For c_Item In (Select Distinct b.名称, a.卡号
                 From 病人医疗卡信息 A, 医疗卡类别 B
                 Where a.卡类别id = b.Id And Nvl(b.是否启用, 0) = 1 And
                       a.病人id In
                       (Select 病人id
                        From 病人信息
                        Where 身份证号 = v_身份证
                        Union All
                        Select 病人id
                        From 病人医疗卡信息
                        Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 Like '%身份证%' And Nvl(是否启用, 0) = 1) And
                              卡号 = v_身份证) And
                       (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                        (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) Loop
    v_Temp := '<LB>' || c_Item.名称 || '</LB>';
    v_Temp := v_Temp || '<KH>' || c_Item.卡号 || '</KH>';
    v_Temp := '<JZK>' || v_Temp || '</JZK>';
    Select Appendchildxml(x_Templet, '/OUTPUT/LIST', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;
  --自定义查询  
  Zl_Third_Custom_Findcards(Xml_In, x_Templet);

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Findcards;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--82722:刘尔旋,2015-02-13,结帐作废操作员问题
--81907:冉俊明,2015-02-27,部分退费重打票据时使用了新票据但未回收旧票据。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_病人结帐记录_Delete
(
  No_In           病人结帐记录.No%Type,
  操作员编号_In   病人结帐记录.操作员编号%Type,
  操作员姓名_In   病人结帐记录.操作员姓名%Type,
  误差金额_In     病人预交记录.冲预交%Type := 0, --医保或预交退现金产生的误差
  结帐作废结算_In Varchar2 := Null, --结算方式|结算金额|结算号码||......
  预交退现金_In   Number := 0 --当预交款退现金时，结算方式及金额通过参数结帐作废结算_In传入
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --该游标用于预交记录相关信息
  Cursor c_Deposit(v_Id 病人预交记录.结帐id%Type) Is
    Select 病人id, 记录性质, 结算方式, 冲预交, 预交类别 From 病人预交记录 Where 结帐id = v_Id;
  r_Depositrow c_Deposit%RowType;

  --该游标用于处理费用相关汇总表
  Cursor c_Money(v_Id 病人预交记录.结帐id%Type) Is
    Select NO, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 病人id, 主页id, 收入项目id, 门诊标志, 结帐金额
    From 住院费用记录
    Where 结帐id = v_Id
    Union All
    Select NO, 开单部门id, 病人科室id, 执行部门id, 0 As 病人病区id, 病人id, 0 As 主页id, 收入项目id, 门诊标志, 结帐金额
    From 门诊费用记录
    Where 结帐id = v_Id;

  r_Moneyrow c_Money%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容   Varchar2(500);
  v_当前结算   Varchar2(50);
  v_结算方式   病人预交记录.结算方式%Type;
  n_结算金额   病人预交记录.冲预交%Type;
  v_结算号码   病人预交记录.结算号码%Type;
  v_实际票号   病人预交记录.实际票号%Type;
  v_误差no     住院费用记录.No%Type;
  v_误差       结算方式.名称%Type;
  n_病人id     病人信息.病人id%Type;

  n_原id   病人结帐记录.Id%Type;
  n_结帐id 病人结帐记录.Id%Type;
  n_打印id 票据打印内容.Id%Type;

  n_来源       Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值     病人余额.预交余额%Type;
  n_组id       财务缴款分组.Id%Type;
  n_预交类别   Number;
  d_Date       Date;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  Select 名称 Into v_误差 From 结算方式 Where 性质 = 9 And Rownum = 1;
  Begin
    Select ID, 病人id, 实际票号 Into n_原id, n_病人id, v_实际票号 From 病人结帐记录 Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;
  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, d_Date, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 = 3 And 性质 = 1;
  End If;

  --病人预交记录(冲预交及缴款)
  If 结帐作废结算_In Is Null Then
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id, Null,
             结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 合作单位, 2
      From 病人预交记录
      Where 结帐id = n_原id And (记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0 Or 记录性质 Not In (1, 11));
  Else
    --1.先处理冲预交部分
    If 预交退现金_In = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = n_原id And 记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0;
    End If;
  
    --2.再处理结帐结算,包括医保和非医保
    v_结算内容 := 结帐作废结算_In || ' ||'; --以空格分开以|结尾,没有结算号码的
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐作废退款',
         Null, Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, -1 * n_结算金额, n_结帐id, n_组id, 2);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;
  --确定结帐的费用记录来源
  Begin
    Select Case
             When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
              3
             When Nvl(Max(住院), 0) = 1 Then
              2
             Else
              1
           End
    Into n_来源
    From (Select 1 As 住院, 0 As 门诊
           From 住院费用记录
           Where 结帐id = n_原id And Rownum = 1
           Union All
           Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原id And Rownum = 1);
  
  Exception
    When Others Then
      n_来源 := 3;
  End;

  If 误差金额_In <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 误差金额_In
    Where NO = No_In And 记录性质 = 12 And 记录状态 = 1 And 结帐id = n_结帐id;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_误差, Null, '结帐作废退款', Null,
         Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, 误差金额_In, n_结帐id, n_组id, 2);
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;
  --相关汇总表处理
  For r_Depositrow In c_Deposit(n_结帐id) Loop
    If r_Depositrow.记录性质 In (1, 11) Then
    
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Depositrow.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Depositrow.病人id And 类型 = Nvl(r_Depositrow.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Depositrow.病人id, 1, Nvl(r_Depositrow.预交类别, 2), -1 * r_Depositrow.冲预交, 0);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 性质 = 1 And 病人id = r_Depositrow.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Depositrow.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Depositrow.结算方式, 1, r_Depositrow.冲预交);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;

  For r_Moneyrow In c_Money(n_结帐id) Loop
    --病人余额 ,误差项已结帐,所以不需要更新这两个汇总表
    If Nvl(v_误差no, 'sc') <> Nvl(r_Moneyrow.No, 'sc') Then
      If Nvl(r_Moneyrow.门诊标志, 0) = 1 Or Nvl(r_Moneyrow.门诊标志, 0) = 2 Then
        n_预交类别 := r_Moneyrow.门诊标志;
      Elsif Nvl(r_Moneyrow.主页id, 0) = 0 Or Nvl(r_Moneyrow.门诊标志, 0) = 4 Then
        --体检:门诊病人
        n_预交类别 := 1;
      Else
        n_预交类别 := 2;
      End If;
    
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - r_Moneyrow.结帐金额 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Moneyrow.病人id And 类型 = n_预交类别 And 性质 = 1
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, n_预交类别, 0, -1 * r_Moneyrow.结帐金额);
        n_返回值 := -1 * r_Moneyrow.结帐金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_Moneyrow.结帐金额
      Where 病人id = r_Moneyrow.病人id And Nvl(主页id, 0) = Nvl(r_Moneyrow.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Moneyrow.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Moneyrow.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Moneyrow.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Moneyrow.执行部门id, 0) And
            收入项目id + 0 = r_Moneyrow.收入项目id And 来源途径 + 0 = r_Moneyrow.门诊标志;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Moneyrow.病人id, Decode(r_Moneyrow.主页id, Null, Null, 0, Null, r_Moneyrow.主页id),
           Decode(r_Moneyrow.病人病区id, Null, Null, 0, Null, r_Moneyrow.病人病区id), r_Moneyrow.病人科室id, r_Moneyrow.开单部门id,
           r_Moneyrow.执行部门id, r_Moneyrow.收入项目id, r_Moneyrow.门诊标志, -1 * r_Moneyrow.结帐金额);
      End If;
    End If;
  End Loop;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Delete;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-12,部分退费重打票据时使用了新票据但未回收旧票据。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。 
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。 
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生 
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额) 
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式) 
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录 
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了 
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中 
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用 
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id   := Zl_Get组id(操作员姓名_In);
  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称 
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行) 
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能) 
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录 
          n_费用状态 := 0;
          --该笔项目第几次退费 
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9 
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数) 
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9 
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --------------------------------------------------------------------------------- 
  --处理病人预交记录 

  --原单据的结帐ID 
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完 
    --冲预交部分记录 
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额 
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理) 
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对. 
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上 
      --需要处理误差金额
    Else
      --a.原样退回 
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    ------------------------------------------------- 
    --部分退费直接退为指定结算方式 
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * (n_总金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志, 1, 2, 0), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交 
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --检查是否已经处理完 
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If Nvl(校对标志_In, 0) = 0 Then
        --更新病人预交余额 
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
          n_返回值 := n_总金额 + Nvl(误差_In, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  --------------------------------------------------------------------------------- 
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款) 
  --如果是需要校对的,暂不处理人员缴款余额 
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(Zl_Getsysparameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理 
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null And
                     (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费 
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费 
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--76674:余伟节,2015-02-10,撤消预约登记病人不检查住院日报
--78184:余伟节,2015-03-17,再入院病人取消入院登记时病人信息的入院时间和出院时间要与最后一次入院记录保持一致
Create Or Replace Procedure Zl_入院病案主页_Delete
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转留观_In     Number := 0,
  清除住院号_In Number := 0
  --功能：取消病人入院/预约登记
  --     主页ID_IN:为0时表示取消预约登记
  --     转留观_IN:将正常入院登记病人转为住院留观病人
  --     清除住院号_In:第一次住院的病人转留观时是否清除住院号
) As
  v_入院时间   病案主页.入院日期%Type;
  v_入院科室   病案主页.入院科室id%Type;
  v_出院时间   病案主页.出院日期%Type;
  v_住院号     病案主页.住院号%Type;
  v_再入院     病案主页.再入院%Type;
  v_出院科室id 病案主页.出院科室id%Type;
  n_病人性质   病案主页.病人性质%Type;
  n_主页id     病案主页.主页id%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Nvl(状态, 0), Nvl(病人性质, 0)
  Into v_Count, n_病人性质
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 1 Then
    v_Error := '该病人已经入科,请先将病人撤消至入院状态。';
    Raise Err_Custom;
  End If;

  --删除电子病历时机
  Select 出院科室id, 再入院 Into v_出院科室id, v_再入院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_再入院 = 0 Then
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', v_出院科室id);
  Else
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '再次入院', v_出院科室id);
  End If;

  --提取最近一次不为空的住院号
  Begin
    If 主页id_In = 0 Then
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0 And Nvl(住院号, 0) <> 0);
    Else
      Select 住院号
      Into v_住院号
      From 病案主页
      Where 病人id = 病人id_In And
            主页id =
            (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And 主页id < 主页id_In And Nvl(住院号, 0) <> 0);
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 转留观_In = 1 And Nvl(主页id_In, 0) <> 0 Then
    Update 病案主页
    Set 病人性质 = 2, 住院号 = Decode(清除住院号_In, 1, Null, 住院号)
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(病人性质, 0) = 0;
  
    --调整住院次数
    Update 病人信息 Set 住院次数 = Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null) Where 病人id = 病人id_In;
    If 清除住院号_In = 1 Then
      Update 病人信息 Set 住院号 = v_住院号 Where 病人id = 病人id_In;
    End If;
  Else
    Begin
      Select b.入院日期, b.出院日期, b.入院科室id
      Into v_入院时间, v_出院时间, v_入院科室
      From 病人信息 A, 病案主页 B
      Where a.病人id = 病人id_In And a.病人id = b.病人id And a.主页id = b.主页id And Nvl(b.主页id, 0) <> 0;
    Exception
      When Others Then
        Null;
    End;
    --撤消预约登记病人不检查住院日报
    If Nvl(主页id_In, 0) <> 0 Then
      Select Zl_住院日报_Count(v_入院科室, v_入院时间) Into v_Count From Dual;
      If v_Count > 0 Then
        v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
        Raise Err_Custom;
      End If;
    End If;
    --门诊留观病人下达入院通知后存在两条有效的病案主页记录（36549）
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 入院日期 Is Not Null And 出院日期 Is Null;
    If Not v_Count > 1 Then
      v_Count := 0;
      If Nvl(主页id_In, 0) <> 0 And Nvl(n_病人性质, 0) = 0 Then
        v_Count := 1;
      End If;
      --再入院病人,取消入院登记时,病人信息的入院时间和出院时间应该回退到上一次入院日期和出院日期
      If v_再入院 = 1 Then
        Select 入院日期, 出院日期
        Into v_入院时间, v_出院时间
        From 病案主页
        Where 病人id = 病人id_In And
              主页id =
              (Select Max(主页id) From 病案主页 Where 病人id = 病人id_In And 主页id < 主页id_In And Nvl(住院号, 0) <> 0);
      End If;
    
      Update 病人信息
      Set 住院号 = v_住院号, 住院次数 = Decode(v_Count, 0, 住院次数, Decode(Sign(住院次数 - 1), 1, 住院次数 - 1, Null)), 当前科室id = Null,
          当前病区id = Null, 当前床号 = Null, 入院时间 = v_入院时间, 出院时间 = v_出院时间, 担保人 = Null, 担保额 = Null, 担保性质 = Null, 在院 = Null
      Where 病人id = 病人id_In;
      Delete From 在院病人 Where 病人id = 病人id_In;
    End If;
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 记录来源 = 2;
  
    --本次住院如果交了预交款,改为当作门诊交的
    Update 病人预交记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    --本次发卡的,改变门诊发卡
    Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 5;
  
    --本次住院的所有费用记录无结算且已全部冲销，则将对应费用记录中的"主页ID"清除。
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1 And 结帐id Is Not Null;
  
    If v_Count = 0 Then
      Begin
        Select Nvl(Count(*), 0)
        Into v_Count
        From 住院费用记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1
        Group By NO, 记录性质, 序号
        Having Nvl(Sum(实收金额), 0) <> 0;
      Exception
        When Others Then
          v_Count := 0;
      End;
    
      If v_Count = 0 Then
        Delete 病人未结费用 Where 病人id = 病人id_In And 主页id = 主页id_In And 金额 = 0;
        Update 住院费用记录 Set 主页id = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 记帐费用 = 1;
      End If;
    End If;
  
    --本次住院所有医嘱记录都已作废
    v_Count := 0;
    Select Nvl(Count(*), 0)
    Into v_Count
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(医嘱状态, 0) <> 4;
    If v_Count = 0 Then
      Delete From 病人医嘱记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
  
    --以下表,没有建病案主页(病人ID,主页ID)的外键,因为其主页ID可能是挂号ID
    Delete From 病人过敏记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人诊断记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 病人新生儿记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历记录 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    Delete From 电子病历打印 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --如果入院发放了就诊卡,则删除会失败(病人费用记录主页ID有外键约束)
    Delete From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0);
    --修改病人信息的主页ID和住院次数
    Select Max(主页id) Into n_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
    Update 病人信息 Set 主页id = n_主页id Where 病人id = 病人id_In;
    If n_主页id Is Null Then
      Update 病人信息 Set 住院次数 = Null Where 病人id = 病人id_In;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Delete;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-12,部分退费重打票据时使用了新票据但未回收旧票据。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7'))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_总金额
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额, 1);
        n_返回值 := n_总金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(Zl_Getsysparameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4')
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--83618:刘尔旋,2015-03-30,退号挂号汇总问题
--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-11,部分退费重打票据时使用了新票据但未回收旧票据。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_病人挂号记录_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.记录状态 = v_状态 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = 单据号_In And
          Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 2 And b.记录性质 = 4 And b.记录状态 = 2 And
          Nvl(b.冲预交, 0) <> 0 And
          Nvl(a.附加标志, 0) =
          Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(a.附加标志, 0), 1, -1, Nvl(a.附加标志, 0)), Nvl(a.附加标志, 0));

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  
    --更新挂号序号状态
    Delete 挂号序号状态
    Where 状态 = 2 And
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, Trunc(发生时间)
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In) Or
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, 发生时间
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  
    --Update 病人挂号记录 set 摘要=nvl(摘要_IN,摘要) where NO=单据号_IN;
    --删除门诊费用记录
    Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) <> 2 Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Delete 挂号序号状态
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    Else
      Update 挂号序号状态
      Set 状态 = 4
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) <> 2 Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  --门诊费用记录
  --冲销记录
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
     数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
     结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
           收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
           操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
           Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
           Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));

  --原始记录
  If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
    Update 门诊费用记录
    Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  Else
    Update 门诊费用记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
          Rownum = 1;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 非原样退结算_In Is Not Null Then
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                Nvl(附加标志, 0) =
                Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
        
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
        Begin
          Select 冲预交
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
      
        --a.允许的结算方式
      
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        If n_退费金额 = 0 Then
          --b.不允许的退现金
          If n_退款金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
              Exception
                When Others Then
                  v_退指定结算方式 := '现金';
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退款金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --a.允许的结算方式原样退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        --b.不允许的退现金
        Begin
          Select Sum(冲预交)
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
        If n_退费金额 <> 0 Then
          If v_退指定结算方式 Is Null Then
            --退给现金
            Begin
              Select 结算方式
              Into v_退指定结算方式
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
            
            Exception
              When Others Then
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
            End;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * n_退费金额)
          Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                     操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录 A
              Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
          End If;
        End If;
      End If;
    Else
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                Nvl(附加标志, 0) =
                Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
      End If;
      If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
        --首次全退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
      Else
        --二次退费,或者本次单退一部分
        --二次退费时,记录状态=3 ,首次部分退,记录状态为1
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                 -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And 冲预交 = n_退款金额 And
                Rownum < 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And Rownum < 2;
        End If;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
          If Sql%RowCount = 0 Then
            --部分退费,并且全部使用预交款缴费时才存在此种情况
            n_预交金额 := n_退款金额;
          End If;
        End If;
      
      End If;
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If Nvl(退费类型_In, 0) <> 2 Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  Open c_Registinfo(3);
  Fetch c_Registinfo
    Into r_Registrow;

  If c_Registinfo%RowCount = 0 Then
    --只收病历费时无号别,不处理
    Close c_Registinfo;
  Else
  
    --需要确定是否预约挂号
    --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
    --2.如果是正常挂号,则只减已挂数
  
    Begin
      Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
    Exception
      When Others Then
        n_预约挂号 := 0;
    End;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where 日期 = Decode(n_预约挂号, 0, Trunc(r_Registrow.发生时间), Trunc(r_Registrow.接收时间)) And 科室id = r_Registrow.科室id And
          项目id = r_Registrow.项目id And (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (Decode(n_预约挂号, 0, Trunc(r_Registrow.发生时间), Trunc(r_Registrow.接收时间)), r_Registrow.科室id, r_Registrow.项目id,
         r_Registrow.医生姓名, Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号,
         -1 * n_预约挂号);
    End If;
  
    Close c_Registinfo;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) <> 2 Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Delete;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--81907:冉俊明,2015-02-27,部分退费重打票据时使用了新票据但未回收旧票据。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊转住院_收费转出
(
  结算序号_In   病人预交记录.结算序号%Type,
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  三方退费_In   Number := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  --门诊退费_In:0-门诊转住院立即销帐;1-门诊退费模式
  -- 门诊退费_In为1时:入院科室id_In和主页ID_IN可以不传入
  n_Count      Number(5);
  n_原结帐id   住院费用记录.结帐id%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  n_组id       财务缴款分组.Id%Type;
  n_病人id     病人信息.病人id%Type;
  v_预交no     病人预交记录.No%Type;
  n_预交金额   病人预交记录.冲预交%Type;
  n_打印id     票据使用明细.打印id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_返回值     病人余额.费用余额%Type;
  n_部分退费   Number(5);
  n_退费条数   Number(5);
  v_结算方式   结算方式.名称%Type;
  v_Nos        Varchar2(3000);
  n_退现       Number(5);
  v_结帐ids    Varchar2(3000);
  n_Tempid     病人预交记录.Id%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  For r_Nos In (Select Distinct a.No
                From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
    v_Nos := v_Nos || ',' || r_Nos.No;
  End Loop;
  v_Nos := Substr(v_Nos, 2);

  For r_结帐ids In (Select Distinct a.结帐id
                  From 门诊费用记录 A
                  Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                        a.记录状态 <> 0) Loop
    v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
  End Loop;
  v_结帐ids := Substr(v_结帐ids, 2);
  Select Count(a.No), Sum(a.实收金额)
  Into n_Count, n_实收金额
  From 门诊费用记录 A
  Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1;
  If n_Count = 0 Or n_实收金额 = 0 Then
    v_Err_Msg := '本次结算不是收费或因并发原因他人操作了该结算,不能转为住院费用.';
    Raise Err_Item;
  End If;

  Select 结帐id, 病人id, 开单部门id, 开单人
  Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
  From 门诊费用记录
  Where 结帐id = Abs(结算序号_In) And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;

  Begin
    Select 1
    Into n_部分退费
    From 门诊费用记录 A
    Where Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
          Rownum < 2;
  Exception
    When Others Then
      n_部分退费 := 0;
  End;

  Begin
    Select 0
    Into n_部分退费
    From 门诊费用记录 A
    Where 记录性质 = 11 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Rownum < 2;
  Exception
    When Others Then
      Null;
  End;
  Begin
    Select Count(Avg(1))
    Into n_退费条数
    From 病人预交记录 A
    Where a.记录性质 = 3 And a.记录状态 <> 0 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))
    Group By a.结算方式;
  Exception
    When Others Then
      n_退费条数 := 0;
  End;
  --1.1作废费用记录
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位,
     付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号,
     操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
    Select 病人费用记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
           a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志, a.收入项目id,
           a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.执行人, -1, a.执行时间,
           操作员编号_In, 操作员姓名_In, a.发生时间, 退费时间_In, n_结帐id, -1 * a.结帐金额, a.保险项目否, a.保险大类id, a.统筹金额, a.摘要,
           Decode(Nvl(a.附加标志, 0), 9, 1, 0), a.保险编码, a.费用类型, n_组id
    From 门诊费用记录 A
    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1;

  --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  --1.2作废预交记录
  --作废冲预交部分
  If n_部分退费 = 0 Then
    For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交, 卡类别id,
                            结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                     From 病人预交记录 A
                     Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Nvl(冲预交, 0) <> 0
                     Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                              交易流水号, 交易说明, 合作单位, 结算性质) Loop
      Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
        Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
               r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
               操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
               r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
        From Dual;
    End Loop;
  
    For v_预交 In (Select Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录 A
                 Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                       a.结帐id <> n_结帐id
                 Group By Nvl(预交类别, 2)
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, Nvl(v_预交.预交类别, 2), n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  Else
    If n_退费条数 = 0 And Nvl(门诊退费_In, 0) = 0 Then
      --只使用了预交，原样退回预交
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, Max(结算方式) As 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间,
                              -1 * Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Nvl(冲预交, 0) <> 0
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                                交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
          From Dual;
        Select -1 * 冲预交 Into n_预交金额 From 病人预交记录 Where ID = n_Tempid;
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_预交金额, 0)
        Where 病人id = n_病人id And 类型 = 1 And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_预交金额, 1);
          n_返回值 := n_预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1;
      Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null, Null,
               Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null, -1 * n_原结帐id, 3
        From 病人预交记录 A
        Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Nvl(冲预交, 0) <> 0
        Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
    End If;
  End If;

  --作废门诊缴费及医保部分
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
     卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
    Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In, 0,
           n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
    From 病人预交记录 A, 结算方式 B
    Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
          a.结算方式 = b.名称 And b.性质 <> 8;

  Update 病人预交记录
  Set 记录状态 = 3
  Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));

  --2.票据收回
  --可能以前没有打印,无收回
  For r_Nos In (Select Distinct a.No
                From 门诊费用记录 A
                Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                      a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
  
    Select Nvl(Max(ID), 0)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = r_Nos.No
           Order By a.使用时间 Desc)
    Where Rownum < 2;
    If n_打印id > 0 Then
      --多张单据循环调用时只能收回一次
      Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      End If;
    End If;
  End Loop;

  --3.缴款数据处理(
  --   现有两种情况:
  --    1. 转出过程直接销帐的,则缴款数据不增加;
  --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
  If Nvl(门诊退费_In, 0) = 1 Then
    For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                        Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                 From 病人预交记录 A, 结算方式 B
                 Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                       b.性质 In (1, 2, 3, 4, 7, 8)
                 Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                 Having Sum(a.冲预交) <> 0) Loop
      If c_预交.性质 In (3, 4, 8) Then
        v_结算方式 := c_预交.结算方式;
      Else
        If 结算方式_In Is Null Then
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
        Else
          v_结算方式 := 结算方式_In;
        End If;
      End If;
      If c_预交.性质 = 7 Then
        Begin
          Select 1 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id And 是否退现 = 1;
        Exception
          When Others Then
            n_退现 := 0;
        End;
        If n_部分退费 = 0 Then
          If n_退现 = 0 And 三方退费_In = 0 Then
            v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
            Raise Err_Item;
          End If;
          If n_退现 = 1 Then
            If 结算方式_In Is Null Then
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
          If 三方退费_In = 1 Then
            v_结算方式 := c_预交.结算方式;
          End If;
        Else
          If 三方退费_In = 1 Then
            v_结算方式 := c_预交.结算方式;
          End If;
          If n_退现 = 0 And 三方退费_In = 0 Then
            v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If c_预交.性质 = 8 Then
        Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id);
      End If;
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - c_预交.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
        n_返回值 := c_预交.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
      End If;
      --部分退费情况，退原预交记录
      If c_预交.性质 <> 8 Then
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
             c_预交.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
        End If;
      End If;
    End Loop;
  
    --更新费用审核记录
    Update 费用审核记录
    Set 记录状态 = 2
    Where 费用id In (Select a.Id
                   From 门诊费用记录 A
                   Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                         a.记录状态 In (1, 3)) And 性质 = 1;
    --作废门诊记录
    For r_Nos In (Select Distinct NO
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And
                        结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) = 1 And 记录状态 = 1;
    End Loop;
    For r_Clinic In (Select Min(a.记录性质) As 记录性质, a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别,
                            a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, Sum(a.数次) As 数次,
                            a.加班标志, a.附加标志, a.婴儿费, a.收入项目id, a.收据费目, a.标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额,
                            Sum(a.统筹金额) As 统筹金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.记帐单id, a.是否急诊, a.发生时间,
                            Min(a.实际票号) As 实际票号
                     From 门诊费用记录 A
                     Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                           a.记录状态 In (2, 3) And a.附加标志 Not In (8, 9)
                     Group By a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别, a.收费类别, a.收费细目id,
                              a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, a.加班标志, a.附加标志, a.婴儿费, a.收入项目id,
                              a.收据费目, a.标准单价, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.记帐单id, a.是否急诊, a.发生时间
                     Having Sum(a.数次) <> 0) Loop
      Insert Into 门诊费用记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
         保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人,
         发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态)
      Values
        (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Clinic.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
         r_Clinic.病人id, '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
         r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
         r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.婴儿费, r_Clinic.收入项目id, r_Clinic.收据费目,
         r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人,
         r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊,
         n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1);
    End Loop;
  Else
    --4.退款转预交(不产生票据,由操作员通过重打进行)
  
    For r_Pay In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                         Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                  From 病人预交记录 A, 结算方式 B
                  Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                        a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                        b.性质 In (1, 2, 3, 4, 7, 8)
                  Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                  Having Sum(a.冲预交) <> 0) Loop
      --4.1产生预交款单据 (不存在部分退费的情况)
      --所有单据,按规则生成预交款单据
      --因为收款后立即缴款,所以人员缴款余额无变化
      If n_部分退费 = 0 Or n_退费条数 = 1 Then
        v_结算方式 := r_Pay.结算方式;
      Else
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
      End If;
      If r_Pay.性质 = 7 Then
        Begin
          Select 1 Into n_退现 From 医疗卡类别 Where ID = r_Pay.卡类别id And 是否退现 = 1;
        Exception
          When Others Then
            n_退现 := 0;
        End;
        If n_部分退费 = 0 Then
          If 三方退费_In = 1 Then
            v_结算方式 := r_Pay.结算方式;
          End If;
          If n_退现 = 0 And 三方退费_In = 0 Then
            v_结算方式 := r_Pay.结算方式;
          End If;
          If n_退现 = 1 And 三方退费_In = 0 Then
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
          End If;
        Else
          If 三方退费_In = 1 Then
            v_结算方式 := r_Pay.结算方式;
          End If;
          If n_退现 = 0 And 三方退费_In = 0 Then
            v_结算方式 := r_Pay.结算方式;
          End If;
        End If;
      End If;
    
      If r_Pay.性质 = 8 Then
        Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id);
      End If;
      If (r_Pay.性质 Not In (3, 4, 7, 8)) Or (r_Pay.性质 = 7 And 三方退费_In = 0) Then
        Update 病人预交记录
        Set 金额 = 金额 + r_Pay.冲预交
        Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And Nvl(预交类别, 2) = 2;
        If Sql%RowCount = 0 Then
          v_预交no := Nextno(11);
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 预交类别, 结算性质)
          Values
            (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In, Null,
             Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2, Null);
        End If;
      
        --病人余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
        Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
          n_返回值 := r_Pay.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End If;
      --4.2缴款数据处理
      --   因为没有实际收病人的钱,所以不处理
      --部分退费情况，退原预交记录
      If r_Pay.性质 In (3, 4, 8) Or (r_Pay.性质 = 7 And 三方退费_In = 1) Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
          n_返回值 := r_Pay.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If r_Pay.性质 <> 8 Then
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
             r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
        End If;
      End If;
    End Loop;
  End If;
  Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
  Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_收费转出;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_病人预约挂号_接收
(
  No_In         病人挂号记录.No%Type,
  诊室_In       病人挂号记录.诊室%Type,
  结帐id_In     门诊费用记录.结帐id%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  接收时间_In   病人挂号记录.接收时间%Type := Null
  --该过程用于直接完成预约挂号接收、就诊；主要是医生站使用。
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(n_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = n_病人id And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = n_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  --号别信息
  Cursor c_Regist Is
    Select b.科室id, b.项目id, b.医生id, b.医生姓名, b.号码
    From 门诊费用记录 A, 挂号安排 B
    Where a.记录性质 = 4 And a.记录状态 = 1 And a.No = No_In And a.序号 = 1 And a.计算单位 = b.号码;
  r_Regist c_Regist%RowType;

  v_划价no       门诊费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     门诊费用记录.操作员编号%Type;
  v_人员姓名     门诊费用记录.操作员姓名%Type;
  v_挂号生成队列 Varchar2(2);
  v_排队号码     排队叫号队列.排队号码%Type;
  v_预约方式     病人挂号记录.预约方式%Type;

  n_病人id   病人挂号记录.病人id%Type;
  n_门诊号   病人挂号记录.门诊号%Type;
  n_挂号金额 门诊费用记录.实收金额%Type;
  n_剩余金额 病人余额.预交余额%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_返回值   病人预交记录.金额%Type;

  d_Date     Date;
  n_当天排队 Number(18);
  n_排队     Number(18);
  v_结算方式 病人预交记录.结算方式%Type;
  v_三方名称 医疗卡类别.名称%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
  n_组id     财务缴款分组.Id%Type;
  v_排队序号 排队叫号队列.排队序号%Type;
  n_结算模式 病人信息.结算模式%Type;
  v_付款方式 病人挂号记录.医疗付款方式%Type;
Begin
  Begin
    Select a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0) As 余额, Sum(a.实收金额) As n_挂号金额, Substr(a.结论, 1, 10)
    Into n_病人id, n_门诊号, n_剩余金额, n_挂号金额, v_预约方式
    From 门诊费用记录 A, 病人余额 B
    Where a.病人id = b.病人id(+) And b.性质(+) = 1 And b.类型(+) = 1 And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0
    Group By a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0), a.结论;
  Exception
    When Others Then
      v_Error := '预约挂号信息不存在，可能该预约挂号已被接收。';
      Raise Err_Custom;
  End;
  If 接收时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 接收时间_In;
  End If;
  --当前操作人员
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  n_组id     := Zl_Get组id(v_人员姓名);
  n_结算模式 := 0;
  If Nvl(n_病人id, 0) <> 0 Then
    Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = n_病人id;
  End If;
  If n_结算模式 = 0 Then
    If Nvl(结帐id_In, 0) = 0 Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  End If;

  --病人信息的产生
  If n_门诊号 Is Null Then
    Select To_Number(Nextno(3)) Into n_门诊号 From Dual;
  End If;

  If n_病人id Is Null Then
    Select To_Number(Nextno(1)) Into n_病人id From Dual;
    Insert Into 病人信息
      (病人id, 门诊号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 登记时间)
      Select n_病人id, n_门诊号, a.姓名, a.性别, a.年龄, a.费别, b.名称, d_Date
      From 门诊费用记录 A, 医疗付款方式 B
      Where a.付款方式 = b.编码(+) And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0 And a.序号 = 1;
  End If;

  --更新病人信息，含就诊信息
  Update 病人信息 Set 就诊时间 = d_Date, 就诊状态 = 2, 就诊诊室 = 诊室_In Where 病人id = n_病人id;

  --更新门诊费用记录，含就诊信息
  Update 门诊费用记录
  Set 记录状态 = 1, 结帐id = Decode(n_结算模式, 1, Null, n_结帐id), 结帐金额 = Decode(n_结算模式, 1, Null, 实收金额), 发药窗口 = 诊室_In, 执行人 = v_人员姓名,
      执行状态 = 2, 执行时间 = d_Date, 病人id = Decode(病人id, Null, n_病人id, 病人id), 标识号 = Decode(标识号, Null, n_门诊号, 标识号),
      登记时间 = d_Date, 操作员编号 = v_人员编号, 操作员姓名 = v_人员姓名, 缴款组id = n_组id, 记帐费用 = Decode(n_结算模式, 1, 1, 0)
  Where NO = No_In And 记录性质 = 4 And 记录状态 = 0;

  Update 病人挂号记录
  Set 记录性质 = 1, 接收人 = v_人员姓名, 接收时间 = d_Date, 诊室 = 诊室_In, 执行人 = v_人员姓名, 执行时间 = d_Date, 执行状态 = 2,
      病人id = Decode(病人id, Null, n_病人id, 病人id), 门诊号 = Decode(门诊号, Null, n_门诊号, 门诊号)
  Where NO = No_In And 记录状态 = 1 And 记录性质 = 2;

  If Sql%NotFound Then
    --产生病人挂号记录，含就诊信息
    Begin
      Select a.名称
      Into v_付款方式
      From 医疗付款方式 A, 门诊费用记录 B
      Where b.No = No_In And b.记录性质 = 4 And b.记录状态 = 1 And b.序号 = 1 And a.编码 = b.付款方式 And Rownum < 2;
      Insert Into 病人挂号记录
        (ID, NO, 病人id, 记录性质, 记录状态, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 发生时间, 登记时间, 操作员编号, 操作员姓名,
         预约, 预约方式, 接收时间, 接收人, 预约时间, 医疗付款方式)
        Select 病人挂号记录_Id.Nextval, No_In, 病人id, 1, 1, 标识号, 姓名, 性别, 年龄, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, v_人员姓名, 2, d_Date,
               发生时间, 登记时间, 操作员编号, 操作员姓名, 1, Substr(结论, 1, 10) As 预约方式, d_Date, v_人员姓名, 发生时间, v_付款方式

        
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    Exception
      When Others Then
        v_Error := '该预约挂号已被接收。';
        Raise Err_Custom;
    End;
  End If;

  v_挂号生成队列 := Zl_To_Number(Zl_Getsysparameter('排队叫号模式', 1113));
  If v_挂号生成队列 <> 0 Then
    For c_挂号 In (Select ID, 执行部门id, 姓名, 诊室_In As 诊室, 登记时间, 执行人 As 执行人, 病人id, 号别, 号序
                 From 病人挂号记录
                 Where NO = No_In And Rownum = 1) Loop
      Begin
        Select 1,
               Case
                 When 排队时间 < Trunc(Sysdate) Then
                  1
                 Else
                  0
               End
        Into n_排队, n_当天排队
        From 排队叫号队列
        Where 业务类型 = 0 And 业务id = c_挂号.Id And Rownum <= 1;
      Exception
        When Others Then
          n_排队 := 0;
      End;
    
      If n_排队 = 0 Then
        --新增排队
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 0);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, v_排队号码, Null, c_挂号.姓名, c_挂号.病人id, c_挂号.诊室, c_挂号.执行人,
                         Sysdate, v_预约方式, Null, v_排队序号);
      Elsif Nvl(n_当天排队, 0) = 1 Then
        --更新队列号
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人, v_排队号码, v_排队序号);
      
      Else
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人);
      End If;
      --接收后,变成弃号
      Update 排队叫号队列 Set 排队状态 = 2 Where 业务类型 = 0 And 业务id = c_挂号.Id;
    End Loop;
  End If;

  --挂号费用结算
  If Nvl(n_挂号金额, 0) <> 0 Then
  
    If Nvl(n_剩余金额, 0) >= Nvl(n_挂号金额, 0) And Nvl(卡类别id_In, 0) = 0 And n_结算模式 = 0 Then
      --冲预交方式结算
      n_预交金额 := n_挂号金额;
      For r_Deposit In c_Deposit(n_病人id) Loop
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
                 v_人员姓名, v_人员编号, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, r_Deposit.金额, n_预交金额), n_结帐id, n_组id, 卡类别id,
                 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      If n_预交金额 = 0 Then
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_挂号金额
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      Else
        v_Error := '病人门诊预存帐户不足,请立即充值。';
        Raise Err_Custom;
      End If;
    Elsif Nvl(卡类别id_In, 0) > 0 And n_结算模式 = 0 Then
    
      Begin
        Select 结算方式, 名称 Into v_结算方式, v_三方名称 From 医疗卡类别 Where ID = 卡类别id_In;
      Exception
        When Others Then
          v_三方名称 := Null;
      End;
      If v_三方名称 Is Null Then
        v_Error := '未找到三方接口,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      If v_结算方式 Is Null Then
        v_Error := v_三方名称 || '未设置对应的结算方式,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      --第三方接口支付
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
         缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, Null, 4, 1, 病人id, 病人科室id, Null, v_结算方式, Null, '医生站挂号接收', Null, Null, Null, 登记时间,
               操作员姓名, 操作员编号, n_挂号金额, 结帐id, 缴款组id, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_三方名称, Null, 结帐id, 4
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + n_挂号金额
      Where 收款员 = v_人员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (v_人员姓名, v_结算方式, 1, n_挂号金额);
      End If;
    Else
      If n_结算模式 = 1 Then
        --记帐
        For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                     From 门诊费用记录
                     Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
          --病人余额
          Update 病人余额
          Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 性质, 类型, 费用余额, 预交余额)
            Values
              (n_病人id, 1, 1, Nvl(c_费用.实收金额, 0), 0);
          End If;
        
          --病人未结费用
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
                Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And
                收入项目id + 0 = c_费用.收入项目id And 来源途径 + 0 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
          End If;
        End Loop;
      
      Else
      
        --生成划价单收费(允许的情况下)
        v_Temp := Zl_Getsysparameter('允许挂号划价单', 1260);
        If Nvl(v_Temp, '0') <> '1' Then
          v_Error := '病人剩余款额' || To_Char(Nvl(n_剩余金额, 0), '0.00') || ' 不足挂号金额' || To_Char(Nvl(n_挂号金额, 0), '0.00') ||
                     '，不能完成预约接收。';
          Raise Err_Custom;
        End If;
      
        Select Nextno(13) Into v_划价no From Dual;
      
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数,
           数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要,
           结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 1, v_划价no, 0, a.序号, a.从属父号, a.价格父号, a.门诊标志, a.病人id, a.标识号, a.付款方式, a.姓名, a.性别, a.年龄,
                 a.病人科室id, a.费别, a.收费类别, a.收费细目id, b.计算单位, a.付数, a.数次, Null, Null, Null, a.收入项目id, a.收据费目, a.标准单价,
                 a.应收金额, a.实收金额, 0, v_人员姓名, a.执行部门id, v_人员姓名, d_Date, d_Date, a.执行部门id, 0, '挂号:' || No_In, a.结论, n_组id
          From 门诊费用记录 A, 收费项目目录 B
          Where a.收费细目id = b.Id And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 1;
      
        --挂号本身不收费
        Update 门诊费用记录
        Set 应收金额 = 0, 实收金额 = 0, 结帐金额 = 0
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  Open c_Regist;
  Fetch c_Regist
    Into r_Regist;
  Update 病人挂号汇总
  Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
  Where 日期 = Trunc(d_Date) And Nvl(科室id, 0) = Nvl(r_Regist.科室id, 0) And Nvl(项目id, 0) = Nvl(r_Regist.项目id, 0) And
        Nvl(医生姓名, '医生') = Nvl(r_Regist.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Regist.医生id, 0) And
        (号码 = r_Regist.号码 Or 号码 Is Null);
  If Sql%RowCount = 0 Then
    Insert Into 病人挂号汇总
      (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
    Values
      (Trunc(d_Date), r_Regist.科室id, r_Regist.项目id, r_Regist.医生姓名, r_Regist.医生id, r_Regist.号码, 1);
  End If;
  Close c_Regist;

  --病人担保信息
  If n_病人id Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = n_病人id And Exists (Select 1
           From 病人担保记录
           Where 病人id = n_病人id And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = n_病人id));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = n_病人id And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约挂号_接收;
/

--83869:刘尔旋,2015-04-08,医疗付款方式为空时挂号报错的问题
--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In         门诊费用记录.No%Type,
  票据号_In     门诊费用记录.实际票号%Type,
  领用id_In     票据使用明细.领用id%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  诊室_In       门诊费用记录.发药窗口%Type,
  病人id_In     门诊费用记录.病人id%Type,
  门诊号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  付款方式_In   门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In       门诊费用记录.费别%Type,
  结算方式_In   病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In   病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In   病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In   病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In   门诊费用记录.发生时间%Type,
  号序_In       挂号序号状态.序号%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  生成队列_In   Number := 0,
  登记时间_In   门诊费用记录.登记时间%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  结算卡序号_In 病人预交记录.结算卡序号%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  险类_In       病人挂号记录.险类%Type := Null,
  结算模式_In   Number := 0,
  记帐费用_In   Number := 0
  
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, 预交类别, NO)
    Order By ID, NO, 预交类别;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id   票据打印内容.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date     Date;
  d_预约时间 门诊费用记录.发生时间%Type;
  d_发生时间 Date;
  d_排队时间 Date;
  n_时段     Number := 0;
  n_存在     Number := 0;
  v_排队序号 排队叫号队列.排队序号%Type;
  n_结算模式 病人信息.结算模式%Type;
  n_票种     票据使用明细.票种%Type;
  v_付款方式 病人挂号记录.医疗付款方式%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      v_Err_Msg := '当前预约挂号单已被其它人接收';
      Raise Err_Item;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = 号序_In And Rownum <= 1
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = 号序_In And d.生效时间 > Sysdate And Rownum <= 1);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 Then
    d_发生时间 := Sysdate;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) Then
      
        If n_时段 = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), 现金支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--77769:冉俊明,2015-02-27,调整医疗小组确定规则。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_病人结算记录_Update
(
  结帐id_In       病人预交记录.结帐id%Type,
  保险结算_In     Varchar2, --"结算方式|结算金额||....."
  结帐_In         Number := 0,
  缺省结算方式_In Varchar2 := Null,
  缺省冲预交_In   Number := 0, --0-用现金缴款,1:剩于款项用冲预交支付(门诊预交),2-剩于款项用冲预交支付(住院预交)
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null
  
) As
  --该游标为要删除的由费用记录产生的结算记录

  Cursor c_Del Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And a.结帐id = 结帐id_In;

  --相关信息
  v_No         病人预交记录.No%Type;
  v_病人id     住院费用记录.病人id%Type;
  v_主页id     住院费用记录.主页id%Type;
  v_发生时间   住院费用记录.发生时间%Type;
  v_登记时间   住院费用记录.登记时间%Type;
  v_操作员编号 住院费用记录.操作员编号%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;

  --本次结算变量
  v_金额合计 病人预交记录.冲预交%Type;

  --保险结算
  v_保险结算 Varchar2(255);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_记录性质 病人预交记录.记录性质%Type;
  v_缺省     病人预交记录.结算方式%Type;

  --分币处理及误差变量
  v_Centmode   Number;
  v_现金金额   病人预交记录.冲预交%Type;
  v_Cashcented 病人预交记录.冲预交%Type;
  v_误差金额   病人预交记录.冲预交%Type;
  v_零钱       病人预交记录.冲预交%Type;
  v_费用id     住院费用记录.Id%Type;
  v_序号       住院费用记录.序号%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  v_收费细目id 住院费用记录.收费细目id%Type;
  v_收入项目id 住院费用记录.收入项目id%Type;
  v_收据费目   住院费用记录.收据费目%Type;
  v_Sign       Number;
  n_Noexists   Number(3);
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_结算序号   病人预交记录.结算序号%Type;
  n_费用状态   门诊费用记录.费用状态%Type;
  n_预交金额   病人预交记录.金额%Type;
  n_当前金额   病人预交记录.金额%Type;
  v_误差项     结算方式.名称%Type;

  --临时变量
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
Begin
  --如果缺省结算方式为空，则取现金结算方式
  If 缺省结算方式_In Is Null Then
    Begin
      Select 名称 Into v_缺省 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_缺省 := '现金';
    End;
  Else
    v_缺省 := 缺省结算方式_In;
  End If;

  --取得本次结算的相关信息
  If Nvl(结帐_In, 0) = 1 Then
    Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id, 0
    Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态
    From 病人结帐记录
    Where ID = 结帐id_In;
  Else
    Begin
      n_Noexists := 0;
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
      From 门诊费用记录
      Where 结帐id = 结帐id_In And Rownum < 2;
    Exception
      When Others Then
        n_Noexists := 1;
    End;
    If n_Noexists = 1 Then
      --费用记录不存在，从补充记录中找
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_费用状态
      From 费用补充记录
      Where 结算id = 结帐id_In And Rownum < 2;
    End If;
    If Nvl(n_费用状态, 0) = 1 Then
      --异常单据为空:
      v_缺省 := Null;
    End If;
  
    Begin
      --20051027 陈东
      Select 记录性质
      Into v_记录性质
      From 病人预交记录
      Where 结帐id = 结帐id_In And Rownum = 1 And Mod(记录性质, 10) <> 1;
    Exception
      When Others Then
        v_记录性质 := -1;
    End;
    If v_记录性质 = -1 Then
      Begin
        Select Decode(记录性质, 1, 3, 11, 3, 4, 4, 记录性质)
        Into v_记录性质
        From 门诊费用记录
        Where 结帐id = 结帐id_In And Rownum = 1;
      Exception
        When Others Then
          --可能是卡费
          Select 记录性质 Into v_记录性质 From 住院费用记录 Where 结帐id = 结帐id_In And Rownum = 1;
      End;
    End If;
  End If;

  If Nvl(v_病人id, 0) <> 0 And Nvl(结帐_In, 0) = 1 Then
    Select 主页id Into v_主页id From 病人信息 Where 病人id = v_病人id;
  End If;
  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  ----回退缴款,预交不动,因为没有改冲预交的
  --收费未最未最终完成的,代表按异常单据修正,不处理人员缴款余额
  v_金额合计 := 0;
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
        End If;
      End If;
      v_金额合计 := v_金额合计 + r_Del.冲预交;
      Delete From 病人预交记录 Where ID = r_Del.Id;
    Else
      --检查是否冲预交
      If Nvl(缺省冲预交_In, 0) <> 0 Then
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
          Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
          If Sql%NotFound Then
            Insert Into 病人余额
              (病人id, 性质, 预交余额, 费用余额, 类型)
            Values
              (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
          End If;
        End If;
        If r_Del.记录性质 = 1 Then
          Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
        Else
          Delete 病人预交记录 Where ID = r_Del.Id;
        End If;
      End If;
    End If;
  End Loop;

  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  --产生医保支付结算
  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_保险结算 := 保险结算_In || '||';
    While v_保险结算 Is Not Null Loop
      v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险部份', v_结算方式, v_登记时间, v_操作员编号,
         v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    
      v_金额合计 := v_金额合计 - v_结算金额;
    
      v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
    End Loop;
  End If;
  --剩余部分用预交
  If Nvl(缺省冲预交_In, 0) <> 0 And v_金额合计 <> 0 Then
  
    n_预交金额 := v_金额合计;
    For c_预交 In (Select *
                 From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
                        From 病人预交记录 A,
                             (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                               From 病人预交记录 A
                               Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 缺省冲预交_In
                               Group By NO
                               Having Sum(Nvl(a.金额, 0)) <> 0) B
                        Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                              a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And a.病人id = v_病人id And
                              Nvl(a.预交类别, 2) = 缺省冲预交_In
                        Union All
                        Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                        From 病人预交记录
                        Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                              Nvl(预交类别, 2) = 缺省冲预交_In Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                        Group By 记录状态, NO, 预交类别)
                 Order By ID, NO) Loop
    
      n_当前金额 := Case
                  When c_预交.金额 - n_预交金额 < 0 Then
                   c_预交.金额
                  Else
                   n_预交金额
                End;
    
      If c_预交.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = n_结算序号, 结算性质 = Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        Where ID = c_预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_登记时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号,
               Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        From 病人预交记录
        Where NO = c_预交.No And 记录状态 = c_预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = v_病人id And 性质 = 1 And 类型 = Nvl(c_预交.预交类别, 2);
      --检查是否已经处理完
      If c_预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_预交.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '[ZLSOFT]预交余不够支付本次支付金额,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    v_金额合计 := n_预交金额;
  End If;

  --剩余部份全部用缺省结算方式结算，(小于零也不进行额外处理)
  If v_金额合计 <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + v_金额合计, 卡类别id = 卡类别id_In, 结算卡序号 = 结算卡序号_In, 卡号 = 卡号_In, 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In,
        合作单位 = 合作单位_In, 结算序号 = n_结算序号
    
    Where 结帐id = 结帐id_In And Nvl(结算方式, 'LXH_Test') = Nvl(v_缺省, 'LXH_Test') And 记录性质 = Decode(结帐_In, 1, 2, v_记录性质);
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 合作单位, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险结算修正', v_缺省, v_登记时间, v_操作员编号,
         v_操作员姓名, v_金额合计, 结帐id_In, n_组id, n_结算序号, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In,
         Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    End If;
  
    --挂号结算,分币处理(由于挂号界面没有预结算,所以在此过程中根据分币处理规则来修正)
    If v_记录性质 = 4 Then
    
      Begin
        Select a.冲预交
        Into v_现金金额
        From 病人预交记录 A, 结算方式 B
        Where a.结算方式 = b.名称 And b.性质 = 1 And a.结帐id = 结帐id_In;
      Exception
        When Others Then
          v_现金金额 := 0;
      End;
      If Floor(Abs(v_现金金额) * 10) <> Abs(v_现金金额) * 10 Then
        v_Centmode := Substr(Nvl(Zl_Getsysparameter(14), 0), 1, 1);
      
        v_Sign     := Sign(v_现金金额);
        v_现金金额 := Abs(v_现金金额);
        If v_Centmode = 1 Then
          v_Cashcented := Round(v_现金金额, 1); --1.四舍五入法,eg:0.51=0.50;0.56=0.60
        Elsif v_Centmode = 2 Then
          v_Cashcented := Ceil(v_现金金额 * 10) / 10; --2.补整收法,eg:0.51=0.60,0.56=0.60
        Elsif v_Centmode = 3 Then
          v_Cashcented := Floor(v_现金金额 * 10) / 10; --3.舍分收法,eg:0.51=0.50,0.56=0.50
          --4.四舍六入五成双,由于Oracle没有相关函数,算法复杂,暂不支持
        Elsif v_Centmode = 5 Then
          v_零钱 := v_现金金额 - Floor(v_现金金额);
          If v_零钱 >= 0.8 Then
            v_零钱 := 1;
          Elsif v_零钱 < 0.3 Then
            v_零钱 := 0;
          Else
            v_零钱 := 0.5;
          End If;
          v_Cashcented := Floor(v_现金金额) + v_零钱; --5.三七作五、二舍八入,eg:0.29=0,0.30=0.50,0.79=0.50,0.80=1.00
        Elsif v_Centmode = 6 Then
          --6:五舍六入
          v_Cashcented := Round(v_现金金额 - 0.01, 1); --6.五舍六入,eg:0.55=0.50,0.56=0.60
        Else
          v_Cashcented := v_现金金额;
        End If;
        v_Cashcented := v_Sign * v_Cashcented;
        v_现金金额   := v_Sign * v_现金金额;
      
        v_误差金额 := v_Cashcented - v_现金金额;
        If v_误差金额 <> 0 Then
          If n_结算序号 < 0 Then
            --10.34之后误差数据
            Begin
              Select 名称 Into v_误差项 From 结算方式 Where 性质 = 9;
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取误差项的信息，请先检查结算方式中误差费是否设置正确。';
                Raise Err_Item;
            End;
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '误差费', v_误差项, v_登记时间, v_操作员编号,
               v_操作员姓名, v_误差金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
          Else
            --1.更新预交记录(一定存在记录)
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结算方式 = (Select 名称 From 结算方式 Where 性质 = 1 And Rownum = 1) And 结帐id = 结帐id_In;
          
            --2.生成误差费用记录(注:计算单位记录的是号别,所以不取误差项的)
            Begin
              Select a.类别, a.Id, c.Id, c.收据费目
              Into v_收费类别, v_收费细目id, v_收入项目id, v_收据费目
              From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
              Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
                    Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
                Raise Err_Item;
            End;
            If Nvl(结帐_In, 0) = 1 Then
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1, Max(发生时间) Into v_序号, v_发生时间 From 住院费用记录 Where 结帐id = 结帐id_In;
              n_医疗小组id := Zl_医疗小组_Get(0, v_操作员姓名, v_病人id, v_主页id, v_发生时间);
            
              Insert Into 住院费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别, 收费类别,
                 收费细目id, 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
                 登记时间, 执行部门id, 执行人, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id, 医疗小组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id,
                       费别, v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用,
                       划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id,
                       Decode(n_医疗小组id, Null, 医疗小组id, n_医疗小组id)
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            Else
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In;
              Insert Into 门诊费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id,
                 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
                 执行部门id, 执行人, 执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别,
                       v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用, 划价人,
                       开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 费用状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            End If;
          End If;
          --3.更新汇总表
          --只可能产生误差金额的变化.仅为了变量处理方便而用游标
        End If;
      End If;
    End If;
  End If;

  --最后再处理"人员缴款余额"(没有动冲预交那部分,所以"病人余额"的预交余额不用更新)
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, r_Del.冲预交);
        End If;
      End If;
    End If;
  End Loop;
  Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结算记录_Update;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊收费结算_Update
(
  结帐id_In   门诊费用记录.结帐id%Type,
  收费结算_In Varchar2,
  冲预交额_In 病人预交记录.冲预交%Type,
  保险结算_In Varchar2,
  误差_In     门诊费用记录.实收金额%Type,
  缴款_In     病人预交记录.缴款%Type := Null,
  找补_In     病人预交记录.找补%Type := Null
) As
  --功能:处理收费时和医保正式结算后,相关结算信息的调整
  --     因为预结算后,生成的医保结算金额总额及分摊可能会与正式结算时有差异,所以提供了校对功能,
  --   操作员在结算校对时,可以调整非医保结算方式的各种结算金额及方式,重新生成结算串,并且可能产生误差金额.

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And 预交类别 = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = v_病人id And a.预交类别 = 1
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And 预交类别 = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;

  v_费用id 门诊费用记录.Id%Type;
  v_序号   门诊费用记录.序号%Type;

  v_收费类别   门诊费用记录.收费类别%Type;
  v_收费细目id 门诊费用记录.收费细目id%Type;
  v_计算单位   门诊费用记录.计算单位%Type;
  v_收入项目id 门诊费用记录.收入项目id%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  v_执行部门id 门诊费用记录.执行部门id%Type;
  v_Temp       Varchar2(500);
  n_返回值     人员缴款余额.余额%Type;
  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;

  v_预交金额 病人预交记录.冲预交%Type;
  n_组id     财务缴款分组.Id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
  n_费用状态 门诊费用记录.费用状态%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin

  --1.取预交记录需要的相关信息
  Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
  From 门诊费用记录
  Where 结帐id = 结帐id_In And Rownum = 1 And 记录性质 = 1;
  --误差相关信息
  Begin
    Select a.类别, a.Id, a.计算单位, c.Id, c.收据费目
    Into v_收费类别, v_收费细目id, v_计算单位, v_收入项目id, v_收据费目
    From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
          Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
        Raise Err_Custom;
      End;
  End;

  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  If Nvl(n_费用状态, 0) <> 1 Then
    --2.删除旧的记录,回退汇总数据
    --回退人员缴款余额,病人余额,
    --人员缴款余额中不包含未较对的,未较对的直接删除
    For c_Del In (Select 冲预交, 操作员姓名, 结算方式
                  From 病人预交记录
                  Where 结帐id = 结帐id_In And 记录性质 = 3 And Nvl(校对标志, 0) = 0) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - Nvl(c_Del.冲预交, 0)
      Where 结算方式 = c_Del.结算方式 And 收款员 = v_操作员姓名 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, c_Del.结算方式, 1, -1 * c_Del.冲预交);
        n_返回值 := -1 * c_Del.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 性质 = 1 And 收款员 = v_操作员姓名 And 结算方式 = c_Del.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If v_病人id > 0 Then
    For v_预交 In (Select 预交类别, Nvl(Sum(冲预交), 0) As 预交金额
                 From 病人预交记录
                 Where 结帐id = 结帐id_In And 记录性质 In (1, 11)
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = v_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2);
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, Nvl(v_预交.预交类别, 2), v_预交金额, 1);
      End If;
    
    End Loop;
  End If;

  --回退汇总表
  --只可能产生误差金额的变化,其它的不会变,并且只可能存在一行,仅为了变量处理方便而用游标

  --删除收费结算,保险结算记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 3;
  --第一次冲预交的,清空冲减额
  Update 病人预交记录 Set 冲预交 = Null, 结帐id = Null, 结算性质 = Null Where 结帐id = 结帐id_In And 记录性质 = 1;
  --删除冲余款
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 11;
  --删除误差记录
  Delete 门诊费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;

  --3.产生门诊费用记录的误差记录
  If 误差_In <> 0 Then
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
    Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In And 记录性质 = 1;
    v_Temp       := Zl_Identity;
    v_执行部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  
    Insert Into 门诊费用记录
      (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
       发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 费用状态,
       结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
      Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, v_收费类别,
             v_收费细目id, v_计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, 误差_In, 误差_In, 误差_In, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
             登记时间, v_执行部门id, 执行状态, 费用状态, 结帐id, 误差_In, 操作员编号, 操作员姓名, 1, 缴款组id
      From 门诊费用记录
      Where 记录性质 = 1 And 结帐id = 结帐id_In And Rownum = 1;
  End If;

  --4.重新生成病人预交记录相关数据
  --4.1.收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, v_病人id, Null, '收费结算', v_结算方式, v_结算号码, v_收款时间, v_操作员编号, v_操作员姓名, v_结算金额,
           结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null), Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.2.保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, v_病人id, Null, '保险结算', v_结算方式, v_收款时间, v_操作员编号, v_操作员姓名, v_结算金额, 结帐id_In,
           n_组id, n_结算序号, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.3.预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(v_病人id, 0) = 0 Then
      v_Error := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Custom;
    End If;
  
    v_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(v_病人id) Loop
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_收款时间,
               v_操作员姓名, v_操作员编号, Decode(Sign(r_Deposit.金额 - v_预交金额), -1, r_Deposit.金额, v_预交金额), 结帐id_In, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --检查是否已经处理完
      If r_Deposit.金额 < v_预交金额 Then
        v_预交金额 := v_预交金额 - r_Deposit.金额;
      Else
        v_预交金额 := 0;
      End If;
      If v_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If v_预交金额 > 0 Then
      v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Custom;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交额_In
    Where 病人id = v_病人id And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 1, -1 * 冲预交额_In, 1);
      n_返回值 := -1 * 冲预交额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;

  --5.相关汇总表的处理
  --汇总人员缴款余额
  --收费结算
  If 收费结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算

  If 保险结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --汇总表,只需重汇误差行,因为其它项不会变
  --6.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Update;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_划价收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  三方卡结算_In Varchar2 := Null,
  登记时间_In   门诊费用记录.登记时间%Type := Null,
  结算序号_In   病人预交记录.结算序号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  简单收费_In   Number := 0
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n
  --        病人来源_IN:1-门诊;2-住院
  --        收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --        保险结算_IN:格式="结算方式|结算金额||....."
  --        三方卡结算_In:格式=卡类别Id|是否消费卡|结算金额|卡号|备注||...
  --        交易流水号_In和交易说明_In:收费结算_IN时有效.
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容

  --=================================
  --备注：该过程目前只有简单收费使用！
  --=================================

  Cursor c_Price Is
    Select ID, 医嘱序号
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  t_医嘱id     t_Numlist;
  l_医嘱id     t_Numlist;
  v_部门名称   部门表.名称%Type;
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, Nvl(a.预交类别, 2) As 预交类别, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, Nvl(预交类别, 2) As 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(预交类别, 2) = 1 And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id = v_病人id Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, Nvl(预交类别, 2))
    Order By ID, 预交类别 Desc, NO;

  --预交与结算相关变量
  v_预交金额 病人预交记录.冲预交%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  v_标识号   门诊费用记录.标识号%Type;
  v_付款方式 医疗付款方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;

  --临时变量
  n_Count      Number;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_组id     财务缴款分组.Id%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  n_消费卡   Number;
  v_卡号     病人预交记录.卡号%Type;
  v_卡名称   Varchar2(100);
  n_自制卡   Number;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_金额     病人预交记录.金额%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    v_Err_Msg := '不能读取划价单内容,该单据可能已经删除或已经收费！';
    Raise Err_Item;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id, t_医嘱id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = v_标识号, 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
          性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      v_Err_Msg := '由于并发操作,该单据可能已经删除或已经收费！';
      Raise Err_Item;
    End If;
  
    --更新医属的计价数据
    Select Column_Value Bulk Collect Into l_医嘱id From Table(t_医嘱id) Where Column_Value Is Not Null;
    If l_医嘱id.Count <> 0 Then
      Forall I In 1 .. l_医嘱id.Count
        Update 病人医嘱发送 A
        Set 计费状态 = 3
        Where NO = No_In And 医嘱id = l_医嘱id(I) And 记录性质 = 1 And 计费状态 = 1;
    End If;
  
  End Loop;
  Close c_Price;
  ------------------------------------------------------------------------------------------------------------------------

  --预交款相关结算
  --收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 交易流水号,
           交易说明, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, v_Date,
           操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 结算序号_In, 交易流水号_In, 交易说明_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, v_Date, 操作员编号_In,
           操作员姓名_In, n_结算金额, 结帐id_In, n_组id, 结算序号_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := v_当前结算;
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 卡类别id, 结算卡序号, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id,
           结算序号, 卡号, 结算性质)
        Values
          (n_预交id, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, Decode(n_消费卡, 1, Null, n_卡类别id),
           Decode(n_消费卡, 0, Null, n_卡类别id), v_结算方式, v_结算号码, v_Date, 操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Null, Null,
           n_组id, 结算序号_In, v_卡号, 3);
      
        --卡结算对照
        If n_消费卡 = 1 Then
          n_消费卡id := Null;
          If n_自制卡 = 1 Then
            Select ID
            Into n_消费卡id
            From 消费卡目录
            Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                  序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
          End If;
          Zl_病人卡结算记录_Insert(n_卡类别id, n_消费卡id, v_结算方式, n_结算金额, v_卡号, Null, Null, v_结算摘要, 结帐id_In, n_预交id);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人病人ID,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
  
    v_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(病人id_In) Loop
    
      n_金额 := Case
                When r_Deposit.金额 - v_预交金额 < 0 Then
                 r_Deposit.金额
                Else
                 v_预交金额
              End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 校对标志, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_Date,
               操作员姓名_In, 操作员编号_In, n_金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号_In, 校对标志, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 类型, 性质) Values (病人id_In, -n_金额, Nvl(r_Deposit.预交类别, 2), 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < v_预交金额 Then
        v_预交金额 := v_预交金额 - r_Deposit.金额;
      Else
        v_预交金额 := 0;
      End If;
      If v_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If v_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
  End If;

  --相关汇总表的处理

  --汇总"人员缴款余额"
  --收费结算
  n_返回值 := 0;
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') + 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
  End If;

  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And b.No = No_In And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    If Nvl(简单收费_In, 0) <> 0 Then
      Update 门诊费用记录
      Set 发药窗口 = 发药窗口_In
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 收费类别 = 'Z';
    Else
      For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
        Update 门诊费用记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
      
        Update 药品收发记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              费用id + 0 In (Select ID
                           From 门诊费用记录
                           Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      
        Update 未发药品记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                               From 门诊费用记录
                               Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      End Loop;
    End If;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄), 姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(Zl_Getsysparameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_划价收费记录_Insert;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  保险大类id_In 门诊费用记录.保险大类id%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  原no_In       门诊费用记录.No%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  摘要_In       门诊费用记录.摘要%Type := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null
) As
  --功能：新收一张门诊收费单据
  --参数：
  --  病人来源_IN:1-门诊;2-住院  住院病人收费时用。
  --  原NO_IN:修改保存新单据时用。目前用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  -- 收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  -- 保险结算_IN:格式="结算方式|结算金额||....."

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  --不包含结算方式为代收款项的预交款。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And 预交类别 = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.预交类别 = 1 And
                 a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And a.病人id = v_病人id
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And 预交类别 = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  v_费用id   门诊费用记录.Id%Type;
  v_优先级   未发药品记录.优先级%Type;
  v_预交金额 病人预交记录.冲预交%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock(n_Outmode Number) Is
    Select *
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = 执行部门id_In And 性质 = 1 And (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And
          Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  v_分批 药品规格.药房分批%Type;
  v_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  v_总数量   Number;
  v_当前数量 Number;
  v_总金额   Number;
  v_当前单价 Number;
  --药品收发记录
  v_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_序号       药品收发记录.序号%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_灭菌日期   药品收发记录.灭菌日期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;

  v_煎法 药品收发记录.外观%Type;
  ------------------------------------------------------------
  --结算方式串
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_返回值   病人余额.费用余额%Type;

  v_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;

  --临时变量
  n_Outmode Number(1);
  v_Count   Number;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_单价小数 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
     保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
     执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 结论, 缴款组id)
  Values
    (v_费用id, 1, No_In, 1, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In),
     Decode(病人来源_In, 1, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 付款方式_In, 姓名_In, 性别_In,
     年龄_In, 病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 保险项目否_In, 保险大类id_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In,
     收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 0, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In,
     0, 结帐id_In, 实收金额_In, 操作员编号_In, 操作员姓名_In, 摘要_In, 是否急诊_In, 中药形态_In, n_组id);

  If 序号_In = 1 Then
    --病人预交记录(第一行时处理)
    --正常结算
    If 收费结算_In Is Not Null Then
      --各个收费结算
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
      
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
        v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, 登记时间_In,
             操作员编号_In, 操作员姓名_In, v_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
             Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, 登记时间_In, 操作员编号_In,
             操作员姓名_In, v_结算金额, 结帐id_In, n_组id, 3);
        End If;
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --预交结算
    If Nvl(冲预交额_In, 0) <> 0 Then
      If Nvl(病人id_In, 0) = 0 Then
        v_Error := '不能确定病人病人ID,收费使用预交款结算失败！';
        Raise Err_Custom;
      End If;
    
      v_预交金额 := 冲预交额_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - v_预交金额), -1, r_Deposit.金额, v_预交金额), 结帐id_In,
                 n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        --检查是否已经处理完
        If r_Deposit.金额 < v_预交金额 Then
          v_预交金额 := v_预交金额 - r_Deposit.金额;
        Else
          v_预交金额 := 0;
        End If;
        If v_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      --检查金额是否足够
      If v_预交金额 > 0 Then
        v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
        Raise Err_Custom;
      End If;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交额_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -冲预交额_In, 1, 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  --相关汇总表的处理
  --汇总"人员缴款余额"(注意要处理个人帐户的结算)
  n_返回值 := 0;
  If 序号_In = 1 Then
    --各个收费结算
    If 收费结算_In Is Not Null Then
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(Zl_Getsysparameter(150), 0)) Into n_Outmode From Dual;
  
    v_总数量 := 付数_In * 数次_In;
    v_总金额 := 0;
    Open c_Stock(n_Outmode);
  
    While v_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If v_分批 = 1 Or v_时价 = 1 Then
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
          Else
            v_Error := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
          End If;
          Raise Err_Custom;
        End If;
      Elsif (v_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (v_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
        Else
          v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
        End If;
        Raise Err_Custom;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (v_总数量 > 0 Or v_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
          Else
            v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
          End If;
          Raise Err_Custom;
        End If;
      End If;
    
      --确定本次分解数量
      If v_分批 = 1 Or v_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If v_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          v_当前数量 := v_总数量;
        Else
          v_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If v_时价 = 1 Then
          v_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif v_分批 = 1 Then
          v_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        v_当前数量 := v_总数量;
        v_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * v_当前数量);
        End If;
      End If;
    
      --药品收发记录
      v_批次       := Null;
      v_批号       := Null;
      v_效期       := Null;
      v_产地       := Null;
      v_灭菌效期   := Null;
      v_灭菌日期   := Null;
      v_供药单位id := Null;
      v_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        v_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        v_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        v_供药单位id := r_Stock.上次供应商id;
        v_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            v_灭菌效期 := r_Stock.灭菌效期;
            v_灭菌日期 := v_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into v_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If v_分批 = 1 And v_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      --注意卫材单据与药品单据不同
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 灭菌效期, 灭菌日期, 外观, 供药单位id, 生产日期, 批准文号)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, v_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         v_批次, v_产地, v_批号, v_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In),
         Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In), v_当前单价, Round(v_当前单价 * v_当前数量, v_Dec), 原no_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, v_灭菌效期, v_灭菌日期, v_煎法, v_供药单位id, v_生产日期, v_批准文号);
    
      v_总数量 := v_总数量 - v_当前数量;
      v_总金额 := v_总金额 + Round(v_当前数量 * v_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录:可能同一个库房,但一个为药品,一个为卫材,插入两条记录。
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 发药窗口 = Nvl(发药窗口_In, 发药窗口) --可能药品和材料用同一个库房,但材料无发药窗口
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), Null, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 1, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If v_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If v_当前数量 <> 付数_In * 数次_In Then
        v_当前单价 := Round(v_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If v_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        Else
          v_Error := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And Nvl(病人来源_In, 1) = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(Zl_Getsysparameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Insert;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_病人预交记录_冲预交
(
  病人id_In   门诊费用记录.病人id%Type,
  预交支付_In 病人预交记录.冲预交%Type,
  结帐id_In   门诊费用记录.结帐id%Type
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;

  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_组id       财务缴款分组.Id%Type;
Begin
  Begin
    Select 登记时间, 操作员编号, 操作员姓名, 缴款组id
    Into v_收款时间, v_操作员编号, v_操作员姓名, n_组id
    From 门诊费用记录
    Where 结帐id = 结帐id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '对应费用记录不存在,不能继续操作！';
      Raise Err_Item;
  End;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
    
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_收款时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 > 0 Then
      v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
      Raise Err_Item;
    
    End If;
    Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_冲预交;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_结帐预交记录_Insert
(
  Id_In       病人预交记录.Id%Type,
  No_In       病人预交记录.No%Type,
  记录状态_In 病人预交记录.记录状态%Type,
  冲预交_In   病人预交记录.冲预交%Type,
  结帐id_In   病人结帐记录.Id%Type,
  病人id_In   病人预交记录.病人id%Type
) As
  -----------------------------------------------------------
  --功能：处理一行病人结帐时的冲预交记录
  --说明：ID_IN=空：表示冲历史余额预交记录
  -----------------------------------------------------------
  n_返回值 病人余额.预交余额%Type;
  n_类别   病人预交记录.预交类别%Type;

  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_组id       财务缴款分组.Id%Type;
Begin
  Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id
  From 病人结帐记录
  Where ID = 结帐id_In;

  If Id_In <> 0 Then
    --第一次冲预交
    Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2 Where ID = Id_In;
  End If;
  --冲上次剩余额
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
     缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
    Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_收款时间,
           v_操作员姓名, v_操作员编号, 冲预交_In, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
    From 病人预交记录
    Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And 记录状态 = 记录状态_In And Rownum = 1;
  Begin
    Select 预交类别
    Into n_类别
    From 病人预交记录
    Where NO = No_In And 记录性质 In (1, 11) And 记录状态 = 记录状态_In And Rownum = 1;
  Exception
    When Others Then
      n_类别 := 2;
  End;

  --病人余额
  Update 病人余额
  Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = n_类别
  Returning 预交余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额
      (病人id, 性质, 类型, 预交余额, 费用余额)
    Values
      (病人id_In, 1, Nvl(n_类别, 2), -1 * 冲预交_In, 0);
    n_返回值 := -1 * 冲预交_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐预交记录_Insert;
/

--82934:冉俊明,2015-03-05,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_住院收费结算_Update
(
  结帐id_In   住院费用记录.结帐id%Type,
  结帐结算_In Varchar2, --结帐结算_IN-非医保时:结算方式|结算金额|结算号码||.....医保时:结算方式|结算金额|保险类别,保险密码,保险帐号||.....
  冲预交_In   Varchar2, --冲预交_IN= ID|单据号|金额|记录状态||.....
  缴款_In     病人预交记录.缴款%Type := Null,
  找补_In     病人预交记录.找补%Type := Null
) As
  --功能:处理结帐时和医保正式结算后,相关结算信息的调整
  --     因为虚拟结帐后,生成的医保结算金额总额及分摊可能会与正式结算时有差异,所以提供了校对功能,
  --   操作员在结算校对时,可以调整非医保结算方式的各种结算金额及方式,重新生成结算串,并且可能产生误差金额.

  --病人信息
  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = v_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(100);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 Varchar2(100); --保险结算记录时,存入:保险类别,保险密码,保险帐号

  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  v_误差结算   病人预交记录.结算方式%Type;

  v_预交id   病人预交记录.Id%Type;
  v_记录状态 病人预交记录.记录状态%Type;

  v_保险类别 病人预交记录.缴款单位%Type;
  v_保险帐号 病人预交记录.单位开户行%Type;
  v_保险密码 病人预交记录.单位帐号%Type;
  v_付款方式 门诊费用记录.付款方式%Type;
  n_返回值   病人余额.预交余额%Type;
  n_Dele     Number; --0-不删除,1-删除
  v_Error    Varchar2(255);
  Err_Custom Exception;
  n_门诊标志   Number; --1.门诊,2-住院,3-门诊和住院
  n_组id       财务缴款分组.Id%Type;
  n_类别       Number;
  n_门诊冲预交 病人预交记录.冲预交%Type;
  n_住院冲预交 病人预交记录.冲预交%Type;

Begin

  --1.取预交记录中的需要的相关信息
  Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id
  From 病人结帐记录
  Where ID = 结帐id_In;

  Open c_Pati(v_病人id);
  Fetch c_Pati
    Into r_Pati;

  --误差相关信息
  Begin
    Select 名称 Into v_误差结算 From 结算方式 Where 性质 = 9;
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
        Raise Err_Custom;
      End;
  End;

  --2.删除旧的记录,回退汇总数据
  --回退人员缴款余额,病人余额,
  For c_Del In (Select 结算方式, 操作员姓名, 冲预交 From 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) - Nvl(c_Del.冲预交, 0)
    Where 结算方式 = c_Del.结算方式 And 收款员 = v_操作员姓名 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (v_操作员姓名, c_Del.结算方式, 1, -1 * c_Del.冲预交);
    End If;
  End Loop;

  If v_病人id > 0 Then
    For v_预交 In (Select 预交类别, Sum(Nvl(冲预交, 0)) As 预交金额
                 From 病人预交记录
                 Where 结帐id = 结帐id_In And 记录性质 In (1, 11)
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = v_病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (v_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
      End If;
    End Loop;
  End If;

  --取门诊标志
  Select Case
           When 门诊标志 = 1 And 住院标志 = 1 Then
            3
           When 门诊标志 = 1 Then
            1
           Else
            2
         End, 付款方式
  Into n_门诊标志, v_付款方式
  From (Select Nvl(Max(门诊标志), 0) As 门诊标志, Nvl(Max(住院标志), 0) As 住院标志, Max(付款方式) As 付款方式
         From (Select 1 As 门诊标志, 0 As 住院标志, 付款方式
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1
                Union All
                Select 0 As 门诊标志, 1 As 住院标志, '' As 付款方式
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1));

  --回退汇总表.         病人未结费用(因为新误差将立即结帐,所以不处理)
  --只可能产生误差金额的变化. 旧误差只可能存在一行,仅为了变量处理方便而用游标

  --删除结帐缴款,保险结算记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2;
  --第一次冲预交的,清空冲减额
  Update 病人预交记录 Set 冲预交 = Null, 结帐id = Null, 结算性质 = Null Where 结帐id = 结帐id_In And 记录性质 = 1;
  --删除冲余款
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 11;

  --删除误差记录
  If n_门诊标志 = 1 Then
    Delete 门诊费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;
  Else
    Delete 住院费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;
  End If;

  --4.重新生成病人预交记录相关数据
  --4.1.补款结算,保险结算
  If 结帐结算_In Is Not Null Then
    v_结算内容 := 结帐结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      If Instr(v_结算号码, ',') > 0 Then
        --医保结算:保险类别,保险密码,保险帐号
        v_结算号码 := v_结算号码 || ',';
        v_保险类别 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Substr(v_结算号码, Instr(v_结算号码, ',') + 1);
        v_保险密码 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Substr(v_结算号码, Instr(v_结算号码, ',') + 1);
        v_保险帐号 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Null;
      Else
        v_保险类别 := Null;
        v_保险密码 := Null;
        v_保险帐号 := Null;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员编号, 操作员姓名, 冲预交,
           结帐id, 缴款, 找补, 缴款组id, 结算性质)
        Values
          (病人预交记录_Id.Nextval, v_No, Null, 2, 1, v_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐缴款',
           v_保险类别, v_保险密码, v_保险帐号, v_收款时间, v_操作员编号, v_操作员姓名, n_结算金额, 结帐id_In,
           Decode(v_结算内容, 结帐结算_In || '||', 缴款_In, Null), Decode(v_结算内容, 结帐结算_In || '||', 找补_In, Null), n_组id, 2);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.2.预交结算
  If 冲预交_In Is Not Null Then
    v_结算内容   := 冲预交_In || '||';
    n_门诊冲预交 := 0;
    n_住院冲预交 := 0;
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_预交id   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1)); --是记录冲预交的ID
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1); --是记录冲预交的NO号
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_记录状态 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If v_预交id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2 Where ID = v_预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, v_记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_收款时间, v_操作员姓名, v_操作员编号, n_结算金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = v_结算号码 And 记录性质 In (1, 11) And 记录状态 = v_记录状态 And Rownum = 1;
    
      Begin
        Select Nvl(预交类别, 2)
        Into n_类别
        From 病人预交记录
        Where NO = v_结算号码 And 记录性质 In (1, 11) And 记录状态 = v_记录状态 And Rownum = 1;
      Exception
        When Others Then
          n_类别 := 2;
      End;
      If Nvl(n_类别, 0) = 1 Then
        n_门诊冲预交 := n_门诊冲预交 + Nvl(n_结算金额, 0);
      Else
        n_住院冲预交 := n_住院冲预交 + Nvl(n_结算金额, 0);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
    --更新病人余额
    If n_门诊冲预交 <> 0 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_门诊冲预交
      Where 病人id = v_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 1, -1 * n_门诊冲预交, 1);
        n_返回值 := -1 * n_门诊冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    If n_住院冲预交 <> 0 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_住院冲预交
      Where 病人id = v_病人id And 性质 = 1 And 类型 = 2
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 2, -1 * n_住院冲预交, 1);
        n_返回值 := -1 * n_住院冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  
  End If;

  --5.相关汇总表的处理
  --汇总人员缴款余额
  --缴款结算,保险结算
  n_Dele := 0;
  If 结帐结算_In Is Not Null Then
    v_结算内容 := 结帐结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_结算金额, 0);
        End If;
      
        If Nvl(n_返回值, 0) = 0 Then
          n_Dele := 1;
        End If;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;
  If n_Dele = 1 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
  End If;
  --汇总表,只需重汇误差行,因为其它项不会变,未结费用不变(新产生的误差项已结帐),只有一行误差记录,仅为使用变量方便而用游标

  --6.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

  Close c_Pati;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院收费结算_Update;
/

--82934:冉俊明,2015-03-26,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-03-09,收费财务监控模块性能问题调整预交款数据处理规则
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10)
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                2
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --如果存在医保,肯定先退,所以校对标志应该2,减少重复更新
                2
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id := 冲销id_In;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id := n_重结id;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In,
         交易说明_In, Null, 3);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号,
                   交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                                 预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 2, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--83072:刘尔旋,2015-03-11,自定义获取病人标识
--82870:刘尔旋,2015-03-09,获取病人标识时生成门诊号
--82380:刘尔旋,2015-02-05,新病人绑定传入到三方用户资料
Create Or Replace Procedure Zl_Third_Getpati_Unique
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人的唯一标识(病人ID) 
  --入参:Xml_In: 
  --   <IN> 
  --     <SFZ>身份证号</SFZ> 
  --     <XM>姓名</XM> 
  --     <KH>卡号</KH> 
  --     <KLB>卡类别</KLB> 
  --    </IN> 
  --出参:Xml_Out 
  -- <OUTPUT> 
  --   <BRID>病人ID</BRID> 
  --   <MZH>门诊号</MZH>
  --   <ERROR><MSG>错误信息</MSG></ERROR> 
  --  </OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_身份证 Varchar2(50);
  v_姓名   Varchar2(100);
  v_卡号   Varchar2(100);
  v_卡类别 Varchar2(100);

  n_病人id 病人信息.病人id%Type;
  n_门诊号 病人信息.门诊号%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/SFZ'), Extractvalue(Value(A), 'IN/XM'), Extractvalue(Value(A), 'IN/KH'),
         Extractvalue(Value(A), 'IN/KLB')
  Into v_身份证, v_姓名, v_卡号, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --先从用户自定义过程获取病人ID
  n_病人id := Zl_Third_Custom_Getpati(v_卡类别, v_卡号);

  If Nvl(n_病人id, 0) = 0 Then
    If Nvl(v_卡类别, '-') <> '-' And Nvl(v_卡号, '-') <> '-' Then
      Select Max(病人id)
      Into n_病人id
      From 病人医疗卡信息
      Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_卡类别 And Nvl(是否启用, 0) = 1) And 卡号 = v_卡号;
    End If;
    If Nvl(n_病人id, 0) = 0 And Not v_身份证 Is Null Then
      Begin
        Select 病人id Into n_病人id From 病人信息 Where 身份证号 = v_身份证;
      Exception
        When Others Then
          n_病人id := Null;
      End;
      If Nvl(n_病人id, 0) = 0 Then
        Select Max(病人id)
        Into n_病人id
        From 病人医疗卡信息
        Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 Like '%身份证%' And Nvl(是否启用, 0) = 1) And 卡号 = v_身份证;
      End If;
    End If;
  
    If Nvl(n_病人id, 0) = 0 Then
      Select Max(病人id)
      Into n_病人id
      From 病人医疗卡信息
      Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 Like '%身份证%' And Nvl(是否启用, 0) = 1) And 卡号 = v_身份证;
    End If;
  End If;

  If Nvl(n_病人id, 0) <> 0 Then
    v_Temp := '<BRID>' || n_病人id || '</BRID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Select 门诊号 Into n_门诊号 From 病人信息 Where 病人id = n_病人id;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_病人id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpati_Unique;
/

--82399:梁唐彬,2015-02-02,支付宝需求医嘱发送后产生导引
Create Or Replace Procedure Zl_门诊医嘱发送_Insert
(
  医嘱id_In     病人医嘱发送.医嘱id%Type,
  发送号_In     病人医嘱发送.发送号%Type,
  记录性质_In   病人医嘱发送.记录性质%Type,
  No_In         病人医嘱发送.No%Type,
  记录序号_In   病人医嘱发送.记录序号%Type,
  发送数次_In   病人医嘱发送.发送数次%Type,
  首次时间_In   病人医嘱发送.首次时间%Type,
  末次时间_In   病人医嘱发送.末次时间%Type,
  发送时间_In   病人医嘱发送.发送时间%Type,
  执行状态_In   病人医嘱发送.执行状态%Type,
  执行部门id_In 病人医嘱发送.执行部门id%Type,
  计费状态_In   病人医嘱发送.计费状态%Type,
  First_In      Number := 0,
  样本条码_In   病人医嘱发送.样本条码%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：填写病人医嘱发送记录 
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
           a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In
    Group By Nvl(a.相关id, a.Id), a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
             a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志;
  r_Advice c_Advice%Rowtype;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%Rowtype;

  --其它临时变量 
  v_Temp     Varchar2(255);
  v_Count    Number;
  v_病人性质 病案主页.病人性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_入院方式 入院方式.名称%Type;
  d_开始时间 病人医嘱记录.开始执行时间%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  If 首次时间_In Is Null Then
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In;
  End If;

  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
  
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理:临嘱发送后自动停止 
    --------------------------------------------------------------------------------------- 
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
        --可能没有 
        停嘱时间 = 发送时间_In,
        --要作为发送时间显示 
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作 
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --1-留观;2-住院; 
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录 
      
        --删除超过挂号有效天数的预约登记 
        Begin
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0;
        Exception
          When Others Then
            v_Count := 0;
        End;
        If Nvl(v_Count, 0) > 0 Then
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0);
          v_Count := 0;
        End If;
      
        If v_Count = 0 Then
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null;
        End If;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间);
        End If;
        If v_Count = 0 Then
          If r_Advice.操作类型 = '1' Then
            --留观医嘱,将病人在"开始时间"留观到临床执行科室 
            Begin
              v_病人性质 := 2;
              Select Decode(服务对象, 1, 1, 2)
              Into v_病人性质
              From 部门性质说明
              Where 工作性质 = '临床' And 部门id = 执行部门id_In;
            Exception
              When Others Then
                Null;
            End;
          Elsif r_Advice.操作类型 = '2' Then
            --住院医嘱,将病人在"开始时间"登记到临床执行科室 
            v_病人性质 := 0;
          End If;
        
          Open c_Pati(r_Advice.病人id);
          Fetch c_Pati
            Into r_Pati;
        
          v_入院方式 := Null;
          If r_Advice.紧急标志 = 1 Then
            v_入院方式 := '急诊';
          Else
            Select Decode(急诊, 1, '急诊', Null)
            Into v_入院方式
            From 病人挂号记录
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1;
          End If;
        
          If v_病人性质 = 1 Then
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          Else
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          End If;
          Close c_Pati;
        End If;
      End If;
    End If;
  
    Close c_Advice;
  End If;

  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null));

  --发送后产生导引
  Begin
    Execute Immediate 'Begin ZL_Third_AFTERADVICE(:1); End;'
      Using 发送号_In;
  Exception
    When Others Then
      Null;
  End;
  
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_门诊医嘱发送_Insert;
/

--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
--82380:刘尔旋,2015-02-02,HIS过程中添加动态调用生成推送信息
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  结帐id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  退支票额_In     病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成结算_In     Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.." 
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_退支票   病人预交记录.结算方式%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;
  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Open c_Feedata;
    Begin
      Fetch c_Feedata
        Into r_Feedata;
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      End If;
    Exception
      When Others Then
        n_Count := 1;
    End;
    Close c_Feedata;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                         Union All
                         Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                               预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
      n_返回值 := -1 * 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;
  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 2, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
    --医保相关表的处理 
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_Third_AFTERPAYMENT(:1); End;'
      Using 结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--82936:刘尔旋,2015-03-06,接口获取科室列表调整
--82380:刘尔旋,2015-02-02,临时XML串超长的问题
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室

  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  l_Temp     Clob; --临时XML
  x_Templet  Xmltype; --模板XML
  n_查询天数 Number(5);
  v_合作单位 合作单位安排控制.合作单位%Type;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW')
  Into n_查询天数, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  l_Temp     := '<KSLIST>';

  If v_合作单位 Is Null Then
    For r_Dept In (Select Distinct a.科室id, b.名称
                   From 挂号安排 A, 部门表 B
                   Where a.停用日期 Is Null And a.科室id = b.Id) Loop
      l_Temp := l_Temp || '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
    End Loop;
  Else
    For r_Dept In (Select Distinct b.科室id, d.名称
                   From (Select a.Id
                          From 挂号安排 A
                          Where a.停用日期 Is Null And Not Exists
                           (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = '支付宝')
                          Union All
                          Select a.Id
                          From 挂号安排 A, 合作单位安排控制 B
                          Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B, 挂号安排计划 C,
                        部门表 D
                   Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And c.生效时间 < Sysdate And
                         c.失效时间 > Sysdate + n_查询天数 And Not Exists
                    (Select 1 From 合作单位计划控制 Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id) Loop
      l_Temp := l_Temp || '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
    End Loop;
  End If;

  l_Temp := l_Temp || '</KSLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(l_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    l_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(l_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Getdeptlist;
/

--82828:胡俊勇,2015-02-28,输血申请单调整
--82311:胡俊勇,2015-02-11,输血申请单检验指标显示自己定义
  Create Or Replace Function Zl_Fun_Bloodapplyrate
(
  名称_In In 诊疗项目目录.名称%Type,
  指标_In In Varchar2
) Return Varchar2
--功能:返回在输血申请单上显示的检验指标
  --参数：名称_In 输血项目名称   诊疗项目目录.名称
  --      指标_In 字符串，半角的逗号分割，对应  诊治所见项目.中文名,指标结果的审核时间，时间可能没有，没有时用 无表示。
  --      指标名1,时间1,指标名2,时间2,指标名3,无,指标4,时间4,指标5,无,......
  --返回值：字符串格式，指标中文名|(0/1)，0-不显示当前提取到的结果，1－要显示结果。用半角的竖线和逗号分割，
  --                 如：指标1|1,指标2|1,指标3|0,指标4|1,指标5|0
  --用户可在该过程添加代码
 As
  v_Return       Varchar2(4000);
  v_Tmp指标      Varchar2(4000);
  v_中文名       Varchar2(200);
  v_名称符合     Varchar2(4000);
  v_名称时间符合 Varchar2(4000);
  n_有效时间     Number(18);
  v_Tmp时间      Varchar2(200);
  d_时间         部门表.撤档时间%Type;
  n_时间差       Number(18);
  d_Cur          部门表.撤档时间%Type;
  n_Pos          Number(6);
Begin
  If 1 = 1 Then
    v_Return := 指标_In;
    Return v_Return;
  Else
    --以下为例子代码，仅供参考
    --例子：血红蛋白,2015-01-23 12:11:23,乙肝表面抗体,2015-01-23 12:11:23,乙肝核心抗体,2015-01-23 12:11:23,甲型肝炎抗体测定,2015-01-23 12:11:23,人免疫缺陷病毒抗体测定,2015-01-23 12:11:23,其它抗体,无
    --返回：想显示的结果 例：血红蛋白,内抗体
    --说明：此过程为示例过程，使用时请跟据实际应用做相应调整
    --     示例功能：对于 输全血 项目要求，在输血申请单上只显示满足以下两个条件中的一个的指标结果。
    --              1、指标中文名为：血红蛋白,乙肝表面抗体,乙肝核心抗体，同时指标结果在24小时内。
    --              2、指标中文名为：甲型肝炎抗体测定,人免疫缺陷病毒抗体测定
    If 名称_In = '输全血' Then
      v_名称符合     := ',甲型肝炎抗体测定,人免疫缺陷病毒抗体测定,';
      v_名称时间符合 := ',血红蛋白,乙肝表面抗体,乙肝核心抗体,';
      n_有效时间     := 24 * 60 * 60;
    Elsif 名称_In = '静脉血' Then
      Null;
      --对于其它项目可以在此加代码
    End If;
    v_Tmp指标 := 指标_In || ',';
    d_Cur     := Sysdate;
    While v_Tmp指标 Is Not Null Loop
      n_时间差 := 0;
      --获取指标中文名   v_中文名
      n_Pos     := Instr(v_Tmp指标, ',');
      v_中文名  := Substr(v_Tmp指标, 1, n_Pos - 1);
      v_Tmp指标 := Substr(v_Tmp指标, n_Pos + 1);
      --获取指标产生的时间   d_时间
      n_Pos     := Instr(v_Tmp指标, ',');
      v_Tmp时间 := Substr(v_Tmp指标, 1, n_Pos - 1);
      v_Tmp指标 := Substr(v_Tmp指标, n_Pos + 1);
      If v_Tmp时间 <> '无' Then
        d_时间 := To_Date(v_Tmp时间, 'YYYY-MM-DD HH24:MI:SS');
        --指标结果和当前时间差，n_时间差  单位 秒
        Select (d_Cur - d_时间) * 24 * 60 * 60 Into n_时间差 From Dual;
      End If;
      If Instr(v_名称符合, ',' || v_中文名 || ',') > 0 Then
        v_Return := v_Return || ',' || v_中文名;
      Elsif Instr(v_名称时间符合, ',' || v_中文名 || ',') > 0 And n_时间差 < n_有效时间 Then
        v_Return := v_Return || ',' || v_中文名;
      End If;
    End Loop;
    Return v_Return;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Bloodapplyrate;
/

--82318:马政,2015-01-30,诊疗项目输血对照删除修改
Create Or Replace Procedure Zl_诊疗项目_Update
(
  类别_In             In 诊疗项目目录.类别%Type := Null,
  分类id_In           In 诊疗项目目录.分类id%Type := Null,
  Id_In               In 诊疗项目目录.Id%Type,
  编码_In             In 诊疗项目目录.编码%Type := Null,
  名称_In             In 诊疗项目目录.名称%Type := Null,
  名称拼音_In         In 诊疗项目别名.简码%Type := Null,
  名称五笔_In         In 诊疗项目别名.简码%Type := Null,
  别名_In             诊疗项目目录.名称%Type := Null,
  别名拼音_In         诊疗项目别名.简码%Type := Null,
  别名五笔_In         诊疗项目别名.简码%Type := Null,
  操作类型_In         In 诊疗项目目录.操作类型%Type := Null,
  执行频率_In         In 诊疗项目目录.执行频率%Type := Null,
  单独应用_In         In 诊疗项目目录.单独应用%Type := Null,
  计算方式_In         In 诊疗项目目录.计算方式%Type := Null,
  计算单位_In         In 诊疗项目目录.计算单位%Type := Null,
  适用性别_In         In 诊疗项目目录.适用性别%Type := Null,
  执行安排_In         In 诊疗项目目录.执行安排%Type := Null,
  服务对象_In         In 诊疗项目目录.服务对象%Type := Null,
  组合项目_In         In 诊疗项目目录.组合项目%Type := Null,
  标本部位_In         In 诊疗项目目录.标本部位%Type := Null,
  手术操作id_In       In 疾病诊断对照.疾病id%Type := Null,
  执行科室_In         In 诊疗项目目录.执行科室%Type := Null,
  门诊执行_In         In 诊疗执行科室.执行科室id%Type := Null,
  住院执行_In         In 诊疗执行科室.执行科室id%Type := Null,
  定向执行_In         In Varchar2, --开单科室定向执行的说明串，以'|'分割，每个定向按'开单科室id^执行科室id'形式组织
  参考目录id_In       In 诊疗项目目录.参考目录id%Type := Null,
  不处理执行科室_In   In Number := 0,
  应用范围_In         In Number := 0,
  录入限量_In         In 诊疗项目目录.录入限量%Type := Null,
  限量范围_In         In Number := 0,
  执行标记_In         In Number := 0,
  执行分类_In         In 诊疗项目目录.执行分类%Type := 0,
  站点_In             In 诊疗项目目录.站点%Type := Null,
  项目频率_In         In Varchar2 := Null, --该项目的频率设置串：编码|编码......
  计算规则_In         In 诊疗项目目录.计算规则%Type := Null,
  使用科室_In         In Varchar2 := Null, --使用科室的IDs,用逗号分隔
  使用科室应用范围_In In Number := 0, --使用科室应用的范围  0-本项，1-应用于同级，2-分类下所有，3-应用于当前类别
  First_In            In Number := 1, --First：1-需要删除执行科室，再新增，0-不删除执行科室，直接新增
  计算系数_In         In 诊疗项目目录.计算系数%Type := Null,
  输血检验对照_In     In Varchar2 := Null
) Is
  Type t_诊疗项目 Is Ref Cursor;
  c_诊疗项目   t_诊疗项目;
  v_Id         诊疗项目目录.Id%Type;
  t_Id         t_Numlist;
  v_Records    Varchar2(4000); --临时记录开单科室定向执行科室的字符串
  v_Currrec    Varchar2(1000); --包含在定向执行科室字符串中的一个定向
  v_Fields     Varchar2(1000);
  v_开单科室id 诊疗执行科室.开单科室id%Type := Null;
  v_执行科室id 诊疗执行科室.执行科室id%Type := Null;
  n_序号       Number;
  v_编号       Varchar2(1000);
  v_Strtmp     Varchar2(1000);
  v_Strinput   Varchar2(1000);
  Err_Notfind Exception;
Begin
  If 不处理执行科室_In = 0 Then
  
    Update 路径医嘱内容 Set 执行性质 = 执行科室_In Where 诊疗项目id = Id_In;
    Update 诊疗项目组合 Set 执行性质 = 执行科室_In Where 诊疗项目id = Id_In;
  
    Update 诊疗项目目录
    Set 类别 = 类别_In, 分类id = 分类id_In, 编码 = 编码_In, 名称 = 名称_In, 操作类型 = 操作类型_In, 执行频率 = 执行频率_In, 单独应用 = 单独应用_In,
        计算方式 = 计算方式_In, 计算单位 = 计算单位_In, 适用性别 = 适用性别_In, 执行安排 = 执行安排_In, 服务对象 = 服务对象_In, 执行科室 = 执行科室_In, 组合项目 = 组合项目_In,
        标本部位 = Decode(类别_In, 'D', Decode(组合项目_In, 1, '', 标本部位_In), 标本部位_In), 参考目录id = 参考目录id_In, 录入限量 = 录入限量_In,
        执行标记 = 执行标记_In, 执行分类 = 执行分类_In, 计算规则 = 计算规则_In, 站点 = 站点_In, 计算系数 = 计算系数_In
    Where ID = Id_In;
  
  Else
    Update 诊疗项目目录
    Set 分类id = 分类id_In, 编码 = 编码_In, 名称 = 名称_In, 操作类型 = 操作类型_In, 执行频率 = 执行频率_In, 单独应用 = 单独应用_In, 计算方式 = 计算方式_In,
        计算单位 = 计算单位_In, 适用性别 = 适用性别_In, 执行安排 = 执行安排_In, 服务对象 = 服务对象_In, 组合项目 = 组合项目_In, 录入限量 = 录入限量_In,
        标本部位 = Decode(类别_In, 'D', Decode(组合项目_In, 1, '', 标本部位_In), 标本部位_In), 执行分类 = 执行分类_In, 计算规则 = 计算规则_In, 站点 = 站点_In,
        计算系数 = 计算系数_In
    Where ID = Id_In;
  End If;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
  If 不处理执行科室_In = 0 Then
    If 手术操作id_In Is Null Then
      Delete 疾病诊断对照 Where 手术id = Id_In;
    Else
      Update 疾病诊断对照 Set 疾病id = 手术操作id_In Where 手术id = Id_In;
      If Sql%RowCount = 0 Then
        Insert Into 疾病诊断对照 (疾病id, 诊断id, 手术id) Values (手术操作id_In, Null, Id_In);
      End If;
    End If;
  End If;

  If 名称拼音_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 名称拼音_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 名称拼音_In, 1);
    End If;
  End If;
  If 名称五笔_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
  Else
    Update 诊疗项目别名 Set 名称 = 名称_In, 简码 = 名称五笔_In Where 诊疗项目id = Id_In And 性质 = 1 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 名称_In, 1, 名称五笔_In, 2);
    End If;
  End If;

  If 别名_In Is Null Then
    Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9;
  Else
    If 别名拼音_In Is Null Then
      Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 1;
    Else
      Update 诊疗项目别名 Set 名称 = 别名_In, 简码 = 别名拼音_In Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 别名_In, 9, 别名拼音_In, 1);
      End If;
    End If;
    If 别名五笔_In Is Null Then
      Delete 诊疗项目别名 Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 2;
    Else
      Update 诊疗项目别名 Set 名称 = 别名_In, 简码 = 别名五笔_In Where 诊疗项目id = Id_In And 性质 = 9 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 诊疗项目别名 (诊疗项目id, 名称, 性质, 简码, 码类) Values (Id_In, 别名_In, 9, 别名五笔_In, 2);
      End If;
    End If;
  End If;

  If 类别_In = 'D' And 组合项目_In = 1 Then
    Update 诊疗项目目录 Set 名称 = 名称_In Where ID In (Select 诊疗项目id From 诊疗项目组合 Where 诊疗组合id = Id_In);
  
    Update 诊疗项目别名
    Set 名称 = 名称_In, 简码 = Decode(码类, 1, zlSpellCode(名称_In), zlWbCode(名称_In))
    Where 性质 = 1 And 诊疗项目id In (Select 诊疗项目id From 诊疗项目组合 Where 诊疗组合id = Id_In);
  End If;

  If 不处理执行科室_In = 0 Then
    If 应用范围_In = 1 Then
      If 分类id_In Is Null Then
        Open c_诊疗项目 For
          Select ID From 诊疗项目目录 Where 分类id Is Null Order By 编码;
      Else
        Open c_诊疗项目 For
          Select ID From 诊疗项目目录 Where 分类id = 分类id_In Order By 编码;
      End If;
    Elsif 应用范围_In = 2 Then
      If 分类id_In Is Null Then
        Open c_诊疗项目 For
          Select c.Id
          From 诊疗项目目录 C, (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
          Where d.Id = c.分类id
          Order By 编码;
      Else
        Open c_诊疗项目 For
          Select c.Id
          From 诊疗项目目录 C, (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
          Where d.Id = c.分类id
          Order By 编码;
      End If;
    Elsif 应用范围_In = 3 Then
      Open c_诊疗项目 For
        Select ID From 诊疗项目目录 Where 类别 = 类别_In Order By 编码;
    Else
      Open c_诊疗项目 For
        Select ID From 诊疗项目目录 Where ID = Id_In;
    End If;
    Loop
    
      Fetch c_诊疗项目
        Into v_Id;
      Exit When c_诊疗项目%NotFound;
    
      If First_In = 1 Then
        Delete From 诊疗执行科室 Where 诊疗项目id = v_Id;
        If 执行科室_In = 4 And 门诊执行_In Is Not Null Then
          Insert Into 诊疗执行科室 (诊疗项目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 1, Null, 门诊执行_In);
        End If;
        If 执行科室_In = 4 And 住院执行_In Is Not Null Then
          Insert Into 诊疗执行科室 (诊疗项目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 2, Null, 住院执行_In);
        End If;
      End If;
      If 执行科室_In <> 4 Or 定向执行_In Is Null Then
        v_Records := Null;
      Else
        v_Records := 定向执行_In || '|';
      End If;
      While v_Records Is Not Null Loop
        v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
        v_Fields     := v_Currrec;
        v_开单科室id := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
        v_Fields     := Substr(v_Fields, Instr(v_Fields, '^') + 1);
        v_执行科室id := To_Number(v_Fields);
        Insert Into 诊疗执行科室
          (诊疗项目id, 病人来源, 开单科室id, 执行科室id)
        Values
          (v_Id, Null, Decode(v_开单科室id, 0, Null, v_开单科室id), v_执行科室id);
        v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
      End Loop;
      If 应用范围_In <> 0 Then
        Update 诊疗项目目录 Set 执行科室 = 执行科室_In Where ID = v_Id;
        Update 路径医嘱内容 Set 执行性质 = 执行科室_In Where 诊疗项目id = v_Id;
        Update 诊疗项目组合 Set 执行性质 = 执行科室_In Where 诊疗项目id = v_Id;
      End If;
    End Loop;
    Close c_诊疗项目;
  End If;

  If 限量范围_In = 1 Then
    If 分类id_In Is Null Then
      Update 诊疗项目目录 Set 录入限量 = 录入限量_In Where 分类id Is Null;
    Else
      Update 诊疗项目目录 Set 录入限量 = 录入限量_In Where 分类id = 分类id_In;
    End If;
  Elsif 限量范围_In = 2 Then
    If 分类id_In Is Null Then
      Update 诊疗项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id);
    Else
      Update 诊疗项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id);
    End If;
  Elsif 限量范围_In = 3 Then
    Update 诊疗项目目录 Set 录入限量 = 录入限量_In Where 类别 = 类别_In;
  Elsif 限量范围_In = 4 Then
    Update 诊疗项目目录 Set 录入限量 = 录入限量_In;
  End If;

  --该项目的频率设置
  If 类别_In <> 'C' Then
    Delete 诊疗用法用量 Where 项目id = Id_In;
    If 项目频率_In Is Not Null Then
      v_Strinput := 项目频率_In || '|';
      n_序号     := 0;
    
      While v_Strinput Is Not Null Loop
        v_Strtmp := Substr(v_Strinput, 1, Instr(v_Strinput, '|') - 1);
        v_编号   := v_Strtmp;
        n_序号   := n_序号 + 1;
      
        Insert Into 诊疗用法用量 (项目id, 性质, 频次) Values (Id_In, n_序号, v_编号);
        v_Strinput := Replace('|' || v_Strinput, '|' || v_Strtmp || '|');
      End Loop;
    End If;
  End If;

  --使用科室
  If 使用科室应用范围_In = 1 Then
    If 分类id_In Is Null Then
      Open c_诊疗项目 For
        Select ID From 诊疗项目目录 Where 分类id Is Null Order By 编码;
    Else
      Open c_诊疗项目 For
        Select ID From 诊疗项目目录 Where 分类id = 分类id_In Order By 编码;
    End If;
  Elsif 使用科室应用范围_In = 2 Then
    If 分类id_In Is Null Then
      Open c_诊疗项目 For
        Select c.Id
        From 诊疗项目目录 C, (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    Else
      Open c_诊疗项目 For
        Select c.Id
        From 诊疗项目目录 C, (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    End If;
  Elsif 使用科室应用范围_In = 3 Then
    Open c_诊疗项目 For
      Select ID From 诊疗项目目录 Where 类别 = 类别_In Order By 编码;
  Else
    Open c_诊疗项目 For
      Select ID From 诊疗项目目录 Where ID = Id_In;
  End If;
  Fetch c_诊疗项目 Bulk Collect
    Into t_Id;
  Close c_诊疗项目;

  Forall I In 1 .. t_Id.Count
    Delete 诊疗适用科室 Where 项目id = t_Id(I) And Instr(',' || 使用科室_In || ',', ',' || 科室id || ',') = 0;

  If 使用科室_In Is Not Null Then
    Forall I In 1 .. t_Id.Count
      Insert Into 诊疗适用科室
        (项目id, 科室id)
        Select t_Id(I), Column_Value
        From Table(f_Num2list(使用科室_In)) A
        Where Not Exists (Select 1 From 诊疗适用科室 Where 科室id = Column_Value And 项目id = t_Id(I));
  End If;
  --输血检验对照
  If 类别_In = 'K' Then
    Delete From 输血检验对照 Where 项目id = Id_In;
    If 输血检验对照_In Is Not Null Then
      v_Strinput := 输血检验对照_In || '|';
    
      While v_Strinput Is Not Null Loop
        v_Strtmp := Substr(v_Strinput, 1, Instr(v_Strinput, '|') - 1);
        v_Id     := v_Strtmp;
      
        Insert Into 输血检验对照 (项目id, 检验项目id) Values (Id_In, v_Id);
        v_Strinput := Replace('|' || v_Strinput, '|' || v_Strtmp || '|');
      End Loop;
    End If;
  End If;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该项目不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_诊疗项目_Update;
/

--81899:田林,2015-01-22,取消报到后，将报到时间清空
CREATE OR REPLACE Procedure Zl_影像检查_Cancel
(
  医嘱id_In     影像检查记录.医嘱id%Type,
  发送号_In     影像检查记录.发送号%Type,
  单独执行_In   Number := 0,
  执行部门id_In 部门表.Id%Type := 0
  --参数：  
  --      医嘱ID_IN=单独执行的医嘱ID。  
  --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行  
) Is
  Cursor c_Advice Is
    Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
  r_Advice c_Advice%RowType;

  n_报告id Number;
  v_Count  Number;
  v_Delete Boolean;
Begin
  n_报告id := 0;

  --取主医嘱ID  
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  --如果是成套执行医嘱，则取消检查的时候，删除报告，删除影像检查记录  
  --如果是单独执行医嘱，则只有在取消最后一条医嘱的时候，才删除报告，删除影像检查记录  
  v_Delete := False;

  If Nvl(单独执行_In, 0) = 0 Then
    v_Delete := True;
  Else
    Select Count(*)
    Into v_Count
    From 病人医嘱发送
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id) And 执行状态 = 1 Or 执行状态 = 3;
    If v_Count = 1 Then
      Select Count(*) Into v_Count From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      If v_Count = 1 Then
        v_Delete := True;
      End If;
    End If;
  End If;

  --删除报告信息和影像信息  
  If v_Delete = True Then
    Begin
      Select 病历id Into n_报告id From 病人医嘱报告 Where 医嘱id = r_Advice.组id;
    Exception
      When Others Then
        Null;
    End;
  
    Delete From 影像危急值记录 Where 医嘱id = 医嘱id_In;
  
    Delete 电子病历记录 Where ID = n_报告id;
  
    Delete From 影像检查记录 Where 医嘱id = r_Advice.组id;
  End If;

  --调用统一的医嘱执行Cancel过程  
  Zl_病人医嘱执行_Cancel(医嘱id_In, 发送号_In, Null, 单独执行_In, 执行部门id_In);

  --先处理医嘱执行Cancel之后，再设置病人医嘱发送表的状态,PACS中有些字段定义不一样，要特殊处理  
  --取消医嘱执行   
  If Nvl(单独执行_In, 0) = 0 Then
    Update 病人医嘱发送
    Set 首次时间 = Null,报到时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null
    Where 发送号 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id);
  Else
    Update 病人医嘱发送
    Set 首次时间 = Null,报到时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_Cancel;
/

--82004:马政,2015-01-21,药品移库数量检查
Create Or Replace Procedure Zl_药品移库_Insert
(
  No_In           In 药品收发记录.No%Type,
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  批次_In         In 药品收发记录.批次%Type,
  填写数量_In     In 药品收发记录.填写数量%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售价_In       In 药品收发记录.零售价%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  填制人_In       In 药品收发记录.填制人%Type,
  产地_In         In 药品收发记录.产地%Type := Null,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  摘要_In         In 药品收发记录.摘要%Type := Null,
  填制日期_In     In 药品收发记录.填制日期%Type := Null,
  上次供应商id_In In 药品收发记录.供药单位id%Type := Null,
  批准文号_In     In 药品收发记录.批准文号%Type := Null,
  申领方式_In     In 药品收发记录.单量%Type := Null,
  结束时间_In     In 药品收发记录.频次%Type := Null
) Is
  v_Lngid        药品收发记录.Id%Type; --收发ID
  n_出库收发id   药品收发记录.Id%Type; --出库库房收发id
  v_入的类别id   药品收发记录.入出类别id%Type; --入出类别ID
  v_出的类别id   药品收发记录.入出类别id%Type; --入出类别ID
  v_批次         药品收发记录.批次%Type := Null; --主要针对入库中实行药库分批的药品
  v_是否分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  v_药库分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  v_药房分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_检查方式     药品出库检查.检查方式%Type;
  n_可用数量     药品库存.可用数量%Type;
  v_Error        Varchar2(255);
  Err_Custom Exception;
  v_下可用库存 Zlparameters.参数值%Type;
Begin
  Select Nvl(检查方式, 0) Into n_检查方式 From 药品出库检查 Where 库房id = 库房id_In;

  Select b.Id
  Into v_入的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = 1 And Rownum < 2;
  Select b.Id
  Into v_出的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = -1 And Rownum < 2;

  Begin
    Select 上次生产日期
    Into d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      d_上次生产日期 := Null;
  End;
  Select 药品收发记录_Id.Nextval Into n_出库收发id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次)
  Values
    (n_出库收发id, 1, 6, No_In, 序号_In, 库房id_In, 对方部门id_In, v_出的类别id, -1, 药品id_In, 批次_In, 产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In);

  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_药库分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  v_是否分批 := 0;
  If v_药房分批 = 0 Then
    If v_药库分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_是否分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 对方部门id_In;
      Exception
        When Others Then
          v_是否分批 := 1;
      End;
    End If;
  Else
    v_是否分批 := 1;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  If v_是否分批 = 1 And Nvl(批次_In, 0) = 0 Then
    --入库分批且出库不分批
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid);
  Elsif v_是否分批 = 0 Then
    --入库不分批
    v_批次 := 0;
  Elsif Nvl(批次_In, 0) <> 0 Then
    --入库分批且出库也分批
    v_批次 := 批次_In;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次)
  Values
    (v_Lngid, 1, 6, No_In, 序号_In + 1, 对方部门id_In, 库房id_In, v_入的类别id, 1, 药品id_In, v_批次, 产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In);
  --处理库存
  Zl_药品库存_Update(n_出库收发id, 0);

  --根据参数决定是否下发药库房的可用库存
  Select Zl_Getsysparameter(96) Into v_下可用库存 From Dual;

  If v_下可用库存 = '1' Then
    If n_检查方式 = 2 Then
      --只有参数明确禁止时才不让负数的通过
      Select 可用数量
      Into n_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
      If n_可用数量 < 0 Then
        v_Error := '库存检查情况下，不允许负库存出库！';
        Raise Err_Custom;
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Insert;
/

--81870:马政,2015-01-20,药品结存不涉及卫材调整
Create Or Replace Procedure Zl_药品结存记录_Insert
(
  库房id_In In 药品结存记录.库房id%Type := Null,
  填制人_In In 药品结存记录.填制人%Type := Null,
  转结_In   In Number := 1
) Is
  v_Lngid      药品结存记录.Id%Type;
  d_开始日期   药品结存记录.期初日期%Type;
  d_结束日期   药品结存记录.期末日期%Type;
  n_结存时点   Number(2);
  n_上次结存id 药品结存记录.Id%Type;
  v_上次期间   药品结存记录.期间%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
  n_未审核记录 Number(1) := 0;
Begin
  If 转结_In = 0 Then
    --初始结存，期初日期 = 期末日期= 当前系统日期 
    d_开始日期 := Sysdate;
    d_结束日期 := d_开始日期;
  Else
    --检查是否存在未审核的结存记录，如果存在则不能结存 
    Select Count(ID) Into n_未审核记录 From 药品结存记录 Where 库房id = 库房id_In And 审核日期 Is Null;
  
    If n_未审核记录 > 0 Then
      v_Error := '上次结存未审核，不能再次结存';
      Raise Err_Custom;
    End If;
  
    --取结存时点，默认每月最后一日结存 
    n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);
  
    --取上次结存ID,上期期末日期作为本期的期初日期,上次期间 
    Select Max(ID), Trunc(Max(期末日期)) + 1, Max(期间)
    Into n_上次结存id, d_开始日期, v_上次期间
    From 药品结存记录
    Where 库房id = 库房id_In;
  
    If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(d_开始日期 - 1)), 'dd')) Then
      --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存 
      d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
    Else
      d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
    End If;
  
    --检查日期，在结存时点后才能进行结存 
    If Sysdate - d_结束日期 < 0 Then
      v_Error := '本月结存时点未到，不能提前结存！';
      Raise Err_Custom;
    End If;
  
    --检查期间 
    If v_上次期间 = To_Char(Trunc(d_结束日期), 'yyyymm') Then
      v_Error := '本月已经结存，不能再次结存！';
      Raise Err_Custom;
    End If;
  End If;

  Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;

  --产生药品结存主表 
  Insert Into 药品结存记录
    (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 审核人, 审核日期, 上次结存id, 期间, 性质)
  Values
    (v_Lngid, 库房id_In, d_开始日期, d_结束日期, Nvl(填制人_In, Zl_Username), Sysdate,
     Decode(d_开始日期, Null, Nvl(填制人_In, Zl_Username), Null), Decode(d_开始日期, Null, Sysdate, Null), n_上次结存id,
     To_Char(Trunc(d_结束日期), 'yyyymm'), Decode(转结_In, 0, 0, 1));

  If 转结_In = 0 Then
    --初始结存，以当前库存为准期末 = 期初=当前库存数据 
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, Nvl(a.实际数量, 0) As 期初数量, Nvl(a.实际金额, 0) As 期初金额,
                    Nvl(a.实际差价, 0) As 期初差价, Nvl(a.实际数量, 0) As 期末数量, Nvl(实际金额, 0) As 期末金额, Nvl(实际差价, 0) As 期末差价
             From 药品库存 A, 药品规格 B
             Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期初数量,
                    -1 * a.入出系数 * a.零售金额 As 期初金额, -1 * a.入出系数 * a.差价 As 期初差价, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量,
                    -1 * a.入出系数 * a.零售金额 As 期末金额, -1 * a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 > d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  Else
    --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生 
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select 库房id, 药品id, Nvl(批次, 0) As 批次, 期末数量 As 期初数量, 期末金额 As 期初金额, 期末差价 As 期初差价, 期末数量, 期末金额, 期末差价
             From 药品结存明细
             Where 结存id = n_上次结存id
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                    a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 Between d_开始日期 And d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  
    --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据) 
    Insert Into 药品结存误差
      (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
      Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
      From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
             From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                           Nvl(a.期末差价, 0) As 实际差价
                    From 药品结存明细 A, 药品规格 B
                    Where a.药品id = b.药品id And a.结存id = v_Lngid
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量, -1 * Nvl(a.实际金额, 0) As 实际金额,
                           -1 * Nvl(a.实际差价, 0) As 实际差价
                    From 药品库存 A, 药品规格 B
                    Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                           a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                    From 药品收发记录 A, 药品规格 B
                    Where a.药品id = b.药品id And a.库房id = 库房id_In And a.审核日期 > d_结束日期) A
             Group By 库房id, 药品id, 批次) A
      Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Insert;
/

--81870:马政,2015-01-20,药品结存不涉及卫材调整
Create Or Replace Procedure Zl_药品结存记录_Verify
(
  结存id_In In 药品结存记录.Id%Type,
  审核人_In In 药品结存记录.审核人%Type := Null
) Is
  v_Id    药品结存记录.Id%Type;
  Err_Msg Varchar2(255);
  Err_Find Exception;

  Cursor c_Mistake Is
    Select a.Id, a.结存id, a.库房id, a.药品id, Nvl(a.批次, 0) 批次, a.数量差, a.金额差, a.差价差
    From 药品结存误差 A, 药品规格 B
    Where a.药品id = b.药品id And a.结存id = 结存id_In;
Begin
  --并发检查 
  Begin
    Select ID Into v_Id From 药品结存记录 Where 审核人 Is Null And ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员审核，请查看！';
      Raise Err_Find;
  End;

  --审核药品结存主表 
  Update 药品结存记录
  Set 审核人 = Nvl(审核人_In, Zl_Username), 审核日期 = Sysdate
  Where 审核人 Is Null And ID = 结存id_In;

  --根据误差数据修正库存数据 
  For r_Mistake In c_Mistake Loop
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + r_Mistake.数量差, 实际数量 = Nvl(实际数量, 0) + r_Mistake.数量差, 实际金额 = Nvl(实际金额, 0) + r_Mistake.金额差,
        实际差价 = Nvl(实际差价, 0) + r_Mistake.差价差
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0);
  
    If Sql%RowCount = 0 Then
      Begin
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 效期, 上次供应商id, 上次采购价, 上次产地, 上次生产日期, 批准文号)
          Select 库房id, 药品id, Nvl(批次, 0) As 批次, 1, r_Mistake.数量差, r_Mistake.数量差, r_Mistake.金额差, r_Mistake.差价差, 批号, 效期,
                 供药单位id, 成本价, 产地, 生产日期, 批准文号
          From 药品收发记录
          Where ID = (Select Max(ID)
                      From 药品收发记录
                      Where 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0) And
                            审核日期 Is Not Null And 单据 In (1, 2, 3, 4, 6, 7, 8, 9, 10, 11));
      
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    Delete From 药品库存
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  End Loop;

Exception
  When Err_Find Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Verify;
/

--81870:马政,2015-01-20,药品结存不涉及卫材调整
Create Or Replace Procedure Zl1_Autocloseaccount Is
  v_Lngid    药品结存记录.Id%Type;
  d_开始日期 药品结存记录.期初日期%Type;
  d_结束日期 药品结存记录.期末日期%Type;
  n_结存时点 Number(2);
  v_Error    Varchar2(255);
  Err_Custom Exception;
  d_计算日期     药品结存记录.期末日期%Type;
  n_结存id       药品结存记录.Id%Type;
  n_未审核结存id 药品结存记录.Id%Type;

  Cursor c_Stock Is
    Select Distinct b.Id
    From 部门性质说明 A, 部门表 B
    Where a.部门id = b.Id And a.工作性质 In ('西药库', '成药库', '中药库', '西药房', '成药房', '中药房', '制剂室') And
          To_Char(b.撤档时间, 'yyyy-MM-dd') = '3000-01-01'
    Order By b.Id;
  r_Stock c_Stock%RowType;
Begin
  --取结存时点，默认每月最后一日结存 
  n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);

  --计算本次结存的结束日期；因为自动结存是对前一天数据进行结存，所以需要按当前日期提前一天来计算或判断， 
  If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(Sysdate - 1)), 'dd')) Then
    --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存 
    d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
  Else
    d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
  End If;

  --检查日期，在结存时点后才能进行自动结存 
  If Sysdate - d_结束日期 > 0 Then
    For r_Stock In c_Stock Loop
      --判断期间内是否有结存(不算转结) 
      Select Nvl(Max(ID), 0)
      Into n_结存id
      From 药品结存记录
      Where 库房id = r_Stock.Id And 性质 = 1 And 期间 = To_Char(Trunc(d_结束日期), 'yyyymm');
    
      If n_结存id > 0 Then
        --如果当前期间已经结存过了，就不再结存，一个期间只结存一次 
        Null;
      Else
        --取库房最大的结存ID和本次结存的开始日期 
        Select Nvl(Max(ID), 0), Max(期末日期) + 1 / 24 / 60 / 60
        Into n_结存id, d_开始日期
        From 药品结存记录
        Where 库房id = r_Stock.Id;
      
        If n_结存id > 0 Then
          --检查是否存在未审核的结存，如果存在则自动审核(通常情况都是在期间内手工审核) 
          Select Nvl(Max(ID), 0) Into n_未审核结存id From 药品结存记录 Where 库房id = r_Stock.Id And 审核日期 Is Null;
        
          If n_未审核结存id > 0 Then
            Zl_药品结存记录_Verify(n_未审核结存id, Zl_Username);
          End If;
        
          --产生新的结存记录 
          Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;
        
          Insert Into 药品结存记录
            (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 上次结存id, 期间, 性质)
          Values
            (v_Lngid, r_Stock.Id, d_开始日期, d_结束日期, Zl_Username, Sysdate, n_结存id, To_Char(Trunc(d_结束日期), 'yyyymm'), 1);
        
          --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生 
          Insert Into 药品结存明细
            (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
            Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
            From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.期末数量 As 期初数量, a.期末金额 As 期初金额, a.期末差价 As 期初差价, a.期末数量,
                          a.期末金额, a.期末差价
                   From 药品结存明细 A, 药品规格 B
                   Where a.药品id = b.药品id And a.结存id = n_结存id
                   Union All
                   Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                          a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
                   From 药品收发记录 A, 药品规格 B
                   Where a.药品id = b.药品id And a.库房id + 0 = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期)
            Group By 库房id, 药品id, 批次
            Order By 库房id, 药品id, 批次;
        
          --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据) 
          Insert Into 药品结存误差
            (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
            Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
            From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
                   From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                                 Nvl(a.期末差价, 0) As 实际差价
                          From 药品结存明细 A, 药品规格 B
                          Where a.药品id = b.药品id And a.结存id = v_Lngid
                          Union All
                          Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量,
                                 -1 * Nvl(a.实际金额, 0) As 实际金额, -1 * Nvl(实际差价, 0) As 实际差价
                          From 药品库存 A, 药品规格 B
                          Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = r_Stock.Id
                          Union All
                          Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                                 a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                          From 药品收发记录 A, 药品规格 B
                          Where a.药品id = b.药品id And a.库房id = r_Stock.Id And a.审核日期 > d_结束日期) A
                   Group By 库房id, 药品id, 批次) A
            Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
        End If;
      End If;
      --按库房提交 
      Commit;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autocloseaccount;
/

--81840:刘尔旋,2015-01-19,充值作废人员缴款余额不正确的问题
Create Or Replace Procedure Zl_消费卡充值记录_Cancel
(
  Id_In     In 消费卡充值记录.ID%Type,
  取消人_In In 消费卡充值记录.操作员姓名%Type
) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(500);
  v_卡号     消费卡目录.卡号%Type;
  d_回收时间 Date;
  d_停用时间 Date;
  n_存在卡片 Number(2);
  n_最大序号 消费卡目录.序号%Type;
  n_序号     消费卡目录.序号%Type;
  n_余额     消费卡目录.余额%Type;
  n_卡面金额 消费卡目录.卡面金额%Type;
  n_返回值   人员缴款余额.余额%Type;

  n_组id 财务缴款分组.ID%Type;

Begin
  n_组id := Zl_Get组id(取消人_In);

  For c_充值 In (Select ID, 消费卡id, 序号, 记录状态, 充值金额, 充值折扣, 缴款金额, 充值时间, 操作员姓名, 缴款人, 备注,
                        结算方式
                 From 消费卡充值记录
                 Where ID = Id_In) Loop
    --检查当前卡号是否已经使用
    Begin
      Select 卡号, 1, 回收时间, 停用日期,
             (Select Max(序号) From 消费卡目录 B Where A.卡号 = B.卡号 And A.接口编号 = B.接口编号), 序号, 余额,
             卡面金额
      Into v_卡号, n_存在卡片, d_回收时间, d_停用时间, n_最大序号, n_序号, n_余额, n_卡面金额
      From 消费卡目录 A
      Where ID = c_充值.消费卡id;
    Exception
      When Others Then
        n_存在卡片 := 0;
    End;

    --取消回收
    If n_存在卡片 = 0 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的消费卡可能被他人删除，不能进行取消充值,请检查！';
      Raise Err_Item;
    End If;
    If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
      v_Err_Msg := '不能对历史发放的消费卡(卡号为“' || v_卡号 || '”)进行取消充值,请检查！';
      Raise Err_Item;
    End If;

    If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的消费卡可能被他人回收或回退，不能进行取消充值,请检查！';
      Raise Err_Item;
    End If;

    If d_停用时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的消费卡已经停止使用，不能取消充值,请检查！';
      Raise Err_Item;
    End If;
    --检查余额是否充足
    If n_余额 - c_充值.充值金额 - n_卡面金额 < 0 Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的消费卡的余额不充足,不能取消充值,请检查！';
      Raise Err_Item;
    End If;

    --需要更新余额
    Update 消费卡目录 Set 余额 = Nvl(余额, 0) - Nvl(c_充值.充值金额, 0) Where ID = c_充值.消费卡id;
    If Sql%NotFound Then
      v_Err_Msg := '卡号为“' || v_卡号 || '”的消费卡可能被他人删除，不能进行充值,请检查！';
      Raise Err_Item;
    End If;

    Update 消费卡充值记录 Set 记录状态 = 3 Where ID = Id_In;

    Insert Into 消费卡充值记录
      (ID, 消费卡id, 序号, 记录状态, 充值金额, 充值折扣, 缴款金额, 充值时间, 操作员姓名, 缴款人, 备注, 结算方式,
       缴款组id)
    Values
      (消费卡充值记录_Id.Nextval, c_充值.消费卡id, c_充值.序号, 2, -1 * c_充值.充值金额, c_充值.充值折扣,
       -1 * c_充值.缴款金额, Sysdate, 取消人_In, c_充值.缴款人, c_充值.备注, c_充值.结算方式, n_组id);

    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) - Nvl(c_充值.缴款金额, 0)
    Where 收款员 = 取消人_In And 性质 = 1 And 结算方式 = c_充值.结算方式 Returning 余额 Into n_返回值;
    If Sql%Rowcount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (取消人_In, c_充值.结算方式, 1, -1 * Nvl(c_充值.缴款金额, 0));
      n_返回值 := Nvl(c_充值.缴款金额, 0);
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 人员缴款余额
      Where 收款员 = 取消人_In And 性质 = 1 And 结算方式 = c_充值.结算方式 And Nvl(余额, 0) = 0 And 性质 = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_消费卡充值记录_Cancel;
/

--82620:刘兴洪,2015-03-11,收费轧帐按收费类别轧帐
--81859:刘尔旋,2015-01-19,存在借款记录轧帐的问题
Create Or Replace Procedure Zl_收费员轧帐记录_Insert
(
  Id_In         In 人员收缴记录.Id%Type,
  No_In         In 人员收缴记录.No%Type,
  收款员_In     In 人员收缴记录.收款员%Type,
  收款部门id_In In 人员收缴记录.收款部门id%Type,
  冲预交款_In   In 人员收缴记录.冲预交款%Type,
  借入合计_In   In 人员收缴记录.借入合计%Type,
  借出合计_In   In 人员收缴记录.借出合计%Type,
  摘要_In       In 人员收缴记录.摘要%Type,
  开始时间_In   In 人员收缴记录.开始时间%Type,
  终止时间_In   In 人员收缴记录.终止时间%Type,
  登记人_In     In 人员收缴记录.登记人%Type,
  登记时间_In   In 人员收缴记录.登记时间%Type,
  收缴标志_In   In 人员收缴记录.收缴标志%Type,
  收费对照_In   In Varchar2,
  操作类别_In   In Integer := 0,
  暂存金_In     In 人员暂存记录.金额%Type := 0,
  类别_In       In 人员收缴记录.类别%Type := 0
) Is
  --------------------------------------------------------------------------------------------
  --功能:收费员轧帐记录写入
  --参数:记录性质_IN:
  --     收费对照_IN:性质1,记录ID1|性质2,记录ID2|...|性质n,记录IDn
  --     操作类别_In:0-保存轧帐记录和对照;1-只保存对照
  --------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;

  n_组id     人员收缴记录.缴款组id%Type;
  n_Count    Number(18);
  n_暂存id   人员暂存记录.Id%Type;
  v_暂存单号 人员暂存记录.No%Type;
  v_现金     结算方式.名称%Type;

Begin
  --并发检查,是否当前时间范围内已经有轧帐记录
  If 操作类别_In = 0 Then
    Select Count(1)
    Into n_Count
    From 人员收缴记录
    Where 收款员 = 收款员_In And 开始时间 > 开始时间_In And 作废时间 Is Null And Nvl(类别, 0) = Nvl(类别_In, 0) And Rownum < 2 And 记录性质 = 1;
    If n_Count <> 0 Then
      v_Err_Msg := '收费员:"' || 收款员_In || '"在当前轧帐范围内已经被他人进行轧帐,不能再进行轧帐！';
      Raise Err_Item;
    End If;
    If 收费对照_In Is Null Then
      v_Err_Msg := '不存在任何轧帐记录,不能进行轧帐操作！';
      Raise Err_Item;
    End If;
  End If;

  --检查是否已存在轧帐明细
  For c_检查 In (Select /*+ rule*/
                a.性质, a.记录id, m.收款员
               From 人员收缴对照 A, Table(f_Str2list2(收费对照_In, '|', ',')) B, 人员收缴记录 M
               Where a.性质 = b.C1 And a.记录id = b.C2 And a.收缴id = m.Id And m.作废时间 Is Null And Rownum < 2) Loop
    --1-收费(含挂号),2-结帐,3-预交,4-借款;5-消费卡充值;6--消费卡面值;7-暂存金(本次增加)；８－收款或轧帐作废对照（本次增加）
    If c_检查.性质 = 1 Then
      Select Decode(记录性质, 1, '收费', 4, '挂号', '') || '单据为:' || NO || '的' || Decode(记录性质, 1, '收费', 4, '挂号', '') ||
              '记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 门诊费用记录
      Where 结帐id = c_检查.记录id And Rownum < 2;
    End If;
  
    If c_检查.性质 = 2 Then
      Select '结帐单据为:' || NO || '的结帐记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 病人结帐记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 3 Then
      Select '预交单据为:' || NO || '的预交记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 病人预交记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 4 And 收款员_In = c_检查.收款员 Then
      Select '收费员在' || To_Char(借出时间, 'yyyy-mm-dd hh24:mi:ss') || '的' || Decode(借款人, Null, '借出款', '借入款') ||
              '已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 人员借款记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
  
    If c_检查.性质 = 5 Then
      Select '收费员在' || To_Char(充值时间, 'yyyy-mm-dd hh24:mi:ss') || '的消费卡充值记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 消费卡充值记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 6 Then
      Select '收费员在发卡号为:' || 卡号 || '的且发卡时间为:' || To_Char(发卡时间, 'yyyy-mm-dd hh24:mi:ss') || '发卡记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 消费卡目录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 7 Then
      Select '暂存单号为:' || NO || '的暂存记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 人员暂存记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 9 Then
      Select '单号为:' || NO || '的补充结算记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 费用补充记录
      Where 结算id = c_检查.记录id And Rownum < 2;
    End If;
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
  End Loop;

  If 操作类别_In = 0 Then
    n_组id := Zl_Get组id(收款员_In);
    Insert Into 人员收缴记录
      (ID, 记录性质, NO, 收款员, 收款部门id, 冲预交款, 借入合计, 借出合计, 摘要, 开始时间, 终止时间, 缴款组id, 登记人, 登记时间, 收缴标志, 类别)
    Values
      (Id_In, 1, No_In, 收款员_In, 收款部门id_In, 冲预交款_In, 借入合计_In, 借出合计_In, 摘要_In, 开始时间_In, 终止时间_In, n_组id, 登记人_In, 登记时间_In,
       收缴标志_In, 类别_In);
  
    Update 人员缴款余额 Set 上次轧帐时间 = 终止时间_In Where 收款员 = 收款员_In;
  End If;
  --插入收费对照
  Insert Into 人员收缴对照
    (收缴id, 性质, 记录id)
    Select Id_In, C1, C2 From Table(f_Str2list2(收费对照_In, '|', ','));
  If 暂存金_In <> 0 Then
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Select 人员暂存记录_Id.Nextval Into n_暂存id From Dual;
    v_暂存单号 := Nextno(141);
    Insert Into 人员暂存记录
      (ID, 收缴id, 记录性质, NO, 结算方式, 金额, 收款员, 登记人, 登记时间)
    Values
      (n_暂存id, Id_In, 2, v_暂存单号, v_现金, -1 * 暂存金_In, 收款员_In, 登记人_In, 登记时间_In);
  
    Insert Into 人员收缴对照 (收缴id, 性质, 记录id) Values (Id_In, 7, n_暂存id);
    Select 人员暂存记录_Id.Nextval Into n_暂存id From Dual;
    v_暂存单号 := Nextno(141);
    Insert Into 人员暂存记录
      (ID, 收缴id, 记录性质, NO, 结算方式, 金额, 收款员, 登记人, 登记时间)
    Values
      (n_暂存id, Id_In, 2, v_暂存单号, v_现金, 暂存金_In, 收款员_In, 登记人_In, 登记时间_In + 1 / 24 / 60 / 60);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费员轧帐记录_Insert;
/

--82740:张德婷,2015-03-23,确认输液单变化条件
--76300:张德婷,2015-03-09,来源科室调整为来源病区
--81825:张德婷,2015-01-16,查询该病人输液单的时候加上病人条件
--82158:张德婷,2015-03-30,tpn输液单全部为配置状态
--82158:张德婷,2015-03-30,配置中心tpn输液单全部接收为配置状态
--82158:李业庆,2015-01-26,TPN处置方式
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In And b.病人id = n_病人id
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;
  Function Zl_Getpivaworkbatch
  (
    执行时间_In   In Date,
    配置中心id_In In 输液配药记录.部门id%Type
  ) Return Number As
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 配置中心id_In
      Order By 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 配置中心id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch     := 0;
      v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
      v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
    
      If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
        v_Batch := v_配药批次.批次;
        n_打包  := v_配药批次.打包;
        Exit When v_Batch > 0;
      End If;
    End Loop;
  
    If v_Batch = 0 Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源病区', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  
  v_医嘱ids  := 医嘱id_In;
  v_当前病人 := '';

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B
    Where a.收费细目id = b.药品id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
    
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人病区id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
    
    If v_医嘱记录.是否tpn = 2 Then
      v_Continue := 1;  
    end if;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change      := True;
            d_Old执行时间 := v_执行时间;
            
            Select /*+ rule*/
             Count(a.要求时间)
            Into n_Cur
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60;
            
            Select Count(a.要求时间)
            Into n_Sum
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
            Select Count(Distinct a.摆药单号)
            Into n_摆药单
            From 输液配药记录 A
            Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                  a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
          
            If n_Cur <> n_Sum Or  n_摆药单 > 1 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
              
              For v_输液记录 In (Select ID, 执行时间
                             From 输液配药记录
                             Where 医嘱id In
                                   (Select ID
                                    From 病人医嘱记录
                                    Where 病人id =
                                          (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                                   执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60 And 操作状态 < 2) Loop
                v_批次 := Zl_Getpivaworkbatch(v_输液记录.执行时间, 部门id_In);
                Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液记录.Id;
                v_批次 := 0;
              End Loop;
            End If;
          End If;
        
          If b_Change = True Then
            b_Change := True;
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            End If;
          
            If b_Change = True Then
              For v_单个医嘱记录 In c_单个医嘱记录 Loop
                --检查输液单是否调整到打包状态
                Select Count(ID)
                Into n_Sum
                From 输液配药记录
                Where 医嘱id = v_单个医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And
                      打包时间 Is Not Null;
                If n_Sum <> 0 Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              
                Select Count(医嘱id)
                Into n_Cur
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
                Select Count(医嘱id)
                Into n_Sum
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
                If n_Sum <> n_Cur Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              End Loop;
            End If;
          End If;
        
          If v_保持上次批次 = 1 Or b_Change = True Then
            --取上次的批次
            Begin
              Select Distinct 配药批次
              Into v_批次
              From 输液配药记录 A
              Where 医嘱id = v_医嘱记录.相关id And
                    发送号 = (Select Distinct Max(发送号)
                           From 输液配药记录
                           Where 医嘱id = v_医嘱记录.相关id And 发送号 <> v_医嘱记录.发送号) And
                    To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_执行时间, 'hh24:mi:ss');
            Exception
              When Others Then
                v_批次 := 0;
            End;
          End If;
        
          If v_批次 = 0 Then
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, 部门id_In);
          
            --同病人同批次总输液量控制，超过则分配到下个批次
            If v_输液总量 > 0 And Not v_大输液剂型 Is Null And v_批次 < v_Maxbatch Then
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Curdose
                From (Select Distinct c.Id, c.单量
                       From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id And
                             e.药名id = f.药名id And b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And
                             f.药品剂型 = g.Column_Value And a.相关id = v_相关id And b.发送号 = v_发送号);
              Exception
                When Others Then
                  v_Curdose := 0;
              End;
            
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Sumdose
                From (Select Distinct a.Id, a.单量
                       From 药品收发记录 A, 病人医嘱记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where c.Id = d.记录id And a.Id = d.收发id And c.医嘱id = b.Id And a.药品id + 0 = e.药品id And
                             e.药名id = f.药名id And b.病人id + 0 = v_医嘱记录.病人id And f.药品剂型 = g.Column_Value And
                             c.执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And c.配药批次 = v_批次);
              Exception
                When Others Then
                  v_Sumdose := 0;
              End;
            
              If v_Sumdose > 0 And v_Sumdose + v_Curdose > v_输液总量 Then
                v_批次 := v_批次 + 1;
              End If;
            End If;
          End If;
        
          Select Count(医嘱id)
          Into n_发送次数
          From 医嘱执行时间
          Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
          Order By 要求时间;
        
          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 启用 = 1 And 配置中心id = 部门id_In And 批次 = v_批次;
          End If;
        
          If Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0 Then
            n_是否打包     := 1;
            d_手工打包时间 := Sysdate;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
           --如果是TPN：如果指定了要打包或配置，则不管其他条件如何都设置为打包或配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, Decode(v_批次, 0, Null, v_批次), v_Maxno, n_调整批次, n_是否打包,
             d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          --产生配药记录对应的药品记录
          For v_收发记录 In c_收发记录 Loop
            If v_收发记录.是否不予配置 = 1 Then
              v_Nodosage := 1;
            End If;
          
            n_Count := n_Count + 1;
          
            Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
          
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
               成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
               产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
              Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                     效期, 付数, 填写数量 / v_Count, 实际数量 / v_Count, 成本价, 成本金额 / v_Count, 扣率, 零售价, 零售金额 / v_Count, 差价 / v_Count,
                     '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                     领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间



        From 药品收发记录
              Where ID = v_收发记录.收发id;
          
            Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, v_收发记录.数量 / v_Count);
          End Loop;
        
        End Loop;
      
        For v_收发记录 In c_收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录 Set 是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--81683:李南春,2015-01-13,赋值语句容错处理
CREATE OR REPLACE Procedure Zl_门诊记帐记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  婴儿费_In     门诊费用记录.婴儿费%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  划价_In       Number,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  记帐单id_In   门诊费用记录.记帐单id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  门诊标志_In   门诊费用记录.门诊标志%Type := 1,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
) As
  --功能：新收一张门诊记帐单据
  --参数：
  --   药品摘要_IN:修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And
          Decode(备货材料_In, 0, 0, Nvl(批次, 0)) = Decode(备货材料_In, 0, 0, Nvl(批次_In, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock      c_Stock%RowType;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_部门名称   部门表.名称%Type;
  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法     药品收发记录.用法%Type;
  v_煎法     药品收发记录.外观%Type;
  n_单价小数 Number;

  n_Outmode Number(1);
  n_Dec     Number;
  n_Count   Number;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_发药窗口 药品收发记录.发药窗口%Type;
  n_跟踪在用 材料特性.跟踪在用%Type;

Begin
  n_跟踪在用 := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select Nvl(跟踪在用, 0) Into n_跟踪在用 From 材料特性 Where 材料id = 收费细目id_In;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    --根据执行库房取虚拟库房ID
    Begin
      Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
    Exception
      When Others Then
        n_虚拟库房id := 0;
    End;
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  If (收费类别_In In ('5', '6', '7') Or 收费类别_In = '4' And n_跟踪在用 = 1) And Nvl(划价_In, 0) = 0 Then
    --同一张单据,满足同一药房同一窗口
    Begin
      Select 发药窗口
      Into v_发药窗口
      From 门诊费用记录
      Where 收费类别 In ('5', '6', '7', '4') And NO = No_In And 记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And
            Rownum <= 1;
    Exception
      When Others Then
        v_发药窗口 := Null;
    End;
    If v_发药窗口 Is Null Then
      --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
      n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
      If n_Count = 0 Then
        n_Count := 1;
      End If;

      Begin
        Select 发药窗口
        Into v_发药窗口
        From (Select 登记时间, 发药窗口
               From 门诊费用记录 A
               Where 收费类别 In ('5', '6', '7', '4') And 病人id = 病人id_In And 登记时间 Between Sysdate - n_Count And Sysdate And
                     记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And Exists
                (Select 1
                      From 未发药品记录
                      Where a.No = NO And 单据 In (9, 26) And 库房id + 0 = 执行部门id_In And 病人id + 0 = 病人id_In) And Exists
                (Select 1
                      From 发药窗口
                      Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = 执行部门id_In)
               Order By 登记时间 Desc)
        Where Rownum <= 1;

      Exception
        When Others Then
          v_发药窗口 := Null;
      End;
      If v_发药窗口 Is Null Then
        v_发药窗口 := Zl_Get发药窗口(执行部门id_In);
      End If;
    End If;
  End If;
  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  
  --是否是急诊挂号单
  If NVL(医嘱序号_In,0) <> 0 then
     Select NVL(MAX(急诊),0) Into n_急诊 From 病人挂号记录 Where NO In (Select 挂号单 From 病人医嘱记录 Where ID=NVL(医嘱序号_In,0)) And 病人ID=病人id_In;
  End if;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
     附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 操作员编号, 操作员姓名, 婴儿费, 记帐单id,
     摘要, 医嘱序号, 结论, 发药窗口,是否急诊)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 门诊标志_In, 病人id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In,
     病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 付数_In, 数次_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In,
     实收金额_In, 1, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 婴儿费_In, 记帐单id_In, 费用摘要_In, 医嘱序号_In, 中药形态_In, v_发药窗口,Nvl(n_急诊,0));

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1;

    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, 实收金额_In, 0);
    End If;

    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 门诊标志_In;

    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 门诊标志_In, 实收金额_In);
    End If;

  End If;

  --药品和卫生材料部分

  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_跟踪在用, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;

    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;

    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      n_库房id := 执行部门id_In;
    End If;
    Open c_Stock(n_Outmode, n_库房id);

    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;

      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;

      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;

      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;

      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;

      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;

        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;

      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 25, 9) And 记录状态 = 1 And NO = No_In;

      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;

      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;

      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 25, 9), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);

      --产生其他出库单
      If 收费类别_In = '4' And Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And 记录性质 = 2 And b.门诊标志 = 门诊标志_In And instr( ',8,9,10,21,24,25,26,',','||a.单据||',')>0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);

        n_出库序号 := Nvl(n_出库序号, 0) + 1;

        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;

    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 姓名 = 姓名_In, 发药窗口 = v_发药窗口
    Where 单据 = Decode(收费类别_In, '4', 25, 9) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态, 发药窗口)
      Values
        (Decode(收费类别_In, '4', 25, 9), No_In, 病人id_In, 姓名_In, v_优先级, 开单部门id_In, 执行部门id_In, 登记时间_In,
         Decode(划价_In, 1, 0, 1), 0, v_发药窗口);
    End If;
    Zl_Prescription_Type_Update(No_In, 2, 收费细目id_In, 收费类别_In);

    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;

    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Insert;
/

--81683:李南春,2015-01-13,对赋值语句容错处理
CREATE OR REPLACE Procedure Zl_门诊划价记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  病人来源_In   Number := 1,
  保险编码_In   门诊费用记录.保险编码%Type := Null,
  费用类型_In   门诊费用记录.费用类型%Type := Null,
  保险项目否_In 门诊费用记录.保险项目否%Type := Null,
  保险大类id_In 门诊费用记录.保险大类id%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null

) As
  --功能：新收一张门诊划价单据
  --参数：
  --   病人来源_IN:1-门诊病人,2-住院病人
  --     主页ID_IN:住院病人划价时用。
  --   药品摘要_IN:修改保存新单据时用。目前仅存放在药品收发记录的摘要中。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And
          Decode(备货材料_In, 0, 0, Nvl(批次, 0)) = Decode(备货材料_In, 0, 0, Nvl(批次_In, 0)) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  v_其他出库no 药品收发记录.No%Type;
  v_部门名称   部门表.名称%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;
  n_单价小数   Number;
  n_Outmode    Number(1);
  n_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
Begin
  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    --根据执行库房取虚拟库房ID
    Begin
      Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
    Exception
      When Others Then
        n_虚拟库房id := 0;
    End;
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额及单价小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  --是否是急诊挂号单
  If NVL(医嘱序号_In,0) <> 0 then
     Select NVL(MAX(急诊),0) Into n_急诊 From 病人挂号记录 Where NO In (Select 挂号单 From 病人医嘱记录 Where ID=NVL(医嘱序号_In,0)) And 病人ID=病人id_In;
  End if;
  
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 发药窗口,
     加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要, 医嘱序号, 保险项目否, 保险编码,
     保险大类id, 费用类型, 结论,是否急诊)
  Values
    (v_费用id, 1, No_In, 0, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In), Nvl(病人来源_In, 1),
     Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In, 病人科室id_In, 费别_In, 收费类别_In,
     收费细目id_In, 计算单位_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 0,
     操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, 费用摘要_In, 医嘱序号_In, 保险项目否_In, 保险编码_In, 保险大类id_In,
     费用类型_In, 中药形态_In,Nvl(n_急诊,0));

  --药品和卫生材料部分
  n_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into n_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;

    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;

    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      n_库房id := 执行部门id_In;
    End If;

    Open c_Stock(n_Outmode, n_库房id);

    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货收费！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货收费！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫行材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;

      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;

      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;

      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;

      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;

        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;

      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;

      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;

      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;

      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      --产生其他出库单
      If 收费类别_In = '4' And Nvl(备货材料_In, 0) = 1 Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And b.记录性质 = 1 And instr( ',8,9,10,21,24,25,26,',','||a.单据||',')>0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);

        n_出库序号 := Nvl(n_出库序号, 0) + 1;

        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码,
           v_内部条码);

      End If;
      v_Err_Msg := '';

      n_总数量 := n_总数量 - n_当前数量;
      n_总金额 := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;

    --未发药品记录
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), 主页id_In, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 0, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);

    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;

    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then

    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;

    If 费别_In Is Not Null Then
      Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
    End If;

    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;

    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Insert;
/


--81595:马政,2015-01-12,中草药成本价变动修正改进
Create Or Replace Procedure Zl_药品收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_审核日期     药品收发记录.审核日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_费用单价精度 Number;
  d_填制日期     药品收发记录.填制日期%Type;
  d_日期         药品收发记录.填制日期%Type;
Begin

  --1、售价调剂处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出系数, Nvl(a.零售价, 0) 原价, b.现价,
         Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id
  Into v_单据, v_库房id, v_药品id, v_批次, v_实际数量, v_入出系数, v_原价, v_现价, v_是否变价, v_价格id
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5')) Into n_费用单价精度 From Dual;
  If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
    --发药应该取费用精度，其他业务应该取药品卫材精度中精度
    Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into v_金额精度 From Dual;
  Else
    Select Nvl(精度, 2) Into v_金额精度 From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  End If;
  --定价直接取收费价目中现价
  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    v_执行修正 := 1;
  Else
    --时价药品的现售价，不能从收费价目中取，因为时价调价可能是按库房和批次来调整的
    v_现价 := 0;
  
    If v_批次 > 0 Then
      --时价分批优先从库存表中取，时价不分批则直接在明细表中查调价记录的零售价
      --从库存记录中取现价
      Begin
        Select Nvl(零售价, 0)
        Into v_现价
        From 药品库存
        Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 = 0 Then
      Begin
        --取原始单据的审核时间
        Select a.审核日期, a.填制日期
        Into v_审核日期, d_填制日期
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
        If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
          d_日期 := d_填制日期;
        Else
          d_日期 := v_审核日期;
        End If;
      
        If Months_Between(Sysdate, d_日期) <= 1 Then
          --只处理小于一个月的数据
          --从调价记录中取现零售价
          Select 零售价, 价格id
          Into v_现价, v_价格id
          From (Select 零售价, 价格id
                 From 药品收发记录
                 Where 单据 = 13 And 摘要 = '药品调价' And 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And
                       审核日期 Between d_日期 And Sysdate
                 Order By 审核日期 Desc)
          Where Rownum = 1;
        End If;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 > 0 Then
      v_执行修正 := 1;
    End If;
  End If;

  If v_执行修正 = 1 Then
    --发药类单据售价精度为5，其他流通类单据为7
    If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
      v_售价精度 := n_费用单价精度;
    Else
      v_售价精度 := 7;
    End If;
  
    --比较原价和现价，不同则处理
    If v_原价 <> Round(v_现价, v_售价精度) Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
    
      Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 13;
    
      v_修正金额 := Round(v_入出系数 * (Round(v_现价, v_售价精度) - v_原价) * v_实际数量, v_金额精度);
    
      --产生调价修正记录
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
         填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
        Select v_收发id, 1, 13, v_收发id, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, Abs(v_实际数量), 0, v_原价, 0,
               Round(v_现价, v_售价精度), 扣率, v_修正金额, v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新药品库存
      Zl_药品库存_Update(v_收发id);
    End If;
  End If;

  --2、成本价调价
  Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * Nvl(实际数量, 0) * Nvl(付数, 1) As 实际数量, 入出系数 * 零售金额, 入出系数 * 差价, 成本价
  Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
  From 药品收发记录
  Where ID = 收发id_In;

  --取原始单据的审核时间
  Select a.审核日期
  Into v_审核日期
  From 药品收发记录 A, 药品收发记录 B
  Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
        (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  v_执行修正 := 0;
  Begin
    Select 1, 新成本价
    Into v_执行修正, v_现价
    From 成本价调价信息
    Where 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And 执行日期 > v_审核日期 And Rownum = 1
    Order By 执行日期 Desc;
  
  Exception
    When Others Then
      v_执行修正 := 0;
      v_现价     := 0;
    
  End;

  If v_执行修正 = 1 Then
    v_修正金额 := (v_零售金额 - v_差价) - Round(v_现价 * v_实际数量, v_金额精度);
  
    If v_修正金额 <> 0 Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Select b.Id, b.系数
      Into v_入出类别id, v_入出系数
      From 药品单据性质 A, 药品入出类别 B
      Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
    
      v_No := Nextno(25, v_库房id);
    
      --产生库存差价调整单
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
        Select v_收发id, 1, 5, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价, v_修正金额,
               '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新库存
      Zl_药品库存_Update(v_收发id);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_调价修正;
/

--91484:马政,2015-01-12,卫材财务审核时可用数量修正
Create Or Replace Procedure Zl_药品财务审核_Insert
(
  库房id_In   In 药品财务审核.库房id%Type,
  单据_In     In 药品财务审核.单据%Type,
  冲销no_In   In 药品财务审核.上次no%Type,
  Newno_In    In 药品财务审核.本次no%Type,
  审核人_In   In 药品财务审核.审核人%Type,
  审核日期_In In 药品财务审核.审核日期%Type,
  摘要_In     In 药品财务审核.摘要%Type := Null
) Is
  v_原始no 药品收发记录.No%Type;
Begin
  Begin
    Select 原始no Into v_原始no From 药品财务审核 Where 单据 = 单据_In And 本次no = 冲销no_In;
  Exception
    When Others Then
      v_原始no := Null;
  End;
  Insert Into 药品财务审核
    (库房id, 单据, 原始no, 上次no, 本次no, 审核人, 审核日期, 摘要)
  Values
    (库房id_In, 单据_In, Decode(v_原始no, Null, 冲销no_In, v_原始no), 冲销no_In, Newno_In, 审核人_In, 审核日期_In, 摘要_In);

  Update 药品收发记录 Set 费用id = 2 Where 单据 = 单据_In And NO = Newno_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--91484:马政,2015-01-09,卫材财务审核时可用数量修正
Create Or Replace Procedure Zl_材料外购_Verify
(
  No_In       In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_单位id      药品收发记录.供药单位id%Type;
  n_发票金额    应付记录.发票金额%Type;
  n_库存金额    药品库存.实际金额%Type;
  n_库存差价    药品库存.实际差价%Type;
  n_库存数量    药品库存.实际数量%Type;
  n_实价卫材    收费项目目录.是否变价%Type;
  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  v_条码前缀    Varchar2(20);
  v_内部条码    药品库存.内部条码%Type;
  v_移库no      药品收发记录.No%Type;
  v_对方库房id  药品收发记录.库房id%Type := 0;
  v_入类别id    药品收发记录.入出类别id%Type := 0;
  v_出类别id    药品收发记录.入出类别id%Type := 0;
  n_平均成本价  药品库存.平均成本价%Type;
  n_可用数量    药品收发记录.实际数量%Type;
Begin
  v_条码前缀 := Nvl(Zl_Getsysparameter(159), '');

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核或删除，不能进行审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --原分批现不分批的材料,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 材料特性 B
         Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.库房分批, 0) = 0 Or
               (Nvl(b.在用分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室')))));

  For v_收发 In (Select a.Id, a.实际数量, a.发药方式, a.零售价, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期,
                      a.灭菌效期, a.生产日期, a.产地, a.入出类别id, a.注册证号, a.扣率, a.商品条码, a.内部条码, Nvl(b.是否条码管理, 0) As 条码管理, a.批准文号,
                      Nvl(a.费用id, 0) As 费用id
               From 药品收发记录 A, 材料特性 B
               Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1
               Order By a.药品id) Loop
    v_内部条码 := Null;
    If v_收发.条码管理 = 1 Then
      If v_收发.内部条码 Is Null Then
        If Not v_条码前缀 Is Null Then
          v_内部条码 := v_条码前缀 || Nextno(126);
        Else
          v_内部条码 := Nextno(126);
        End If;
      Else
        v_内部条码 := v_收发.内部条码;
      End If;
    End If;
  
    --更改材料库存表的相应数据
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_收发.药品id;
  
    If v_收发.费用id = 2 Then
      n_可用数量 := Nvl(v_收发.实际数量, 0);
    Else
      If v_收发.发药方式 = 1 Then
        n_可用数量 := 0;
      Else
        n_可用数量 := Nvl(v_收发.实际数量, 0);
      End If;
    End If;
  
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + Nvl(v_收发.实际数量, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(v_收发.零售金额, 0),
        实际差价 = Nvl(实际差价, 0) + Nvl(v_收发.差价, 0), 上次供应商id = Nvl(v_收发.供药单位id, 上次供应商id), 上次采购价 = Nvl(v_收发.成本价, 上次采购价),
        上次批号 = Nvl(v_收发.批号, 上次批号), 上次产地 = Nvl(v_收发.产地, 上次产地), 灭菌效期 = Nvl(v_收发.灭菌效期, 灭菌效期),
        上次生产日期 = Nvl(v_收发.生产日期, 上次生产日期), 效期 = Nvl(v_收发.效期, 效期),
        零售价 = Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)), 上次扣率 = Nvl(v_收发.扣率, 上次扣率),
        商品条码 = v_收发.商品条码, 内部条码 = v_内部条码, 批准文号 = v_收发.批准文号
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 效期, 零售价, 上次扣率, 商品条码,
         内部条码, 平均成本价, 批准文号)
      Values
        (v_收发.库房id, v_收发.药品id, v_收发.批次, 1, n_可用数量, v_收发.实际数量, v_收发.零售金额, v_收发.差价, v_收发.供药单位id, v_收发.成本价, v_收发.批号,
         v_收发.生产日期, v_收发.产地, v_收发.灭菌效期, v_收发.效期, Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)),
         v_收发.扣率, v_收发.商品条码, v_内部条码, v_收发.成本价, v_收发.批准文号);
    End If;
  
    If v_收发.内部条码 Is Null And Not v_内部条码 Is Null Then
      Update 药品收发记录 Set 内部条码 = v_内部条码 Where ID = v_收发.Id;
    End If;
  
    --清除数量金额为零的记录
    Delete From 药品库存
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --更改材料收发汇总表的相应数据
    --更新该材料的成本价
    Begin
      Select Sum(Nvl(实际金额, 0)), Sum(Nvl(实际差价, 0)), Sum(Nvl(实际数量, 0))
      Into n_库存金额, n_库存差价, n_库存数量
      From 药品库存
      Where 性质 = 1 And 药品id = v_收发.药品id;
    Exception
      When Others Then
        n_库存数量 := 0;
    End;
  
    --更新该药品的成本价
    Update 材料特性
    Set 成本价 = v_收发.成本价, 上次售价 = v_收发.零售价, 上次供应商id = v_收发.供药单位id, 上次产地 = v_收发.产地
    Where 材料id = v_收发.药品id;
  
    --更改材料特性中的注册证号:如果发现材料特性表中的注册证号没填，则直接反写给材料特性表中的注册证号
    If Nvl(v_收发.注册证号, ' ') <> ' ' Then
      Update 材料特性 Set 注册证号 = v_收发.注册证号 Where 材料id = v_收发.药品id And 注册证号 Is Null;
    End If;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 库房id = v_收发.库房id And 性质 = 1 And Nvl(实际数量, 0) <> 0;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_收发.药品id;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 药品id = v_收发.药品id And 库房id = v_收发.库房id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = No_In And 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into n_单位id, n_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = No_In And a.单据 = 15 And b.系统标识 = 5
    Group By b.单位id;
  
    If Nvl(n_单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(n_发票金额, 0) Where 单位id = n_单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (n_单位id, 1, n_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;

  --如果是自动产生的备货卫材入库单，则产生移库单
  For v_Data In (Select ID, 序号, 实际数量, 发药方式, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 供药单位id, 成本价, 成本金额, 批号, 效期, 灭菌效期, 生产日期, 产地,
                        入出类别id, 注册证号, 扣率, 摘要, 商品条码, 内部条码, 费用id, 审核人, 审核日期
                 From 药品收发记录
                 Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核日期 Is Not Null And 费用id > 0
                 Order By 序号) Loop
    If v_对方库房id = 0 Then
      Begin
        Select Distinct 库房id Into v_对方库房id From 药品收发记录 Where 单据 In (24, 25) And 费用id = v_Data.费用id;
      Exception
        When Others Then
          v_对方库房id := 0;
      End;
    End If;
  
    If v_对方库房id > 0 Then
      If v_移库no Is Null Then
        v_移库no := Nextno(72, v_Data.库房id);
      End If;
    
      Zl_材料移库_Insert(v_移库no, v_Data.序号 * 2 - 1, v_Data.库房id, v_对方库房id, v_Data.药品id, v_Data.批次, v_Data.实际数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售价, v_Data.零售金额, v_Data.差价, v_Data.审核人, v_Data.产地, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.摘要, v_Data.审核日期);
    End If;
  End Loop;

  --对新产生的移库单进行备料和审核
  If Not v_移库no Is Null Then
    Zl_材料移库_Prepare(v_移库no, 审核人_In);
    Zl_材料移库_Prepare(v_移库no);
  
    Select b.Id As 类别id
    Into v_入类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = 1 And Rownum < 2;
  
    Select b.Id As 类别id
    Into v_出类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = -1 And Rownum < 2;
  
    For v_Data In (Select 序号, 库房id, 对方部门id, 药品id, 产地, Nvl(批次, 0) As 批次, 填写数量, 实际数量, 成本价, 成本金额, 零售金额, 差价, NO, 填制人, 批号, 效期,
                          灭菌效期, 填制日期
                   From 药品收发记录
                   Where 单据 = 19 And NO = v_移库no And 审核日期 Is Null And 入出系数 = -1
                   Order By 序号) Loop
    
      Zl_材料移库_Verify(v_Data.序号, v_Data.库房id, v_Data.对方部门id, v_Data.药品id, v_Data.产地, v_Data.批次, v_Data.填写数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售金额, v_Data.差价, v_出类别id, v_入类别id, v_Data.No, v_Data.填制人, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.填制日期);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Verify;
/

--82063:梁唐彬,2015-01-23,门诊留观病人医嘱回退问题
--80775:胡俊勇,2015-01-07,输液药品记录的回退
Create Or Replace Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                --还原医嘱执行时间
                Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                Into v_Time
                From Dual;
                Insert Into 医嘱执行时间
                  (要求时间, 医嘱id, 发送号)
                  Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                  From Table(f_Str2list(v_Time));
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(是否锁定, 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0  And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', Nvl(r_Rolladvice.类型, '0')) > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                If r_Patilog.科室id = r_Rolladvice.执行科室id Then
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr('7,8,11', r_Rolladvice.类型) > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--81400:胡俊勇,2015-01-07,医嘱单打印问题
CREATE OR REPLACE Procedure Zl_病人医嘱打印_Delete
(
  病人id_In   病人医嘱记录.病人id%Type,
  主页id_In   病人医嘱记录.主页id%Type,
  婴儿_In     病人医嘱记录.婴儿%Type,
  期效_In     病人医嘱记录.医嘱期效%Type,
  起始页号_In 病人医嘱打印.页号%Type,
  医嘱位置_In Varchar2 := Null,
  清除方式_In Number := 0
  --1－清除未打印但已生成的预打印记录，0－清除已经打过的记录及之后的
) Is
  v_位置 Varchar2(20);
Begin

  If 期效_In = 0 Then
    Select Nvl(Max(LPad(页号, 4, '0') || LPad(行号, 3, '0')), '0000000')
    Into v_位置
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id Is Null And 特殊医嘱 Is Null;
  Else
    v_位置 := '0000000';
  End If;

  If 医嘱位置_In > v_位置 And 清除方式_In = 1 Then
    v_位置 := 医嘱位置_In;
  
    --长期医嘱单有可能产生了特殊医嘱，重整，重开 的预打印记录。如果是紧挨着的要删掉
    If 期效_In = 0 Then
      For R In (Select 医嘱id, 打印时间, LPad(页号, 4, '0') || LPad(行号, 3, '0') As 位置
                From 病人医嘱打印
                Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 页号 = 起始页号_In And
                      LPad(页号, 4, '0') || LPad(行号, 3, '0') < v_位置
                Order By 行号 Desc) Loop
        If r.医嘱id Is Null And r.打印时间 Is Null Then
          v_位置 := r.位置;
        Else
          Exit;
        End If;
      End Loop;
    End If;
  End If;

  Delete From 病人医嘱打印
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 页号 >= 起始页号_In And
        To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= To_Number(v_位置);
        
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--81313:马政,2015-01-12,材料领用核查修正
Create Or Replace Procedure Zl_材料领用_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  No_In         In 药品收发记录.No%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  审核方式_In   In Number := 0
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  v_负成本计算 Zlparameters.参数值%Type;
  v_编码       收费项目目录.编码%Type;
  v_批准文号   药品库存.批准文号%Type;

  d_上次生产日期 药品库存.上次生产日期%Type;
  d_效期         药品库存.效期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;

  n_可用数量     药品库存.可用数量%Type;
  n_实际数量     药品库存.实际数量%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_小数         Number(2);
  v_上次扣率     药品库存.上次扣率%Type;
  n_数量差       药品收发记录.实际数量%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  n_平均成本价   药品库存.平均成本价%Type;
Begin
  Select Zl_Getsysparameter(120) Into v_负成本计算 From Dual;
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;

  --由于领用处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。

  Begin
    Select Nvl(可用数量, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_可用数量, n_实际数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  
  Exception
    When Others Then
      n_可用数量 := 0;
      n_实际数量 := 0;
      v_上次扣率 := 100;
      v_商品条码 := Null;
      v_内部条码 := Null;
  End;

  --取上次供应商ID
  Begin
    Select 供药单位id, 生产日期, 批准文号, 效期, 灭菌效期, 零售价
    Into n_上次供应商id, d_上次生产日期, v_批准文号, d_效期, d_灭菌效期, n_零售价
    From 药品收发记录
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 记录状态 = 1 And 序号 = 序号_In And Rownum = 1;
  
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_效期         := 效期_In;
  End;

  If 审核方式_In = 0 Then
    --出库审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率, 商品条码 = v_商品条码, 内部条码 = v_内部条码
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
  Elsif 审核方式_In = 1 Then
    --财务审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 配药人 = Nvl(审核人_In, 配药人), 配药日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
  End If;

  If 批次_In > 0 And (n_可用数量 + n_数量差) < 0 Then
    Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
    v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的分批核算材料' || Chr(10) || Chr(13) || '可用库存数量不够！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  If 审核方式_In = 0 Then
    --出库审核处理实际库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差, 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In,
        实际差价 = Nvl(实际差价, 0) - 差价_In,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null), 商品条码 = v_商品条码,
        内部条码 = v_内部条码
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率,
         商品条码, 内部条码, 平均成本价)
      Values
        (库房id_In, 材料id_In, 批次_In, 1, -实际数量_In, -实际数量_In, -零售金额_In, -差价_In, d_效期, d_灭菌效期, n_上次供应商id, 成本价_In, 批号_In,
         d_上次生产日期, 产地_In, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码,
         成本价_In);
    End If;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And Nvl(实际数量, 0) <> 0;
  
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 材料id_In;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 性质 = 1 And 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
    End If;
  
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  Elsif 审核方式_In = 1 Then
    --财务审核仅处理可用库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Verify;
/

--83869:刘尔旋,2015-04-08,医疗付款方式为空时挂号报错的问题
--66870:刘尔旋,2015-03-16,提前放号时间
--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
--81983:刘尔旋,2015-01-21,预约收款挂号没有扣减相应时段人数的问题
--81333:刘尔旋,2014-12-31,挂号费别的修改
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In     门诊费用记录.病人id%Type,
  门诊号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  付款方式_In   门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In       门诊费用记录.费别%Type,
  单据号_In     门诊费用记录.No%Type,
  票据号_In     门诊费用记录.实际票号%Type,
  序号_In       门诊费用记录.序号%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  数次_In       门诊费用记录.数次%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  结算方式_In   病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  医生姓名_In   挂号安排.医生姓名%Type,
  医生id_In     挂号安排.医生id%Type,
  病历费_In     Number, --该条记录是否病历工本费
  急诊_In       Number,
  号别_In       挂号安排.号码%Type,
  诊室_In       门诊费用记录.发药窗口%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  领用id_In     票据使用明细.领用id%Type,
  预交支付_In   病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In   病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In   病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In 门诊费用记录.保险大类id%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  摘要_In       门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In   Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In   Number := 0, --挂号是否使用收费票据
  保险编码_In   门诊费用记录.保险编码%Type,
  复诊_In       病人挂号记录.复诊%Type := 0,
  号序_In       挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In       病人挂号记录.社区%Type := Null,
  预约接收_In   Number := 0,
  预约方式_In   预约方式.名称%Type := Null,
  生成队列_In   Number := 0,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  结算卡序号_In 病人预交记录.结算卡序号%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null,
  操作类型_In   Number := 0,
  险类_In       病人挂号记录.险类%Type := Null,
  结算模式_In   Number := 0,
  记帐费用_In   Number := 0,
  退号重用_In   Number := 1
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);
  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
  End If;
  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In And
          (Nvl(预约挂号_In, 0) = 1 Or Nvl(预约接收_In, 0) = 1 Or
          Decode(To_Char(发生时间_In, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                  Null) In
          (Select 时间段
            From (Select 时间段,
                          To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(Nvl(提前时间, 开始时间), 'HH24:MI:SS'),
                                          '3000-01-10 ' || To_Char(Nvl(提前时间, 开始时间), 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                          To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                          '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                          To_Date('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                          To_Date('3000-01-10 ' || To_Char(Nvl(提前时间, 开始时间), 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                          To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                   From 时间段)
            Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间));
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  If Nvl(n_计划id, 0) = 0 Then
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
  Else
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), 现金支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
      
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         Null, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) > Sysdate;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--81246:刘尔旋,2014-12-31,移动接口处理费别
Create Or Replace Procedure Zl_Third_Getmoney
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:计算项目的实收金额
  --入参:Xml_In: 
  --  <IN> 
  --    <FB>费别</FB>                      //费别名称,可以不传
  --    <XMID>收费项目ID</XMID>        //收费项目的ID
  --    <CXFY>1</CXFY>                     //是否计算从项费用,-0不计算,1-计算，默认计算
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <JE>5</JE>                   //返回根据费别计算好的金额
  --                                     //如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_费别       费别.名称%Type;
  n_收费项目id 收费项目目录.Id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_标准单价   收费价目.现价%Type;
  v_收费类别   收费项目目录.类别%Type;
  v_收据费目   收入项目.收据费目%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_金额       Varchar2(200);
  n_从项费用   Number(3);
  n_不计算     Number(3);
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 
  v_Err_Msg    Varchar2(200);
  n_Exists     Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/CXFY')
  Into v_费别, n_收费项目id, n_从项费用
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_不计算 := 0;
  If v_费别 Is Null Then
    n_不计算 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;

  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费项目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Rownum < 2;

  If Nvl(n_屏蔽费别, 0) = 0 And n_不计算 = 0 Then
    v_金额     := Zl_Actualmoney(v_费别, n_收费项目id, n_收入项目id, n_标准单价);
    v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
    n_实收金额 := Zl_To_Number(v_金额);
  Else
    n_实收金额 := n_标准单价;
  End If;

  If Nvl(n_从项费用, 1) = 1 Then
    For r_Subfee In (Select b.现价, a.从项数次, b.收入项目id, c.屏蔽费别, a.从项id As 收费细目id
                     From 收费从属项目 A, 收费价目 B, 收费项目目录 C
                     Where a.主项id = n_收费项目id And c.Id = a.从项id And a.从项id = b.Id And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      If Nvl(r_Subfee.屏蔽费别, 0) = 0 And n_不计算 = 0 Then
        v_金额     := Zl_Actualmoney(v_费别, r_Subfee.收费细目id, r_Subfee.收入项目id, r_Subfee.现价);
        v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
        n_实收金额 := n_实收金额 + Zl_To_Number(v_金额) * r_Subfee.从项数次;
      Else
        n_实收金额 := n_实收金额 + r_Subfee.现价 * r_Subfee.从项数次;
      End If;
    End Loop;
  End If;

  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getmoney;
/

--82936:刘兴洪,2015-03-13,获取医嘱费用时包含附加费用及医保补结算问题
--83017:刘尔旋,2015-03-10,检验执行科室更改
--82584:刘兴洪,2015-02-09,增中:是否发药,标准单价,应收金额,实收金额节点
--81724:刘兴洪,2015-01-13,增加是否发药节点
--81323:刘兴洪,2014-12-31,医保补充结算,移动平台接口就诊详情退款金额统计错误
Create Or Replace Procedure Zl_Third_Getvisitinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:根据挂号单号获取该次就诊详情(医嘱为主要显示)
  --入参:Xml_In:
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --    <JSKLB>结算卡类别</JSKLB>
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <GH>
  --     <YYSJ>预约时间</YYSJ> //yyyy-mm-dd hh24:mi:ss
  --     <JZSJ></JZSJ>      //实际就诊时间
  --     <DJH></DJH>        //单据号
  --     <JE></JE>          //金额
  --     <DJLX></DJLX>      //单据类型,1-收费单，4-挂号单
  --     <KDSJ></KDSJ>      //开单时间
  --     <ZFZT></ZFZT>  //支付状态,0-待支付，1-已支付，2-已退费
  --     <SFJSK></SFJSK>    //是否结算卡支付，0-否，1-是
  --  </GH>
  --  <YZLIST>
  --     <YZ>                   //医嘱返回与HIS中显示的内容相同
  --        <YZID><YZID>        //医嘱ID，返回组医嘱ID
  --        <YZLX><YZLX>        //医嘱类型,如处方、检查、检验
  --         <YZMC></YZMC>        //医嘱名称
  --        <ZXKS></ZXKS>       //执行科室
  --        <ZXKSID></ZXKSID>   //执行科室ID
  --        <YZMX>
  --           <MX>
  --              <YZNR></YZNR>        //医嘱内容
  --              <ZXZT></ZXZT>        //医嘱执行状态
  --              <SFFY>是否发药</SFFY> // 0-否 ，1-是
  --              <GG>规格</GG>
  --              <SL>数量</SL>
  --              <DW>计算单位</DW>
  --              <BZDJ>标准单价</BZDJ>
  --              <YSJE>应收金额</YSJE>
  --              <SSJE>实收金额</SSJE>
  --           </MX>
  --           <MX/>
  --        </YZMX>
  --        <BG></BG>                   //是否已出报告，是否签名
  --        <BLID></BLID>              //病历ID，如果<BG>字段为1，该值不为空
  --        <DJLIST>
  --           <DJ>                //费用单据信息
  --              <DJH></DJH>      //费用单据号
  --              <DJLX></DJLX>    //单据类型
  --              <JE></JE>        //单据总金额
  --              <KDSJ></KDSJ>    //开单时间
  --              <ZFZT></ZFZT>    //支付状态,0-待支付，1-已支付，2-已退费
  --              <SFJSK></SFJSK>  //是否结算卡支付，0-否，1-是
  --           </DJ>
  --           <DJ/>
  --        </DJLIST>
  --     </YZ>
  --  </YZLIST>
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);
  v_队列名称 排队叫号队列.队列名称%Type;

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  n_Add_Djlist Number(1); --是否增加了DJLIST的
  n_性质       Number(2);
  n_组医嘱id   Number(18);
  n_独立医嘱   Number(8);
  n_执行科室id Number(18);
  v_执行科室   Varchar2(50);
  n_退款金额   病人预交记录.冲预交%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB')
  Into v_挂号单, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  n_性质 := 4;
  --1.获取挂号数据
  Begin
    Select Replace(摘要, '划价:', '') Into v_No From 病人挂号记录 Where NO = v_挂号单;
  Exception
    When Others Then
      v_No := Null;
  End;

  If v_No Is Not Null Then
    Select Count(*) Into n_Count From 门诊费用记录 Where NO = v_No And 记录性质 = 1;
    If n_Count <> 0 Then
      n_性质 := 1;
    End If;
  End If;
  If n_性质 = 4 Then
    v_No := v_挂号单;
  End If;

  n_Count := 0;
  For c_挂号 In (Select a.Id, v_No As NO, n_性质 As 记录性质, a.执行部门id, c.名称 As 执行部门,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, To_Char(a.预约时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi:ss') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志, b.结帐id As 结帐id
               From 病人挂号记录 A,
                    (Select Max(Decode(记录状态, 0, 0, 2, 0, Nvl(结帐id, 0))) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = n_性质 And NO = v_No) B, 部门表 C
               Where a.No = v_挂号单 And a.执行部门id = c.Id(+)) Loop
  
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
  
    Begin
      Select 排队号码, 队列名称
      Into v_排队号码, v_队列名称
      From 排队叫号队列
      Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码, v_队列名称);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where 结帐id = c_挂号.结帐id And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    v_Temp := '<DJH>' || c_挂号.No || '</DJH>';
    v_Temp := v_Temp || '<YYSJ>' || c_挂号.预约时间 || '</YYSJ>';
    v_Temp := v_Temp || '<JZSJ>' || c_挂号.就诊时间 || '</JZSJ>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<JE>' || c_挂号.金额 || '</JE>';
    v_Temp := v_Temp || '<DJLX>' || n_性质 || '</DJLX>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
    v_Temp := '<GH>' || v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;

  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.组建医嘱及费用相关数据
  n_组医嘱id := 0;

  For c_医嘱 In (With 医嘱费用 As
                  (Select 医嘱id, 发送号, 记录性质, NO, Max(Nvl(执行状态, 0)) As 执行状态
                  From (Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(b.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+)
                         Union All
                         Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(c.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱附费 B, 病人医嘱发送 C
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+) And b.医嘱id = c.医嘱id(+) And b.发送号 = c.发送号(+))
                  Group By 医嘱id, 发送号, 记录性质, NO)
                 
                 Select Nvl(a.相关id, a.Id) As 组id, Decode(a.相关id, Null, 0, 1) As 附医嘱, a.Id, a.相关id,
                        Max(Decode(a.诊疗类别, 'E', Decode(q.操作类型, '2', '处方', '4', '处方', '6', '检验', m.名称), m.名称)) As 医嘱类型,
                        a.执行科室id, d.名称 As 执行科室, Decode(a.相关id, Null, a.医嘱内容, Null) As 组医嘱内容,
                        Max(Decode(a.诊疗类别, '5', 1, '6', 1, '7', 1, 0) * Decode(Nvl(e.执行状态, 0), 1, 1, 3, 1, 0)) As 发药状态,
                        Decode(a.相关id, Null, Null, q.名称) As 明细医嘱内容, s.规格, (e.数次 * e.付数) As 数量, e.计算单位 As 单位,
                        Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行') As 执行状态,
                        Decode(p.审核时间, Null, Decode(C1.完成时间, Null, 0, 1), 1) As 是否已出报告, c.病历id, e.No, e.记录性质 As 单据类型,
                        Max(e.标准单价) As 标准单价, Sum(e.应收金额) As 应收金额, Sum(e.实收金额) As 实收金额,
                        To_Char(e.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1) As 支付状态

                 
                 From 病人医嘱记录 A, 医嘱费用 B, 病人医嘱报告 C, 电子病历记录 C1, 部门表 D, 门诊费用记录 E, 诊疗项目类别 M, 诊疗项目目录 Q, 收费项目目录 S, 检验标本记录 P
                 Where a.Id = b.医嘱id(+) And a.执行科室id = d.Id(+) And c.病历id = C1.Id(+) And a.Id = c.医嘱id(+) And
                       a.Id = p.医嘱id(+) And b.医嘱id = e.医嘱序号(+) And e.收费细目id = s.Id(+) And b.No = e.No(+) And
                       b.记录性质 = e.记录性质(+) And e.记录状态(+) <> 2 And a.挂号单 = v_挂号单 And a.诊疗类别 = m.编码(+) And
                       a.诊疗项目id = q.Id(+) And a.医嘱状态 In (3, 8)
                 Group By a.Id, a.婴儿, a.序号, a.相关id, a.诊疗类别, a.执行科室id, d.名称, a.医嘱内容, q.名称, s.规格, e.数次 * e.付数, e.计算单位,
                          Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行'), C1.完成时间,
                          Decode(c.病历id, Null, 0, 1), c.病历id, e.No, e.记录性质, e.发生时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1),
                          p.审核时间
                 Order By 组id, 附医嘱, Nvl(a.婴儿, 0), a.序号) Loop
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZLIST></YZLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
  
    If n_组医嘱id <> Nvl(c_医嘱.组id, 0) Then
      n_组医嘱id := Nvl(c_医嘱.组id, 0);
    
      If c_医嘱.医嘱类型 = '检验' Then
        --检验医嘱以显示采集科室
        n_执行科室id := c_医嘱.执行科室id;
        v_执行科室   := c_医嘱.执行科室;
      Else
        Begin
          Select b.Id, b.名称
          Into n_执行科室id, v_执行科室
          From 病人医嘱记录 A, 部门表 B
          Where a.相关id = n_组医嘱id And a.执行科室id = b.Id And Rownum <= 1;
        Exception
          When Others Then
            n_执行科室id := c_医嘱.执行科室id;
            v_执行科室   := c_医嘱.执行科室;
        End;
      End If;
    
      v_Temp := '<YZID>' || n_组医嘱id || '</YZID>';
      v_Temp := v_Temp || '<YZLX>' || c_医嘱.医嘱类型 || '</YZLX>';
      v_Temp := v_Temp || '<YZMC>' || c_医嘱.组医嘱内容 || '</YZMC>';
      v_Temp := v_Temp || '<ZXKS>' || v_执行科室 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || n_执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<BG>' || c_医嘱.是否已出报告 || '</BG>';
      If Nvl(c_医嘱.是否已出报告, 0) = 1 And c_医嘱.病历id Is Not Null Then
        v_Temp := v_Temp || '<BLID>' || c_医嘱.病历id || '</BLID>';
      End If;
      v_Temp := '<YZ 医嘱ID="' || n_组医嘱id || '">' || v_Temp || '<YZMX></YZMX><DJLIST></DJLIST></YZ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    
      For v_费用 In (
                   
                   Select a.No, Mod(a.记录性质, 10) As 单据类型, To_Char(a.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间,
                           Max(Decode(Nvl(a.记录状态, 0), 0, 0, 3, 2, 1)) As 支付状态, Sum(a.实收金额) As 单据金额, Max(a.结帐id) As 结算卡支付
                   From 门诊费用记录 A
                   Where (a.No, a.记录性质) In
                         (Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱发送 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)
                          Union All
                          Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱附费 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)) And
                         Nvl(a.记录状态, 0) In (0, 1, 3)
                   Group By a.No, Mod(a.记录性质, 10), To_Char(a.发生时间, 'yyyy-mm-dd hh24:mi:ss')) Loop
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
        Begin
          Select -1 * Sum(结帐金额)
          Into n_退款金额
          From 门诊费用记录 B
          Where b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 = 2;
        Exception
          When Others Then
            n_退款金额 := 0;
        End;
      
        v_Temp := '<DJH>' || v_费用.No || '</DJH>';
        v_Temp := v_Temp || '<DJLX>' || v_费用.单据类型 || '</DJLX>';
        v_Temp := v_Temp || '<JE>' || v_费用.单据金额 || '</JE>';
        v_Temp := v_Temp || '<KDSJ>' || v_费用.开单时间 || '</KDSJ>';
        v_Temp := v_Temp || '<ZFZT>' || v_费用.支付状态 || '</ZFZT>';
        v_Temp := v_Temp || '<YTJE>' || Nvl(n_退款金额, 0) || '</YTJE>';
        v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
        v_Temp := '<DJ>' || v_Temp || '</DJ>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/DJLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End Loop;
    End If;
  
    --只有一条记录的医嘱，在明细中增加该条医嘱，以获取执行状态
    Select Decode(Count(*), 0, 1, 0) Into n_独立医嘱 From 病人医嘱记录 Where 相关id = n_组医嘱id;
    If n_独立医嘱 = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.组医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
    If Nvl(c_医嘱.附医嘱, 0) = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.明细医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
  End Loop;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitinfo;
/

--83258:刘尔旋,2015-04-01,分时段序号控制加号发生时间的问题
--82862:刘尔旋,2015-03-02,移动挂未来号采用预约方式
--82380:刘尔旋,2015-02-03,合作单位分时段非序号控制挂号报错的问题
--81983:刘尔旋,2015-01-21,预约收款挂号不扣减人数的问题
--81246:刘尔旋,2014-12-31,移动接口新增费别处理
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号目前仅支持一个，结构与收费一致，以后可扩展
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码       挂号安排.号码%Type;
  d_发生时间   Date;
  d_原始时间   Date;
  d_登记时间   Date;
  v_金额       Varchar2(200);
  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  n_分时段     Number(3);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名
  
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Extractvalue(b.Column_Value, '/JS/JSKLB'), Extractvalue(b.Column_Value, '/JS/JSKH'),
         Extractvalue(b.Column_Value, '/JS/JSFS'), Extractvalue(b.Column_Value, '/JS/JYLSH'),
         Extractvalue(b.Column_Value, '/JS/JYSM')
  Into v_卡类别名称, v_结算卡号, v_结算方式, v_流水号, v_说明
  From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;
  Begin
    Select b.结算方式, b.Id Into v_结算方式, n_卡类别id From 医疗卡类别 B Where b.名称 = v_卡类别名称 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现该结算卡的相关信息';
      Raise Err_Item;
  End;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;
  Select Decode(To_Char(d_发生时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  Begin
    Select ID
    Into n_计划id
    From (Select ID
           From 挂号安排计划
           Where 号码 = v_号码 And d_发生时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                 Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
           Order By 生效时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
  End;
  If Nvl(n_计划id, 0) <> 0 Then
    --从计划读取信息
    Select a.项目id, b.科室id, a.医生姓名, a.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                   Null), Nvl(a.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = n_计划id And b.Id = a.安排id;
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号计划时段
      Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号计划时段
            Where 计划id = n_计划id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  Else
    --从安排读取信息
    Select b.项目id, b.科室id, b.医生姓名, b.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                   Null), Nvl(b.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排 B
    Where b.Id = n_安排id;
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号安排时段
            Where 安排id = n_安排id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  End If;
  
  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费细目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Rownum < 2;

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;

  If Trunc(d_发生时间) <> Trunc(Sysdate) Then
    Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null, v_流水号,
                     v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名);
  Else
    Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null, v_流水号,
                     v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名);
  End If;

  For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                        Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
    Insert Into 三方结算交易 (交易id, 交易项目, 交易内容) Values (n_预交id, c_扩展信息.交易名称, c_扩展信息.交易内容);
  End Loop;

  v_Temp := '<GHDH>' || v_No || '</GHDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/


--81907:冉俊明,2015-02-12,部分退费重打票据时使用了新票据但未回收旧票据。
--81310:刘尔旋,2014-12-30,补充结算医保接口重打票据报错的问题
Create Or Replace Procedure Zl_补充结算票据_Reprint
(
  No_In         门诊费用记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  领用id_In     票据使用明细.领用id%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  退费_In       Number := 0,
  票据张数_In   Number := 0,
  收回票据号_In Varchar2 := Null
) As
  --功能：用于重打收费票据 
  --参数： 
  --      NO_IN         =   要重打的单据号，可能是一起收费的多张单据中的一张。 
  --      票据号        =   用于重打的起始票据号.而该张收费单据可能使用多张票据。 
  --      领用ID        =   如果为0或NULL,表示不严格控制票据。 
  --      退费_IN       =   是否部份退费时调用该过程 
  --      收回票据号_In =   部分退费时,界面选择要收回的票据号,这些票据只收回,不重新发出,传入空表示全部收回并重打 
  --该游标用于范围判断 
  Cursor c_Fact Is
    Select 开始号码, 终止号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;
  v_票据号 票据使用明细.号码%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --获取该张单据的最后一次的的打印ID(可能没有) 
  Begin
    Select ID
      Into v_收回id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --收回票据(可能以前未控制票据,无法收回) 
  If v_收回id Is Not Null Then
    If 收回票据号_In Is Null Then
      If Nvl(退费_In, 0) = 0 Then
        --a.重打 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Else
        --b.部分退费重打先收回 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 票种 = 1 And 性质 = 2);
      End If;
    Else
      --c.部分退费收回指定的票据号 
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Instr(收回票据号_In, 号码) > 0;
      Return;
    End If;
  End If;

  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据并填写票据打印内容 
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  Insert Into 票据打印内容
    (ID, 数据性质, NO)
    Select Distinct v_打印id, 1, NO
    From (Select NO
           From 票据打印内容
           Where ID = v_收回id And 数据性质 = 1
           Union All
           Select No_In From Dual);

  --门诊费用记录中记录票据号以便显示 
  Update 费用补充记录
  Set 实际票号 = 票据号_In
  Where 记录性质 = 1 And NO In (Select NO
                            From 票据打印内容
                            Where ID = v_收回id And 数据性质 = 1
                            Union
                            Select No_In From Dual);

  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次,无法完成重打操作！';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    If Nvl(领用id_In, 0) <> 0 Then
      --检查票据范围 
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据:重打时,如果是部份退费重打,则处理为新发生；如果以前没有收回，也处理为新发出。 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 1, v_票据号, 1, Decode(Nvl(退费_In, 0), 0, Decode(v_收回id, Null, 1, 3), 1), 领用id_In, v_打印id, 使用人_In,
       使用时间_In);
  
    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);
  
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;
  Update 票据领用记录 Set 使用时间 = 使用时间_In Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_补充结算票据_Reprint;
/

--83869:刘尔旋,2015-04-08,医疗付款方式为空时挂号保存报错的问题
--83258:刘尔旋,2015-03-27,服务窗支持失效号挂号
--82936:刘尔旋,2015-03-09,未设置合作单位预约问题
--82934:冉俊明,2015-03-06,病人预交记录增加“结算性质”字段。
--82592:冉俊明,2015-02-09,收费财务监控模块性能问题调整预交款数据处理规则
--82380:刘尔旋,2015-02-02,HIS过程添加动态调用生成推送信息
--81246:刘尔旋,2014-12-31,移动接口新增费别处理
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In     Integer,
  病人id_In       门诊费用记录.病人id%Type,
  号码_In         挂号安排.号码%Type,
  号序_In         挂号序号状态.序号%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  合作单位_In     挂号合作单位.名称%Type,
  挂号金额合计_In 门诊费用记录.实收金额%Type,
  领用id_In       票据使用明细.领用id%Type,
  收费票据_In     Number := 0, --挂号是否使用收费票据
  交易流水号_In   病人预交记录.交易流水号%Type,
  交易说明_In     病人预交记录.交易说明%Type,
  预约方式_In     预约方式.名称%Type := Null,
  预交id_In       病人预交记录.Id%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  加入序号状态_In Number := 0,
  是否自助设备_In Number := 0,
  结帐id_In       门诊费用记录.结帐id%Type := Null,
  锁定类型_In     Number := 0,
  保险结算_In     Varchar2 := Null,
  冲预交_In       Number := Null,
  支付卡号_In     病人预交记录.卡号%Type := Null,
  退号重用_In     Number := 1,
  费别_In         门诊费用记录.费别%Type := Null,
  机器名_In       挂号序号状态.机器名%Type := Null
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制 Number(18);
  n_是否开放     Number(1);
  n_Count        Number(18);
  n_行号         Number(18);
  n_序号         病人挂号记录.号序%Type;
  n_费用id       门诊费用记录.Id%Type;
  n_价格父号     Number(18);
  n_原项目id     收费项目目录.Id%Type;
  n_原收入项目id 收费项目目录.Id%Type;
  v_诊室         病人挂号记录.诊室%Type;
  n_安排id       挂号安排.Id%Type;
  n_实收金额合计 门诊费用记录.实收金额%Type;
  n_开单部门id   门诊费用记录.开单部门id%Type;
  n_实收金额     门诊费用记录.实收金额%Type;
  n_应收金额     门诊费用记录.实收金额%Type;
  n_结帐id       病人结帐记录.Id%Type;
  v_Temp         Varchar2(500);
  n_预约时段序号 Number;
  n_预约总数     Number;
  d_时段开始时间 Date;
  n_预约数量     合作单位挂号汇总.已约数%Type;
  n_号序         病人挂号记录.号序%Type;
  d_登记时间     Date;
  v_操作员编号   人员表.编号%Type;
  v_操作员姓名   人员表.姓名%Type;
  n_预约         Integer;
  v_星期         挂号安排时段.星期%Type;
  n_启用分时段   Integer;
  n_已挂数       病人挂号汇总.已挂数%Type;
  n_已约数       病人挂号汇总.已约数%Type;
  n_其中已接收   病人挂号汇总.已约数%Type;
  n_预约生成队列 Number;
  d_Date         Date;
  n_挂号序号     Number;
  v_排队标记     排队叫号队列.排队标记%Type;
  v_排队序号     排队叫号队列.排队序号%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_序号操作员   挂号序号状态.操作员姓名%Type;
  v_序号机器名   挂号序号状态.机器名%Type;
  n_序号锁定     Number := 0;
  v_付款方式     病人挂号记录.医疗付款方式%Type;
  v_费别         门诊费用记录.费别%Type;
  n_屏蔽费别     Number(3) := 0;
  n_Tmp安排id    挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(n_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = n_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, c.项目id, c.医生id, c.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

Begin
  If 费别_In Is Null Then
    n_屏蔽费别 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  Else
    v_费别 := 费别_In;
  End If;
  Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  --获取当前机器名称
  If 机器名_In Is Not Null Then
    v_机器名 := 机器名_In;
  Else
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  n_实收金额合计 := 0;
  Select Count(*) + 1
  Into n_挂号序号
  From 病人挂号记录
  Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  --Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Item;
  End If;

  If 登记时间_In Is Null Then
    d_登记时间 := Sysdate;
  Else
    d_登记时间 := 登记时间_In;
  End If;
  If Trunc(Sysdate) > Trunc(发生时间_In) Then
    v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
    Raise Err_Item;
  End If;
  n_同科限约一个号 := Nvl(zl_GetSysParameter('病人同科限约一个号', 1111), 0);
  n_病人预约科室数 := Nvl(zl_GetSysParameter('病人预约科室数', 1111), 0);
  n_开单部门id     := To_Number(Zl_操作员(0, v_Temp));
  v_操作员编号     := Zl_操作员(1, v_Temp);
  v_操作员姓名     := Zl_操作员(2, v_Temp);
  n_组id           := Zl_Get组id(v_操作员姓名);

  If 操作方式_In <> 1 Then
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
            Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
      Order By 生效时间 Desc;
    Exception
      When Others Then
        Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Select Count(0)
      Into n_合作单位限制
      From 合作单位计划控制
      Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
    Else
      Select Count(0)
      Into n_合作单位限制
      From 合作单位安排控制
      Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
    End If;
  End If;

  If 操作方式_In <> 2 Then
    v_诊室 := Zl_诊室(号码_In);
  End If;
  If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
    --检查结算方式是否完备
    Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
    If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
      Select Count(1)
      Into n_Count
      From 医疗卡类别
      Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
    End If;
    If n_Count = 0 Then
      v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
      Raise Err_Item;
    End If;
  End If;

  --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
  Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
  If n_Count <> 0 Then
    v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
    Raise Err_Item;
  End If;

  Open c_Pati(病人id_In);
  n_Count := 0;
  Begin
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '病人未找到，不能继续。';
    Raise Err_Item;
  End If;

  Open c_安排(号码_In, 发生时间_In);
  Begin
    Fetch c_安排
      Into r_安排;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
    Raise Err_Item;
  End If;

  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', '周日')
  Into v_星期
  From Dual;
  Begin
    Select 1 Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --对参数控制进行检查
  --仅在预约不扣款时进行检查
  If 操作方式_In = 2 Then
    If Nvl(n_同科限约一个号, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Count(1) As 已约, a.执行部门id As 科室id, Nvl(k.名称, '') As 科室
                        From 病人挂号记录 A, 病人信息 B, 部门表 K
                        Where a.病人id = b.病人id And a.病人id = 病人id_In And a.执行部门id = k.Id(+) And a.记录性质 = 2 And 记录状态 = 1 And
                              a.预约时间 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60
                        Group By a.执行部门id, k.名称) Loop
        If Nvl(n_同科限约一个号, 0) <> 0 And c_Chkitem.科室id = r_安排.科室id Then
        
          v_Err_Msg := '该病人已经在科室[' || c_Chkitem.科室 || ']进行了预约,不能再预约！';
          Raise Err_Item;
        
          If Nvl(n_病人预约科室数, 0) > 0 And c_Chkitem.科室id <> r_安排.科室id Then
            n_已约科室 := n_已约科室 + 1;
          End If;
        End If;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Err_Msg := '同一病人在最多同时预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  d_Date         := Null;
  d_时段开始时间 := Null;

  If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
  
    Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
    Into n_已挂数, n_其中已接收, n_已约数
    From 挂号安排 A, 病人挂号汇总 B
    Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
          Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
          Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
  
    If n_启用分时段 = 1 Then
      If Nvl(r_安排.序号控制, 0) = 1 Then
        If Nvl(是否自助设备_In, 0) = 0 Then
          Select Count(*), Max(开始时间)
          Into n_Count, d_时段开始时间
          From 挂号安排时段
          Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
          v_Temp := '挂号';
          If 操作方式_In > 1 Then
            v_Temp := '预约挂号';
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
            Raise Err_Item;
          End If;
        End If;
        --过点的,不能选择挂号
        If Trunc(Sysdate) = Trunc(发生时间_In) Then
          --挂当天的号
          v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
          For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                       To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                       From 挂号安排时段
                       Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
            If Sysdate > v_时段.结束时间 Then
              v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End Loop;
        End If;
      Elsif 操作方式_In > 1 Then
        --未启用序号的,需要检查预约的情况
      
        n_Count := 0;
        For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                     From 挂号安排时段
                     Where 安排id = r_安排.Id And 星期 = v_星期 And
                           (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                           '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                    '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
          n_预约时段序号 := v_时段.序号;
          d_时段开始时间 := v_时段.开始时间;
        
          Select Count(*), Max(序号)
          Into n_Count, n_预约总数
          From 挂号序号状态
          Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
        
          If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                         To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
            Raise Err_Item;
          End If;
          n_Count := 1;
        End Loop;
      
        If n_Count = 0 Then
          v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                       '),不能进行预约挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作方式_In = 1 And 锁定类型_In <> 2 Then
    --挂号规则:
    --  已挂数不能大于限号数
    If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
      v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
      Raise Err_Item;
    End If;
  End If;

  If 操作方式_In > 1 Then
    --预约的相关检查
    --规则:
    --   1.已限约不能超过限约数
    --   2.检查是否启用时段的
    If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
      v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
      Raise Err_Item;
    End If;
  End If;
  If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
  
    If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
      v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
      Raise Err_Item;
    End If; --Nvl(r_安排.序号控制, 0) =0
  
    n_序号 := Case
              When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
               Nvl(号序_In, 0)
              Else
               0
            End;
  
    --开放序号检查
    For c_合作单位 In (Select c.序号, 数量
                   From 挂号安排 A, 合作单位安排控制 C
                   Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                         c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                    (Select 1
                          From 挂号安排计划 D
                          Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                   Union All
                   Select c.序号, 数量
                   From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                        (Select Max(a.生效时间) As 生效, 安排id
                          From 挂号安排计划 A, 挂号安排 B
                          Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                          Group By 安排id) E
                   Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                         Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                         Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                         发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
    
      If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 Then
        n_是否开放 := 1;
        Exit;
      Elsif Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号 Then
        Begin
          Select Nvl(已约数, 0)
          Into n_预约数量
          From 合作单位挂号汇总
          Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
        Exception
          When Others Then
            n_预约数量 := 0;
        End;
        If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
          v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
          Raise Err_Item;
        End If;
        n_是否开放 := 1;
        Exit;
      End If;
    
    End Loop;
  
    If Nvl(n_是否开放, 0) = 0 Then
      v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
      Raise Err_Item;
    End If;
  End If;

  --检查限号数和限约数
  n_行号         := 1;
  n_原项目id     := 0;
  n_原收入项目id := 0;
  n_实收金额合计 := 0;
  If 锁定类型_In <> 1 Then
    If 操作方式_In <> 2 Then
      If Nvl(结帐id_In, 0) = 0 Then
        --这里应该程序传入
        Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
      Else
        n_结帐id := 结帐id_In;
      End If;
    Else
      n_结帐id := Null;
    End If;
  End If;
  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = r_安排.项目id And
                       Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_价格父号 := Null;
    If n_原项目id = c_Item.项目id Then
      If n_原收入项目id <> c_Item.收入项目id Then
        n_价格父号 := n_行号;
      End If;
      n_原收入项目id := c_Item.收入项目id;
    End If;
    n_原项目id := c_Item.项目id;
    n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
    n_实收金额 := n_应收金额;
    If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
      --打折:
      v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    End If;
    n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
  
    --锁定单据不产生费用
    If 锁定类型_In <> 1 Then
      --产生病人挂号费用(可能单独是或包括病历费用)
      Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
      --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      Insert Into 门诊费用记录
        (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
         收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
         操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
      Values
        (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
         Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
         r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
         n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
         Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
         摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
    End If;
    n_行号 := n_行号 + 1;
  
  End Loop;

  If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
    v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
    Raise Err_Item;
  End If;

  If n_启用分时段 = 1 Then
    d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
  Else
    d_Date := Trunc(发生时间_In);
  End If;

  --更新挂号序号状态
  If 锁定类型_In <> 2 Then
    n_号序 := 号序_In;
  End If;
  If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
    If 退号重用_In = 1 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
    End If;
  End If;
  If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
  
    If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
      --规则:预约时段序号||预约数
      If Nvl(n_预约总数, 0) = 0 Then
        v_Temp := Nvl(r_安排.限约数, 0);
        v_Temp := LTrim(RTrim(v_Temp));
        v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
        v_Temp := n_预约时段序号 || v_Temp;
        n_号序 := To_Number(v_Temp);
      Else
        n_号序 := n_预约总数 + 1;
      End If;
    End If;
  End If;

  If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
      n_序号锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_序号锁定   := 0;
    End;
    If n_序号锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
      Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
          Values
            (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
        
          If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
            Update 合作单位挂号汇总
            Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
            Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
            If Sql%NotFound Then
              Insert Into 合作单位挂号汇总
                (号码, 日期, 序号, 合作单位, 已约数, 已接数)
              Values
                (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --锁定单据不产生任何 费用
  If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
    --挂号,预约挂号已经扣款部分
    n_预交id := 预交id_In;
    If Nvl(n_预交id, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    n_结算合计 := 0;
    If 保险结算_In Is Not Null Then
      --各个保险结算
      v_结算内容 := 保险结算_In || '||';
      n_结算合计 := 0;
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
          Values
            (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额,
             n_结帐id, n_组id, n_结帐id, 4);
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        End If;
        n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    If Nvl(冲预交_In, 0) <> 0 Then
      --处理总预交
      n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
      n_预交金额 := 冲预交_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_结算金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 <= n_结算金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      End If;
    End If;
    --剩余款项,用指定结算方支付
    n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
    If Nvl(n_结算金额, 0) < 0 Then
      v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
      Raise Err_Item;
    End If;
    If Nvl(n_结算金额, 0) <> 0 Then
      If 结算方式_In Is Null Then
        v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(预交id_In, 0) <> 0 Then
        --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
        Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
        n_预交id := Nvl(预交id_In, 0);
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, n_结算金额, d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id, 合作单位_In || '缴款', n_组id,
         交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
    End If;
  
    --更新人员缴款数据
  
    For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                 Group By 结算方式) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
      Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
        n_返回值 := Nvl(v_缴款.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    
    End Loop;
  
  End If;

  --处理挂号记录
  If 锁定类型_In = 2 Then
    Begin
      Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    Exception
      When Others Then
        Null;
    End;
  Else
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  End If;

  Update 病人挂号记录
  Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
      操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1), 接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
      接收时间 = Case 锁定类型_In
                When 1 Then
                 Null
                Else
                 Case 操作方式_In
                   When 2 Then
                    Null
                   Else
                    d_登记时间
                 End
              End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位)
  Where ID = n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
       r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
       Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
       Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In, v_付款方式);
  End If;
  --锁定单据不能产生队列
  If 锁定类型_In <> 1 Then
    n_预约生成队列 := 0;
    If 操作方式_In > 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
    --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
    If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
      If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
        --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站      
        If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
          --产生队列
          --.按”执行部门” 的方式生成队列
          v_队列名称 := r_安排.科室id;
          v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          v_排队标记 := Substr(v_排队号码, 1, 1);
          v_排队号码 := Substr(v_排队号码, 2);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)  
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
          --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, v_排队标记, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                           d_排队时间, 预约方式_In, n_启用分时段, v_排队序号);
        End If;
      End If;
    End If;
  
    If Nvl(操作方式_In, 0) = 1 Then
      --处理票据使用情况
      If 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --病人本次就诊(以发生时间为准)
      If Nvl(r_Pati.病人id, 0) <> 0 Then
        Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
      End If;
    End If;
  End If;
  --病人挂号汇总
  --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
  If 锁定类型_In <> 2 Then
    --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
    n_预约 := Case
              When Nvl(操作方式_In, 0) = 1 Then
               0
              When Nvl(操作方式_In, 0) = 2 Then
               1
              When Nvl(操作方式_In, 0) = 3 Then
               3
              Else
               0
            End;
    Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
  End If;
  --挂号后产生导引
  Begin
    Execute Immediate 'Begin ZL_Third_AFTERREGIST(:1); End;'
      Using n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--83258:刘尔旋,2015-04-07,临时计划不能获取排班的问题
--83017:刘尔旋,2015-03-16,获取排班新增科室处理
--82906:刘尔旋,2015-03-03,获取排班的性能问题
--82862:刘尔旋,2015-03-02,移动挂未来号使用预约方式
--81234:刘尔旋,2014-12-29,移动挂号接口调整
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;
  If Nvl(n_科室id, 0) = 0 Then
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      n_安排存在 := 0;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数

                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生id = n_医生id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        v_上班时间 := v_上班时间 || '+' || r_排班.排班;
        n_总已挂数 := n_总已挂数 + r_排班.已挂数;
        n_已挂数   := r_排班.已挂数;
        n_限号数   := r_排班.限号数;
        n_已约数   := r_排班.已约数;
        n_限约数   := r_排班.限约数;
        n_安排id   := Nvl(r_排班.安排id, 0);
        n_计划id   := Nvl(r_排班.计划id, 0);
        v_号码     := r_排班.号码;
        n_安排存在 := 1;
        If v_上班时间 Is Not Null Then
          If v_合作单位 Is Not Null Then
            If n_计划id <> 0 Then
              Begin
                Select 1
                Into n_合约存在
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约存在 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_合约存在
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约存在 := 0;
              End;
            End If;
          End If;
        
          If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
            If n_计划id <> 0 Then
              Begin
                Select Sum(数量)
                Into n_合作单位数量
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null);
              Exception
                When Others Then
                  n_合作单位数量 := 0;
              End;
            Else
              Begin
                Select Sum(数量)
                Into n_合作单位数量
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null);
              Exception
                When Others Then
                  n_合作单位数量 := 0;
              End;
            End If;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                    Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
              n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
            Else
              n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
            End If;
          Else
            --合约单位
            If n_计划id <> 0 Then
              Begin
                Select 1
                Into n_禁用
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_禁用
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            End If;
            If Nvl(n_禁用, 0) = 0 Then
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
            
            End If;
          End If;
        End If;
        n_合作单位数量 := 0;
        n_合约存在     := 0;
        n_禁用         := 0;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  Else
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      n_安排存在 := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数

                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生id = n_医生id And
                                       Ap.科室id = n_科室id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        v_上班时间 := v_上班时间 || '+' || r_排班.排班;
        n_总已挂数 := n_总已挂数 + r_排班.已挂数;
        n_已挂数   := r_排班.已挂数;
        n_限号数   := r_排班.限号数;
        n_已约数   := r_排班.已约数;
        n_限约数   := r_排班.限约数;
        n_安排id   := Nvl(r_排班.安排id, 0);
        n_计划id   := Nvl(r_排班.计划id, 0);
        v_号码     := r_排班.号码;
        n_安排存在 := 1;
      
        If v_上班时间 Is Not Null Then
          If v_合作单位 Is Not Null Then
            If n_计划id <> 0 Then
              Begin
                Select 1
                Into n_合约存在
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约存在 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_合约存在
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约存在 := 0;
              End;
            End If;
          End If;
        
          If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
            If n_计划id <> 0 Then
              Begin
                Select Sum(数量)
                Into n_合作单位数量
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null);
              Exception
                When Others Then
                  n_合作单位数量 := 0;
              End;
            Else
              Begin
                Select Sum(数量)
                Into n_合作单位数量
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null);
              Exception
                When Others Then
                  n_合作单位数量 := 0;
              End;
            End If;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                    Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
              n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
            Else
              n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
            End If;
          Else
            --合约单位
            If n_计划id <> 0 Then
              Begin
                Select 1
                Into n_禁用
                From 合作单位计划控制
                Where 计划id = n_计划id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_禁用
                From 合作单位安排控制
                Where 安排id = n_安排id And
                      限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                    '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            End If;
            If Nvl(n_禁用, 0) = 0 Then
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
            
            End If;
          End If;
        End If;
        n_合作单位数量 := 0;
        n_合约存在     := 0;
        n_禁用         := 0;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  End If;
  v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Docarrange;
/

--80967:张险华,2014-12-26,支持新版电子病历传染病报告卡
CREATE OR REPLACE Procedure Zl_病案反馈记录_Update
( 
  Id_In         In 病案反馈记录.Id%Type, 
  相关id_In     In 病案反馈记录.相关id%Type, 
  提交id_In     In 病案反馈记录.提交id%Type, 
  病人id_In     In 病案反馈记录.病人id%Type, 
  主页id_In     In 病案反馈记录.主页id%Type, 
  反馈对象_In   In 病案反馈记录.反馈对象%Type, 
  文件id_In     In 病案反馈记录.文件id%Type, 
  反馈意见_In   In 病案反馈记录.反馈意见%Type, 
  反馈项目id_In In 病案反馈记录.反馈项目id%Type, 
  反馈人_In     In 病案反馈记录.反馈人%Type, 
  反馈时间_In   In 病案反馈记录.反馈时间%Type, 
  处理期限_In   In 病案反馈记录.处理期限%Type, 
  医嘱id_In     In 病案反馈记录.医嘱id%Type := Null, 
  科室id_In     In 病案反馈记录.科室id%Type := Null, 
  评分级别_In   In 病案反馈记录.评分级别%Type := 0, 
  分制_In       In 病案反馈记录.分制%Type := 0, 
  分值_In       In 病案反馈记录.分值%Type := 0, 
  补充说明_In   In 病案反馈记录.补充说明%Type := Null, 
  反馈次数_In   In 病案反馈记录.反馈次数%Type := Null, 
  反馈记录_In   In 病案反馈记录.反馈记录%Type := Null, 
  子文档id_In   In 病案反馈记录.子文档id%Type := Null 
) Is 
Begin 
 
  Update 病案反馈记录 
  Set 提交id = Decode(提交id_In, 0, Null, 提交id_In), 病人id = 病人id_In, 主页id = 主页id_In, 反馈对象 = 反馈对象_In, 
      记录性质 = Decode(提交id_In, Null, 1, 0, 1, 2), 记录状态 = 1, 反馈意见 = 反馈意见_In, 反馈项目id = Decode(反馈项目id_In, 0, Null, 反馈项目id_In), 
      文件id = Decode(文件id_In, '0', Null, 文件id_In), 医嘱id = Decode(医嘱id_In, 0, Null, 医嘱id_In), 
      科室id = Decode(科室id_In, 0, Null, 科室id_In), 反馈人 = 反馈人_In, 反馈时间 = 反馈时间_In, 处理期限 = 处理期限_In, 评分级别 = 评分级别_In, 分制 = 分制_In, 
      分值 = 分值_In, 补充说明 = 补充说明_In, 反馈次数 = 反馈次数_In, 反馈记录 = 反馈记录_In, 子文档id = 子文档id_In 
  Where ID = Id_In; 
 
  If Sql%RowCount = 0 Then 
    Insert Into 病案反馈记录 
      (ID, 相关id, 提交id, 病人id, 主页id, 反馈对象, 文件id, 记录性质, 记录状态, 反馈意见, 反馈项目id, 反馈人, 反馈时间, 处理期限, 医嘱id, 科室id, 评分级别, 分制, 分值, 
       补充说明, 反馈次数, 反馈记录, 子文档id) 
    Values 
      (Id_In, Decode(相关id_In, 0, Null, 相关id_In), Decode(提交id_In, 0, Null, 提交id_In), 病人id_In, 主页id_In, 反馈对象_In, 
       Decode(文件id_In, '0', Null, 文件id_In), Decode(提交id_In, Null, 1, 0, 1, 2), 1, 反馈意见_In, 
       Decode(反馈项目id_In, 0, Null, 反馈项目id_In), 反馈人_In, 反馈时间_In, 处理期限_In, Decode(医嘱id_In, 0, Null, 医嘱id_In), 
       Decode(科室id_In, 0, Null, 科室id_In), 评分级别_In, 分制_In, 分值_In, 补充说明_In, 反馈次数_In, 反馈记录_In, 子文档id_In); 
   
    Update 病案提交记录 Set 记录状态 = 4 Where 病人id = 病人id_In And 主页id = 主页id_In And 记录状态 <> 2; 
   
  End If; 
 
  Zl_病案反馈记录_Updatesatue(病人id_In, 主页id_In); 
 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病案反馈记录_Update;
/

--83258:刘尔旋,2015-04-07,临时计划不能获取排班的问题
--82906:刘尔旋,2015-03-04,获取号源XML溢出的问题
--82862:刘尔旋,2015-03-09,移动挂未来号使用预约方式
--82833:刘尔旋,2015-02-28,挂号从项费用计算错误的问题
--82380:刘尔旋,2015-02-10,号别剩余数量不对的问题
--81983:刘尔旋,2015-01-21,预约收款挂号未扣减人数的问题
--81246:刘尔旋,2014-12-30,移动挂号接口调整
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>      
  --  <KSID>科室ID</KSID> 
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称 
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD/>      //时间段
  --                  <SL/>      //数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式 
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;

  Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  n_合约剩余数量 := 0;
  If Nvl(n_科室id, 0) <> 0 Then
    --按科室过滤号别
    For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                      Nvl(Xz.限号数, 0) As 限号数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                      Nvl(Xz.限号数, 0) As 限号数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.科室id = n_科室id And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And b.终止日期 > d_日期 And
                       b.执行日期 <= d_日期) Loop
      If r_No.计划id <> 0 Then
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排计划 Jh, 挂号计划时段 Sd
        Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      Else
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排 Ap, 挂号安排时段 Sd
        Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      End If;
      If n_分时段 = 0 Then
        v_Temp := '';
        If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
          If r_No.计划id <> 0 Then
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          Else
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          End If;
          If n_合约模式 = 0 Then
            If r_No.计划id <> 0 Then
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位计划控制
                     Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位安排控制
                     Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            End If;
          Else
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
          End If;
          If n_合约总数量 = 0 Then
            n_合约剩余数量 := 0;
          Else
            n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
            If n_合约剩余数量 > (r_No.限号数 - r_No.已挂数) Then
              n_合约剩余数量 := r_No.限号数 - r_No.已挂数;
            End If;
          End If;
        End If;
      Else
        v_Temp := '<SPANLIST>';
        If r_No.计划id <> 0 Then
          Select Max(结束时间)
          Into d_加号时间
          From 挂号计划时段
          Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Jh.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排计划 Jh, 挂号计划时段 Sd
                     Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
              Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
            End If;
          
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                           Order By Jh.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        Else
          Select Max(结束时间)
          Into d_加号时间
          From 挂号安排时段
          Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Ap.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排 Ap, 挂号安排时段 Sd
                     Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
              Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
            End If;
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                           Order By Ap.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        End If;
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 0
            Into n_非合约
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        Else
          Begin
            Select 0
            Into n_非合约
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        End If;
      End If;
      If v_合作单位 Is Null Or n_非合约 = 1 Then
        If r_No.限号数 = 0 Then
          v_剩余数量 := '';
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          Else
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          End If;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          Select Count(1)
          Into n_预留数量
          From 挂号序号状态
          Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
          If Trunc(d_日期) = Trunc(Sysdate) Then
            v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
            n_已挂数   := r_No.已挂数;
            If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
              n_缓冲序号 := 1;
              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' || '<SL>' ||
                            To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
            Else
              n_缓冲序号 := 0;
            End If;
          Else
            v_剩余数量 := r_No.限约数 - r_No.已约数 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
            n_已挂数   := r_No.已挂数;
          End If;
        End If;
      Else
        If Nvl(r_No.计划id, 0) <> 0 Then
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位计划控制
          Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        Else
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位安排控制
          Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        End If;
        If n_合约模式 = 0 Then
          v_剩余数量   := n_合约剩余数量;
          n_已挂数     := r_No.已挂数;
          n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
        Else
          n_已挂数 := r_No.已挂数;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          v_剩余数量 := Nvl(n_合约总数量, 0) - n_合约已挂数;
        End If;
      End If;
      Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_Timetemp || '-';
      Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_时间段 || v_Timetemp;
      If v_Temp Is Not Null Then
        v_Temp := v_Temp || '</SPANLIST>';
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 1
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        Else
          Begin
            Select 1
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        End If;
      End If;
      If Nvl(n_禁用, 0) = 0 Then
        --从项金额计算
        n_合计金额 := r_No.价格;
        For r_Subfee In (Select 现价, 从项数次
                         From 收费从属项目 A, 收费价目 B
                         Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                               Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
          n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
        End Loop;
        If Trunc(Sysdate) = Trunc(d_日期) Then
          Begin
            Select 1
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Exception
            When Others Then
              n_Exists := 0;
          End;
        Else
          n_Exists := 1;
        End If;
        If n_Exists = 1 Then
          If v_剩余数量 > 0 Then
            v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                         '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                         '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                         r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
          Else
            v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                         '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                         '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    If Nvl(n_医生id, 0) <> 0 Then
      --按医生ID过滤号别
      For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数

                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                                '6', Ap.周五, '7', Ap.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                                '6', Jh.周五, '7', Jh.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                        Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生id = n_医生id And
                                       d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And b.终止日期 > d_日期 And
                         b.执行日期 <= d_日期) Loop
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (r_No.限号数 - r_No.已挂数) Then
                n_合约剩余数量 := r_No.限号数 - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select Max(结束时间)
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          Else
            Select Max(结束时间)
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
              n_已挂数   := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              v_剩余数量 := r_No.限约数 - r_No.已约数 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
              n_已挂数   := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位计划控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位安排控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            v_剩余数量 := Nvl(n_合约总数量, 0) - n_合约已挂数;
          
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 1
              Into n_禁用
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          Else
            Begin
              Select 1
              Into n_禁用
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Begin
              Select 1
              Into n_Exists
              From (Select 时间段
                     From 时间段
                     Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                   '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
              Where 时间段 = r_No.排班;
            Exception
              When Others Then
                n_Exists := 0;
            End;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                           '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                           r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                           '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                           '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
            Else
              v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                           '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                           r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                           '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                           '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' ||
                           n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
            End If;
          End If;
        End If;
        n_合约剩余数量 := 0;
        n_合约总数量   := 0;
        n_时段数量     := 0;
        n_禁用         := 0;
        n_非合约       := 0;
      End Loop;
      v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                   '</HBLIST>' || '</GROUP>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
    Else
      If Nvl(v_医生姓名, '_') <> '_' Then
        --按医生姓名过滤号别
        For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数

                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5',
                                                  Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                          Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Ap.医生姓名 = v_医生姓名 And Ap.停用日期 Is Null And
                                         d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5',
                                                  Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班, Nvl(Xz.限约数, 0) As 限约数,
                                          Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生姓名 = v_医生姓名 And
                                         d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And b.终止日期 > d_日期 And
                           b.执行日期 <= d_日期) Loop
          If r_No.计划id <> 0 Then
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排计划 Jh, 挂号计划时段 Sd
            Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          Else
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排 Ap, 挂号安排时段 Sd
            Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          End If;
          If n_分时段 = 0 Then
            v_Temp := '';
            If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
              If r_No.计划id <> 0 Then
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              Else
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              End If;
              If n_合约模式 = 0 Then
                If r_No.计划id <> 0 Then
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位计划控制
                         Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                Else
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位安排控制
                         Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                End If;
              Else
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
              End If;
              If n_合约总数量 = 0 Then
                n_合约剩余数量 := 0;
              Else
                n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                If n_合约剩余数量 > (r_No.限号数 - r_No.已挂数) Then
                  n_合约剩余数量 := r_No.限号数 - r_No.已挂数;
                End If;
              End If;
            End If;
          Else
            v_Temp := '<SPANLIST>';
            If r_No.计划id <> 0 Then
              Select Max(结束时间)
              Into d_加号时间
              From 挂号计划时段
              Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Jh.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排计划 Jh, 挂号计划时段 Sd
                         Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                  Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                        Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                               Order By Jh.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            Else
              Select Max(结束时间)
              Into d_加号时间
              From 挂号安排时段
              Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Ap.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排 Ap, 挂号安排时段 Sd
                         Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                  Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                        Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                               Order By Ap.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 0
                Into n_非合约
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            Else
              Begin
                Select 0
                Into n_非合约
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            End If;
          End If;
          If v_合作单位 Is Null Or n_非合约 = 1 Then
            If r_No.限号数 = 0 Then
              v_剩余数量 := '';
            Else
              If Nvl(r_No.计划id, 0) <> 0 Then
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              Else
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              Select Count(1)
              Into n_预留数量
              From 挂号序号状态
              Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
              If Trunc(d_日期) = Trunc(Sysdate) Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
                n_已挂数   := r_No.已挂数;
                If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                  n_缓冲序号 := 1;
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                                '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
                Else
                  n_缓冲序号 := 0;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - Nvl(n_合约总数量, n_合约已挂数) + n_合约已挂数 - n_预留数量;
                n_已挂数   := r_No.已挂数;
              End If;
            End If;
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            Else
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            End If;
            If n_合约模式 = 0 Then
              v_剩余数量   := n_合约剩余数量;
              n_已挂数     := r_No.已挂数;
              n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
            Else
              n_已挂数 := r_No.已挂数;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              v_剩余数量 := Nvl(n_合约总数量, 0) - n_合约已挂数;
            
            End If;
          End If;
          Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_Timetemp || '-';
          Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_时间段 || v_Timetemp;
          If v_Temp Is Not Null Then
            v_Temp := v_Temp || '</SPANLIST>';
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 1
                Into n_禁用
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_禁用
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            End If;
          End If;
          If Nvl(n_禁用, 0) = 0 Then
            --从项金额计算
            n_合计金额 := r_No.价格;
            For r_Subfee In (Select 现价, 从项数次
                             From 收费从属项目 A, 收费价目 B
                             Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                   Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
              n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
            End Loop;
            If Trunc(Sysdate) = Trunc(d_日期) Then
              Begin
                Select 1
                Into n_Exists
                From (Select 时间段
                       From 时间段
                       Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                     '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
                Where 时间段 = r_No.排班;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
            Else
              n_Exists := 1;
            End If;
            If n_Exists = 1 Then
              If v_剩余数量 > 0 Then
                v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                             '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                             r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                             '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' ||
                             '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 ||
                             '</HCXH>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' ||
                             v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              Else
                v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                             '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                             r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                             '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' ||
                             '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 ||
                             '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                             r_No.排班 || '</FWMC>' || '</HB>';
              End If;
            End If;
          End If;
          n_合约剩余数量 := 0;
          n_合约总数量   := 0;
          n_时段数量     := 0;
          n_禁用         := 0;
          n_非合约       := 0;
        End Loop;
        v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                     '</HBLIST>' || '</GROUP>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Getnolist;
/

--81134:刘尔旋,2014-12-26,新增计划处理合作单位信息
Create Or Replace Procedure Zl_挂号安排计划_Delete(Id_In In 挂号安排计划.Id%Type) Is
  Err_Item Exception;
  v_Err_Msg   Varchar2(100);
  v_User_Name 人员表.姓名%Type;
  v_Candel    Number(18) := 0;
  n_Count     Number := 0;
Begin
  Begin
    Select p.姓名 Into v_User_Name From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_User_Name := Null;
  End;
  If v_User_Name Is Null Then
    v_Err_Msg := '[ZLSOFT]当前用户未设置对应的人员信息,请与' || Chr(10) || Chr(13) || '系统管理员联系,先到用户授权管理中设置！[ZLSOFT]';
    Raise Err_Item;
  End If;
  Begin
    Select 1 Into v_Candel From 挂号安排计划 Where ID = Id_In And 审核时间 Is Null;
  Exception
    When Others Then
      v_Candel := 0;
  End;
  If v_Candel = 0 Then
    v_Err_Msg := '[ZLSOFT]该计划安排已经被他人审核或删除,不能再删除![ZLSOFT]';
    Raise Err_Item;
  End If;
  Select Count(1) Into n_Count From 挂号安排计划 Where 安排id = (Select 安排id From 挂号安排计划 Where ID = Id_In);
  --删除计划需先删除挂号计划限制和挂号计划时段
  If n_Count <> 2 Then
    Delete 挂号计划时段 Where 计划id = Id_In;
    Delete 挂号计划限制 Where 计划id = Id_In;
    Delete 合作单位计划控制 Where 计划id = Id_In;
    Delete 挂号安排计划 Where ID = Id_In And 审核时间 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '[ZLSOFT]该计划安排已经被他人审核或删除,不能再删除![ZLSOFT]';
      Raise Err_Item;
    End If;
  Else
    --因为 首次添加计划时 默认添加了已挂号安排的数据 添加了一条计划
    --在用户删除首次添加的计划时  这条长期的计划 也应该删除
    Delete 挂号计划时段
    Where 计划id In (Select ID From 挂号安排计划 Where 安排id = (Select 安排id From 挂号安排计划 Where ID = Id_In));
    Delete 挂号计划限制
    Where 计划id In (Select ID From 挂号安排计划 Where 安排id = (Select 安排id From 挂号安排计划 Where ID = Id_In));
    Delete 合作单位计划控制
    Where 计划id In (Select ID From 挂号安排计划 Where 安排id = (Select 安排id From 挂号安排计划 Where ID = Id_In));
    Delete 挂号安排计划 Where 安排id = (Select 安排id From 挂号安排计划 Where ID = Id_In);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排计划_Delete;
/

--83328:刘尔旋,2015-03-27,新增计划默认禁用合作单位
--81134:刘尔旋,2014-12-26,新增计划处理合作单位信息
Create Or Replace Procedure Zl_挂号安排计划_Insert
(
  Id_In       In 挂号安排计划.Id%Type,
  安排id_In   In 挂号安排计划.安排id%Type,
  号码_In     In 挂号安排计划.号码%Type,
  生效时间_In In 挂号安排计划.生效时间%Type,
  失效时间_In In 挂号安排计划.失效时间%Type,
  周日_In     In 挂号安排计划.周日%Type,
  周一_In     In 挂号安排计划.周一%Type,
  周二_In     In 挂号安排计划.周二%Type,
  周三_In     In 挂号安排计划.周三%Type,
  周四_In     In 挂号安排计划.周四%Type,
  周五_In     In 挂号安排计划.周五%Type,
  周六_In     In 挂号安排计划.周六%Type,
  限号控制_In In Varchar2,
  分诊方式_In In 挂号安排计划.分诊方式%Type,
  序号控制_In In 挂号安排计划.序号控制%Type,
  项目id_In   In 挂号安排计划.项目id%Type,
  医生姓名_In In 挂号安排计划.医生姓名%Type,
  医生id_In   In 挂号安排计划.医生id%Type,
  诊室_In     Varchar2,
  新增_In     Number := 1,
  处理类型_In Number := 0,
  时段间隔_In 挂号安排计划.默认时段间隔%Type := 0
) Is
  --  限号控制_IN:|周一,22(限号),13(限约)|周二,20(限号),11(限约)....
  --  处理类型 0-对时段信息不处理
  --            新增时 不提取安排的时段数据
  --            修改时 修改了排班后对时段数据不进行处理 ,只删除 去掉了排班的时段)
  --         1.新增时  自动提取挂号安排时段的数据作为计划时段的数据
  --           修改时  清除该计划所有的计划时段的数据
  --  时段间隔_IN:为计划设置时段是默认时间段间隔
  --立即启用_IN,立即审核_IN,此两个参数,暂时未使用
  Err_Item Exception;
  v_Err_Msg   Varchar2(500);
  v_User_Name 人员表.姓名%Type;
  v_诊室      Varchar2(4000);
  d_Date      Date;
  n_限号数    挂号安排限制.限号数%Type;
  n_限约数    挂号安排限制.限约数%Type;
  v_限制项目  挂号安排限制.限制项目%Type;
  v_限制控制  Varchar2(4000);
  v_当前项目  Varchar2(4000);
  v_Rowtotal  Number(9) := 1;
  v_Firstid   挂号安排计划.Id%Type;
Begin
  Begin
    Select p.姓名 Into v_User_Name From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_User_Name := Null;
  End;
  If v_User_Name Is Null Then
    v_Err_Msg := '[ZLSOFT]当前用户未设置对应的人员信息,请与' || Chr(10) || Chr(13) || '系统管理员联系,先到用户授权管理中设置！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --之所以要减,主要是避免当前立即生效的结果
  Select Sysdate - 20 * 1 / 24 / 60 / 60 Into d_Date From Dual;
  If 生效时间_In < d_Date Then
    v_Err_Msg := '[ZLSOFT]计划生效时间,必须大于当前时间,请检查！[ZLSOFT]';
    Raise Err_Item;
  End If;
  If 新增_In = 1 Then
    Select Count(1) Into v_Rowtotal From 挂号安排计划 Where 安排id = 安排id_In;
  
    Insert Into 挂号安排计划
      (ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 安排人, 安排时间, 审核人, 审核时间, 实际生效, 项目id, 医生姓名, 医生id,
       默认时段间隔)
      Select Id_In, 安排id_In, 号码_In, 生效时间_In, 失效时间_In, 周日_In, 周一_In, 周二_In, 周三_In, 周四_In, 周五_In, 周六_In, 分诊方式_In, 序号控制_In,
             v_User_Name, Sysdate, Null, Null, To_Date('3000-01-01', 'yyyy-mm-dd'), 项目id_In, 医生姓名_In, 医生id_In,
             Nvl(时段间隔_In, 5)
      From Dual;
    For r_合作单位 In (Select 名称 From 挂号合作单位) Loop
      Insert Into 合作单位计划控制
        (合作单位, 计划id, 限制项目, 序号, 数量)
        Select r_合作单位.名称, Id_In, '周日', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周一', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周二', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周三', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周四', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周五', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周六', 0, 0 From Dual;
    End Loop;
    --处理首次添加计划时 把原来挂号安排中的数据作为一个长期计划添加的挂号安排计划以及相关的表中
    If v_Rowtotal = 0 Then
      Select 挂号安排计划_Id.Nextval Into v_Firstid From Dual;
      Insert Into 挂号安排计划
        (ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 安排人, 安排时间, 审核人, 审核时间, 实际生效, 项目id, 医生姓名, 医生id,
         默认时段间隔)
        Select v_Firstid As ID, ID As 安排id, 号码, Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')),
               Nvl(终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')), 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, v_User_Name,
               Sysdate, v_User_Name, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 项目id, 医生姓名, 医生id, Nvl(默认时段间隔, 5)
        From 挂号安排
        Where ID = 安排id_In;
      Insert Into 挂号计划诊室
        (计划id, 门诊诊室)
        Select v_Firstid As 计划id, 门诊诊室 From 挂号安排诊室 Where 号表id = 安排id_In;
      Insert Into 挂号计划限制
        (计划id, 限号数, 限约数, 限制项目)
        Select v_Firstid As 计划id, 限号数, 限约数, 限制项目 From 挂号安排限制 Where 安排id = 安排id_In;
      Insert Into 挂号计划时段
        (计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
        Select v_Firstid As 计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期
        From 挂号安排时段
        Where 安排id = 安排id_In;
      Insert Into 合作单位计划控制
        (合作单位, 计划id, 限制项目, 序号, 数量)
        Select 合作单位, v_Firstid, 限制项目, 序号, 数量 From 合作单位安排控制 Where 安排id = 安排id_In;
    End If;
  
  Else
    Delete 挂号计划诊室 Where 计划id = Id_In;
    --修改计划时 先处理时段信息
    If Nvl(处理类型_In, 0) = 0 Then
      If Nvl(处理类型_In, 0) = 1 Then
        Delete 挂号计划时段 Where 计划id = Id_In; --
      Else
        --针对存在时段这种情况需要先处理排班修改后的时段 在后再修改安排
        Delete 挂号计划时段
        Where 计划id = Id_In And 星期 In (Select 星期
                                      From (Select Case 周一
                                                       When 周一_In Then
                                                        Null
                                                       Else
                                                        '周一'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周二
                                                       When 周二_In Then
                                                        Null
                                                       Else
                                                        '周二'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周三
                                                       When 周三_In Then
                                                        Null
                                                       Else
                                                        '周三'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周四
                                                       When 周四_In Then
                                                        Null
                                                       Else
                                                        '周四'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周五
                                                       When 周五_In Then
                                                        Null
                                                       Else
                                                        '周五'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周六
                                                       When 周六_In Then
                                                        Null
                                                       Else
                                                        '周六'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周日
                                                       When 周日_In Then
                                                        Null
                                                       Else
                                                        '周日'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In) A
                                      Where a.星期 Is Not Null);
      End If;
    Else
      Delete 挂号计划时段 Where 计划id = Id_In;
    End If;
  
    Update 挂号安排计划
    Set ID = Id_In, 安排id = 安排id_In, 号码 = 号码_In, 生效时间 = 生效时间_In, 失效时间 = 失效时间_In, 周日 = 周日_In, 周一 = 周一_In, 周二 = 周二_In,
        周三 = 周三_In, 周四 = 周四_In, 周五 = 周五_In, 周六 = 周六_In, 分诊方式 = 分诊方式_In, 序号控制 = 序号控制_In, 安排人 = v_User_Name,
        安排时间 = Sysdate, 项目id = Nvl(项目id_In, 项目id), 医生姓名 = 医生姓名_In, 医生id = Decode(医生id_In, 0, Null, 医生id_In),
        默认时段间隔 = Decode(Nvl(时段间隔_In, 0), 0, 默认时段间隔, 时段间隔_In)
    Where ID = Id_In And 审核时间 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '[ZLSOFT]该计划安排已经被他人审核或删除,不能再修改![ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete 挂号计划限制 Where 计划id = Id_In;
  End If;

  v_限制控制 := 限号控制_In || '|';
  While v_限制控制 Is Not Null Loop
    v_当前项目 := Substr(v_限制控制, 1, Instr(v_限制控制, '|') - 1);
    v_限制项目 := Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1);
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_限号数   := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    n_限约数   := To_Number(Substr(v_当前项目, Instr(v_当前项目, ',') + 1));
    If Nvl(n_限号数, 0) <> 0 Then
      Insert Into 挂号计划限制
        (计划id, 限制项目, 限号数, 限约数)
      Values
        (Id_In, v_限制项目, Decode(n_限号数, 0, Null, n_限号数), Decode(n_限约数, 0, Null, n_限约数));
    End If;
    v_限制控制 := Substr(v_限制控制, Instr(v_限制控制, '|') + 1);
  End Loop;
  --对挂号计划时段进行处理
  If Nvl(新增_In, 0) = 1 And 处理类型_In = 1 Then
    --提取挂号安排时段的数据作为计划时段的数据
    Insert Into 挂号计划时段
      (计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
      Select Id_In, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期 From 挂号安排时段 Where 安排id = 安排id_In;
  End If;
  --挂号安排诊室处理
  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ';';
    While v_诊室 Is Not Null Loop
      Insert Into 挂号计划诊室 (计划id, 门诊诊室) Values (Id_In, Substr(v_诊室, 1, Instr(v_诊室, ';') - 1));
      v_诊室 := Substr(v_诊室, Instr(v_诊室, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排计划_Insert;
/

--82870:刘尔旋,2015-03-09,生成病人时包含门诊号
--82380:刘尔旋,2015-02-05,新病人绑定传入到三方用户资料
--77834:余伟节,2014-12-26,创建新病人,移动平台接口整理
Create Or Replace Procedure Zl_Third_Buildpatient
(
  Patiinfo_In  In Xmltype,
  Patiinfo_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------
  --参数说明:
  -- 入参 Patiinfo_In:
  --<IN>
  -- <SFZ></SFZ>                       //身份证
  --  <XM></XM>                       //姓名
  --  <SJH></SJH>                      //手机号
  --</IN>

  --出参 Patiinfo_Out：
  --<OUTPUT>
  --       <BRID></BRID>                //病人ID
  --       <MZH></MZH>                  //门诊号
  --     <ERROR></ERROR>         //如果有错误返回该节点
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Pati_Id      病人信息.病人id%Type;
  n_Card_Type_Id 医疗卡类别.Id%Type;
  n_Count        Number(5);
  n_Sum          Number(5);
  v_校验位       Varchar2(50);

  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_手机号       病人信息.家庭电话%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  v_操作员       人员表.姓名%Type;
  v_医疗付款方式 病人信息.医疗付款方式%Type;
  n_门诊号       病人信息.门诊号%Type;

  v_Pattern Varchar2(500);
  v_Temp    Varchar2(32767); --临时XML
  v_Err_Msg Varchar2(2000);

  d_出生日期  病人信息.出生日期%Type;
  d_Curr_Time Date;

  Err_Item Exception;
Begin
  Patiinfo_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Sysdate Into d_Curr_Time From Dual;

  --新建病人：姓名、身份证号、手机号（存在家庭电话中）、出生日期、性别、年龄(后面三项可从身份证中获取)。
  Select Extractvalue(Value(I), 'IN/XM'), Extractvalue(Value(I), 'IN/SFZ'), Extractvalue(Value(I), 'IN/SJH')
  Into v_姓名, v_身份证号, v_手机号
  From Table(Xmlsequence(Extract(Patiinfo_In, 'IN'))) I;

  If v_姓名 Is Null Then
    v_Err_Msg := '传人姓名为空!';
    Raise Err_Item;
  End If;

  If v_身份证号 Is Null Then
    v_Err_Msg := '传人身份证号为空!';
    Raise Err_Item;
  Else
    --身份证合法验证
    v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
  
    --地区检验
    If Instr(v_Pattern, Substr(v_身份证号, 1, 2)) = 0 Then
      v_Err_Msg := '身份证前两位地区码不正确!';
      Raise Err_Item;
    End If;
    --身份证长度检查
    If Length(v_身份证号) = 15 Then
      --检查身份证号:15位身份证号要求全部为数字
      v_Pattern := '^\d{15}$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中包含非法字符，请检查!';
        Raise Err_Item;
      End If;
      --获取性别
      If Mod(To_Number(Substr(v_身份证号, 15, 1)), 2) = 1 Then
        v_性别 := '男';
      Else
        v_性别 := '女';
      End If;
      --出生日期的合法性检查
      d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
      v_Pattern  := '^[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(v_身份证号, 7, 6), v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中的出生日期无效，请检查!';
        Raise Err_Item;
      Else
        If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        End If;
      End If;
    Elsif Length(v_身份证号) = 18 Then
      -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
      v_Pattern := '^\d{17}[0-9Xx]$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中包含非法字符!';
        Raise Err_Item;
      End If;
      --获取性别
      If Mod(To_Number(Substr(v_身份证号, 17, 1)), 2) = 1 Then
        v_性别 := '男';
      Else
        v_性别 := '女';
      End If;
      --出生日期的合法性检查
      d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
      v_Pattern  := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
      Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(v_身份证号, 7, 8), v_Pattern);
      If n_Count = 0 Then
        v_Err_Msg := '身份证中的出生日期无效，请检查!';
        Raise Err_Item;
      Else
        If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        End If;
        --计算校验位
        n_Sum     := (To_Number(Substr(v_身份证号, 1, 1)) + To_Number(Substr(v_身份证号, 11, 1))) * 7 +
                     (To_Number(Substr(v_身份证号, 2, 1)) + To_Number(Substr(v_身份证号, 12, 1))) * 9 +
                     (To_Number(Substr(v_身份证号, 3, 1)) + To_Number(Substr(v_身份证号, 13, 1))) * 10 +
                     (To_Number(Substr(v_身份证号, 4, 1)) + To_Number(Substr(v_身份证号, 14, 1))) * 5 +
                     (To_Number(Substr(v_身份证号, 5, 1)) + To_Number(Substr(v_身份证号, 15, 1))) * 8 +
                     (To_Number(Substr(v_身份证号, 6, 1)) + To_Number(Substr(v_身份证号, 16, 1))) * 4 +
                     (To_Number(Substr(v_身份证号, 7, 1)) + To_Number(Substr(v_身份证号, 17, 1))) * 2 +
                     To_Number(Substr(v_身份证号, 8, 1)) * 1 + To_Number(Substr(v_身份证号, 9, 1)) * 6 +
                     To_Number(Substr(v_身份证号, 10, 1)) * 3;
        n_Count   := Mod(n_Sum, 11);
        v_Pattern := '10X98765432';
        v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
        If v_校验位 <> Upper(Substr(v_身份证号, 18, 1)) Then
          v_Err_Msg := '身份证号码不正确，请检查。';
          Raise Err_Item;
        End If;
      End If;
    Else
      v_Err_Msg := '身份证长度不对,请检查。';
      Raise Err_Item;
    End If;
  
    If Nvl(v_年龄, '_') = '_' Then
      v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
    End If;
  End If;

  Select 名称 Into v_医疗付款方式 From 医疗付款方式 Where 缺省标志 = 1;
  Select 病人信息_Id.Nextval Into n_Pati_Id From Dual;
  n_门诊号 := Nextno(3);
  Insert Into 病人信息
    (病人id, 姓名, 身份证号, 家庭电话, 出生日期, 性别, 年龄, 登记时间, 门诊号, 医疗付款方式)
    Select n_Pati_Id, v_姓名, v_身份证号, v_手机号, d_出生日期, v_性别, v_年龄, d_Curr_Time, n_门诊号, v_医疗付款方式
    From Dual;

  --病人信息保存完后，完成医疗卡绑定（二代身份证卡类别的绑定）
  Begin
    Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 Like '%就诊卡%' And Rownum < 2;
  Exception
    When No_Data_Found Then
      v_Err_Msg := '就诊卡卡类别不存在！';
      Raise Err_Item;
  End;
  Select b.姓名 Into v_操作员 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;

  Zl_医疗卡变动_Insert(11, n_Pati_Id, n_Card_Type_Id, Null, v_身份证号, '创建虚拟卡', Null, v_操作员, d_Curr_Time);

  v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
  Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
  Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;

Exception
  When Err_Item Then
    v_Temp := '<BRID>' || '0' || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    v_Temp := '<ERROR>' || v_Err_Msg || '</ERROR>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatient;
/

--80773:李业庆,2015-01-05,医嘱回退时更新输液配药记录状态
Create Or Replace Procedure Zl_输液配药记录_医嘱回退
(
  医嘱id_In   In 输液配药记录.医嘱id%Type,
  发送号_In   In 输液配药记录.发送号%Type,
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null
) Is
  n_Count Number(5);
Begin
  --只对状态=1(未配药)的记录处理，如果已经配药了，则通过销账方式处理
  Select Count(ID) Into n_Count From 输液配药记录 Where 操作状态 = 1 And 医嘱id = 医嘱id_In And 发送号 = 发送号_In;

  If n_Count > 0 Then
    Update 输液配药记录
    Set 操作状态 = 12, 操作人员 = Nvl(操作人员_In, Zl_Username), 操作时间 = Nvl(操作时间_In, Sysdate)
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间)
      Select ID, 12, Nvl(操作人员_In, Zl_Username), Nvl(操作时间_In, Sysdate)
      From 输液配药记录
      Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_医嘱回退;
/
--82014:梁唐彬,2015-01-22,拆分SQL中的OR
Create Or Replace Procedure Zl_病人医嘱执行_Insert
(
  医嘱id_In       病人医嘱执行.医嘱id%Type,
  发送号_In       病人医嘱执行.发送号%Type,
  要求时间_In     病人医嘱执行.要求时间%Type,
  本次数次_In     病人医嘱执行.本次数次%Type,
  执行摘要_In     病人医嘱执行.执行摘要%Type,
  执行人_In       病人医嘱执行.执行人%Type,
  执行时间_In     病人医嘱执行.执行时间%Type,
  单独执行_In     Number := 0,
  自动完成_In     Number := 0,
  执行结果_In     病人医嘱执行.执行结果%Type := 1,
  未执行原因_In   病人医嘱执行.说明%Type := Null,
  操作员编号_In   人员表.编号%Type := Null,
  操作员姓名_In   人员表.姓名%Type := Null,
  执行部门id_In   门诊费用记录.执行部门id%Type := 0,
  配液检查_In     Number := 0,
  检验项目记帐_In Number := 0,
  输液通道_In     病人医嘱执行.输液通道%Type := Null
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      执行结果_In=1- 完成   =0  -未执行
  --      如果是台式机调用 操作员编号_In 操作员姓名_In 这两个参数必须传入
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
  --配液检查_In=移动工作站调用时，是否检查配液信息。
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态
) Is
  --除了要执行的主记录,还包含了附加手术,检查部位的记录
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同
  v_组id     病人医嘱记录.Id%Type;
  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_自动完成 Number;
  v_病人来源 病人医嘱记录.病人来源%Type;
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_操作类型 诊疗项目目录.操作类型%Type;
  v_病区id   病案主页.当前病区id%Type;
  v_配液病区 Varchar2(200);
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_期效     病人医嘱记录.医嘱期效%Type;

  n_执行次数 Number;
  n_剩余次数 Number;
  n_执行状态 Number;
  d_终止时间 Date;
  d_开始时间 Date;

  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发查检，防止产生多条执行记录
  Begin
    Select (a.发送数次 - c.登记次数) As 剩余数次
    Into v_Count
    From 病人医嘱发送 A,
         (Select 医嘱id_In As 医嘱id, 发送号_In As 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
           From 病人医嘱执行 B
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In) C
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
  Exception
    When Others Then
      v_Count := 本次数次_In;
  End;
  If 本次数次_In > v_Count Then
    v_Error := '由于并发操作可能已经被他人登记，请刷新后再试。';
    Raise Err_Custom;
  End If;
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    Begin
      Select 姓名, 编号 Into v_人员姓名, v_人员编号 From 人员表 Where 姓名 = 执行人_In;
    Exception
      When Others Then
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End;
  End If;
  --对医嘱终止时间进行检查
  Select a.执行终止时间, a.开始执行时间, a.医嘱期效
  Into d_终止时间, d_开始时间, n_期效
  From 病人医嘱记录 A
  Where a.Id = 医嘱id_In;
  If Not d_终止时间 Is Null And n_期效 = 0 Then
    If 要求时间_In > d_终止时间 Then
      v_Error := '要求时间超过了医嘱终止时间，请确认医嘱是否提前停止！';
      Raise Err_Custom;
    End If;
  End If;
  If Not d_开始时间 Is Null Then
    If 执行时间_In < d_开始时间 Then
      v_Error := '执行时间必须大于医嘱的开始执行时间''' || To_Char(d_开始时间, 'yyyy-mm-dd HH24:mi:ss') || '''！';
      Raise Err_Custom;
    End If;
  End If;
  Select Sysdate Into v_Date From Dual;
  Select a.病人来源, 执行科室id, Nvl(a.相关id, a.Id), a.诊疗类别, Nvl(b.操作类型, '0') 操作类型
  Into v_病人来源, v_病区id, v_组id, v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id;

  If v_病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;

  --移动系统配液检查
  If 配液检查_In = 1 Then
    --检查当前病人所属病区是否进行配液登记管理
    Select Nvl(Zl_Getsysparameter(184), '') Into v_配液病区 From Dual;
  
    If v_配液病区 Is Not Null And 执行结果_In <> 0 Then
      If Instr(',' || v_配液病区 || ',', ',' || v_病区id || ',') > 0 Then
        v_病区id   := 0;
        v_配液病区 := 'Select 1 From 病区配液记录 where 医嘱ID=:YZID AND 发送号=:FSH AND 要求时间=:YQSJ';
        Begin
          Execute Immediate v_配液病区
            Into v_病区id
            Using 医嘱id_In, 发送号_In, 要求时间_In;
        Exception
          When Others Then
            Null;
        End;
        If v_病区id = 0 Then
          v_Error := '当前医嘱还未进行配液，不允许进行执行登记！';
          Raise Err_Custom;
        End If;
      End If;
    End If;
    --检查当前医嘱是否已配液
  End If;

  --病人医嘱执行
  Select Count(1)
  Into v_Count
  From 病人医嘱执行
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 执行时间_In;
  If v_Count > 0 Then
    v_Error := '您指定的执行时间，已经执行过本条医嘱，请更改一个执行时间。';
    Raise Err_Custom;
  End If;
  Insert Into 病人医嘱执行
    (医嘱id, 发送号, 要求时间, 本次数次, 执行摘要, 执行人, 执行时间, 登记时间, 登记人, 执行结果, 说明, 输液通道)
  Values
    (医嘱id_In, 发送号_In, 要求时间_In, 本次数次_In, 执行摘要_In, 执行人_In, 执行时间_In, v_Date, v_人员姓名, 执行结果_In, 未执行原因_In, 输液通道_In);

  --费用记录的执行状态进行更新
  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数)
  Into n_执行次数, n_剩余次数
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;
  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;

  --填写了执行状态后就标记为正在执行
  If Nvl(单独执行_In, 0) = 1 Then
    Update 病人医嘱发送
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3)
    Where 执行状态 In (0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;
  Else
    Update 病人医嘱发送
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3)
    Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And
          医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID = v_组id And 诊疗类别 = v_诊疗类别
                   Union All
                   Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别);
  End If;

  --更新对应的费用执行状态为已执行(无正在执行)
  --不应该处理药品和跟踪在用的卫材
  If 执行结果_In = 1 Then
    If v_费用性质 = 2 Then
      If Nvl(单独执行_In, 0) = 1 Then
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 住院费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                     医嘱id In (Select ID
                              From 病人医嘱记录
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别
                              Union All
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别));
      End If;
    Else
      If Nvl(单独执行_In, 0) = 1 Then
        --对于门诊单据n_执行状态可能为0（登记执行情况，选择执行结果为未执行），因此需判断
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In);
      Else
        Update 门诊费用记录 A
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In)
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And
              (医嘱序号, NO, 记录性质) In
              (Select 医嘱id, NO, 记录性质
               From 病人医嘱发送
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And
                     医嘱id In (Select ID
                              From 病人医嘱记录
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别
                              Union All
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别));
      End If;
    End If;
    --检验自动完成采集
    If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
      Update 病人医嘱发送 A
      Set a.采样人 = 执行人_In, a.采样时间 = 执行时间_In
      Where 医嘱id In (Select ID
                     From 病人医嘱记录
                     Where ID = v_组id
                     Union All
                     Select ID From 病人医嘱记录 Where 相关id = v_组id) And 发送号 = 发送号_In;
    End If;
  
    --执行数次达到之后自动完成执行(主要用于PDA自动执行)，如果启用了移动临床，则护士站和PDA一致。
    v_自动完成 := 自动完成_In;
    If Nvl(v_自动完成, 0) = 0 And v_病人来源 = 2 And Instr('C,D', v_诊疗类别) = 0 Then
      Begin
        Execute Immediate 'Select Count(1) From ZLMBSYSTEMS'
          Into v_Count;
      Exception
        When Others Then
          Null;
      End;
      If v_Count > 0 Then
        v_自动完成 := 1;
      End If;
    End If;
  
    If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then
      Begin
        Select Decode(Sign(Nvl(Sum(b.本次数次), 0) - a.发送数次), 1, 1, 0, 1, 0)
        Into v_自动完成
        From 病人医嘱发送 A, 病人医嘱执行 B
        Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And a.执行状态 In (0, 3) And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In
        Group By a.发送数次;
      Exception
        When Others Then
          Null;
      End;
    
      If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then
        Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, 单独执行_In, v_人员编号, v_人员姓名, 执行部门id_In, 检验项目记帐_In);
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱执行_Insert;
/

--81829:李业庆,2015-02-04,病人实际取药确认模式
--82406:李业庆,2015-02-06,移动支付宝项目在发药后动态调用生成推送信息的过程  
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No,b.记录性质
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间)
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In
      Where ID = v_Modifybillout.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.数量, 0), 0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id,
             v_Modifybillout.成本价, v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期,
             v_Modifybillout.批准文号, v_Modifybillout.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id, v_Modifybillout.成本价,
             v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期, v_Modifybillout.批准文号,
             v_Modifybillout.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型
      Where ID = v_Modifybillin.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.数量, 0), 0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id,
             v_Modifybillin.成本价, v_Modifybillin.批号, v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期,
             v_Modifybillin.批准文号, v_Modifybillin.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id, v_Modifybillin.成本价, v_Modifybillin.批号,
             v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期, v_Modifybillin.批准文号, v_Modifybillin.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  Begin
    --移动支付宝项目在发药后动态调用生成推送信息的过程
    Execute Immediate 'Begin ZL_Third_AFTERDrug(:1,:2); End;'
      Using No_In, Partid_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--81829:李业庆,2015-02-04,病人实际取药确认模式
Create Or Replace Procedure Zl_药品收发记录_确认取药
(
  库房id_In       In 药品收发记录.库房id%Type,
  单据_In         In 药品收发记录.单据%Type,
  No_In           In 药品收发记录.No%Type,
  是否未取药_In   In 药品收发记录.是否未取药%Type,
  取药确认人员_In In 药品收发记录.取药确认人员%Type,
  取药时间_In     In 药品收发记录.取药时间%Type
) Is
Begin
  Update 药品收发记录
  Set 是否未取药 = 是否未取药_In, 取药确认人员 = 取药确认人员_In, 取药时间 = 取药时间_In
  Where NO = No_In And 单据 = 单据_In And 库房id + 0 = 库房id_In And 审核人 Is Not Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_确认取药;
/

Delete from zlFilesUpgrade Where UPPER(文件名)='ZLGETIMAGEEX.EXE';
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 1,'zlGetImageEx.exe','', Null ,'1','ZL9PACSWORK','[Appsoft]\Apply','zlGetImageEx是使用ActiveExe的方式实现后台进程加载及上传图像，是一个ActiveExe部件','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLGETIMAGEEX.EXE');

----------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.34.20' Where 编号=&n_System;
--部件版本号
Commit;