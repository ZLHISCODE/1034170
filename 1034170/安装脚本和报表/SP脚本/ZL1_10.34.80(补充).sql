--[连续升级]1
--[管理工具版本号]10.34.80
--本脚本支持从ZLHIS+ v10.34.70 升级到 v10.34.80
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--96744:梁经伙,2016-06-08,增加疾病申报反馈存储上报后的报告的备注说明
Create Table 疾病申报反馈(
  申报ID Number(18),
  反馈信息 VARCHAR2(500),
  登记人 VARCHAR2(20),
  登记时间 date,
  处理情况说明 VARCHAR2(500),
  待转出 Number(3))
TABLESPACE zl9EprDat;
Alter Table 疾病申报反馈 Add Constraint 疾病申报反馈_FK_申报ID Foreign Key (申报ID) References 疾病申报记录 (文件ID) On Delete Cascade;

Alter Table 疾病申报反馈 Add Constraint 疾病申报反馈_PK Primary Key (申报ID,登记时间) Using Index Tablespace zl9Indexcis;

Create Index 疾病申报反馈_IX_登记时间 On 疾病申报反馈(登记时间) Tablespace zl9Indexcis;

Create Index 疾病申报反馈_IX_待转出 On 疾病申报反馈(待转出) Tablespace zl9Indexcis;

--96922:许华峰,2016-06-01,处理一个医嘱多份报告的存储问题
Alter Table 病人医嘱报告 Add RISID Number(18);

--96182:许华锋,2016-05-30,RIS接口日志记录
Create Table RIS接口日志记录
(
   ID Number(18),
   时间 Date,
   站点 Varchar2(50),
   用户 Varchar2(100),
   类型 Number(1),
   标题 Varchar2(100),
   函数 Varchar2(100),
   内容 Varchar2(4000)
)Tablespace ZL9CISREC;

Alter Table RIS接口日志记录 Add Constraint RIS接口日志记录_PK Primary Key (ID) Using Index Pctfree 5 Tablespace zl9Indexcis;
Create Index RIS接口日志记录_IX_时间 On RIS接口日志记录(时间) Tablespace zl9Indexcis;
Create Sequence RIS接口日志记录_ID Start With 1;


--91776:蔡青松,2016-05-27,新增批量签收功能
alter table 病人医嘱发送 add 标本发送批号 number(18);

Create Sequence 病人医嘱发送_标本发送批号 Start With 1;

Create Index 病人医嘱发送_IX_标本发送批号 On 病人医嘱发送(标本发送批号) Pctfree 5 Tablespace zl9Indexcis;

--96208:李小东,2016-05-16,部门人员最后修改时间修正
Alter Table 部门表 Add 最后修改时间 Date;

Alter Table 人员表 Add 最后修改时间 Date;

--83671:许华锋,2016-05-13,第三方功能接口配置
Create Table 影像插件挂接
(
  ID         Number(18),
  名称       Varchar2(30),
  版本       Varchar2(30),
  路径       Varchar2(100),
  程序集     Varchar2(100),
  执行类型   Number(1),
  是否启用   Number(1),
  所属模块   Number(18)
)TableSpace zl9BaseItem;

Alter Table 影像插件挂接 Add Constraint 影像插件挂接_PK Primary Key (ID) Using Index Tablespace zl9indexhis;
Alter Table 影像插件挂接 Add Constraint 影像插件挂接_UQ_名称 Unique (名称, 程序集) Using Index Tablespace zl9indexhis;

Create Table 影像插件功能
(
  ID         Number(18),
  插件ID     Number(18),
  功能序号   Number(3),
  名称       Varchar2(30),
  方法       Varchar2(500),
  方法参数   Varchar2(4000),
  是否启用   Number(1),
  VBS脚本    Varchar2(4000)
)TableSpace zl9BaseItem;


Alter Table 影像插件功能 Add Constraint 影像插件功能_PK Primary Key (ID) Using Index Tablespace zl9indexhis;
Alter Table 影像插件功能 Add Constraint 影像插件功能_UQ_插件ID Unique (插件ID, 功能序号) Using Index Tablespace zl9indexhis;
Alter Table 影像插件功能 Add Constraint 影像插件功能_FK_程序ID Foreign Key (插件ID) References 影像插件挂接(ID) On Delete Cascade;

--95610:涂建华,2016-05-11,调整影像报告驳回表的索引处理
Drop Index 影像报告驳回_IX_医嘱ID;

Alter Table 影像报告驳回 Add Constraint 影像报告驳回_FK_医嘱ID Foreign Key (医嘱ID,病历ID,检查报告ID) References 病人医嘱报告(医嘱ID,病历ID,检查报告ID) On Delete Cascade;
Create Index 影像报告驳回_IX_医嘱ID On 影像报告驳回(医嘱ID,病历ID,检查报告ID) Tablespace ZL9INDEXCIS;


--92837:马政,2016-05-10,出库单据库房信息中入库时间处理
create table 药品入库信息 
(
       药品id number(18),
       库房id number(18),
       批次 number(18),
       入库日期 date
) tablespace ZL9MEDLST;

Alter Table 药品入库信息 Add Constraint 药品入库信息_UQ_药品id Unique (药品id,库房id,批次) Using Index Tablespace zl9indexhis;
Alter Table 药品入库信息 Modify 药品id Constraint 药品入库信息_NN_药品id Not Null; 
Alter Table 药品入库信息 Modify 库房id Constraint 药品入库信息_NN_库房id Not Null; 

Alter Table 药品入库信息 Add Constraint 药品入库信息_FK_库房id Foreign Key (库房id) References 部门表(id);
Alter Table 药品入库信息 Add Constraint 药品入库信息_FK_药品id Foreign Key (药品id) References 收费项目目录(id);

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Alter Table 病人预交记录 Add 会话号 Varchar2(45);

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Create Table 药品设备接口(
  ID Number(18) Not Null, 
  编号 Varchar2(10) Not Null, 
  名称 Varchar2(20), 
  类型 Number(2), 
  启用日期 Date,
  停用日期 Date, 
  连接信息 Varchar2(2000), 
  扩展信息 Xmltype, 
  备注 Varchar2(200)
)
Tablespace Zl9medlst;

Create Sequence 药品设备接口_Id Start With 1;

Alter Table 药品设备接口 Add Constraint 药品设备接口_Pk Primary Key(ID) Using Index Tablespace Zl9indexhis;
Alter Table 药品设备接口 Add Constraint 药品设备接口_Uq_编号 Unique(编号) Using Index Tablespace Zl9indexhis;
Alter Table 药品设备接口 Add Constraint 药品设备接口_Uq_名称 Unique(名称) Using Index Tablespace Zl9indexhis;

Create Table 药品收发门诊标志(
  处方号 Varchar2(8), 
  单据 Number(2),
  库房ID Number(18),
  业务分类 Number(2), 
  标志 Number(2),
  待转出 Number(3)
) Initrans 20
Tablespace Zl9medlst;

Alter Table 药品收发门诊标志 Add Constraint 药品收发门诊标志_Pk Primary Key(处方号, 单据, 库房ID) Using Index Tablespace Zl9indexhis;
Alter Table 药品收发门诊标志 Add Constraint 药品收发门诊标志_Fk_库房id Foreign Key(库房id) References 部门表(ID);
Create Index 药品收发门诊标志_IX_待转出 ON 药品收发门诊标志(待转出) Tablespace Zl9indexhis;

Create Table 药品收发住院标志(
  收发ID NUMBER(18), 
  业务分类 Number(2), 
  标志 Number(2),
  待转出 Number(3)
) Initrans 20
Tablespace Zl9medlst;

Alter Table 药品收发住院标志 Add Constraint 药品收发住院标志_Pk Primary Key(收发ID, 业务分类) Using Index Tablespace Zl9indexhis;
Alter Table 药品收发住院标志 Add Constraint 药品收发住院标志_FK_收发ID Foreign Key(收发ID) References 药品收发记录(ID);
Create Index 药品收发住院标志_IX_待转出 ON 药品收发住院标志(待转出) Tablespace Zl9indexhis;


--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
ALTER TABLE 票据打印内容 ADD (打印类型 NUMBER(2)); 

--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
Create Global Temporary Table 临时票据打印内容(
  ID NUMBER(18),
  性质 NUMBER(3),
  NO VARCHAR2(8),
  开始票号 varchar2(50),
  领用ID number(18))
    ON COMMIT PRESERVE ROWS;


--94806:许华峰,2016-04-26,影像检查类别管理诊疗类型
Alter Table 影像检查类别 Add 诊疗类型 VARCHAR2(20);

--93317:李小东,2016-04-20,药品卫材验收结论处理
Create Table 入库验收结论
(
  编码   VARCHAR2(3),
  名称   VARCHAR2(100),
  缺省标志 NUMBER(1) default 0
)
tablespace ZL9BASEITEM;
alter table 药品收发记录 add 验收结论 varchar2(100);
alter table 药品验收明细 add 验收结论 varchar2(100);
alter table 入库验收结论 add constraint 入库验收结论_PK primary key (编码) using index tablespace ZL9INDEXHIS;
alter table 入库验收结论 add constraint 入库验收结论_UQ_名称 unique (名称) using index tablespace ZL9INDEXHIS;

--79038:梁唐彬,2015-07-10,停嘱医生填写实习医生
alter table 病人医嘱记录 modify (停嘱医生 VARCHAR2(201));

--95293:马政,2016-04-15,取消表索引
drop index 药品验收记录_IX_库房ID;

--94434:梁经伙,2016-04-12,增加字典表 路径上报变异原因 
Create Table 路径上报变异原因(
    编码       VARCHAR2(2),
    名称       VARCHAR2(80),
    简码       VARCHAR2(10),
    缺省标志   NUMBER(1) default 0)
    TABLESPACE zl9BaseItem;

Alter Table 路径上报变异原因 Add Constraint 路径上报变异原因_PK Primary Key (编码) Using Index Tablespace zl9Indexcis;

Alter Table 路径上报变异原因 Add Constraint 路径上报变异原因_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Table 部门扩展项目
(
  编码 Number(3),
  名称 Varchar2(20),
  是否图片  Number(1)
)TABLESPACE zl9BaseItem
 Cache Storage(Buffer_Pool Keep);

Create Table 部门扩展信息
(
  部门id Number(18),
  项目 Varchar2(20),
  内容 Varchar2(1000),
  图片 Blob
)TABLESPACE zl9BaseItem
 Cache Storage(Buffer_Pool Keep);

Create Table 人员扩展项目
(
  编码 Number(3),
  名称 Varchar2(20),
  是否图片  Number(1)
)TABLESPACE zl9BaseItem
 Cache Storage(Buffer_Pool Keep);

Create Table 人员扩展信息
(
  人员id Number(18),
  项目 Varchar2(20),
  内容 Varchar2(1000),
  图片 Blob
)TABLESPACE zl9BaseItem
Cache Storage(Buffer_Pool Keep);

Alter Table 部门表 Add 顺序 Number(3);

Alter Table 人员表 Add 顺序 Number(3);

Alter Table 部门扩展项目 Add Constraint 部门扩展项目_PK Primary Key (编码) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展项目 Add Constraint 部门扩展项目_UQ_名称 Unique (名称) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展信息 Add Constraint 部门扩展信息_UQ_部门id Unique (部门id,项目) Using Index Tablespace zl9indexhis;

Alter Table 部门扩展信息 Modify 项目 Constraint 部门扩展信息_NN_项目 Not Null;

Alter Table 人员扩展项目 Add Constraint 人员扩展项目_PK Primary Key (编码) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展项目 Add Constraint 人员扩展项目_UQ_名称 Unique (名称) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展信息 Add Constraint 人员扩展信息_UQ_人员id Unique (人员id,项目) Using Index Tablespace zl9indexhis;

Alter Table 人员扩展信息 Modify 项目 Constraint 人员扩展信息_NN_项目 Not Null;

Create Index 部门扩展信息_IX_项目 On 部门扩展信息(项目) Tablespace zl9Indexhis;

Create Index 人员扩展信息_IX_项目 On 人员扩展信息(项目) Tablespace zl9Indexhis;

Alter Table 部门扩展信息 Add Constraint 部门扩展信息_FK_部门id Foreign Key (部门id) References 部门表(id) On Delete Cascade;
Alter Table 部门扩展信息 Add Constraint 部门扩展信息_FK_项目 Foreign Key (项目) References 部门扩展项目(名称) On Delete Cascade;
Alter Table 人员扩展信息 Add Constraint 人员扩展信息_FK_人员id Foreign Key (人员id) References 人员表(id) On Delete Cascade;
Alter Table 人员扩展信息 Add Constraint 人员扩展信息_FK_项目 Foreign Key (项目) References 人员扩展项目(名称) On Delete Cascade;

--93444:刘尔旋,2016-04-06,机器名字段大小调整
Alter Table 挂号序号状态 Modify 机器名 varchar2(200);

--94851:涂建华,2016-04-05,Pacs文档编辑器词句或插件加载时机
Alter Table 影像报告原型清单 Add 词句加载时机 Number(1);
Alter Table 影像报告原型清单 Add 插件加载时机 Number(1);

--94427:刘尔旋,2016-03-29,医嘱发送生成条码接口
Alter Table 医疗卡类别 Add 发送调用接口 Number(3) Default 0;

--94361:张德婷,2016-03-22,添加配药批次脚本
alter table 输液配药记录 add  批次标记 number(1);

--94337:刘尔旋,2016-03-22,是否持卡消费
Alter Table 医疗卡类别 Add 是否持卡消费 Number(3) Default 1;

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Alter Table 疾病编码目录 Add 适用范围 Number(1); 
Alter Table 疾病诊断目录 Add 适用范围 Number(1); 

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------

--94777:胡俊勇,2016-06-12,申请单诊断
Declare
  n_编号   Number(18);
  n_分类id Number(18);
Begin
  Select Nvl(Max(ID), 0) Into n_分类id From 诊治所见分类 Where 名称 = '病人医嘱信息' And 性质 = 1;  
  If n_分类id <> 0 Then
    Select To_Number(Max(Substr(a.编码, Instr(a.编码, '-') + 1)))
    Into n_编号
    From (Select Max(编码) As 编码 From 诊治所见项目 Where 分类id = n_分类id) A;  
    n_编号 := Nvl(n_编号, 0) + 1; 
  
    Insert Into 诊治所见项目
      (ID, 分类id, 编码, 中文名, 英文名, 替换域, 类型, 长度, 小数, 单位, 临床意义, 表示法, 性别域, 数值域, 正常域, 初始值, 文字表述, 空值文字, 必填, 动态域)
      Select 诊治所见项目_Id.Nextval, n_分类id, '112-' || n_编号, '申请单诊断', 'SQDZD', 1, 1, 999, 0, Null, Null, 0, 0, Null, Null, Null,
             -null, Null, 0, -null
      From Dual
      Where Not Exists (Select 1 From 诊治所见项目 Where 分类id = n_分类id And 中文名 = '申请单诊断' And 替换域 = 1);
    If Sql%RowCount <> 0 Then
      n_编号 := n_编号 + 1;
    End If;
  End If;
End;
/      
     

--96744:梁经伙,2016-06-08,为表疾病申报反馈添加权限
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,6,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All
       Select '疾病申报反馈',5,1,-NULL From Dual Union All
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0) A;

--97263:胡俊勇,2016-06-08,医嘱申请单修改         
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 260, '启用申请单后必须使用申请单下达医嘱', '11', '11',
         '与(申请单启用环节)参数配合使用，在医嘱编辑界面必须使用申请单，用两位表示第1位表示门诊，第2位表示住院，0-未启用;1-启用。'
  From Dual
  Where Not Exists (Select 1
         From Zlparameters
         Where 参数名 = '启用申请单后必须使用申请单下达医嘱' And Nvl(模块, 0) = 0 And Nvl(系统, 0) = &n_System);
--97263:胡俊勇,2016-06-08,医嘱申请单修改   
Declare
  v_Old  Varchar2(100);
  v_New  Varchar2(100);
  v_Temp Varchar2(100);
Begin
  Select Max(参数值) Into v_Old From zlParameters Where 参数名 = '申请单启用环节';
  If Instr(v_Old, '|') = 0 And v_Old Is Not Null Then
    v_Temp := Substr(v_Old, 1, 1);
    If v_Temp = '1' Then
      v_New := '11';
    Else
      v_New := '00';
    End If;
    v_Temp := Substr(v_Old, 2, 1);
    If v_Temp = '1' Then
      v_New := v_New || '|11';
    Else
      v_New := v_New || '|00';
    End If;
    v_Temp := Substr(v_Old, 3, 1);
    If v_Temp = '1' Then
      v_New := v_New || '|11';
    Else
      v_New := v_New || '|00';
    End If;
    Update zlParameters
    Set 参数值 = v_New, 缺省值 = '11|11|11',
        参数说明 = '控制申请单启用环节，如果启用对应的申请单，则可用相应申请单下达医嘱；依次是：检查|检验|输血；门诊住院分开控制，参数格式－(11|11|11)竖线分割两位一个组合，第1位表示门诊，第2位表示住院'
    Where 参数名 = '申请单启用环节';
  End If;
End;
/    
--91998:冉俊明,2016-05-31,退费发票(红票)
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 108, '退费发票打印方式', Null, Null,
         '在病人收费管理中当退费完成后控制门诊医疗收据退费红票的打印。' || Chr(10) ||
          '格式:使用类别1,方式1|使用类别2,方式2|...；使用类别:普通病人,医保病人或...；方式:0-不打印,1-自动打印,2-选择是否打印'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '退费发票打印方式');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 109, '退费发票格式', Null, Null,
         '在病人收费管理中完成退费后,根据病人类型决定打印哪种门诊医疗票据(红票)。' || Chr(10) ||
          '格式:使用类别1,格式1|使用类别2,格式2|...；使用类别:普通病人,医保病人或...；格式:0或NULL:使用本地缺省格式，>0:票据格式序号'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '退费发票格式');
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1124, 0, 0, 0, 0, 17, '退费发票打印方式', Null, Null,
         '在保险补充结算中当退费完成后控制门诊医疗收据退费红票的打印。' || Chr(10) ||
          '格式:使用类别1,方式1|使用类别2,方式2|...；使用类别:普通病人,医保病人或...；方式:0-不打印,1-自动打印,2-选择是否打印'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1124 And 参数名 = '退费发票打印方式');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1124, 0, 0, 0, 0, 18, '退费发票格式', Null, Null,
         '在保险补充结算中完成退费后,根据病人类型决定打印哪种门诊医疗票据(红票)。' || Chr(10) ||
          '格式:使用类别1,格式1|使用类别2,格式2|...；使用类别:普通病人,医保病人或...；格式:0或NULL:使用本地缺省格式，>0:票据格式序号'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1124 And 参数名 = '退费发票格式');

--96182:许华锋,2016-05-30,RIS接口日志记录
Insert Into zlRegInfo(项目,行号,内容) Values ('记录专业版RIS日志',null,'0');

--92159:刘尔旋,2016-05-27,结帐作废红票
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 0, 0, 0, 0, 50, '作废发票打印方式', Null, Null,
         '在病人结帐管理中当作废完成后控制住院医疗收据或门诊医疗收据红票的打印'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1137 And 参数名 = '作废发票打印方式');
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 0, 0, 0, 0, 51, '作废发票格式', Null, Null,
         '在病人结帐管理中完成作废后,根据病人类型决定打印哪种住院医疗票据(红票)或门诊医疗票据(红票)'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1137 And 参数名 = '作废发票格式');

--96357:冉俊明,2016-05-26,门诊收费窗口按照执行科室进行分开收费
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 1, 0, 0, 107, '本机收费执行科室', Null, Null,
         '门诊收费窗口按照执行科室进行分开收费，设置了该参数的收费窗口只能收这些执行科室的单据费用，' || 
         '其它收费窗口除非也设置了这些执行科室，否则不能收这些执行科室的单据费用。' ||
         '格式：执行科室ID1,执行科室ID2,...'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '本机收费执行科室');

--93536:李南春,2016-05-23,自助费用查询数量、单价、金额显示位数
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1806, 0, 0, 0, 0, 8,'药品单位', Null, '0', '设置药品按哪种单位显示：0-售价单位,1-药房(门诊/住院)单位'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1806 And 参数名 = '药品单位');

--92161:刘尔旋,2016-05-23,预交款退款红票
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1103, 0, 0, 0, 0, 21, '预交退款打印方式', Null, Null,
         '在病人预交款管理中当退款完成后控制病人预交款收据红票的打印'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1103 And 参数名 = '预交退款打印方式');
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1103, 0, 0, 0, 0, 22, '退款发票格式', Null, Null,
         '在病人预交款管理中完成退款后,根据预交款类型决定打印哪种病人预交款收据(红票)'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1103 And 参数名 = '退款发票格式');

--96044:陈刘,2016-05-17,新增参数不同护理文件之间允许数据同步
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1255, 0, 0, 1, 0, 90, '允许数据同步', '1', '1',
         '当病人允许对应多份记录单时,此参数控制是否同步。0-不允许同步，1-允许同步。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1255 And 参数名 = '允许数据同步');

--96208:李小东,2016-05-16,部门人员最后修改时间修正
Update 部门表 Set 最后修改时间 = 建档时间;
Update 人员表 Set 最后修改时间 = 建档时间;

--83671:许华锋,2016-05-13,第三方功能接口配置
Insert Into 影像插件挂接(ID,名称,版本,路径,程序集,执行类型,是否启用,所属模块) Values
(1,'盈谷接口','6.0.1507.1401','C:\Program Files (x86)\iMAGES\Release\SpiderSightClient.exe','SpiderSightClient.exe',2,1,0);

Insert Into 影像插件功能(ID,插件ID,名称,方法,方法参数,是否启用,VBS脚本) Values
(1,1,'3D观片','C:\Program Files (x86)\iMAGES\Release\SpiderSightClient.exe','Command※字符串※accurad:///[OEM!DEFAULT][Version!DEFAULT][Customer!DEFAULT][Modality![[影像类别]]][App!SSCAMatrix][Plugin!SSCPViewer][UserName!10002:nanningsiyuan][Password!12345][ShareDataMode!true][StoreData!NULL][DB_PatientID![[病人ID]]][SSServerIP!www.imagesopen.cn][SSServerPort!60000]',1,
'Sub ExcuteSub()
    Dim objExecute
                
    Set objExecute = CreateObject("wscript.shell")
    Call objExecute.exec ("C:\Program Files (x86)\iMAGES\Release\SpiderSightClient.exe accurad:///[OEM!DEFAULT][Version!DEFAULT][Customer!DEFAULT][Modality![[影像类别]]][App!SSCAMatrix][Plugin!SSCPViewer][UserName!10002:nanningsiyuan][Password!12345][ShareDataMode!true][StoreData!NULL][DB_PatientID![[病人ID]]][SSServerIP!www.imagesopen.cn][SSServerPort!60000]")
End Sub');

--95875:张德婷,2016-05-11,输液配置中心当天的输液单到备用批次
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 0, 0, 36,'当天发送的医嘱产生的输液单全部到备用批次', Null, '0', '此参数勾选之后，当天发送的医嘱产生的输液单全部到备用批次'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1345 And 参数名 = '当天发送的医嘱产生的输液单全部到备用批次');

--87413:梁唐彬,2015-08-13,检验医嘱单独产生单据
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1254, 0, 0, 0, 0, 74, '检验医嘱单独产生单据', '0', '0',
         '住院检验医嘱发送时，根据医院管理要求，决定检验医嘱是否每一条都单独产生单据。0-根据条码规则产生单据号;1-每一组检验医嘱单独产生单据号。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1254 And 参数名 = '检验医嘱单独产生单据');
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1252, 0, 0, 0, 0, 55, '检验医嘱单独产生单据', '0', '0',
         '门诊检验医嘱发送时，根据医院管理要求，决定检验医嘱是否每一条都单独产生单据。0-根据条码规则产生单据号;1-每一组检验医嘱单独产生单据号。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1252 And 参数名 = '检验医嘱单独产生单据');

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,2,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All 
  Select '药品收发门诊标志',8,1,-Null From Dual Union All 
  Select '药品收发住院标志',9,1,-Null From Dual Union All 
Select 表名,序号,直接转出,停用触发器 From ZLBAKTABLES Where 1 = 0) A;

Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(9010,'药品自动化设备接口','药品自动化设备接口的虚拟模块',&n_System,'zlDrugMachine');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 9010, 0, 0, 0, 0, 1, '启用药品自动化设备接口', '0', '0',
         '是否启用药品自动化设备接口向第三方接口提供ZLHIS数据。0-不启用；1-启用'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '启用药品自动化设备接口' And 模块 = 9010 And 系统 = &n_System);
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 9010, 0, 0, 0, 0, 2, '启用信息交互平台', '0|', '0|',
         '启用时，本参数确定接口是否走信息交互平台与第三方接口交互。竖线左：0-不启用；1-启用。竖线右：信息交互平台的WebService地址'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '启用信息交互平台' And 模块 = 9010 And 系统 = &n_System);
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 9010, 0, 0, 0, 0, 3, '信息交互平台密钥', '', '',
         '信息交互平台密钥'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '信息交互平台密钥' And 模块 = 9010 And 系统 = &n_System);
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 9010, 0, 0, 0, 0, 4, '信息交互平台令牌', '', '', '信息交互平台令牌'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '信息交互平台令牌' And 模块 = 9010 And 系统 = &n_System);

--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 105,'按病人补打发票格式', Null, '0|0', '1)在病人收费管理中按病人补打发票时，根据病人类型决定打印哪种门诊医疗票据' || chr(10) || '2)补打时调用报表:zl1_BILL_1121_1'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '按病人补打发票格式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 106,'按病人补打发票不区分结算次数', Null, '0', '按病人补打发票时，不根据结算次数进行发票打印'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '按病人补打发票不区分结算次数');

--93317:李小东,2016-04-20,药品卫材验收结论处理
Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '入库验收结论', 0, '对入库产品检查验收的记录', '药品管理');

--93917:许华峰,2016-04-15,与RIS的数据交换接口脚本
Update zlComponent Set 次版本 = 34, 附版本 = 70, 注册产品名称 = '中联医学影像系统', 注册产品简名 = 'ZLPACS', 注册产品版本 = '10.9.0' Where 部件 = 'zl9XWInterface' And 系统 = &n_System;

--94434:梁经伙,2016-04-12,增加字典表 路径上报变异原因 
Insert Into zlBaseCode
  (系统, 表名, 固定, 说明, 分类)
  Select &n_System, '路径上报变异原因', 0, '住院首页,临床路径的变异原因', '医疗工作'
  From Dual
  Where Not Exists (Select 1 From zlBaseCode Where 系统 =&n_System and  表名 = '路径上报变异原因');

--94434:梁经伙,2016-04-12,增加参数 路径变异原因从字典表中选取 
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, 0, 0, 0, 0, 259,'路径变异原因从字典表中选取', '0', '0',  '此参数开启后，四川版，云南版的住院首页的临床路径的变异原因将不能够自动提取出来，只能从字典表路径上报变异原因中进行选择，并且不能够自由录入。0-不启用，1-启用'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And Nvl(模块,0) = 0 And 参数名 = '路径变异原因从字典表中选取');

--94980:余智勇,2016-04-08,移动循环呼叫病人
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1264, 0, 1, 0, 0, 13, '移动呼叫', '0', '0',
         '此参数开启后，门诊输液管理定时循环呼叫移动业务的病人；0-不呼叫，1-呼叫'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '移动呼叫' And 模块 = 1264 And 系统 = &n_System);

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '部门扩展项目', 0, '部门扩展项目说明', '部门属性');

Insert Into zlBaseCode(系统, 表名, 固定, 说明, 分类) Values (&n_System, '人员扩展项目', 0, '人员扩展项目说明', '人员属性');

--95546:马政,2016-04-08,领用不明确批次修改
Insert Into zlParameters
  (ID, 系统, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 258, '按批次领用卫生材料', '0', '1', '当该参数启用之后，领用时要确定具体批次，否则不用确定具体批次 0-不启用，1-启用'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 参数名 = '按批次领用卫生材料' And 模块 Is Null);

--82730:梁唐彬,2015-04-30,申请附项支持单选
Insert Into 诊治所见性质
  (编码, 名称, 简码, 固定)
  Select '6', '申请附项', 'SQFX', 0
  From Dual
  Where Not Exists (Select 1 From 诊治所见性质 Where 名称 = '申请附项' And 编码 = '6');


--90335:李南春,2016-04-01,控制自助缴费读取划价单的时间范围
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1805, 0, 0, 0, 0, 24,'显示N天内的划价单', '', '0', '控制自助缴费读取划价单的时间范围'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1805 And 参数名 = '显示N天内的划价单');


--92837:李业庆,2016-06-29,出库单据库房信息中入库时间处理
Insert Into 药品入库信息
  (药品id, 库房id, 批次, 入库日期)
  Select b.药品id, b.库房id, b.批次, Min(审核日期)
  From 药品收发记录 A, 药品库存 B, 药品规格 C
  Where a.药品id = b.药品id And a.库房id = b.库房id And Nvl(a.批次, 0) = Nvl(b.批次, 0) And a.入出系数 = 1 And a.审核日期 Is Not Null And
        b.药品id = c.药品id And b.性质 = 1
  Group By b.药品id, b.库房id, b.批次;


-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--96744:梁经伙,2016-06-08,为表疾病申报反馈添加权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1260,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
       Select '疾病申报反馈','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1261,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
       Select '疾病申报反馈','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
       Select '疾病申报反馈','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1278,'报送',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'zl_疾病申报反馈_insert','EXECUTE' From Dual Union All
  Select 'Zl_疾病申报反馈_Update','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,9001,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_疾病阳性记录_Delete','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--97187:胡俊勇,2016-06-06,医嘱发送
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1252,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '影像检查项目','SELECT' From Dual Union All     
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1253,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '影像检查项目','SELECT' From Dual Union All     
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1254,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '影像检查项目','SELECT' From Dual Union All     
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--94434:梁经伙,2016-06-06,为表 路径上报变异原因 增加权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1261,'首页整理',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '路径上报变异原因','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--96182:许华锋,2016-05-30,RIS接口日志记录
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1287,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'RIS接口日志记录','SELECT' From Dual Union All
  Select 'zl_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--95543:冉俊明,2016-05-25,按病人补打发票不区分结算次数
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, '票据打印内容_ID', 'Select'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('票据打印内容_ID'));

--92837:马政,2016-05-10,出库单据库房信息中入库时间处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1300, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1300 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1301, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1301 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));       

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1302, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1302 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));   

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1304, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1304 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));    

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1305, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1305 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1306, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1306 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));    

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1307, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1307 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));     

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1309, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1309 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));   

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1330, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1330 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));                                                          

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1331, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1331 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息')); 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1333, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1333 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));     

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1343, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1343 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息'));      

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1344, '基本', User, '药品入库信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1344 And 功能 = '基本' And Upper(对象) = Upper('药品入库信息')); 

--91055:张德婷,2016-05-23,瓶签报表添加权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1345, '基本', User, 'zl_GetSysParameter', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1345 And 功能 = '基本' And 对象 = 'zl_GetSysParameter');

--83671:许华锋,2016-05-13,第三方功能接口配置
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, '影像插件挂接', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('影像插件挂接'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, '影像插件功能', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('影像插件功能'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, '影像插件挂接', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('影像插件挂接'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, '影像插件功能', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('影像插件功能'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, '影像插件挂接', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('影像插件挂接'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, '影像插件功能', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('影像插件功能'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像插件挂接_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Update'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像插件功能_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Update'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像插件挂接_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Delete')); 
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像插件功能_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Delete')); 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'ZL_影像插件挂接_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Update'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'ZL_影像插件功能_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Update'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'ZL_影像插件挂接_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Delete')); 
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'ZL_影像插件功能_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Delete')); 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'ZL_影像插件挂接_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Update'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'ZL_影像插件功能_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Update'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'ZL_影像插件挂接_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件挂接_Delete')); 
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'ZL_影像插件功能_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像插件功能_Delete')); 

--91700:马政,2016-05-10,新增权限控制上次供应商列的显示
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1725, '查看供应商', 11, '有此权限时在卫材申购管理中新增、修改、审核、查看中都能看到上次供应商列，无此权限时不能看到此列', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1725 And 功能 = '查看供应商');
  
--91700:马政,2016-05-10,新增权限控制上次供应商列的显示
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select Distinct 系统, 序号, 角色, '查看供应商' 功能 From zlRoleGrant Where 系统 = &n_System And 序号 = 1725;

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,9010,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
  Select '参数设置',1,'进行参数设定',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9010,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '部门表','SELECT' From Dual Union All
  Select '药品设备接口','SELECT' From Dual Union All
  Select '药品剂型','SELECT' From Dual Union All
  Select '部门性质说明','SELECT' From Dual Union All
  Select '部门性质分类','SELECT' From Dual Union All
  Select '人员性质分类','SELECT' From Dual Union All
  Select '人员性质说明','SELECT' From Dual Union All
  Select '人员表','SELECT' From Dual Union All
  Select '上机人员表','SELECT' From Dual Union All
  Select '部门人员','SELECT' From Dual Union All
  Select '药品收发记录','SELECT' From Dual Union All
  Select '药品收发门诊标志','SELECT' From Dual Union All
  Select '药品收发住院标志','SELECT' From Dual Union All
  Select '收费项目目录','SELECT' From Dual Union All
  Select '收费项目别名','SELECT' From Dual Union All
  Select '药品规格','SELECT' From Dual Union All
  Select '药品特性','SELECT' From Dual Union All
  Select '诊疗项目目录','SELECT' From Dual Union All
  Select '药品生产商','SELECT' From Dual Union All
  Select '诊疗项目别名','SELECT' From Dual Union All
  Select '药品库存','SELECT' From Dual Union All
  Select '药品储备限额','SELECT' From Dual Union All
  Select '供应商','SELECT' From Dual Union All
  Select '发药窗口','SELECT' From Dual Union All
  Select '门诊费用记录','SELECT' From Dual Union All
  Select '病人信息','SELECT' From Dual Union All
  Select '身份','SELECT' From Dual Union All
  Select '病人医嘱记录','SELECT' From Dual Union All
  Select '病人诊断医嘱','SELECT' From Dual Union All
  Select '病人诊断记录','SELECT' From Dual Union All
  Select '住院费用记录','SELECT' From Dual Union All
  Select '病人医嘱发送','SELECT' From Dual Union All
  Select '医嘱执行时间','SELECT' From Dual Union All
  Select 'ZL_药品设备接口_UPDATE','EXECUTE' From Dual Union All
  Select 'ZL_药品设备接口_STATE','EXECUTE' From Dual Union All
  Select 'ZL_药品设备接口_DELETE','EXECUTE' From Dual Union All
  Select 'ZL_FUN_DRUG_MACHINE','EXECUTE' From Dual Union All
  Select 'ZL_未发药品记录_分配发药窗口','EXECUTE' From Dual Union All
  Select 'ZL_药品收发门诊标志_FLAG','EXECUTE' From Dual Union All
  Select 'ZL_药品收发住院标志_FLAG','EXECUTE' From Dual Union All
  Select 'ZL_DRUG_MAC_WIN','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--95543:刘兴洪,2016-05-09,按病人补打发票时不按结算次数打印
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, '临时票据打印内容', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('临时票据打印内容'));  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, 'Zl_临时票据打印内容_Insert', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('Zl_临时票据打印内容_Insert'));  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, 'Zl_临时票据打印内容_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('Zl_临时票据打印内容_Delete'));  

--95074:许华峰,2016-04-25,PACS依赖性接口模块关联病人管理公共模块
--9004:PACS公共模块
Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,9004,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9003,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From ZLMODULERELAS Where 1 = 0) A;

--95071:许华峰,2016-04-25,排队叫号消息内容获取
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1160, '基本', User, 'zl_排队消息_XML内容获取', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1160 And 功能 = '基本' And Upper(对象) = Upper('zl_排队消息_XML内容获取'));

--93317:李小东,2016-04-20,药品卫材验收结论处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1300, '基本', User, '入库验收结论', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1300 And 功能 = '基本' And Upper(对象) = Upper('入库验收结论'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1348, '基本', User, '入库验收结论', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1348 And 功能 = '基本' And Upper(对象) = Upper('入库验收结论'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1712, '基本', User, '入库验收结论', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1712 And 功能 = '基本' And Upper(对象) = Upper('入库验收结论'));

--95353:许华峰,2016-04-19,影像后台采集优化
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '图像关联', User, 'Zl_影像检查_图像导入', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '图像关联' And Upper(对象) = Upper('Zl_影像检查_图像导入'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '图像关联', User, 'Zl_影像检查_图像导入', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1291 And 功能 = '图像关联' And Upper(对象) = Upper('Zl_影像检查_图像导入'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '图像关联', User, 'Zl_影像检查_图像导出', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '图像关联' And Upper(对象) = Upper('Zl_影像检查_图像导出'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '图像关联', User, 'Zl_影像检查_图像导出', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1294 And 功能 = '图像关联' And Upper(对象) = Upper('Zl_影像检查_图像导出'));

--93299:刘尔旋,2016-04-07,结帐三方卡处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1137, '住院费用结帐', User, 'Zl_结帐预交记录_三方退款', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1137 And 功能 = '住院费用结帐' And Upper(对象) = Upper('Zl_结帐预交记录_三方退款'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1137, '门诊费用结帐', User, 'Zl_结帐预交记录_三方退款', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1137 And 功能 = '门诊费用结帐' And Upper(对象) = Upper('Zl_结帐预交记录_三方退款'));


--95290:胡俊勇,2016-04-18,权限处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'Zl1_Fun_Getreturnvisit', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And Upper(对象) = Upper('Zl1_Fun_Getreturnvisit'));    
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1261, '基本', User, 'Zl1_Fun_Getreturnvisit', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1261 And 功能 = '基本' And Upper(对象) = Upper('Zl1_Fun_Getreturnvisit'));  

--95125:余伟节,2016-04-15,删除新生儿登记检查
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1132, '新生儿登记', User, '病人护理文件', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1132 And 功能 = '新生儿登记' And Upper(对象) = Upper('病人护理文件'));
--95090:刘尔旋,2016-04-12,结帐仅使用预交
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1137, '仅用预交结帐', 23, '有此权限时,不允许使用其他方式结帐也不能退款,只能用预交款进行结帐', 0
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1137 And 功能 = '仅用预交结帐');

--95076:余伟节,2016-04-11,病人地址信息结构化
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, '病人地址信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1101 And 功能 = '基本' And Upper(对象) = Upper('病人地址信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, 'ZL_病人地址信息_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1101 And 功能 = '基本' And Upper(对象) = Upper('ZL_病人地址信息_UPDATE'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1101 And 功能 = '基本' And Upper(对象) = Upper('Zl_Adderss_Structure'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '病人地址信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And Upper(对象) = Upper('病人地址信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'ZL_病人地址信息_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And Upper(对象) = Upper('ZL_病人地址信息_UPDATE'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'Zl_Adderss_Structure', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And Upper(对象) = Upper('Zl_Adderss_Structure'));

--95041:李南春,2016-04-11,病人地址信息查询权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '基本', User, '病人地址信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '基本' And Upper(对象) = Upper('病人地址信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, '病人地址信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1111 And 功能 = '基本' And Upper(对象) = Upper('病人地址信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1113, '病案修改', User, '病人地址信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1113 And 功能 = '病案修改' And Upper(对象) = Upper('病人地址信息'));

--95035:刘尔旋,2016-04-11,财务组组长构成权限缺失
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1500, '基本', User, '财务组组长构成', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1500 And 功能 = '基本' And Upper(对象) = Upper('财务组组长构成'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1506, '基本', User, '财务组组长构成', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1506 And 功能 = '基本' And Upper(对象) = Upper('财务组组长构成'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1507, '基本', User, '财务组组长构成', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1507 And 功能 = '基本' And Upper(对象) = Upper('财务组组长构成'));

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1001, '扩展信息维护', 3, '有此权限时能对部门扩展信息进行维护', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1001 And 功能 = '扩展信息维护');

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1002, '扩展信息维护', 7, '有此权限时能对人员扩展信息进行维护', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1002 And 功能 = '扩展信息维护');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, '部门扩展项目', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1001 And 功能 = '基本' And Upper(对象) = Upper('部门扩展项目'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, '部门扩展信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1001 And 功能 = '基本' And Upper(对象) = Upper('部门扩展信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1001, '基本', User, 'Zl_Lob_Read', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1001 And 功能 = '基本' And Upper(对象) = Upper('Zl_Lob_Read'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, '人员扩展项目', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1002 And 功能 = '基本' And Upper(对象) = Upper('人员扩展项目'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, '人员扩展信息', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1002 And 功能 = '基本' And Upper(对象) = Upper('人员扩展信息'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, 'Zl_Lob_Read', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1002 And 功能 = '基本' And Upper(对象) = Upper('Zl_Lob_Read'));

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1001,'扩展信息维护',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
Select 'Zl_部门扩展信息_Insert','EXECUTE' From Dual Union All
Select 'Zl_部门扩展信息_Delete','EXECUTE' From Dual Union All
Select '部门扩展信息','UPDATE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1002,'扩展信息维护',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'Zl_Lob_Append','EXECUTE' From Dual Union All
Select 'Zl_Lob_Read','EXECUTE' From Dual Union All
Select 'Zl_人员扩展信息_Insert','EXECUTE' From Dual Union All
Select 'Zl_人员扩展信息_Delete','EXECUTE' From Dual Union All
Select '人员扩展信息','UPDATE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--94941:李南春,2016-04-07,医疗卡发卡是否允许修改病人门诊号
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1107, '允许修改门诊号', 16, '对病人门诊号进行修改的权限。', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1107 And 功能 = '允许修改门诊号');

--90696:余伟节,2016-04-05,允许修改门诊号
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1101,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '允许修改门诊号',21,'新增、修改病人信息时允许修改门诊号',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--94400:余伟节,2016-03-30,入院管理增加全院预约权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1131,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '全院预约',26,'如果没有权限则只能对当前操作员所在科室/病区对应的科室进行预约',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--94311:张德婷,2016-03-22,对出院病人和已结账病人操作进行权限控制
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1345,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '发退出院病人处方',2,'已经出院的病人还可以发退药',0 From Dual Union All
Select '退已结帐处方',2,'已经结账的病人可以退药',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--95040:余伟节,2016-04-11,预约登记权限调整
Delete From Zlprogrelas Where Nvl(系统, 0) = &n_System And 序号 = 1131 And 组号 = 1 And 功能 = '保险病人登记';
Delete From Zlprogrelas Where Nvl(系统, 0) = &n_System And 序号 = 1131 And 组号 = 1 And 功能 = '允许非医保病人';
Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
Select  &n_System,1131,3,A.* From (
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
Select '预约登记',2,1,0 From Dual Union All
Select '办理登记',2,1,0 From Dual Union All
Select '保险病人登记',2,0,0 From Dual Union All
Select '允许非医保病人',2,0,0 From Dual Union All
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A;

--95090:刘尔旋,2016-04-12,结帐仅使用预交
Insert Into ZlProgrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1137, 2, '仅用预交结帐', 2, 0, 0
  From Dual
  Where Not Exists
   (Select 1 From Zlprogrelas Where 系统 = &n_System And 序号 = 1137 And 功能 = '仅用预交结帐' And 组号 = 2);


--94086:刘尔旋,2016-04-07,收费号与免费号分开挂
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select 系统, 序号, '挂收费号', 排列, '给病人挂收费号的操作权限。有该权限时，允许对病人进行挂费用不为0的号', 缺省值
  From zlProgFuncs
  Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Update Zlprogrelas Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Update zlProgPrivs Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Insert Into zlProgPrivs
  (系统, 序号, 功能, 对象, 所有者, 权限)
  Select 系统, 序号, '挂免费号', 对象, 所有者, 权限
  From zlProgPrivs
  Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂收费号';

Update zlRoleGrant Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Delete From zlProgFuncs Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

--95988:余智勇,2016-05-09,支持药品自动化设备接口
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1341, Null, &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists
   (Select 1 From Zlmodulerelas Where 系统 = &n_System And 模块 = 1341 And 相关模块 = 9010 And 相关功能 = '基本');

--96310:李南春,2016-05-17,自助缴费调用包药机
Insert Into zlModuleRelas
  (系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
  Select &n_System, 1805, '基本', &n_System, 9010, 0, '基本', 1
  From Dual
  Where Not Exists (Select 1
         From zlModuleRelas
         Where 系统 = &n_System And 模块 = 1805 And 功能 = '基本' And 相关模块 = 9010 And 相关功能 = '基本');

--96236:冉俊明,2016-05-24,支持药品自动化设备接口
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1121, '门诊收费', &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists (Select 1
         From Zlmodulerelas
         Where 系统 = &n_System And 模块 = 1121 And 功能 = '门诊收费' And 相关模块 = 9010 And 相关功能 = '基本');
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1121, '门诊退费', &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists (Select 1
         From Zlmodulerelas
         Where 系统 = &n_System And 模块 = 1121 And 功能 = '门诊退费' And 相关模块 = 9010 And 相关功能 = '基本');
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1124, '结算退费', &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists (Select 1
         From Zlmodulerelas
         Where 系统 = &n_System And 模块 = 1124 And 功能 = '结算退费' And 相关模块 = 9010 And 相关功能 = '基本');
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1151, '基本', &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists (Select 1
         From Zlmodulerelas
         Where 系统 = &n_System And 模块 = 1151 And 功能 = '基本' And 相关模块 = 9010 And 相关功能 = '基本');

--96819:李业庆,2016-05-25,部门发药和药品自动化设备接口模块关系
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1342, NULL, &n_System, 9010, 0, '基本', 0
  From Dual
  Where Not Exists
   (Select 1 From Zlmodulerelas Where 系统 = &n_System And 模块 = 1342 And 相关模块 = 9010 And 相关功能 = '基本');

--96740:李业庆,2016-05-25,人员信息RIS接口
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1002, '基本', User, '部门性质说明', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1002 And 功能 = '基本' And Upper(对象) = Upper('部门性质说明'));

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------
--97030:梁经伙,2016-06-12,增加传染病阳性反馈报表

--报表：ZL1_INSIDE_1278_1/传染病阳性反馈单
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1278_1','传染病阳性反馈单',Null,'Mv:d>b`xd)5[qki7O:TW',Null,15,0,0,100,Null,Null,Sysdate,Null,To_Date('2016-06-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-06-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'传染病阳性反馈单1',11904,16832,9,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'反馈单','ID,131|来源,130|病人ID,131|姓名,202|性别,202|年龄,202|科室,202|标识号,131|床号名,202|床号线,202|床号,202|送检时间,135|送检医生,202|检查时间,135|送检科室,202|标本名称,202|反馈结果,202|疑似疾病,202|病情,202|登记人,202|登记时间,135|登记科室,202|处理人,202|处理时间,135|处理情况说明,202',User||'.疾病阳性记录,'||User||'.病人挂号记录,'||User||'.病案主页,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select a.Id, a.来源, a.病人id, a.姓名, a.性别, a.年龄, e.名称 As 科室, a.标识号,decode(a.来源,''住 院 号'',''床    号'','''') as 床号名,decode(a.来源,''住 院 号'',''____________'','''') as 床号线,a.床号, a.送检时间, a.送检医生, a.检查时间, f.名称 As 送检科室,' From Dual Union All
  Select 2,'       a.标本名称, nvl(a.反馈结果,'' '') as 反馈结果, a.传染病名称 As 疑似疾病, a.病情, a.登记人, a.登记时间, g.名称 As 登记科室, a.处理人, a.处理时间, nvl(a.处理情况说明,'' '') as 处理情况说明' From Dual Union All
  Select 3,'From (Select a.Id, ''门 诊 号'' As 来源, a.病人id, b.姓名, b.性别, b.年龄, b.门诊号 As 标识号,  Null As 床号, a.送检时间, a.送检医生,' From Dual Union All
  Select 4,'              a.送检科室id, a.检查时间, a.标本名称, a.反馈结果, a.传染病名称, Null As 病情, a.登记人, a.登记时间, a.登记科室id, a.处理人, a.处理时间, a.处理情况说明,' From Dual Union All
  Select 5,'              b.执行部门id As 科室id' From Dual Union All
  Select 6,'       From 疾病阳性记录 A, 病人挂号记录 B' From Dual Union All
  Select 7,'       Where a.病人id = b.病人id And a.挂号单 = b.No And a.Id = [0]' From Dual Union All
  Select 8,'       Union All' From Dual Union All
  Select 9,'       Select a.Id, ''住 院 号'' As 来源, a.病人id, c.姓名, c.性别, c.年龄, c.住院号 As 标识号,  c.出院病床 As 床号, a.送检时间, a.送检医生,' From Dual Union All
  Select 10,'              a.送检科室id, a.检查时间, a.标本名称, a.反馈结果, a.传染病名称, c.当前病况 As 病情, a.登记人, a.登记时间, a.登记科室id, a.处理人, a.处理时间, a.处理情况说明,' From Dual Union All
  Select 11,'              c.出院科室id As 科室id' From Dual Union All
  Select 12,'       From 疾病阳性记录 A, 病案主页 C' From Dual Union All
  Select 13,'       Where a.病人id = c.病人id And a.主页id = c.主页id And a.Id = [0]) A, 部门表 E, 部门表 F, 部门表 G' From Dual Union All
  Select 14,'Where a.送检科室id = f.Id(+) And a.科室id = e.Id(+) And a.登记科室id = g.Id(+)' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'反馈单ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条2',1,Null,0,Null,0,Null,Null,1757,1875,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条6',1,Null,0,Null,0,Null,Null,1757,2442,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条11',1,Null,0,Null,0,Null,Null,1757,3009,1814,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条12',1,Null,0,Null,0,Null,Null,1757,3576,1814,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条14',1,Null,0,Null,0,Null,Null,1757,6240,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条1',1,Null,0,Null,0,Null,Null,3495,960,4635,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条3',1,Null,0,Null,0,Null,Null,4183,1875,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条7',1,Null,0,Null,0,Null,Null,4183,2442,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条10',1,Null,0,Null,0,Null,Null,4690,3009,1814,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条13',1,Null,0,Null,0,Null,Null,4690,3576,1814,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条4',1,Null,0,Null,0,Null,Null,6609,1875,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条9',1,Null,0,Null,0,Null,Null,7616,3009,1814,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条15',1,Null,0,Null,0,Null,Null,8447,6410,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条16',1,Null,0,Null,0,Null,Null,8447,6977,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条17',1,Null,0,Null,0,Null,Null,8447,7559,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条18',1,Null,0,Null,0,Null,Null,8447,10394,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条19',1,Null,0,Null,0,Null,Null,8447,10961,1984,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条5',1,Null,0,Null,0,Null,Null,9035,1875,1134,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,Null,0,'姓    名',Null,900,1635,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,Null,0,'科    室',Null,900,2205,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签9',2,Null,0,Null,0,'送检时间',Null,900,2760,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签12',2,Null,0,Null,0,'检查时间',Null,900,3330,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签14',2,Null,0,Null,0,'反馈结果',Null,900,3975,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签15',2,Null,0,Null,0,'疑似疾病',Null,900,6000,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签19',2,Null,0,Null,0,'处理情况',Null,900,7980,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签35',2,Null,0,Null,0,'[反馈单.疑似疾病]',Null,1830,6000,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签23',2,Null,0,Null,0,'[反馈单.姓名]',Null,1845,1620,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签26',2,Null,0,Null,0,'[反馈单.科室]',Null,1845,2190,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签31',2,Null,0,Null,0,'[反馈单.送检时间]',Null,1845,2760,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,'YYYY-MM-DD HH:mm',Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签32',2,Null,0,Null,0,'[反馈单.检查时间]',Null,1845,3330,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,'YYYY-MM-DD HH:mm',Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签34',2,Null,0,Null,0,'[反馈单.反馈结果]',Null,1875,3960,8490,1740,0,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签39',2,Null,0,Null,0,'[反馈单.处理情况说明]',Null,1890,7980,8490,1740,0,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,Null,0,'[反馈单.来源]',Null,3330,2205,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,Null,0,'性    别',Null,3333,1635,840,210,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,Null,0,'传染病阳性结果反馈单',Null,3525,465,4479,450,0,0,1,'宋体',22,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签10',2,Null,0,Null,0,'送检科室',Null,3840,2760,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签13',2,Null,0,Null,0,'标本名称',Null,3840,3330,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签24',2,Null,0,Null,0,'[反馈单.性别]',Null,4275,1635,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签27',2,Null,0,Null,0,'[反馈单.标识号]',Null,4275,2205,1575,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签30',2,Null,0,Null,0,'[反馈单.送检科室]',Null,4785,2775,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签33',2,Null,0,Null,0,'[反馈单.标本名称]',Null,4785,3330,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,Null,0,'年    龄',Null,5759,1635,840,210,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签8',2,Null,0,Null,0,'[反馈单.床号名]',Null,5760,2190,1575,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签42',2,Null,0,Null,0,'[反馈单.床号线]',Null,6645,2250,1701,225,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签25',2,Null,0,Null,0,'[反馈单.年龄]',Null,6690,1620,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签28',2,Null,0,Null,0,'[反馈单.床号]',Null,6690,2190,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签11',2,Null,0,Null,0,'送检医生',Null,6765,2760,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签17',2,Null,0,Null,0,'登记科室',Null,7605,6735,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签18',2,Null,0,Null,0,'登记时间',Null,7605,7305,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签20',2,Null,0,Null,0,'确认医师',Null,7605,10140,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签21',2,Null,0,Null,0,'处理时间',Null,7605,10710,840,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签29',2,Null,0,Null,0,'[反馈单.送检医生]',Null,7695,2760,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签16',2,Null,0,Null,0,'登记人',Null,7815,6165,630,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,Null,0,'病    情',Null,8185,1635,840,210,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签36',2,Null,0,Null,0,'[反馈单.登记人]',Null,8520,6165,1575,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签37',2,Null,0,Null,0,'[反馈单.登记科室]',Null,8520,6720,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签38',2,Null,0,Null,0,'[反馈单.登记时间]',Null,8520,7290,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,'YYYY-MM-DD HH:mm',Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签40',2,Null,0,Null,0,'[反馈单.处理人]',Null,8520,10140,1575,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签41',2,Null,0,Null,0,'[反馈单.处理时间]',Null,8520,10710,1785,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,'YYYY-MM-DD HH:mm',Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签22',2,Null,0,Null,0,'[反馈单.病情]',Null,9120,1620,1365,225,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);

--报表：ZL1_INSIDE_1278_1/传染病阳性反馈单
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1278,'传染病阳性反馈单','对病人的阳性检测结果进行处理的反馈单');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1278,'传染病阳性反馈单',User,'疾病阳性记录','SELECT' From Dual Union All
  Select 100,1278,'传染病阳性反馈单',User,'病人挂号记录','SELECT' From Dual Union All
  Select 100,1278,'传染病阳性反馈单',User,'病案主页','SELECT' From Dual Union All
  Select 100,1278,'传染病阳性反馈单',User,'部门表','SELECT' From Dual ;



--91998:冉俊明,2016-05-31,退费发票(红票)

--报表：ZL1_BILL_1121_7/门诊医疗费收据(红票)
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1121_7','门诊医疗费收据(红票)','退费收据(红票)打印','C~!`T6ro,7Cc<ymU8[T',Null,Null,1,&n_System,Null,Null,Sysdate,Sysdate,Null,To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,&n_System,1121,'门诊医疗费收据(红票)');
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'门诊医疗费收据(红票)',0,12191,5443,256,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费汇总','页号,139|NO,202|姓名,202|性别,202|年龄,202|来源,202|操作员编号,202|操作员姓名,202|日期,202|合计,139|大写,202',User||'.病人预交记录,'||User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--1.票据号使用固定标签获取,内容中填写[票据号]即可' From Dual Union All
  Select 2,'--2.缺省按收据费目汇总打印,汇总时因为有医保部分退费重收,因此不管记录状态' From Dual Union All
  Select 3,'--3.明细不读取工本费用，如果收取了工本费，使用固定标签获取加到合计上' From Dual Union All
  Select 4,'--4.按每页3行设计并取数' From Dual Union All
  Select 5,'--子表A：根据收据行次设置及单据中的收据费目,返回每张票据的汇总金额' From Dual Union All
  Select 6,'--子表B：返回单据中的病人信息' From Dual Union All
  Select 7,Null From Dual Union All
  Select 8,'Select a.页号, b.NO, b.姓名, b.性别, b.年龄, b.来源, b.操作员编号, b.操作员姓名, To_Char(b.登记时间, ''YYYY-MM-DD'') As 日期,' From Dual Union All
  Select 9,'       a.金额 As 合计, zlUppMoney(a.金额) As 大写' From Dual Union All
  Select 10,'From (' From Dual Union All
  Select 11,'       ' From Dual Union All
  Select 12,'       Select Ceil(序号 / 3) As 页号, Sum(金额) As 金额' From Dual Union All
  Select 13,'       From (Select Rownum As 序号, 项目, 金额' From Dual Union All
  Select 14,'               From (Select a.收据费目 As 项目, Sum(Nvl(a.实收金额, 0)) As 金额' From Dual Union All
  Select 15,'                      From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = [0]) B' From Dual Union All
  Select 16,'                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 ' From Dual Union All
  Select 17,'						And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8' From Dual Union All
  Select 18,'                      Group By a.收据费目' From Dual Union All
  Select 19,'                      Having Sum(Nvl(a.付数 * a.数次, 0)) <> 0)' From Dual Union All
  Select 20,'               Order By 项目)' From Dual Union All
  Select 21,'       Group By Ceil(序号 / 3)) A,' From Dual Union All
  Select 22,'     ' From Dual Union All
  Select 23,'     (Select Min(NO) || Decode(Max(NO), Min(NO), Null, ''-'' || Max(NO)) As NO, Max(姓名) As 姓名, Max(性别) As 性别, Max(年龄) As 年龄,' From Dual Union All
  Select 24,'         Max(操作员编号) As 操作员编号, Max(操作员姓名) As 操作员姓名, Max(登记时间) As 登记时间, Max(来源) As 来源' From Dual Union All
  Select 25,'	  From (Select a.NO, a.姓名, a.性别, a.年龄, a.操作员编号, a.操作员姓名, a.登记时间, Decode(a.门诊标志, 2, ''(住院收费)'', Null) As 来源' From Dual Union All
  Select 26,'         From 门诊费用记录 A, 病人预交记录 B' From Dual Union All
  Select 27,'         Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 ' From Dual Union All
  Select 28,'			And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8 And b.结算序号 = [0])) B' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结算序号',1,'0',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费明细','项目,202|金额,139',User||'.病人预交记录,'||User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'----说明见数据源:收费汇总' From Dual Union All
  Select 2,Null From Dual Union All
  Select 3,'Select a.收据费目 As 项目, Sum(Nvl(a.实收金额, 0)) As 金额' From Dual Union All
  Select 4,'From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = [0]) B' From Dual Union All
  Select 5,'Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 ' From Dual Union All
  Select 6,'	And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8' From Dual Union All
  Select 7,'Group By a.收据费目' From Dual Union All
  Select 8,'Having Sum(Nvl(a.付数 * a.数次, 0)) <> 0' From Dual Union All
  Select 9,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结算序号',1,'0',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,555,780,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,Null,0,'[收费汇总.日期]',Null,675,4290,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,Null,0,'[收费汇总.姓名]',Null,915,1125,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,1134,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,Null,0,'[收费汇总.大写]',Null,1395,3945,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,2310,4320,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,4410,765,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签8',2,Null,0,Null,0,'[收费汇总.日期]',Null,4415,4310,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签9',2,Null,0,Null,0,'[收费汇总.姓名]',Null,4770,1110,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签11',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,5024,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签10',2,Null,0,Null,0,'[收费汇总.大写]',Null,5255,3935,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签12',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,6165,4305,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签13',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,8265,765,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签14',2,Null,0,Null,0,'[收费汇总.日期]',Null,8275,4315,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签15',2,Null,0,Null,0,'[收费汇总.姓名]',Null,8625,1110,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签17',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,8959,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签16',2,Null,0,Null,0,'[收费汇总.大写]',Null,9115,3940,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签18',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,10020,4305,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'收费明细',Null,556,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',0,0,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',0,0,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表4',4,Null,0,Null,0,'收费明细',Null,4446,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',300,300,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',300,300,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表5',4,Null,0,Null,0,'收费明细',Null,8336,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',600,600,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',600,600,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1121_7/门诊医疗费收据(红票)
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1121,'门诊医疗费收据(红票)','退费收据(红票)打印');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1121,'门诊医疗费收据(红票)',User,'病人预交记录','SELECT' From Dual Union All
  Select &n_System,1121,'门诊医疗费收据(红票)',User,'门诊费用记录','SELECT' From Dual;



--91998:冉俊明,2016-05-31,退费发票(红票)

--报表：ZL1_BILL_1124_3/门诊医疗费收据(红票)
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1124_3','门诊医疗费收据(红票)','退费收据(红票)打印','C~!`T{6wo,7Cf<}mU8[T',7,'Epson LQ-1600K',1,&n_System,Null,Null,Sysdate,Sysdate,0,To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,&n_System,1124,'门诊医疗费收据(红票)');
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'门诊医疗费收据(红票)',0,12191,5443,256,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费汇总','页号,139|NO,202|姓名,202|性别,202|年龄,202|来源,202|操作员编号,202|操作员姓名,202|日期,202|合计,139|大写,202',User||'.病人预交记录,'||User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--1.票据号使用固定标签获取,内容中填写[票据号]即可' From Dual Union All
  Select 2,'--2.缺省按收据费目汇总打印,汇总时因为有医保部分退费重收,因此不管记录状态' From Dual Union All
  Select 3,'--3.明细不读取工本费用，如果收取了工本费，使用固定标签获取加到合计上' From Dual Union All
  Select 4,'--4.按每页3行设计并取数' From Dual Union All
  Select 5,'--子表A：根据收据行次设置及单据中的收据费目,返回每张票据的汇总金额' From Dual Union All
  Select 6,'--子表B：返回单据中的病人信息' From Dual Union All
  Select 7,Null From Dual Union All
  Select 8,'Select a.页号, b.NO, b.姓名, b.性别, b.年龄, b.来源, b.操作员编号, b.操作员姓名, To_Char(b.登记时间, ''YYYY-MM-DD'') As 日期,' From Dual Union All
  Select 9,'       a.金额 As 合计, zlUppMoney(a.金额) As 大写' From Dual Union All
  Select 10,'From (' From Dual Union All
  Select 11,'       ' From Dual Union All
  Select 12,'       Select Ceil(序号 / 3) As 页号, Sum(金额) As 金额' From Dual Union All
  Select 13,'       From (Select Rownum As 序号, 项目, 金额' From Dual Union All
  Select 14,'               From (Select a.收据费目 As 项目, Sum(Nvl(a.实收金额, 0)) As 金额' From Dual Union All
  Select 15,'                      From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = [0]) B' From Dual Union All
  Select 16,'                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 ' From Dual Union All
  Select 17,'            And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8 ' From Dual Union All
  Select 18,'                      Group By a.收据费目' From Dual Union All
  Select 19,'                      Having Sum(Nvl(a.付数 * a.数次, 0)) <> 0)' From Dual Union All
  Select 20,'               Order By 项目)' From Dual Union All
  Select 21,'       Group By Ceil(序号 / 3)) A,' From Dual Union All
  Select 22,'     ' From Dual Union All
  Select 23,'     (Select Min(NO) || Decode(Max(NO), Min(NO), Null, ''-'' || Max(NO)) As NO, Max(姓名) As 姓名, Max(性别) As 性别, Max(年龄) As 年龄,' From Dual Union All
  Select 24,'         Max(操作员编号) As 操作员编号, Max(操作员姓名) As 操作员姓名, Max(登记时间) As 登记时间, Max(来源) As 来源' From Dual Union All
  Select 25,'	  From (Select a.NO, a.姓名, a.性别, a.年龄, a.操作员编号, a.操作员姓名, a.登记时间, Decode(a.门诊标志, 2, ''(住院收费)'', Null) As 来源' From Dual Union All
  Select 26,'         From 门诊费用记录 A, 病人预交记录 B' From Dual Union All
  Select 27,'         Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 ' From Dual Union All
  Select 28,'			And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8 And b.结算序号 = [0])) B' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结算序号',1,'0',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费明细','项目,202|金额,139',User||'.病人预交记录,'||User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'----说明见数据源:收费汇总' From Dual Union All
  Select 2,Null From Dual Union All
  Select 3,'Select a.收据费目 As 项目, Sum(Nvl(a.实收金额, 0)) As 金额' From Dual Union All
  Select 4,'From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = [0]) B' From Dual Union All
  Select 5,'Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And Nvl(a.费用状态, 0) = 0 And Nvl(a.附加标志, 0) <> 8' From Dual Union All
  Select 6,'Group By a.收据费目' From Dual Union All
  Select 7,'Having Sum(Nvl(a.付数 * a.数次, 0)) <> 0' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结算序号',1,'0',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,555,780,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,Null,0,'[收费汇总.日期]',Null,675,4290,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,Null,0,'[收费汇总.姓名]',Null,915,1125,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,1209,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,Null,0,'[收费汇总.大写]',Null,1395,3945,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,2310,4320,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,4410,765,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签8',2,Null,0,Null,0,'[收费汇总.日期]',Null,4415,4310,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签9',2,Null,0,Null,0,'[收费汇总.姓名]',Null,4770,1110,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签11',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,5099,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签10',2,Null,0,Null,0,'[收费汇总.大写]',Null,5255,3935,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签12',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,6165,4305,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签13',2,Null,0,Null,0,'[票据号][收费汇总.来源]',Null,8265,765,2625,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签14',2,Null,0,Null,0,'[收费汇总.日期]',Null,8275,4315,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签15',2,Null,0,Null,0,'[收费汇总.姓名]',Null,8625,1110,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签17',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,8974,3555,2280,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签16',2,Null,0,Null,0,'[收费汇总.大写]',Null,9115,3940,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签18',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,10020,4305,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'收费明细',Null,556,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',0,0,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',0,0,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表4',4,Null,0,Null,0,'收费明细',Null,4446,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',300,300,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',300,300,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表5',4,Null,0,Null,0,'收费明细',Null,8336,1903,2858,1410,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^#',600,600,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^#',600,600,1410,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1124_3/门诊医疗费收据(红票)
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1124,'门诊医疗费收据(红票)','退费收据(红票)打印');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1124,'门诊医疗费收据(红票)',User,'病人预交记录','SELECT' From Dual Union All
  Select &n_System,1124,'门诊医疗费收据(红票)',User,'门诊费用记录','SELECT' From Dual;



--92159:刘尔旋,2016-05-27,结帐作废红票打印

--报表：ZL1_BILL_1137_5/住院医疗收据(红票)
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1137_5','住院医疗收据(红票)','住院医疗收据(红票)','T}!`Ad4ld84Wz0`wG1OB',Null,15,1,0, &n_System,1137,'住院医疗收据(红票)',Sysdate,Sysdate,To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'住院医疗收据(红票)',21546,6521,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'补款明细','结算方式,200|金额,200',User||'.病人预交记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select B.结算方式,' From Dual Union All
  Select 2,'Decode(Sign(B.冲预交),-1,''退:'',''收:'')||' From Dual Union All
  Select 3,'Ltrim(To_Char(ABS(B.冲预交),''999990.00'')) as 金额' From Dual Union All
  Select 4,'From 病人预交记录 B' From Dual Union All
  Select 5,'Where B.结帐ID=[] And B.记录性质 In(2,12)' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'费用汇总','页号,139|单据号,202|病人ID,131|住院号,131|姓名,202|性别,202|年龄,202|科室,202|收费时间,135|开始日期,135|结束日期,135|操作员姓名,202|操作员编号,202|合计,202|大写,202',User||'.住院费用记录,'||User||'.门诊费用记录,'||User||'.病人结帐记录,'||User||'.病人信息,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'----1.缺省按每页打印40行设计' From Dual Union All
  Select 2,'----2.按误差项不占用票据行设计,误差项合计到第一行' From Dual Union All
  Select 3,'----3.票据号使用固定标签获取,标签内容为[票据号]即可' From Dual Union All
  Select 4,Null From Dual Union All
  Select 5,Null From Dual Union All
  Select 6,'Select A.页号, B.单据号, B.病人id, B.住院号, B.姓名, B.性别, B.年龄, B.科室, B.收费时间, B.开始日期, B.结束日期, B.操作员姓名, B.操作员编号,' From Dual Union All
  Select 7,'       LTrim(To_Char(A.金额, ''99999990.00'')) As 合计, zlUppMoney(A.金额) As 大写' From Dual Union All
  Select 8,'From (Select Ceil(A.序号 / 40) As 页号, Sum(Decode(A.序号, 1, A.金额 + Nvl(B.误差费, 0), A.金额)) As 金额' From Dual Union All
  Select 9,'       From (Select Rownum As 序号, 金额' From Dual Union All
  Select 10,'              From (Select 收据费目, Sum(结帐金额) As 金额' From Dual Union All
  Select 11,'                     From (Select 收据费目, 结帐金额 From 住院费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) <> 9 Union All' From Dual Union All
  Select 12,'                           Select 收据费目, 结帐金额 From 门诊费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) <> 9)' From Dual Union All
  Select 13,'                     Group By 收据费目)' From Dual Union All
  Select 14,'              Order By 收据费目) A,' From Dual Union All
  Select 15,'            (Select Sum(实收金额) As 误差费' From Dual Union All
  Select 16,'              From (Select 实收金额 From 住院费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) = 9 Union All' From Dual Union All
  Select 17,'                    Select 实收金额 From 门诊费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) = 9)) B' From Dual Union All
  Select 18,'       Group By Ceil(A.序号 / 40)) A,' From Dual Union All
  Select 19,'     (Select A.No As 单据号, C.病人id, C.住院号, C.姓名, C.性别, C.年龄, D.名称 As 科室, A.收费时间, A.开始日期, A.结束日期, A.操作员姓名, A.操作员编号' From Dual Union All
  Select 20,'       From 病人结帐记录 A, 病人信息 C, 部门表 D' From Dual Union All
  Select 21,'       Where C.当前科室id = D.Id(+) And A.病人id = C.病人id And A.Id = [0]' From Dual Union All
  Select 22,'       Group By A.No, A.实际票号, C.病人id, C.住院号, C.姓名, C.性别, C.年龄, D.名称, A.收费时间, A.开始日期, A.结束日期, A.操作员姓名, A.操作员编号) B' From Dual Union All
  Select 23,Null From Dual Union All
  Select 24,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'费用明细','项目,202|金额,202',User||'.住院费用记录,'||User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select A.项目, LTrim(To_Char(Decode(Rownum, 1, A.金额 + Nvl(B.误差费, 0), A.金额), ''99999990.00'')) 金额' From Dual Union All
  Select 2,'From (Select 收据费目 As 项目, Sum(结帐金额) As 金额' From Dual Union All
  Select 3,'       From (Select 收据费目, 结帐金额 From 住院费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) <> 9 Union All' From Dual Union All
  Select 4,'             Select 收据费目, 结帐金额 From 门诊费用记录 Where 结帐id = [0] And Nvl(附加标志, 0) <> 9)' From Dual Union All
  Select 5,'       Group By 收据费目) A,' From Dual Union All
  Select 6,'     (Select Sum(结帐金额) As 误差费' From Dual Union All
  Select 7,'       From (Select 结帐金额 From 住院费用记录 Where 结帐id = [0] And 附加标志 = 9 Union All' From Dual Union All
  Select 8,'             Select 结帐金额 From 门诊费用记录 Where 结帐id = [0] And 附加标志 = 9)) B' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'预交汇总','冲预交合计,200|冲预交大写,200',User||'.病人预交记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select Ltrim(To_Char(Sum(B.冲预交),''99999990.00'')) as 冲预交合计,' From Dual Union All
  Select 2,'zlUppMoney(Sum(B.冲预交)) as 冲预交大写' From Dual Union All
  Select 3,'From 病人预交记录 B' From Dual Union All
  Select 4,'Where B.结帐ID=[0] And B.记录性质 IN(1,11)' From Dual Union All
  Select 5,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'预交明细','单据号,200|票据号,200|结算方式,200|预交时间,135|冲预交,200',User||'.病人预交记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select B.NO as 单据号,B.实际票号 as 票据号,' From Dual Union All
  Select 2,'B.结算方式,B.收款时间 as 预交时间,' From Dual Union All
  Select 3,'Ltrim(To_Char(Sum(B.冲预交),''99999990.00'')) as 冲预交' From Dual Union All
  Select 4,'From 病人预交记录 B' From Dual Union All
  Select 5,'Where B.结帐ID=[0] And B.记录性质 IN(1,11)' From Dual Union All
  Select 6,'Group by B.NO,B.实际票号,B.结算方式,B.收款时间' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,Null,0,'[费用汇总.姓名]',Null,600,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,Null,0,'[费用汇总.合计]',Null,1470,6195,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签8',2,Null,0,Null,0,'[费用汇总.住院号]',Null,2130,105,1530,180,0,2,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,Null,0,'大写:[费用汇总.大写]',Null,3210,6195,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签9',2,Null,0,Null,0,'[费用汇总.科室]',Null,4020,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,Null,0,'冲预交:[预交汇总.冲预交合计]',Null,4110,1665,2520,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,Null,0,'单据号:[费用汇总.单据号]',Null,4395,4380,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,Null,0,'[费用汇总.操作员姓名]',Null,4395,4725,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,Null,0,'[费用汇总.收费时间]',Null,4395,5085,1725,180,0,1,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签28',2,Null,0,Null,0,'票据号:[票据号]',Null,4500,450,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签16',2,Null,0,Null,0,'[费用汇总.姓名]',Null,6990,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签10',2,Null,0,Null,0,'[费用汇总.合计]',Null,7920,6195,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签17',2,Null,0,Null,0,'[费用汇总.住院号]',Null,8550,105,1530,180,0,2,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签11',2,Null,0,Null,0,'大写:[费用汇总.大写]',Null,9665,6195,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签18',2,Null,0,Null,0,'[费用汇总.科室]',Null,10560,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签12',2,Null,0,Null,0,'冲预交:[预交汇总.冲预交合计]',Null,10560,1680,2520,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签13',2,Null,0,Null,0,'单据号:[费用汇总.单据号]',Null,10800,4395,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签14',2,Null,0,Null,0,'[费用汇总.操作员姓名]',Null,10800,4725,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签15',2,Null,0,Null,0,'[费用汇总.收费时间]',Null,10800,5085,1725,180,0,1,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签29',2,Null,0,Null,0,'票据号:[票据号]',Null,10970,470,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签25',2,Null,0,Null,0,'[费用汇总.姓名]',Null,13395,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签19',2,Null,0,Null,0,'[费用汇总.合计]',Null,14310,6195,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签26',2,Null,0,Null,0,'[费用汇总.住院号]',Null,15135,105,1530,180,0,2,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签20',2,Null,0,Null,0,'大写:[费用汇总.大写]',Null,16045,6195,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签27',2,Null,0,Null,0,'[费用汇总.科室]',Null,16920,105,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签21',2,Null,0,Null,0,'冲预交:[预交汇总.冲预交合计]',Null,16950,1710,2520,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签22',2,Null,0,Null,0,'单据号:[费用汇总.单据号]',Null,17115,4425,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签23',2,Null,0,Null,0,'[费用汇总.操作员姓名]',Null,17115,4770,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签24',2,Null,0,Null,0,'[费用汇总.收费时间]',Null,17115,5085,1725,180,0,1,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签30',2,Null,0,Null,0,'票据号:[票据号]',Null,17335,475,1350,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表7',4,Null,0,Null,0,'费用明细',Null,581,368,1733,5731,285,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,2,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[费用明细.项目]','4^30^#',600,600,885,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[费用明细.金额]','4^30^#',600,600,810,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表2',4,Null,0,Null,0,'补款明细',Null,4020,1890,1835,2370,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[补款明细.结算方式]','4^30^#',0,0,615,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[补款明细.金额]','4^30^#',0,0,1125,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表3',4,Null,0,Null,0,'费用明细',Null,6996,368,1763,5731,285,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,2,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[费用明细.项目]','4^30^#',300,300,885,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[费用明细.金额]','4^30^#',300,300,810,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表4',4,Null,0,Null,0,'补款明细',Null,10490,1910,1835,2370,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[补款明细.结算方式]','4^30^#',300,300,615,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[补款明细.金额]','4^30^#',300,300,1125,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表5',4,Null,0,Null,0,'费用明细',Null,13376,368,1763,5731,285,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,2,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[费用明细.项目]','4^30^#',600,600,885,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[费用明细.金额]','4^30^#',600,600,825,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表6',4,Null,0,Null,0,'补款明细',Null,16870,1930,1835,2370,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[补款明细.结算方式]','4^30^#',600,600,615,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[补款明细.金额]','4^30^#',600,600,1125,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1137_5/住院医疗收据(红票)
Insert into zlProgFuncs(系统,序号,功能,说明) Values( &n_System,1137,'住院医疗收据(红票)','住院医疗收据(红票)');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select  &n_System,1137,'住院医疗收据(红票)',User,'H病人结帐记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'H病人预交记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'H门诊费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'H住院费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'病人结帐记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'病人信息','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'病人预交记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'部门表','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'门诊费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'住院医疗收据(红票)',User,'住院费用记录','SELECT' From Dual;
  
  


--92159:刘尔旋,2016-05-27,结帐作废红票打印

--报表：ZL1_BILL_1137_6/门诊医疗收据(红票)
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1137_6','门诊医疗收据(红票)','门诊医疗收据(红票)','C~!`Ag4ls;4Wz0cwP2OB',Null,15,1,0, &n_System,1137,'住院医疗收据(红票)',Sysdate,Sysdate,To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'门诊医疗收据(红票)',12191,5443,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费汇总','页号,139|单据号,202|病人ID,202|住院号,202|姓名,202|性别,202|年龄,202|日期,202|操作员姓名,202|操作员编号,202|合计,202|大写,202',User||'.门诊费用记录,'||User||'.住院费用记录,'||User||'.病人结帐记录,'||User||'.病人信息,'||User||'.合约单位',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--缺省按收费细目汇总' From Dual Union All
  Select 2,Null From Dual Union All
  Select 3,'Select A.页号, B.单据号, B.病人id, B.住院号, B.姓名, B.性别, B.年龄, To_Char(B.收费时间, ''YYYY-MM-DD'') 日期, B.操作员姓名, B.操作员编号,' From Dual Union All
  Select 4,'       LTrim(To_Char(A.金额, ''99999990.00'')) As 合计, zlUppMoney(A.金额) As 大写' From Dual Union All
  Select 5,'From (Select Rownum 页号, 金额' From Dual Union All
  Select 6,'       From (Select Sum(金额) 金额' From Dual Union All
  Select 7,'              From (Select Rownum 序号, LTrim(To_Char(Decode(Rownum, 1, 金额 + 误差费, 金额), ''999999990.00'')) As 金额' From Dual Union All
  Select 8,'                     From (Select 收据费目, Sum(Decode(Nvl(附加标志, 0), 9, 结帐金额, 0)) 误差费, Sum(Decode(Nvl(附加标志, 0), 9, 0, 结帐金额)) 金额' From Dual Union All
  Select 9,'                            From (Select 收据费目, 附加标志, 结帐金额 From 门诊费用记录 Where 结帐id = [0] And 病人id = Decode( [1], 0, 病人id, [1]) Union All' From Dual Union All
  Select 10,'                                  Select 收据费目, 附加标志, 结帐金额 From 住院费用记录 Where 结帐id = [0] And 病人id = Decode( [1], 0, 病人id, [1]))' From Dual Union All
  Select 11,'                            Group By 收据费目)' From Dual Union All
  Select 12,'                     Order By 收据费目)' From Dual Union All
  Select 13,'              Group By Ceil(序号 / 3))) A,' From Dual Union All
  Select 14,'     (Select A.No As 单据号, Decode(A.病人id, Null, '' '', A.病人id) 病人id, Decode(A.病人id, Null, '' '', C.住院号) 住院号,' From Dual Union All
  Select 15,'              Decode(A.病人id, Null, Q.名称, C.姓名) 姓名, Decode(A.病人id, Null, '' '', C.性别) 性别, Decode(A.病人id, Null, '' '', C.年龄) 年龄,' From Dual Union All
  Select 16,'              A.收费时间, A.操作员姓名, A.操作员编号' From Dual Union All
  Select 17,'       From 病人结帐记录 A,' From Dual Union All
  Select 18,'            (Select 结帐id, 病人id From 门诊费用记录 Where 结帐id = [0] And 病人id = Decode( [1], 0, 病人id, [1]) Union All' From Dual Union All
  Select 19,'             Select 结帐id, 病人id From 住院费用记录 Where 结帐id = [0] And 病人id = Decode( [1], 0, 病人id, [1])) B, 病人信息 C, 合约单位 Q' From Dual Union All
  Select 20,'       Where A.Id = [0] And A.Id = B.结帐id And B.病人id = C.病人id And C.合同单位id = Q.Id(+) And Rownum = 1) B' From Dual Union All
  Select 21,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'病人ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费明细','项目,202|金额,202',User||'.门诊费用记录,'||User||'.住院费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'--缺省仅提供按收据费目汇总打印' From Dual Union All
  Select 2,Null From Dual Union All
  Select 3,'Select 项目, LTrim(To_Char(Decode(Rownum, 1, 金额 + 误差费, 金额), ''999999990.00'')) As 金额' From Dual Union All
  Select 4,'From (Select 收据费目 as 项目, Sum(Decode(Nvl(附加标志, 0), 9, 结帐金额, 0)) 误差费,Sum(Decode(Nvl(附加标志, 0), 9, 0, 结帐金额)) 金额 From ' From Dual Union All
  Select 5,'      (Select 收据费目,附加标志,结帐金额 From 门诊费用记录 Where 结帐id = [0] And 病人id = Decode([1],0,病人id,[1]) union all' From Dual Union All
  Select 6,'       Select 收据费目,附加标志,结帐金额 From 住院费用记录 Where 结帐id = [0] And 病人id = Decode([1],0,病人id,[1])' From Dual Union All
  Select 7,'     )' From Dual Union All
  Select 8,'      Group By 收据费目)' From Dual Union All
  Select 9,'Order By 项目' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'结帐ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'病人ID',1,Null,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签22',2,Null,0,Null,0,'[票据号]',Null,480,795,915,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签23',2,Null,0,Null,0,'[收费汇总.日期]',Null,495,4320,1440,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签25',2,Null,0,Null,0,'[收费汇总.姓名]',Null,840,1125,1710,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签26',2,Null,0,Null,0,'[收费汇总.大写]',Null,1335,3945,1830,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签27',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,1440,3555,2400,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签28',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,2040,4320,1980,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签30',2,Null,0,Null,0,'[收费汇总.日期]',Null,4320,4320,1440,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签29',2,Null,0,Null,0,'[票据号]',Null,4335,765,915,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签32',2,Null,0,Null,0,'[收费汇总.姓名]',Null,4695,1110,1830,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签33',2,Null,0,Null,0,'[收费汇总.大写]',Null,5190,3930,1830,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签34',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,5325,3555,2400,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签35',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,5865,4320,1980,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签37',2,Null,0,Null,0,'[收费汇总.日期]',Null,8175,4320,1440,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签36',2,Null,0,Null,0,'[票据号]',Null,8190,765,915,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签39',2,Null,0,Null,0,'[收费汇总.姓名]',Null,8550,1110,1830,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签40',2,Null,0,Null,0,'[收费汇总.大写]',Null,9060,3945,1830,225,0,0,1,'宋体',11,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签41',2,Null,0,Null,0,'合计:[收费汇总.合计]',Null,9210,3555,2400,225,0,2,1,'宋体',11,0,0,0,0,16777215,0,Null,'0.00',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签42',2,Null,0,Null,0,'[收费汇总.操作员姓名]',Null,9825,4320,1980,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表7',4,Null,0,Null,0,'收费明细',Null,536,1893,3248,1440,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^项目',900,900,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^金额',900,900,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表8',4,Null,0,Null,0,'收费明细',Null,4381,1893,3248,1440,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^项目',1200,1200,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^金额',1200,1200,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表9',4,Null,0,Null,0,'收费明细',Null,8226,1893,3248,1440,465,0,0,'宋体',11,0,0,0,0,16777215,1,Null,Null,Null,1,16777215,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^30^项目',1500,1500,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.金额]','4^30^金额',1500,1500,1560,0,255,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1137_6/门诊医疗收据(红票)
Insert into zlProgFuncs(系统,序号,功能,说明) Values( &n_System,1137,'门诊医疗收据(红票)',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'H病人结帐记录','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'H门诊费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'H住院费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'病人结帐记录','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'病人信息','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'合约单位','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'门诊费用记录','SELECT' From Dual Union All
  Select  &n_System,1137,'门诊医疗收据(红票)',User,'住院费用记录','SELECT' From Dual;



--92161:刘尔旋,2016-05-23,预交款退款红票
--报表：ZL1_BILL_1103_1/病人预交款收据(红票)
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1103_1','病人预交款收据(红票)','病人预交款收据(红票)','Lv!fYy6pm#?Ag1mU8T\',15,'Star AR-3200+',1,&n_System,1103,'病人预交款收据(红票)',Sysdate,Sysdate,0,To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-05-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'预交款票据(红票)',0,6804,5094,256,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'预交收据','票据号,202|单据号,202|病人ID,131|门诊号,131|住院号,131|姓名,202|性别,202|年龄,202|科室,202|缴款单位,202|单位开户行,202|单位帐号,202|摘要,202|金额,202|结算方式,202|结算号码,202|收款时间,135|操作员编号,202|操作员姓名,202',User||'.病人预交记录,'||User||'.病人信息,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select A.实际票号 as 票据号,' From Dual Union All
  Select 2,'       A.NO as 单据号,' From Dual Union All
  Select 3,'       A.病人ID,' From Dual Union All
  Select 4,'       B.门诊号,' From Dual Union All
  Select 5,'       B.住院号,' From Dual Union All
  Select 6,'       B.姓名,' From Dual Union All
  Select 7,'       B.性别,' From Dual Union All
  Select 8,'       B.年龄,' From Dual Union All
  Select 9,'       C.名称 as 科室,' From Dual Union All
  Select 10,'       A.缴款单位,' From Dual Union All
  Select 11,'       A.单位开户行,' From Dual Union All
  Select 12,'       A.单位帐号,' From Dual Union All
  Select 13,'       A.摘要,' From Dual Union All
  Select 14,'       Ltrim(To_Char(A.金额, ''99999990.00'')) as 金额,' From Dual Union All
  Select 15,'       A.结算方式,' From Dual Union All
  Select 16,'       A.结算号码,' From Dual Union All
  Select 17,'       A.收款时间,' From Dual Union All
  Select 18,'       A.操作员编号,' From Dual Union All
  Select 19,'       A.操作员姓名' From Dual Union All
  Select 20,'  From 病人预交记录 A, 病人信息 B, 部门表 C' From Dual Union All
  Select 21,' Where A.病人ID = B.病人ID And A.科室ID = C.ID(+) And A.记录性质 = 1 And' From Dual Union All
  Select 22,'       A.记录状态 = 2 And A.NO = [0]' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标题',2,Null,0,Null,0,'[单位名称]预交款收据',Null,1875,300,3165,300,0,0,1,'宋体',14,1,0,0,0,16777215,0,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表2',4,Null,0,Null,0,Null,Null,365,815,6105,3525,255,0,0,'宋体',10.5,0,0,0,0,16777215,1,Null,Null,Null,1,0,Null,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^姓名：[预交收据.姓名]|1^420^金额：[预交收据.金额]|1^420^结算：[预交收据.结算方式]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^时间：[预交收据.收款时间]',300,300,795,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^姓名：[预交收据.姓名]|1^420^金额：[预交收据.金额]|1^420^结算：[预交收据.结算方式]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^时间：[预交收据.收款时间]',300,300,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^性别：[预交收据.性别]|1^420^金额：[预交收据.金额]|1^420^结算：[预交收据.结算方式]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^时间：[预交收据.收款时间]',300,300,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^性别：[预交收据.性别]|1^420^科室：[预交收据.科室]|1^420^号码：[预交收据.结算号码]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^收款员：[预交收据.操作员姓名]',300,300,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^年龄：[预交收据.年龄]|1^420^科室：[预交收据.科室]|1^420^号码：[预交收据.结算号码]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^收款员：[预交收据.操作员姓名]',300,300,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,Null,'7^420^单据号：[预交收据.单据号]|1^420^年龄：[预交收据.年龄]|1^420^科室：[预交收据.科室]|1^420^号码：[预交收据.结算号码]|1^420^单位：[预交收据.缴款单位]|1^420^摘要：[预交收据.摘要]|1^420^收款员：[预交收据.操作员姓名]',300,300,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,Null,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1103_1/病人预交款收据(红票)
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1103,'病人预交款收据(红票)','病人预交款收据(红票)');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1103,'病人预交款收据(红票)',User,'病人信息','SELECT' From Dual Union All
  Select &n_System,1103,'病人预交款收据(红票)',User,'病人预交记录','SELECT' From Dual Union All
  Select &n_System,1103,'病人预交款收据(红票)',User,'部门表','SELECT' From Dual;





-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--97529:张德婷,2016-06-16,修正呼叫的性能问题
CREATE OR REPLACE Procedure Zl_未发药品记录_呼叫
( 
  No_In       药品收发记录.NO%Type, 
  单据_In     药品收发记录.单据%Type, 
  药房id_In   药品收发记录.库房id%Type, 
  发药窗口_In 药品收发记录.发药窗口%Type, 
  呼叫内容_In 未发药品记录.呼叫内容%Type := Null 
) Is 
Begin 
  If 呼叫内容_In Is Null Then 
    --呼叫内容为空时，将当前的呼叫状态的单据的呼叫内容清空 
    Update 未发药品记录 
    Set 呼叫内容 = Null 
    Where 库房id = 药房id_In And 单据 = 单据_In And NO = No_In And 发药窗口 = 发药窗口_In And 排队状态 = 3 and 填制日期 between sysdate-3 and sysdate; 
  Else 
    --呼叫内容不为空时，先将以前的呼叫状态中的单据设置为已呼叫，再将当前单据设置为呼叫状态，并填写呼叫内容和呼叫时间 
    --可以满足同一单据反复呼叫的情况 
    Update 未发药品记录 
    Set 排队状态 = 4, 呼叫内容 = Null 
    Where 库房id = 药房id_In And 发药窗口 = 发药窗口_In And 排队状态 = 3 and 填制日期 between sysdate-3 and sysdate; 
 
    Update 未发药品记录 
    Set 排队状态 = 3, 呼叫内容 = 呼叫内容_In, 呼叫时间 = Sysdate 
    Where 库房id = 药房id_In And 单据 = 单据_In And NO = No_In and 填制日期 between sysdate-3 and sysdate; 
  End If; 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_未发药品记录_呼叫;
/

--97219:刘尔旋,2016-06-13,服务窗获取科室天数调整
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室

  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --  <ZD></ZD>              //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Temp      Varchar(5000); --临时XML
  x_Templet   Xmltype; --模板XML
  n_查询天数  Number(5);
  n_预约天数  Number(5);
  n_Add_Lists Number(3);
  v_合作单位  合作单位安排控制.合作单位%Type;
  n_站点      部门表.站点%Type;
  v_Err_Msg   Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/ZD')
  Into n_查询天数, v_合作单位, n_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_预约天数 := zl_GetSysParameter(66);
  If n_查询天数 Is Null Then
    --未传入查询天数的
    If v_合作单位 Is Null Then
      For r_Dept In (Select Distinct a.科室id, b.名称
                     From 挂号安排 A, 部门表 B
                     Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)) Loop
        If Nvl(n_Add_Lists, 0) = 0 Then
          --增加DJList节点
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
          n_Add_Lists := 1;
        End If;
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    Else
      For r_Dept In (Select Distinct 科室id, 名称
                     From (Select b.科室id, d.名称
                            From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                   From 挂号安排 A
                                   Where a.停用日期 Is Null And Not Exists
                                    (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                   Union All
                                   Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                   From 挂号安排 A, 合作单位安排控制 B
                                   Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                 挂号安排计划 C, 部门表 D
                            Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                  ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + a.预约天数) Or
                                  (c.生效时间 Between Sysdate And Sysdate + a.预约天数) Or
                                  (c.失效时间 Between Sysdate And Sysdate + a.预约天数)) And Not Exists
                             (Select 1
                                   From 合作单位计划控制
                                   Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                  (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                  (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                            Union All
                            Select b.科室id, d.名称
                            From (Select a.Id
                                   From 挂号安排 A
                                   Where a.停用日期 Is Null And Not Exists
                                    (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                   Union All
                                   Select a.Id
                                   From 挂号安排 A, 合作单位安排控制 B
                                   Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B, 部门表 D
                            Where a.Id = b.Id And Not Exists
                             (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                  (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                  (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null))) Loop
        If Nvl(n_Add_Lists, 0) = 0 Then
          --增加DJList节点
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
          n_Add_Lists := 1;
        End If;
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End If;
  Else
    If v_合作单位 Is Null Then
      For r_Dept In (Select Distinct a.科室id, b.名称
                     From 挂号安排 A, 部门表 B
                     Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)) Loop
      
        If Nvl(n_Add_Lists, 0) = 0 Then
          --增加DJList节点
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
          n_Add_Lists := 1;
        End If;
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    Else
      For r_Dept In (Select Distinct 科室id, 名称
                     From (Select b.科室id, d.名称
                            From (Select a.Id
                                   From 挂号安排 A
                                   Where a.停用日期 Is Null And Not Exists
                                    (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                   Union All
                                   Select a.Id
                                   From 挂号安排 A, 合作单位安排控制 B
                                   Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                 挂号安排计划 C, 部门表 D
                            Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                  ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + n_查询天数) Or
                                  (c.生效时间 Between Sysdate And Sysdate + n_查询天数) Or
                                  (c.失效时间 Between Sysdate And Sysdate + n_查询天数)) And Not Exists
                             (Select 1
                                   From 合作单位计划控制
                                   Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                  (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                  (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                            Union All
                            Select b.科室id, d.名称
                            From (Select a.Id
                                   From 挂号安排 A
                                   Where a.停用日期 Is Null And Not Exists
                                    (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                   Union All
                                   Select a.Id
                                   From 挂号安排 A, 合作单位安排控制 B
                                   Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B, 部门表 D
                            Where a.Id = b.Id And Not Exists
                             (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                  (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                  (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null))) Loop
        If Nvl(n_Add_Lists, 0) = 0 Then
          --增加DJList节点
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
          n_Add_Lists := 1;
        End If;
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptlist;
/

--96744:梁经伙,2016-06-08,添加转出表 疾病申报反馈 到过程
Create Or Replace Procedure Zl_Retu_Clinic
(
  n_Patiid In Number,
  v_Times  In Varchar2,
  n_Flag   In Number
) As
  --------------------------------------------
  --参数:n_Patiid,病人id
  --     v_Times,挂号单号或住院主页id（体检时，挂号单是体检单号）
  --     n_Flag,门诊或住院标志:0-门诊,1-住院,2-体检（此时，只有n_Patiid参数无效）
  --------------------------------------------
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_System     Number(5);
  n_Opersystem Number(5);
  n_只读       Number(2);

  v_Table    Varchar2(100);
  v_Subtable Varchar2(100);
  v_Field    Varchar2(100);
  v_Subfield Varchar2(100);
  v_Sql      Varchar2(4000);
  v_Sqlchild Varchar2(4000);
  v_Fields   Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定病人ID和主页的相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Other
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  
  Begin
  
    For R In (Select Column_Value From Table(f_Str2list('病人过敏记录,病人诊断记录,病人手麻记录'))) Loop
      v_Table  := r.Column_Value;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    End Loop;
  End Zl_Retu_Other;

  --------------------------------------------
  --返回指定病人ID和主页的临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Path
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
    v_Table  := '病人临床路径';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select ID As 路径记录id From H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人路径执行,病人合并路径,病人路径评估,病人路径变异,病人路径指标,病人合并路径评估,病人出径记录'))) Loop
        v_Table := r.Column_Value;
        If v_Table = '病人合并路径' Then
          v_Field := '首要路径记录id';
        Else
          v_Field := '路径记录id';
        End If;
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      End Loop;
    End Loop;
  
    Delete H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Path;

  --------------------------------------------
  --返回指定病人ID和主页的护理相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Tend
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
  
    v_Table  := '病人护理文件';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID As 文件id From H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人护理数据,病人护理打印,病人护理活动项目,病人护理要素内容,产程要素内容'))) Loop
        v_Table  := r.Column_Value;
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      
        If v_Table = '病人护理数据' Then
          v_Fields := Getfields('病人护理明细');
          v_Sql    := 'Insert Into 病人护理明细(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                      ' From H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        
          v_Sql := 'Delete H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        End If;
      
        v_Sql := 'Delete H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      End Loop;
    End Loop;
  
    Delete H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  
    --老版护理系统数据
    ------------------------------------------------------------------------
    v_Table  := '病人护理记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID From H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      v_Table  := '病人护理内容';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    
      v_Sql := 'Delete H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    End Loop;
  
    Delete H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Tend;

  --------------------------------------------
  --返回指定ID的病人新版电子病历记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Epr(n_Rec_Id H电子病历记录.Id%Type) As
    v_Field Varchar(100);
  Begin
    v_Table  := '电子病历记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --病人诊断记录在Zl_Retu_Other中已转回（无病历ID外键）
    --影像报告驳回,病人医嘱报告,报告查阅记录,这几张表的数据在Zl_Retu_Order中转回医嘱后再处理
    For R In (Select Column_Value
              From Table(f_Str2list('电子病历附件,电子病历格式,电子病历内容,疾病申报记录,疾病报告反馈,疾病申报反馈'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '电子病历附件' Then
        v_Field := '病历id';
      Else
        v_Field := '文件id';
      End If;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '电子病历内容' Then
        v_Fields := Getfields('电子病历图形');
        v_Sql    := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = n_Rec_Id And 对象类型 = 5);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    Delete H电子病历记录 Where ID = n_Rec_Id;
  End Zl_Retu_Epr;
  --------------------------------------------
  --返回指定ID的病人医嘱记录子过程，必须在病历、临床路径转出之后执行(病人医嘱报告,影像报告驳回，病人路径医嘱)
  --在Zl_Retu_Other中已转回了"病人诊断记录",转回"病人诊断医嘱"时不用再转
  --------------------------------------------
  Procedure Zl_Retu_Order(n_Rec_Id H病人医嘱记录.Id%Type) As
  Begin
    v_Table  := '病人医嘱记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --以"医嘱ID,发送号"为外键的，都按医嘱ID直接转回，只需要排在"病人医嘱发送"之后即可
    --由于外键关系，"报告查阅记录"须在"病人医嘱报告"后面
    For P In (Select Column_Value
              From Table(f_Str2list('病人医嘱计价,病人医嘱状态,病人医嘱发送,病人医嘱附费,病人医嘱附件,病人医嘱执行,病人医嘱打印,输血申请记录,输血检验结果,' ||
                                     '医嘱执行打印,医嘱执行时间,医嘱执行计价,执行打印记录,病人诊断医嘱,病人路径医嘱,病人医嘱报告,报告查阅记录,' ||
                                     '影像报告驳回,影像报告记录,影像报告操作记录,影像检查记录,影像申请单图像,影像收藏内容,影像危急值记录,检验标本记录,检验试剂记录,检验拒收记录'))) Loop
      v_Table := p.Column_Value;
      If Instr('病人路径医嘱', v_Table) > 0 Then
        v_Field := '病人医嘱ID';
      Else
        v_Field := '医嘱ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      If v_Table = '病人医嘱状态' Then
        v_Sqlchild := v_Sql;
      Else
        Execute Immediate v_Sql
          Using n_Rec_Id;
      End If;
    
      If v_Table = '病人医嘱状态' Then
        v_Fields := Getfields('医嘱签名记录');
        v_Sql    := 'Insert Into 医嘱签名记录(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H医嘱签名记录 Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = :1 And 签名id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H医嘱签名记录
        Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = n_Rec_Id And 签名id Is Not Null);
      
        Execute Immediate v_Sqlchild
          Using n_Rec_Id;
      
      Elsif v_Table = '病人医嘱发送' Then
        v_Fields := Getfields('诊疗单据打印');
        v_Sql    := 'Insert Into 诊疗单据打印(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '影像检查记录' Then
        v_Fields := Getfields('影像检查序列');
        v_Sql    := 'Insert Into 影像检查序列(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('影像检查图象');
        v_Sql    := 'Insert Into 影像检查图象(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查图象 Where 序列uid In (Select b.序列uid From H影像检查记录 A, H影像检查序列 B Where a.医嘱id = :1 And a.检查uid = b.检查uid)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H影像检查图象
        Where 序列uid In (Select b.序列uid
                        From H影像检查记录 A, H影像检查序列 B
                        Where a.医嘱id = n_Rec_Id And a.检查uid = b.检查uid);
        Delete H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '检验标本记录' Then
        For R In (Select Column_Value
                  From Table(f_Str2list('检验申请项目,检验分析记录,检验项目分布,检验质控记录,检验操作记录,检验签名记录,检验图像结果'))) Loop
          v_Subtable := r.Column_Value;
          If v_Subtable = '检验签名记录' Then
            v_Subfield := '检验标本ID';
          Else
            v_Subfield := '标本ID';
          End If;
          v_Fields := Getfields(v_Subtable);
          v_Sql    := 'Insert Into ' || v_Subtable || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Subtable || ' Where ' || v_Subfield ||
                      ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        
          v_Sql := 'Delete H' || v_Subtable || ' Where ' || v_Subfield ||
                   ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        End Loop;
      
        v_Fields := Getfields('检验普通结果');
        v_Sql    := 'Insert Into 检验普通结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验药敏结果');
        v_Sql    := 'Insert Into 检验药敏结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验药敏结果 Where 细菌结果id In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验质控报告');
        v_Sql    := 'Insert Into 检验质控报告(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验质控报告 Where 结果ID In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H检验药敏结果
        Where 细菌结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
        Delete H检验质控报告
        Where 结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
      
        Delete H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --手麻数据
    If n_Opersystem > 0 Then
      Execute Immediate 'Call zl24_Retu_Oper(:1)'
        Using n_Rec_Id;
    End If;
  
    Delete H病人医嘱记录 Where ID = n_Rec_Id;
  End Zl_Retu_Order;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --对基于视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  --对基于视图的转储方案进行了只读判断.
  n_Opersystem := 0;
  Select 编号 Into n_Opersystem From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '24%';
  If n_Opersystem > 0 Then
    Begin
      Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_Opersystem And 当前 = 1;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]当前没有可用的手麻子系统历史数据空间,不能继续![ZLSOFT]';
        Raise Err_Item;
    End;
    If n_只读 = 1 Then
      v_Err_Msg := '[ZLSOFT]手麻子系统历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --1.门诊病人，按挂号单抽回
  If n_Flag = 0 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid, 8);
  
    v_Table  := '病人挂号记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1 ';
    Execute Immediate v_Sql
      Using v_Times;
  
    For r_Other In (Select ID, 病人id From H病人挂号记录 Where NO = v_Times) Loop
      Zl_Retu_Other(r_Other.病人id, r_Other.Id);
    End Loop;
  
    For r_Epr In (Select /*+ Rule*/
                   b.Id
                  From H病人挂号记录 A, H电子病历记录 B
                  Where a.No = v_Times And a.病人id = n_Patiid And b.病人id = a.病人id And b.主页id = a.Id) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人来源 <> 4 And 病人id = n_Patiid And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    --转诊记录
    v_Table  := '病人转诊记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1';
    Execute Immediate v_Sql
      Using v_Times;
  
    Delete H病人转诊记录 Where NO = v_Times;
    Delete H病人挂号记录 Where NO = v_Times;
  
    --2.住院病人，按病人ID和主页ID抽回
  Elsif n_Flag = 1 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid || ',' || v_Times, 8);
  
    Zl_Retu_Other(n_Patiid, To_Number(v_Times));
    Zl_Retu_Path(n_Patiid, To_Number(v_Times));
  
    --先转病历，再转医嘱（影像报告驳回，病人医嘱报告这类又有病历又有医嘱的子表，在医嘱转回后处理）
    For r_Epr In (Select ID From H电子病历记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    Zl_Retu_Tend(n_Patiid, To_Number(v_Times));
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
    Update 病案主页 Set 数据转出 = 0 Where 病人id = n_Patiid And 主页id = To_Number(v_Times);
  
    --3.体检病人
  Elsif n_Flag = 2 Then
    Zl_Retu_Other(n_Patiid, v_Times);
  
    For r_Cpr In (Select ID From H病人医嘱记录 Where 病人来源 = 4 And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Cpr.Id);
    End Loop;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Clinic;
/

--96744:梁经伙,2016-06-08,增加疾病申报反馈存储上报后的报告的备注说明
CREATE OR REPLACE Procedure zl_疾病申报反馈_insert
(
  申报ID_In         In 疾病申报反馈.申报ID%Type,
  反馈信息_In       In 疾病申报反馈.反馈信息%Type,
  登记人_In         In 疾病申报反馈.登记人%Type,
  登记时间_In       In 疾病申报反馈.登记时间%Type,
  处理情况说明_In   In 疾病申报反馈.处理情况说明%Type
) Is
Begin
 Insert Into 疾病申报反馈 (申报ID,反馈信息,登记人,登记时间,处理情况说明) Values
  (申报ID_In, 反馈信息_In, 登记人_In, 登记时间_In, 处理情况说明_In);
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End zl_疾病申报反馈_insert;
/

--96744:梁经伙,2016-06-08,增加疾病申报反馈存储上报后的报告的备注说明
Create Or Replace Procedure Zl_疾病申报反馈_Update
(
  申报id_In       In 疾病申报反馈.申报id%Type,
  反馈信息_In     In 疾病申报反馈.反馈信息%Type,
  登记人_In       In 疾病申报反馈.登记人%Type,
  登记时间_In     In 疾病申报反馈.登记时间%Type,
  处理情况说明_In In 疾病申报反馈.处理情况说明%Type
) Is
Begin
  Update 疾病申报反馈
  Set 登记人 = 登记人_In, 反馈信息 = 反馈信息_In, 处理情况说明 = 处理情况说明_In
  Where 申报id = 申报id_In And 登记时间 = 登记时间_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病申报反馈_Update;
/

--96744:梁经伙,2016-06-08,增加疾病申报反馈存储上报后的报告的备注说明
Create Or Replace Procedure Zl_疾病阳性记录_Delete
(
  id_In In 疾病阳性记录.id%Type
) Is
Begin
  Delete From 疾病阳性记录 Where id = id_In ;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病阳性记录_Delete;
/

--97030:梁经伙,2016-06-08,可以修改阳性反馈单
CREATE OR REPLACE Procedure Zl_疾病阳性检测记录_Update
(
  Operate_In      In Number,
  Id_In           In 疾病阳性记录.Id%Type,
  文件id_In       In 疾病阳性记录.文件id%Type,
  记录状态_In     In 疾病阳性记录.记录状态%Type,
  处理人_In       In 疾病阳性记录.处理人%Type,
  处理时间_In     In 疾病阳性记录.处理时间%Type,
  处理情况说明_In In 疾病阳性记录.处理情况说明%Type,
  送检时间_In     In 疾病阳性记录.送检时间%Type := Null,
  送检科室id_In   In 疾病阳性记录.送检科室id%Type := Null,
  送检医生_In     In 疾病阳性记录.送检医生%Type := Null,
  标本名称_In     In 疾病阳性记录.标本名称%Type := Null,
  反馈结果_In     In 疾病阳性记录.反馈结果%Type := Null,
  传染病_In       In 疾病阳性记录.传染病名称%Type := Null,
  检查时间_In     In 疾病阳性记录.检查时间%Type := Null,
  登记时间_In     In 疾病阳性记录.登记时间%Type := Null,
  登记人_In       In 疾病阳性记录.登记人%Type := Null,
  登记科室id_In   In 疾病阳性记录.登记科室id%Type := Null
) Is
Begin
  If Operate_In = 1 Then
    /*设置处理说明 */
    Update 疾病阳性记录
    Set 处理人 = 处理人_In, 处理时间 = 处理时间_In, 处理情况说明 = 处理情况说明_In, 记录状态 = 记录状态_In, 文件id = 文件id_In
    Where ID = Id_In;
  Elsif Operate_In = 2 Then
    /*关联报告单和阳性结果反馈单*/
    If 文件id_In Is Not Null Then
      Update 疾病阳性记录 Set 文件id = 文件id_In Where ID = Id_In;
    End If;
  Elsif Operate_In = 3 Then
    /*取消报告单和阳性结果反馈单的关联*/
    If 文件id_In Is Not Null Then
      Update 疾病阳性记录 Set 文件id = Null Where 文件id = 文件id_In;
    End If;
  Elsif Operate_In = 4 Then
    /*修改阳性结果反馈单*/
    Update 疾病阳性记录
    Set 送检时间 = 送检时间_In, 送检科室id = 送检科室id_In, 送检医生 = 送检医生_In, 标本名称 = 标本名称_In, 反馈结果 = 反馈结果_In, 传染病名称 = 传染病_In,
        检查时间 = 检查时间_In, 登记时间 = 登记时间_In, 登记人 = 登记人_In, 登记科室id = 登记科室id_In Where ID = Id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病阳性检测记录_Update;
/

--93574:刘尔旋,2016-06-07,挂号后担保记录的处理
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0--是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                 Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, 预交类别, NO)
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, NO, 预交类别;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date     Date;
  d_预约时间 门诊费用记录.发生时间%Type;
  d_发生时间 Date;
  d_排队时间 Date;
  n_时段     Number := 0;
  n_存在     Number := 0;
  v_排队序号 排队叫号队列.排队序号%Type;
  n_结算模式 病人信息.结算模式%Type;
  n_票种     票据使用明细.票种%Type;
  v_付款方式 病人挂号记录.医疗付款方式%Type;
  n_接收模式 Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter(64, 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      v_Err_Msg := '当前预约挂号单已被其它人接收';
      Raise Err_Item;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), 现金支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (r_Deposit.病人id, Nvl(r_Deposit.预交类别, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In,0)=0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In,0)=0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--93574:刘尔旋,2016-06-07,挂号后担保记录的处理
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In       门诊费用记录.病人id%Type,
  门诊号_In       门诊费用记录.标识号%Type,
  姓名_In         门诊费用记录.姓名%Type,
  性别_In         门诊费用记录.性别%Type,
  年龄_In         门诊费用记录.年龄%Type,
  付款方式_In     门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In         门诊费用记录.费别%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  序号_In         门诊费用记录.序号%Type,
  价格父号_In     门诊费用记录.价格父号%Type,
  从属父号_In     门诊费用记录.从属父号%Type,
  收费类别_In     门诊费用记录.收费类别%Type,
  收费细目id_In   门诊费用记录.收费细目id%Type,
  数次_In         门诊费用记录.数次%Type,
  标准单价_In     门诊费用记录.标准单价%Type,
  收入项目id_In   门诊费用记录.收入项目id%Type,
  收据费目_In     门诊费用记录.收据费目%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In     门诊费用记录.应收金额%Type,
  实收金额_In     门诊费用记录.实收金额%Type,
  病人科室id_In   门诊费用记录.病人科室id%Type,
  开单部门id_In   门诊费用记录.开单部门id%Type,
  执行部门id_In   门诊费用记录.执行部门id%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  医生姓名_In     挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病历费_In       Number, --该条记录是否病历工本费
  急诊_In         Number,
  号别_In         挂号安排.号码%Type,
  诊室_In         门诊费用记录.发药窗口%Type,
  结帐id_In       门诊费用记录.结帐id%Type,
  领用id_In       票据使用明细.领用id%Type,
  预交支付_In     病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In     病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In     病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In   门诊费用记录.保险大类id%Type,
  保险项目否_In   门诊费用记录.保险项目否%Type,
  统筹金额_In     门诊费用记录.统筹金额%Type,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In     Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In     Number := 0, --挂号是否使用收费票据
  保险编码_In     门诊费用记录.保险编码%Type,
  复诊_In         病人挂号记录.复诊%Type := 0,
  号序_In         挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In         病人挂号记录.社区%Type := Null,
  预约接收_In     Number := 0,
  预约方式_In     预约方式.名称%Type := Null,
  生成队列_In     Number := 0,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  操作类型_In     Number := 0,
  险类_In         病人挂号记录.险类%Type := Null,
  结算模式_In     Number := 0,
  记帐费用_In     Number := 0,
  退号重用_In     Number := 1,
  修正病人费别_In Number := 0,
  更新交款余额_In  Number := 0--是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);
  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;
  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存在相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  If Nvl(n_计划id, 0) = 0 Then
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
  Else
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In,0)=0 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
      
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         Null, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Preout
(
  病人id_In   病案主页.病人id%Type,
  主页id_In   病案主页.主页id%Type,
  发生时间_In 病人变动记录.开始时间%Type
) As
  -----------------------------------------------------------
  --功能：将病人标为预出院状态，并产生一条变动
  -----------------------------------------------------------
 Cursor c_Oldinfo Is
        Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间) From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 发生时间_In)) A, 病人变动记录 B

    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 发生时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo c_Oldinfo%RowType;
  r_Endinfo c_Endinfo%RowType;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Temp     Varchar2(255);
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;
  v_姓名     病人信息.姓名%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Nvl(状态, 0) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 0 Then
    v_Error := '该病人当前正在转科或尚未入科，不能执行预出院。';
    Raise Err_Custom;
  End If;

  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1  And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;

    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记,0)<>-1  And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --操作员信息
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Open c_Oldinfo; --必须在处理之前先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%RowCount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is not NULL then
    v_终止时间:=r_Oldinfo.终止时间;
    v_终止原因:=r_Oldinfo.终止原因;
    v_终止人员:=r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名 ,上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因=v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录 Set 上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间>发生时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 发生时间_In) - 发生时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --产生新变动
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名,终止时间,终止原因,终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
       r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
       r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, v_人员编号, v_人员姓名,v_终止时间,v_终止原因,v_终止人员);
    If Nvl(r_Oldinfo.附加床位, 0) = 0 Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', r_Oldinfo.科室id, r_Oldinfo.经治医师, 发生时间_In, 发生时间_In);
    End If;
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;

  Update 病案主页 Set 状态 = 3 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Preout;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Undo
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  数据_In       Varchar2 := Null, --a.转为住院时,清除住院号,b-检查自动记帐费用是否已结帐
  床号_In       Varchar2 := Null, --传入时表示撤销出院时安排到新的床号，原床位被占用在程序中判断
  主床位_In     Varchar2 := Null, --传入时表示撤销出院时安排到新的主床位，原床位被占用在程序中判断
  撤销方式_In   Varchar2 := Null --指明具体撤销操作，如撤销出院、转科等必须输入
) As
  -----------------------------------------------------------
  --说明：1.撤消病人最近一次的变动
  --        2.前提：当病人包床时,对其中一张床位作变动,则所有床位相应产生变动
  -----------------------------------------------------------
  --要撤消的变动记录(如果包床,可能多条)
  Cursor c_Curlog Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curlogrow c_Curlog%Rowtype;

  --撤消后要恢复的变动记录(如果包床,可能多条)
  Cursor c_Prelog
  (
    v_终止时间 病人变动记录.终止时间%Type,
    v_终止原因 病人变动记录.终止原因%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prelogrow c_Prelog%Rowtype;

  --获取病人原床位所住病人信息
  Cursor c_Prebed
  (
    v_病人id 病案主页.病人id%Type,
    v_主页id 病案主页.主页id%Type
  ) Is
    Select a.床号, c.出院病床, c.出院科室id, c.当前病区id
    From 病人变动记录 a, 床位状况记录 b, 病案主页 c
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And
          a.主页id = c.主页id And a.床号 = b.床号
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedrow c_Prebed%Rowtype;

  Cursor c_Prebedpati
  (
    v_出院科室id 病人变动记录.科室id%Type,
    v_病区id     病人变动记录.病区id%Type,
    v_原床号     病人变动记录.床号%Type
  ) Is
    Select a.病人id, c.主页id, a.床号, c.出院病床
    From 病人变动记录 a, 病案主页 c,
         (Select 病人id
           From 床位状况记录
           Where (科室id Is Null Or 科室id = v_出院科室id Or 共用 = 1) And 病区id = v_病区id And 床号 = v_原床号) d
    Where a.病人id = d.病人id And a.主页id = (Select 主页id From 病人信息 Where 病人id = d.病人id) And a.终止原因 = 4 And a.病人id = c.病人id And
          a.主页id = c.主页id
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedpati c_Prebedpati%Rowtype;

  v_开始时间 病人变动记录.开始时间%Type;
  v_开始原因 病人变动记录.开始原因%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count       Number;
  v_Countcurlog Number;
  v_Countprelog Number;

  Err_Custom Exception;
  v_Error Varchar2(255);

  v_撤销方式     Varchar2(100);
  v_共享号       Zlsystems.共享号%Type;
  v_病案状态     Number(3);
  v_床号串       Varchar2(255);
  v_床号         病人变动记录.床号%Type;
  v_病人id       病人变动记录.病人id%Type;
  v_主页id       病人变动记录.主页id%Type;
  v_病区id       病人变动记录.病区id%Type;
  v_原床号1      病人变动记录.床号%Type;
  v_原床号2      病人变动记录.床号%Type;
  v_当前床号1    病人变动记录.床号%Type;
  v_当前床号2    病人变动记录.床号%Type;
  v_出院科室id   病人变动记录.科室id%Type;
  v_床位等级id   病人变动记录.床位等级id%Type;
  v_险类         病案主页.险类%Type;
  v_姓名         病人信息.姓名%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Tmp          Varchar2(100);
  d_开始时间     Date;
Begin
  If 撤销方式_In Is Null Then
    v_Error := '[ZLSOFT]没有指明具体的撤销操作！[ZLSOFT]';
    Raise Err_Custom;
  Else
    v_撤销方式 := 撤销方式_In;
  End If;

  Open c_Curlog;
  Fetch c_Curlog
    Into r_Curlogrow;
  If c_Curlog%Rowcount = 0 Then
    v_Error := '[ZLSOFT]病人当前没有可以撤消的操作！[ZLSOFT]';
    Close c_Curlog;
    Raise Err_Custom;
  End If;
  
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id > 主页id_In;
  If v_Count > 0 Then
    v_Error := '[ZLSOFT]您只能对病人的最后一次住院进行撤销操作,本次撤销操作终止![ZLSOFT]';
    Raise Err_Custom;
  End If;
  
  Select Count(Id)
  Into v_Countcurlog
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
  Order By 终止时间 Desc, 开始时间 Desc;

  Select Count(a.床号)
  Into v_Countprelog
  From 病人变动记录 a, 床位状况记录 b, 病案主页 c
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And a.主页id = c.主页id And
        a.床号 = b.床号
  Order By 终止时间 Desc, 开始时间 Desc;

  --判断是否撤消床位对换
  If v_撤销方式 = '换床' And v_Countcurlog <= 1 And v_Countprelog <= 1 Then
    Open c_Prebed(病人id_In, 主页id_In);
    Fetch c_Prebed
      Into r_Prebedrow;
  
    v_出院科室id := r_Prebedrow.出院科室id;
    v_病区id     := r_Prebedrow.当前病区id;
    v_原床号1    := r_Prebedrow.床号;
    v_当前床号1  := r_Prebedrow.出院病床;
  
    For r_Prebedpati In c_Prebedpati(v_出院科室id, v_病区id, v_原床号1) Loop
      v_病人id    := r_Prebedpati.病人id;
      v_主页id    := r_Prebedpati.主页id;
      v_原床号2   := r_Prebedpati.床号;
      v_当前床号2 := r_Prebedpati.出院病床;
    
      If v_病人id <> 0 And v_主页id <> 0 And v_原床号1 = v_当前床号2 And v_原床号2 = v_当前床号1 Then
        v_撤销方式 := '床位对换';
        Select 险类 Into v_险类 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id;
        If v_险类 Is Null Then
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, Null, 床号_In, 主床位_In, v_撤销方式);
        Else
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, '1', 床号_In, 主床位_In, v_撤销方式);
        End If;
      End If;
    
      --只对最近一次床位是对方床位的记录进行处理
      Exit;
    End Loop;
  End If;

  If r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 3;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 15;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    --撤消出院
    v_开始时间 := r_Curlogrow.终止时间; --新增的变动记录的开始时间
  
    Select Zl_住院日报_Count(r_Curlogrow.科室id, r_Curlogrow.终止时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
    --是否进行过电子病案审查
    Select Nvl(病案状态, 0) Into v_病案状态 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_病案状态 Not In (0, 2) Then
      v_Error := '[ZLSOFT]病人的电子病案已提交审查，不能再撤消出院。[ZLSOFT]';
      Close c_Curlog;
      Raise Err_Custom;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
  
    --恢复入院
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
  
    Select 开始原因
    Into v_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Update 病案主页
    Set 状态 = Decode(v_开始原因, 10, 3, 状态), 出院日期 = Null, 出院方式 = Null, 随诊标志 = Null, 随诊期限 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --处理床位
    If 床号_In Is Null Then
      --原床位没有被占用,家庭病床也不会被占用(程序中已判断被占用情况,占用会传入床号_In)
      Close c_Curlog;
      For r_Curlogrow In c_Curlog Loop
        If r_Curlogrow.床号 Is Not Null Then
          --检查床位
          Select Count(*)
          Into v_Count
          From 床位状况记录
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号 And 状态 = '空床';
          If v_Count = 0 Then
            v_Error := '[ZLSOFT]操作失败,床位 ' || r_Curlogrow.床号 || ' 不是空床！[ZLSOFT]';
            Raise Err_Custom;
          End If;
          --重新占用床位
          Update 床位状况记录
          Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Curlogrow.床位等级id, 科室id = r_Curlogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
        End If;
      
        If Nvl(r_Curlogrow.附加床位, 0) = 0 Then
          Update 病人信息
          Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = r_Curlogrow.床号, 在院 = 1
          Where 病人id = 病人id_In;
        
          --更新在院病人
          Begin
            Update 在院病人
            Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id
            Where 病人id = 病人id_In;
            If Sql%Rowcount = 0 Then
              Insert Into 在院病人
                (病人id, 科室id, 病区id)
              Values
                (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
            End If;
          Exception
            When Others Then
              Null;
          End;
        
        End If;
      End Loop;
    Else
      --原床位被占用，传入新安排的床位,入住一张或多张病床病床
      v_床号串 := 床号_In || ',';
      --如果病人出院前状态为预出院，则撤消预出院
      If v_开始原因 = 10 Then
        --撤消预出院
        Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
        --恢复变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
      
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
      End If;
    
      While v_床号串 Is Not Null Loop
        v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
        --原始床位等级与新床位等级及数量在程序中判断
        --检查床位
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！';
          Close c_Curlog;
          Raise Err_Custom;
        End If;
        --更新床位状况记录
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = r_Curlogrow.科室id
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
      
        Select 等级id Into v_床位等级id From 床位状况记录 Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
        ----新增原因为4
        Insert Into 病人变动记录
          (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_开始时间, 4, Decode(主床位_In, v_床号, 0, 1), r_Curlogrow.病区id,
           r_Curlogrow.科室id, r_Curlogrow.医疗小组id, r_Curlogrow.护理等级id, v_床位等级id, v_床号, r_Curlogrow.责任护士, r_Curlogrow.经治医师,
           r_Curlogrow.主治医师, r_Curlogrow.主任医师, r_Curlogrow.病情, 操作员编号_In, 操作员姓名_In);
      
        v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
      End Loop;
      --更新病人信息
      Update 病人信息
      Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = 主床位_In, 在院 = 1
      Where 病人id = 病人id_In;
    
      --更新在院病人
      Begin
        Update 在院病人 Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id Where 病人id = 病人id_In;
        If Sql%Rowcount = 0 Then
          Insert Into 在院病人
            (病人id, 科室id, 病区id)
          Values
            (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      --更新病案主页出院病床
      Update 病案主页 Set 出院病床 = 主床位_In Where 病人id = 病人id_In And 主页id = 主页id_In;
      Close c_Curlog;
    End If;
    --删除出院诊断 保留该诊断信息
    --Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 in (3,13) And 记录来源 = 2;
  
    Begin
      Select 共享号 Into v_共享号 From Zlsystems Where Floor(编号 / 100) = 3;
    Exception
      When Others Then
        Null;
    End;
    --删除该病人的随诊记录
    If v_共享号 = 100 Then
      Execute Immediate 'Delete From 随诊记录 Where 病人id =:1 And 主页id =:2'
        Using 病人id_In, 主页id_In;
    End If;
  Elsif r_Curlogrow.开始原因 = 1 And v_撤销方式 = '入院入住' Then
    --撤消入科(入院同时入科)
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    Close c_Curlog;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Update 病案主页 Set 入院病床 = Null, 出院病床 = Null, 状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
  
    --恢复变动(入院同时入科不会有包床)
    --因为是同一条记录中的撤消,所以不处理人员
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  Elsif r_Curlogrow.开始原因 = 2 And v_撤销方式 = '入住' Then
    --撤消入院入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Open c_Prelog(v_开始时间, 2);
    Fetch c_Prelog
      Into r_Prelogrow;
    Update 病案主页
    Set 入院病床 = Null, 出院病床 = Null, 状态 = 1, 当前病况 = r_Prelogrow.病情, 入院病况 = r_Prelogrow.病情, 医疗小组id = r_Prelogrow.医疗小组id,
        护理等级id = r_Prelogrow.护理等级id
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    Close c_Prelog;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
    Delete 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And (信息名 = '主治医师' Or 信息名 = '主任医师');
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科入住' Then
    --撤消转科入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件
    Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And 创建时间 >= r_Curlogrow.开始时间;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '转科', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 3) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该科室前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        --判断是否有婴儿
        Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
        If v_Count > 0 Then
          Select 母婴转科标志 Into v_母婴转科标志 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
          If v_母婴转科标志 Is Not Null Then
            If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
              --如果是1表示母亲和婴儿未分开，则清空“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”；
              Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
              Else
                v_母婴转科标志 := '';
              End If;
            Else
              --如果是0，表示是上次转科是母亲单独转走的，则重新将原产科科室和病区填写到“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”（从病人变动记录中取），并清除最后一位标识
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
                --查看上一次转科的标识
                If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
                  Update 病案主页
                  Set 婴儿科室id = Null, 婴儿病区id = Null
                  Where 病人id = 病人id_In And 主页id = 主页id_In;
                Else
                  --取出转科前的婴儿科室病区ID
                  v_Tmp   := v_母婴转科标志;
                  v_Count := 1;
                  While v_Tmp Is Not Null Loop
                    v_Count := v_Count + 1;
                    If Substr(v_Tmp, Length(v_Tmp)) = '1' Then
                      Select Max(a.科室id) As 科室id, Max(a.病区id) As 科室id
                      Into n_原科室id, n_原病区id
                      From (Select 科室id, 病区id, Rownum As 序号
                             From (Select 科室id, 病区id
                                    From 病人变动记录
                                    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 附加床位 = 0
                                    Order By 开始时间 Desc)) a
                      Where 序号 = v_Count;
                    End If;
                    If Length(v_Tmp) = 1 Then
                      v_Tmp := '';
                    Else
                      v_Tmp := Substr(v_Tmp, 1, Length(v_Tmp) - 1);
                    End If;
                  End Loop;
                  If Nvl(n_原科室id, 0) = 0 Then
                    --如果没有找到，则取入院科室
                    Select Max(b.科室id), Max(b.病区id)
                    Into n_原科室id, n_原病区id
                    From 病人变动记录 b
                    Where b.病人id = 病人id_In And b.主页id = 主页id_In And b.科室id Is Not Null And b.病区id Is Not Null And
                          b.开始时间 = (Select Min(a.开始时间)
                                    From 病人变动记录 a
                                    Where a.病人id = b.病人id And a.主页id = b.主页id And a.科室id Is Not Null And
                                          a.病区id Is Not Null And a.附加床位 = 0);
                  End If;
                
                  If Nvl(n_原科室id, 0) <> 0 Then
                    Update 病案主页
                    Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  Else
                    --之前没有转科记录,清空婴儿科室ID和婴儿病区ID
                    Update 病案主页
                    Set 婴儿科室id = Null, 婴儿病区id = Null
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  End If;
                End If;
              Else
                --只有这一次转科,回退后清空婴儿科室病区ID
                v_母婴转科标志 := '';
                Update 病案主页
                Set 婴儿科室id = Null, 婴儿病区id = Null
                Where 病人id = 病人id_In And 主页id = 主页id_In;
              End If;
            End If;
            --去除最后一位标识
            Update 病案主页 Set 母婴转科标志 = v_母婴转科标志 Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        
        End If;
      
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主治医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主任医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
      
        Update 病人信息
        Set 当前病区id = r_Prelogrow.病区id, 当前科室id = r_Prelogrow.科室id, 当前床号 = r_Prelogrow.床号
        Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0), 科室id = r_Prelogrow.科室id Where 病人id = 病人id_In;
      
      End If;
    End Loop;
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 病区id = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '换床' Then
    --撤消换床
    v_开始时间 := r_Curlogrow.开始时间;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人最近一次换床前所入住的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '床位对换' Then
    --撤消床位对换
    v_开始时间 := r_Curlogrow.开始时间;
    Select 姓名 Into v_姓名 From 病人信息 Where 病人id = 病人id_In;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]病人 ' || v_姓名 || ' 的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间 And 开始时间 = d_开始时间;
  Elsif r_Curlogrow.开始原因 = 5 And v_撤销方式 = '床位等级变动' Then
    --撤消床位等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.床位等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --还原原床位的等级
    For r_Prelogrow In c_Prelog(r_Curlogrow.开始时间, 5) Loop
      d_开始时间 := r_Prelogrow.开始时间;
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 等级id = r_Prelogrow.床位等级id
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = d_开始时间;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 6 And v_撤销方式 = '护理等级变动' Then
    --撤消护理等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.护理等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(r_Curlogrow.开始时间, 6);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原护理等级
    Update 病案主页 Set 护理等级id = r_Prelogrow.护理等级id Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null;
  
    --医嘱产生的护理等级变动没有记录秒，可能前一等级的停止时间与当前等级的开始时间是同一分钟，所以要取max(id)
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 7 And v_撤销方式 = '经治医师改变' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
    --撤消经治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 7);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医师
    Update 病案主页 Set 住院医师 = r_Prelogrow.经治医师 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 7 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 7 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 8 And v_撤销方式 = '责任护士改变' Then
    --撤消责任护士改变
    Open c_Prelog(r_Curlogrow.开始时间, 8);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原责任护士
    Update 病案主页 Set 责任护士 = r_Prelogrow.责任护士 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 8 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 8 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 9 And v_撤销方式 = '转为住院病人' Then
    --撤消转为住院病人
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 9);
    Fetch c_Prelog
      Into r_Prelogrow;
      
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Update 病案主页 Set 病人性质 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 9 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 9 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    If 主页id_In = 1 And Nvl(数据_In, '0') = '1' Then
      Update 病人信息 Set 住院号 = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 住院号 = Null Where 病人id = 病人id_In;
    End If;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 10 And v_撤销方式 = '预出院' Then
    --撤消预出院
    --删除病历书写时机
    Open c_Prelog(r_Curlogrow.开始时间, 10);
    Fetch c_Prelog
      Into r_Prelogrow;
      
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
    --恢复住院状态
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Curlog;
    Close c_Prelog;
  Elsif r_Curlogrow.开始原因 = 11 And v_撤销方式 = '主治医师变动' Then
    --撤消主治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 11);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 11 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 11 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 12 And v_撤销方式 = '主任医师变动' Then
    --撤消主任医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 12);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主任医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主任医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 12 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 12 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 13 And v_撤销方式 = '病况变动' Then
    --撤消病情改变
    Open c_Prelog(r_Curlogrow.开始时间, 13);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原病情
    Update 病案主页 Set 当前病况 = r_Prelogrow.病情 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 13 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 13 And 终止时间 = r_Curlogrow.开始时间 And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  
  Elsif r_Curlogrow.开始原因 = 14 And v_撤销方式 = '转医疗小组' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
  
    --撤消医疗小组改变
    Open c_Prelog(r_Curlogrow.开始时间, 14);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医疗小组
    Update 病案主页
    Set 医疗小组id = r_Prelogrow.医疗小组id, 住院医师 = r_Prelogrow.经治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 14 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 14 And 终止时间 = r_Curlogrow.开始时间  And 开始时间 = r_Prelogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区入住' Then
    --撤消入病区
    v_开始时间 := r_Curlogrow.开始时间;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(v_开始时间, 15);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    d_开始时间 := r_Prelogrow.开始时间;
    --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
    Update 病人医嘱记录
    Set 执行科室id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Curlogrow.病区id And 医嘱状态 Not In (4, 8, 9) And 开嘱时间 < v_开始时间;
    --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
    Update 住院费用记录
    Set 执行部门id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Curlogrow.病区id And 记录状态 = 0;
    Close c_Prelog;
    Close c_Curlog;
  
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 15) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该病区前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前病区id = r_Prelogrow.病区id, 当前床号 = r_Prelogrow.床号 Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      
      End If;
    End Loop;
  
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 附加床位 = Null, 主治医师 = Null, 病情 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间  And 开始时间 = d_开始时间;
  Else
    Close c_Curlog;
    v_Error := '[ZLSOFT]你执行的撤销' || v_撤销方式 || '操作已经被其他人执行,请刷新界面！[ZLSOFT]';
    Raise Err_Custom;
  End If;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, v_Error);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Undo;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Inunit
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       Varchar2,
  病区id_In     病案主页.当前病区id%Type,
  护理等级id_In 病案主页.护理等级id%Type,
  当前病况_In   病案主页.当前病况%Type,
  是否陪伴_In   病案主页.是否陪伴%Type,
  责任护士_In   病案主页.责任护士%Type,
  入病区时间_In 病人变动记录.开始时间%Type,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  主床位_In     病案主页.出院病床%Type
) As
  -----------------------------------------------------------
  --说明：完成病人入病区处理
  --参数：
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In;
  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入病区时间_In;

  r_Futureinfo   c_Futureinfo %Rowtype;
  b_Isdel        Boolean;
  r_Endinfo      c_Endinfo%Rowtype;
  r_Oldinfo      c_Oldinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;
  v_床号     Varchar2(255);
  v_当前床号 床位状况记录.床号%Type;
  v_等级id   床位状况记录.等级id%Type;
  v_病区id   病案主页.当前病区id%Type;
  v_科室id   病案主页.出院科室id%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Count    Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Open c_Oldinfo; --必须先打开

  --入病区
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;

  If v_Count = 0 Then
    v_Error := '病人当前不处于转病区状态,可能已经撤转病区，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Begin
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;
  Exception
    When Others Then
      v_病区id := 0;
  End;
  --v_病区id=0说明病人可能是转科状态
  If v_病区id = 0 Then
    v_Error := '病人当前不处于转病区状态，而是处于转科状态，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If v_病区id <> 病区id_In Then
    v_Error := '当前该病人即将入住的病区和变动记录中实际要入住病区不符,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  --产生新变动
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In,
      护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In, 责任护士 = 责任护士_In, 是否陪伴 = 是否陪伴_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In)
  Where 病人id = 病人id_In;

  --更新在院病人
  v_科室id := 0;
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0) Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Select 出院科室id Into v_科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
  Exception
    When Others Then
      v_科室id := 0;
  End;
  If v_科室id > 0 Then
    Insert Into 在院病人 (病人id, 科室id, 病区id) Values (病人id_In, v_科室id, Nvl(病区id_In, 0));
  End If;

  --退除病人当前床位
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --记录上一步的终止操作人员
  If r_Oldinfo.终止时间 Is Not Null Then
    v_变动终止时间 := r_Oldinfo.终止时间;
    v_变动终止原因 := r_Oldinfo.终止原因;
    v_变动终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入病区时间_In) - 入病区时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
  End If;

  Delete From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;

  --新的床位记录
  If 床号_In Is Null Then
    --仅家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师,
       当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
      b_Isdel := True;
    End If;
  
    v_Count := 0;
    v_床号  := 床号_In || ',';
  
    While v_床号 Is Not Null Loop
      v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_当前床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_当前床号
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 科室id, 医疗小组id, 床位等级id, 床号, 经治医师, 主治医师, 主任医师, 操作员编号, 操作员姓名, 终止时间, 终止原因,
               终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               r_Futureinfo.科室id, r_Futureinfo.医疗小组id, v_等级id, v_当前床号, r_Futureinfo.经治医师, r_Futureinfo.主治医师,
               r_Futureinfo.主任医师, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
               r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
    
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      v_Count := v_Count + 1;
    End Loop;
  End If;
  --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
  Update 病人变动记录
  Set 病区id = 病区id_In, 责任护士 = 责任护士_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 当前病况_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Close c_Oldinfo;
  Close c_Endinfo;
  --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
  Update 病人医嘱记录
  Set 执行科室id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Oldinfo.病区id And 医嘱状态 Not In (4, 8, 9);
  --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
  Update 住院费用记录
  Set 执行部门id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Oldinfo.病区id And 记录状态 = 0;
  --已发送且未执行且未记帐审核或未收费的医嘱发送记录，如果执行科室是原病区的，应更新为当前病区
  Update 病人医嘱发送 a
  Set a.执行部门id = 病区id_In
  Where a.执行部门id = r_Oldinfo.病区id And a.执行状态 = 0 And Exists
   (Select 1
         From 住院费用记录 b
         Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 0 And 病人id = 病人id_In And 主页id = 主页id_In);

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Inunit;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Indept
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  床号_In         Varchar2,
  病区id_In       病案主页.当前病区id%Type,
  科室id_In       病案主页.出院科室id%Type,
  医疗小组id_In   病案主页.医疗小组id%Type,
  护理等级id_In   病案主页.护理等级id%Type,
  当前病况_In     病案主页.当前病况%Type,
  责任护士_In     病案主页.责任护士%Type,
  门诊医师_In     病案主页.门诊医师%Type,
  住院医师_In     病案主页.住院医师%Type,
  是否陪伴_In     病案主页.是否陪伴%Type,
  入院时间_In     病案主页.入院日期%Type,
  入科时间_In     病人变动记录.开始时间%Type,
  操作员编号_In   人员表.编号%Type,
  操作员姓名_In   人员表.姓名%Type,
  入院_In         Number,
  主治医师_In     病案主页.住院医师%Type := Null,
  主任医师_In     病案主页.住院医师%Type := Null,
  主床位_In       病案主页.出院病床%Type := Null,
  母婴转科标志_In 病案主页.母婴转科标志%Type := '1'
) As
  -----------------------------------------------------------
  --说明：完成病人入院或转科入科处理。
  --参数：
  --       入院_IN:病人是入院还是转科入科。
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In)) A, 病人变动记录 B
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入科时间_In;

  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入科时间_In;

  r_Futureinfo   c_Futureinfo %Rowtype;
  b_Isdel        Boolean;
  r_Oldinfo      c_Oldinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  v_床号         Varchar2(255);
  v_当前床号     床位状况记录.床号%Type;
  v_等级id       床位状况记录.等级id%Type;
  v_病区id       病案主页.当前病区id%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_再入院       病案主页.再入院%Type;
  v_终止人员     病人变动记录.终止人员%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Count        Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Select Zl_住院日报_Count(科室id_In, 入科时间_In) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;
  --都要更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前科室id = 科室id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In), 入院时间 = 入院时间_In
  Where 病人id = 病人id_In;
  --更新在院病人
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0), 科室id = 科室id_In Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Insert Into 在院病人 (病人id, 科室id, 病区id) Values (病人id_In, 科室id_In, Nvl(病区id_In, 0));
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 入院_In = 1 Then
    --入院入科
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;
  
    If v_Count = 0 Then
      v_Error := '病人当前不处于入院状态,可能已经撤入院，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select 入院病区id, 再入院 Into v_病区id, v_再入院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    If v_病区id <> 病区id_In Then
      v_Error := '当前入住病区与病人登记病区不一致,病人状态已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    --病案主页
    --同时更改了入院登记时的科室,病区,病况
    Update 病案主页
    Set 入院科室id = 科室id_In, 入院病区id = 病区id_In, 入院病况 = 当前病况_In, 状态 = 0, 入院病床 = Decode(床号_In, Null, Null, 主床位_In),
        出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 出院科室id = 科室id_In,
        医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In), 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In,
        责任护士 = 责任护士_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In, 是否陪伴 = 是否陪伴_In, 入院日期 = 入院时间_In
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病案主页从表
    Set 信息值 = 主治医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主治医师', 主治医师_In);
    End If;
    Update 病案主页从表
    Set 信息值 = 主任医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主任医师', 主任医师_In);
    End If;
  
    --记录上一步的终止操作人员
    Update 病人变动记录
    Set 终止时间 = 入科时间_In, 终止原因 = 2, 终止人员 = 操作员姓名_In,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
  
    If 床号_In Is Null Then
      --仅家庭病床
      Insert Into 病人变动记录
        (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, 0, 病区id_In, 科室id_In, Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
         Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, 住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In,
         操作员姓名_In);
    Else
      --多张床位
      v_床号 := 床号_In || ',';
    
      While v_床号 Is Not Null Loop
        v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
        Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 2, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           Decode(医疗小组id_In, 0, Null, 医疗小组id_In), Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In,
           住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In, 操作员姓名_In);
      
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
      
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 科室id_In, 科室id)
        Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        v_床号 := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
    End If;
    --产生病历书写时机
    If v_再入院 = 0 Then
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
    Else
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
    End If;

    --添加首份体温单
    Zl_病人体温单_NewFirst(病人id_In,主页id_In,病区id_In);

    -- 修改入院时间
    If 入院时间_In Is Not Null Then
      Update 病人变动记录
      Set 开始时间 = 入院时间_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 开始时间 <> 入院时间_In;
    End If;
  Else
    --转科入科
    Open c_Oldinfo; --必须先打开
    Fetch c_Oldinfo
      Into r_Oldinfo;
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;
  
    If v_Count = 0 Then
      v_Error := '病人当前不处于转科状态,可能已经撤转科，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录 --病区与科室独立时,临时记录里没有填,为Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  
    If v_病区id <> 病区id_In Then
      --病区与科室独立时,由于是Null判断,所以不会提示
      v_Error := '当前入住病区与病人登记病区不一致,病人状态已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
    Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_Count > 0 Then
      --有婴儿才处理
      v_母婴转科标志 := 母婴转科标志_In;
      --取出婴儿科室病区ID
      Select 婴儿科室id, 婴儿病区id
      Into n_原科室id, n_原病区id
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
    
      If Nvl(n_原科室id, 0) <> 0 Then
        --母婴转科标志_In=0表示只转母亲，婴儿科室ID不为Null表示已经分离了，已经分离了默认只转母亲
        v_母婴转科标志 := '0';
        --如果相等，则表示母亲转回婴儿科室,清空婴儿科室ID
        If n_原科室id = 科室id_In Then
          Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
        End If;
      Else
        --为null表示母婴未分离
        Select 出院科室id, 当前病区id
        Into n_原科室id, n_原病区id
        From 病案主页
        Where 病人id = 病人id_In And 主页id = 主页id_In;
        If Nvl(n_原科室id, 0) <> 0 Then
          --只转母亲
          If v_母婴转科标志 = 0 Then
            Update 病案主页
            Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
            Where 病人id = 病人id_In And 主页id = 主页id_In;
          Else
            Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        End If;
      End If;
      Update 病案主页 Set 母婴转科标志 = 母婴转科标志 || v_母婴转科标志 where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
    --病案主页
    Update 病案主页
    Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 出院科室id = 科室id_In,
        医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In), 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In,
        责任护士 = 责任护士_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In, 是否陪伴 = 是否陪伴_In
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病案主页从表
    Set 信息值 = 主治医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主治医师', 主治医师_In);
    End If;
    Update 病案主页从表
    Set 信息值 = 主任医师_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    If Sql%Rowcount = 0 Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, 主页id_In, '主任医师', 主任医师_In);
    End If;
  
    --退除病人当前床位
    For r_Bedrow In c_Bedinfo Loop
      Update 床位状况记录
      Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
      Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
    End Loop;
  
    --记录上一步的终止操作人员等
    If r_Oldinfo.终止时间 Is Not Null Then
      v_变动终止时间 := r_Oldinfo.终止时间;
      v_变动终止原因 := r_Oldinfo.终止原因;
      v_变动终止人员 := r_Oldinfo.终止人员;
      --取消上次变动
      Update 病人变动记录
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员, 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
      --更新将来的记录如果有停止到将来的则删除上次计算时间
      Update 病人变动记录
      Set 上次计算时间 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    Else
      Update 病人变动记录
      Set 终止时间 = 入科时间_In, 终止原因 = 3, 终止人员 = v_终止人员,
          上次计算时间 = Decode(Sign(Nvl(上次计算时间, 入科时间_In) - 入科时间_In), 1, Null, 上次计算时间)
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
    End If;
  
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 开始时间 Is Null And 终止时间 Is Null;
  
    --新的床位记录
    If 床号_In Is Null Then
      --仅家庭病床
      Insert Into 病人变动记录
        (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, 0, 病区id_In, 科室id_In, Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
         Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, 住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In,
         操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      --如果修改了床位，则必须修改停止到将来的变动数
      If c_Oldinfo%Rowcount <> 1 Then
        --删除所有将来的附加床位的变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In;
      End If;
      --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
      Update 病人变动记录
      Set 床位等级id = Null, 床号 = Null
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    Else
      v_床号  := 床号_In || ',';
      v_Count := 0;
      While v_床号 Is Not Null Loop
        v_Count := v_Count + 1;
        v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
      --如果修改了床位，则必须修改停止到将来的变动数
      b_Isdel := False;
      If c_Oldinfo%Rowcount <> v_Count Then
        --删除所有将来的附加床位的变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入科时间_In;
        b_Isdel := True;
      End If;
    
      v_床号 := 床号_In || ',';
      While v_床号 Is Not Null Loop
        v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
        Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名, 终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入科时间_In, 3, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, 科室id_In,
           Decode(医疗小组id_In, 0, Null, 医疗小组id_In), Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In,
           住院医师_In, 主治医师_In, 主任医师_In, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
      
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 科室id_In, 科室id)
        Where 病区id = 病区id_In And 床号 = v_当前床号;
      
        If b_Isdel = True Then
          --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
          If 主床位_In = v_当前床号 Then
            --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
            Update 病人变动记录
            Set 床位等级id = v_等级id, 床号 = v_当前床号
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In And 附加床位 = 0;
          Else
            Open c_Futureinfo; --必须先打开
            Fetch c_Futureinfo
              Into r_Futureinfo;
            --循环停到将来的数据，进行附加床位插入
            While c_Futureinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 床位等级id, 床号, 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
                 v_等级id, v_当前床号, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
                 r_Futureinfo.终止人员);
              Fetch c_Futureinfo
                Into r_Futureinfo;
            End Loop;
            Close c_Futureinfo;
          End If;
        End If;
        v_床号 := Substr(v_床号, Instr(v_床号, ',') + 1);
      End Loop;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
    Update 病人变动记录
    Set 病区id = 病区id_In, 科室id = 科室id_In, 医疗小组id = Decode(医疗小组id_In, 0, Null, 医疗小组id_In),
        护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 责任护士 = 责任护士_In, 经治医师 = 住院医师_In, 主治医师 = 主治医师_In, 主任医师 = 主任医师_In,
        病情 = 当前病况_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入科时间_In;
    Close c_Oldinfo;
    --产生病历书写时机
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '转科', 科室id_In, 住院医师_In, 入科时间_In, 入科时间_In);
  End If;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Indept;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Out
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  疾病id_In       病人诊断记录.疾病id%Type,
  诊断id_In       病人诊断记录.诊断id%Type,
  出院诊断_In     病人诊断记录.诊断描述%Type,
  出院情况_In     病人诊断记录.出院情况%Type,
  中医疾病id_In   病人诊断记录.疾病id%Type,
  中医诊断id_In   病人诊断记录.诊断id%Type,
  中医诊断_In     病人诊断记录.诊断描述%Type,
  中医出院情况_In 病人诊断记录.出院情况%Type,
  是否疑诊_In     病案主页.是否确诊%Type, --同时作为西医的是否疑诊
  出院方式_In     病案主页.出院方式%Type,
  出院时间_In     病案主页.出院日期%Type,
  随诊标志_In     病案主页.随诊标志%Type, --0/NULL-不随诊，1-月，2-年，3-周，4-天，9-终身
  随诊期限_In     病案主页.随诊期限%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  操作员编号_In   病人变动记录.操作员编号%Type,
  操作员姓名_In   病人变动记录.操作员姓名%Type,
  确诊日期_In     病案主页.确诊日期%Type := Null
) As
  -----------------------------------------------------------
  --说明：病人出院
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  v_Count Number;
  Err_Custom Exception;
  v_Error      Varchar2(255);
  v_随诊期限   Date;
  v_应发时间   Date;
  v_共享号     Zlsystems.共享号%Type;
  v_年龄       病人信息.年龄%Type;
  v_Sql        Varchar2(1000);
  v_住院医师   Varchar2(20);
  v_出院科室   Number;
  v_姓名       病人信息.姓名%Type;
  n_婴儿科室id 病案主页.婴儿科室id%Type;
Begin
  --首先判断该病人是否已出院
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;

  If v_Count = 0 Then
    v_Error := '操作失败,该病人可能已经出院！';
    Raise Err_Custom;
  End If;

  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能出院！';
    Raise Err_Custom;
  End If;

  --临床路径正在执行时不允许出院
  Select Max(b.状态)
  Into v_Count
  From 病案主页 a, 病人临床路径 b
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.病人id = b.病人id And a.主页id = b.主页id And a.出院科室id = b.科室id;
  If v_Count = 1 Then
    v_Error := '该病人的临床路径正在执行中,不能出院。';
    Raise Err_Custom;
  End If;

  --母婴分离婴儿未出院则母亲不能出院
  Select 婴儿科室id Into n_婴儿科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_婴儿科室id Is Not Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 a, 诊疗项目目录 b
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊疗项目id = b.Id And b.操作类型 = '5' And b.类别 = 'Z' And
          Nvl(a.婴儿, 0) <> 0 And a.医嘱状态 <> 4;
    If v_Count = 0 Then
      v_Error := '该病人的婴儿还在其他科室，并未下达出院医嘱,请先给婴儿下达出院医嘱后再出院。';
      Raise Err_Custom;
    End If;
  End If;

  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --判断是否产生住院日报
  Select Nvl(出院科室id, 入院科室id), 住院医师
  Into v_出院科室, v_住院医师
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  Select Zl_住院日报_Count(v_出院科室, 出院时间_In) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;

  --判断是否与病案系统共享
  Begin
    Select 共享号 Into v_共享号 From Zlsystems Where Floor(编号 / 100) = 3;
  Exception
    When Others Then
      Null;
  End;
  --出院变动
  Update 病人变动记录
  Set 终止时间 = 出院时间_In, 终止原因 = 1, 终止人员 = 操作员姓名_In, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 出院时间_In) - 出院时间_In), 1, Null, 上次计算时间)
  Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;

  --床位记录
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院日期 = 出院时间_In, 出院方式 = 出院方式_In,
      住院天数 = Decode(Trunc(出院时间_In) - Trunc(入院日期), 0, 1, Trunc(出院时间_In) - Trunc(入院日期)), 随诊标志 = 随诊标志_In,
      随诊期限 = Decode(随诊期限_In, 0, Null, 随诊期限_In), 尸检标志 = 尸检标志_In, 是否确诊 = Decode(Nvl(是否疑诊_In, 0), 0, 0, 1), 病案状态 = Null,
      确诊日期 = 确诊日期_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --产生病历书写时机
  Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', v_出院科室, v_住院医师, 出院时间_In, 出院时间_In);
  --增加随诊记录
  If v_共享号 = 100 Then
    If Nvl(随诊期限_In, 0) <> 0 Then
      If 随诊标志_In = 1 Then
        v_随诊期限 := Add_Months(出院时间_In, 随诊期限_In);
      Elsif 随诊标志_In = 2 Then
        v_随诊期限 := Add_Months(出院时间_In, 12 * 随诊期限_In);
      Elsif 随诊标志_In = 3 Then
        v_随诊期限 := 出院时间_In + 7 * 随诊期限_In;
      Elsif 随诊标志_In = 4 Then
        v_随诊期限 := 出院时间_In + 随诊期限_In;
      End If;
    Else
      v_随诊期限 := To_Date('3000-1-1', 'YYYY-MM-DD');
    End If;
  
    If 随诊标志_In = 1 Or 随诊标志_In = 2 Or 随诊标志_In = 3 Or 随诊标志_In = 4 Then
      If v_随诊期限 > Add_Months(出院时间_In, 3) Then
        v_应发时间 := Trunc(Add_Months(出院时间_In, 3));
      Else
        v_应发时间 := v_随诊期限;
      End If;
      v_Sql := 'Insert Into 随诊记录 (ID, 病人id, 主页id, 随诊期限, 应发时间) Values (随诊记录_Id.Nextval,:1,:2,:3,:4)';
      Execute Immediate v_Sql
        Using 病人id_In, 主页id_In, To_Date(To_Char(v_随诊期限, 'YYYY-MM-DD'), 'YYYY-MM-DD'), To_Date(To_Char(v_应发时间, 'YYYY-MM-DD'), 'YYYY-MM-DD');
    End If;
  End If;
  --病人信息
  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息
  Set 当前科室id = Null, 当前病区id = Null, 当前床号 = Null, 出院时间 = 出院时间_In, 年龄 = v_年龄, 在院 = Null
  Where 病人id = 病人id_In;
  --在院病人
  Delete From 在院病人 Where 病人id = 病人id_In;
  --出院诊断
  If 出院诊断_In Is Not Null Or 疾病id_In Is Not Null Or 诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 3 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 3, 1, 疾病id_In, 诊断id_In, 出院诊断_In, Decode(Nvl(是否疑诊_In, 0), 0, 1, 0),
       出院情况_In, Sysdate, 操作员姓名_In);
  End If;

  --中医出院诊断
  If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Or 中医诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 13 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 13, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Null, 中医出院情况_In, Sysdate, 操作员姓名_In);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Out;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Move
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  换床时间_In   病人变动记录.开始时间%Type,
  床号_In       Varchar2,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  病区id_In     病人变动记录.病区id%Type,
  主床位_In     病人信息.当前床号%Type,
  对换病人id_In 病案主页.病人id%Type := Null
) As
  -----------------------------------------------------------
  --说明：病人换床
  --参数：
  --       床号=Null:家庭病床;"床号1,床号2,....床号n"
  --       对换病人ID_IN 床位对换必须传入病人ID
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 换床时间_In;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 换床时间_In;

  r_Futureinfo c_Futureinfo %Rowtype;
  b_Isdel      Boolean;
  r_Oldinfo    c_Oldinfo%Rowtype;
  v_终止原因   病人变动记录.终止原因%Type;
  v_终止时间   病人变动记录.终止时间%Type;
  v_终止人员   病人变动记录.终止人员%Type;

  v_床号串 Varchar2(255);
  v_床号   Varchar2(255);
  v_等级id 床位状况记录.等级id%Type;
  v_年龄   病人信息.年龄%Type;
  n_病人id 病案主页.病人id%Type;
  n_病区id 病案主页.当前病区id%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(状态, 0) = 0;

  If v_Count = 0 Then
    v_Error := '病人当前不处于正常住院状态,可能尚未入科,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select 当前病区id Into n_病区id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;

  If n_病区id <> 病区id_In Then
    v_Error := '当前操作病区与病人实际病区不一致,病人病区已经更改,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人后再试！';
    Raise Err_Custom;
  End If;

  --退除病人原床位
  v_Count := 0;
  For r_Bedrow In c_Bedinfo Loop
    v_Count := v_Count + 1;
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;
  If 对换病人id_In Is Not Null And v_Count > 1 Then
    v_Error := '操作失败,床位为' || v_床号 || '的病人为包床病人，不允许进行床位对换！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
    Raise Err_Custom;
  End If;

  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  For r_Fee In (Select No
                From 住院费用记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= 换床时间_In And 收费类别 = 'J'
                Group By No, 序号, Mod(记录性质, 10)
                Having Sum(结帐金额) <> 0) Loop
    v_Error := '变动时间之后已有已结帐的自动记帐费用,不能进行换床操作！';
    Raise Err_Custom;
  End Loop;

  --取消上批变动记录
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 换床时间_In, 终止原因 = 4, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 换床时间_In, 终止原因 = 4, 终止人员 = 操作员姓名_In,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 换床时间_In) - 换床时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --新增病人床位
  If 床号_In Is Null Then
    --家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 换床时间_In, 4, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id,
       Null, Null, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In,
       v_终止时间, v_终止原因, v_终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 换床时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In;
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    If v_Count > 1 And 对换病人id_In Is Not Null Then
      v_Error := '操作失败,床位对换不允许包床！' || Chr(13) || Chr(10) || '这可能是调用过程传参错误,请与开发商联系！';
      Raise Err_Custom;
    End If;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 换床时间_In;
      b_Isdel := True;
    End If;
  
    --入住一张或多张病床病床
    v_床号串 := 床号_In || ',';
  
    While v_床号串 Is Not Null Loop
      v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
    
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 换床时间_In, 4, Decode(主床位_In, v_床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, v_等级id, v_床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
         r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
    
      --换床检查床位是否为空：床位对换如果目标床位不为空，则检查是否是床位对换的病人
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号 And 状态 = '空床';
      If 对换病人id_In Is Null Then
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
          Raise Err_Custom;
        End If;
      Else
        If v_Count = 0 Then
          Select Max(病人id) Into n_病人id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_床号;
          If n_病人id Is Null Then
            v_Error := '操作失败,床位 ' || v_床号 || ' 不是有效的床位！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
            Raise Err_Custom;
          End If;
          If n_病人id <> 对换病人id_In Then
            v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床,且对换床位的病人发生了变化！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新后再试！';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_床号, 病区id = 病区id_In
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 换床时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               病区id_In, r_Futureinfo.科室id, r_Futureinfo.医疗小组id, r_Futureinfo.护理等级id, v_等级id, v_床号, r_Futureinfo.责任护士,
               r_Futureinfo.经治医师, r_Futureinfo.主治医师, r_Futureinfo.主任医师, r_Futureinfo.病情, r_Futureinfo.操作员编号,
               r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因, r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
    
      v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
    End Loop;
  End If;
  Close c_Oldinfo;

  --病人信息、病案主页

  Update 病案主页
  Set 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息
  Set 当前床号 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In, 年龄 = v_年龄
  Where 病人id = 病人id_In;

  --在院病人
  Update 在院病人 Set 病区id = 病区id_In Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Move;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人变动记录_Bedlevel
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       病人变动记录.床号%Type,
  等级id_In     病人变动记录.床位等级id%Type,
  生效时间_In   病人变动记录.开始时间%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：更改床位等级
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 生效时间_In;

  Cursor c_Endinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%Rowtype;
  r_Endinfo  c_Endinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  If Nvl(r_Endinfo.床号, '') <> 床号_In Then
    v_Error := '发现病人的床号已经发生变化,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If r_Endinfo.床位等级id = 等级id_In Then
    v_Error := '操作失败,当前该病人的床位等级和即将调整的床位等级相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is Not Null Then
    v_终止时间 := r_Oldinfo.终止时间;
    v_终止原因 := r_Oldinfo.终止原因;
    v_终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 5, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 5, 终止人员 = 操作员姓名_In,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 生效时间_In) - 生效时间_In), 1, Null, 上次计算时间) 
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;

  --产生新变动
  While c_Oldinfo%Found Loop
    If r_Oldinfo.床号 = 床号_In Then
      Update 床位状况记录 Set 等级id = 等级id_In Where 病区id = r_Oldinfo.病区id And 床号 = 床号_In;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 5, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, 等级id_In, 床号_In, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
         r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
      --更新将来的记录
      Update 病人变动记录
      Set 床位等级id = 等级id_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In;
    Else
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 5, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
    End If;
  
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Bedlevel;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
CREATE OR REPLACE Procedure Zl_病人变动记录_ChangeGroup
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  医疗小组id_In 病人变动记录.医疗小组id%Type,
  住院医师_In   病人变动记录.经治医师%Type,
  主治医师_In   病人变动记录.主治医师%Type,
  生效时间_In   病人变动记录.开始时间%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：转医疗小组
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
        Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间) From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In)) A, 病人变动记录 B
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 生效时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo c_Oldinfo%RowType;
  r_Endinfo c_Endinfo%RowType;
  v_Count   Number;
  v_Error   Varchar2(255);
  Err_Custom Exception;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;
Begin
  Open c_Oldinfo; --必须先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%RowCount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;
  Select Count(*) Into v_count From 病人变动记录 Where 病人ID=病人ID_in And 主页ID=主页id_In And 开始时间 Is null And 终止时间 Is Null;
  If v_count > 0 Then
    v_Error := '该病人正在转科或转病区，不能进行其他变动！';
    Raise Err_Custom;
  End If;

  --如果终止时间<>NULL ，就记录下终止时间和终止原因。
  If r_Oldinfo.终止时间 Is not NULL then
    v_终止时间:=r_Oldinfo.终止时间;
    v_终止原因:=r_Oldinfo.终止原因;
    v_终止人员:=r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 14, 终止人员 = 操作员姓名_In ,上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因=v_终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录 Set 医疗小组ID=Decode(医疗小组id_In,0,Null,医疗小组id_In),上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间>生效时间_In;
  Else
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 生效时间_In, 终止原因 = 14, 终止人员 = 操作员姓名_In,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 生效时间_In) - 生效时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End IF;

 --产生新变动
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,终止时间,终止原因,终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 14, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id, Decode(医疗小组id_In,0,Null,医疗小组id_In), r_Oldinfo.护理等级id,
       r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, 住院医师_In, 主治医师_In, r_Oldinfo.主任医师, r_Oldinfo.病情,
       操作员编号_In, 操作员姓名_In,v_终止时间,v_终止原因,v_终止人员);
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  -- 产生病历书写时机
  If r_Oldinfo.经治医师 <> 住院医师_In Then
    ZL_电子病历时机_Insert(病人id_In, 主页id_In, 2, '交班', r_Oldinfo.科室id, 住院医师_In, 生效时间_In, 生效时间_In);
  End If;

  Close c_Oldinfo;
  Close c_Endinfo;

  Update 病案主页 Set 医疗小组id = Decode(医疗小组id_In,0,Null,医疗小组id_In), 住院医师 = 住院医师_In Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  Update 病案主页从表
      Set 信息值 = 主治医师_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
      If Sql%RowCount = 0 Then
        Insert Into 病案主页从表
          (病人id, 主页id, 信息名, 信息值)
        Values
          (病人id_In, 主页id_In, '主治医师', 主治医师_In);
      End If;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人变动记录_ChangeGroup;
/

--96956:刘尔旋,2016-06-03,支付宝收费误差自动计算问题
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_Count    Number(18);
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;
  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH'))
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_结帐金额, 0) - Nvl(n_收费总额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室ID, b.开单人, b.收费类别, b.收入项目id, b.附加标志,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And Nvl(b.费用状态, 0) = 0 And
                       b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室ID, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位, b.附加标志
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, c_费用.附加标志, Null, Null, Null, Null, c_费用.病人科室ID, c_费用.执行部门id);
      n_结帐金额 := n_结帐金额 + c_费用.实收金额;
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        n_预交支付 := c_结算方式.结算金额;
      Else
        If Nvl(n_普通支付, 0) = 0 Then
          n_普通支付 := c_结算方式.结算金额;
          v_结算方式 := c_结算方式.结算方式;
          If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
            Begin
              n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_结算卡序号 := 0;
            End;
            If n_结算卡序号 = 0 Then
              Begin
                Select 编号
                Into n_结算卡序号
                From 卡消费接口目录
                Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的消费卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            End If;
          Else
            Begin
              n_卡类别id := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_卡类别id := 0;
            End;
            If n_卡类别id = 0 Then
              Begin
                Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的医疗卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
          End If;
          v_结算卡号   := c_结算方式.结算卡号;
          v_交易流水号 := c_结算方式.交易流水号;
          v_交易说明   := c_结算方式.交易说明;
          v_摘要       := c_结算方式.摘要;
        Else
          v_Err_Msg := '挂号结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --预约接收
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
  
    Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别, v_结算方式,
                     n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号, v_结算卡号,
                     v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1);
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_收费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/

--96901:陈刘,2016-06-02,补充对护理汇总表的处理
Create Or Replace Procedure Zl_护理记录项目_Insert
(
  项目序号_In In 护理记录项目.项目序号%Type,
  项目名称_In In 护理记录项目.项目名称%Type,
  项目类型_In In 护理记录项目.项目类型%Type,
  项目长度_In In 护理记录项目.项目长度%Type,
  项目小数_In In 护理记录项目.项目小数%Type,
  项目单位_In In 护理记录项目.项目单位%Type,
  项目表示_In In 护理记录项目.项目表示%Type,
  项目值域_In In 护理记录项目.项目值域%Type,
  护理等级_In In 护理记录项目.护理等级%Type,
  分组名_In   In 护理记录项目.分组名%Type,
  项目id_In   In 护理记录项目.项目id%Type,
  应用方式_In In 护理记录项目.应用方式%Type,
  适用病人_In In 护理记录项目.适用病人%Type,
  项目性质_In In 护理记录项目.项目性质%Type := 1,
  应用场合_In In 护理记录项目.应用场合%Type := 0,
  说明_In     In 护理记录项目.说明%Type := Null
) Is
Begin
  Insert Into 护理记录项目
    (项目序号, 项目名称, 项目类型, 项目长度, 项目小数, 项目单位, 项目表示, 项目值域, 护理等级, 分组名, 项目id, 适用科室, 应用方式, 适用病人, 项目性质, 应用场合, 说明)
  Values
    (项目序号_In, 项目名称_In, 项目类型_In, 项目长度_In, 项目小数_In, 项目单位_In, 项目表示_In, 项目值域_In, 护理等级_In, 分组名_In, 项目id_In, 1, 应用方式_In,
     适用病人_In, 项目性质_In, 应用场合_In, 说明_In);

  If 项目表示_In = 4 Then
    Insert Into 护理汇总项目
      (序号, 父序号)
      Select 项目序号_In, Null From Dual Where Not Exists (Select 1 From 护理汇总项目 Where 序号 = 项目序号_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_护理记录项目_Insert;
/

--96901:陈刘,2016-06-07,增加对护理汇总表的处理
CREATE OR REPLACE Procedure Zl_护理记录项目_Update
(
  项目序号_In In 护理记录项目.项目序号%Type,
  项目名称_In In 护理记录项目.项目名称%Type,
  项目类型_In In 护理记录项目.项目类型%Type,
  项目长度_In In 护理记录项目.项目长度%Type,
  项目小数_In In 护理记录项目.项目小数%Type,
  项目单位_In In 护理记录项目.项目单位%Type,
  项目表示_In In 护理记录项目.项目表示%Type,
  项目值域_In In 护理记录项目.项目值域%Type,
  护理等级_In In 护理记录项目.护理等级%Type,
  分组名_In   In 护理记录项目.分组名%Type,
  项目id_In   In 护理记录项目.项目id%Type,
  应用方式_In In 护理记录项目.应用方式%Type,
  适用病人_In In 护理记录项目.适用病人%Type,
  项目性质_In In 护理记录项目.项目性质%Type := 1,
  应用场合_In In 护理记录项目.应用场合%Type := 0,
  说明_In     In 护理记录项目.说明%Type := Null
) Is
  n_汇总 Number(1);
Begin
  n_汇总 := 0;
  Select count(项目序号)  Into n_汇总 From 护理记录项目 Where 项目序号 = 项目序号_In and 项目表示=4;
  Update 护理记录项目
  Set 项目名称 = 项目名称_In, 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 项目值域 = 项目值域_In,
      护理等级 = 护理等级_In, 分组名 = 分组名_In, 项目id = 项目id_In, 应用方式 = 应用方式_In, 适用病人 = 适用病人_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In,
      说明 = 说明_In
  Where 项目序号 = 项目序号_In;

  If 项目序号_In = 2 Then
    Update 护理记录项目
    Set 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 项目值域 = 项目值域_In, 护理等级 = 护理等级_In,
        分组名 = 分组名_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In, 说明 = 说明_In
    Where 项目序号 = -1;
  End If;

  If 项目序号_In = 4 Or 项目序号_In = 5 Then
    Update 护理记录项目
    Set 项目类型 = 项目类型_In, 项目长度 = 项目长度_In, 项目小数 = 项目小数_In, 项目单位 = 项目单位_In, 项目表示 = 项目表示_In, 护理等级 = 护理等级_In, 分组名 = 分组名_In,
        应用方式 = 应用方式_In, 适用病人 = 适用病人_In, 项目性质 = 项目性质_In, 应用场合 = 应用场合_In, 说明 = 说明_In
    Where 项目序号 In (4, 5);
  End If;
  If 项目表示_In = 4 Then
    Insert Into 护理汇总项目
      (序号, 父序号)
      Select 项目序号_In, Null From Dual Where Not Exists (Select 1 From 护理汇总项目 Where 序号 = 项目序号_In);
  Else
    If n_汇总 = 1 Then
      Delete 护理汇总项目 Where 序号 = 项目序号_In;
      update  护理汇总项目  set 父序号=null where  父序号=项目序号_in;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_护理记录项目_Update;
/

--96901:陈刘,2016-06-07,增加对护理汇总表的处理
CREATE OR REPLACE Procedure Zl_护理记录项目_Delete
(
项目序号_In In 护理记录项目.项目序号%Type
) Is
  n_汇总 Number(1);
Begin
  n_汇总 := 0;
  Select count(项目序号) Into n_汇总 From 护理记录项目 Where 项目序号 = 项目序号_In And 项目表示 = 4;
  Delete From 护理记录项目 Where 项目序号 = 项目序号_In;
  If n_汇总 = 1 Then
    Delete 护理汇总项目 Where 序号 = 项目序号_In;
    update  护理汇总项目  set 父序号=null where  父序号=项目序号_in;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_护理记录项目_Delete;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
Create Or Replace Procedure Zl_门诊退费票据_Insert
(
  结算序号_In 病人预交记录.结算序号%Type,
  票据号_In   票据使用明细.号码%Type,
  领用id_In   票据使用明细.领用id%Type,
  使用人_In   票据使用明细.使用人%Type,
  使用时间_In 票据使用明细.使用时间%Type,
  票据张数_In Number := 1
) As
  --功能：处理门诊退费票据(红票)的发出
  --参数：
  --      结算序号_In    =     退费的结算序号
  --      票据号_IN   =     要使用的开始票据号。该票据号应该不为空，否则不用处理票据，也不能区分多张一起收费的单据。
  --      领用ID_IN   =     严格控制票据时，为使用票据的领用批次。非严格控制时，为NULL。
  --      票据张数_In =     实际所需的票据打印张数
  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_票据号     票据使用明细.号码%Type;
  v_当前票据号 票据使用明细.号码%Type;
  v_打印id     票据打印内容.Id%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --无票据号时,不用处理票据
  If 票据号_In Is Null Then
    Return;
  End If;

  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;

  --生成单据的票据打印内容
  For c_No In (Select Distinct a.No
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And Nvl(a.费用状态, 0) = 0 And b.结算序号 = 结算序号_In) Loop
  
    Insert Into 票据打印内容 (ID, 数据性质, NO, 打印类型) Values (v_打印id, 1, c_No.No, Null);
  End Loop;

  --发出票据
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 票据张数_In Then
      v_Error := '当前批次的剩余数量不足' || 票据张数_In || '张，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;

  For I In 1 .. 票据张数_In Loop
    --检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '该单据需要打印多张票据，但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 1, v_票据号, 1, 6, 领用id_In, v_打印id, 使用人_In, 使用时间_In);
  
    v_当前票据号 := v_票据号;
    --下一个票据号
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前票据号, 剩余数量 = Nvl(剩余数量, 0) - 票据张数_In
    Where ID = 领用id_In;
  
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费票据_Insert;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
Create Or Replace Procedure Zl_补充结算退费票据_Insert
(
  结算序号_In 病人预交记录.结算序号%Type,
  票据号_In   票据使用明细.号码%Type,
  领用id_In   票据使用明细.领用id%Type,
  使用人_In   票据使用明细.使用人%Type,
  使用时间_In 票据使用明细.使用时间%Type,
  票据张数_In Number
) As
  --功能：处理门诊收费票据的发出 
  --参数： 
  --      结算序号_In    =     退费的结算序号
  --      票据号_IN   =     要使用的开始票据号。该票据号应该不为空，否则不用处理票据，也不能区分多张一起收费的单据。 
  --      领用ID_IN   =     严格控制票据时，为使用票据的领用批次。非严格控制时，为NULL。 
  --      票据张数_In =     实际所需的票据打印张数 

  --该游标用于票据范围判断 
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_票据号     票据使用明细.号码%Type;
  v_当前票据号 票据使用明细.号码%Type;
  v_打印id     票据打印内容.Id%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;

  --生成单据的票据打印内容 
  For c_No In (Select Distinct a.No
               From 费用补充记录 A
               Where a.记录性质 = 1 And a.记录状态 = 2 And Nvl(a.费用状态, 0) = 0 And a.结算序号 = 结算序号_In) Loop
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 1, c_No.No);
  End Loop;

  --并发出票据 
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次，无法完成补充结算票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 票据张数_In Then
      v_Error := '当前批次的剩余数量不足' || 票据张数_In || '张，无法完成补充结算票据分配操作。';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    --检查票据范围是否正确 
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '该单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 1, v_票据号, 1, 6, 领用id_In, v_打印id, 使用人_In, 使用时间_In);
  
    v_当前票据号 := v_票据号;
    --下一个票据号 
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前票据号, 剩余数量 = Nvl(剩余数量, 0) - 票据张数_In
    Where ID = 领用id_In;
  
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_补充结算退费票据_Insert;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7'))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                      (Select 1
                            From 病人医嘱附费
                            Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_总金额
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额, 1);
        n_返回值 := n_总金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      --性质=1，原因=6为退费打印票据(红票)，不回收
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4')
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
Create Or Replace Procedure Zl_补充结算票据_Reprint
(
  No_In         门诊费用记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  领用id_In     票据使用明细.领用id%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  退费_In       Number := 0,
  票据张数_In   Number := 0,
  收回票据号_In Varchar2 := Null
) As
  --功能：用于重打收费票据 
  --参数： 
  --      NO_IN         =   要重打的单据号，可能是一起收费的多张单据中的一张。 
  --      票据号        =   用于重打的起始票据号.而该张收费单据可能使用多张票据。 
  --      领用ID        =   如果为0或NULL,表示不严格控制票据。 
  --      退费_IN       =   是否部份退费时调用该过程 
  --      收回票据号_In =   部分退费时,界面选择要收回的票据号,这些票据只收回,不重新发出,传入空表示全部收回并重打 
  --该游标用于范围判断 
  Cursor c_Fact Is
    Select 开始号码, 终止号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id 票据打印内容.Id%Type;
  v_打印id 票据打印内容.Id%Type;
  v_票据号 票据使用明细.号码%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --获取该张单据的最后一次的的打印ID(可能没有) 
  Begin
    --性质=1，原因=6为退费打印票据(红票)，不回收
    Select ID
      Into v_收回id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --收回票据(可能以前未控制票据,无法收回) 
  If v_收回id Is Not Null Then
    If 收回票据号_In Is Null Then
      If Nvl(退费_In, 0) = 0 Then
        --a.重打 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Else
        --b.部分退费重打先收回 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 票种 = 1 And 性质 = 2);
      End If;
    Else
      --c.部分退费收回指定的票据号 
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where 打印id = v_收回id And 票种 = 1 And 性质 = 1 And Instr(收回票据号_In, 号码) > 0;
      Return;
    End If;
  End If;

  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据并填写票据打印内容 
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  Insert Into 票据打印内容
    (ID, 数据性质, NO)
    Select Distinct v_打印id, 1, NO
    From (Select NO
           From 票据打印内容
           Where ID = v_收回id And 数据性质 = 1
           Union All
           Select No_In From Dual);

  --门诊费用记录中记录票据号以便显示 
  Update 费用补充记录
  Set 实际票号 = 票据号_In
  Where 记录性质 = 1 And NO In (Select NO
                            From 票据打印内容
                            Where ID = v_收回id And 数据性质 = 1
                            Union
                            Select No_In From Dual);

  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次,无法完成重打操作！';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    If Nvl(领用id_In, 0) <> 0 Then
      --检查票据范围 
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据:重打时,如果是部份退费重打,则处理为新发生；如果以前没有收回，也处理为新发出。 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 1, v_票据号, 1, Decode(Nvl(退费_In, 0), 0, Decode(v_收回id, Null, 1, 3), 1), 领用id_In, v_打印id, 使用人_In,
       使用时间_In);
  
    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);
  
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;
  Update 票据领用记录 Set 使用时间 = 使用时间_In Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_补充结算票据_Reprint;
/

--96906:许华锋,2016-05-24,RIS报告存储到HIS后的格式问题修正
--96907:许华锋,2016-05-24,查报告完成后，执行人和执行时间没有发送到HIS中
--96909:许华锋,2016-05-24,RIS报告存储后不能修改
--96922:许华锋,2016-06-01,处理一个医嘱多份报告的存储问题
--96924:许华锋,2016-05-24,处理HIS报告和RIS报告状态不同步的问题
Create Or Replace Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  Procedure Test;
  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  );

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  );

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  );

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  );

End b_Zlxwinterface;
/

Create Or Replace Package Body b_Zlxwinterface Is

  Procedure Test Is
  Begin
    Null;
  End Test;

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  ) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源, 执行科室id
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_Count Number;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允许开始检查和审核费用
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 A, 病案主页 B
    Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Adviceinfo.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，无法开始检查。';
      Raise Err_Custom;
    End If;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核      
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
      Where ID = (Select 病历id From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Risid = Risid_In);
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --开始执行医嘱 
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行 
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = Decode(v_执行过程, 6, 操作人员_In, 完成人),
            完成时间 = Decode(v_执行过程, 6, 执行时间_In, 完成时间)
        Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = Decode(v_执行过程, 6, 操作人员_In, 完成人),
            完成时间 = Decode(v_执行过程, 6, 执行时间_In, 完成时间)
        Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
  Begin
  
    Select 发送号, 执行过程 Into v_发送号, v_执行过程 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      --取主医嘱ID
      Open c_Advice;
      Fetch c_Advice
        Into r_Advice;
      Close c_Advice;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
        Into v_费用性质
        From 病人医嘱发送
        Where 发送号 = v_发送号 And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      End If;
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    v_发送号 病人医嘱发送.发送号%Type;
  Begin
  
    Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In, v_发送号, Null, 单独执行_In, 执行部门id_In, 操作员编号_In, 操作员姓名_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  ) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice
    (
      v_组id  Number,
      v_Risid Number
    ) Is
      Select e.Id, e.病人来源, e.病人id, e.主页id, e.婴儿, e.病人科室id, e.文件id, e.病历种类, e.病历名称, f.病历id, e.执行科室id
      From (Select c.Id, c.病人来源, c.病人id, c.主页id, c.婴儿, c.病人科室id, c.文件id, d.种类 病历种类, d.名称 病历名称, c.执行科室id
             From (Select a.Id, a.病人来源, a.病人id, a.主页id, a.婴儿, a.病人科室id, b.病历文件id 文件id, a.执行科室id
                    From 病人医嘱记录 A, 病历单据应用 B
                    Where a.Id = v_组id And a.诊疗项目id = b.诊疗项目id(+) And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                  病历文件列表 D
             Where c.文件id = d.Id(+)) E, 病人医嘱报告 F
      Where e.Id = f.医嘱id(+) And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where a.文件id = v_File
      Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
      From 电子病历内容 A, 电子病历内容 B
      Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = v_电子病历记录id;
  
    Cursor c_Content
    (
      v_文件id Number,
      v_表格id Number
    ) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where 文件id = v_文件id And 父id = v_表格id;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id Into v_主医嘱id From 病人医嘱记录 Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容 Set 内容文本 = 报告所见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容 Set 内容文本 = 报告意见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容 Set 内容文本 = 报告建议_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
        Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
        Where ID = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%所见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%意见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%建议%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        Insert Into 电子病历记录
          (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
        Values
          (v_病历id, r_Advice.病人来源, r_Advice.病人id, r_Advice.主页id, r_Advice.婴儿, r_Advice.病人科室id, r_Advice.病历种类,
           r_Advice.文件id, r_Advice.病历名称, 报告医生_In, Sysdate, Sysdate, 报告医生_In, Sysdate, 1, 2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告 (医嘱id, 病历id, Risid) Values (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称, r_Advice.病人id, r_Advice.主页id, r_Advice.病人来源, r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
               要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
            Values
              (v_病历内容id, v_病历id, 1, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记, r_File.保留对象,
               r_File.对象属性, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id,
               r_File.替换域, r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态,
               r_File.要素值域, Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval Into v_病历内容idnew From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
                 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
              Values
                (v_病历内容idnew, v_病历id, 1, 0, v_病历内容id, v_对象序号, 2, r_Con.对象标记, r_Con.保留对象, r_Con.对象属性, Null, v_内容文本,
                 r_Con.是否换行, r_Con.预制提纲id, r_Con.复用提纲, r_Con.使用时机, r_Con.诊治要素id, r_Con.替换域, r_Con.要素名称, r_Con.要素类型,
                 r_Con.要素长度, r_Con.要素小数, r_Con.要素单位, r_Con.要素表示, r_Con.输入形态, r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  ) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id Into v_病人来源, v_病人id From 病人医嘱记录 Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                       Sysdate - v_年龄)
        Into v_出生日期
        From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
      Set 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别),
          医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业),
          身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  ) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In, v_发送号, 操作员编号_In, 操作员姓名_In, 执行部门id_In, 拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;
End b_Zlxwinterface;
/

--96182:许华锋,2016-06-06,RIS接口日志记录
Create Or Replace Procedure Zl_RIS接口日志记录_Insert
(
  时间_In In RIS接口日志记录.时间%Type,
  站点_In In RIS接口日志记录.站点%Type,
  类型_In In RIS接口日志记录.类型%Type,
  标题_In In RIS接口日志记录.标题%Type,
  函数_In In RIS接口日志记录.函数%Type,
  内容_In In RIS接口日志记录.内容%Type
) Is
Begin
  Insert Into RIS接口日志记录
    (ID, 时间, 站点, 用户, 类型, 标题, 函数, 内容)
  Values
    (RIS接口日志记录_Id.Nextval, 时间_In, 站点_In, User, 类型_In, 标题_In, 函数_In, 内容_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_RIS接口日志记录_Insert;
/

--92161:刘尔旋,2016-06-01,预交退款红票打印
Create Or Replace Procedure Zl_病人预交记录_Delete
(
  Id_In         病人预交记录.Id%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  帐户退费_In   Number := 1,
  冲预交id_In   病人预交记录.Id%Type := Null,
  票据号_In     病人预交记录.实际票号%Type := Null,
  领用id_In     票据领用记录.Id%Type := Null
) As
  Cursor c_Moneyinfo Is
    Select ID, NO, 金额, 结算方式, 病人id, 预交类别
    From 病人预交记录
    Where ID = Id_In And 记录性质 = 1 And 记录状态 = 1;
  r_Moneyrow c_Moneyinfo%RowType;

  v_打印id   票据打印内容.Id%Type;
  v_性质     结算方式.性质%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;
  n_预交id   病人预交记录.Id%Type;
  v_Date     Date;
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;
  v_Msg  Varchar2(500);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;

  Open c_Moneyinfo;
  Fetch c_Moneyinfo
    Into r_Moneyrow;

  --首先判断要退款的记录是否存在
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Raise Err_Custom;
  Else
    Select Sysdate Into v_Date From Dual;
    If 冲预交id_In Is Not Null Then
      n_预交id := 冲预交id_In;
    Else
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
  
    --处理票据
    If 票据号_In Is Not Null Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    
      --发出票据
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 6, 领用id_In, v_打印id, v_Date, 操作员姓名_In);
    
      --状态改动
      Update 票据领用记录
      Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
      
      v_打印id := Null;
    End If;
  
    --预交退款
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持个人帐户退费,正常处理
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要_In, -1 * 金额, 结算方式, 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, 缴款单位,
               单位开户行, 单位帐号, n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    Else
      --不支持时,处理成现金,记录性质为2的摘要填标志,为3的更新新输入的摘要
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, Nvl(摘要_In, '个人帐户退款'), -1 * 金额,
               Decode(结算方式, v_个人帐户, v_现金, 结算方式), 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, Decode(结算方式, v_个人帐户, Null, 缴款单位),
               Decode(结算方式, v_个人帐户, Null, 单位开户行), Decode(结算方式, v_个人帐户, Null, 单位帐号), n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明,
               合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    End If;
  
    Update 病人预交记录 Set 记录状态 = 3, 摘要 = 摘要_In Where ID = Id_In;
  
    --处理相关汇总表
    --人员缴款余额(注意包括处理个人帐户的结算方式)
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持退个人帐户时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    Else
      --不支持时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式)
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式), 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式) And
              Nvl(余额, 0) = 0;
      End If;
    End If;
  
    --病人(预交)余额(不管是退现金还是个人帐户都应该减少)
    --判断要退款的性质
    Select b.性质 Into v_性质 From 病人预交记录 A, 结算方式 B Where a.结算方式 = b.名称(+) And a.Id = Id_In;
    If Nvl(v_性质, 1) <> 5 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 病人id = r_Moneyrow.病人id And Nvl(类型, 2) = Nvl(r_Moneyrow.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, Nvl(r_Moneyrow.预交类别, 2), -r_Moneyrow.金额, 0);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --作废收回票据(可能以前没有使用票据,无法收回)
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = r_Moneyrow.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 2 And 性质 = 1;
    End If;
  
    Close c_Moneyinfo;
  End If;
  --消息推送;
  Select Id_In || ',' || 帐户退费_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 12, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20999, '[ZLSOFT]没有发现要退款的预交记录,该记录可能已经退除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Delete;
/

--91776:蔡青松,2016-05-26,添加批量签收功能
CREATE OR REPLACE Procedure Zl_Lis预置条码_标本送出
( 
  医嘱内容_In Varchar2, --内容包括多个|医嘱ID,医嘱ID,医嘱ID...| 
  Type_In     Number := 0, --0为送检 1为取消送检 
  送检人_In   病人医嘱发送.送检人%Type := '' ,
  标本发送批号_In 病人医嘱发送.标本发送批号%type
) Is 
  V_Nowdate Date; 
Begin 
  If Type_In = 0 Then 
    V_Nowdate := Sysdate; 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Decode(标本送出时间, Null, V_Nowdate, 标本送出时间), 送检人 = 送检人_In ,标本发送批号 = 标本发送批号_In
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  Else 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Null, 送检人 = Null ,标本发送批号 = Null
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  End If; 
Exception 
 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_Lis预置条码_标本送出;
/

--94035:胡俊勇,2016-05-25,医嘱单打印
Create Or Replace Procedure Zl_病人医嘱打印_Delete
(
  病人id_In       病人医嘱记录.病人id%Type,
  主页id_In       病人医嘱记录.主页id%Type,
  婴儿_In         病人医嘱记录.婴儿%Type,
  期效_In         病人医嘱记录.医嘱期效%Type,
  起始页号_In     病人医嘱打印.页号%Type := Null,
  医嘱位置_In     Varchar2 := Null,
  清除上次打印_In Number := Null
  --清除上次打印_In 1 清除上次打印保留数据，2-清除上次打印删除打印数据，其它－按指定规则清除打印，3－清除预打印数据
) Is
  v_位置   Varchar2(10);
  n_Cnt    Number(8);
  d_重整   Date;
  n_医嘱id 病人医嘱记录.Id%Type;
Begin
  If 清除上次打印_In = 3 Then
    Delete From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 Is Null;
  Else
    --医嘱变化时的自动清除和清除指定位置医嘱，删数据方式
    If 期效_In = 1 Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    Else
      Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
      If d_重整 Is Null Then
        d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
      End If;
    End If;
  
    If 清除上次打印_In Is Null Then
      If 医嘱位置_In Is Not Null Then
        v_位置 := 医嘱位置_In;
      End If;
      If v_位置 Is Null Then
        --通过页号来找一个合适的位置
        v_位置 := LPad(起始页号_In, 4, '0') || '001';
      End If;
    Else
      Select Nvl(Min(LPad(页号, 4, '0') || LPad(行号, 3, '0')), '0001001')
      Into v_位置
      From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            打印时间 = (Select Max(打印时间)
                    From 病人医嘱打印
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In);
    End If;
  
    --处理一组医嘱打印多行的情况，如一并给药含多个药的医嘱
    For X In (Select a.医嘱id, b.序号, b.相关id, b.诊疗类别, c.操作类型
              From 病人医嘱打印 A, 病人医嘱记录 B, 诊疗项目目录 C
              Where a.医嘱id = b.Id(+) And b.诊疗项目id = c.Id(+) And a.病人id = 病人id_In And a.主页id = 主页id_In And
                    Nvl(a.婴儿, 0) = 婴儿_In And a.期效 = 期效_In And LPad(页号, 4, '0') || LPad(行号, 3, '0') = v_位置) Loop
      If x.诊疗类别 = '5' Or x.诊疗类别 = '6' Then
        Select a.Id
        Into n_医嘱id
        From 病人医嘱记录 A
        Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.医嘱期效 = 期效_In And
              a.序号 = (Select Min(序号) From 病人医嘱记录 Where 相关id = x.相关id);
      Elsif x.诊疗类别 = 'E' And x.操作类型 = '2' Then
        Select a.Id
        Into n_医嘱id
        From 病人医嘱记录 A
        Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.医嘱期效 = 期效_In And
              a.序号 = (Select Min(序号) From 病人医嘱记录 Where 相关id = x.医嘱id);
      End If;
    End Loop;
  
    n_Cnt := To_Number(v_位置);
    If n_医嘱id Is Not Null Then
      If 期效_In = 1 Then
        Select LPad(页号, 4, '0') || LPad(行号, 3, '0')
        Into v_位置
        From 病人医嘱打印
        Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id = n_医嘱id;
        n_Cnt := To_Number(v_位置);
      Else
        --长嘱单考虑重整及特殊医嘱的情况
        Begin
          Select LPad(页号, 4, '0') || LPad(行号, 3, '0')
          Into v_位置
          From 病人医嘱打印
          Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id = n_医嘱id And
                (打印时间 > d_重整 Or 打印时间 Is Null);
          --该位置的前的特殊医嘱一并删除
          For X In (Select 医嘱id, 位置
                    From (Select 医嘱id, LPad(页号, 4, '0') || LPad(行号, 3, '0') As 位置
                           From 病人医嘱打印
                           Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
                                 LPad(页号, 4, '0') || LPad(行号, 3, '0') < v_位置
                           Order By 页号 Desc, 行号 Desc)) Loop
            If x.医嘱id Is Not Null Then
              Exit;
            Else
              v_位置 := x.位置;
            End If;
          End Loop;
          n_Cnt := To_Number(v_位置);
        Exception
          When Others Then
            --清除最近一次重整后的所有医嘱
            Select To_Number(Nvl(Max(LPad(页号, 4, '0') || LPad(行号, 3, '0')), 0))
            Into n_Cnt
            From 病人医嘱打印
            Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 < d_重整;
            n_Cnt := n_Cnt + 1;
        End;
      End If;
    End If;
  
    If n_Cnt Is Not Null Then
      Delete From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= n_Cnt;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--96536:马政,2016-05-20,卫材调价成本价显示调整
Create Or Replace Procedure Zl_材料收发记录_成本价调价(材料id_In In 药品收发记录.药品id%Type) As
  v_No         药品收发记录.No%Type;
  v_应付id     应付记录.Id%Type; --应付记录的ID 
  v_应付单据号 应付记录.No%Type;
  d_调价时间   Date;
  n_序号       Number(8);
  n_库房id     药品收发记录.库房id%Type;
  n_入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数   药品收发记录.入出系数%Type;
  n_收发id     药品收发记录.Id%Type;
  n_调整额     药品收发记录.零售金额%Type;
  n_原成本价   药品收发记录.成本价%Type;
  n_新成本价   药品收发记录.成本价%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  v_调价id     成本价调价信息.Id%Type;
  v_调价汇总号 成本价调价信息.调价汇总号%Type;
  n_Count      Number(1) := 0;

  Cursor c_Stock Is --当前库存 
    Select 上次供应商id, a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) As 批次, a.上次批号, a.效期, a.上次产地, a.灭菌效期,
           Decode(Sign(Nvl(a.批次, 0)), 1, a.上次采购价, a.平均成本价) As 原成本价
    From 药品库存 A
    Where a.性质 = 1 And Nvl(a.实际数量, 0) <> 0 And a.药品id = 材料id_In
    Order By a.库房id;

  v_Stock c_Stock%RowType;
Begin
  d_调价时间 := Sysdate;
  n_库房id   := 0;

  --判断是否存在无库存调价 
  Begin
    Select ID, 新成本价, 调价汇总号
    Into v_调价id, n_新成本价, v_调价汇总号
    From 成本价调价信息
    Where 执行日期 Is Null And Nvl(库房id, 0) = 0 And 药品id = 材料id_In;
  Exception
    When Others Then
      v_调价id   := 0;
      n_新成本价 := Null;
  End;

  --无库存调价 
  If v_调价id > 0 Then
    --根据当前库存重新产生调价信息 
    For v_Stock In c_Stock Loop
      Zl_材料成本调价_Insert(v_Stock.上次供应商id, v_Stock.库房id, v_Stock.材料id, v_Stock.批次, v_Stock.上次批号, v_Stock.原成本价, n_新成本价,
                       Null, Null, 0, 0, v_调价汇总号);
      n_Count := n_Count + 1;
    End Loop;
  
    If n_Count > 0 Then
      --如果当前有库存记录，则删除无库存调价记录 
      Delete 成本价调价信息 Where ID = v_调价id;
    Else
      Update 成本价调价信息 Set 执行日期 = d_调价时间 Where ID = v_调价id;
    
      Update 材料特性 Set 成本价 = n_新成本价 Where 材料id = 材料id_In And 成本价 <> n_新成本价;
    End If;
  End If;

  --取库存差价调整的入出类别ID 
  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 33 And Rownum < 2;

  For c_成本调整 In (Select a.库房id, a.药品id As 材料id, Nvl(a.批次, 0) 批次, a.上次供应商id, a.实际数量, a.实际金额, a.实际差价, a.上次产地 As 产地,
                        a.上次批号 As 批号, a.灭菌效期, a.效期, a.上次生产日期 As 生产日期, a.批准文号, Nvl(a.平均成本价, 0) As 原成本价, b.新成本价, b.发票号,
                        b.发票日期, b.发票金额, Nvl(a.上次采购价, 0) As 上次采购价, b.Id As 调价id
                 From 药品库存 A, 成本价调价信息 B
                 Where a.药品id = b.药品id And Nvl(a.上次供应商id, 0) = Nvl(b.供药单位id, 0) And a.库房id = b.库房id And
                       Nvl(a.批次, 0) = Nvl(b.批次, 0) And a.性质 = 1 And b.执行日期 Is Null And a.药品id = 材料id_In
                 Order By a.库房id) Loop
    If n_库房id <> c_成本调整.库房id Then
      n_序号   := 1;
      n_库房id := c_成本调整.库房id;
      v_No     := Nextno(71, n_库房id);
    Else
      n_序号 := n_序号 + 1;
    End If;
  
    Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
  
    If Nvl(c_成本调整.实际数量, 0) = 0 And Nvl(c_成本调整.实际金额, 0) = 0 And Nvl(c_成本调整.实际差价, 0) = 0 Then
      --数量,金额、差价都为0，则表示数据是填单下可用数量出库产生的单据，此单据还没有审核，因此只需要更新调价信息，其他不更新
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Elsif Nvl(c_成本调整.实际数量, 0) = 0 And (Nvl(c_成本调整.实际金额, 0) <> 0 Or Nvl(c_成本调整.实际差价, 0) <> 0) Then
      --数量=0 金额或差价<>0时只更新库存表中对应的平均成本价和特性表中成本价，并产生成本价修正数据但是差价差=0，只记录最新成本价
      --产生调价记录，只记录最新成本价
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, 0, c_成本调整.实际金额, c_成本调整.实际差价, 0, '卫生材料成本价调价', Zl_Username, d_调价时间, Zl_Username, d_调价时间,
         c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, c_成本调整.原成本价);
      --更新库存      
      Update 药品库存
      Set 平均成本价 = c_成本调整.新成本价, 上次采购价 = c_成本调整.新成本价
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = c_成本调整.批次 And 性质 = 1;
      Update 材料特性 Set 成本价 = c_成本调整.新成本价 Where 材料id = c_成本调整.材料id;
    
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地, 批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    Else
      --调整相应的库存:原成本金额-实新成本金额 
      n_调整额   := (c_成本调整.实际金额 - c_成本调整.实际差价) - Round(c_成本调整.新成本价 * c_成本调整.实际数量, 2);
      n_原成本价 := c_成本调整.原成本价;
    
      If n_原成本价 <= 0 Then
        n_原成本价 := c_成本调整.上次采购价;
      End If;
    
      --目前：收发记录对应: 
      -- 扣率--> 原成本价 
      -- 单量-->新成本价 
      -- 填写数量-->库存实际数量 
      -- 零售价-->库存实际金额 
      -- 成本价-->库存实际差价 
      -- 差价-->本次调整额 
    
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率)
      Values
        (n_收发id, 1, 18, v_No, n_序号, c_成本调整.库房id, n_入出类别id, c_成本调整.上次供应商id, n_入出系数, c_成本调整.材料id, c_成本调整.批次, c_成本调整.产地,
         c_成本调整.批号, c_成本调整.效期, c_成本调整.实际数量, c_成本调整.实际金额, c_成本调整.实际差价, n_调整额, '卫生材料成本价调价', Zl_Username, d_调价时间,
         Zl_Username, d_调价时间, c_成本调整.生产日期, c_成本调整.批准文号, c_成本调整.新成本价, 1, n_原成本价);
    
      --更新库存 
      Update 药品库存
      Set 实际差价 = Nvl(实际差价, 0) + n_调整额
      Where 库房id = c_成本调整.库房id And 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 灭菌效期)
        Values
          (c_成本调整.库房id, c_成本调整.材料id, c_成本调整.批次, 1, n_调整额, c_成本调整.批号, c_成本调整.效期, c_成本调整.产地, c_成本调整.上次供应商id, c_成本调整.生产日期,
           c_成本调整.批准文号, c_成本调整.灭菌效期);
      End If;
    
      Update 药品库存
      Set 上次采购价 = c_成本调整.新成本价
      Where 药品id = c_成本调整.材料id And 上次采购价 <> c_成本调整.新成本价;
    
      Update 材料特性
      Set 成本价 = c_成本调整.新成本价
      Where 材料id = c_成本调整.材料id And 成本价 <> c_成本调整.新成本价;
    
      --重新计算库存表中的平均成本价 
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 药品id = c_成本调整.材料id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 库房id = c_成本调整.库房id And 性质 = 1 And
            Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_成本调整.材料id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 药品id = c_成本调整.材料id And 库房id = c_成本调整.库房id And Nvl(批次, 0) = Nvl(c_成本调整.批次, 0) And 性质 = 1;
      End If;
    
      --更新成本价调价信息 
      Update 成本价调价信息
      Set 收发id = n_收发id, 执行日期 = d_调价时间, 原成本价 = n_原成本价, 效期 = c_成本调整.效期, 灭菌效期 = c_成本调整.灭菌效期, 产地 = c_成本调整.产地,
          批号 = c_成本调整.批号
      Where ID = c_成本调整.调价id;
    End If;
  End Loop;

  --产生应付记录 
  For c_应付 In (Select Distinct a.供药单位id, a.药品id, a.发票号, a.发票日期, a.发票金额, b.名称, b.计算单位, b.规格
               From 成本价调价信息 A, 收费项目目录 B
               Where a.药品id = b.Id And Nvl(a.应付款变动, 0) = 1 And Nvl(a.供药单位id, 0) <> 0 And a.药品id = 材料id_In
               Order By a.供药单位id) Loop
  
    v_应付单据号 := Nextno(67);
  
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 发票号, 发票日期, 发票金额, 品名, 规格, 填制人, 填制日期, 审核人, 审核日期, 摘要)
    Values
      (v_应付id, 1, 1, c_应付.供药单位id, v_应付单据号, 5, c_应付.发票号, c_应付.发票日期, c_应付.发票金额, c_应付.名称, c_应付.规格, Zl_Username, d_调价时间,
       Zl_Username, d_调价时间, '成本价调价自动产生应付款变动记录');
  
    If Nvl(c_应付.供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(c_应付.发票金额, 0) Where 单位id = c_应付.供药单位id And 性质 = 1;
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (c_应付.供药单位id, 1, Nvl(c_应付.发票金额, 0));
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_成本价调价;
/

--96471:马政,2016-06-03,结存初始化问题调整
Create Or Replace Procedure Zl1_Autocloseaccount Is
  v_Lngid    药品结存记录.Id%Type;
  d_开始日期 药品结存记录.期初日期%Type;
  d_结束日期 药品结存记录.期末日期%Type;
  n_结存时点 Number(2);
  v_Error    Varchar2(255);
  Err_Custom Exception;
  d_计算日期     药品结存记录.期末日期%Type;
  n_结存id       药品结存记录.Id%Type;
  n_未审核结存id 药品结存记录.Id%Type;

  Cursor c_Stock Is
    Select Distinct b.Id
    From 部门性质说明 A, 部门表 B
    Where a.部门id = b.Id And a.工作性质 In ('西药库', '成药库', '中药库', '西药房', '成药房', '中药房', '制剂室') And
          To_Char(b.撤档时间, 'yyyy-MM-dd') = '3000-01-01'
    Order By b.Id;
  r_Stock c_Stock%RowType;
Begin
  --取结存时点，默认每月最后一日结存
  n_结存时点 := Nvl(zl_GetSysParameter(221), 0);

  --只有自动结存才走此过程，手工结存不在走此过程
  If n_结存时点 <> -1 Then
    --计算本次结存的结束日期；因为自动结存是对前一天数据进行结存，所以需要按当前日期提前一天来计算或判断，
    If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(Sysdate - 1)), 'dd')) Then
      --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
      d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
    Else
      d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
    End If;
  
    --检查日期，在结存时点后才能进行自动结存
    If Sysdate - d_结束日期 > 0 Then
      For r_Stock In c_Stock Loop
        --判断期间内是否有结存(不算转结)
        --此处不再通过“期间”字段进行判断，而是通过结存时间点来判断：如2016-05-28 23：59：59，如有则不结存，无则结存
        Select Nvl(Max(ID), 0)
        Into n_结存id
        From 药品结存记录
        Where 库房id = r_Stock.Id And 期末日期 = d_结束日期 And 取消人 Is Null;
      
        If n_结存id > 0 Then
          --如果当前期间已经结存过了，就不再结存，一个期间只结存一次
          Null;
        Else
          --取库房最大的结存ID和本次结存的开始日期
          Select Nvl(Max(ID), 0), Max(期末日期) + 1 / 24 / 60 / 60
          Into n_结存id, d_开始日期
          From 药品结存记录
          Where 库房id = r_Stock.Id And 取消人 Is Null;
        
          --开始时间不能大于结束时间
          If d_开始日期 <= d_结束日期 Then
            If n_结存id > 0 Then
              --检查是否存在未审核的结存，如果存在则自动审核(通常情况都是在期间内手工审核)
              Select Nvl(Max(ID), 0)
              Into n_未审核结存id
              From 药品结存记录
              Where 库房id = r_Stock.Id And 审核日期 Is Null;
            
              If n_未审核结存id > 0 Then
                Zl_药品结存记录_Verify(n_未审核结存id, Zl_Username);
              End If;
            
              --产生新的结存记录
              Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;
            
              Insert Into 药品结存记录
                (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 上次结存id, 期间, 性质)
              Values
                (v_Lngid, r_Stock.Id, d_开始日期, d_结束日期, Nvl(Zl_Username, 'zlhis'), Sysdate, n_结存id,
                 To_Char(Trunc(d_结束日期), 'yyyymm'), 1);
            
              --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
              Insert Into 药品结存明细
                (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
                Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
                From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.期末数量 As 期初数量, a.期末金额 As 期初金额, a.期末差价 As 期初差价, a.期末数量,
                              a.期末金额, a.期末差价
                       From 药品结存明细 A, 药品规格 B
                       Where a.药品id = b.药品id And a.结存id = n_结存id
                       Union All
                       Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                              a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
                       From 药品收发记录 A, 药品规格 B
                       Where a.药品id = b.药品id And a.库房id + 0 = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期)
                Group By 库房id, 药品id, 批次
                Order By 库房id, 药品id, 批次;
            
              --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
              Insert Into 药品结存误差
                (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
                Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
                From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
                       From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                                     Nvl(a.期末差价, 0) As 实际差价
                              From 药品结存明细 A, 药品规格 B
                              Where a.药品id = b.药品id And a.结存id = v_Lngid
                              Union All
                              Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量,
                                     -1 * Nvl(a.实际金额, 0) As 实际金额, -1 * Nvl(实际差价, 0) As 实际差价
                              From 药品库存 A, 药品规格 B
                              Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = r_Stock.Id
                              Union All
                              Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                                     a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                              From 药品收发记录 A, 药品规格 B
                              Where a.药品id = b.药品id And a.库房id = r_Stock.Id And a.审核日期 > d_结束日期) A
                       Group By 库房id, 药品id, 批次) A
                Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
              --自动结存后立马审核结存信息
              Zl_药品结存记录_Verify(v_Lngid, Zl_Username);
            End If;
          End If;
        End If;
        --按库房提交
        Commit;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autocloseaccount;
/

--83671:许华锋,2016-05-13,第三方功能接口配置
CREATE OR REPLACE Procedure ZL_影像插件挂接_Update
(
     ID_In       In 影像插件挂接.ID%Type,
     名称_In     In 影像插件挂接.名称%Type,
     版本_In     In 影像插件挂接.版本%Type,
     路径_In     In 影像插件挂接.路径%Type,
     程序集_In   In 影像插件挂接.程序集%Type,
     执行类型_In In 影像插件挂接.执行类型%Type,
     是否启用_In In 影像插件挂接.是否启用%Type,
     所属模块_In In 影像插件挂接.所属模块%Type
) Is

Begin
  Update 影像插件挂接 Set 名称 = 名称_In, 版本 = 版本_In, 路径 = 路径_In, 执行类型 = 执行类型_In,
  是否启用 = 是否启用_In, 所属模块 = 所属模块_In Where ID = ID_In;

  If Sql%RowCount = 0 Then
    Insert Into 影像插件挂接(ID, 名称, 版本, 路径, 程序集, 执行类型, 是否启用, 所属模块)
    Values(ID_In, 名称_In, 版本_In, 路径_In, 程序集_In, 执行类型_In, 是否启用_In, 所属模块_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_影像插件挂接_Update;
/

--83671:许华锋,2016-05-13,第三方功能接口配置
CREATE OR REPLACE Procedure ZL_影像插件功能_Update
(
     插件ID_In      In 影像插件功能.插件ID%Type,
     名称_In        In 影像插件功能.名称%Type,
     方法_In        In 影像插件功能.方法%Type,
     方法参数_In    In 影像插件功能.方法参数%Type,
     是否启用_In    In 影像插件功能.是否启用%Type,
     VBS脚本_In     In 影像插件功能.VBS脚本%Type
) Is

  n_功能序号 影像插件功能.功能序号%Type;
  n_ID Number;

Begin

  Select Nvl(Max(功能序号), 0) + 1 Into n_功能序号 From 影像插件功能 Where 插件ID = 插件ID_In;
  Select Nvl(Max(ID),0) + 1 Into n_ID from 影像插件功能;

  Insert Into 影像插件功能(ID, 插件ID, 功能序号, 名称, 方法, 方法参数, 是否启用, VBS脚本)
  Values(n_ID, 插件ID_In,n_功能序号, 名称_In, 方法_In, 方法参数_In, 是否启用_In, VBS脚本_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_影像插件功能_Update;

/


--83671:许华锋,2016-05-13,第三方功能接口配置
CREATE OR REPLACE Procedure ZL_影像插件挂接_Delete
(
     ID_In In 影像插件挂接.ID%Type
) Is

Begin

  Delete From 影像插件挂接 Where ID = ID_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_影像插件挂接_Delete;
/

--83671:许华锋,2016-05-13,第三方功能接口配置
CREATE OR REPLACE Procedure ZL_影像插件功能_Delete
(
     插件ID_In      In 影像插件功能.插件ID%Type
) Is

Begin

  Delete From 影像插件功能 Where 插件ID = 插件ID_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_影像插件功能_Delete;
/

--95564:胡俊勇,2016-05-12,医嘱回退
Create Or Replace Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                --还原医嘱执行时间
                Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                Into v_Time
                From Dual;
                Insert Into 医嘱执行时间
                  (要求时间, 医嘱id, 发送号)
                  Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                  From Table(f_Str2list(v_Time));
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
          
          If r_Rolladvice.类别 = 'Z' And  Instr(',9,10,', ','||r_Rolladvice.类型||',') > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then 
            --回退病况医嘱时，调用变动记录回退
            Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '病况变动'); 
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(max(是否锁定), 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', ','||r_Rolladvice.类型||',') > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr(',7,8,11,', ','||r_Rolladvice.类型||',') > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--93789:冉俊明,2016-06-14,医保单据部分退费重结时医保项目信息更新。
Create Or Replace Procedure Zl_门诊收费记录_Update
(
  Id_In         In 门诊费用记录.Id%Type,
  保险大类id_In In 门诊费用记录.保险大类id%Type,
  保险项目否_In In 门诊费用记录.保险项目否%Type,
  保险编码_In   In 门诊费用记录.保险编码%Type,
  费用类型_In   In 门诊费用记录.费用类型%Type,
  统筹金额_In   In 门诊费用记录.统筹金额%Type,
  摘要_In       In 门诊费用记录.摘要%Type
) Is
  --功能：医保病人退费时，更新重收费用记录的保险信息 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  Update 门诊费用记录
  Set 保险大类id = Decode(保险大类id_In, 0, Null, 保险大类id_In), 保险项目否 = 保险项目否_In, 保险编码 = 保险编码_In, 费用类型 = 费用类型_In, 统筹金额 = 统筹金额_In,
      摘要 = 摘要_In
  Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '未发现当前医保病人的剩余费用重收记录，保险信息更新失败！';
    Raise Err_Item;
  End If;

  --更新原收费记录无保险信息的记录
  If 费用类型_In Is Not Null Then
    Update 门诊费用记录
    Set 保险大类id = Decode(保险大类id_In, 0, Null, 保险大类id_In), 保险项目否 = 保险项目否_In, 保险编码 = 保险编码_In, 费用类型 = 费用类型_In, 统筹金额 = 统筹金额_In,
        摘要 = 摘要_In
    Where Mod(记录性质, 10) = 1 And 费用类型 Is Null And
          (NO, 序号) = (Select NO, 序号 From 门诊费用记录 Where ID = Id_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Update;
/

--95875:张德婷,2016-05-11,输液配置中心当天的输液单到备用批次
CREATE OR REPLACE Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  v_药品类型       varchar2(20);
  n_打包药品批次   number(1);
  n_特殊药品批次   number(1);
  n_优先级         number:=999;
  n_自动排批       number:=0;
  n_科室id       number:=0;
  n_row            number(2);
  n_备用批次       number:=0;
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And  c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In And b.病人id = n_病人id
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No,F.抗生素,F.是否肿瘤药
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E,药品特性 F,药品规格 G
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id=G.药品ID and G.药名ID=F.药名ID And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;

  Function Zl_Getpivaworkbatch(执行时间_In In Date,药品类型_In In varchar2:=null) Return Number As
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包,药品类型 From 配药工作批次 Where 启用 = 1 and 配置中心id=部门id_In Order By 批次;

    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');

    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 and 配置中心id=部门id_In;

    For v_配药批次 In c_配药批次 Loop
      v_Batch     := 0;

      if 药品类型_In is null then
        --当天发送的医嘱发送到备用批次
        if Trunc(执行时间_In) > v_Currdate or n_备用批次=0 then
          if v_配药批次.批次<>'0'and v_配药批次.药品类型 is null then
            v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
            v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');

            If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
              v_Batch := v_配药批次.批次;
              n_打包  := v_配药批次.打包;
              Exit When v_Batch > 0;
            End If;
          end if;
        end if;
      else
        if 药品类型_In=v_配药批次.药品类型 then
          v_Batch := v_配药批次.批次;
          n_打包  := v_配药批次.打包;
          Exit When v_Batch > 0;
        end if;
      end if;
    End Loop;

    If (v_Batch = 0 and n_打包药品批次<>1) or n_备用批次=1 Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;

  Function Zl_GetFirst(配药id_In In number,科室id_In In number) Return Number As
    n_First     Number;
    n_科室id    number;
    Cursor c_优先级 Is
      select 科室id,配药类型,优先级,频次 from 输液药品优先级 where (科室id=科室id_In or 科室id=0) order by 科室id,优先级 desc;

    r_优先级 c_优先级%RowType;
  Begin
   n_First:=0;
   for r_优先级 in c_优先级 loop
     if n_科室id<>0 and r_优先级.科室id=0 then
       exit;
     end if;
     n_科室id:=r_优先级.科室id;

     for r_配药记录 in(select distinct D.配药类型,E.执行频次 from 输液配药记录 A,输液配药内容 B,药品收发记录 C,输液药品属性 D,病人医嘱记录 E  where A.医嘱id=E.Id and A.id=B.记录ID and B.收发ID=C.id and C.药品ID=D.药品ID and a.id=配药id_In) loop
       if instr(r_配药记录.配药类型,r_优先级.配药类型,1)>0 and instr(r_优先级.频次,r_配药记录.执行频次,1)>0 then
         n_First:= r_优先级.优先级;
         exit;
       end if;
     end loop;
   end loop;

   if n_First=0 then
     n_First:=999;
   end if;
   Return(n_First);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源科室', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  n_Tpn处置方式    := Zl_To_Number(Nvl(zl_GetSysParameter('静脉营养药物处置方式', 1345), 0));
  n_打包药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('单个药品，不予配置药品及根据给药时间没有配药批次的输液单默认为0批次并打包', 1345), 0));
  n_特殊药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('特殊药品按药品类型指定批次', 1345), 0));
  n_自动排批:= Zl_To_Number(Nvl(zl_GetSysParameter('启动自动排批', 1345), 0));
  n_备用批次:=Zl_To_Number(Nvl(zl_GetSysParameter('当天发送的医嘱产生的输液单全部到备用批次', 1345), 0));
  v_医嘱ids  := 医嘱id_In;
  v_当前病人 := '';
  n_发送次数:=0;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  --先将原收发记录的序号增大，新的收发记录产生后再删除
  --Update 药品收发记录
  --Set 序号 = 序号 + 10000
  --Where ID In (Select \*+rule *\
  --             Distinct c.Id
  --             From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, Table(f_Num2list(医嘱id_In)) F
  --             Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
  --                   c.单据 = 9 And c.审核日期 Is Null And a.相关id = f.Column_Value And b.发送号 = 发送号_In And c.序号 < 10000);

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
    n_病人id := v_医嘱记录.病人id;
    n_科室id:= v_医嘱记录.病人科室id;

    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B,住院费用记录 C
    Where c.收费细目id = b.药品id And c.医嘱序号 =A.id and A.相关id= v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;

    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;

    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;

    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人科室id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;

    v_药品类型:=null;
    for r_药品类型 in (Select decode(nvl(D.是否肿瘤药,0),0,'','肿瘤药') 药品类型
    From 病人医嘱记录 A, 药品规格 B,住院费用记录 C,药品特性 D
    Where c.收费细目id = b.药品id And B.药名ID=D.药名ID And c.医嘱序号 =A.id and A.相关id= v_医嘱记录.相关id) loop
      if r_药品类型.药品类型 is not null then
        v_药品类型:=r_药品类型.药品类型;
      end if;
    end loop;

    if v_药品类型 is null then
       If v_医嘱记录.是否tpn = 2 Then
        v_药品类型:='营养药';
        v_Continue := 1;
      end if;
    end if;

    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;


      If v_Continue = 1 Then
        --v_Count := Zl_Gettransexenumber(v_医嘱记录.开始执行时间, v_医嘱记录.首次时间, v_医嘱记录.末次时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;

        v_Nodosage := 0;

        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;

          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            --v_执行时间 := Zl_Gettransexetime(v_医嘱记录.开始执行时间, v_执行时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;

          v_批次 := 0;
          --药品类型不为空，则根据药品类型匹配批次

          if (v_药品类型 is null or n_特殊药品批次=0) and n_自动排批=0 then
            If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
              b_Change      := True;
              d_Old执行时间 := v_执行时间;

              Select /*+ rule*/
               Count(a.要求时间)
              Into n_Cur
              From 医嘱执行时间 A
              Where a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60;

              Select Count(a.要求时间)
              Into n_Sum
              From 医嘱执行时间 A
              Where a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;

              Select Count(Distinct a.摆药单号)
              Into n_摆药单
              From 输液配药记录 A
              Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;

              If n_Cur <> n_Sum Or  n_摆药单 > 1 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            End If;

            If b_Change = True Then
              b_Change := True;
              n_病人id := v_医嘱记录.病人id;
              Select Count(ID)
              Into n_Sum
              From 输液配药记录
              Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
              If n_Sum = 0 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;

              If b_Change = True Then
                For v_单个医嘱记录 In c_单个医嘱记录 Loop
                  --检查输液单是否调整到打包状态
                  Select Count(ID)
                  Into n_Sum
                  From 输液配药记录
                  Where 医嘱id = v_单个医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And
                        打包时间 Is Not Null;
                  If n_Sum <> 0 Then
                    Update 输液配药记录
                    Set 是否调整批次 = 1
                    Where 医嘱id In
                          (Select ID
                           From 病人医嘱记录
                           Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                          执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                    b_Change := False;
                    Exit;
                  End If;

                  Select Count(医嘱id)
                  Into n_Cur
                  From 医嘱执行时间
                  Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
                  Select Count(医嘱id)
                  Into n_Sum
                  From 医嘱执行时间
                  Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
                  If n_Sum <> n_Cur Then
                    Update 输液配药记录
                    Set 是否调整批次 = 1
                    Where 医嘱id In
                          (Select ID
                           From 病人医嘱记录
                           Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                          执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                    b_Change := False;
                    Exit;
                  End If;
                End Loop;
              End If;
            End If;

            If (v_保持上次批次 = 1 Or b_Change = True) and n_自动排批=0 Then
              --取上次的批次
              Begin
                Select Distinct 配药批次
                Into v_批次
                From 输液配药记录 A
                Where 医嘱id = v_医嘱记录.相关id And
                      发送号 = (Select Distinct Max(发送号)
                             From 输液配药记录
                             Where 医嘱id = v_医嘱记录.相关id And 发送号 <> v_医嘱记录.发送号) And
                      To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_执行时间, 'hh24:mi:ss');
              Exception
                When Others Then
                  v_批次 := 0;
              End;
            End If;

            If v_批次 = 0 Then
              v_批次 := Zl_Getpivaworkbatch(v_执行时间);

              --同病人同批次总输液量控制，超过则分配到下个批次
              If v_输液总量 > 0 And Not v_大输液剂型 Is Null And v_批次 < v_Maxbatch Then
                Begin
                  Select /*+rule */
                   Sum(单量) As 单量
                  Into v_Curdose
                  From (Select Distinct c.Id, c.单量
                         From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                         Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id And
                               e.药名id = f.药名id And b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And
                               f.药品剂型 = g.Column_Value And a.相关id = v_相关id And b.发送号 = v_发送号);
                Exception
                  When Others Then
                    v_Curdose := 0;
                End;

                Begin
                  Select /*+rule */
                   Sum(单量) As 单量
                  Into v_Sumdose
                  From (Select Distinct a.Id, a.单量
                         From 药品收发记录 A, 病人医嘱记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                         Where c.Id = d.记录id And a.Id = d.收发id And c.医嘱id = b.Id And a.药品id + 0 = e.药品id And
                               e.药名id = f.药名id And b.病人id + 0 = v_医嘱记录.病人id And f.药品剂型 = g.Column_Value And
                               c.执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And c.配药批次 = v_批次);
                Exception
                  When Others Then
                    v_Sumdose := 0;
                End;

                If v_Sumdose > 0 And v_Sumdose + v_Curdose > v_输液总量 Then
                  v_批次 := v_批次 + 1;
                End If;
              End If;
            End If;

          elsif v_药品类型 is not null and n_特殊药品批次=1 then
            --药品类型不为空，直接根据药品类型匹配批次
            v_批次 := Zl_Getpivaworkbatch(sysdate,v_药品类型);
          else
            v_批次 := Zl_Getpivaworkbatch(v_执行时间);
          end if;  

          Select Count(医嘱id)
          Into n_发送次数
          From 医嘱执行时间
          Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
          Order By 要求时间;

          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;

          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;

          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_批次;
          End If;

          If (Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0) and (v_药品类型 is null or n_特殊药品批次=0) Then
            n_是否打包     := 1;
            d_手工打包时间 := Sysdate;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;

          --如果是TPN不管其他条件如何都设置为配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;

          if v_批次=0 then
             n_是否打包:=1;
          end if;
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, v_批次, v_Maxno, n_调整批次, n_是否打包,
             d_手工打包时间, 1, 核查人_In, 核查时间_In);

          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);

          --产生配药记录对应的药品记录
          For v_收发记录 In c_收发记录 Loop
            If v_收发记录.是否不予配置 = 1 Then
              v_Nodosage := 1;
            End If;

            n_Count := n_Count + 1;

            Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;

            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
               成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
               产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
              Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                     效期, 付数, 填写数量 / v_Count, 实际数量 / v_Count, 成本价, 成本金额 / v_Count, 扣率, 零售价, 零售金额 / v_Count, 差价 / v_Count,
                     '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                     领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间





              From 药品收发记录
              Where ID = v_收发记录.收发id;

            Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, v_收发记录.数量 / v_Count);

            n_优先级:=Zl_GetFirst(v_配药id,v_医嘱记录.病人科室id);
            update 输液配药记录 set 优先级=n_优先级 where id=v_配药id;
          End Loop;

        End Loop;

        For v_收发记录 In c_收发记录 Loop
          n_单据 := v_收发记录.单据;

          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;

        --单个药品或者不予配置的药品默认为0批次
        select count(收发id) into n_Row from 输液配药内容 where 记录id=v_配药id;
        if (v_Nodosage = 1 or n_row=1) and n_打包药品批次=1 then
          Update 输液配药记录 Set 配药批次 = 0,是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 and 操作状态<2;
        end if;
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录 Set 是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 and 操作状态<2;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

  if n_自动排批=1 then
    Zl_输液配药记录_自动排批(n_病人id,n_科室id,部门id_In,v_执行时间);
  end if;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--92837:马政,2016-05-10,出库单据库房信息中入库时间处理
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  Delete_In   In Number := 0,
  冲销方式_In In Number := 0,
  发药标志_In In Number := 0,
  财务审核_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:根据明细数据更新库存
  --关键：根据下可用库存参数决定是否处理可用数量
  --业务规则：按照模块分开处理数据，便于后期维护
  --过程适用范围：药品流通业务，涉及到产生药品收发记录明细后再更新库存表并重算库存表平均成本价的业务，该过程
  --只能由其他过程内部调用，不能作为单独过程直接执行
  --参数:
  --     Id_In:药品业务新增、删除、审核、冲销时产生收发记录明细的id
  --     Delete_in: 0--非删除操作业务（新增、审核、冲销） 1--删除操作业务
  --     冲销方式_In: 0--正常冲销方式 1-产生冲销申请单据 2-发送 3-回退 目前只有移库模块有效
  --     发药标志_in: 0--不标记  1--标记  此参数只有药品处方、部门发药模块有效
  --     财务审核_in:0,财务审核单据,1-其他业务
  ----------------------------------------------------------------------------------------
  v_下可用数量 Zlparameters.参数值%Type;
  n_可用数量   药品库存.实际数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_差价       药品库存.实际差价%Type;
  n_时价分批   Number(1);
  n_成本价     药品收发记录.成本价%Type;
  n_零售价     药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;

  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  v_Detail c_Detail%RowType;
Begin
  --取下可用库存参数
  Select zl_GetSysParameter(96) Into v_下可用数量 From Dual;

  For v_Detail In c_Detail Loop
    n_实际数量 := v_Detail.入出系数 * v_Detail.实际数量 * Nvl(v_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_零售金额 := v_Detail.入出系数 * v_Detail.零售金额;
    n_差价     := v_Detail.入出系数 * v_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), Nvl(平均成本价, 0)
      Into n_库存数量, n_库存平均价
      From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
    Exception
      When Others Then
        n_库存数量   := 0;
        n_库存平均价 := 0;
    End;
  
    --外购入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，退库模式时在填单时要根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --冲销时直接按数量加减库存可用数量
    --用数量判断是入库还是退库
    If v_Detail.单据 = 1 Then
      If v_Detail.审核日期 Is Null Then
        --未审核单据，填单或删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --已审核或已冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            --退库要考虑填单时已经处理了可用数量
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --自制入库：对于自制药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于原料药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 2 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --协定入库：对于协定药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于组成药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 3 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --其他入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，负数入库模式时要根据参数处理可用数量，在审核时则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --用数量判断是入库还是退库
    If v_Detail.单据 = 4 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --差价调整，成本价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 5 Then
      n_可用数量 := 0;
    End If;
  
    --移库：移库有两条单据，一条出库单据，一条入库单据；出库单据需要根据下可用库存参数决定是否下可用库存，如果是冲销则可用库存则相反处理
    --在填单不减可用数量时，在发送时预减可用数量，审核时不处理可用数量
    --申请冲销模式时也要根据参数来处理可用数量
    --填单时出库业务根据参数决定是否下库存，入库业务不下库存；删除时出库业务更加参数要把库存还回去，入库业务不还库存
    If v_Detail.单据 = 6 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          --新增、修改、发送、回退、冲销申请
          If v_Detail.记录状态 = 1 Then
            If 冲销方式_In = 2 Then
              --发送
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Elsif 冲销方式_In = 3 Then
              --回退
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := -1 * n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Else
              --新增
              If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            End If;
          Else
            --申请冲销
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        Else
          --删除
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Elsif v_Detail.配药日期 Is Not Null And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = -1 Then
            --出的那笔
            n_可用数量 := 0;
          Else
            --入的那笔
            n_可用数量 := n_实际数量;
          End If;
        Else
          If 冲销方式_In = 0 Then
            --正常冲销审核
            n_可用数量 := n_实际数量;
          Else
            --申请冲销审核
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --领用：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 7 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --发药业务：在填单时固定处理可用数量，在审核时不处理
    --删除单据时要把填单时预减的加回去
    --不再发药标记的可用数量处理等同于删除，填单操作
    If v_Detail.单据 = 8 Or v_Detail.单据 = 9 Or v_Detail.单据 = 10 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          If 发药标志_In = 0 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := -1 * n_实际数量;
          End If;
        Else
          n_可用数量 := -1 * n_实际数量;
        End If;
      Else
        n_可用数量 := 0;
      End If;
    End If;
  
    --其他出库：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 11 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --冲销和审核
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --盘点：填单时盘盈业务不处理可用数量，盘亏业务固定处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    --用入出系数区分盘盈盘亏业务
    If v_Detail.单据 = 12 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --售价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 13 Then
      n_可用数量 := 0;
    End If;
  
    --药品留存：产生发药单据时，已经下了库存，部门发药时，需要将库存加回去
    If v_Detail.单据 = 27 Then
      n_可用数量 := n_实际数量;
    End If;
  
    If v_Detail.批次 > 0 And v_Detail.是否变价 = 1 Then
      n_时价分批 := 1;
    Else
      n_时价分批 := 0;
    End If;
  
    n_零售价 := v_Detail.零售价;
    --特殊单据需要处理成本价 特殊单据有单据=5 单据=12
    If v_Detail.单据 = 5 Or v_Detail.单据 = 12 Then
      If v_Detail.单据 = 5 Then
        If v_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(v_Detail.零售价, 0) / v_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If v_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := v_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(v_Detail.零售价, 0) - Nvl(v_Detail.成本价, 0)) / v_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = v_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := v_Detail.单量;
      End If;
    Else
      If v_Detail.单据 = 13 Then
        n_成本价 := Nvl(v_Detail.单量, 0) - Nvl(v_Detail.频次, 0);
      Else
        n_成本价 := v_Detail.成本价;
      End If;
    End If;
  
    --根据业务数据更新库存记录
    If v_Detail.审核日期 Is Null Then
      If n_可用数量 <> 0 Then
        --填单，删除时只更新可用数量
        Update 药品库存
        Set 可用数量 = 可用数量 + n_可用数量
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, 0, 0, 0, v_Detail.供药单位id, n_成本价,
             v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号, Decode(n_时价分批, 1, n_零售价, Null),
             v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    Else
      --审核时更新库存可用数量，实际数量，库存金额，库存差价等数据
      If v_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If v_Detail.摘要 = '外购退库差价误差自动修正' Or v_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, n_差价, v_Detail.批号, v_Detail.效期, v_Detail.产地,
               v_Detail.供药单位id, v_Detail.生产日期, v_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          
            Insert Into 药品入库信息
              (药品id, 库房id, 批次, 入库日期)
              Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
              From Dual
              Where Not Exists (Select 1
                     From 药品入库信息
                     Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
          End If;
        End If;
      Elsif v_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        Update 药品库存
        Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价分批, 1, n_零售价, Null));
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        Else
          If n_时价分批 = 1 Then
            Update 药品库存
            Set 零售价 = 实际金额 / 实际数量
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
          End If;
        End If;
      Else
        --按入库和出库 状态分解
        --入库业务,出库冲销，不分批多种价格入库冲销需要更新库存表所有信息
        If (v_Detail.入出系数 = 1 And v_Detail.记录状态 = 1) Or (v_Detail.入出系数 = -1 And Mod(v_Detail.记录状态, 3) = 2) Or
           (v_Detail.入出系数 = 1 And Mod(v_Detail.记录状态, 3) = 2) Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = v_Detail.供药单位id,
              上次采购价 = Decode(v_Detail.单据, 1, Decode(v_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(v_Detail.批号, 上次批号), 上次生产日期 = Nvl(v_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(v_Detail.产地, 上次产地),
              灭菌效期 = Nvl(v_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(v_Detail.效期, 效期), 批准文号 = Nvl(v_Detail.批准文号, 批准文号),
              上次扣率 = Decode(v_Detail.单据, 1, v_Detail.扣率, 上次扣率), 商品条码 = Nvl(v_Detail.商品条码, 商品条码),
              内部条码 = Nvl(v_Detail.内部条码, 内部条码)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          --外购入库和其他入库审核时
          If (v_Detail.单据 = 1 And v_Detail.记录状态 = 1 And 财务审核_In = 0) Or (v_Detail.单据 = 4 And v_Detail.记录状态 = 1) Then
            Update 药品库存
            Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null)
            Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          End If;
          --不分批入库需要重算成本价
          --外购退货、财务审核和所有冲销业务不更新平均成本价，保持当前价格
          If (v_Detail.单据 = 1 And v_Detail.发药方式 = 1) Or Mod(v_Detail.记录状态, 3) = 2 Or (v_Detail.单据 = 1 And 财务审核_In = 1) Then
            Null;
          Else
            --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
            n_总数量 := (n_库存数量 + n_实际数量);
            If n_总数量 <> 0 Then
              n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
              Update 药品库存
              Set 平均成本价 = n_总成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          --出库业务只需要更新数量、金额、差价
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        End If;
        --库存表未找到数据则需要产生库存表所有信息
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, v_Detail.供药单位id,
             n_成本价, v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号,
             Decode(n_时价分批, 1, n_零售价, Null), v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    End If;
  
    --删除多余的库存数据
    If 财务审核_In = 0 Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  结帐id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  退支票额_In     病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成结算_In     Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null,
  更新交款余额_In Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.." 
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_退支票   病人预交记录.结算方式%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
  Exception
    When Others Then
      v_误差费 := '误差费';
  End;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;

  --1.增加结算方式为空的结算数据
  n_结算金额 := 0;
  n_Count    := 0;
  Open c_Feedata;
  Begin
    Fetch c_Feedata
      Into r_Feedata;
    --修正或新增结算方式为null的记录
    Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    If Nvl(n_Havenull, 0) = 0 Or Round(Nvl(r_Feedata.结算金额, 0), 6) <> Round(Nvl(n_结算金额, 0), 6) Then
      --先删除存在的结算方式为null的记录
      Delete From 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      Select Nvl(Sum(冲预交), 0) Into n_结算金额 From 病人预交记录 Where 结帐id = 结帐id_In;
    
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0) - n_结算金额, 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3, n_会话号);
    End If;
  Exception
    When Others Then
      n_Count := 1;
  End;
  Close c_Feedata;
  If n_Count = 1 Then
    v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
    Raise Err_Item;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                         Union All
                         Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                               预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3, 会话号 = n_会话号
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3, n_会话号
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
      n_返回值 := -1 * 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;
  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3,
             n_会话号);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  If Nvl(更新交款余额_In, 0) = 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4, 结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。 
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。 
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生 
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额) 
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式) 
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录 
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
  n_会话号       病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了 
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3, n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中 
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用 
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称 
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行) 
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能) 
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录 
          n_费用状态 := 0;
          --该笔项目第几次退费 
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9 
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数) 
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9 
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --------------------------------------------------------------------------------- 
  --处理病人预交记录 

  --原单据的结帐ID 
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完 
    --冲预交部分记录 
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额 
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理) 
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对. 
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上 
      --需要处理误差金额
    Else
      --a.原样退回 
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    ------------------------------------------------- 
    --部分退费直接退为指定结算方式 
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * (n_总金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志, 1, 2, 0), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交 
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --检查是否已经处理完 
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If Nvl(校对标志_In, 0) = 0 Then
        --更新病人预交余额 
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
          n_返回值 := n_总金额 + Nvl(误差_In, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3, n_会话号
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3,
                   n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  --------------------------------------------------------------------------------- 
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款) 
  --如果是需要校对的,暂不处理人员缴款余额 
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_门诊收费结算_完成退费
(
  病人id_In       门诊费用记录.病人id%Type,
  退费结算序号_In 病人预交记录.结算序号%Type,
  冲销ids_In      Varchar2,
  操作员姓名_In   病人预交记录.操作员姓名%Type := Null,
  操作标志_In     Integer := 0
) As
  --功能:完成退费处理
  --NOs_In:可以为多张;No1,No2...Non
  --操作标志_IN:0-更新缴款余额;1-不更新缴款余额(异常单据作废)
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_Count      Number;
  n_返回值     病人预交记录.冲预交%Type;
  v_Msg        Varchar2(500);
Begin
  v_操作员姓名 := 操作员姓名_In;

  If 冲销ids_In Is Null Then
    Select Count(*)
    Into n_Count
    From 病人预交记录 A
    Where 结算序号 = 退费结算序号_In And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
      Raise Err_Item;
    End If;
    For v_结帐 In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 退费结算序号_In) Loop
      If 操作标志_In = 1 Then
      
        Update 病人预交记录 A
        Set 校对标志 = 2
        Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
              (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
               (Select 1 From 结算方式 B Where a.结算方式 = b.名称 And b.性质 In (3, 4))));
        Return;
      End If;
    
      Update 病人预交记录
      Set 校对标志 = 0, 会话号 = Null
      Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
    
      For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数
                   From 门诊费用记录 A, 门诊费用记录 B
                   Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                         b.结帐id = v_结帐.结帐id
                   Group By a.No, Nvl(a.价格父号, a.序号)) Loop
        Update 门诊费用记录 A
        Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 0
        Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
      End Loop;
    
      --处理预交记录
    
      If Nvl(操作标志_In, 0) = 0 Then
      
        --处理病人预交余额
        For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 预交类别
                     Having Sum(Nvl(冲预交, 0)) <> 0) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
          Returning 预交余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
            n_返回值 := Nvl(v_预交.预交金额, 0);
          End If;
          If n_返回值 = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      
        --更新人员缴款余额
        For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                     From 病人预交记录 A
                     Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 结算方式) Loop
        
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
          Returning Nvl(余额, 0) Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
            n_返回值 := Nvl(v_缴款.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete 人员缴款余额
            Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End Loop;
      End If;
    
    End Loop;
    Return;
  End If;

  --按单据号更新
  Select /*+ rule */
   Count(a.Id)
  Into n_Count
  From 病人预交记录 A, Table(f_Num2list(冲销ids_In)) J
  Where a.结帐id = j.Column_Value And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
  If n_Count <> 0 Then
    v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
    Raise Err_Item;
  End If;

  --更新执行状态:在未完成时,都是9
  For v_结帐 In (Select /*+ rule */
                j.Column_Value As 结帐id
               From Table(f_Num2list(冲销ids_In)) J) Loop
  
    If Nvl(操作标志_In, 0) = 1 Then
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
            (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
             (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4))));
    
    End If;
  
    Update 病人预交记录
    Set 校对标志 = 0, 会话号 = Null
    Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
  
    For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数


                 
                 From 门诊费用记录 A, 门诊费用记录 B
                 Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                       b.结帐id = v_结帐.结帐id
                 Group By a.No, Nvl(a.价格父号, a.序号)) Loop
      Update 门诊费用记录 A
      Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 0
      Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
    End Loop;
  
    --处理预交记录
  
    If Nvl(操作标志_In, 0) = 0 Then
    
      --处理病人预交余额
      For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := Nvl(v_预交.预交金额, 0);
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    
      --更新人员缴款余额
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning Nvl(余额, 0) Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 人员缴款余额
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  End Loop;
  --消息推送
  Select 病人id_In || ',' || 冲销ids_In || ',' || 操作标志_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_完成退费;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_费用补充记录_补结算
(
  No_In          In 费用补充记录.No%Type,
  实际票号_In    In 费用补充记录.实际票号%Type,
  结算id_In      In 费用补充记录.结算id%Type,
  结算序号_In    In 病人预交记录.结算序号%Type,
  收费结帐ids_In Varchar2,
  医保结算_In    Varchar2,
  操作员编号_In  In 费用补充记录.操作员编号%Type,
  操作员姓名_In  In 费用补充记录.操作员姓名%Type,
  登记时间_In    In 费用补充记录.登记时间%Type := Null,
  备注_In        In 费用补充记录.备注%Type := Null,
  附加标志_In    In 费用补充记录.备注%Type := Null,
  费用状态_In    In 费用补充记录.费用状态%Type := 0
) Is
  -- 医保结算_IN:允许传入多个,格式为:结算方式,结算金额|..
  Err_Item Exception;

  v_Err_Msg Varchar2(255);
  n_Date    Date;
  n_病人id  门诊费用记录.病人id%Type;
  n_组id    财务缴款分组.Id%Type;
  n_冲预交  病人预交记录.冲预交%Type;
  n_会话号  病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    n_Date := Sysdate;
  End If;
  Begin
    Select 病人id
    Into n_病人id
    From 门诊费用记录
    Where 结帐id In (Select Column_Value From Table(f_Num2list(收费结帐ids_In))) And Rownum < 2;
  Exception
    When Others Then
      n_病人id := Null;
  End;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '费用记录中存在未建档病人的费用,不允许继续操作！';
    Raise Err_Item;
  End If;

  If 医保结算_In Is Not Null Then
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 6, No_In, 1, n_病人id, Null, Null, 结算方式, n_Date, 操作员编号_In, 操作员姓名_In, 结算金额, 结算id_In, n_组id,
             结算序号_In, 2, Null, Null, Null, Null, Null, Null, 6, n_会话号
      From (Select C1 As 结算方式, To_Number(C2) As 结算金额 From Table(f_Str2list2(医保结算_In, '|', ',')));
  
    Select Sum(To_Number(C2)) Into n_冲预交 From Table(f_Str2list2(医保结算_In, '|', ','));
  End If;
  --增加结算方式为NULL
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
  Values
    (病人预交记录_Id.Nextval, 6, No_In, 1, n_病人id, Null, '', Null, n_Date, 操作员编号_In, 操作员姓名_In, -1 * n_冲预交, 结算id_In, n_组id,
     结算序号_In, 1, Null, Null, Null, Null, Null, Null, 6, n_会话号);

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 备注, 附加标志)
    Select 1, No_In, 1, 实际票号_In, 结算id_In, 结帐id, 费用状态_In, 操作员编号_In, 操作员姓名_In, n_Date, n_组id, n_病人id, 结算序号_In, 备注_In,
           附加标志_In
    From (Select Column_Value As 结帐id From Table(f_Num2list(收费结帐ids_In)));
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_补结算;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_费用补充结算_Modify
(
  操作类型_In   Number,
  结算id_In     In 费用补充记录.结算id%Type,
  结算方式_In   Varchar2,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null,
  完成结算_In   Number := 0
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:保险补充结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通结算方式:
  --     结算方式_IN:允许传入多个,格式为:结算方式|结算金额|结算号码|结算摘要||.. ;也允许传入空.
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成补充结算;0-未完成补充结算;2-完成了异常作废
  ------------------------------------------------------------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  v_误差费   结算方式.名称%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  l_预交id   t_Numlist := t_Numlist();
  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(4000);
  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号


    
    From 费用补充记录 A
    Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  r_Balance c_Balance%RowType;

  n_Count  Number(18);
  n_会话号 病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#
Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6, n_会话号);
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - 误差金额_In Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --0.普通结算方式
  If Nvl(操作类型_In, 0) = 0 Then
    --各个收费结算 :格式为:结算方式|结算金额|结算号码|结算摘要||..
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
           r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
           卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --1.三方卡结算
  If Nvl(操作类型_In, 0) = 1 Then
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, n_结算金额, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
         卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 6, n_会话号);
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_结算金额 Where 结帐id = 结算id_In And 结算方式 Is Null;
    End If;
  End If;

  --2.医保结算
  If Nvl(操作类型_In, 0) = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结算id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
  
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    --先删除结算方式为空的记录
    Delete 病人预交记录 Where 结帐id = 结算id_In And 结算方式 Is Null;
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
    n_冲预交 := 0;
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '保险结算', v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, Nvl(n_结算金额, 0), r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null,
         Null, Null, Null, Null, Null, 6, n_会话号);
      n_冲预交 := n_冲预交 + Nvl(n_结算金额, 0);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
    --处理结算方式为NULL
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, '', Null, r_Balance.登记时间,
       r_Balance.操作员编号, r_Balance.操作员姓名, -1 * n_冲预交, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 1, Null, Null,
       Null, Null, Null, Null, 6, n_会话号);
    --医保相关表的处理
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结算id_In;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  If Nvl(完成结算_In, 0) = 2 Then
    --1.更新校对标志
    Update 病人预交记录 Set 校对标志 = 0 Where NO = r_Balance.No;
    Update 费用补充记录 Set 费用状态 = 2 Where NO = r_Balance.No;
    If Sql%NotFound Then
      v_Err_Msg := '未找到医保补结算数据，可能被他人进行了作废操作!';
      Raise Err_Item;
    End If;
    Return;
  End If;

  Select Sum(冲预交) Into n_冲预交 From 病人预交记录 Where 结帐id = 结算id_In;
  If Nvl(n_冲预交, 0) <> 0 Then
    v_Err_Msg := '医保结算数据与退未结算数据不匹配!';
    Raise Err_Item;
  End If;

  Delete 病人预交记录 Where 结帐id = 结算id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结算id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --1.更新异常状态
  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能被他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志,会话号
  Update 病人预交记录 Set 校对标志 = 0, 会话号 = Null Where 结帐id = 结算id_In;
  --3.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_Modify;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_费用补充记录_Delete
(
  No_In           In 费用补充记录.No%Type,
  冲销id_In       In 费用补充记录.结算id%Type,
  重结id_In       In 费用补充记录.结算id%Type,
  结算序号_In     In 费用补充记录.结算序号%Type,
  退费结帐ids_In  In Varchar2,
  操作员编号_In   In 费用补充记录.操作员编号%Type,
  操作员姓名_In   In 费用补充记录.操作员姓名%Type,
  登记时间_In     In 费用补充记录.登记时间%Type := Null,
  非原样退结算_In In Varchar2 := Null
) Is
  --退费结帐id_In:传入本次退费的结帐ID,多个用逗号分离(123,111...)
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  d_Date     Date;
  n_组id     财务缴款分组.Id%Type;
  n_结算id   费用补充记录.结算id%Type;
  n_费用状态 费用补充记录.费用状态%Type;
  v_实际票号 费用补充记录.实际票号%Type;
  n_病人id   费用补充记录.病人id%Type;
  n_附加标志 费用补充记录.附加标志%Type;
  n_Count    Number(18);
  n_打印id   票据使用明细.Id%Type;
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  d_Date := 登记时间_In;
  If 登记时间_In Is Null Then
    d_Date := Sysdate;
  End If;

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  v_Err_Msg := Null;
  Begin
    Select 结算id, 费用状态, 实际票号, 病人id, 附加标志
    Into n_结算id, n_费用状态, v_实际票号, n_病人id, n_附加标志
    From 费用补充记录
    Where 记录性质 = 1 And NO = No_In And 记录状态 = 1 And Rownum < 2 And Nvl(费用状态, 0) = 0;
  Exception
    When Others Then
      v_Err_Msg := '未找到结算单号为' || No_In || '的结算记录,可能已经被他人作废或重新结算,不允许再继续操作！';
  End;

  If v_Err_Msg Is Not Null Then
    Raise Err_Item;
  End If;

  Update 费用补充记录 Set 记录状态 = 3 Where 结算id = n_结算id;

  Insert Into 费用补充记录
    (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
    Select 记录性质, NO, 2, 实际票号, 冲销id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名, d_Date As 登记时间,
           n_组id As 缴款组id, 病人id, 结算序号_In As 结算序号, 附加标志
    From 费用补充记录
    Where 结算id = n_结算id;

  --先将医保退回,剩下部分,直接退款(退款界面)
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, 结算方式, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 冲预交, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 2 As 校对标志, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 6,
           n_会话号
    From 病人预交记录 A
    Where 结帐id = n_结算id And Exists
     (Select 1
           From 结算方式
           Where a.结算方式 = 名称 And 性质 In (3, 4) And Instr(',' || 非原样退结算_In || ',', ',' || 名称 || ',') = 0) And
          Mod(a.记录性质, 10) <> 1;

  --插入病人预交记录.结算方式为空的记录
  Insert Into 病人预交记录
    (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
     交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Select 病人预交记录_Id.Nextval, 6, NO, 2, 病人id, 主页id, 摘要, Null, d_Date As 收款时间, 操作员编号_In As 操作员编号, 操作员姓名_In As 操作员姓名,
           -1 * 退款额, 冲销id_In As 结帐id, n_组id As 缴款组id, 结算序号_In As 结算序号, 1 As 校对标志, Null, Null, Null, Null, Null, Null, 6,
           n_会话号
    From (Select NO, Max(病人id) As 病人id, Max(主页id) As 主页id, Max(摘要) As 摘要, Sum(冲预交) As 退款额
           From 病人预交记录
           Where 结帐id = 冲销id_In
           Group By NO) A;

  Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = n_结算id;

  Select Count(*)
  Into n_Count
  From (Select a.No, a.记录性质, a.序号, a.收费细目id, Sum(Nvl(a.付数, 1) * a.数次) As 数量
         From 门诊费用记录 A,
              (Select Distinct m.记录性质, m.No
                From 费用补充记录 J, 门诊费用记录 M
                Where j.收费结帐id = m.结帐id And j.No = No_In And Mod(j.记录性质, 0) = 1) B
         Where a.记录性质 = b.记录性质 And a.No = b.No And a.价格父号 Is Null
         Group By a.No, a.记录性质, a.序号, a.收费细目id
         Having Sum(Nvl(a.付数, 1) * a.数次) <> 0);

  If Nvl(n_Count, 0) <> 0 Then
    --部分冲销,需要产生重收记录
    Insert Into 费用补充记录
      (记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志)
      Select 1 As 记录性质, No_In As NO, 1, v_实际票号 As 实际票号, 重结id_In As 结算id, 收费结帐id, 1 As 费用状态, 操作员编号_In As 操作员编号,
             操作员姓名_In As 操作员姓名, d_Date As 登记时间, n_组id As 缴款组id, n_病人id As 病人id, 结算序号_In As 结算序号, n_附加标志 As 附加标志
      From (Select Distinct 收费结帐id As 收费结帐id
             From 费用补充记录 J
             Where j.No = No_In And Mod(j.记录性质, 10) = 1
             Union
             Select Column_Value As 结帐id From Table(f_Num2list(退费结帐ids_In)));
  End If;
  --收回票据
  --获取单据最后一次的打印ID(可能是多张单据收费打印)
  Begin
    --性质=1，原因=6为退费打印票据(红票)，不回收
    Select ID
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Null;
  End;

  --可能以前没有打印,无收回
  If n_打印id Is Not Null Then
    --a.多张单据循环调用时只能收回一次
    Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
    If n_Count = 0 Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
    Else
      --b.部分退费多次收回时,最后一次全退收回要排开已收回的
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
        From 票据使用明细 A
        Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
         (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充记录_Delete;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_记录状态 病人预交记录.记录状态%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  v_Msg      Varchar2(5000);
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10), n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                1
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3, n_会话号
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 In (1, 3)) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 In (1, 3) And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id   := 冲销id_In;
    n_记录状态 := 2;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id   := n_重结id;
      n_记录状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, n_记录状态, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
         Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null, n_会话号);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号,
                   交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                                 预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3, 会话号 = n_会话号
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质, 会话号)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3, n_会话号);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3, n_会话号);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = n_重结id;
  End If;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--93186:冉俊明,2016-05-09,并发异常单据处理控制。
Create Or Replace Procedure Zl_费用补充结算_完成退费
(
  结算id_In     In 费用补充记录.结算id%Type,
  结算方式_In   Varchar2,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:补结算退费
  --   结算方式_IN:格式为:"结算方式|结算金额|结算号码|结算摘要" ;也允许传入空.
  --   三方卡结算:需传入卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  -- 误差金额_In:存在误差费时,传入
  ------------------------------------------------------------------------------------------------------------------------------

  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  v_误差费   结算方式.名称%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_当前结算 Varchar2(4000);
  Cursor c_Balance Is
    Select 记录性质, NO, 记录状态, 实际票号, 结算id, 收费结帐id, 费用状态, 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id, 结算序号, 附加标志
    From 费用补充记录 A
    Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  r_Balance  c_Balance%RowType;
  n_未退合计 病人预交记录.冲预交%Type;
  n_Count    Number(18);
Begin
  Begin
    Select 1 Into n_Count From 费用补充记录 Where 结算id = 结算id_In And Rownum < 2 And 记录性质 = 1;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未找到医保补结算数据，不能继续操作!';
    Raise Err_Item;
  End If;

  Open c_Balance;
  Fetch c_Balance
    Into r_Balance;

  If Nvl(误差金额_In, 0) <> 0 Then
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结算id_In And 结算方式 = v_误差费;
  
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, v_误差费, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         卡号_In, 交易流水号_In, 交易说明_In, Null, 6);
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) - Nvl(误差金额_In, 0)
    Where 结算方式 Is Null And 结帐id = 结算id_In;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 6, r_Balance.No, r_Balance.记录状态, r_Balance.病人id, Null, Null, Null, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, -1 * 误差金额_In, r_Balance.结算id, r_Balance.缴款组id, r_Balance.结算序号, 2, Null, Null,
         Null, Null, Null, Null, 6);
    End If;
  End If;

  Select Sum(Nvl(冲预交, 0))
  Into n_未退合计
  From 病人预交记录
  Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1;
  If Not 结算方式_In Is Null Then
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
  
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_未退合计, 0) <> -1 * Nvl(n_结算金额, 0) Then
      v_Err_Msg := '当前退款合计(' || Nvl(n_结算金额, 0) || ')与未退合计(' || Nvl(n_未退合计, 0) || ')不区配!';
      Raise Err_Item;
    End If;
  
    For c_结算 In (Select 结帐id, 记录性质, 记录状态, NO, Sum(Nvl(冲预交, 0)) As 结算金额
                 From 病人预交记录
                 Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1
                 Group By 结帐id, 记录性质, NO, 记录状态) Loop
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, c_结算.记录性质, c_结算.No, c_结算.记录状态, r_Balance.病人id, Null, v_结算摘要, v_结算方式, r_Balance.登记时间,
         r_Balance.操作员编号, r_Balance.操作员姓名, c_结算.结算金额, c_结算.结帐id, r_Balance.缴款组id, r_Balance.结算序号, 2, 卡类别id_In, Null,
         卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, Mod(c_结算.记录性质, 10));
    
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) - Nvl(c_结算.结算金额, 0)
      Where 结算方式 Is Null And 结帐id = c_结算.结帐id;
    End Loop;
  End If;

  Select Sum(冲预交) Into n_冲预交 From 病人预交记录 Where 结帐id = r_Balance.结算序号;
  If Nvl(n_冲预交, 0) <> 0 Then
    v_Err_Msg := '医保结算数据与未退结算数据不匹配!';
    Raise Err_Item;
  End If;

  Delete From 病人预交记录
  Where 结算序号 = r_Balance.结算序号 And 结算方式 Is Null And Mod(记录性质, 10) <> 1 And Nvl(冲预交, 0) = 0;

  --1.更新异常状态
  Update 门诊费用记录
  Set 费用状态 = 0
  Where Nvl(费用状态, 0) = 1 And 结帐id In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = r_Balance.结算序号);

  Update 费用补充记录 Set 费用状态 = 0 Where 结算序号 = r_Balance.结算序号;
  If Sql%NotFound Then
    v_Err_Msg := '未找到医保补结算数据，可能补他人进行了退费或作废操作!';
    Raise Err_Item;
  End If;

  --2.更新校对标志,会话号
  Update 病人预交记录 Set 校对标志 = 0, 会话号 = Null Where 结算序号 = r_Balance.结算序号;

  --3.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = r_Balance.结算序号 And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_费用补充结算_完成退费;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
CREATE OR REPLACE Procedure Zl_药品设备接口_Update
(
  编号_In     In 药品设备接口.编号%Type,
  名称_In     In 药品设备接口.名称%Type,
  类型_In     In 药品设备接口.类型%Type,
  连接信息_In In 药品设备接口.连接信息%Type,
  扩展信息_In In Varchar2,
  Id_In       In 药品设备接口.Id%Type := Null,
  备注_In     In 药品设备接口.备注%Type := Null
) Is

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin

  --功能：药品设备接口表新增、修改记录

  If Id_In Is Null Then
    --新增
    Insert Into 药品设备接口
      (ID, 编号, 名称, 类型, 连接信息, 扩展信息, 备注)
    Values
      (药品设备接口_Id.Nextval, 编号_In, 名称_In, 类型_In, 连接信息_In, 扩展信息_In, 备注_In);
  Else
    --修改 
    Update 药品设备接口
    Set 编号 = 编号_In, 名称 = 名称_In, 类型 = 类型_In, 连接信息 = 连接信息_In, 扩展信息 = 扩展信息_In, 备注 = 备注_In
    Where ID = Id_In;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品设备接口_Update;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
CREATE OR REPLACE Procedure Zl_药品设备接口_State
(
  Id_In   In 药品设备接口.Id%Type,
  启用_In In Number
) Is

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin

  --功能：药品设备接口的状态调整

  If Id_In Is Null Then
    v_Error := '药品设备接口ID不正确！';
    Raise Err_Custom;
  End If;

  If 启用_In = 1 Then
    --启用
    Update 药品设备接口 Set 启用日期 = Sysdate, 停用日期 = Null Where ID = Id_In;
  Else
    --停用
    Update 药品设备接口 Set 停用日期 = Sysdate Where ID = Id_In;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品设备接口_State;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
CREATE OR REPLACE Procedure Zl_药品设备接口_Delete(Id_In In 药品设备接口.Id%Type) Is

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin

  --功能：药品设备接口表删除记录

  Delete From 药品设备接口 Where ID = Id_In;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品设备接口_Delete;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Create Or Replace Function Zl_Fun_Drug_Machine
(
  库房id_In   In 部门表.Id%Type,
  药品剂型_In In 药品剂型.名称%Type,
  收发id_In   In 药品收发记录.Id%Type := Null
) Return 药品设备接口.编号%Type Is

  v_Code 药品设备接口.编号%Type;

Begin

  --功能：计算参数对应的接口编号
  --说明：药品自动化设备接口部件的专用函数。
  --参数：
  --  收发ID_In：扩展参数，标准调用不传入

  Begin
    Select a.编号
    Into v_Code
    From 药品设备接口 A,
         Xmltable('//root/bm' Passing a.扩展信息 Columns 库房id Number(18) Path 'id', 剂型编码 Varchar2(20) Path 'jxbm') B, 药品剂型 C
    Where b.剂型编码 = c.编码 And a.停用日期 Is Null And a.启用日期 Is Not Null And b.库房id = 库房id_In And c.名称 = 药品剂型_In And
          Rownum < 2;
  Exception
    When Others Then
      Begin
        Select a.编号
        Into v_Code
        From 药品设备接口 A,
             Xmltable('//root/bm' Passing a.扩展信息 Columns 库房id Number(18) Path 'id', 剂型编码 Varchar2(20) Path 'jxbm') B
        Where a.停用日期 Is Null And a.启用日期 Is Not Null And (b.剂型编码 = '' Or b.剂型编码 Is Null) And b.库房id = 库房id_In And
              Rownum < 2;
      Exception
        When Others Then
          v_Code := Null;
      End;
  End;

  Return v_Code;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Drug_Machine;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
CREATE OR REPLACE Procedure Zl_药品收发门诊标志_Flag
(
  业务分类_In In 药品收发门诊标志.业务分类%Type,
  库房id_In   In 药品收发门诊标志.库房id%Type,
  处方信息_In In Varchar2,
  传送标志_In In Number
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --参数
  --  处方信息：单据1,处方号1;单据2,处方号2...

  For r_Tmp In (Select b.c2 处方号, b.c1 单据, a.标志
                From 药品收发门诊标志 A, Table(f_Str2list2(处方信息_In, ';', ',')) B
                Where a.处方号(+) = b.C2 And a.单据(+) = b.C1 And a.库房id(+) = 库房id_In And a.业务分类(+) = 业务分类_In) Loop
    If r_Tmp.标志 Is Null Then
      Delete 药品收发门诊标志 Where 处方号 = r_Tmp.处方号 And 单据 = r_Tmp.单据 And 库房id = 库房id_In;
      If 传送标志_In = 1 Then
        Insert Into 药品收发门诊标志
          (处方号, 单据, 库房id, 业务分类, 标志)
        Values
          (r_Tmp.处方号, r_Tmp.单据, 库房id_In, 业务分类_In, 1);
      Else
        Insert Into 药品收发门诊标志
          (处方号, 单据, 库房id, 业务分类, 标志)
        Values
          (r_Tmp.处方号, r_Tmp.单据, 库房id_In, 业务分类_In, 11);
      End If;
    Elsif r_Tmp.标志 Between 11 And 12 Then
      Update 药品收发门诊标志
      Set 标志 = 标志 + 1
      Where 处方号 = r_Tmp.处方号 And 单据 = r_Tmp.单据 And 库房id = 库房id_In And 业务分类 = 业务分类_In;
    End If;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发门诊标志_Flag;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
CREATE OR REPLACE Procedure Zl_药品收发住院标志_Flag
(
  业务分类_In In 药品收发住院标志.业务分类%Type,
  医嘱信息_In In Varchar2,
  传送标志_In In Number
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --参数
  --  医嘱信息：医嘱id1;医嘱2...

  For r_Tmp In (Select b.Column_Value 收发id, a.标志
                From 药品收发住院标志 A, Table(f_Str2list(医嘱信息_In, ';')) B
                Where a.收发id(+) = b.Column_Value And a.业务分类(+) = 业务分类_In) Loop
    If r_Tmp.标志 Is Null Then
      Delete 药品收发住院标志 Where 收发id = r_Tmp.收发id;
      If 传送标志_In = 1 Then
        Insert Into 药品收发住院标志 (收发id, 业务分类, 标志) Values (r_Tmp.收发id, 业务分类_In, 1);
      Else
        Insert Into 药品收发住院标志 (收发id, 业务分类, 标志) Values (r_Tmp.收发id, 业务分类_In, 11);
      End If;
    Elsif r_Tmp.标志 Between 11 And 12 Then
      Update 药品收发住院标志 Set 标志 = 标志 + 1 Where 收发id = r_Tmp.收发id And 业务分类 = 业务分类_In;
    End If;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发住院标志_Flag;
/

--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Create Or Replace Procedure Zl_Drug_Mac_Win
(
  No_In       In Varchar2,
  库房id_In   In 药品收发记录.库房id%Type,
  窗口编码_In In 发药窗口.编码%Type,
  病人id_In   In 病人医嘱记录.病人id%Type := Null
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
  v_No   药品收发记录.No%Type;
  v_Tmp  Varchar2(50);
  n_Bill 药品收发记录.单据%Type;
Begin

  --功能：第三方通知ZLHIS门诊处方发药窗口调整
  --参数：
  --  NO_In：设备的NO格式：处方号_单据_库房id

  If No_In Is Null Or No_In = '' Then
    v_Error := '处方信息无';
    Raise Err_Custom;
  End If;

  If 窗口编码_In Is Null Or 窗口编码_In = '' Then
    v_Error := '窗口信息无';
    Raise Err_Custom;
  End If;

  v_No := Substr(No_In, 1, 8);

  If Length(No_In) >= 10 Then
    v_Tmp := Substr(No_In, 10);
  End If;

  If v_Tmp Is Null Or v_Tmp = '' Then
    v_Error := '处方信息异常';
    Raise Err_Custom;
  End If;

  Select Column_Value Into n_Bill From Table(f_Num2list(v_Tmp, '_')) Where Rownum < 2;

  Zl_未发药品记录_分配发药窗口(v_No, n_Bill, 库房id_In, 窗口编码_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Drug_Mac_Win;
/

--96744:梁经伙,2016-06-08,添加转出表 疾病申报反馈 到过程
--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Create Or Replace Procedure Zl1_Datamove_Reb
(
  System_In    In Number,
  Speedmode_In In Number,
  Func_In      In Number,
  Enable_In    In Number := 0,
  Parallel_In  In Number := 0,
  Rebscope_In  In Number := 0
) As
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间 
  --参数： 
  --System_In:    应用系统编号,100=标准版 
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作） 
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引 ,8-重建标记转出查询所需索引以外的其他索引 
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效 
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部) 

  v_Sql      Varchar2(4000);
  n_Do       Number(1);
  n_Parallel Number(1);
  v_Tbs      Varchar2(100);

 --转出标记中的SQL查询所需的索引
  v_Indexeswithtag Varchar2(4000) := '门诊费用记录_IX_结帐ID,住院费用记录_IX_结帐ID,费用补充记录_IX_结算ID,费用补充记录_IX_登记时间,病人预交记录_IX_主页ID,病人预交记录_IX_结帐ID,病人预交记录_IX_收款时间,门诊费用记录_IX_登记时间,门诊费用记录_IX_医嘱序号,住院费用记录_IX_登记时间,病人结帐记录_IX_收费时间,病人结帐记录_IX_病人id' ||
                                     ',药品收发记录_IX_费用ID,收发记录补充信息_IX_收发ID,输液配药内容_IX_收发ID,药品留存计划_IX_留存ID,药品签名明细_IX_收发ID' ||
                                     ',人员借款记录_IX_借出时间,人员收缴记录_IX_登记时间,人员暂存记录_IX_收缴ID,人员暂存记录_IX_登记时间,票据领用记录_IX_登记时间,票据使用明细_IX_领用ID,票据打印明细_IX_使用ID' ||
                                     ',病人挂号记录_IX_登记时间,病人医嘱发送_IX_发送时间,病人医嘱记录_IX_挂号单,病人医嘱记录_IX_主页ID,病人医嘱记录_IX_相关ID' ||
                                     ',病案主页_IX_出院日期,住院费用记录_IX_病人ID,病人过敏记录_IX_病人ID,病人诊断记录_IX_病人ID,病人手麻记录_IX_主页ID' ||
                                     ',病人护理记录_IX_主页ID,病人护理内容_IX_记录id,病人护理文件_IX_主页ID,病人护理数据_IX_文件ID,病人护理明细_IX_记录ID,病人护理打印_IX_文件ID' ||
                                     ',电子病历记录_IX_病人ID,病人医嘱报告_IX_病历ID,影像报告驳回_IX_医嘱ID,报告查阅记录_IX_病历ID,病人诊断记录_IX_病历ID' ||
                                     ',病人临床路径_IX_病人ID,病人合并路径_IX_首要路径记录ID,病人路径执行_IX_路径记录ID,病人出径记录_IX_路径记录ID,病人诊断医嘱_IX_医嘱ID' ||
                                     ',影像报告记录_IX_医嘱ID,影像报告操作记录_IX_医嘱ID,影像申请单图像_IX_医嘱ID,影像收藏内容_IX_医嘱ID,检验标本记录_IX_医嘱ID,检验项目分布_IX_标本ID,检验分析记录_IX_标本ID' ||
                                     ',检验操作记录_IX_标本ID,检验图像结果_IX_标本ID,检验拒收记录_IX_医嘱ID,检验普通结果_IX_检验标本ID'; 

  --转出标记中的SQL查询所需的索引(主键及唯一键对应的索引)
  v_Constraintswithtag Varchar2(4000) := '病人预交记录_UQ_NO,病人结帐记录_UQ_NO,病人结帐记录_PK,门诊费用记录_UQ_NO,住院费用记录_UQ_NO,医保结算明细_PK' ||
                                         ',病人卡结算对照_PK,费用补充记录_PK,病人卡结算记录_PK,三方结算交易_PK,三方退款信息_PK,输液配药记录_PK,药品签名记录_PK,票据打印内容_PK,病人挂号记录_PK,病人挂号汇总_UQ_日期,病人转诊记录_UQ_NO' ||
                                         ',病人护理活动项目_UQ_页号,病人护理要素内容_UQ_页号,产程要素内容_PK,电子病历记录_PK,电子病历附件_PK,电子病历格式_PK,电子病历内容_UQ_对象序号,电子病历图形_PK,疾病申报记录_PK,疾病报告反馈_PK,疾病申报反馈_PK' ||
                                         ',病人合并路径评估_PK,病人路径评估_PK,病人路径变异_PK,病人路径指标_UQ_评估指标,病人路径医嘱_PK' ||
                                         ',病人医嘱记录_PK,病人医嘱报告_PK,病人医嘱计价_UQ_收费细目ID,病人医嘱附费_PK,病人医嘱附件_PK,病人医嘱执行_PK,医嘱执行时间_PK,医嘱执行打印_PK,病人医嘱打印_UQ_医嘱ID,输血申请记录_PK,输血检验结果_PK' ||
                                         ',病人诊断记录_PK,病人医嘱状态_PK,医嘱签名记录_PK,病人医嘱发送_PK,诊疗单据打印_PK,医嘱执行计价_PK,执行打印记录_PK,RIS检查预约_PK' ||
                                         ',影像检查记录_PK,影像检查序列_UQ_序列号,影像检查图象_UQ_图像号,影像危急值记录_UQ_医嘱ID' ||
                                         ',检验申请项目_PK,检验质控记录_PK,检验签名记录_PK,检验试剂记录_PK,检验质控报告_PK,检验药敏结果_PK,人员收缴记录_PK,人员收缴明细_PK,人员收缴票据_PK,人员收缴对照_PK' ||
                                         ',药品收发门诊标志_PK,药品收发住院标志_PK';

  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除 
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能 
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。 
  Procedure Setconstraintstatus As
    v_Pcol Varchar2(50);
    v_Fcol Varchar2(50);
    v_Del  Varchar2(4000);
  Begin
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键 
    If Enable_In = 0 Then
      --1.在线模式转出时，由于有业务产生删除操作，所以，对于级联删除的外键，用触发器来替代对子表数据的删除操作
      If Speedmode_In = 0 Then
        For Rp In (Select Distinct a.Table_Name As Ptable_Name, a.Constraint_Name
                   From User_Constraints A, User_Constraints C, zlBakTables B
                   Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                         c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And
                         c.Delete_Rule = 'CASCADE'
                   Order By a.Table_Name) Loop
        
          Select f_List2str(Cast(Collect(Column_Name Order By Position) As t_Strlist))
          Into v_Pcol
          From User_Cons_Columns
          Where Constraint_Name = Rp.Constraint_Name;
        
    v_Del := '';
          For Rf In (Select b.Table_Name, b.Constraint_Name,
                            f_List2str(Cast(Collect(b.Column_Name Order By b.Position) As t_Strlist)) As r_Col
                     From User_Constraints A, User_Cons_Columns B
                     Where a.r_Constraint_Name = Rp.Constraint_Name And a.Constraint_Name = b.Constraint_Name
                     Group By b.Table_Name, b.Constraint_Name) Loop
            If Instr(v_Pcol, ',') > 0 Then
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where (' || Rf.r_Col ||
                       ') in ((:Old.' || Replace(v_Pcol, ',', ',:Old.') || '));';
            Else
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where ' || Rf.r_Col || ' = :Old.' ||
                       v_Pcol || ';';
            End If;
          End Loop;
        
          v_Sql := 'Create Or Replace Trigger ' || Rp.Ptable_Name || '_Cascade_Del' || Chr(10) ||
                   '    After Delete On ' || Rp.Ptable_Name || Chr(10) || '    For Each Row' || Chr(10) || 'Begin' ||
                   Chr(10) || '    If :Old.待转出 Is Null Then ' || v_Del || Chr(10) || '    End If; ' || Chr(10) ||
                   'End ' || Rp.Ptable_Name || '_Cascade_Del;';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.禁用引用转出表主键的他表外键
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED'
                Order By a.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.禁用主键或唯一键索引(离线转出时)
      If Speedmode_In = 1 Then
        --必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引) 
        For R In (Select a.Table_Name, a.Constraint_Name
                  From User_Constraints A, zlBakTables T, User_Tables B
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And
                        a.Constraint_Name Not In
                        (Select Upper(Column_Value) As Constraint_Name From Table(f_Str2list(v_Constraintswithtag)))
                  Order By Constraint_Name) Loop
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name ||
                   ' Cascade Drop Index';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    Else
      --启用时
      --1.先启用主键和唯一键，再启用引用转出表主键的他表外键 
      If Speedmode_In = 1 Then
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式 
        For R In (Select d.Table_Name, d.Constraint_Name,
                         f_List2str(Cast(Collect(d.Column_Name Order By d.Position) As t_Strlist)) Colstr
                  From User_Cons_Columns D,
                       (Select a.Table_Name, a.Constraint_Name
                         From User_Constraints A, zlBakTables T
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And
                               a.Constraint_Type In ('P', 'U')) A
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name
                  Group By d.Table_Name, d.Constraint_Name
                  Order By Constraint_Name) Loop
          Update Zldatamovelog
          Set 当前进度 = '正在恢复约束:' || r.Constraint_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2;
        
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create 
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr ||
                   ') Tablespace ' || v_Tbs || ' Nologging';
          Begin
            Execute Immediate v_Sql;
          Exception
            When Others Then
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错 
          End;
        
          --会自动建立约束与索引的关联 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.启用引用转出表主键的他表外键 
      For R In (Select c.Table_Name, c.Constraint_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED'
                Order By a.Table_Name) Loop
        --为了加快速度，采用novalidate，不验证已有数据 
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.在线模式转出时，删除之前创建的用来替代级联删除外键的触发器
      If Speedmode_In = 0 Then
        For R In (Select a.Trigger_Name
                  From User_Triggers A, zlBakTables B
                  Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And
                        Trigger_Name = Table_Name || '_CASCADE_DEL' And Triggering_Event = 'DELETE') Loop
          v_Sql := 'Drop Trigger ' || r.Trigger_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    End If;
  End Setconstraintstatus;

  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID) 
  --说明：禁用索引是为了提高删除数据的性能 
  Procedure Setindexstatus As
  Begin
    If Speedmode_In = 1 Then
      --保留转出标记中的SQL查询所需的索引 
      For R In (Select /*+ rule*/
                 a.Index_Name
                From User_Indexes A, zlBakTables T
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And
                      a.Index_Name Not In
                      (Select Upper(Column_Value) As Index_Name From Table(f_Str2list(v_Indexeswithtag))) And
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists
                 (Select 1
                       From User_Constraints C
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U'))
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
          Execute Immediate v_Sql;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
          Begin
            Execute Immediate v_Sql;
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
          
          Exception
            When Others Then
              If SQLErrM Like 'ORA-00054%' Then
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
                Execute Immediate v_Sql;
              End If;
          End;
        End If;
      End Loop;
    Else
      For R In (Select a.Index_Name
                From (Select d.Table_Name, d.Index_Name,
                              f_List2str(Cast(Collect(d.Column_Name Order By d.Column_Position) As t_Strlist)) Colstr
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name
                       Group By d.Table_Name, d.Index_Name) A,
                     (Select e.Table_Name,
                              f_List2str(Cast(Collect(e.Column_Name Order By e.Position) As t_Strlist)) Colstr
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And
                             Not Exists
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In)
                       Group By e.Table_Name, e.Constraint_Name) B
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用 
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '药品收发记录_IX_药品ID', '药品收发记录_IX_价格ID') Then
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
            Execute Immediate v_Sql;
          End If;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        End If;
      End Loop;
    End If;
  End Setindexstatus;

  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复 
  Procedure Settriggerstatus As
  Begin
    For R In (Select Distinct a.Table_Name, t.停用触发器
              From User_Triggers A, zlBakTables T
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And
                    t.系统 = System_In) Loop
      If Enable_In = 0 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name;
      Elsif Nvl(r.停用触发器, 0) = 1 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name;
      End If;
      Execute Immediate v_Sql;
    End Loop;
    Commit;
  End Settriggerstatus;

  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用 
  Procedure Setjobstatus As
    v_Jobs Varchar2(4000);
  Begin
    --停用 
    If Enable_In = 0 Then
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop
        Dbms_Job.Broken(r.Job, True);
        v_Jobs := v_Jobs || ',' || r.Job;
      End Loop;
    
      If v_Jobs Is Not Null Then
        v_Jobs := Substr(v_Jobs, 2);
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1;
      End If;
    Else
      --启用 
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1;
      If v_Jobs Is Not Null Then
        For R In (Select Job
                  From User_Jobs
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop
          Dbms_Job.Broken(r.Job, False);
        End Loop;
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1;
      End If;
    End If;
    --作业设置后必须提交事务才生效 
    Commit;
  End Setjobstatus;
Begin
  If Parallel_In < 2 Then
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL';
  Else
    If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度） 
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度 
      --恢复在线库的约束和索引时，不管是不是在线模式，都加上并行，否则太慢
      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In;
      n_Parallel := 1;
    End If;
  End If;

  If Func_In = 1 Then
    --1.设置触发器 
    Settriggerstatus;
  Elsif Func_In = 2 Then
    --2.设置自动作业 
    Setjobstatus;
  Elsif Func_In = 3 Then
    --3.设置约束状态 
    Setconstraintstatus;
  Elsif Func_In = 4 Then
    --4.设置索引状态 
    Setindexstatus;
  Elsif Func_In = 5 Then
    --5.重建"待转出"索引 
    For R In (Select b.Index_Name
              From zlBakTables A, User_Indexes B
              Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And b.Index_Name = b.Table_Name || '_IX_待转出'
              Union All
              Select '病案主页_IX_待转出'
              From Dual
              Where System_In = 100) Loop
      Update Zldatamovelog
      Set 当前进度 = '正在重建索引:' || r.Index_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --耗时太短，无须并行DDL 
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
      --在线重建索引太慢，所以，即使在线转出模式也不用在线重建
      v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Begin
        Execute Immediate v_Sql;
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
  
  Elsif Func_In = 6 Then
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间） 
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时 
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.系统 = System_In And a.表名 = b.Table_Name And
                    b.Index_Name In (Select Upper(Column_Value)
                                     From Table(f_Str2list(v_Indexeswithtag))
                                     Union
                                     Select Upper(Column_Value)
                                     From Table(f_Str2list(v_Constraintswithtag)))
              Order By Index_Name) Loop
      n_Do := 0;
      If Rebscope_In = 0 Then
        If r.组号 < 5 Then
          n_Do := 1; --仅经济核算类 
        End If;
      Elsif Rebscope_In = 1 Then
        If r.组号 < 5 Or r.组号 = 8 Then
          n_Do := 1; --仅经济核算类、医嘱类 
        End If;
      Else
        n_Do := 1;
      End If;
    
      If n_Do = 1 Then
        Update Zldatamovelog
        Set 当前进度 = '正在重建索引:' || r.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space'; 
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍 
        If Speedmode_In = 1 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
        Else
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
        End If;
        Begin
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        
        Exception
          When Others Then
            If SQLErrM Like 'ORA-00054%' Then
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
              Execute Immediate v_Sql;
            End If;
        End;
      End If;
    End Loop;
  
    --重组表的数据
  Elsif Func_In = 7 Then
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组 
    For R In (Select a.表名 As Table_Name
              From zlBakTables A
              Where a.直接转出 = 1 And (组号 < Decode(Rebscope_In, 0, 5, 100))
              Order By 组号, 序号) Loop
    
      Update Zldatamovelog
      Set 当前进度 = '正在重组表:' || r.Table_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩 
      --在前面设置了会话级的强制并行 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging';
      Execute Immediate v_Sql;
    
      --单独移动Lob对象 
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' ||
                 l.Tablespace_Name || ') Nologging';
        Execute Immediate v_Sql;
      End Loop;
    
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel';
      Execute Immediate v_Sql;
    
      --move后，表相关的索引会全部失效，需要全部重建 
      For S In (Select Index_Name
                From User_Indexes
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE'
                Order By Index_Name) Loop
        Update Zldatamovelog
        Set 当前进度 = '正在恢复失效索引:' || s.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --在前面设置了会话级的强制并行 
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging';
        Execute Immediate v_Sql;
      End Loop;
    End Loop;
    --重建转出表上标记转出以外的其他索引（用于转出完成后收回空闲空间）
    --失效的索引不重建，因为转出完后有单独的重建功能
  Elsif Func_In = 8 Then
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.系统 = System_In And a.表名 = b.Table_Name And b.Status = 'VALID' And b.Index_Type = 'NORMAL' And
                    b.Index_Name Not Like 'BIN$%' And
                    b.Index_Name Not In (Select Upper(Column_Value)
                                         From Table(f_Str2list(v_Indexeswithtag))
                                         Union
                                         Select Upper(Column_Value)
                                         From Table(f_Str2list(v_Constraintswithtag)))
              Order By Index_Name) Loop
      Update Zldatamovelog
      Set 当前进度 = '正在重建索引:' || r.Index_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      If Speedmode_In = 1 Then
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Else
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
      End If;
      Begin
        Execute Immediate v_Sql;
        --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源    
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
  End If;

  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢) 
  --------------------------------------------------------------------------------------------------- 
  If n_Parallel = 1 Then
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL';
  
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel';
      Execute Immediate v_Sql;
    End Loop;
  End If;

  Update Zldatamovelog
  Set 当前进度 = '重建完成'
  Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
  Commit;
  --本过程不进行错误处理，错误由调用过程处理 
End Zl1_Datamove_Reb;
/

--96744:梁经伙,2016-06-08,添加转出表 疾病申报反馈 到过程
--95987:余智勇,2016-05-09,药品自动化设备接口虚拟模块
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End    In Date,
  n_批次   In Number,
  n_System In Number
) As
  --功能：标记待转出的数据 
  --说明：为避免Undo表空间膨胀过大，分段提交 
Begin
  --1.经济核算（费用,药品,收款和票据等）  
  --新加子查询注意性能优化，把能够将数据过滤到最小的条件放到最后，Exists类条件放前面
  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录(排除之后退号和退费的,一张单据中只要其中一行退了) 
         From 门诊费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
     And a.待转出 Is Null And a.记录性质 In (1, 4) And a.登记时间 < d_End
         Union All
         Select Distinct a.结算id --2.医保补结算 
         From 费用补充记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 费用补充记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 In (1, 2) And b.登记时间 >= d_End))
     And a.待转出 Is Null And a.记录性质 = 1 And a.登记时间 < d_End
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了) 
         From 住院费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 住院费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
    And a.待转出 Is Null And a.记帐费用 = 0 And a.记录性质 = 5 And a.登记时间 < d_End
         Union All --4.门诊(记帐单)和住院的结帐结算记录 
         Select 结帐id
         From (With Settle As (Select Distinct a.Id As 结帐id, a.病人id --3.门诊(记帐单)和住院的结帐结算记录(排除之后结帐作废的) 
                               From 病人结帐记录 A
                               Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                                      (Select 1 From 病人结帐记录 B Where a.No = b.No And b.记录状态 = 2 And b.收费时间 >= d_End))
              And a.待转出 Is Null And a.收费时间 < d_End)
                Select 结帐id
                From Settle
                Minus
                --以下结帐ID要整体排除,避免部分费用明细被转出后影响后续的计算是否冲完 
                --1.一张预交款被多笔结帐冲完（结帐ID不同）
                --2.费用单据的结帐ID相关的可能还有其他NO的其他结帐ID(结帐作废后分多次结帐结清，可能部分在转出时间之后)
                --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除 
                Select Distinct d.Id
                From 病人结帐记录 D,
                     (Select Distinct c.病人id --多次住院可以一起结，以及门诊记帐和住院记帐可以一起结且冲同一笔预交，所以这里不加主页ID 
                       From 住院费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 住院费用记录 D,
                                   (Select s.结帐id From Settle S, 病人结帐记录 E --没有结清且该病人之后没有再结过就成了呆帐，这种就不排除 
                                     Where s.病人id = e.病人id And (e.收费时间 > d_End Or Exists (Select 1 From 在院病人 F Where s.病人id = f.病人id))) S 
                              Where d.结帐id = s.结帐id) D
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号 --结帐后作废后，再对包含记帐单销帐的结帐ID为空的记录,一起汇总计算是否结清,这种结帐ID为空的数据转出在后面单独转出 
                       Group By c.No, Mod(c.记录性质, 10), c.病人id --一张单据中的一行可部分结帐，以单据为对象来判断，避免一张单据的其中一部分被转出 
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1 --排除转出时间之后再次结帐的(作废后再次结帐)，避免原始单据转走后，后续结帐时无法正确判断 
                                                                                   From 住院费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id  And s.待转出 Is Null And s.收费时间 >= d_End)
                       Union All
                       Select Distinct c.病人id
                       From 门诊费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 门诊费用记录 D, Settle S
                              Where d.结帐id = s.结帐id) D --因为是门诊病人，所以，只要没有结清,该病人的都不转出 
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号
                       Group By c.No, Mod(c.记录性质, 10), c.病人id
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1
                                                                                   From 门诊费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id And s.待转出 Is Null And s.收费时间 >= d_End)) N
                Where d.病人id = n.病人id)
         );

  --排除预交款未冲完的
  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除 
  --由于可能存在数据异常(住院费用结帐冲预交类别为1的门诊预交)，所以没有加预交类别条件限定 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In (Select Distinct d.结帐id
                 From 病人预交记录 D,
                      --连接D表是为了查冲同一预交单据的其他结帐ID（退预交款，冲预交作废的，再次冲同一预交单据） 
                      --该预交或冲预交单据涉及的所有结帐ID的都不转出，避免部分冲预交的结帐ID被排除后，原始预交单被转走，或者其他结帐ID将费用单据的一部分(原始结帐、结帐作废、再次结一部分、再次结全部)转走 
                      (Select Distinct l.No
                        From 病人预交记录 L, 病人预交记录 P --可能本次结帐冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID 
                        Where l.记录性质 = p.记录性质 And l.No = p.No And p.记录性质 In (1, 11) And p.待转出 = n_批次
                        Group By l.No, l.病人id
                        Having Nvl(Sum(l.金额), 0) <> Nvl(Sum(l.冲预交), 0) And (Exists (Select 1
                                                                                  From 病人预交记录 E --没有冲完且之后没有再冲过或结算过就成了呆帐（以及存在用负的结帐补款来表示冲预交当成冲完的清况），这种就不排除
                                                                                  Where l.病人id = e.病人id And e.待转出 Is Null And e.收款时间 > d_End)
                                                                                  Or Exists (Select 1 From 在院病人 E Where l.病人id =e.病人id)
                                                                                  Or Exists (Select 1 From 病人未结费用 E Where l.病人id =e.病人id))  
                        Or Nvl(Sum(l.金额), 0) = Nvl(Sum(l.冲预交), 0) And Exists (Select 1
                                                                                  From 病人预交记录 E --排除转出时间之后的其他结帐ID冲的,10.34.20后，冲预交全部单独增加了一条记录，收费时间就是冲预交时间(以前是在原始交预交款的记录上填冲预交字段，不能直接查到冲预交款的时间)
                                                                                  Where e.No = l.No And e.记录性质 = 11 And e.待转出 Is Null And e.收款时间 >= d_End)) N
                 Where d.No = n.No And d.记录性质 In (1, 11));

  --预交款没有使用就直接退了的记录(结帐ID为空) 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --冲预交款作废的记录（记录性质为2），没有结帐ID 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 2 And NO In (Select a.No From 病人预交记录 A Where a.待转出 = n_批次 And a.记录性质 = 3);

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐) 
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 三方退款信息
  Set 待转出 = n_批次
  Where (记录id,结帐ID) In (Select a.Id,A.结帐ID From 病人预交记录 A Where 待转出 = n_批次);

  --1.挂号打折后实收金额为0的(没有对应的预交记录),即使之后有退号费用也不管，因为金额为零不影响计算),而卡费即使为零也有预交记录 
  --结帐ID为空的是异常数据（德阳医院仅有3笔此类数据）
  --根据挂号记录再找门诊费用，比直接按时间查门诊费用要快 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where NO In (Select NO From 病人挂号记录 Where 待转出 Is Null And 登记时间 < d_End) And 记录性质 = 4 And (实收金额 = 0 Or 结帐id Is Null);

  --2.直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --3.没有结帐id的数据(按登记时间)
  --1)未结帐的门诊记帐费用(赖账)，该病人没有预交记录或冲预交记录，并且该时间之后无门诊费用发生
  --2)未结帐的划价记录
  --3)未收费（也没有冲预交）的零费用
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Not Exists (Select 1 From 病人预交记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 记录性质 In (1, 11)) And Not Exists
         (Select 1 From 门诊费用记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 登记时间 > d_End) And 记录性质 = 2 Or 记录状态 = 0 Or
         记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And 结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --4.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --1)未结帐的零记帐费用或打折后实收金额为零的（结帐模块参数没有勾选对零费用结帐）
  --2)结帐作废后，记帐单销帐的记录（结帐ID为空且记录状态为2的），记录状态为3的且有结帐ID的在最前面已转出. 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Exists (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                       b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
          From 门诊费用记录 B
          Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
          Group By b.No, b.记录性质, b.序号
          Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --5.有结帐id的零费用(按发生时间)
  --按费别打折后结帐金额为零的收费记录,或者一张单据相同结帐ID的结帐金额之和为0(冲销后为零)
  --即使在转出时间之后发药的，也强制转出（为了减少逻辑复杂性，提高查询性能）
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (结帐金额 = 0 Or Exists
         (Select 1 From 门诊费用记录 C Where a.结帐id = c.结帐id Group By c.结帐id, c.No Having Sum(c.结帐金额) = 0)) And Not Exists
   (Select 1 From 病人预交记录 B Where a.结帐id = b.结帐id And b.待转出 Is Null) And 记录性质 = 1 And 结帐id Is Not Null And
        待转出 Is Null And 发生时间 < d_End;


  Update /*+ rule*/ 医保结算明细
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);


  --1.从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的 
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --2.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --1)转出结帐作废后，记帐单销帐的记录（记帐状态为2且没有结帐ID且(记录状态为3的有结帐ID的)在最前面已转出） 
  --2)未结帐的零费用(已冲销的记帐单或打折后实收金额为零) 
  --3)没有结帐ID的划价记录处理为转出 
  
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 Or 记录状态 = 0) And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --3.离院未结帐的（赖帐病人），因为是很久以前的这些数据，如果预交已冲完，则处理为要转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.待转出 Is Null And b.预交类别 = 2 And b.记录性质 In (1, 11)
                                Having Nvl(Sum(b.金额), 0) - Nvl(Sum(b.冲预交), 0) <> 0));

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品收发门诊标志 A
  Set 待转出 = n_批次
  Where Exists(Select 1 From 药品收发记录 B Where b.NO = a.处方号 And b.单据 = a.单据 And b.待转出 = n_批次);

  Update /*+ rule*/ 药品收发住院标志
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists
   (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_End) And 待转出 Is Null And 剩余数量 = 0 And 登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据 
  --不转出的条件：挂号费用未转出的，转出时间之后存在医嘱，医嘱对应的费用未转出的 
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出 
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1
                From 门诊费用记录 A
                Where r.No = a.No And a.登记时间 < d_End And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.待转出 Is Null And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_End) And Not Exists
          (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And r.待转出 Is Null And
               r.登记时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配 
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

  --通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用 
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人当时并未出院(一次住院多次结帐)。 
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低） 
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
        数据转出 Is Null And 出院日期 < d_End And
        (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据 
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据 
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据 
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id
                                       From 病案主页
                                       Where 待转出 = n_批次);

  --自登记类病人(无挂号单号) 
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID 
  --为提升性能，不从医嘱发送记录的发送时间查询，不采用精确的时间，因为直接登记的检验医嘱，一般开嘱时间与发送时间相差不大
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = N_批次
  Where ID In (Select C.病历id
             From 病人医嘱记录 B, 病人医嘱报告 C
             Where C.医嘱id = B.Id And Nvl(B.主页id, 0) = 0 And B.挂号单 Is Null And B.相关id Is Null And B.待转出 Is Null And
                   B.开嘱时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次  
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  
  Update /*+ rule*/ 疾病报告反馈
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  
  Update /*+ rule*/ 疾病申报反馈
  Set 待转出 = n_批次
  Where 申报id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
 
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径 
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);
  
  Update /*+ rule*/ RIS检查预约
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/

--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
CREATE OR REPLACE Procedure Zl_临时票据打印内容_Insert
(
  打印id_In     票据打印内容.Id%Type,
  No_In         Varchar2,
  领用id_In     临时票据打印内容.领用id%Type,
  开始发票号_In 临时票据打印内容.开始票号%Type
  
) As
  --功能：处理临时表数据
  --参数：
  --      打印ID_IN   =     当修改多单据中的一张时,为了便于整体重打,将该单据的打印内容填写为与退费单据相同,不单独新发出票据,由退费重打发出
  --      NO_IN       =     收费的单据号,可能是多张单据同时收费。格式为：A0000001,A0000002,....

  v_Error Varchar2(255);
  Err_Custom Exception;

  v_当前号 门诊费用记录.No%Type;
  v_单据号 Varchar2(1000);
  n_Count  Number(2);
Begin
  If Nvl(打印id_In, 0) = 0 Then
    v_Error := '必须传入打印ID！';
    Raise Err_Custom;
  End If;

  --生成单据的票据打印内容
  v_单据号 := No_In || ',';
  While v_单据号 Is Not Null Loop
    v_当前号 := Substr(v_单据号, 1, Instr(v_单据号, ',') - 1);
    If v_当前号 Is Not Null Then
      --由于临时票据打印内容没有主键及唯一键，所以需要检查
      Begin
        Select 1 Into n_Count From 临时票据打印内容 Where ID = 打印id_In And 性质 = 1 And NO = v_当前号 And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If Nvl(n_Count, 0) = 1 Then
        v_Error := '临时票据打印内容表的(ID, 性质, NO)重复！';
        Raise Err_Custom;
      End If;
    
      --临时票据打印内容
      Insert Into 临时票据打印内容
        (ID, 性质, NO, 开始票号, 领用id)
      Values
        (打印id_In, 1, v_当前号, 开始发票号_In, 领用id_In);
    End If;
    v_单据号 := Substr(v_单据号, Instr(v_单据号, ',') + 1);
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临时票据打印内容_Insert;
/

--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
Create Or Replace Procedure Zl_临时票据打印内容_Delete(打印id_In 票据打印内容.Id%Type) As
  --功能：删除临时表数据
  --参数：
  --      打印ID_IN   =     当修改多单据中的一张时,为了便于整体重打,将该单据的打印内容填写为与退费单据相同,不单独新发出票据,由退费重打发出
  --      NO_IN       =     收费的单据号,可能是多张单据同时收费。格式为：A0000001,A0000002,....

Begin
  Delete 临时票据打印内容 Where ID = 打印id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临时票据打印内容_Delete;
/

--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
Create Or Replace Procedure Zl_门诊收费票据_Insert
(
  No_In           Varchar2,
  票据号_In       票据使用明细.号码%Type,
  领用id_In       票据使用明细.领用id%Type,
  使用人_In       票据使用明细.使用人%Type,
  使用时间_In     票据使用明细.使用时间%Type,
  打印id_In       票据打印内容.Id%Type := 0,
  票据张数_In     Number := 1,
  医保接口打印_In Number := 0,
  按病人打印_In   Number := 0
) As
  --功能：处理门诊收费票据的发出
  --参数：
  --      NO_IN       =     收费的单据号,可能是多张单据同时收费。格式为：A0000001,A0000002,....
  --      票据号_IN   =     要使用的开始票据号。该票据号应该不为空，否则不用处理票据，也不能区分多张一起收费的单据。
  --      领用ID_IN   =     严格控制票据时，为使用票据的领用批次。非严格控制时，为NULL。
  --      打印ID_IN   =     当修改多单据中的一张时,为了便于整体重打,将该单据的打印内容填写为与退费单据相同,不单独新发出票据,由退费重打发出
  --      票据张数_In =     实际所需的票据打印张数
  --      医保接口打印_In = 是否医保接口打印先存入票据数据，若是将传入打印id_In
  --      按病人打印_In:是否按病人打印:1-按病人打印(即从临时票据打印内容中取数,打印ID_IN要传入)，0-是
  --该游标用于票据范围判断
  Cursor c_Fact Is
    Select * From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_票据号     票据使用明细.号码%Type;
  v_当前票据号 票据使用明细.号码%Type;
  v_打印id     票据打印内容.Id%Type;

  v_当前号 门诊费用记录.No%Type;
  v_单据号 Varchar2(1000);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(打印id_In, 0) = 0 Or Nvl(医保接口打印_In, 0) = 1 Or Nvl(按病人打印_In, 0) = 1 Then
  
    --无票据号时,不用处理票据
    If 票据号_In Is Null Then
      Return;
    End If;
    v_打印id := Nvl(打印id_In, 0);
    If Nvl(v_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    End If;
  
    If Nvl(按病人打印_In, 0) = 1 Then
      --根据临时表数据来产生打印内容
      Insert Into 票据打印内容
        (ID, 数据性质, NO, 打印类型)
        Select ID, 性质, NO, 1 From 临时票据打印内容 Where ID = v_打印id And 性质 = 1;
      If Sql%NotFound Then
        v_Error := '在临时表中未找到对应的打印单据。';
        Raise Err_Custom;
      End If;
      --门诊费用记录中填写开始票据号以便显示
      Update 门诊费用记录
      Set 实际票号 = 票据号_In
      Where 记录性质 = 1 And NO 　in (Select NO From 临时票据打印内容 Where ID = v_打印id And 性质 = 1);
    Else
    
      --生成单据的票据打印内容
      v_单据号 := No_In || ',';
      While v_单据号 Is Not Null Loop
        v_当前号 := Substr(v_单据号, 1, Instr(v_单据号, ',') - 1);
        --票据打印内容
        Insert Into 票据打印内容 (ID, 数据性质, NO, 打印类型) Values (v_打印id, 1, v_当前号, Null);
        --门诊费用记录中填写开始票据号以便显示
        Update 门诊费用记录 Set 实际票号 = 票据号_In Where 记录性质 = 1 And NO = v_当前号;
        v_单据号 := Substr(v_单据号, Instr(v_单据号, ',') + 1);
      End Loop;
    End If;
  
    --并发出票据
    v_票据号 := 票据号_In;
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
      If c_Fact%RowCount = 0 Then
        v_Error := '无效的票据领用批次，无法完成收费票据分配操作。';
        Close c_Fact;
        Raise Err_Custom;
      Elsif Nvl(r_Factrow.剩余数量, 0) < 票据张数_In Then
        v_Error := '当前批次的剩余数量不足' || 票据张数_In || '张，无法完成收费票据分配操作。';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
    For I In 1 .. 票据张数_In Loop
      --检查票据范围是否正确
      If Nvl(领用id_In, 0) <> 0 Then
        If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
            Length(v_票据号) = Length(r_Factrow.终止号码)) Then
          v_Error := '该单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
          Close c_Fact;
          Raise Err_Custom;
        End If;
      End If;
    
      --发出票据
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
      Values
        (票据使用明细_Id.Nextval, 1, v_票据号, 1, 1, 领用id_In, v_打印id, 使用人_In, 使用时间_In);
    
      v_当前票据号 := v_票据号;
      --下一个票据号
      v_票据号 := Zl_Incstr(v_票据号);
    End Loop;
  
    If Nvl(领用id_In, 0) <> 0 Then
      Update 票据领用记录
      Set 使用时间 = 使用时间_In, 当前号码 = v_当前票据号, 剩余数量 = Nvl(剩余数量, 0) - 票据张数_In
      Where ID = 领用id_In;
    
      Close c_Fact;
    End If;
  Else
    Insert Into 票据打印内容 (ID, 数据性质, NO, 打印类型) Values (打印id_In, 1, No_In, Null);
    If 票据号_In Is Null Then
      Return;
    End If;
    --门诊费用记录中填写开始票据号以便显示
    Update 门诊费用记录 Set 实际票号 = 票据号_In Where 记录性质 = 1 And NO = No_In;
  End If;
  If 打印id_In > 0 Then
    Delete 临时票据打印内容 Where ID = 打印id_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费票据_Insert;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
--95543:刘兴洪,2016-05-06,按病人补打发票时不按结算次数打印
Create Or Replace Procedure Zl_门诊收费记录_Reprint
(
  No_In         门诊费用记录.No%Type,
  票据号_In     票据使用明细.号码%Type,
  领用id_In     票据使用明细.领用id%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  退费_In       Number := 0,
  票据张数_In   Number := 0,
  收回票据号_In Varchar2 := Null,
  票种_In       Number := 1
) As
  --功能：用于重打收费票据 
  --参数： 
  --      NO_IN         =   要重打的单据号，可能是一起收费的多张单据中的一张。 
  --      票据号        =   用于重打的起始票据号.而该张收费单据可能使用多张票据。 
  --      领用ID        =   如果为0或NULL,表示不严格控制票据。 
  --      退费_IN       =   是否部份退费时调用该过程 
  --      收回票据号_In =   部分退费时,界面选择要收回的票据号,这些票据只收回,不重新发出,传入空表示全部收回并重打 
  --该游标用于范围判断 
  Cursor c_Fact Is
    Select 开始号码, 终止号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_收回id   票据打印内容.Id%Type;
  v_打印id   票据打印内容.Id%Type;
  v_票据号   票据使用明细.号码%Type;
  n_补打     Number(2);
  n_分单据   Number(2);
  n_打印类型 票据打印内容.打印类型%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  n_分单据 := zl_GetSysParameter('多张单据收费分别打印', 1121);
  --获取该张单据的最后一次的的打印ID(可能没有) 
  Begin
    --性质=1，原因=6为退费打印票据(红票)，不回收
    Select ID
    Into v_收回id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 票种_In And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      n_补打 := 1;
  End;

  n_打印类型 := Null;
  If 票种_In = 1 Then
    Begin
      Select Max(打印类型) Into n_打印类型 From 票据打印内容 Where 数据性质 = 票种_In And NO = No_In;
    Exception
      When Others Then
        Null;
    End;
  End If;

  --收回票据(可能以前未控制票据,无法收回) 
  If v_收回id Is Not Null Then
    If 收回票据号_In Is Null Then
      If Nvl(退费_In, 0) = 0 Then
        --a.重打 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Else
        --b.部分退费重打先收回 
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
          From 票据使用明细 A
          Where 打印id = v_收回id And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      End If;
    Else
      --c.部分退费收回指定的票据号 
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细 A
        Where 打印id = v_收回id And 性质 = 1 And Instr(收回票据号_In, 号码) > 0 And Not Exists
         (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = v_收回id And 性质 = 2);
      Return;
    End If;
  Else
    n_补打 := 1;
  End If;

  --无票据号时,不用处理票据 
  If 票据号_In Is Null Then
    Return;
  End If;

  --重新发出票据并填写票据打印内容 
  Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  If n_补打 = 1 And n_分单据 = 0 Then
    Insert Into 票据打印内容
      (ID, 数据性质, NO, 打印类型)
      Select Distinct v_打印id, 1, NO, 0
      From (Select Distinct a.No
             From 门诊费用记录 A, 病人预交记录 B
             Where a.结帐id = b.结帐id And b.结算序号 In (Select Distinct a.结算序号
                                                  From 病人预交记录 A, 门诊费用记录 B
                                                  Where b.No = No_In And a.结帐id = b.结帐id));
  
    --门诊费用记录中记录票据号以便显示
    If 票种_In = 1 Or 票种_In = 4 Then
      Update 门诊费用记录
      Set 实际票号 = 票据号_In
      Where Mod(记录性质, 10) = Decode(票种_In, 1, 1, 4) And
            NO In
            (Select Distinct a.No
             From 门诊费用记录 A, 病人预交记录 B
             Where a.结帐id = b.结帐id And b.结算序号 In (Select Distinct a.结算序号
                                                  From 病人预交记录 A, 门诊费用记录 B
                                                  Where b.No = No_In And a.结帐id = b.结帐id));
    End If;
  Else
    Insert Into 票据打印内容
      (ID, 数据性质, NO, 打印类型)
      Select Distinct v_打印id, 1, NO, n_打印类型 As 打印类型
      From (Select NO
             From 票据打印内容
             Where ID = v_收回id And 数据性质 = 票种_In
             Union All
             Select No_In From Dual);
  
    --门诊费用记录中记录票据号以便显示 
    If 票种_In = 1 Or 票种_In = 4 Then
      Update 门诊费用记录
      Set 实际票号 = 票据号_In
      Where Mod(记录性质, 10) = Decode(票种_In, 1, 1, 4) And
            NO In (Select NO
                   From 票据打印内容
                   Where ID = v_收回id And 数据性质 = 票种_In
                   Union
                   Select No_In From Dual);
    End If;
  End If;
  v_票据号 := 票据号_In;
  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Error := '无效的票据领用批次,无法完成重打操作！';
      Close c_Fact;
      Raise Err_Custom;
    End If;
  End If;
  For I In 1 .. 票据张数_In Loop
    If Nvl(领用id_In, 0) <> 0 Then
      --检查票据范围 
      If Not (Upper(v_票据号) >= Upper(r_Factrow.开始号码) And Upper(v_票据号) <= Upper(r_Factrow.终止号码) And
          Length(v_票据号) = Length(r_Factrow.终止号码)) Then
        v_Error := '单据需要打印多张票据,但票据号"' || v_票据号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Custom;
      End If;
    End If;
  
    --发出票据:重打时,如果是部份退费重打,则处理为新发生；如果以前没有收回，也处理为新发出。 
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (票据使用明细_Id.Nextval, 票种_In, v_票据号, 1, Decode(Nvl(退费_In, 0), 0, Decode(v_收回id, Null, 1, 3), 1), 领用id_In, v_打印id,
       使用人_In, 使用时间_In);
  
    Update 票据领用记录
    Set 当前号码 = v_票据号, 剩余数量 = Decode(Sign(Nvl(剩余数量, 0) - 1), -1, 0, Nvl(剩余数量, 0) - 1)
    Where ID = Nvl(领用id_In, 0);
  
    v_票据号 := Zl_Incstr(v_票据号);
  End Loop;
  Update 票据领用记录 Set 使用时间 = 使用时间_In Where ID = 领用id_In;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Reprint;
/

--95543:刘兴洪,2016-05-11,按病人补打发票时不按结算次数打印
Create Or Replace Procedure Zl_Custom_Invoice_Autoallot
(
  操作类型_In       Number,
  模拟计算_In       Number,
  票种_In           票据使用明细.票种%Type,
  领用id_In         票据使用明细.领用id%Type,
  病人id_In         门诊费用记录.病人id%Type,
  Nos_In            Varchar2,
  起始发票号_In     门诊费用记录.实际票号%Type,
  使用人_In         票据使用明细.使用人%Type,
  使用时间_In       票据使用明细.使用时间%Type,
  发票号_In         In Out Varchar2,
  发票张数_In       Out Number,
  按病人补打票据_In Number := 0,
  打印id_In         票据使用明细.打印id%Type := Null,
  Print_Nos_In      t_Strlist := Null
) As
  -------------------------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多有400张单据,格式为:A00001,A00002.....
  --     退费NOs:退费所涉及的单据
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示本次需要回收的票据
  --     打印id_In:按病人补打示据时，传入了相关的打印ID,以外面传入的打印ID为准
  --     按病人补打票据_In：1-表示按病人补打票据,不分结算次数
  --     Print_Nos_in:当前的所涉及的收费单据号，主要是控制超过varchar2的大小限制，主要是按病人补打发票时会出现超长的情况，因此通过集合传入,主要是歉容用，本次打印单据>3000时，Nos_in传入值为空。
  --出参:
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示重打或退费重新发出的票据
  --     发票张数_IN :返回本次收费所需要的发票张数
  -------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_Nos        Varchar2(4000);
  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_当前发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1    门诊费用记录.No%Type;
  n_元素2    门诊费用记录.执行部门id%Type;
  v_元素3    门诊费用记录.收据费目%Type;
  n_元素4    门诊费用记录.收费细目id%Type;
  v_发票信息 Varchar2(4000);
  n_误差项   Number(1);
  n_打印id   票据使用明细.打印id%Type;
  n_使用id   票据使用明细.Id%Type;
  n_返回数   Number(18);
  n_关联序号 Number(18);
  r_单据号   t_Strlist := t_Strlist();
  r_单据序号 t_Strlist := t_Strlist();
  l_使用id   t_Numlist := t_Numlist();
  l_关联序号 t_Numlist := t_Numlist();

  v_打印内容 Varchar2(4000);
  v_Temp     Varchar2(4000);
  Procedure Invoice_Split_Notgroup
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out In Out Varchar2,
    本次发票张数_Out In Out Number,
    Invoce_Out       In Out Ty_Tb_Bill
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号 
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- Invoce_Out:本次返回的发票号与单据的对应关系
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量 
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select NO, 序号 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J Where m.票号 = j.Column_Value) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(Print_Nos) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          Invoce_Out.Extend;
          Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
          Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
          Invoce_Out(Invoce_Out.Count).序号 := Case
                                               When Instr(c_No(I).序号, ',') > 0 Then
                                                Substr(c_No(I).序号, 2)
                                               Else
                                                c_No(I).序号
                                             End;
          Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        Invoce_Out.Extend;
        Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
        Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        Invoce_Out(Invoce_Out.Count).序号 := c_No(I).序号;
        Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;

Begin
  --处理票据数据
  If 票种_In <> 1 Then
    --暂不支持其他,只支持门诊收费
    Return;
  End If;
  v_发票号 := 起始发票号_In;
  v_Nos    := Nos_In;
  -----------------------------------------------------------------------------------------------------------------------------
  --一、获取发票分配的相关规则
  --**开始
  --1.确定是否分单据分配票号,缺省不按单据分号
  n_分单据打印 := 0;
  --2.确定是否按执行科室分单据号,缺省为按1个执行科室分号
  n_执行科室 := 1;

  --3.确定是否按收据费目分单据号,缺省为按3个收据费目分号
  n_收据费目 := 3;

  --4.确定是否按收费细目分单据号,缺省为不按收费细目分号
  n_收费细目 := 0;

  --5.决定是否首页汇总,缺省为不汇总
  n_汇总条件 := 0;

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --**结束
  If Nvl(按病人补打票据_In, 0) <> 0 Then
    --按病人补打票据时，只按收费费目打印
    n_执行科室 := 0;
  End If;

  -----------------------------------------------------------------------------------------------------------------------------
  --二、进行发票分配
  Invoice_Split_Notgroup(Print_Nos_In, 发票号_In, v_发票信息, 发票张数_In, c_Invoce);

  -----------------------------------------------------------------------------------------------------------------------------
  --*****************************************************************************************************************************
  --注意:
  --以下代码，不轻意更改,在上面的代码中需要确定两个变量的值:一是v_发票信息;二是c_Invoce集合中的值
  --  v_发票信息:本次所涉及的发票信息,多个用逗号分离,最好按升序排序
  --  c_Invoce:为集合数据，为发票号和单据的对应关系

  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;
  -----------------------------------------------------------------------------------------------------------------------------
  --四、退费时，需要先处理回收发票
  v_开始发票号 := Null;
  v_当前发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, Decode(操作类型_In, 3, 4, 2), 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无发票数据,则直接返回,退费时，表示只收回票据
    Return;
  End If;

  -----------------------------------------------------------------------------------------------------------------------------
  --五、重新处理发出的票据(含退费重新发出的票据处理)
  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    End If;
  End If;

  --1.实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Or Nvl(按病人补打票据_In, 0) = 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    n_打印id := 打印id_In;
    If Nvl(n_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
    End If;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息)) Order By 发票号) Loop
    --2.检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(c_Invoce_No.发票号) >= Upper(r_Factrow.开始号码) And Upper(c_Invoce_No.发票号) <= Upper(r_Factrow.终止号码) And
          Length(c_Invoce_No.发票号) = Length(r_Factrow.终止号码)) Then
        v_Err_Msg := '该单据需要打印多张票据,但票据号"' || c_Invoce_No.发票号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Item;
      End If;
    End If;
  
    --3.处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
  
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容
            (ID, 数据性质, NO, 打印类型)
          Values
            (n_打印id, 1, r_单据号(I), Decode(Nvl(按病人补打票据_In, 0), 1, 1, 0));
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where Mod(记录性质, 10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO, 打印类型)
          Select n_打印id, 1, Column_Value, Decode(Nvl(按病人补打票据_In, 0), 1, 1, 0) From Table(Print_Nos_In);
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where Mod(记录性质, 10) = 1 And NO In (Select Column_Value From Table(Print_Nos_In));
      End If;
    End If;
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1), Decode(Nvl(领用id_In, 0), 0, Null, 领用id_In), n_打印id,
       使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    v_当前发票号 := c_Invoce_No.发票号;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前发票号, 剩余数量 = Nvl(剩余数量, 0) - 发票张数_In
    Where ID = 领用id_In
    Returning 剩余数量 Into n_返回数;
    If n_返回数 < 0 Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Raise Err_Item;
    End If;
  End If;
  --*****************************************************************************************************************************
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Custom_Invoice_Autoallot;
/

--95543:刘兴洪,2016-05-11,按病人补打发票时不按结算次数打印
Create Or Replace Procedure Zl_Invoice_Autoallot
(
  操作类型_In   Number,
  模拟计算_In   Number,
  票种_In       票据使用明细.票种%Type,
  领用id_In     票据使用明细.领用id%Type,
  病人id_In     门诊费用记录.病人id%Type,
  Nos_In        Varchar2,
  起始发票号_In 门诊费用记录.实际票号%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  发票号_In     In Out Varchar2,
  发票张数_In   Out Number,
  打印id_In     票据使用明细.打印id%Type := 0
) As
  ---------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多;有400张单据,格式为:A00001,A00002.....
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     发票号_In   :可以为多个,当操作类型为3-重打票据时,有效
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --     打印ID_In :打印ID_In<>0时，表示根据临时表"临时票据打印内容"所对应的NO来产生打印数据(主要解决按病人补打发票不分结算次数的情况)
  --出参:
  --     发票张数_IN :返回本次收费所需要的发票张数
  ---------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_Para       Varchar2(1000);
  v_Temp       Varchar2(32767);
  n_启用模式   Number(3);
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  ---------------------------------------------------------
  Type Ty_Rec_Splitno Is Record(
    元素1    票据打印明细.No%Type,
    元素2集  Varchar2(4000),
    元素3集  Varchar2(4000),
    关联序号 Number(18));

  Type Ty_Tb_Splitno Is Table Of Ty_Rec_Splitno;
  c_Split_No   Ty_Tb_Splitno := Ty_Tb_Splitno();
  c_Split_费目 Ty_Tb_Splitno := Ty_Tb_Splitno();

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  --------------------------------------------------------------------------------------------
  --根据相关传入的数据,取对应的数据集

  v_Nos        Varchar2(32767);
  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_当前发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1     门诊费用记录.No%Type;
  n_元素2     门诊费用记录.执行部门id%Type;
  v_元素3     门诊费用记录.收据费目%Type;
  n_元素4     门诊费用记录.收费细目id%Type;
  v_发票信息  Varchar2(4000);
  n_误差项    Number(1);
  n_打印id    票据使用明细.打印id%Type;
  n_使用id    票据使用明细.Id%Type;
  n_返回数    Number(18);
  n_关联序号  Number(18);
  r_单据号    t_Strlist := t_Strlist();
  l_Print_Nos t_Strlist := t_Strlist();
  r_单据序号  t_Strlist := t_Strlist();
  l_使用id    t_Numlist := t_Numlist();
  l_关联序号  t_Numlist := t_Numlist();

  v_打印内容       Varchar2(4000);
  l_元素2          t_Numlist := t_Numlist();
  l_元素3          t_Strlist := t_Strlist();
  v_起始发票号     票据领用记录.开始号码%Type;
  n_按病人补打票据 Number(2);
  n_打印类型       票据打印内容.打印类型%Type;

  -------------------------------------------------------------------------------------------------------------------
  --Invoice_Split_Notgroup:不进行分组汇总或首页汇总时调用此过程
  Procedure Invoice_Split_Notgroup
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号 
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- 本次退费单据_Out-退费回收所涉及的NO号,多个用逗号分离
  
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量 
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select NO, 序号 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J Where m.票号 = j.Column_Value) B
          Where Mod(记录性质, 10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(Print_Nos) B
          Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          c_Invoce.Extend;
          c_Invoce(c_Invoce.Count).票号 := v_发票号;
          c_Invoce(c_Invoce.Count).No := c_No(I).No;
          c_Invoce(c_Invoce.Count).序号 := Case
                                           When Instr(c_No(I).序号, ',') > 0 Then
                                            Substr(c_No(I).序号, 2)
                                           Else
                                            c_No(I).序号
                                         End;
          c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        c_Invoce.Extend;
        c_Invoce(c_Invoce.Count).票号 := v_发票号;
        c_Invoce(c_Invoce.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        c_Invoce(c_Invoce.Count).序号 := c_No(I).序号;
        c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;
  --结束:不进行分组汇总或首页汇总时调用此过程
  -------------------------------------------------------------------------------------------------------------------
  --按组汇总
  Procedure Invoice_Split_Group
  (
    Print_Nos        t_Strlist,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
  Begin
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
  
    c_No.Delete;
    l_元素2.Delete;
  
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --******************************************************************************************************************************
      --退费和重打按发票号处理(开始)  
      --4.收据费目+收费细目
      If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        v_元素3 := '+';
        c_Split_费目.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素3, Count(*) As 个数
                       From c_费用 A
                       Group By 元素3
                       Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
        n_关联序号 := 0;
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                         From c_费用 M
                         Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                         Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                         Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
              n_元素4_Count := 0;
              --分页
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
        n_元素2_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        c_Split_No.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                             
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素1, a.元素2, b.编码, Count(*) As 个数
                       From c_费用 A, 部门表 B
                       Where a.元素2 = b.Id(+)
                       Group By 元素1, b.编码, 元素2
                       Order By 元素1, b.编码, 元素2) Loop
          If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
            c_Split_No.Extend;
            n_元素2_Count := 0;
            v_元素1       := '+';
            n_元素2       := 0;
          End If;
          If (v_元素1 <> c_分页.元素1) Then
            v_元素1 := c_分页.元素1;
            c_Split_No(c_Split_No.Count).元素1 := v_元素1;
          End If;
          If (n_元素2 <> c_分页.元素2) Then
            n_元素2_Count := n_元素2_Count + 1;
            n_元素2 := c_分页.元素2;
            c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
          End If;
        End Loop;
      End If;
    
      --6.(no Or 执行科室)+收费细目
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
      
        For I In 1 .. c_Split_No.Count Loop
          v_元素3 := '+';
          --只有首页汇总的,才有关联序号
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                         Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
          
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --7.(no Or 执行科室)+收据费目+收费细目
      n_关联序号 := 0;
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        c_Split_费目.Delete;
        For I In 1 .. c_Split_No.Count Loop
        
          n_关联序号    := n_关联序号 + 1;
          v_元素3       := '+';
          n_元素3_Count := 0;
          l_元素3.Delete;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          a.元素3, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素3
                         Order By 元素3) Loop
          
            If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
              If v_元素3 <> '+' Then
                c_Split_费目.Extend;
                c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
                c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
                c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
                For J In 1 .. l_元素3.Count Loop
                  --单据号相同,将序号合并
                  c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
                End Loop;
              End If;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
            If (v_元素3 <> c_分页.元素3) Then
              n_元素3_Count := n_元素3_Count + 1;
              v_元素3       := c_分页.元素3;
              l_元素3.Extend;
              l_元素3(l_元素3.Count) := v_元素3;
            End If;
          End Loop;
        
          If l_元素3.Count <> 0 Then
            c_Split_费目.Extend;
            c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
            c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
            c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
          End If;
        End Loop;
      
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where Mod(记录性质, 10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_费目(I).元素1 And
                               Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                               Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                         Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
            If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
        
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --退费和重打按发票号处理(结束)
      --******************************************************************************************************************************
      If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
        本次打印发票_Out := Substr(本次打印发票_Out, 2);
      End If;
      Return;
    
    End If;
  
    --******************************************************************************************************************************
    --以下是按正常分配单据(开始)
    --4.收据费目+收费细目
    If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      v_元素3 := '+';
      c_Split_费目.Delete;
    
      For c_分页 In (With c_费用 As
                      (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                             Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                             Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(Print_Nos) B
                      Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.实收金额, 0)) <> 0)
                     Select /*+ RULE */
                      a.元素3, Count(*) As 个数
                     From c_费用 A
                     Group By 元素3
                     Order By 元素3) Loop
        If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
          If v_元素3 <> '+' Then
            c_Split_费目.Extend;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
        End If;
        If (v_元素3 <> c_分页.元素3) Then
          n_元素3_Count := n_元素3_Count + 1;
          v_元素3       := c_分页.元素3;
          l_元素3.Extend;
          l_元素3(l_元素3.Count) := v_元素3;
        End If;
      End Loop;
      If l_元素3.Count <> 0 Then
        c_Split_费目.Extend;
        For J In 1 .. l_元素3.Count Loop
          --单据号相同,将序号合并
          c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
        End Loop;
      End If;
      n_关联序号 := 0;
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_关联序号    := n_关联序号 + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                       From c_费用 M
                       Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                       Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                       Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
            n_元素4_Count := 0;
            --分页
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
      n_元素2_Count := 0;
      v_元素1       := '+';
      n_元素2       := 0;
      c_Split_No.Delete;
      For c_分页 In (With c_费用 As
                      (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                             Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                             Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(Print_Nos) B
                      Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.实收金额, 0)) <> 0)
                     Select /*+ RULE */
                      a.元素1, a.元素2, b.编码, Count(*) As 个数
                     From c_费用 A, 部门表 B
                     Where a.元素2 = b.Id(+)
                     Group By 元素1, b.编码, 元素2
                     Order By 元素1, b.编码, 元素2) Loop
        If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
          c_Split_No.Extend;
          n_元素2_Count := 0;
          v_元素1       := '+';
          n_元素2       := 0;
        End If;
        If (v_元素1 <> c_分页.元素1) Then
          v_元素1 := c_分页.元素1;
          c_Split_No(c_Split_No.Count).元素1 := v_元素1;
        End If;
        If (n_元素2 <> c_分页.元素2) Then
          n_元素2_Count := n_元素2_Count + 1;
          n_元素2 := c_分页.元素2;
          c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
        End If;
      End Loop;
    End If;
  
    --3.(no Or 执行科室)+收费细目
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
    
      For I In 1 .. c_Split_No.Count Loop
        v_元素3 := '+';
        --只有首页汇总的,才有关联序号
        n_关联序号    := Nvl(n_关联序号, 0) + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                       Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
        
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    --7.(no Or 执行科室)+收据费目+收费细目
    n_关联序号 := 0;
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      c_Split_费目.Delete;
    
      For I In 1 .. c_Split_No.Count Loop
      
        n_关联序号    := n_关联序号 + 1;
        v_元素3       := '+';
        n_元素3_Count := 0;
        l_元素3.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素3, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素3
                       Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
              c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
              c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
            End If;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
      
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
          c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
          c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
      End Loop;
    
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_元素4_Count := 0;
        --收费细目,按条数计数,还是要按执行科室+收据费目
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(Print_Nos) B
                        Where Mod(记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_费目(I).元素1 And
                             Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                             Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                       Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
          If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
    --正常分配单据结束
    --******************************************************************************************************************************
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Group;
  -------------------------------------------------------------------------------------------------------------------
Begin

  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  If Instr(v_Para, '||') = 0 Then
    v_Para := v_Para || '||';
  End If;
  v_Temp := Substr(v_Para, 1, Instr(v_Para, '||') - 1);
  If v_Temp Is Null Then
    --无设置值,代表无启用,直接返回
    Return;
  End If;

  --0-根据实际打印分配票号;1-根据预定规则分配票号;2-.根据自定义规则分配票号
  n_启用模式 := Zl_To_Number(v_Temp);
  If Nvl(n_启用模式, 0) = 0 Then
    --0-根据实际打印分配票号:按原来的处理方式分配票据,直接退出
    Return;
  End If;
  v_Temp       := Nvl(zl_GetSysParameter('误差项不使用票据', 1121), '0');
  n_误差项     := Zl_To_Number(v_Temp);
  v_起始发票号 := 起始发票号_In;

  If v_起始发票号 Is Null Then
    --模拟计算时,可以不传入起始发票号
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
    
      If c_Fact%RowCount <> 0 Then
        If Nvl(r_Factrow.当前号码, '-') <> '-' Then
          v_起始发票号 := Zl_Incstr(r_Factrow.当前号码);
        Else
          v_起始发票号 := r_Factrow.开始号码;
        End If;
      End If;
    End If;
    If v_起始发票号 Is Null Then
      v_起始发票号 := 'J0000001';
    End If;
  End If;

  v_发票号   := v_起始发票号;
  v_发票信息 := Null;

  n_按病人补打票据 := 0;
  n_打印类型       := Null;
  --按单据分配票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
    If 发票号_In Is Null Then
      v_Err_Msg := '未传入指定的回收票据,不允许' || Case
                     When 操作类型_In = 1 Then
                      '重打票据。'
                     Else
                      '补打票据。'
                   End;
      Raise Err_Item;
    End If;
  
    Select 单据号 Bulk Collect
    Into l_Print_Nos
    From (Select Distinct c.No As 单据号
           From 票据打印明细 A, 票据使用明细 B, 票据打印内容 C, Table(f_Str2list(发票号_In)) J
           Where a.使用id = b.Id And b.打印id = c.Id And a.票号 = j.Column_Value
           Order By 单据号);
  
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到指定发票(' || 发票号_In || '所对应的收费单据!';
      Raise Err_Item;
    End If;
  
    Select Max(打印类型)
    Into n_打印类型
    From 票据打印内容 A, Table(l_Print_Nos) B
    Where a.No = b.Column_Value And a.数据性质 = 1;
  
    If Nvl(n_打印类型, 0) = 1 Then
      --一次打印有多次结算的，则表示以前为按病人打印的
      n_按病人补打票据 := 1;
      n_打印类型       := 1;
    End If;
  
  Elsif 打印id_In <> 0 Then
    n_按病人补打票据 := 1;
    n_打印类型       := 1;
    Select 单据号 Bulk Collect
    Into l_Print_Nos
    From (Select Distinct NO As 单据号
           From 临时票据打印内容 A
           Where a.Id = 打印id_In And Nvl(a.性质, 0) = 1
           Order By 单据号);
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到本次需要分配票据的单据信息(打印ID=' || 打印id_In || ')!';
      Raise Err_Item;
    End If;
  
  Else
    Select Column_Value Bulk Collect Into l_Print_Nos From Table(f_Str2list(Nos_In)) J;
    If l_Print_Nos.Count = 0 Then
      v_Err_Msg := '未找到本次需要分配票据的单据信息(单据信息：' || Nvl(Nos_In, '') || ')!';
      Raise Err_Item;
    End If;
  End If;

  v_Nos := Null;
  If n_启用模式 = 2 Then
    If l_Print_Nos.Count < 3000 Then
      --1.只有自定义模式时，才会涉及可能存在用户调整的情况，加入此判断，主要是为了歉容
      --2.以前不可能超过3000张单据，如果超过3000张单据，需要改造对应的票据,主要适用按病人补打票据的情况
      For I In 1 .. l_Print_Nos.Count Loop
        v_Nos := Nvl(v_Nos, '') || ',' || l_Print_Nos(I);
      
      End Loop;
      v_Nos := Substr(v_Nos, 2);
    End If;
  
    --根据自定义规则分配票号,调用:Zl_Custom_Invoice_Autoallot过程
    Zl_Custom_Invoice_Autoallot(操作类型_In, 模拟计算_In, 票种_In, 领用id_In, 病人id_In, v_Nos, 起始发票号_In, 使用人_In, 使用时间_In, 发票号_In,
                                发票张数_In, n_按病人补打票据, 打印id_In, l_Print_Nos);
    Return;
  End If;

  --参数获取:
  --1.根据预定规则分配票号
  --   NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Substr(v_Para, Instr(v_Para, '||') + 2);
  If Instr(v_Para, ';') > 0 Then
    --NO:票据是否按单据进行分别打印,1表示按单据打印;0-不按单据打印
    v_Temp       := Substr(v_Para, 1, Instr(v_Para, ';') - 1);
    n_分单据打印 := Zl_To_Number(v_Temp);
    v_Para       := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_执行科室 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收据费目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收费细目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
  Else
    v_Temp := Nvl(v_Para, '0');
  End If;
  n_汇总条件 := Zl_To_Number(v_Temp);

  If n_按病人补打票据 = 1 Then
    --如果打印ID<>0的情况,如果不等零，表示按病人补打发票，则票据将自动不分单据打印，按执行科室打印及收据细目打印
    n_分单据打印 := 0;
    n_执行科室   := 0;
    n_收费细目   := 0;
  End If;

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --一、首页汇总或不汇总
  If n_汇总条件 <> 2 Then
    Invoice_Split_Notgroup(l_Print_Nos, 发票号_In, v_发票信息, 发票张数_In);
  Else
    --二、分组汇总
    Invoice_Split_Group(l_Print_Nos, 发票号_In, v_发票信息, 发票张数_In);
  End If;
  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;

  v_开始发票号 := Null;
  v_当前发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, Decode(操作类型_In, 3, 4, 2), 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无数据,直接返回
    Return;
  End If;

  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    End If;
  End If;

  --实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Or Nvl(n_按病人补打票据, 0) = 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    n_打印id := 打印id_In;
    If Nvl(n_打印id, 0) = 0 Then
      Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
    End If;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息)) Order By 发票号) Loop
    --检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(c_Invoce_No.发票号) >= Upper(r_Factrow.开始号码) And Upper(c_Invoce_No.发票号) <= Upper(r_Factrow.终止号码) And
          Length(c_Invoce_No.发票号) = Length(r_Factrow.终止号码)) Then
        v_Err_Msg := '该单据需要打印多张票据,但票据号"' || c_Invoce_No.发票号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Item;
      End If;
    End If;
  
    --处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容 (ID, 数据性质, NO, 打印类型) Values (n_打印id, 1, r_单据号(I), n_打印类型);
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where Mod(记录性质, 10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO, 打印类型)
          Select n_打印id, 1, Column_Value, n_打印类型 From Table(l_Print_Nos);
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where Mod(记录性质, 10) = 1 And NO In (Select Column_Value From Table(l_Print_Nos));
      End If;
    End If;
  
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1), Decode(Nvl(领用id_In, 0), 0, Null, 领用id_In), n_打印id,
       使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    v_当前发票号 := c_Invoce_No.发票号;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前发票号, 剩余数量 = Nvl(剩余数量, 0) - 发票张数_In
    Where ID = 领用id_In
    Returning 剩余数量 Into n_返回数;
    If n_返回数 < 0 Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Raise Err_Item;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Invoice_Autoallot;
/

--93914:余伟节,2016-05-04,过程变量长度不够
Create Or Replace Function Zl_Pati_Check_Execute
(
  内容_In         Number,
  病人id_In       病人信息.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  婴儿_In         Number := -1,
  检查离院带药_In Number := 0
) Return Varchar2
--功能：检查病人是否存在未执行完成的内容
  --参数：
  --  内容_IN：1-检查药品和卫材,2-检查其他执行项目,3-检查未发血
  --  婴儿_IN：0=病人，1-N=婴儿，-1=不区分
  --返回：如果存在则返回一定格式的提示信息供程序使用，否则返回空
 As
  v_Text  Varchar2(4000);
  v_Drug  Varchar2(1510);
  v_Stuff Varchar2(1510);
  n_Count Number;
  n_Do    Number;
  n_共享  Number;
  Type t_Bool Is Ref Cursor;
  c_Bool t_Bool;
  v_No   住院费用记录.No%Type;
  v_项目 收费项目目录.名称%Type;
  v_部门 部门表.名称%Type;
  v_扣率 Varchar2(100);
  v_Sql  Varchar2(4000);
  v_Pars Varchar2(4000);
Begin
  If 内容_In = 1 Then
    --以药品收发记录中存在未发药品为准
    For r_Info In (Select Distinct a.No, Decode(a.收费类别, '4', 1, 0) As 卫材, d.名称 项目, c.名称 As 部门, To_Char(b.扣率) As 扣率
                   From 住院费用记录 A, 药品收发记录 B, 部门表 C, 收费项目目录 D
                   Where a.No = b.No And a.Id = b.费用id And a.收费细目id = d.Id And b.库房id + 0 = c.Id(+) And
                         a.收费类别 In ('4', '5', '6', '7') And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And
                         b.审核人 Is Null And a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And
                         (Nvl(a.婴儿费, 0) = 婴儿_In Or 婴儿_In = -1) And Nvl(b.摘要, '大医') <> '拒发') Loop
    
      n_Do := 1;
      If Substr(r_Info.扣率, 2) = '3' Then
        n_Do := 检查离院带药_In;
      End If;
      If n_Do = 1 Then
        If r_Info.卫材 = 0 Then
          If v_Drug Is Not Null Then
            If Instr(Chr(13) || Chr(10) || v_Drug || Chr(13) || Chr(10),
                     Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                      Nvl(r_Info.部门, '[未定药房]') || '未发药' || Chr(13) || Chr(10), 1) = 0 Then
              If Lengthb(v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                         Nvl(r_Info.部门, '[未定药房]') || '未发药') <= 1000 Then
                v_Drug := v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                          Nvl(r_Info.部门, '[未定药房]') || '未发药';
              Else
                v_Drug := v_Drug || Chr(13) || Chr(10) || '... ...';
              End If;
            End If;
          Else
            v_Drug := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定药房]') ||
                      '未发药';
          End If;
        Else
          If v_Stuff Is Not Null Then
            If Instr(Chr(13) || Chr(10) || v_Stuff || Chr(13) || Chr(10),
                     Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                      Nvl(r_Info.部门, '[未定部门]') || '未发放' || Chr(13) || Chr(10), 1) = 0 Then
              If Lengthb(v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                         Nvl(r_Info.部门, '[未定部门]') || '未发放') <= 1000 Then
                v_Stuff := v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                           Nvl(r_Info.部门, '[未定部门]') || '未发放';
              Else
                v_Stuff := v_Stuff || Chr(13) || Chr(10) || '... ...';
              End If;
            End If;
          Else
            v_Stuff := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定部门]') ||
                       '未发放';
          End If;
        End If;
      End If;
    End Loop;
  
    If v_Drug Is Not Null Then
      v_Drug := '存在未发药品：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Drug;
    End If;
    If v_Stuff Is Not Null Then
      v_Stuff := '存在未发放卫材料：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
    End If;
  
    If v_Drug Is Not Null And v_Stuff Is Not Null Then
      v_Text := v_Drug || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
    Elsif v_Drug Is Not Null Then
      v_Text := v_Drug;
    Elsif v_Stuff Is Not Null Then
      v_Text := v_Stuff;
    End If;
  Elsif 内容_In = 2 Then
    --1.医技科室执行的项目,临床会诊
    --2.其他类特殊项目不需管执行
    --3.PACS已报到的(执行过程为">=2-检查中"不作为未执行完成的项目
    n_Count := 1;
    Select Zl_Getsysparameter(234) Into v_Pars From Dual;
    v_Pars := Replace(v_Pars, '|', ',');
    For r_Info In (Select Distinct b.No, c.名称 As 项目, d.名称 As 科室, Decode(Nvl(b.执行状态, 0), 0, '未执行', 3, '正在执行') As 执行状态
                   From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C, 部门表 D
                   Where a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And (Nvl(a.婴儿, 0) = 婴儿_In Or 婴儿_In = -1) And
                         a.Id = b.医嘱id And b.执行状态 In (0, 3) And a.诊疗项目id = c.Id And b.执行部门id + 0 = d.Id And
                         a.诊疗类别 Not In ('4', '5', '6', '7') And Not (a.诊疗类别 In ('F', 'D') And a.相关id Is Not Null) And
                         (d.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or d.撤档时间 Is Null) And
                         Not (a.诊疗类别 = 'D' And Nvl(b.执行过程, 0) >= 2) And
                         (Not (a.诊疗类别 = 'Z' And Nvl(c.操作类型, '0') <> '0') Or a.诊疗类别 = 'Z' And c.操作类型 = '7') And
                         c.Id Not In (Select Column_Value From Table(Cast(f_Num2list(v_Pars) As Zltools.t_Numlist)))) Loop
      If Lengthb(v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                 Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态) > 1000 Then
        v_Text := v_Text || Chr(13) || Chr(10) || '... ...';
        Exit;
      Else
        v_Text := v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                  Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态;
      End If;
    
      n_Count := n_Count + 1;
    End Loop;
  
    v_Text := Substr(v_Text, 3);
  Elsif 内容_In = 3 Then
    v_Text := '';
    v_Drug := '';
    --检查是否安装了血库
    Begin
      Select 1
      Into n_共享
      From Zlsystems
      Where Trunc(编号 / 100) = 22 And 所有者 = Sys_Context('USERENV', 'CURRENT_SCHEMA');
    Exception
      When Others Then
        n_共享 := 0;
    End;
    v_Sql := 'Select Distinct a.No, d.名称 项目, c.名称 As 部门, To_Char(b.扣率) As 扣率';
    v_Sql := v_Sql || ' From 住院费用记录 a, 血液收发记录 b, 部门表 c, 收费项目目录 d';
    v_Sql := v_Sql || ' Where a.Id = b.费用id And a.收费细目id = d.Id And b.库房id + 0 = c.Id(+) And a.收费类别 =:1 And b.单据 = 6';
    v_Sql := v_Sql || '  And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And a.病人id =:2 And Nvl(a.主页id, 0) =:3';
    v_Sql := v_Sql || '  And (Nvl(a.婴儿费, 0) =:4 Or -1 =:5) And Nvl(b.摘要,:6) <>:7';
    --共享安装：进行未发血液的检查
    If n_共享 = 1 Then
      Open c_Bool For v_Sql
        Using 'K', 病人id_In, 主页id_In, 婴儿_In, 婴儿_In, '大医', '拒发';
      Loop
        Fetch c_Bool
          Into v_No, v_项目, v_部门, v_扣率;
        Exit When c_Bool%NotFound;
        n_Do := 1;
        If Substr(v_扣率, 2) = '3' Then
          n_Do := 检查离院带药_In;
        End If;
        If n_Do = 1 Then
          If v_Drug Is Not Null Then
            If Instr(Chr(13) || Chr(10) || v_Drug || Chr(13) || Chr(10),
                     Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                      Nvl(v_部门, '[未定血库]') || '未发血' || Chr(13) || Chr(10), 1) = 0 Then
              If Lengthb(v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                         Nvl(v_部门, '[未定血库]') || '未发血') <= 1000 Then
                v_Drug := v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                          Nvl(v_部门, '[未定血库]') || '未发血';
              Else
                v_Drug := v_Drug || Chr(13) || Chr(10) || '... ...';
              End If;
            End If;
          Else
            v_Drug := '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' || Nvl(v_部门, '[未定血库]') || '未发血';
          End If;
        End If;
      End Loop;
      Close c_Bool;
      If v_Drug Is Not Null Then
        v_Drug := '存在未发放的血液：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Drug;
      End If;
      v_Text := v_Drug;
    End If;
  End If;
  Return v_Text;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Pati_Check_Execute;
/

--88484:余智勇,2016-05-04,付款管理
CREATE OR REPLACE Procedure Zl_付款序号_Update
( 
  Id_In       In Varchar2 := Null, 
  计划序号_In In Varchar2 := Null, --以0,1,2,3方式传入 
  付款序号_In In 付款记录.付款序号%Type := Null, 
  预付款_In   In 付款记录.预付款%Type := 0, 
  发票金额_In In 应付记录.发票金额%Type := 0, 
  本次付款_In In 应付记录.单据金额%Type := 0, 
  发票号_In   In 应付记录.发票号%Type := Null, 
  发票日期_In In 应付记录.发票日期%Type := Null 
) Is 
  Err_Item Exception; 
  v_Err_Msg Varchar2(500); 
  v_No      应付记录.NO%Type; 
 
  n_Invoice  Number(16, 5);
  n_发票金额 Number(16, 5); 
  n_计划金额 Number(16, 5); 
  n_已付金额 Number(16, 5); 
  n_计划序号 Number(18); 
  v_填制人   应付记录.填制人%Type; 
  d_填制日期 Date; 
Begin 
 
  begin 
    select 填制人, 填制日期 into v_填制人, d_填制日期 from 付款记录 where 付款序号 = 付款序号_In and rownum = 1; 
  exception 
    when others then 
      select null, null into v_填制人, d_填制日期 from dual; 
  end; 
 
  If 预付款_In = 1 Then 
 
    Begin 
      Select 金额, NO Into n_发票金额, v_Err_Msg From 付款记录 Where ID = Id_In And Rownum = 1 And 记录状态 = 1; 
    Exception 
      When Others Then 
        n_发票金额 := 0; 
        v_Err_Msg  := ''; 
    End; 
 
    If Round(n_发票金额, 2) <> Round(Nvl(发票金额_In, 0), 2) Then 
      v_Err_Msg := '[ZLSOFT]预付款单号为:' || v_Err_Msg || '的记录已经发生改变，' || Chr(10) || Chr(13) || 
                   '付款单上的金额为:' || LTrim(RTrim(To_Char(发票金额_In, '99999999999999.99'))) || ',更改后的金额为:' || 
                   LTrim(RTrim(To_Char(n_发票金额, '99999999999999.99'))) || ',不能再继续![ZLSOFT]'; 
      Raise Err_Item; 
    End If; 
    --付预付款,不处理其他 
    Update 付款记录 Set 付款序号 = 付款序号_In Where ID = Id_In; 
  Else 
    If 计划序号_In Is Null Then 
      --普通付款 
      n_发票金额 := 0; 
      
      begin
      select sum(发票金额) into n_Invoice from 应付记录 A 
                     Where Exists (Select 1 
                            From 应付记录 
                            Where Nvl(A.系统标识, 4) = Nvl(系统标识, 4) And A.NO = NO And A.记录性质 = 记录性质 And 
                                  Nvl(A.项目id, 0) = Nvl(项目id, 0) And Nvl(A.序号, 0) = Nvl(序号, 0) And 
                                  ID = Id_In) And not 记录性质 in (-1, 2) ;
      exception
        when others then
          n_Invoice := Null;
      end;
      
      For v_单据 In (Select id,发票金额,付款序号,记录状态 --min(id) id, sum(发票金额) 发票金额, max(付款序号) 付款序号 
                     From 应付记录 A 
                     Where Exists (Select 1 
                            From 应付记录 
                            Where Nvl(A.系统标识, 4) = Nvl(系统标识, 4) And A.NO = NO And A.记录性质 = 记录性质 And 
                                  Nvl(A.项目id, 0) = Nvl(项目id, 0) And Nvl(A.序号, 0) = Nvl(序号, 0) And 
                                  ID = Id_In) And not 记录性质 in (-1, 2) 
                    ) Loop 
 
        begin 
          select nvl(sum(计划金额), 0), max(计划序号) into n_已付金额, n_计划序号
          from 应付记录 
          where 记录性质 = 2 and ID = v_单据.ID; --NO = v_单据.NO and 发票号 = v_单据.发票号 ; 
        exception 
          when others then 
            n_已付金额 := 0; 
            n_计划序号 := 0; 
        end; 
 
        n_计划序号 := nvl(n_计划序号, 0) + 1;
 
        --if nvl(v_单据.发票金额, 0) > n_已付金额 + 本次付款_In then
        if nvl(n_Invoice, 0) > n_已付金额 + 本次付款_In then
          --插入分次付款数据 
          if v_单据.记录状态 = 1 or mod(v_单据.记录状态, 3) = 0  then 
            Insert Into 应付记录 
              (ID, 记录性质, 记录状态, NO, 项目id, 序号, 收发ID, 单位id, 库房ID, 品名, 
               规格, 产地, 批号, 计量单位, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 
               填制人, 填制日期, 审核人, 审核日期, 系统标识, 付款标志, 付款序号, 计划序号, 计划金额) 
              Select v_单据.ID, 2, 1, NO, 项目id, 序号, 收发ID, 单位id, 库房ID, 品名, 
                规格, 产地, 批号, 计量单位, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 
                v_填制人, d_填制日期, v_填制人, d_填制日期, 系统标识, 付款标志, 付款序号_In, n_计划序号, 本次付款_In 
              From 应付记录 
              Where ID = v_单据.ID and 付款序号 is null ; 
          end if; 
          --update 应付记录 set 计划金额 = v_单据.发票金额 - n_已付金额 - 本次付款_In where ID = v_单据.ID and 付款序号 is null; 
        else 
          --一次全付款或最后付款完 
          if n_Invoice = 本次付款_In then 
            --一次全付 
            Update 应付记录 
            Set 发票号 = Nvl(发票号_In, 发票号), 发票日期 = Nvl(发票日期_In, 发票日期) 
            Where ID = v_单据.ID and 付款序号 is null and 记录性质 <> 2 and mod(记录状态, 3) <> 2  ; 
            update 应付记录
            set 付款序号 = 付款序号_In
            where ID = v_单据.ID and 付款序号 is null and 记录性质 <> 2;
          else 
            --最后一次付完 
            Update 应付记录 
            Set 付款序号 = 付款序号_In, 发票号 = Nvl(发票号_In, 发票号), 发票日期 = Nvl(发票日期_In, 发票日期), 计划金额 = 本次付款_In 
            Where ID = v_单据.ID and 付款序号 is null and 记录性质 <> 2 and mod(记录状态, 3) <> 2  ; 
          end if; 
        end if; 
 
        n_发票金额 := n_发票金额 + Nvl(v_单据.发票金额, 0); 
 
      End Loop; 
 
      If Round(n_发票金额, 2) <> Round(Nvl(发票金额_In, 0), 2) Then 
        Begin 
          Select 入库单据号 Into v_Err_Msg From 应付记录 Where ID = Id_In And Rownum = 1; 
        Exception 
          When Others Then 
            v_Err_Msg := ''; 
        End; 
        v_Err_Msg := '[ZLSOFT]入库单据号为:' || v_Err_Msg || '的记录已经发生改变，' || Chr(10) || Chr(13) || 
                     '付款单上的金额为:' || LTrim(RTrim(To_Char(发票金额_In, '99999999999999.99'))) || ',更改后的金额为:' || 
                     LTrim(RTrim(To_Char(n_发票金额, '99999999999999.99'))) || ',不能再继续![ZLSOFT]'; 
        Raise Err_Item; 
      End If; 
 
    Else 
 
      --可能存在制定计划后，再进行冲销,所以需判断用户是否需重新制定计划 
      Begin 
        Select Sum(Nvl(计划金额, 0)) Into n_计划金额 From 应付记录 Where ID = Id_In And 记录性质 = -1; 
      Exception 
        When Others Then 
          n_计划金额 := 0; 
      End; 
 
      Begin 
        Select Sum(Nvl(发票金额, 0)), Max(NO) 
        Into n_发票金额, v_No 
        From 应付记录 A 
        Where Exists (Select 1 
               From 应付记录 
               Where Nvl(A.系统标识, 4) = Nvl(系统标识, 4) And A.NO = NO And A.记录性质 = 记录性质 And 
                     Nvl(A.项目id, 0) = Nvl(项目id, 0) And Nvl(A.序号, 0) = Nvl(序号, 0) And ID = Id_In) And 
              记录性质 <> -1; 
      Exception 
        When Others Then 
          n_发票金额 := 0; 
          v_No       := Null; 
      End; 
 
      If n_发票金额 < n_计划金额 Then 
        v_Err_Msg := '[ZLSOFT]单号(' || v_No || '的应付单据所制定的' || Chr(10) || Chr(13) || '计划合计(' || n_计划金额 || 
                     ')超过了' || Chr(10) || Chr(13) || '发票金额(' || n_发票金额 || '),请重新制定付款计划![ZLSOFT]'; 
        Raise Err_Item; 
      End If; 
 
      Begin 
        Select 计划金额, 入库单据号 
        Into n_发票金额, v_Err_Msg 
        From 应付记录 
        Where ID = Id_In And 计划序号 = 计划序号_In; 
      Exception 
        When Others Then 
          n_发票金额 := 0; 
          v_Err_Msg  := ''; 
      End; 
      If Round(n_发票金额, 2) <> Round(Nvl(发票金额_In, 0), 2) Then 
        v_Err_Msg := '[ZLSOFT]计划付款(入库单号为:' || v_Err_Msg || ',计划序号为:' || 计划序号_In || 
                     ')的记录已经发生改变，' || Chr(10) || Chr(13) || '计划付款单上的金额为:' || 
                     LTrim(RTrim(To_Char(发票金额_In, '99999999999999.99'))) || ',更改后的金额为:' || 
                     LTrim(RTrim(To_Char(n_发票金额, '99999999999999.99'))) || ',不能再继续![ZLSOFT]'; 
        Raise Err_Item; 
      End If; 
      --计划付款 
      Update 应付记录 Set 付款序号 = 付款序号_In Where ID = Id_In And 计划序号 = 计划序号_In and 记录性质 = -1; 
      Update 应付记录 Set 计划序号 = 0 Where ID = Id_In And 记录性质 <> -1; 
    End If; 
  End If; 
Exception 
  When Err_Item Then 
    Raise_Application_Error(-20101, v_Err_Msg); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_付款序号_Update;
/

--95676:张德婷,2016-05-03,容量设置中最后一列数据删除的问题
CREATE OR REPLACE Procedure Zl_科室容量设置_Save
(
  科室id_In   In 科室容量设置.科室id%Type,
  科室名称_In In 科室容量设置.科室名称%Type,
  配药批次_In In 科室容量设置.配药批次%Type,
  容量_In In 科室容量设置.容量%Type,
  优先级_In   In number,
  配置中心ID_in 科室容量设置.配置中心ID%type
) Is
Begin
  if 优先级_In =0 then
    delete from 科室容量设置 where 配置中心ID=配置中心ID_in;
  end if;
  
  if 优先级_In>0 then
    Insert Into 科室容量设置
      (科室id, 科室名称, 配药批次,容量,配置中心ID)
    Values
      (科室id_In, 科室名称_In,配药批次_In, 容量_In,配置中心ID_in);
  end if;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_科室容量设置_Save;
/

--88559:马政,2016-05-03,无库存调价处理
--96442:马政,2016-05-19,无库存无金额无差价有可用数量调价报除数为零错误
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  Adjustid    In Number, --调价记录的ID
  Bln定价     In Number := 0, --是否转为定价销售（更新2004-06-08、收费细目中的变价）
  Billinfo_In In Varchar2 := Null, --用于时价药品按批次调价。格式:"批次1,现价1|批次2,现价2|....."
  药品id_In   In Number := 0 --当不为0时表示是成本价调价，不处理售价相关内容
) As
  Classid      Number(18); --入出类别
  v_Billno     药品收发记录.No%Type; --调价单号
  Rundate      Date; --调价生效时间
  Blnrun       Number(1); --调价时刻到了
  Blncurprice  Number(1); --时价药品
  Lng细目id    Number(18); --收费细目ID
  Adjustdate   Date; --调价时间
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_序号       Number(8);
  n_原价id     收费价目.原价id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_变动原因   收费价目.变动原因%Type;

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, Rownum 序号, Classid 入出类别id, m.Id As 药品id, s.批次, Null 批号, Null 效期, s.上次产地 As 产地, 1 付数,
           s.上次供应商id As 供应商id, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率, '药品调价' 摘要, Zl_Username 填制人,
           Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(m.是否变价, 0) As 时价, s.实际金额 As 库存金额, s.实际差价 As 库存差价,
           Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 收费项目目录 M, 收费价目 A
    Where s.药品id = m.Id And m.Id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And a.执行日期 <= Sysdate;

  v_Data c_Price%RowType;

  Cursor c_时价按批次调价 --时价药品按批次调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, n_序号 + Rownum 序号, Classid 入出类别id, m.药品id 药品id, s.批次 批次, Null 批号, Null 效期,
           s.上次产地 As 产地, s.上次供应商id As 供应商id, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '药品调价' 摘要, Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价,
           s.实际金额 As 库存金额, s.实际差价 As 库存差价, Nvl(s.零售价, Decode(Nvl(s.实际数量, 0), 0, a.原价, Nvl(s.实际金额, 0) / s.实际数量)) As 原售价
    From 药品库存 S, 药品目录 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = b.Id And s.药品id = m.药品id And m.药品id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;

  v_时价按批次调价 c_时价按批次调价%RowType;
Begin
  If 药品id_In <> 0 Then
    --成本价调价
    Zl_药品收发记录_成本价调价(药品id_In);
  Else
    n_变动原因 := 0;
    --取调价记录生效日期
    Select 收费细目id, 执行日期, 收入项目id Into Lng细目id, Rundate, n_收入项目id From 收费价目 Where ID = Adjustid;
  
    If Sysdate >= Rundate Then
      Blnrun := 1;
    Else
      Blnrun := 0;
    End If;
  
    If Blnrun = 1 Then
      --取入出类别ID
      Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;
    
      --取序列
      Select Nextno(147) Into v_Billno From Dual;
    
      --取该药品是否是时价药品
      Select Nvl(是否变价, 0) Into Blncurprice From 收费项目目录 Where ID = Lng细目id;
    
      --检查是否存在原价和现价相同的情况，相同时不执行调售价功能，并且删除这条收费价目记录，恢复原来的收费价目
      Begin
        Select 原价id Into n_原价id From 收费价目 Where ID = Adjustid And 原价 = 现价 And 原价id Is Not Null;
      Exception
        When Others Then
          n_原价id := 0;
      End;
    
      If n_原价id > 0 Then
        --如果现价=原价，这种情况下是单独调整收入项目，更新收入项目ID，删除调价记录
        Delete 收费价目 Where ID = Adjustid;
        Update 收费价目
        Set 收入项目id = n_收入项目id, 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
        Where ID = n_原价id;
      Else
        Adjustdate := Sysdate;
      
        Begin
          Select 变动原因 Into n_变动原因 From 收费价目 Where ID = Adjustid And 变动原因 = 1;
        Exception
          When Others Then
            n_变动原因 := 0;
        End;
        If n_变动原因 = 0 Then
          If Billinfo_In = '' Or Billinfo_In Is Null Then
            For v_Data In c_Price Loop
              Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              If Nvl(v_Data.填写数量, 0) = 0 And (Nvl(v_Data.库存金额, 0) <> 0 Or Nvl(v_Data.库存差价, 0) <> 0) Then
                --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据            
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                   填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, v_Data.摘要,
                   v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate, v_Data.库存金额,
                   v_Data.库存差价, v_Data.供应商id);
              
                --更新库存零售价,只有时价分批药品才能更新零售价字段
                Zl_药品库存_Update(n_收发id);
              Else
                If Blncurprice = 1 Then
                  n_零售价 := v_Data.原售价;
                Else
                  n_零售价 := v_Data.成本价;
                End If;
                n_零售金额 := Round((v_Data.零售价 - n_零售价) * v_Data.填写数量, 2);
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
                   填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量,
                   Decode(Blncurprice, 1, v_Data.原售价, v_Data.成本价), v_Data.成本金额, v_Data.零售价, v_Data.扣率, n_零售金额, n_零售金额,
                   v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id, Zl_Username, Adjustdate,
                   v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新药品库存
                Zl_药品库存_Update(n_收发id);
              End If;
            End Loop;
          Else
            n_序号 := 0;
            --时价药品按批次调价
            v_Infotmp := Billinfo_In || '|';
            While v_Infotmp Is Not Null Loop
              --分解单据ID串
              v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
              n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
              n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
              v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
            
              For v_时价按批次调价 In c_时价按批次调价 Loop
                If v_时价按批次调价.填写数量 <> 0 Then
                  n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
                Else
                  n_原价 := v_时价按批次调价.成本价;
                End If;
              
                Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              
                If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
                  --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据              
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                     填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数,
                     v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存零售价,只有时价分批药品才能更新零售价字段
                  Zl_药品库存_Update(n_收发id);
                Else
                  If Blncurprice = 1 Then
                    n_零售价 := v_时价按批次调价.原售价;
                  Else
                    n_零售价 := v_时价按批次调价.成本价;
                  End If;
                  n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价,
                     摘要, 填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, Decode(Blncurprice, 1, v_时价按批次调价.原售价, v_时价按批次调价.成本价), v_时价按批次调价.成本金额, v_时价按批次调价.零售价,
                     v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id,
                     v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username, Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价,
                     v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存
                  Zl_药品库存_Update(n_收发id);
                End If;
              End Loop;
            End Loop;
          End If;
        
          Update 收费价目 Set 变动原因 = 1 Where ID = Adjustid;
        
          --更新药品目录、收费细目中的变价
          If Bln定价 = 1 Then
            Update 收费项目目录 Set 是否变价 = 0 Where ID = Lng细目id;
            Update 收费细目 Set 是否变价 = 0 Where ID = Lng细目id;
          End If;
        End If;
      End If;
    
      If n_变动原因 = 0 Then
        --成本价调价
        Zl_药品收发记录_成本价调价(Lng细目id, Rundate);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/


--95512:许华峰,2016-04-29,排队优先
Create Or Replace Procedure Zl_排队叫号队列_优先
(
  队列名称_In 排队叫号队列.队列名称%Type,
  业务id_In   排队叫号队列.业务id%Type,
  优先原因_In 排队叫号队列.备注%Type,
  需插队id_In 排队叫号队列.Id%Type := Null, --需要插队的数据ID 可选参数 
  被插队id_In 排队叫号队列.Id%Type := Null --被插队的数据ID    可选参数 
) Is

  d_被插队时间 排队叫号队列.排队时间%Type;

Begin
  If 需插队id_In Is Not Null Or 被插队id_In Is Not Null Then
    Select 排队时间 Into d_被插队时间 From 排队叫号队列 Where ID = 被插队id_In;
  
    --小于被插队时间的排队时间全部减1秒钟 
    Update 排队叫号队列
    Set 排队时间 = 排队时间 - (1 / 60 / 24 / 60)
    Where 排队时间 < d_被插队时间 And 队列名称 = 队列名称_In And 优先 = 0;
    --再修改需插队的时间为 被插队的时间减1秒，这样保证了需插队的数据始终在被插队的前面 
    Update 排队叫号队列
    Set 排队时间 = d_被插队时间 - (1 / 60 / 24 / 60)
    Where ID = 需插队id_In And 队列名称 = 队列名称_In And 优先 = 0;
  End If;
  --填写原因 
  Update 排队叫号队列 Set 备注 = 优先原因_In, 优先 = 1 Where 队列名称 = 队列名称_In And 业务id = 业务id_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队叫号队列_优先;
/

--95561:马政,2016-04-27,高值卫材外购审核后自动移库单无售价改进
Create Or Replace Procedure Zl_材料外购_Verify
(
  No_In       In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_单位id      药品收发记录.供药单位id%Type;
  n_发票金额    应付记录.发票金额%Type;
  n_库存金额    药品库存.实际金额%Type;
  n_库存差价    药品库存.实际差价%Type;
  n_库存数量    药品库存.实际数量%Type;
  n_实价卫材    收费项目目录.是否变价%Type;
  n_Batch_Count Integer; --原不分批现在分批的材料的数量
  v_条码前缀    Varchar2(20);
  v_内部条码    药品库存.内部条码%Type;
  v_移库no      药品收发记录.No%Type;
  v_对方库房id  药品收发记录.库房id%Type := 0;
  v_入类别id    药品收发记录.入出类别id%Type := 0;
  v_出类别id    药品收发记录.入出类别id%Type := 0;
  n_平均成本价  药品库存.平均成本价%Type;
  n_可用数量    药品收发记录.实际数量%Type;
Begin
  v_条码前缀 := Nvl(zl_GetSysParameter(159), '');

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核或删除，不能进行审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --原分批现不分批的材料,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 材料特性 B
         Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.库房分批, 0) = 0 Or
               (Nvl(b.在用分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室')))));

  For v_收发 In (Select a.Id, a.实际数量, a.发药方式, a.零售价, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期,
                      a.灭菌效期, a.生产日期, a.产地, a.入出类别id, a.注册证号, a.扣率, a.商品条码, a.内部条码, Nvl(b.是否条码管理, 0) As 条码管理, a.批准文号,
                      Nvl(a.费用id, 0) As 费用id
               From 药品收发记录 A, 材料特性 B
               Where a.药品id = b.材料id And a.No = No_In And a.单据 = 15 And a.记录状态 = 1
               Order By a.药品id) Loop
    v_内部条码 := Null;
    If v_收发.条码管理 = 1 Then
      If v_收发.内部条码 Is Null Then
        If Not v_条码前缀 Is Null Then
          v_内部条码 := v_条码前缀 || Nextno(126);
        Else
          v_内部条码 := Nextno(126);
        End If;
      Else
        v_内部条码 := v_收发.内部条码;
      End If;
    End If;
  
    --更改材料库存表的相应数据
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_收发.药品id;
  
    If v_收发.费用id = 2 Then
      n_可用数量 := Nvl(v_收发.实际数量, 0);
    Else
      If v_收发.发药方式 = 1 Then
        n_可用数量 := 0;
      Else
        n_可用数量 := Nvl(v_收发.实际数量, 0);
      End If;
    End If;
  
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + Nvl(v_收发.实际数量, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(v_收发.零售金额, 0),
        实际差价 = Nvl(实际差价, 0) + Nvl(v_收发.差价, 0), 上次供应商id = Nvl(v_收发.供药单位id, 上次供应商id), 上次采购价 = Nvl(v_收发.成本价, 上次采购价),
        上次批号 = Nvl(v_收发.批号, 上次批号), 上次产地 = Nvl(v_收发.产地, 上次产地), 灭菌效期 = Nvl(v_收发.灭菌效期, 灭菌效期),
        上次生产日期 = Nvl(v_收发.生产日期, 上次生产日期), 效期 = Nvl(v_收发.效期, 效期),
        零售价 = Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)), 上次扣率 = Nvl(v_收发.扣率, 上次扣率),
        商品条码 = v_收发.商品条码, 内部条码 = v_内部条码, 批准文号 = v_收发.批准文号
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 效期, 零售价, 上次扣率, 商品条码,
         内部条码, 平均成本价, 批准文号)
      Values
        (v_收发.库房id, v_收发.药品id, v_收发.批次, 1, n_可用数量, v_收发.实际数量, v_收发.零售金额, v_收发.差价, v_收发.供药单位id, v_收发.成本价, v_收发.批号,
         v_收发.生产日期, v_收发.产地, v_收发.灭菌效期, v_收发.效期, Decode(Nvl(v_收发.批次, 0), 0, Null, Decode(n_实价卫材, 1, v_收发.零售价, Null)),
         v_收发.扣率, v_收发.商品条码, v_内部条码, v_收发.成本价, v_收发.批准文号);
    End If;
  
    If v_收发.内部条码 Is Null And Not v_内部条码 Is Null Then
      Update 药品收发记录 Set 内部条码 = v_内部条码 Where ID = v_收发.Id;
    End If;
  
    --清除数量金额为零的记录
    Delete From 药品库存
    Where 库房id = v_收发.库房id And 药品id = v_收发.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --更改材料收发汇总表的相应数据
    --更新该材料的成本价
    Begin
      Select Sum(Nvl(实际金额, 0)), Sum(Nvl(实际差价, 0)), Sum(Nvl(实际数量, 0))
      Into n_库存金额, n_库存差价, n_库存数量
      From 药品库存
      Where 性质 = 1 And 药品id = v_收发.药品id;
    Exception
      When Others Then
        n_库存数量 := 0;
    End;
  
    --更新该药品的成本价
    Update 材料特性
    Set 成本价 = v_收发.成本价, 上次售价 = v_收发.零售价, 上次供应商id = v_收发.供药单位id, 上次产地 = v_收发.产地
    Where 材料id = v_收发.药品id;
  
    --更改材料特性中的注册证号:如果发现材料特性表中的注册证号没填，则直接反写给材料特性表中的注册证号
    If Nvl(v_收发.注册证号, ' ') <> ' ' Then
      Update 材料特性 Set 注册证号 = v_收发.注册证号 Where 材料id = v_收发.药品id And 注册证号 Is Null;
    End If;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 药品id = v_收发.药品id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 库房id = v_收发.库房id And 性质 = 1 And Nvl(实际数量, 0) <> 0;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_收发.药品id;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 药品id = v_收发.药品id And 库房id = v_收发.库房id And Nvl(批次, 0) = Nvl(v_收发.批次, 0) And 性质 = 1;
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = No_In And 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into n_单位id, n_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = No_In And a.单据 = 15 And b.系统标识 = 5
    Group By b.单位id;
  
    If Nvl(n_单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(n_发票金额, 0) Where 单位id = n_单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (n_单位id, 1, n_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;

  --如果是自动产生的备货卫材入库单，则产生移库单
  For v_Data In (Select ID, 序号, 实际数量, 发药方式, 零售价, 零售金额, 差价, 库房id, 药品id, 批次, 供药单位id, 成本价, 成本金额, 批号, 效期, 灭菌效期, 生产日期, 产地,
                        入出类别id, 注册证号, 扣率, 摘要, 商品条码, 内部条码, 费用id, 审核人, 审核日期
                 From 药品收发记录
                 Where NO = No_In And 单据 = 15 And 记录状态 = 1 And 审核日期 Is Not Null And 费用id > 0
                 Order By 序号) Loop
    If v_对方库房id = 0 Then
      Begin
        Select Distinct 库房id Into v_对方库房id From 药品收发记录 Where 单据 In (24, 25) And 费用id = v_Data.费用id;
      Exception
        When Others Then
          v_对方库房id := 0;
      End;
    End If;
  
    If v_对方库房id > 0 Then
      If v_移库no Is Null Then
        v_移库no := Nextno(72, v_Data.库房id);
      End If;
    
      Zl_材料移库_Insert(v_移库no, v_Data.序号 * 2 - 1, v_Data.库房id, v_对方库房id, v_Data.药品id, v_Data.批次, v_Data.实际数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售价, v_Data.零售金额, v_Data.差价, v_Data.审核人, v_Data.产地, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.摘要, v_Data.审核日期);
    End If;
  End Loop;

  --对新产生的移库单进行备料和审核
  If Not v_移库no Is Null Then
    Zl_材料移库_Prepare(v_移库no, 审核人_In);
    Zl_材料移库_Prepare(v_移库no);
  
    Select b.Id As 类别id
    Into v_入类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = 1 And Rownum < 2;
  
    Select b.Id As 类别id
    Into v_出类别id
    From 药品单据性质 A, 药品入出类别 B
    Where a.类别id = b.Id And a.单据 = 34 And 系数 = -1 And Rownum < 2;
  
    For v_Data In (Select 序号, 库房id, 对方部门id, 药品id, 产地, Nvl(批次, 0) As 批次, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, NO, 填制人, 批号,
                          效期, 灭菌效期, 填制日期
                   From 药品收发记录
                   Where 单据 = 19 And NO = v_移库no And 审核日期 Is Null And 入出系数 = -1
                   Order By 序号) Loop
    
      Zl_材料移库_Verify(v_Data.序号, v_Data.库房id, v_Data.对方部门id, v_Data.药品id, v_Data.产地, v_Data.批次, v_Data.填写数量, v_Data.实际数量,
                     v_Data.成本价, v_Data.成本金额, v_Data.零售金额, v_Data.差价, v_出类别id, v_入类别id, v_Data.No, v_Data.填制人, v_Data.批号,
                     v_Data.效期, v_Data.灭菌效期, v_Data.填制日期, 1, v_Data.零售价);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Verify;
/

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
--95453:梁唐彬,2016-04-26,护理等级和医师调整并发导致变动记录错误
CREATE OR REPLACE Procedure Zl_病人变动记录_Nurse
( 
  病人id_In     病案主页.病人id%Type, 
  主页id_In     病案主页.主页id%Type, 
  护理id_In     病人变动记录.护理等级id%Type, 
  生效时间_In   病人变动记录.开始时间%Type, 
  操作员编号_In 病人变动记录.操作员编号%Type, 
  操作员姓名_In 病人变动记录.操作员姓名%Type 
) As 
  ----------------------------------------------------------- 
  --说明：更改病人护理等级 
  ----------------------------------------------------------- 
  Cursor c_Oldinfo Is 
        Select b.* 
    From (Select c.* 
           From 病人变动记录 C 
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And 
                 c.开始时间 = (Select Min(开始时间) From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 生效时间_In)) A, 病人变动记录 B 
 
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位 
    Union 
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 生效时间_In; 
 
  Cursor c_Endinfo Is 
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null; 
  r_Oldinfo c_Oldinfo%RowType; 
  r_Endinfo c_Endinfo%RowType; 
 
  v_终止原因 病人变动记录.终止原因%Type; 
  v_终止时间 病人变动记录.终止时间%Type; 
  v_终止人员 病人变动记录.终止人员%Type; 
  v_Count   Number; 
  v_Date Date; 
  v_Error   Varchar2(255); 
  Err_Custom Exception; 
Begin 
  Open c_Oldinfo; --必须先打开 
  Fetch c_Oldinfo 
    Into r_Oldinfo; 
  Open c_Endinfo; 
  Fetch c_Endinfo 
    Into r_Endinfo; 
  If c_Endinfo%RowCount = 0 Then 
    Close c_Endinfo; 
    v_Error := '未发现该病人当前有效的变动记录！'; 
    Raise Err_Custom; 
  End If; 
  Select Count(*) Into v_count From 病人变动记录 Where 病人ID=病人ID_in And 主页ID=主页id_In And 开始时间 Is null And 终止时间 Is Null; 
  If v_count > 0 Then 
    v_Error := '该病人正在转科或转病区，不能进行其他变动！'; 
    Raise Err_Custom; 
  End If; 
  
  For r_Fee In (Select No 
                From 住院费用记录 
                Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= 生效时间_In And 收费类别 = 'H' 
                Group By NO, 序号, Mod(记录性质, 10) 
                Having Sum(结帐金额) <> 0) Loop 
    v_Error := '变动时间之后已有已结帐的自动记帐费用,不能更改护理等级！'; 
    Raise Err_Custom; 
  End Loop; 
 
  --取消上次变动 
  If r_Oldinfo.终止时间 Is not NULL then 
    --如果将来已经有了护理记录变动，则不允许再产生护理变动。需要回退将来的变动的解决。 
    Select Max(开始时间) Into v_Date From 病人变动记录 Where 病人ID=病人ID_in And 主页ID=主页id_In And 开始时间>生效时间_In And 开始原因=6; 
    If v_Date Is Not Null Then 
      v_Error := '本次护理等级变动时间必须大于最后一次护理等级变动的生效时间:' || To_char(v_Date,'yyyy-mm-dd hh24:mi:ss') || '。'; 
      Raise Err_Custom; 
    End If; 
    v_终止时间:=r_Oldinfo.终止时间; 
    v_终止原因:=r_Oldinfo.终止原因; 
    v_终止人员:=r_Oldinfo.终止人员; 
    --取消上次变动 
    Update 病人变动记录 
    Set 终止时间 = 生效时间_In, 终止原因 = 6, 终止人员 = 操作员姓名_In ,上次计算时间 = Null 
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因=v_终止原因; 
    --更新将来的记录如果有停止到将来的则删除上次计算时间 
    Update 病人变动记录 Set 护理等级id=护理id_In,上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间>生效时间_In; 
  Else 
    Update 病人变动记录 
    Set 终止时间 = 生效时间_In, 终止原因 = 6, 终止人员 = 操作员姓名_In,
        上次计算时间 = Decode(Sign(Nvl(上次计算时间, 生效时间_In) - 生效时间_In), 1, Null, 上次计算时间) 
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null; 
  End If; 
  --产生新变动 
  While c_Oldinfo%Found Loop 
    Insert Into 病人变动记录 
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,终止时间,终止原因,终止人员) 
    Values 
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 生效时间_In, 6, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id, r_Oldinfo.医疗小组id, 护理id_In, 
       r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 
       操作员编号_In, 操作员姓名_In,v_终止时间,v_终止原因,v_终止人员); 
    Fetch c_Oldinfo 
      Into r_Oldinfo; 
  End Loop; 
 
  Close c_Oldinfo; 
  Close c_Endinfo; 
 
  Update 病案主页 Set 护理等级id = 护理id_In Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null; 
 
  --并发操作检查 
  Select Count(*) 
  Into v_Count 
  From 病人变动记录 
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null; 
  If v_Count > 1 Then 
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！'; 
    Raise Err_Custom; 
  End If; 
 
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null; 
  If v_Count = 0 Then 
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！'; 
    Raise Err_Custom; 
  End If; 
 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人变动记录_Nurse;
/

--95362:刘尔旋,2016-04-21,医生站划价收费推送消息问题
Create Or Replace Procedure Zl_三方接口更新_Update
(
  卡类别id_In   病人预交记录.卡类别id%Type,
  消费卡_In     Number,
  卡号_In       病人预交记录.卡号%Type,
  结帐ids_In    Varchar2,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  预交款缴款_In Number := 0,
  退费标志_In   Number := 0,
  校对标志_In   Number := Null,
  发送标志_In   Number := 0
) As
  --功能：用于交易流水号,交易说明等信息
  --参数：
  --        消费卡_IN:1-消费卡结算;0-医疗卡结算
  --        卡类别ID_In:消费卡时为接口编号;医疗卡类别.ID
  --        结帐IDs_In:以逗号分离(如果是预交款缴款,则传入的是预交ID)
  --        预交款缴款_In:1-代表预交款缴款;0-代表消费扣款
  --        退费标志_IN:1-进行退费处理;0-支付处理
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_名称     Varchar2(100);
  n_消费卡id 消费卡目录.Id%Type;
  n_自制卡   卡消费接口目录.自制卡%Type;
  v_结算方式 卡消费接口目录.结算方式%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
Begin

  If Nvl(消费卡_In, 0) = 1 Then
    Begin
      Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
    Exception
      When Others Then
        v_名称 := Null;
    End;
  
    If v_名称 Is Null Then
      v_Err_Msg := '[ZLSOFT]未找到对应的结算卡接口,不能' || Case
                     When 预交款缴款_In = 1 Then
                      '缴预交'
                     Else
                      '刷卡消费'
                   End || '![ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(n_自制卡, 0) = 1 Then
      --消费卡结算.求出消费卡的ID
      Begin
        Select ID
        Into n_消费卡id
        From 消费卡目录 A
        Where a.卡号 = 卡号_In And a.接口编号 = 卡类别id_In And
              序号 = (Select Max(序号) From 消费卡目录 B Where 卡号 = a.卡号 And 接口编号 = a.接口编号);
      Exception
        When Others Then
          n_消费卡id := -1;
      End;
      If n_消费卡id = -1 Then
        v_Err_Msg := '[ZLSOFT]卡号为' || 卡号_In || '的' || v_名称 || '未找到,不能' || Case
                       When 预交款缴款_In = 1 Then
                        '缴预交'
                       Else
                        '刷卡消费'
                     End || '![ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
    If 退费标志_In = 0 Then
      Begin
        Select Nvl(Max(Nvl(序号, 0)), 0) + 1
        Into n_序号
        From 病人卡结算记录
        Where 接口编号 = 卡类别id_In And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = 卡号_In;
      Exception
        When Others Then
          n_序号 := 1;
      End;
    End If;
    If 预交款缴款_In = 0 Then
      For c_预交 In (Select /*+ rule */
                    ID, 冲预交 As 金额
                   From 病人预交记录
                   Where 结算卡序号 = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                         结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J)) Loop
      
        Update 病人预交记录
        Set 交易流水号 = Decode(Sign(Nvl(n_消费卡id, 0)), 1, n_消费卡id, 交易流水号_In), 交易说明 = 交易说明_In, 校对标志 = 校对标志_In,
            卡号 = Nvl(卡号, 卡号_In)
        Where ID = c_预交.Id;
        If Nvl(退费标志_In, 0) = 0 Then
          --退费在调用该过程之间处理了的
          --处理消费卡结算信息
          Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          Insert Into 病人卡结算记录
            (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
          Values
            (n_Id, 卡类别id_In, n_消费卡id, n_序号, 1, v_结算方式, Nvl(c_预交.金额, 0), 卡号_In, 交易流水号_In, Sysdate, Null, 0);
          --如果消费卡,需同时更改其余额
          If Nvl(n_消费卡id, 0) <> 0 Then
            Update 消费卡目录 Set 余额 = 余额 - Nvl(c_预交.金额, 0) Where ID = n_消费卡id;
          End If;
          Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (c_预交.Id, n_Id);
          n_序号 := n_序号 + 1;
        End If;
      End Loop;
    
    Else
      For c_预交 In (Select /*+ rule */
                    ID, 金额
                   From 病人预交记录
                   Where 结算卡序号 = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                         ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J)) Loop
      
        Update 病人预交记录
        Set 交易流水号 = Decode(Sign(Nvl(n_消费卡id, 0)), 1, n_消费卡id, 交易流水号_In), 交易说明 = 交易说明_In, 校对标志 = 0, 卡号 = Nvl(卡号, 卡号_In)
        Where ID = c_预交.Id;
      
        If Nvl(退费标志_In, 0) = 0 Then
          --退费在调用该过程之间处理了的
          --处理消费卡结算信息
          Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          Insert Into 病人卡结算记录
            (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
          Values
            (n_Id, 卡类别id_In, n_消费卡id, n_序号, 1, v_结算方式, Nvl(c_预交.金额, 0), 卡号_In, 交易流水号_In, Sysdate, Null, 0);
          --如果消费卡,需同时更改其余额
          If Nvl(n_消费卡id, 0) <> 0 Then
            Update 消费卡目录 Set 余额 = 余额 - Nvl(c_预交.金额, 0) Where ID = n_消费卡id;
          End If;
          Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (c_预交.Id, n_Id);
          n_序号 := n_序号 + 1;
        End If;
      End Loop;
    End If;
  
  Else
    Begin
      Select 名称 Into v_名称 From 医疗卡类别 Where ID = 卡类别id_In;
    Exception
      When Others Then
        v_名称 := Null;
    End;
    If v_名称 Is Null Then
      v_Err_Msg := '[ZLSOFT]未找到对应的医疗卡接口,不能缴预交![ZLSOFT]';
      Raise Err_Item;
    End If;
    If 预交款缴款_In = 0 Then
      Update 病人预交记录
      Set 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In, 校对标志 = 校对标志_In, 卡号 = Nvl(卡号, 卡号_In)
      Where 卡类别id = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
            结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J) And
            Mod(记录性质, 10) <> 1;
    Else
      Update 病人预交记录
      Set 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In, 校对标志 = 校对标志_In, 卡号 = Nvl(卡号, 卡号_In)
      Where 卡类别id = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
            ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
    End If;
  End If;

  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]警告:' || Chr(13) || Chr(10) || '    ' || v_名称 ||
                 '结算成功,但更新HIS数据时出错,请立即与管理联系处理和核查这部分数据(可以采用手工方式正常录入)![ZLSOFT]';
    Raise Err_Item;
  End If;
  If 预交款缴款_In = 0 And 发送标志_In = 1 Then
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 4, 结帐ids_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方接口更新_Update;
/

--93317:李小东,2016-02-18,药品卫材验收结论处理
Create Or Replace Procedure Zl_药品验收明细_Insert
(
  验收id_In   In 药品验收明细.验收id%Type,
  药品id_In   In 药品验收明细.药品id%Type,
  成本价_In   In 药品验收明细.成本价%Type := Null,
  零售价_In   In 药品验收明细.零售价%Type := Null,
  进药数量_In In 药品验收明细.进药数量%Type := Null,
  批号_In     In 药品验收明细.批号%Type := Null,
  生产日期_In In 药品验收明细.生产日期%Type := Null,
  效期_In     In 药品验收明细.效期%Type := Null,
  产地_In     In 药品验收明细.产地%Type := Null,
  批准文号_In In 药品验收明细.批准文号%Type := Null,
  进药日期_In In 药品验收明细.进药日期%Type := Null,
  是否合格_In In 药品验收明细.是否合格%Type := 0,
  验收结论_In In 药品验收明细.验收结论%Type := Null
) Is
Begin
  Insert Into 药品验收明细
    (验收id, 药品id, 成本价, 零售价, 进药数量, 批号, 生产日期, 效期, 产地, 批准文号, 进药日期, 是否合格, 验收结论)
  Values
    (验收id_In, 药品id_In, 成本价_In, 零售价_In, 进药数量_In, 批号_In, 生产日期_In, 效期_In, 产地_In, 批准文号_In, 进药日期_In, 是否合格_In, 验收结论_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--93317:李小东,2016-02-18,药品卫材验收结论处理
Create Or Replace Procedure Zl_药品外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  外观_In       In 药品收发记录.外观%Type := Null,
  产品合格证_In In 药品收发记录.产品合格证%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  金额差_In     In 药品收发记录.零售金额%Type := Null,
  加成率_In     In 药品收发记录.频次%Type := Null,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  计划id_In     In 药品收发记录.计划id%Type := Null,
  财务审核_In   In Number := 0,
  验收结论_In   In 药品收发记录.验收结论%Type := Null
) Is
  v_No         应付记录.No%Type; --应付记录的NO
  v_商品名     收费项目目录.名称%Type; --通用名称
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID
  v_应付id     应付记录.Id%Type; --应付记录的ID
  v_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID
  v_入出系数   药品收发记录.入出系数%Type; --入出系数
  v_批次       药品收发记录.批次%Type := Null; --批次
  v_药库分批   Integer; --是否药库分批    1:分批；0：不分批
  v_药房分批   Integer; --是否药房分批       1:分批；0：不分批
  v_指导批价   药品规格.指导批发价%Type;
  v_时价分批   Number(1);

  Err_Msg Varchar2(255);
  Err_Noenough Exception;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 药品id_In And 厂家名称 = 产地_In;
  End If;
  If Sql%RowCount = 0 And Not 产地_In Is Null And Not 批准文号_In Is Null Then
    Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (药品id_In, 产地_In, 批准文号_In);
  End If;

  --取该药品的商品名
  v_产地 := '';
  Select 名称, 规格, 计算单位, Nvl(是否变价, 0)
  Into v_商品名, v_规格, v_单位, v_时价分批
  From 收费项目目录
  Where ID = 药品id_In;
  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
  Select Nvl(药库分批, 0), Nvl(药房分批, 0), Nvl(指导批发价, 0)
  Into v_药库分批, v_药房分批, v_指导批价
  From 药品规格
  Where 药品id = 药品id_In;

  --财务审核_in=0表示普通入库，财务审核_in=1表示是财务审核产生新单据，如果是财务审核模式不需要重新产生批次
  If 财务审核_In = 0 Then
    If v_药房分批 = 0 Then
      If v_药库分批 = 1 Then
        Begin
          Select Distinct 0
          Into v_药库分批
          From 部门性质说明
          Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
        Exception
          When Others Then
            v_药库分批 := 1;
        End;
      
        If v_药库分批 = 1 Then
          v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid);
        End If;
      End If;
    Else
      v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid);
    End If;
  Else
    v_批次 := 批次_In;
  End If;

  If v_时价分批 = 1 And v_批次 > 0 Then
    v_时价分批 := 1;
  Else
    v_时价分批 := 0;
  End If;

  Select b.Id, b.系数
  Into v_入出类别id, v_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 1 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 发药方式, 单量, 外观, 产品合格证, 生产日期, 批准文号, 用法, 频次, 计划id, 验收结论)
  Values
    (v_Lngid, 1, 1, No_In, 序号_In, 库房id_In, 供药单位id_In, v_入出类别id, 对方部门id_In, v_入出系数, 药品id_In,
     Decode(退货_In, -1, 批次_In, v_批次), 产地_In, 批号_In, 效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In,
     扣率_In, 零售价_In, 退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, 核查人_In, 核查日期_In, Decode(退货_In, -1, 1, 0),
     v_指导批价, 外观_In, 产品合格证_In, 生产日期_In, 批准文号_In, Decode(退货_In, -1, Null, Decode(v_时价分批, 1, 金额差_In, Null)), 加成率_In,
     计划id_In, 验收结论_In);
  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
    --如果是第一笔明细,则产生应付记录的NO
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人,
       填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 库房id, 发票修改时间, 发票代码)
    Values
      (v_应付id, 0, 1, 供药单位id_In, v_No, 1, v_Lngid, No_In, 退货_In * 零售金额_In, 发票号_In, 发票日期_In,
       退货_In * Decode(Nvl(发票金额_In, 0), 0, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 药品id_In, 序号_In, 随货单号_In, 库房id_In, Sysdate, 发票代码_In);
  End If;
  --调用库存更新过程
  Zl_药品库存_Update(v_Lngid, 0);
Exception
  When Err_Noenough Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Insert;
/

--93317:李小东,2016-02-18,药品卫材验收结论处理
Create Or Replace Procedure Zl_材料外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  零售差价_In   In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  注册证号_In   In 药品收发记录.注册证号%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  高值材料_In   In Varchar2 := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  内部条码_In   In 药品收发记录.内部条码%Type := Null,
  费用id_In     In 药品收发记录.费用id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  财务审核_In   In Number := 0,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  验收结论_In   In 药品收发记录.验收结论%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No         应付记录.No%Type; --应付记录的NO 
  v_商品名     收费项目目录.名称%Type; --通用名称 
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID 
  n_应付id     应付记录.Id%Type; --应付记录的ID 
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID 
  n_入出系数   药品收发记录.入出系数%Type; --入出系数 
  n_批次       药品收发记录.批次%Type := Null; --批次 
  n_库房分批   Integer; --是否分批核算    1:分批；0：不分批 
  n_在用分批   Integer; --是否在用分批       1:分批；0：不分批 
  v_可用数量   药品库存.可用数量%Type;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  --取该材料的名称 
  v_产地 := '';
  Select 名称, 规格, 计算单位 Into v_商品名, v_规格, v_单位 From 收费项目目录 Where ID = 材料id_In;

  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  --财务审核直接用传过来的批次
  If 财务审核_In = 0 Then
    If 费用id_In > 0 And 批次_In > 0 Then
      n_批次 := 批次_In;
    Else
      If n_在用分批 = 0 Then
        If n_库房分批 = 1 Then
          Begin
            Select Distinct 0
            Into n_库房分批
            From 部门性质说明
            Where ((工作性质 Like '发料部门') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
          Exception
            When Others Then
              n_库房分批 := 1;
          End;
        
          If n_库房分批 = 1 Then
            n_批次 := v_Lngid;
          End If;
        End If;
      Else
        n_批次 := v_Lngid;
      End If;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 30 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额,
     扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 发药方式, 配药人, 配药日期, 注册证号, 用法, 商品条码, 内部条码, 费用id, 批准文号, 验收结论)
  Values
    (v_Lngid, 1, 15, No_In, 序号_In, 库房id_In, 供药单位id_In, n_入出类别id, n_入出系数, 材料id_In, Decode(退货_In, -1, 批次_In, n_批次), 产地_In,
     批号_In, 生产日期_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In, 扣率_In, 零售价_In,
     退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, Decode(退货_In, -1, 1, 0), 核查人_In, 核查日期_In, 注册证号_In, 零售差价_In,
     商品条码_In, 内部条码_In, 费用id_In, 批准文号_In, 验收结论_In);

  --高值材料信息 
  If Length(高值材料_In) > 0 Then
    Insert Into 收发记录补充信息
      (收发id, 科室, 病人姓名, 住院号, 床号)
    Values
      (v_Lngid, Substr(高值材料_In, 1, Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 1) + 1, Instr(高值材料_In, ',', 1, 2) - Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 2) + 1, Instr(高值材料_In, ',', 1, 3) - Instr(高值材料_In, ',', 1, 2) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 3) + 1, Length(高值材料_In)));
  End If;

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
  
    Select 应付记录_Id.Nextval Into n_应付id From Dual;
  
    --如果是第一笔明细,则产生应付记录的NO 
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量,
       采购价, 采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码)
    Values
      (n_应付id, 0, 1, 材料id_In, 序号_In, 供药单位id_In, v_No, 5, v_Lngid, No_In, 退货_In * 零售金额_In, 随货单号_In, 发票号_In, 发票日期_In,
       退货_In * Decode(发票号_In, Null, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 库房id_In, 发票代码_In);
  End If;

  --退货时下可用数量 
  If 退货_In = -1 And Nvl(费用id_In, 0) <> 2 Then
    --检查库存 
    Begin
      Select Nvl(可用数量, 0)
      Into v_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
    Exception
      When Others Then
        v_可用数量 := 0;
    End;
  
    If v_可用数量 - 实际数量_In < 0 Then
      v_Err_Msg := '[ZLSOFT]第' || 序号_In || '行的可用数量不够,请检查[ZLSOFT]';
      Raise Err_Item;
    End If;
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - 实际数量_In
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Insert;
/

--95315:刘尔旋,2016-04-20,获取就诊记录包含非三方卡记录
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //卡号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --   <JSKLB></JSKLB>     //结算卡类别
  --   <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  v_结算卡类别   Varchar2(100);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  n_站点         Number(1);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS'), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/ZD')
  Into n_病人id, n_记录数, v_结算卡类别, n_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  n_记录数 := Nvl(n_记录数, 0);

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_Reg In (Select a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                         Decode(a.记录性质, 2, '预约中', Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                         Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  Else
    For r_Reg In (Select a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                         Decode(a.记录性质, 2, '预约中', Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                         Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C, 病人预交记录 D
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        c.结帐id = d.结帐id And (d.卡类别id = n_卡类别id Or d.卡类别id Is Null) And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Reghistory;
/

--95115:蔡青松,2016-05-05,当编辑类型=1时修改检验时间为核收时间
Create Or Replace Procedure Zl_检验质控记录_Edit
(
  编辑类型_In     In Number, --1-质控登记;2-质控修改;3-质控删除
  标本id_In       In 检验质控记录.标本id%Type,
  质控品id_In     In 检验质控记录.质控品id%Type := Null,
  新批号试剂_In   In 检验质控记录.新批号试剂%Type := Null,
  新包装试剂_In   In 检验质控记录.新包装试剂%Type := Null,
  新批号校准物_In In 检验质控记录.新批号校准物%Type := Null,
  新包装校准物_In In 检验质控记录.新包装校准物%Type := Null,
  新包装控制物_In In 检验质控记录.新包装控制物%Type := Null,
  仪器维护更新_In In 检验质控记录.仪器维护更新%Type := Null,
  测试次数_In     In 检验质控记录.测试次数%Type := Null,
  检验时间_in     in 检验质控记录.检验时间%type :=null
) Is
  v_检验人   检验质控记录.检验人%Type;
  v_标本序号 检验质控记录.标本序号%Type;
  n_仪器id   检验质控记录.仪器id%Type;
  d_检验时间 检验质控记录.检验时间%Type;
  v_时间     检验质控记录.时间%Type;
  n_测试次数 检验质控记录.测试次数%Type;
  n_质控品id 检验质控记录.质控品id%Type;
  n_Archived Number(10);
  e_Archived Exception;

  Procedure p_Adjust(控制物id_In In 检验质控记录.质控品id%Type) Is
  Begin
    Update 检验质控记录
    Set 测试次数 = -1 * 测试次数
    Where 检验时间 = d_检验时间 And 质控品id + 0 = 控制物id_In And Nvl(弃用记录, 0) = 0;
    n_测试次数 := 0;
    For r_List In (Select 标本id
                   From 检验质控记录
                   Where 检验时间 = d_检验时间 And 质控品id + 0 = 控制物id_In And Nvl(弃用记录, 0) = 0
                   Order By Nvl(测试次数, -999) Desc) Loop
      n_测试次数 := n_测试次数 + 1;
      Update 检验质控记录 Set 测试次数 = n_测试次数 Where 标本id = r_List.标本id;
    End Loop;
  End p_Adjust;

Begin
  If 编辑类型_In = 1 Then
    Select 标本序号, 检验人, 仪器id, Trunc(核收时间), To_Char(检验时间, 'HH24:MI:SS')
    Into v_标本序号, v_检验人, n_仪器id, d_检验时间, v_时间
    From 检验标本记录
    Where ID = 标本id_In;

    Delete 检验质控记录 Where 标本id = 标本id_In;
    Insert Into 检验质控记录
      (标本序号, 标本id, 检验人, 仪器id, 检验时间, 时间, 测试次数, 质控品id, 新批号试剂, 新包装试剂, 新批号校准物, 新包装校准物, 新包装控制物, 仪器维护更新)
    Values
      (v_标本序号, 标本id_In, v_检验人, n_仪器id, d_检验时间, v_时间, 测试次数_In, 质控品id_In, 新批号试剂_In, 新包装试剂_In, 新批号校准物_In, 新包装校准物_In,
       新包装控制物_In, 仪器维护更新_In);

    Update 检验标本记录
    Set 是否质控品 =
         (Select 水平 From 检验质控品 Where ID = 质控品id_In)
    Where ID = 标本id_In;
    Update 检验普通结果
    Set 是否检验 = 1
    Where 检验标本id = 标本id_In And 检验项目id + 0 In (Select 项目id From 检验质控品项目 Where 质控品id = 质控品id_In);
    If 测试次数_In Is Null Then
      p_Adjust(质控品id_In);
    End If;
  Elsif 编辑类型_In = 2 Then
    Select Count(*)
    Into n_Archived
    From 检验质控报告 T, 检验普通结果 R
    Where t.结果id = r.Id And r.检验标本id = 标本id_In And t.归档人 Is Not Null;
    If n_Archived > 0 Then
      Raise e_Archived;
    End If;

    Select 质控品id, 检验时间, 测试次数
    Into n_质控品id, d_检验时间, n_测试次数
    From 检验质控记录
    Where 标本id = 标本id_In;
    Update 检验质控记录
    Set 质控品id = 质控品id_In, 新批号试剂 = 新批号试剂_In, 新包装试剂 = 新包装试剂_In, 新批号校准物 = 新批号校准物_In, 新包装校准物 = 新包装校准物_In, 新包装控制物 = 新包装控制物_In,
        仪器维护更新 = 仪器维护更新_In
    Where 标本id = 标本id_In;

    Update 检验标本记录
    Set 是否质控品 =
         (Select 水平 From 检验质控品 Where ID = 质控品id_In)
    Where ID = 标本id_In;
    Delete 检验质控报告 Where 结果id In (Select ID From 检验普通结果 Where 检验标本id = 标本id_In);
    Update 检验普通结果 Set 是否检验 = 0 Where 检验标本id = 标本id_In;
    Update 检验普通结果
    Set 是否检验 = 1
    Where 检验标本id = 标本id_In And 检验项目id + 0 In (Select 项目id From 检验质控品项目 Where 质控品id = 质控品id_In);

    If n_质控品id <> 质控品id_In Then
      p_Adjust(n_质控品id);
    End If;
    p_Adjust(质控品id_In);
  Elsif 编辑类型_In = 3 then
    Select Count(*)
    Into n_Archived
    From 检验质控报告 T, 检验普通结果 R
    Where t.结果id = r.Id And r.检验标本id = 标本id_In And t.归档人 Is Not Null;
    If n_Archived > 0 Then
      Raise e_Archived;
    End If;
    Begin
      Select 质控品id, 检验时间 Into n_质控品id, d_检验时间 From 检验质控记录 Where 标本id = 标本id_In;
    Exception
      When Others Then
        n_质控品id := Null;
        d_检验时间 := Null;
    End;
    Delete 检验质控记录 Where 标本id = 标本id_In;
    Delete 检验质控报告 Where 结果id In (Select ID From 检验普通结果 Where 检验标本id = 标本id_In);
    Update 检验标本记录 Set 是否质控品 = 0 Where ID = 标本id_In;
    Update 检验普通结果 Set 是否检验 = 0, 弃用结果 = 0 Where 检验标本id = 标本id_In;
    If n_质控品id Is Not Null Then
      p_Adjust(n_质控品id);
    End If;
 elsif 编辑类型_In = 4 then
    Select 标本序号,  仪器id
    Into v_标本序号,  n_仪器id
    From 检验标本记录
    Where ID = 标本id_In;
 
    Delete 检验质控记录 Where 标本id = 标本id_In;
    Insert Into 检验质控记录
      (标本序号, 标本id, 检验人, 仪器id, 检验时间, 时间, 测试次数, 质控品id, 新批号试剂, 新包装试剂, 新批号校准物, 新包装校准物, 新包装控制物, 仪器维护更新)
    Values
      (v_标本序号, 标本id_In, v_检验人, n_仪器id, 检验时间_in, v_时间, 测试次数_In, 质控品id_In, 新批号试剂_In, 新包装试剂_In, 新批号校准物_In, 新包装校准物_In,
       新包装控制物_In, 仪器维护更新_In);

    Update 检验标本记录
    Set 是否质控品 =
         (Select 水平 From 检验质控品 Where ID = 质控品id_In)
    Where ID = 标本id_In;
    Update 检验普通结果
    Set 是否检验 = 1
    Where 检验标本id = 标本id_In And 检验项目id + 0 In (Select 项目id From 检验质控品项目 Where 质控品id = 质控品id_In);
    If 测试次数_In Is Null Then
      p_Adjust(质控品id_In);
    End If;
  End If;

Exception
  When e_Archived Then
    Raise_Application_Error(-20101, '[ZLSOFT]该标本至少一个项目已经报告失控并归档，不能更改！[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检验质控记录_Edit;
/

--95353:许华峰,2016-04-19,影像后台采集优化
CREATE OR REPLACE Procedure Zl_影像检查_图像导入
(
  医嘱id_In  影像检查记录.医嘱id%Type,
  检查uid_In 影像检查记录.检查uid%Type,
  序列uid_In 影像检查序列.序列uid%Type,
  图像uid_In 影像检查图象.图像uid%Type
) Is
  v_Seriesnum 影像检查序列.序列号%Type;
  v_Imagenum  影像检查图象.图像号%Type;

  v_Error    Varchar2(255);
  v_Rowcount Number;
  Err_Custom Exception;

  Cursor c_Advice Is
    Select a.医嘱id
    From 病人医嘱发送 A, 病人医嘱记录 B
    Where (b.Id = 医嘱id_In Or (b.相关id = 医嘱id_In And b.诊疗类别 In ('F', 'G', 'D'))) And a.医嘱id = b.Id;
Begin

  Select Count(*) Into v_Rowcount From 影像检查记录 B Where b.医嘱id = 医嘱id_In;
  If v_Rowcount = 0 Then
    v_Error := '该检查未正常开始，请取消后重新开始。';
    Raise Err_Custom;
  End If;

  Select Nvl(Max(序列号), 0)
  Into v_Seriesnum
  From 影像检查序列 A, 影像检查记录 B
  Where a.检查uid = b.检查uid And b.医嘱id = 医嘱id_In;

  --将临时序列插入正式库中
  Insert Into 影像检查序列
    (序列uid, 检查uid, 序列号, 序列描述, 采集时间)
    Select 序列uid_In, 检查uid_In, v_Seriesnum + 1, '', Sysdate
    From Dual
    Where Not Exists (Select 1 From 影像检查序列 Where 序列uid = 序列uid_In);

  Select Nvl(Max(图像号), 0) Into v_Imagenum From 影像检查图象 Where 序列uid = 序列uid_In;

  --将临时图像插入正式库中
  Insert Into 影像检查图象
    (图像uid, 序列uid, 图像号, 图像描述, 采集时间, 图像时间, 层厚, 图像位置病人, 图像方向病人, 参考帧uid, 切片位置, 行数, 列数, 像素距离, 动态图)
    Select 图像uid_In, 序列uid_In, v_Imagenum + 1, '', Sysdate, Sysdate, '', '', '', '', '', '', '', '', 0
    From Dual
    Where Not Exists (Select 1 From 影像检查图象 Where 图像uid = 图像uid_In);

  For r_Advice In c_Advice Loop
    Update 病人医嘱发送
    Set 执行状态 = 3, 执行过程 = Decode(Sign(执行过程 - 2), 1, 执行过程, 3)
    Where 医嘱id = r_Advice.医嘱id;
  End Loop;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_图像导入;
/

--95353:许华峰,2016-04-19,影像后台采集优化
Create Or Replace Procedure Zl_影像检查_图像导出
(
  医嘱id_In  影像检查记录.医嘱id%Type,
  图像uid_In 影像检查图象.图像uid%Type
) Is
  v_Seriesuid 影像检查序列.序列uid%Type;
  v_Studyuid  影像检查记录.检查uid%Type;

  v_Error    Varchar2(255);
  v_Rowcount Number;
  Err_Custom Exception;
Begin

  Select Count(*) Into v_Rowcount From 影像检查记录 Where 医嘱id = 医嘱id_In;
  If v_Rowcount = 0 Then
    v_Error := '该检查未正常开始，请取消后重新开始。';
    Raise Err_Custom;
  End If;

  Select 检查uid Into v_Studyuid From 影像检查记录 Where 医嘱id = 医嘱id_In;
  Select 序列uid Into v_Seriesuid From 影像检查图象 Where 图像uid = 图像uid_In;

  Delete From 影像检查图象 Where 图像uid = 图像uid_In;
  Delete From 影像检查序列
  Where 序列uid = v_Seriesuid And Not Exists (Select 1 From 影像检查图象 Where 序列uid = v_Seriesuid);

  Update 影像检查记录
  Set 检查uid = '', 位置一 = '', 位置二 = '', 位置三 = '', 报告图象 = '', 接收日期 = ''
  Where 医嘱id = 医嘱id_In And Not Exists (Select 1 From 影像检查序列 Where 检查uid = v_Studyuid);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_图像导出;
/

--00000:张险华,2016-04-15,处理安装脚本与升级脚本不一致，源于祝庆在2012-03-20错误修改10.30.0.SQL
Create Or Replace Procedure ZL_病案审查方案_Insert
(	ID_in IN 病案审查方案.ID%Type,
	名称_in IN 病案审查方案.名称%Type,
	总分_in IN 病案审查方案.总分%Type,
	分段线_in IN 病案审查方案.分段线%Type,
	选用_in IN Number,
  说明_in IN 病案审查方案.说明%Type
)
IS
Begin
  if 选用_in=1 then
     update 病案审查方案
     Set 停用时间 =Sysdate
     Where 启用时间 Is Not Null;
  
     update 病案审查方案
     set 启用时间=Null;
  end if;
  
  if 选用_in=1 then
    INSERT INTO 病案审查方案
      (ID,名称,总分,分段线,启用时间,停用时间,说明)
    VALUES
      (ID_in,名称_in,总分_in,分段线_in,Sysdate,Null,说明_in);
  else
     INSERT INTO 病案审查方案
      (ID,名称,总分,分段线,启用时间,停用时间,说明)
    VALUES
      (ID_in,名称_in,总分_in,分段线_in,Null,Null,说明_in);
  end if;
Exception
	When Others Then
		ZL_ErrorCenter (SQLCODE, SQLERRM);
End  ZL_病案审查方案_Insert;
/

--95278:涂建华,2016-04-15,调整过程不一致问题
CREATE OR REPLACE Procedure Zl_影像检查_Begin
(
  执行间_In     病人医嘱发送.执行间%Type,
  检查号_In     影像检查记录.检查号%Type,
  医嘱id_In     影像检查记录.医嘱id%Type,
  发送号_In     影像检查记录.发送号%Type,
  影像类别_In   影像检查记录.影像类别%Type,
  姓名_In       影像检查记录.姓名%Type,
  英文名_In     影像检查记录.英文名%Type,
  性别_In       影像检查记录.性别%Type,
  年龄_In       影像检查记录.年龄%Type,
  出生日期_In   影像检查记录.出生日期%Type,
  身高_In       影像检查记录.身高%Type,
  体重_In       影像检查记录.体重%Type,
  病理检查_In   影像检查记录.病理检查%Type,
  发放胶片_IN   影像检查记录.发放胶片%Type,
  检查设备_In   影像检查记录.检查设备%Type,
  检查技师_In   影像检查记录.检查技师%Type,
  检查技师二_In 影像检查记录.检查技师二%Type,
  附加主述_In   影像检查记录.附加主述%Type,
  检查时间_In   病人医嘱发送.首次时间%Type,
  执行科室ID_In 影像检查记录.执行科室ID%Type
) Is
  Cursor c_Advice Is
    Select A.医嘱id, A.首次时间
    From 病人医嘱发送 A, 病人医嘱记录 B
    Where (B.ID = 医嘱id_In Or B.相关id = 医嘱id_In) And B.诊疗类别 In ('F', 'G', 'E', 'D') And A.医嘱id = B.ID And
          A.发送号 + 0 = 发送号_In;
  v_Temp         Varchar2(255);
  v_人员姓名     人员表.姓名%Type;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Update 影像检查记录
  Set 影像类别 = 影像类别_In, 检查号 = 检查号_In, 姓名 = 姓名_In, 英文名 = 英文名_In, 性别 = 性别_In, 年龄 = 年龄_In, 出生日期 = 出生日期_In,
      身高 = 身高_In, 体重 = 体重_In, 病理检查 = 病理检查_In, 发放胶片 = 发放胶片_IN, 检查设备 = 检查设备_In, 检查技师 = 检查技师_In,检查技师二=检查技师二_In,
      附加主述 = 附加主述_In,执行科室ID=执行科室ID_In
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;

  If Sql%RowCount = 0 Then
    Insert Into 影像检查记录
      (医嘱id, 发送号, 影像类别, 检查号, 姓名, 英文名, 性别, 年龄, 出生日期, 身高, 体重, 病理检查, 发放胶片, 检查设备, 检查技师,检查技师二, 附加主述, 报到人,执行科室ID)
    Values
      (医嘱id_In, 发送号_In, 影像类别_In, 检查号_In, 姓名_In, 英文名_In, 性别_In, 年龄_In, 出生日期_In, 身高_In, 体重_In,
       病理检查_In, 发放胶片_IN, 检查设备_In, 检查技师_In,检查技师二_In, 附加主述_In, v_人员姓名,执行科室ID_In);
  End If;

  For r_Advice In c_Advice Loop
    Update 病人医嘱发送
    Set 首次时间 = Nvl(检查时间_In, Sysdate), 安排时间=Sysdate,末次时间 = Nvl(检查时间_In, Sysdate), 报到时间 = Nvl(检查时间_In, Sysdate), 执行状态 = 3,
        执行过程 = 2, 执行间 = 执行间_In
    Where 医嘱id = r_Advice.医嘱id And 发送号 = 发送号_In;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_Begin;
/
--95278:涂建华,2016-04-15,调整过程不一致问题
CREATE OR REPLACE Procedure Zl_病理标本_核收
(
  医嘱ID_IN   病理检查信息.医嘱ID%Type,
  病理号_IN   病理检查信息.病理号%Type,
  检查类型_IN 病理检查信息.检查类型%Type,
  送检单位_IN 病理送检信息.送检单位%Type,
  送检科室_IN 病理送检信息.送检科室%Type,
  送检人_IN   病理送检信息.送检人%Type,
  送检日期_IN 病理送检信息.送检日期%Type,
  联系方式_IN 病理送检信息.联系方式%Type,
  登记人_IN   病理送检信息.登记人%Type
) Is
  v_病理号           病理检查信息.病理号%Type := null;
  v_病理医嘱ID       病理检查信息.病理医嘱ID%Type;
  v_检查类型 病理检查信息.检查类型%Type;
  v_送检ID 病理送检信息.ID%Type;
  v_seqNum 病理取材信息.序号%Type;
Begin

  begin
    select 病理号,病理医嘱ID into v_病理号,v_病理医嘱ID from 病理检查信息 where 医嘱ID=医嘱ID_IN;
  exception
    When Others Then
      v_病理号 := null;
      v_病理医嘱ID := null;
  end;

  select 病理送检信息_ID.NEXTVAL into  v_送检ID from dual;

  if v_病理医嘱ID Is null then
     select 病理检查信息_病理医嘱ID.NEXTVAL into v_病理医嘱ID from dual;
  end if;


  --取得当前病理检查类型
  v_检查类型 := 检查类型_IN;

  if v_病理号 is null then
     --没有找到该医嘱对应的病理检查

     --生成病理号
     --Select Lpad(病理检查信息_病理号.NEXTVAL, 8, 0) into v_病理号 from dual;
     v_病理号 := upper(病理号_IN);



     --添加病理送检信息
     insert into 病理送检信息(ID, 医嘱ID,送检单位,送检科室,送检人,送检日期,联系方式,登记人,核收状态)
     values(v_送检ID, 医嘱ID_IN, 送检单位_IN, 送检科室_IN, 送检人_IN, 送检日期_IN, 联系方式_IN, 登记人_IN, 1);

     --添加病理检查信息,核收后，检查进入取材流程
     insert into 病理检查信息(病理医嘱ID,病理号, 医嘱ID, 检查类型, 取材过程)
     values(v_病理医嘱ID, v_病理号, 医嘱ID_IN, v_检查类型, decode(v_检查类型, 3, 0, 1));
  else
    --当该检查已被核收过时，则只添加送检信息
     insert into 病理送检信息(ID, 医嘱ID,送检单位,送检科室,送检人,送检日期,联系方式,登记人,核收状态)
     values(v_送检ID, 医嘱ID_IN, 送检单位_IN, 送检科室_IN, 送检人_IN, 送检日期_IN, 联系方式_IN, 登记人_IN, 1);
  end if;

  --如果是会诊，当检测到未核收的标本是蜡块时，则将蜡块信息写入到取材数据中
  if v_检查类型=3 then
    begin
      select  nvl(max(序号), 0) into v_seqNum from 病理取材信息 where 病理医嘱ID=v_病理医嘱ID;
    exception
      When Others Then v_seqNum := 0;
    end;

    insert into 病理取材信息(材块ID,序号,病理医嘱ID,标本ID,标本名称,蜡块数,确认状态)
    select 病理取材信息_材块ID.NEXTVAL,v_seqNum + rownum,v_病理医嘱ID,标本ID,标本名称,数量,1 from 病理标本信息 where 医嘱ID=医嘱ID_IN and nvl(送检ID, 0) <= 0 and 材料类别=1;
  end if;


  --更新标本的送检ID，核收后，标本送检ID不能为空
  update 病理标本信息 set 送检ID=v_送检ID where 医嘱ID=医嘱ID_IN and (送检ID is null or nvl(送检ID, 0)=0);

  --更新对应医嘱的执行说明...
  update 病人医嘱发送
  set 执行说明=执行说明 || chr(13) || '标本已被核收 [ 时间:'|| 送检日期_IN  || '    登记人:' || 登记人_IN || '] '
  where 医嘱ID=医嘱ID_IN;



  --更新检查信息的取材过程为需取材（为会诊的检查核收后，不进行取材操作）
  update 病理检查信息
  set 取材过程=decode(v_检查类型, 3, 0, 1),报到时间=decode(报到时间,null,送检日期_IN,'',送检日期_IN,报到时间)
  where 病理医嘱ID=v_病理医嘱ID;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病理标本_核收;
/
--95278:涂建华,2016-04-15,调整过程不一致问题
CREATE OR REPLACE Procedure ZL_排队清除
(
       业务类型_IN 排队叫号队列.业务类型%Type,
       有效时间_IN Number := 1
)
Is
       v_当前有效时间 number;
Begin
     --清除当前业务类型，而且时间在有效时间之前的排队信息
     v_当前有效时间 := 有效时间_IN;
     if v_当前有效时间 = 0 then
       v_当前有效时间 := 1;
     end if;

     Delete From 排队叫号队列 Where 业务类型 = 业务类型_IN And 排队时间 < trunc(sysdate) -(v_当前有效时间-1);
     update 排队叫号队列 set 排队状态=2 where 排队时间 < trunc(sysdate);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_排队清除;
/
--95278:涂建华,2016-04-15,调整过程不一致问题
Create Or Replace Procedure Zl_影像检查_Set
(
	医嘱id_In  影像检查记录.医嘱id%Type,
	发送号_In  影像检查记录.发送号%Type,
	检查uid_In 影像检查记录.检查uid%Type
) Is
	Pos1         影像检查记录.位置一%Type;
	Pos2         影像检查记录.位置二%Type;
	Pos3         影像检查记录.位置三%Type;
	Receiveddate 影像检查记录.接收日期%Type;
	v_Error      Varchar2(255);
	Irowcount    Number;
	Err_Custom Exception;
	Cursor c_Advice Is
		Select a.医嘱id
		From 病人医嘱发送 a, 病人医嘱记录 b
		Where (b.Id = 医嘱id_In Or (b.相关id = 医嘱id_In And b.诊疗类别 In ('F', 'G', 'D'))) And a.医嘱id = b.Id And
					a.发送号 + 0 = 发送号_In;
Begin
	Select Count(*) Into Irowcount From 影像检查记录 b Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In;
	If Irowcount = 0 Then
		v_Error := '该检查未正常开始，请取消后重新开始。';
		Raise Err_Custom;
	End If;

	Select 位置一, 位置二, 位置三, 接收日期
	Into Pos1, Pos2, Pos3, Receiveddate
	From 影像临时记录
	Where 检查uid = 检查uid_In;

	Update 影像检查记录
	Set 检查uid = Decode(检查uid, Null, 检查uid_In, 检查uid), 位置一 = Decode(位置一, Null, Pos1, 位置一),
			位置二 = Decode(位置二, Null, Pos2, 位置二), 位置三 = Decode(位置三, Null, Pos3, 位置三),
			接收日期 = Decode(接收日期, Null, Receiveddate, 接收日期)
	Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
	Insert Into 影像检查序列
		(序列uid, 检查uid, 序列号, 序列描述, 采集时间)
		Select a.序列uid, b.检查uid, Nvl(b.序列号, 0) + a.序列号, a.序列描述, a.采集时间
		From 影像临时序列 a,
				 (Select b.检查uid, Max(c.序列号) As 序列号
					 From 影像检查记录 b, 影像检查序列 c
					 Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And b.检查uid = c.检查uid(+)
					 Group By b.检查uid) b
		Where a.检查uid = 检查uid_In And Not Exists (Select a.序列UID From 影像检查序列 Where 序列UID= a.序列UID);
    
	Insert Into 影像检查图象
		(图像uid, 序列uid, 图像号, 图像描述, 采集时间, 图像时间, 层厚, 图像位置病人, 图像方向病人, 参考帧uid, 切片位置,
		 行数, 列数, 像素距离, 动态图)
		Select a.图像uid, a.序列uid, a.图像号, a.图像描述, a.采集时间, a.图像时间, a.层厚, a.图像位置病人, a.图像方向病人,
					 a.参考帧uid, a.切片位置, a.行数, a.列数, a.像素距离, a.动态图
		From 影像临时图象 a, 影像临时序列 b
		Where a.序列uid = b.序列uid And b.检查uid = 检查uid_In;

	Delete From 影像临时记录 Where 检查uid = 检查uid_In;

	For r_Advice In c_Advice Loop
		Update 病人医嘱发送
		Set 执行状态 = 3, 执行过程 = Decode(Sign(执行过程 - 2), 1, 执行过程, 3)
		Where 医嘱id = r_Advice.医嘱id And 发送号 = 发送号_In;
	End Loop;
Exception
	When Err_Custom Then
		Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
	When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查_Set;
/
--95034:余伟节,2016-04-12,病人信息合并照片ID重复
CREATE OR REPLACE Procedure Zl_病人信息_Merge
(
  A病人id_In    病人信息.病人id%Type, --要合并的病人信息
  B病人id_In    病人信息.病人id%Type, --要保留的病人信息
  合并原因_In   病人合并记录.合并原因%Type,
  操作员姓名_In 人员表.姓名%Type,
  强制保留_In   Number := 0
  --标准版
  ----------------------------------------------------------------------------
  --病人信息,病案主页,病案主页从表,病人变动记录,特殊病人
  --门诊病案记录,住院病案记录,床位状况记录
  --医保病人档案,保险模拟结算,保险结算记录,帐户年度信息
  --病人余额,病人未结费用,住院费用记录,门诊费用记录,病人预交记录,病人结帐记录,未发药品记录
  --病人挂号记录,病人过敏药物,病人过敏记录,病人诊断记录,诊断情况
  --病人医嘱记录,病人手麻记录
  --病人社区信息
  
  --后备表：
  --H病人结帐记录,H病人预交记录,H住院费用记录,H门诊费用记录
  --H病人医嘱记录,H病人诊断记录,H病人过敏记录
  --H病人病历记录,H病人手麻记录
  
  --病案系统
  ----------------------------------------------------------------------------
  --病人费用,随诊记录,借阅记录
  --新生儿诊断记录,病人分娩信息
  --诊断符合情况,病案评分结果
  
) As
  --病人相关表
  Cursor c_Patitable Is
    Select a.Table_Name, Max(Decode(b.Column_Name, '病人ID', 1, 0)) As 病人id,
           Max(Decode(b.Column_Name, '主页ID', 1, 0)) As 主页id
    From User_Tables A, User_Tab_Columns B
    Where a.Table_Name = b.Table_Name And b.Column_Name In ('病人ID', '主页ID') And
          a.Table_Name Not In
          ('病人信息', '病案主页', '病案主页从表', '病人变动记录', '特殊病人', '门诊病案记录', '住院病案记录', '床位状况记录', '医保病人档案', '医保病人关联表', '保险模拟结算',
           '帐户年度信息', '病人余额', '病人未结费用', '住院费用记录', '门诊费用记录', '病人预交记录', '病人结帐记录', '未发药品记录', '病人挂号记录', '病人过敏药物', '病人过敏记录',
           '病人诊断记录', '诊断情况', '病人医嘱记录', '病人手麻记录', '病人费用', '随诊记录', '借阅记录', '病人分娩信息', '诊断符合情况', '病案评分结果', '病人担保记录', '病人社区信息',
           '病人免疫记录', '病人信息从表', '病人医疗卡属性') Having Max(Decode(b.Column_Name, '病人ID', 1, 0)) <> 0
    Group By a.Table_Name;

  --数组定义
  Type Array_Patitable Is Table Of Varchar2(100) Index By Binary_Integer;
  Arronbase Array_Patitable;
  Arronpage Array_Patitable;
  v_Loop    Number;
  n_Have    Number;

  -------------------------------------------------------
  --被合并的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infoa Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id(+) And a.病人id = A病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infoa c_Infoa%RowType;

  --要保留的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infob Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id(+) And a.病人id = B病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infob c_Infob%RowType;

  --合并后的信息
  Cursor c_Info(v_病人id 病人信息.病人id%Type) Is
    Select 病人id, 主页id, (Select Nvl(Max(主页id), 0) From 病案主页 Where 病人id = v_病人id) 最大主页id, 住院号, 病人性质, 医疗付款方式, 费别, 再入院,
           入院病区id, 入院科室id, 医疗小组id, 入院日期, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id, 护理等级id, 出院科室id, 出院病床,
           出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师, 责任护士, 住院医师, 病案号, 编目员编号, 编目员姓名,
           编目日期, 状态, 费用和, 年龄, 身高, 体重, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话, 家庭地址邮编, 联系人姓名, 联系人关系, 联系人地址,
           联系人电话, 联系人身份证号, 户口地址, 户口地址邮编, 中医治疗类别, 险类, 社区, 审核标志, 审核人, 审核日期, 是否上传, 数据转出, 登记人, 登记时间, 备注, 病案状态, 病人类型
    From 病案主页
    Where 主页id = (Select Nvl(Max(主页id), 0)
                  From 病案主页
                  Where 病人id = v_病人id And Not Exists (Select 主页id From 病案主页 Where 病人id = v_病人id And 主页id = 0)) And
          病人id = v_病人id;
  r_Info c_Info%RowType;

  --合并两个住院病人
  Cursor c_Mergepati Is
    Select a.姓名, a.门诊号, a.住院号 当前住院号, b.病人id, b.主页id, b.住院号, b.病人性质, b.医疗付款方式, b.费别, b.再入院, b.入院病区id, b.入院科室id,
           b.医疗小组id, b.入院日期, b.入院病况, b.入院方式, b.入院属性, b.二级院转入, b.住院目的, b.入院病床, b.是否陪伴, b.当前病况, b.当前病区id, b.护理等级id,
           b.出院科室id, b.出院病床, b.出院日期, b.住院天数, b.出院方式, b.是否确诊, b.确诊日期, b.新发肿瘤, b.血型, b.抢救次数, b.成功次数, b.随诊标志, b.随诊期限,
           b.尸检标志, b.门诊医师, b.责任护士, b.住院医师, b.病案号, b.编目员编号, b.编目员姓名, b.编目日期, b.状态, b.费用和, b.性别, b.年龄, b.身高, b.体重, b.婚姻状况,
           b.职业, b.国籍, b.学历, b.单位电话, b.单位邮编, b.单位地址, b.区域, b.家庭地址, b.家庭电话, b.家庭地址邮编, b.联系人姓名, b.联系人关系, b.联系人地址, b.联系人电话,
           b.联系人身份证号, b.户口地址, b.户口地址邮编, b.中医治疗类别, b.险类, b.社区, b.审核标志, b.审核人, b.审核日期, b.是否上传, b.数据转出, b.登记人, b.登记时间, b.备注,
           b.病案状态, b.病人类型, b.封存时间, b.路径状态, b.单病种, b.婴儿科室id, b.婴儿病区id, b.母婴转科标志, b.医嘱重整时间
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id And a.病人id In (A病人id_In, B病人id_In)
    Order By b.入院日期 Desc, Nvl(b.出院日期, Sysdate) Desc;

  v_保留id 病人信息.病人id%Type;
  v_合并id 病人信息.病人id%Type;
  v_门诊号 病人信息.门诊号%Type;
  v_住院号 病人信息.住院号%Type;
  --病人未结费用(门诊部份)
  Cursor c_Owe(v_病人id 病人信息.病人id%Type) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, Sum(金额) As 金额
    From 病人未结费用
    Where 主页id Is Null And 病人id = v_病人id
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径;

  --病人余额
  Cursor c_Spare(v_病人id 病人信息.病人id%Type) Is
    Select 性质, 类型, 预交余额, 费用余额 From 病人余额 Where 病人id = v_病人id;

  --医保病人档案
  Cursor c_Insure(v_病人id 病人信息.病人id%Type) Is
    Select * From 保险帐户 Where 病人id = v_病人id Order By 险类;

  --要保留的医保病人档案
  Cursor c_Keepinsure
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 保险帐户 Where 病人id = v_病人id And 险类 = v_险类;
  r_Keepinsure c_Keepinsure%RowType;

  Cursor c_Year
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 帐户年度信息 Where 病人id = v_病人id And 险类 = v_险类;

  v_原信息   病人合并记录.原信息%Type;
  v_Count    Number;
  n_Readonly Number;
  v_Sql      Varchar2(1000);

  n_主页id       病人信息.主页id%Type;
  v_Error        Varchar2(255);
  n_担保额       病人担保记录.担保额%Type;
  v_担保人       病人信息.担保人%Type;
  n_担保性质     病人担保记录.担保性质%Type;
  n_Row          Number;
  n_独立病案     Number;
  n_每次新住院号 Number;
  n_Max主页id    Number;
  n_Cnt主页id    Number;
  n_Cur主页id    Number;
  n_Cnt住院次数  Number;
  n_Cur住院次数  Number;
  n_Max住院次数  Number;
  n_Loop主页id   病人信息.主页id%Type;

  n_Lengthb Number;
  Err_Custom Exception;
Begin
  Begin
    Select 只读 Into n_Readonly From zlBakSpaces Where 当前 = 1;
  Exception
    When Others Then
      Null;
  End;
  If n_Readonly = 1 Then
    n_Readonly := 0;
    For r_Bak In (Select a.表名 Table_Name
                  From Zltools.Zlbaktables A, User_Constraints B
                  Where a.表名 = b.Table_Name And b.r_Constraint_Name = '病人信息_PK' And b.Constraint_Type = 'R') Loop
      v_Sql := 'Select Count(病人Id) From ' || r_Bak.Table_Name || ' Where 病人Id In(:1,:2)';
      Execute Immediate v_Sql
        Into n_Readonly
        Using A病人id_In, B病人id_In;
      If n_Readonly > 0 Then
        v_Error := '病人在只读的当前转储空间存在数据,不能进行合并!';
        Raise Err_Custom;
      End If;
    End Loop;
  End If;

  --程序中已检查：
  --1.选择了同一个病人
  --2.两个住院病人先入院的却在院(包括两个都在院)。
  --3.两个住院病人的住院期间存在交叉的情况
  --4.医保病人存在未结费用

  --先锁定病人不允许进行其他业务
  Zl_病人信息_锁定(A病人id_In, 1);
  Zl_病人信息_锁定(B病人id_In, 1);

  Open c_Infoa;
  Fetch c_Infoa
    Into r_Infoa;
  If c_Infoa%RowCount = 0 Then
    Close c_Infoa;
    v_Error := '没有发现被合并的病人信息！';
    Raise Err_Custom;
  End If;

  Open c_Infob;
  Fetch c_Infob
    Into r_Infob;
  If c_Infob%RowCount = 0 Then
    Close c_Infob;
    v_Error := '没有发现要保留的病人信息！';
    Raise Err_Custom;
  End If;

  --读取其它相关病人表到数组
  For r_Patitable In c_Patitable Loop
    If r_Patitable.主页id = 0 Then
      Arronbase(Arronbase.Count + 1) := r_Patitable.Table_Name;
    Else
      Arronpage(Arronpage.Count + 1) := r_Patitable.Table_Name;
    End If;
  End Loop;

  --以先住院或先登记的病人ID作为实际上要保留的病人ID
  If Nvl(强制保留_In, 0) = 1 Then
    v_保留id := B病人id_In;
  Else
    Select 病人id
    Into v_保留id
    From (Select /*+ CHOOSE */
            a.病人id
           From 病人信息 A, 病案主页 B
           Where a.病人id = b.病人id(+) And a.病人id In (A病人id_In, B病人id_In)
           Order By Nvl(b.入院日期, To_Date('3000-01-01', 'YYYY-MM-DD')), Nvl(b.出院日期, To_Date('3000-01-01', 'YYYY-MM-DD')),
                    a.登记时间, a.病人id --住院病人优先
           )
    Where Rownum = 1;
  End If;

  --先确定病案号的模式
  Select Zl_To_Number(Nvl(zl_GetSysParameter(39), '0')) Into n_独立病案 From Dual;
  --住院号模式
  Select Zl_To_Number(Nvl(zl_GetSysParameter(145), '0')) Into n_每次新住院号 From Dual;

  --另外一个就是实际最后要删除的病人ID
  If v_保留id = A病人id_In Then
    v_合并id := B病人id_In;
    --问题27445 保留指定病人的门诊号、住院号、医保号
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  Else
    v_合并id := A病人id_In;
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  End If;

  ---记录合并操作,在后面会根据r_PatiTable把合并病人的合并记录更新为保留病人的
  v_原信息 := v_合并id || ',' || r_Infoa.门诊号 || ',' || r_Infoa.住院号 || ',' || r_Infoa.就诊卡号 || ',' || r_Infoa.姓名 || ',' ||
           r_Infoa.性别 || ',' || r_Infoa.年龄 || ',' || To_Char(r_Infoa.出生日期, 'yyyy-mm-dd') || ',' || r_Infoa.身份证号 || ',' ||
           r_Infoa.婚姻状况 || ',' || r_Infoa.职业 || ',' || r_Infoa.家庭地址;
  Insert Into 病人合并记录
    (病人id, 原信息, 合并原因, 操作员姓名, 合并时间)
  Values
    (v_保留id, v_原信息, 合并原因_In, 操作员姓名_In, Sysdate);

  --开始合并
  --84398修改将住院次数计算放在外面，因需要考虑门诊和住院病人合并
  --10.34开始,住院次数不包含留关病人,合并后的住院次数=保留病人住院次数+合并病人正常入院的次数
  Select Nvl(住院次数, 0) Into n_Cur住院次数 From 病人信息 Where 病人id = v_保留id;
  Select Count(*) Into n_Cnt住院次数 From 病案主页 Where 病人id = v_合并id And 主页id <> 0 And 病人性质 = 0;
  n_Max住院次数 := n_Cur住院次数 + n_Cnt住院次数;
  --处理病案主页部份(涉及病人ID,主页ID字段的表)
  If (r_Infoa.主页id Is Not Null And r_Infob.主页id Is Not Null) Or (强制保留_In = 1 And r_Infoa.主页id Is Not Null) Then
    If r_Infoa.主页id = 0 And r_Infob.主页id = 0 Then
      Close c_Infoa;
      Close c_Infob;
      v_Error := '两个预约病人不能进行病人合并操作！';
      Raise Err_Custom;
    Elsif r_Infoa.主页id = 0 Then
      If r_Infob.入院日期 Is Not Null And r_Infob.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    Elsif r_Infob.主页id = 0 Then
      If r_Infoa.入院日期 Is Not Null And r_Infoa.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    End If;
    --求两个病人总共的住院就诊次数
    Select Count(*) Into v_Count From 病案主页 Where 病人id In (A病人id_In, B病人id_In) And 主页id <> 0;
    --因为10.19开始，入院时允许修改主页id，所以最大主页ID可能大于总的住院就诊次数
    Select Max(主页id) Into n_Max主页id From 病案主页 Where 病人id = v_保留id And 主页id <> 0;
    Select Count(*) Into n_Cnt主页id From 病案主页 Where 病人id = v_合并id And 主页id <> 0;
    If n_Max主页id + n_Cnt主页id > v_Count Then
      v_Count := n_Max主页id + n_Cnt主页id;
    End If;
    --求实际要更新的主页截至值,以前用v_Count >= n_Max主页id判断存在一个问题（对于两个病人多次交叉入院，可能导致A,B病人部分就诊次数没有更新）
    Select Nvl(Max(主页id), 0)
    Into n_Loop主页id
    From 病案主页 A, (Select Min(入院日期) 入院日期 From 病案主页 Where 病人id = v_合并id) B
    Where a.病人id = v_保留id And a.入院日期 < b.入院日期;
  
    For r_Merge In c_Mergepati Loop
      If Not (r_Merge.病人id = v_保留id And r_Merge.主页id = v_Count) And v_Count <> 0 Then
        --该病案主页要删除时,不能是已编目了的。
        If r_Merge.编目日期 Is Not Null Then
          Close c_Infoa;
          Close c_Infob;
          If r_Merge.当前住院号 Is Null Then
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ')存在已编目的病案,不允许合并该病人。';
          Else
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ',住院号=' || r_Merge.当前住院号 ||
                       ')存在已编目的病案,不允许合并该病人。';
          End If;
          Raise Err_Custom;
        End If;
        If v_Count >= Nvl(n_Loop主页id, 0) Then
          If r_Merge.主页id = 0 Then
            n_Cur主页id := 0;
            Update 病案主页
            Set 病人性质 = r_Merge.病人性质, 医疗付款方式 = r_Merge.医疗付款方式, 费别 = r_Merge.费别, 再入院 = r_Merge.再入院,
                入院病区id = r_Merge.入院病区id, 入院科室id = r_Merge.入院科室id, 入院日期 = r_Merge.入院日期, 入院病况 = r_Merge.入院病况,
                入院方式 = r_Merge.入院方式, 二级院转入 = r_Merge.二级院转入, 住院目的 = r_Merge.住院目的, 入院病床 = r_Merge.入院病床,
                是否陪伴 = r_Merge.是否陪伴, 当前病况 = r_Merge.当前病况, 当前病区id = r_Merge.当前病区id, 护理等级id = r_Merge.护理等级id,
                出院科室id = r_Merge.出院科室id, 出院病床 = r_Merge.出院病床, 出院日期 = r_Merge.出院日期, 住院天数 = r_Merge.住院天数,
                出院方式 = r_Merge.出院方式, 是否确诊 = r_Merge.是否确诊, 确诊日期 = r_Merge.确诊日期, 新发肿瘤 = r_Merge.新发肿瘤, 血型 = r_Merge.血型,
                抢救次数 = r_Merge.抢救次数, 成功次数 = r_Merge.成功次数, 随诊标志 = r_Merge.随诊标志, 随诊期限 = r_Merge.随诊期限, 尸检标志 = r_Merge.尸检标志,
                门诊医师 = r_Merge.门诊医师, 责任护士 = r_Merge.责任护士, 住院医师 = r_Merge.住院医师, 编目员编号 = r_Merge.编目员编号,
                编目员姓名 = r_Merge.编目员姓名, 编目日期 = r_Merge.编目日期, 状态 = r_Merge.状态, 费用和 = r_Merge.费用和, 姓名 = r_Merge.姓名,
                性别 = r_Merge.性别, 年龄 = r_Merge.年龄, 婚姻状况 = r_Merge.婚姻状况, 职业 = r_Merge.职业, 国籍 = r_Merge.国籍, 学历 = r_Merge.学历,
                单位电话 = r_Merge.单位电话, 单位邮编 = r_Merge.单位邮编, 单位地址 = r_Merge.单位地址, 区域 = r_Merge.区域, 家庭地址 = r_Merge.家庭地址,
                家庭电话 = r_Merge.家庭电话, 家庭地址邮编 = r_Merge.家庭地址邮编, 户口地址 = r_Merge.户口地址, 户口地址邮编 = r_Merge.户口地址邮编,
                联系人姓名 = r_Merge.联系人姓名, 联系人关系 = r_Merge.联系人关系, 联系人地址 = r_Merge.联系人地址, 联系人电话 = r_Merge.联系人电话,
                中医治疗类别 = r_Merge.中医治疗类别, 登记人 = r_Merge.登记人, 登记时间 = r_Merge.登记时间, 险类 = r_Merge.险类, 审核标志 = r_Merge.审核标志,
                是否上传 = r_Merge.是否上传, 备注 = r_Merge.备注, 数据转出 = r_Merge.数据转出, 病案号 = r_Merge.病案号,
                住院号 = Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号),病人类型 = r_Merge.病人类型,
                封存时间 = r_Merge.封存时间, 路径状态 = r_Merge.路径状态, 单病种 = r_Merge.单病种, 婴儿科室id = r_Merge.婴儿科室id,
                婴儿病区id = r_Merge.婴儿病区id, 母婴转科标志 = r_Merge.母婴转科标志, 医嘱重整时间 = r_Merge.医嘱重整时间
            Where 病人id = v_保留id And 主页id = n_Cur主页id;
            If Sql%RowCount = 0 Then
              Insert Into 病案主页
                (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
                 当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志,
                 门诊医师, 责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址,
                 家庭电话, 家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出,
                 病案号, 住院号,病人类型, 封存时间, 路径状态, 单病种, 婴儿科室id, 婴儿病区id, 母婴转科标志, 医嘱重整时间)
              Values
                (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id,
                 r_Merge.入院科室id, r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床,
                 r_Merge.是否陪伴, r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期,
                 r_Merge.住院天数, r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数,
                 r_Merge.成功次数, r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师,
                 r_Merge.编目员编号, r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.姓名, r_Merge.性别, r_Merge.年龄,
                 r_Merge.婚姻状况, r_Merge.职业, r_Merge.国籍, r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域,
                 r_Merge.家庭地址, r_Merge.家庭电话, r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系,
                 r_Merge.联系人地址, r_Merge.联系人电话, r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志,
                 r_Merge.是否上传, r_Merge.备注, r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号),
                 r_Merge.病人类型, r_Merge.封存时间, r_Merge.路径状态, r_Merge.单病种, r_Merge.婴儿科室id, r_Merge.婴儿病区id,
                 r_Merge.母婴转科标志, r_Merge.医嘱重整时间);
            End If;
          Else
            n_Cur主页id := v_Count;
            Insert Into 病案主页
              (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
               当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师,
               责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话,
               家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出, 病案号, 住院号,
               病人类型, 封存时间, 路径状态, 单病种, 婴儿科室id, 婴儿病区id, 母婴转科标志, 医嘱重整时间)
            Values
              (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id, r_Merge.入院科室id,
               r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床, r_Merge.是否陪伴,
               r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期, r_Merge.住院天数,
               r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数, r_Merge.成功次数,
               r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师, r_Merge.编目员编号,
               r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.姓名, r_Merge.性别, r_Merge.年龄, r_Merge.婚姻状况,
               r_Merge.职业, r_Merge.国籍, r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域, r_Merge.家庭地址,
               r_Merge.家庭电话, r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系, r_Merge.联系人地址,
               r_Merge.联系人电话, r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志, r_Merge.是否上传,
               r_Merge.备注, r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号),r_Merge.病人类型,
               r_Merge.封存时间, r_Merge.路径状态, r_Merge.单病种, r_Merge.婴儿科室id, r_Merge.婴儿病区id, r_Merge.母婴转科标志, r_Merge.医嘱重整时间);
          End If;
        Else
          Exit;
        End If;
      
        --更新病人相关表的病人指向
        ---------------------------------------------------------------
        --病人变动记录
        Update 病人变动记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病案主页从表
        Update 病案主页从表
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --住院费用记录
        Update 住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        --门诊费用记录
        --Update 门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
        --Update H门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
      
        --病人预交记录
        Update 病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人未结费用
        Update 病人未结费用
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --未发药品记录
        Update 未发药品记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --诊断情况
        Update 诊断情况
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险结算记录(病人ID和非住院病人一起在后面处理)
        Update 保险结算记录 Set 主页id = n_Cur主页id Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险模拟结算
        Update 保险模拟结算
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人医嘱记录(ZLHIS+)
        Update 病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人过敏记录(ZLHIS+)
        Update 病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人诊断记录(ZLHIS+)
        Update 病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人手麻记录(ZLHIS+)
        Update 病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人担保记录(zlhis+)
        Update 病人担保记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病案系统的表
        Begin
          v_Sql := 'Update 病人费用 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 随诊记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 诊断符合情况 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 病案评分结果 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Insert Into 病人分娩信息(病人ID,主页ID,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分) ' ||
                   'Select :1,:2,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分 From 病人分娩信息 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Delete From 病人分娩信息 Where 病人ID=:1 And 主页ID=:2';
          Execute Immediate v_Sql
            Using r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 借阅记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        --其它病案主页相关表
        For v_Loop In 1 .. Arronpage.Count Loop
          v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        End Loop;
      
        --删除已调整后的病案主页
        Delete From 病案主页 Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      End If;
      If r_Merge.主页id <> 0 Then
        v_Count := v_Count - 1;
      End If;
    End Loop;
  End If;

  --不涉及主页ID部份的更改(无主页ID或主页ID可能为空)
  ---------------------------------------------------------------
  --住院费用记录
  Update 住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  --门诊费用记录
  Update 门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;

  --病人预交记录
  Update 病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --未发药品记录
  Update 未发药品记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --诊断情况
  Update 诊断情况 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人医嘱记录(ZLHIS+)
  Update 病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人过敏记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人诊断记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人手麻记录(ZLHIS+)
  Update 病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人挂号记录(ZLHIS+)
  Update 病人挂号记录 Set 病人id = v_保留id, 门诊号 = Nvl(v_门诊号, 门诊号) Where 病人id = v_合并id;

  --病人结帐记录
  Update 病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --床位状况记录
  Update 床位状况记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人担保记录
  Update 病人担保记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  --特殊病人
  Select Count(*) Into v_Count From 特殊病人 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Update 特殊病人 Set 病人id = v_保留id Where 病人id = v_合并id;
  Else
    Delete From 特殊病人 Where 病人id = v_合并id;
  End If;

  --病人未结费用
  For r_Owe In c_Owe(v_合并id) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Owe.金额, 0)
    Where 主页id Is Null And 病人id = v_保留id And Nvl(病人病区id, 0) = Nvl(r_Owe.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Owe.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Owe.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(r_Owe.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(r_Owe.收入项目id, 0) And
          Nvl(来源途径, 0) = Nvl(r_Owe.来源途径, 0);
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (v_保留id, Null, r_Owe.病人病区id, r_Owe.病人科室id, r_Owe.开单部门id, r_Owe.执行部门id, r_Owe.收入项目id, r_Owe.来源途径, r_Owe.金额);
    End If;
  End Loop;
  Delete From 病人未结费用 Where 病人id = v_合并id;
  Delete From 病人未结费用 Where 病人id = v_保留id And Nvl(金额, 0) = 0;

  --病人余额
  For r_Spare In c_Spare(v_合并id) Loop
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Spare.预交余额, 0), 费用余额 = Nvl(费用余额, 0) + Nvl(r_Spare.费用余额, 0)
    Where Nvl(性质, 0) = Nvl(r_Spare.性质, 0) And 病人id = v_保留id And 类型 = Nvl(r_Spare.类型, 2);
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (v_保留id, r_Spare.性质, Nvl(r_Spare.类型, 2), r_Spare.预交余额, r_Spare.费用余额);
    End If;
  End Loop;
  Delete From 病人余额 Where 病人id = v_合并id;
  Delete From 病人余额 Where 病人id = v_保留id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 性质 = 1;

  --病人过敏药物
  Insert Into 病人过敏药物
    (病人id, 过敏药物id, 过敏药物)
    Select v_保留id, 过敏药物id, 过敏药物
    From 病人过敏药物
    Where 病人id = v_合并id And 过敏药物id Not In (Select 过敏药物id From 病人过敏药物 Where 病人id = v_保留id);
  Delete From 病人过敏药物 Where 病人id = v_合并id;

  --病人社区信息
  Insert Into 病人社区信息
    (病人id, 社区, 社区号, 标志, 就诊类型, 就诊时间)
    Select v_保留id, 社区, 社区号, 标志, 就诊类型, 就诊时间
    From 病人社区信息
    Where 病人id = v_合并id And 社区 Not In (Select 社区 From 病人社区信息 Where 病人id = v_保留id);
  Delete From 病人社区信息 Where 病人id = v_合并id;

  --病人免疫记录
  Insert Into 病人免疫记录
    (病人id, 接种时间, 接种名称)
    Select v_保留id, a.接种时间, a.接种名称
    From 病人免疫记录 A
    Where a.病人id = v_合并id And Not Exists (Select 1 From 病人免疫记录 Where 病人id = v_保留id And 接种时间 = a.接种时间);
  Delete From 病人免疫记录 Where 病人id = v_合并id;

  --病人信息从表
  Insert Into 病人信息从表
    (病人id, 信息名, 信息值, 就诊id)
    Select v_保留id, a.信息名, a.信息值, a.就诊id
    From 病人信息从表 A
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人信息从表
           Where 病人id = v_保留id And 信息名 = a.信息名 And Nvl(就诊id, 0) = Nvl(a.就诊id, 0));
  Delete From 病人信息从表 Where 病人id = v_合并id;

  --病人医疗卡属性
  Insert Into 病人医疗卡属性
    (病人id, 卡类别id, 卡号, 信息名, 信息值)
    Select v_保留id, a.卡类别id, a.卡号, a.信息名, a.信息值
    From 病人医疗卡属性 A
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人医疗卡属性
           Where 病人id = v_保留id And 卡类别id = a.卡类别id And 卡号 = a.卡号 And 信息名 = a.信息名);
  Delete From 病人医疗卡属性 Where 病人id = v_合并id;

  --门诊病案记录
  Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 门诊病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Delete From 门诊病案记录 Where 病人id = v_合并id;
  End If;

  --住院病案记录
  Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_保留id;

  If v_Count = 0 Then
    Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 住院病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Begin
      v_Sql := 'Delete From 借阅记录 Where 病人ID=:1';
      Execute Immediate v_Sql
        Using v_合并id;
    Exception
      When Others Then
        Null;
    End;
  
    Delete From 住院病案记录 Where 病人id = v_合并id;
  End If;

  --医保病人相关处理
  --即使合病或保留的病人当前不是医保帐户,只要曾是医保帐户,险类不同也不能合并
  Select Count(Distinct 险类) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
  If v_Count = 2 Then
    Close c_Infoa;
    Close c_Infob;
    v_Error := '两个病人分别属于不同的保险类别，不允许合并。';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 0;
  --a.合并的病人以前是医保帐户,现在不是
  If v_Count > 0 Then
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
    --a.1保留的病人现在是医保帐户
    --a.2.1保留的病人现在不是医保帐户,以前是,与a.1相同处理
    If v_Count > 0 Then
      Delete From 帐户年度信息 Where 病人id = v_合并id;
    
      Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
      If v_Count <> 2 Then
        --两个病人医保号相同时,不用处理医保病人档案
        For r_Insure In c_Insure(v_合并id) Loop
          --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
          --问题27445 保留指定病人的门诊号、住院号、医保号
          If v_合并id = B病人id_In Then
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          Else
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          End If;
          --合并的病人现在不是医保,即使是用户指定要保留该病人,也不保留它的帐户信息
          Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
        End Loop;
      End If;
      Delete From 医保病人关联表 Where 病人id = v_合并id;
    Else
      --a.2.2保留的病人现在和以前都不是医保帐户
      Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
      Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
      --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
    End If;
  Else
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 1;
    --b.合并的病人现在是医保帐户
    If v_Count > 0 Then
      Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
      --b.1保留的病人现在也是医保帐户
      --b.2.1保留的病人现在不是医保帐户,以前是,与b.1相同处理
      If v_Count > 0 Then
        For r_Insure In c_Insure(v_合并id) Loop
          --转移帐户年度信息
          For r_Year In c_Year(v_合并id, r_Insure.险类) Loop
            Update 帐户年度信息
            Set 帐户增加累计 = Nvl(帐户增加累计, 0) + Nvl(r_Year.帐户增加累计, 0), 帐户支出累计 = Nvl(帐户支出累计, 0) + Nvl(r_Year.帐户支出累计, 0),
                进入统筹累计 = Nvl(进入统筹累计, 0) + Nvl(r_Year.进入统筹累计, 0), 统筹报销累计 = Nvl(统筹报销累计, 0) + Nvl(r_Year.统筹报销累计, 0),
                住院次数累计 = Nvl(住院次数累计, 0) + Nvl(r_Year.住院次数累计, 0), 大额统筹累计 = Nvl(大额统筹累计, 0) + Nvl(r_Year.大额统筹累计, 0),
                起付线累计 = Nvl(起付线累计, 0) + Nvl(r_Year.起付线累计, 0), 本次起付线 = Nvl(本次起付线, r_Year.本次起付线),
                基本统筹限额 = Nvl(基本统筹限额, r_Year.基本统筹限额), 大额统筹限额 = Nvl(大额统筹限额, r_Year.大额统筹限额), 封销信息 = Nvl(封销信息, r_Year.封销信息)
            Where 病人id = v_保留id And 险类 = r_Insure.险类 And 年度 = r_Year.年度;
            If Sql%RowCount = 0 Then
              Insert Into 帐户年度信息
                (病人id, 险类, 年度, 帐户增加累计, 帐户支出累计, 进入统筹累计, 统筹报销累计, 住院次数累计, 本次起付线, 基本统筹限额, 大额统筹限额, 起付线累计, 大额统筹累计, 封销信息)
              Values
                (v_保留id, r_Insure.险类, r_Year.年度, r_Year.帐户增加累计, r_Year.帐户支出累计, r_Year.进入统筹累计, r_Year.统筹报销累计,
                 r_Year.住院次数累计, r_Year.本次起付线, r_Year.基本统筹限额, r_Year.大额统筹限额, r_Year.起付线累计, r_Year.大额统筹累计, r_Year.封销信息);
            End If;
          End Loop;
          Delete From 帐户年度信息 Where 病人id = v_合并id;
        
          Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
          If v_Count <> 2 Then
            --两个病人医保号相同时,不用处理医保病人档案
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 标志 = 0
              Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
              Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
            End If;
            Delete From 医保病人关联表 Where 病人id = v_合并id;
          Else
            --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
            --问题27445 保留指定病人的门诊号、住院号、医保号
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            Else
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            End If;
            --暂存用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              Open c_Keepinsure(B病人id_In, r_Insure.险类);
              Fetch c_Keepinsure
                Into r_Keepinsure;
            End If;
          
            Delete From 医保病人关联表 Where 病人id = v_合并id;
            Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
          
            --保留用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              If c_Keepinsure%RowCount > 0 Then
                Update 医保病人档案
                Set 卡号 = r_Keepinsure.卡号, 医保号 = r_Keepinsure.医保号, 密码 = r_Keepinsure.密码, 人员身份 = r_Keepinsure.人员身份,
                    单位编码 = r_Keepinsure.单位编码, 顺序号 = r_Keepinsure.顺序号, 退休证号 = r_Keepinsure.退休证号, 帐户余额 = r_Keepinsure.帐户余额,
                    当前状态 = r_Keepinsure.当前状态, 病种id = r_Keepinsure.病种id, 在职 = r_Keepinsure.在职, 年龄段 = r_Keepinsure.年龄段,
                    灰度级 = r_Keepinsure.灰度级, 就诊时间 = r_Keepinsure.就诊时间
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                --保留病人可能关联了多个医保病人,都要更改医保号
                Update 医保病人关联表
                Set 医保号 = r_Keepinsure.医保号, 标志 = 0
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
              End If;
              Close c_Keepinsure;
            End If;
          End If;
        End Loop;
      Else
        --b.2.2保留的病人现在和以前都不是医保帐户
        Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
        Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
        --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
      End If;
    Else
      --c.合并的病人以前和现在都不是医保帐户,不作任何处理
      Null;
    End If;
  End If;

  --处理体检子系统的病人合并
  n_Have := 0;
  Begin
    Select 1 Into n_Have From zlSystems Where Floor(编号 / 100) = 21;
  Exception
    When Others Then
      Null;
  End;
  If n_Have = 1 Then
    v_Sql := 'Begin zl21_病人信息_Merge(:1,:2); End;';
    Execute Immediate v_Sql
      Using v_合并id, v_保留id;
  End If;

  --其它病人,病案主页相关表
  For v_Loop In 1 .. Arronpage.Count Loop
    --Executesql('Update ' || Arronpage(v_Loop) || ' Set 病人ID=' || v_保留id || ' Where 病人ID=' || v_合并id || ' And Nvl(主页ID,0) = 0');
    --"主页=0，主页ID is NULL，主页ID=挂号ID"都有可能，前面部分与主页ID关联都没处理到，因此不加条件
    v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;
  For v_Loop In 1 .. Arronbase.Count Loop
    If Arronbase(v_Loop) = '病人照片' Then
      Select Count(1) Into n_Have From 病人照片 Where 病人id = v_保留id;
      If n_Have = 1 Then
        Delete From 病人照片 Where 病人id = v_合并id;
      End If;
    End If;
    v_Sql := 'Update ' || Arronbase(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;

  --删除实际不保留的病人信息
  Delete From 病人信息 Where 病人id = v_合并id;

  --根据界面选择保留病人信息
  Update 病人信息
  Set 姓名 = Nvl(r_Infob.姓名, r_Infoa.姓名), 性别 = Nvl(r_Infob.性别, r_Infoa.性别), 年龄 = Nvl(r_Infob.年龄, r_Infoa.年龄), 门诊号 = v_门诊号,
      住院号 = v_住院号, 就诊卡号 = Nvl(r_Infob.就诊卡号, r_Infoa.就诊卡号), 卡验证码 = Decode(r_Infob.就诊卡号, Null, r_Infoa.卡验证码, r_Infob.卡验证码),
      费别 = Nvl(r_Infob.费别, r_Infoa.费别), 医疗付款方式 = Nvl(r_Infob.医疗付款方式, r_Infoa.医疗付款方式),
      出生日期 = Nvl(r_Infob.出生日期, r_Infoa.出生日期), 出生地点 = Nvl(r_Infob.出生地点, r_Infoa.出生地点),
      身份证号 = Nvl(r_Infob.身份证号, r_Infoa.身份证号), 身份 = Nvl(r_Infob.身份, r_Infoa.身份), 职业 = Nvl(r_Infob.职业, r_Infoa.职业),
      民族 = Nvl(r_Infob.民族, r_Infoa.民族), 国籍 = Nvl(r_Infob.国籍, r_Infoa.国籍), 学历 = Nvl(r_Infob.学历, r_Infoa.学历),
      籍贯 = Nvl(r_Infob.籍贯, r_Infoa.籍贯), 区域 = Nvl(r_Infob.区域, r_Infoa.区域), 婚姻状况 = Nvl(r_Infob.婚姻状况, r_Infoa.婚姻状况),
      家庭地址 = Nvl(r_Infob.家庭地址, r_Infoa.家庭地址), 家庭电话 = Nvl(r_Infob.家庭电话, r_Infoa.家庭电话),
      家庭地址邮编 = Nvl(r_Infob.家庭地址邮编, r_Infoa.家庭地址邮编), 户口地址 = Nvl(r_Infob.户口地址, r_Infoa.户口地址),
      户口地址邮编 = Nvl(r_Infob.户口地址邮编, r_Infoa.户口地址邮编), 联系人姓名 = Nvl(r_Infob.联系人姓名, r_Infoa.联系人姓名),
      联系人关系 = Nvl(r_Infob.联系人关系, r_Infoa.联系人关系), 联系人地址 = Nvl(r_Infob.联系人地址, r_Infoa.联系人地址),
      联系人电话 = Nvl(r_Infob.联系人电话, r_Infoa.联系人电话), 合同单位id = Nvl(r_Infob.合同单位id, r_Infoa.合同单位id),
      工作单位 = Nvl(r_Infob.工作单位, r_Infoa.工作单位), 单位电话 = Nvl(r_Infob.单位电话, r_Infoa.单位电话),
      单位邮编 = Nvl(r_Infob.单位邮编, r_Infoa.单位邮编), 单位开户行 = Nvl(r_Infob.单位开户行, r_Infoa.单位开户行),
      单位帐号 = Nvl(r_Infob.单位帐号, r_Infoa.单位帐号), 就诊时间 = Nvl(r_Infob.就诊时间, r_Infoa.就诊时间),
      就诊状态 = Nvl(r_Infob.就诊状态, r_Infoa.就诊状态), 就诊诊室 = Nvl(r_Infob.就诊诊室, r_Infoa.就诊诊室), 险类 = Nvl(r_Infob.险类, r_Infoa.险类),
      登记时间 = Nvl(r_Infob.登记时间, r_Infoa.登记时间), 住院次数 = Null, 主页id = Null, 当前床号 = Null, 当前科室id = Null, 当前病区id = Null,
      入院时间 = Null, 出院时间 = Null, 在院 = Decode(Nvl(r_Infob.在院, 0), 1, 1, Null)
  Where 病人id = v_保留id;

  Open c_Info(v_保留id);
  Fetch c_Info
    Into r_Info;
  If c_Info%RowCount > 0 Then
    --最后一次为预约病人,只需要更改住院次数和入院时间
    If r_Info.主页id = 0 Then
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数)
      Where 病人id = v_保留id;
    Else
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数),
          当前床号 = Decode(r_Info.出院日期, Null, r_Info.出院病床, Null), 当前病区id = Decode(r_Info.出院日期, Null, r_Info.当前病区id, Null),
          当前科室id = Decode(r_Info.出院日期, Null, r_Info.出院科室id, Null), 入院时间 = r_Info.入院日期, 出院时间 = r_Info.出院日期



      
      Where 病人id = v_保留id;
    End If;
    --处理担保信息
    Select Nvl(主页id, -1) Into n_主页id From 病人信息 Where 病人id = v_保留id;
    --提取当前有效的正常担保记录,确保正常担保与临时担保不并存
    Select Nvl(Sum(担保额), 0), Count(病人id)
    Into n_担保额, n_Row
    From 病人担保记录
    Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 担保性质 = 0 And 删除标志 = 1;
    If n_Row = 0 Then
      --保留最后一条临时担保记录,其余到期
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1 And
            登记时间 <> (Select Max(登记时间)
                     From 病人担保记录
                     Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And
                           删除标志 = 1);
    Else
      --有正常担保就让临时担保失效
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1;
    End If;
  
    --提取当前有效担保额及有效担保记录数
    n_Row    := 0;
    n_担保额 := 0;
    v_担保人 := '';
    For r_提保信息 In (Select 担保人, 担保额
                   From 病人担保记录
                   Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1) Loop
      n_Row     := n_Row + 1;
      n_担保额  := n_担保额 + r_提保信息.担保额;
      v_担保人  := v_担保人 || ',' || r_提保信息.担保人;
      n_Lengthb := Lengthb(v_担保人);
      If n_Lengthb >= 101 Then
        v_Error := '不能合并担保记录，在病人信息保存时超过担保人字段长度！';
        Raise Err_Custom;
      End If;
    End Loop;
    v_担保人 := Substr(v_担保人, 2, 100);
  
    If n_Row = 0 Then
      Update 病人信息 Set 担保人 = Null, 担保额 = Null, 担保性质 = Null Where 病人id = v_保留id;
    Else
      --提取最后一条有效担保人和担保性质
      Select 担保性质
      Into n_担保性质
      From 病人担保记录
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 删除标志 = 1 And
            登记时间 =
            (Select Max(登记时间)
             From 病人担保记录
             Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1);
    
      Update 病人信息 Set 担保人 = v_担保人, 担保额 = n_担保额, 担保性质 = n_担保性质 Where 病人id = v_保留id;
    End If;
  End If;

  Close c_Info;
  Close c_Infoa;
  Close c_Infob;

  --对病人进行解锁
  Update 病人信息 Set 锁定 = 0 Where 病人id In (A病人id_In, B病人id_In);
Exception
  When Err_Custom Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    End;
  When Others Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      zl_ErrorCenter(SQLCode, SQLErrM);
    End;
End Zl_病人信息_Merge;
/

--94241:陈刘,2016-04-12,删除打印记录时,如果明细数据还存在,则不删除

Create Or Replace Procedure Zl_病人护理打印_Update
(
  文件id_In   In 病人护理打印.文件id%Type,
  发生时间_In In 病人护理打印.发生时间%Type,
  行数_In     In 病人护理打印.行数%Type,
  删除_In     Number := 0
) Is
  n_Actives   Number;
  n_Rows      Number; --0-新增,>0表示修改 
  n_Startpage Number; --开始页 
  n_Startrow  Number; --开始行 
  n_Endpage   Number; --结束页 
  n_Endrow    Number; --结束行 
  n_Count     Number; --发生时间之后的数据条数 
  n_Pagerows  Number; --每页有效数据行 
  n_Del       Number;
  n_行数      病人护理打印.行数%Type;
  n_Firstdata Number; --是否是录入的第一条数据 
  n_记录id    病人护理数据.Id%Type;
  n_记录oldid 病人护理打印.记录id%Type;
  n_格式id    病人护理文件.格式id%Type;
  d_发生时间  病人护理打印.发生时间%Type;
  v_Username  人员表.姓名%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(1000);
  v_Print   Varchar2(800);
Begin
  n_Del      := 删除_In;
  n_行数     := 行数_In;
  v_Username := Zl_Username;
  Select 格式id Into n_格式id From 病人护理文件 Where ID = 文件id_In;

  If n_行数 = 0 Then
    v_Err_Msg := '有效数据行不能等于零，请记录本次错误的操作过程！';
    Raise Err_Item;
  End If;

  Begin
    Select 记录id, 行数, 开始页号, 开始行号, 结束页号, 结束行号
    Into n_记录oldid, n_Rows, n_Startpage, n_Startrow, n_Endpage, n_Endrow
    From 病人护理打印
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_Rows := 0;
  End;

  --提取该护理文件格式每页有效数据行（不加错误处理） 
  Select To_Number(内容文本)
  Into n_Pagerows
  From 病历文件结构
  Where 对象属性 = '有效数据行' And 父id = (Select ID From 病历文件结构 Where 文件id = n_格式id And 对象序号 = 1 And 父id Is Null);

  Select Count(*) Into n_Count From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;

  --修改数据时,也可能删除 
  If n_Del = 0 Then
    Begin
      If n_Count = 0 Then
        n_Del := 1;
      End If;
      If n_Count > 1 Then
        v_Err_Msg := '在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】已经存在相应的数据，您不能再次录入或修改数据的时间为此发生时间！';
        Raise Err_Item;
      End If;
    End;
  Elsif n_Del = 1 And n_Count > 0 Then
    n_Del  := 0;
    n_行数 := 1;
  End If;

  n_Firstdata := 0;
  If n_Del = 1 Then
    Delete 病人护理打印 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
    n_Rows := n_Rows * -1;
  Else
    Select ID Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  
    If n_Rows = 0 Then
      --根据现有打印数据及将要插入的数据，计算出开始页号，行号，结束页号，行号 
      Select Min(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      If d_发生时间 Is Null Then
        Select Max(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 < 发生时间_In;
        If d_发生时间 Is Null Then
          n_Startpage := 1;
          n_Startrow  := 1;
          n_Firstdata := 1;
        Else
          Select 结束页号, 结束行号
          Into n_Startpage, n_Startrow
          From 病人护理打印
          Where 文件id = 文件id_In And 发生时间 = d_发生时间;
          n_Startrow := n_Startrow + 1;
        End If;
      Else
        Select 开始页号, 开始行号
        Into n_Startpage, n_Startrow
        From 病人护理打印
        Where 文件id = 文件id_In And 发生时间 = d_发生时间;
      End If;
    
      --校正页号,行号 
      If n_Startrow > n_Pagerows Then
        n_Startpage := n_Startpage + 1;
        n_Startrow  := n_Startrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Startpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Startpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Startpage - 1;
        End If;
      End If;
      n_Endpage := n_Startpage;
      n_Endrow  := n_Startrow + n_行数 - 1;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置 
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Endpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Endpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Endpage - 1;
        End If;
      End If;
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      Insert Into 病人护理打印
        (记录id, 文件id, 发生时间, 行数, 开始页号, 开始行号, 结束页号, 结束行号)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_行数, n_Startpage, n_Startrow, n_Endpage, n_Endrow);
      --新插入的数据的行数就是差值 
      n_Rows := n_行数;
    Else
      --计算与原行数的差值 
      n_Rows := n_行数 - n_Rows;
      --校正页号,行号 
      n_Endrow := n_Endrow + n_Rows;
      If n_Endrow <= 0 Then
        n_Endrow  := n_Pagerows + n_Endrow;
        n_Endpage := n_Endpage - 1;
      End If;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况 
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      End If;
    
      --不允许录入跨两页的数据 
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      --更新打印数据（当前数据的打印人与打印时间更新为NULL，其后数据不动） 
      Update 病人护理打印
      Set 文件id = 文件id_In, 记录id = n_记录id, 发生时间 = 发生时间_In, 行数 = n_行数, 开始页号 = n_Startpage, 开始行号 = n_Startrow,
          结束页号 = n_Endpage, 结束行号 = n_Endrow, 行差 = Decode(打印人, Null, 0, n_Rows),
          --只有打印过的数据才记录行差 
          打印人 = Null, 打印时间 = Null
      Where 记录id = n_记录oldid;
    End If;
  End If;
  --无行差，退出 
  If n_Rows = 0 Then
    Return;
  End If;

  --之后是否存在数据？ 
  Begin
    Select 1 Into n_Count From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 1 Then
    --更新之后数据的打印相关数据（除打印人与打印时间） 
    If n_Rows > 0 Then
      Update 病人护理打印
      Set 开始页号 = 开始页号 + Decode(Sign(开始行号 + n_Rows - n_Pagerows), 1, 1, 0),
          结束页号 = 结束页号 + Decode(Sign(结束行号 + n_Rows - n_Pagerows), 1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(开始行号 + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(结束行号 + n_Rows, n_Pagerows)), 打印人 = Null,
          打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
    Else
      --新的行号小于1则页号-1 
      --新的行号+每页的有效行后再进行判断 
      Update 病人护理打印
      Set 开始页号 = 开始页号 - Decode(Sign(开始行号 + n_Rows - 1), -1, 1, 0),
          结束页号 = 结束页号 - Decode(Sign(结束行号 + n_Rows - 1), -1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows), 0, n_Pagerows,
                         Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows)), 打印人 = Null, 打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      --程序应该是先删除了数据才更新的，所以不会存在页号为零的，页号为零的肯定已经删除了。 
      --DELETE 病人护理打印 WHERE 开始页号=0; 
    End If;
    --检查更新之后的打印数据是否存在连续跨一页以上，如果存在则禁止。 
    v_Print := '';
    For r_Print In (Select 发生时间, 开始页号
                    From 病人护理打印
                    Where 文件id = 文件id_In And 发生时间 > 发生时间_In And 结束页号 - 开始页号 > 1
                    Order By 发生时间) Loop
      If Lengthb(v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                 To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】') < 800 Then
        v_Print := v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                   To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】';
      End If;
    End Loop;
    If v_Print Is Not Null Then
      v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据影响了后续数据位置，导致以下数据连续跨了一页以上：';
      v_Err_Msg := v_Err_Msg || v_Print || Chr(13) || Chr(10) || '目前产品暂不支持对跨一页以上的数据进行展示和打印，操作终止！';
      Raise Err_Item;
    End If;
  End If;
  --进行关联文件的页号修正 
  Zl_病人护理打印_Batchretrypage(文件id_In, n_Firstdata || ';' || n_Firstdata);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理打印_Update;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
Create Or Replace Procedure Zl_部门人员_Update
(
  Id_In       In 部门人员.人员id%Type,
  部门列表_In In Varchar2 --部门列表_IN参数的填写方式如下："12:1;23:0;" 
) Is
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Intpos    Pls_Integer;
  Lng部门id 部门表.Id%Type;
  Int缺省   Number(1);
Begin
  --删除已有的所属部门 
  Delete From 部门人员 Where 人员id = Id_In;

  --再插入所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;
  Update 人员表 Set 最后修改时间 = Sysdate Where ID = Id_In;
End Zl_部门人员_Update;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门扩展信息_Insert
(
  部门id_In In 部门扩展信息.部门id%Type,
  项目_In   In 部门扩展信息.项目%Type,
  内容_In   In 部门扩展信息.内容%Type
) Is
Begin
  Insert Into 部门扩展信息 (部门id, 项目, 内容) Values (部门id_In, 项目_In, 内容_In);
  Update 部门表 Set 最后修改时间 = Sysdate Where ID = 部门id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门扩展信息_Insert;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门扩展信息_Delete
(
  部门id_In In 部门扩展信息.部门id%Type,
  项目_In   In 部门扩展信息.项目%Type
) Is
Begin
  Delete From 部门扩展信息 Where 部门id = 部门id_In And 项目 = 项目_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门扩展信息_Delete;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员扩展信息_Insert
(
  人员id_In In 人员扩展信息.人员id%Type,
  项目_In   In 人员扩展信息.项目%Type,
  内容_In   In 人员扩展信息.内容%Type
) Is
Begin
  Insert Into 人员扩展信息 (人员id, 项目, 内容) Values (人员id_In, 项目_In, 内容_In);
  Update 人员表 Set 最后修改时间 = Sysdate Where ID = 人员id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员扩展信息_Insert;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员扩展信息_Delete
(
  人员id_In In 人员扩展信息.人员id%Type,
  项目_In   In 人员扩展信息.项目%Type
) Is
Begin
  Delete From 人员扩展信息 Where 人员id = 人员id_In And 项目 = 项目_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员扩展信息_Delete;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员表_新增
(
  Id_In           In 人员表.Id%Type,
  编号_In         In 人员表.编号%Type,
  姓名_In         In 人员表.姓名%Type,
  简码_In         In 人员表.简码%Type,
  身份证号_In     In 人员表.身份证号%Type,
  出生日期_In     In 人员表.出生日期%Type,
  性别_In         In 人员表.性别%Type,
  民族_In         In 人员表.民族%Type,
  工作日期_In     In 人员表.工作日期%Type,
  办公室电话_In   In 人员表.办公室电话%Type,
  电子邮件_In     In 人员表.电子邮件%Type,
  执业类别_In     In 人员表.执业类别%Type,
  执业范围_In     In 人员表.执业范围%Type,
  管理职务_In     In 人员表.管理职务%Type,
  专业技术职务_In In 人员表.专业技术职务%Type,
  聘任技术职务_In In 人员表.聘任技术职务%Type,
  学历_In         In 人员表.学历%Type,
  所学专业_In     In 人员表.所学专业%Type,
  留学时间_In     In 人员表.留学时间%Type,
  留学渠道_In     In 人员表.留学渠道%Type,
  接受培训_In     In 人员表.接受培训%Type,
  科研课题_In     In 人员表.科研课题%Type,
  个人简介_In     In 人员表.个人简介%Type,
  部门列表_In     In Varchar2, --部门列表_IN参数的填写方式如下："12:1;23:0;" 
  人员性质_In     In Varchar2, --人员性质_IN参数的填写方式如下："门诊挂号员;医生;护士;" 
  别名_In         In 人员表.别名%Type := Null,
  站点_In         In 人员表.站点%Type := Null,
  签名_In         In 人员表.签名%Type := Null,
  执业证号_In     In 人员表.执业证号%Type := Null,
  资格证书号_In   In 人员表.资格证书号%Type := Null,
  执业开始日期_In In 人员表.执业开始日期%Type := Null,
  处方权标志_In   In 人员表.处方权标志%Type := Null,
  手术等级_In     In 人员表.手术等级%Type := Null,
  移动电话_In     In 人员表.移动电话%Type := Null,
  顺序_In         In 人员表.顺序%Type := Null
) Is
  Intpos    Pls_Integer;
  Int缺省   Number(1);
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Lng部门id 部门表.Id%Type;
Begin
  --首先插入记录 
  Insert Into 人员表
    (ID, 编号, 姓名, 简码, 身份证号, 出生日期, 性别, 民族, 工作日期, 办公室电话, 电子邮件, 执业类别, 执业范围, 管理职务, 专业技术职务, 聘任技术职务, 学历, 所学专业, 留学时间, 留学渠道,
     接受培训, 科研课题, 个人简介, 站点, 别名, 建档时间, 撤档时间, 签名, 执业证号, 资格证书号, 执业开始日期, 处方权标志, 手术等级, 移动电话, 顺序, 最后修改时间)
  Values
    (Id_In, 编号_In, 姓名_In, 简码_In, 身份证号_In, 出生日期_In, 性别_In, 民族_In, 工作日期_In, 办公室电话_In, 电子邮件_In, 执业类别_In, 执业范围_In, 管理职务_In,
     专业技术职务_In, 聘任技术职务_In, 学历_In, 所学专业_In, 留学时间_In, 留学渠道_In, 接受培训_In, 科研课题_In, 个人简介_In, 站点_In, 别名_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 签名_In, 执业证号_In, 资格证书号_In, 执业开始日期_In, 处方权标志_In, 手术等级_In, 移动电话_In, 顺序_In,
     Sysdate);
  --接着修改所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;

  --接着修改人员性质说明 
  Strtemp := 人员性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ';');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 人员性质说明 (人员性质, 人员id) Values (Str性质, Id_In);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_新增;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_人员表_修改
(
  Id_In           In 人员表.Id%Type,
  编号_In         In 人员表.编号%Type,
  姓名_In         In 人员表.姓名%Type,
  简码_In         In 人员表.简码%Type,
  身份证号_In     In 人员表.身份证号%Type,
  出生日期_In     In 人员表.出生日期%Type,
  性别_In         In 人员表.性别%Type,
  民族_In         In 人员表.民族%Type,
  工作日期_In     In 人员表.工作日期%Type,
  办公室电话_In   In 人员表.办公室电话%Type,
  电子邮件_In     In 人员表.电子邮件%Type,
  执业类别_In     In 人员表.执业类别%Type,
  执业范围_In     In 人员表.执业范围%Type,
  管理职务_In     In 人员表.管理职务%Type,
  专业技术职务_In In 人员表.专业技术职务%Type,
  聘任技术职务_In In 人员表.聘任技术职务%Type,
  学历_In         In 人员表.学历%Type,
  所学专业_In     In 人员表.所学专业%Type,
  留学时间_In     In 人员表.留学时间%Type,
  留学渠道_In     In 人员表.留学渠道%Type,
  接受培训_In     In 人员表.接受培训%Type,
  科研课题_In     In 人员表.科研课题%Type,
  个人简介_In     In 人员表.个人简介%Type,
  部门列表_In     In Varchar2, --部门列表_IN参数的填写方式如下："12:1;23:0;" 
  人员性质_In     In Varchar2, --人员性质_IN参数的填写方式如下："门诊挂号员;医生;护士;" 
  别名_In         In 人员表.别名%Type := Null,
  站点_In         In 人员表.站点%Type := Null,
  签名_In         In 人员表.签名%Type := Null,
  执业证号_In     In 人员表.执业证号%Type := Null,
  资格证书号_In   In 人员表.资格证书号%Type := Null,
  执业开始日期_In In 人员表.执业开始日期%Type := Null,
  处方权标志_In   In 人员表.处方权标志%Type := Null,
  手术等级_In     In 人员表.手术等级%Type := Null,
  移动电话_In     In 人员表.移动电话%Type := Null,
  顺序_In         In 人员表.顺序%Type := Null
) Is
  Intpos    Pls_Integer;
  Int缺省   Number(1);
  Strtemp   Varchar2(2000);
  Str性质   Varchar2(10);
  Lng部门id 部门表.Id%Type;
Begin
  --首先插入修改记录 
  Update 人员表
  Set 编号 = 编号_In, 姓名 = 姓名_In, 简码 = 简码_In, 身份证号 = 身份证号_In, 出生日期 = 出生日期_In, 性别 = 性别_In, 民族 = 民族_In, 工作日期 = 工作日期_In,
      办公室电话 = 办公室电话_In, 电子邮件 = 电子邮件_In, 执业类别 = 执业类别_In, 执业范围 = 执业范围_In, 管理职务 = 管理职务_In, 专业技术职务 = 专业技术职务_In,
      聘任技术职务 = 聘任技术职务_In, 学历 = 学历_In, 所学专业 = 所学专业_In, 留学时间 = 留学时间_In, 留学渠道 = 留学渠道_In, 接受培训 = 接受培训_In, 科研课题 = 科研课题_In,
      个人简介 = 个人简介_In, 站点 = 站点_In, 别名 = 别名_In, 签名 = 签名_In, 执业证号 = 执业证号_In, 资格证书号 = 资格证书号_In, 执业开始日期 = 执业开始日期_In,
      处方权标志 = 处方权标志_In, 手术等级 = 手术等级_In, 移动电话 = 移动电话_In, 顺序 = 顺序_In, 最后修改时间 = Sysdate
  Where ID = Id_In;

  --接着删除已有的所属部门 
  Delete From 部门人员 Where 人员id = Id_In;

  --接着修改所属部门 
  Strtemp := 部门列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到部门ID 
      Str性质   := Substr(Strtemp, 1, Intpos - 1);
      Lng部门id := To_Number(Str性质);
      Strtemp   := Substr(Strtemp, Intpos + 1);
      --得到是否缺省 
      Intpos  := Instr(Strtemp, ';');
      Int缺省 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门人员 (部门id, 人员id, 缺省) Values (Lng部门id, Id_In, Int缺省);
    End If;
  End Loop;

  --接着删除已有的性质说明 
  Delete From 人员性质说明 Where 人员id = Id_In;

  --最后修改人员性质说明 
  Strtemp := 人员性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ';');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到人员性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 人员性质说明 (人员性质, 人员id) Values (Str性质, Id_In);
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员表_修改;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门表_Insert
(
  Id_In       In 部门表.Id%Type,
  上级id_In   In 部门表.上级id%Type,
  编码_In     In 部门表.编码%Type,
  名称_In     In 部门表.名称%Type,
  简码_In     In 部门表.简码%Type,
  位置_In     In 部门表.位置%Type,
  部门性质_In In Varchar2,
  临床性质_In In Varchar2, --部门性质_IN参数的填写方式如下： "临床:3:护理:3:产科:0:" 
  环境类别_In In 部门表.环境类别%Type := Null,
  站点_In     In 部门表.站点%Type := Null,
  顺序_In     In 部门表.顺序%Type := Null
) Is
  Intpos  Pls_Integer;
  Int对象 Number(1);
  Strtemp Varchar2(2000);
  Str性质 Varchar2(20);
Begin
  --首先插入记录 
  Insert Into 部门表
    (ID, 上级id, 编码, 名称, 简码, 位置, 建档时间, 撤档时间, 站点, 环境类别, 顺序, 最后修改时间)
  Values
    (Id_In, 上级id_In, 编码_In, 名称_In, 简码_In, 位置_In, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 站点_In, 环境类别_In, 顺序_In,
     Sysdate);
  --接着修改部门性质说明 
  Strtemp := 部门性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Str性质 := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到服务对象 
      Intpos  := Instr(Strtemp, ':');
      Int对象 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门性质说明 (工作性质, 服务对象, 部门id) Values (Str性质, Int对象, Id_In);
    End If;
  End Loop;

  If 临床性质_In Is Not Null Then
    Insert Into 临床部门 (工作性质, 部门id) Values (临床性质_In, Id_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门表_Insert;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_部门表_Update
(
  Id_In       In 部门表.Id%Type,
  上级id_In   In 部门表.上级id%Type,
  编码_In     In 部门表.编码%Type,
  名称_In     In 部门表.名称%Type,
  简码_In     In 部门表.简码%Type,
  位置_In     In 部门表.位置%Type,
  原长度_In   In Number,
  部门性质_In In Varchar2,
  临床性质_In In Varchar2, --部门性质_IN参数的填写方式如下："临床:3:护理:3:产科:0:" 
  环境类别_In In 部门表.环境类别%Type := Null,
  负责人_In   In 部门表.部门负责人%Type := Null,
  站点_In     In 部门表.站点%Type := Null,
  顺序_In     In 部门表.顺序%Type := Null
) Is
  Intpos  Pls_Integer;
  Int对象 Number(1);
  Strtemp Varchar2(2000);
  Str性质 Varchar2(20);
Begin
  --首先插入修改记录 
  Update 部门表
  Set 上级id = 上级id_In, 编码 = 编码_In, 名称 = 名称_In, 简码 = 简码_In, 位置 = 位置_In, 站点 = 站点_In, 环境类别 = 环境类别_In, 部门负责人 = 负责人_In,
      撤档时间 = To_Date('3000-1-1', 'yyyy-mm-dd'), 顺序 = 顺序_In, 最后修改时间 = Sysdate
  Where ID = Id_In;

  --对它的下级也要修改编码 
  Update 部门表
  Set 编码 = 编码_In || Substr(编码, 原长度_In)
  Where ID In (Select ID From 部门表 Start With 上级id = Id_In Connect By Prior ID = 上级id);

  --接着删除已有的性质说明 
  Delete From 部门性质说明 Where 部门id = Id_In;

  --接着修改部门性质说明 
  Strtemp := 部门性质_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, ':');
  
    If Intpos = 0 Then
      Str性质 := '';
    Else
      --得到工作性质 
      Str性质 := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到服务对象 
      Intpos  := Instr(Strtemp, ':');
      Int对象 := To_Number(Substr(Strtemp, 1, Intpos - 1));
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 部门性质说明 (工作性质, 服务对象, 部门id) Values (Str性质, Int对象, Id_In);
    End If;
  End Loop;

  --删除可能有的临床性质 
  Delete From 临床部门 Where 部门id = Id_In;

  If 临床性质_In Is Not Null Then
    Insert Into 临床部门 (工作性质, 部门id) Values (临床性质_In, Id_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_部门表_Update;
/

--96208:李小东,2016-05-16,部门人员最后修改时间修正
--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;15-人员表;16-人员照片;
  --        19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 15 Then
    If Cls_In = 1 Then
      Update 人员表 Set 签名图片 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In) For Update;
	Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    If Cls_In = 1 Then
      Update 人员照片 Set 照片 = Empty_Blob() Where 人员id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 人员照片 (人员id, 照片) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In) For Update;
	Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
	Update 部门表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
	Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  End If;

  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--94399:李小东,2016-04-08,部门、人员扩展信息维护
Create Or Replace Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形);8-电子病历附件;9-体温重叠标记;
  --        10-临床路径文件;11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录;15-人员表;16-人员照片;19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
Begin
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  Elsif Tab_In = 15 Then
    Select 签名图片 Into l_Blob From 人员表 Where ID = To_Number(Key_In);
  Elsif Tab_In = 16 Then
    Select 照片 Into l_Blob From 人员照片 Where 人员id = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    Return Null;
End Zl_Lob_Read;
/

--95546:马政,2016-04-08,领用不明确批次修改
Create Or Replace Procedure Zl_材料领用_Insert
(
  入出类别id_In In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  领用人_In     In 药品收发记录.领用人%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  病人id_In     In 材料领用信息.病人id%Type := Null,
  使用时间_In   In 材料领用信息.使用时间%Type := Null,
  条码_In       In 材料领用信息.条码%Type := Null,
  申购数量_In   In 药品收发记录.单量%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  v_编码         收费项目目录.编码%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_下库存       Zlparameters.参数值%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_入出系数     药品收发记录.入出系数%Type; --收发ID
  n_可用数量     药品库存.可用数量%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_收发id       药品收发记录.Id%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;

Begin
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;
  n_入出系数 := -1;
  Begin
    Select 可用数量, Decode(上次供应商id, 0, Null, 上次供应商id), 上次生产日期, 批准文号, 商品条码, 内部条码
    Into n_可用数量, n_上次供应商id, d_上次生产日期, v_批准文号, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      n_可用数量     := 0;
      n_上次供应商id := Null;
      d_上次生产日期 := Null;
      v_批准文号     := Null;
  End;

  If 批次_In > 0 Then
    If n_可用数量 - 填写数量_In < 0 Then
      Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
    
      v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的分批核算材料' || Chr(10) || Chr(13) || '可用库存数量不够！[ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;
  Select 药品收发记录_Id.Nextval Into n_收发id From Dual;

  --插入类别为出的那一笔
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价,
     摘要, 填制人, 填制日期, 供药单位id, 生产日期, 批准文号, 领用人, 商品条码, 内部条码, 单量)
  Values
    (n_收发id, 1, 20, No_In, 序号_In, 库房id_In, 对方部门id_In, 入出类别id_In, n_入出系数, 材料id_In, 批次_In, 产地_In, 批号_In, 效期_In, 灭菌效期_In,
     填写数量_In, 填写数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, n_上次供应商id, d_上次生产日期, v_批准文号,
     领用人_In, v_商品条码, v_内部条码, 申购数量_In);

  --同时更新库存数
  If v_下库存 = 1 Then
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - 填写数量_In
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  
    --不插入批次是因为批次材料不够，不准出库
    If Sql%NotFound Then
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;
    
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
      Values
        (库房id_In, 材料id_In, Nvl(批次_In, 0), 1, -填写数量_In, 效期_In, 灭菌效期_In, n_上次供应商id, 成本价_In, 批号_In, d_上次生产日期, 产地_In,
         v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, 零售价_In), Null));
    End If;
  
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  End If;

  If Nvl(病人id_In, 0) <> 0 Then
    --处理病人信息
    Insert Into 材料领用信息
      (收发id, 材料id, 病人id, 主页id, 姓名, 性别, 年龄, 床号, 医疗付款方式, 当前科室id, 当前病区id, 使用时间, 条码)
      Select n_收发id, 材料id_In, 病人id_In, 住院次数, 姓名, 性别, 年龄, 当前床号, 医疗付款方式, 当前科室id, 当前病区id, 使用时间_In, 条码_In
      From 病人信息
      Where 病人id = 病人id_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Insert;
/

Create Or Replace Procedure Zl_材料领用_Delete(
                                           --删除药品收发记录及恢复相应的表：药品库存
                                           No_In In 药品收发记录.No%Type) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(100);
  v_下库存   Zlparameters.参数值%Type;
  n_实价卫材 收费项目目录.是否变价%Type;

Begin
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;

  If v_下库存 = 1 Then
    --通过循环，恢复原来的可用数量
    For v_单据 In (Select ID, 填写数量, 库房id, 零售价, 批次, 批号, 药品id, 供药单位id, 成本价, 效期, 灭菌效期, 产地, 生产日期, 批准文号
                 From 药品收发记录
                 Where NO = No_In And 单据 = 20 And 入出系数 = -1
                 Order By 药品id) Loop
      Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = v_单据.药品id;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + v_单据.填写数量
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(批次, 0) = Nvl(v_单据.批次, 0) And 性质 = 1;
    
      If Sql%NotFound Then
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
        Values
          (v_单据.库房id, v_单据.药品id, v_单据.批次, 1, v_单据.填写数量, v_单据.效期, v_单据.灭菌效期, v_单据.供药单位id, v_单据.成本价, v_单据.批号, v_单据.生产日期,
           v_单据.产地, v_单据.批准文号, Decode(n_实价卫材, 1, Decode(Nvl(v_单据.批次, 0), 0, Null, v_单据.零售价), Null));
      End If;
    
      Delete From 药品库存
      Where 库房id = v_单据.库房id And 药品id = v_单据.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
            Nvl(实际差价, 0) = 0;
      Delete From 材料领用信息 Where 收发id = v_单据.Id;
    End Loop;
  End If;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 20 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Delete;
/


Create Or Replace Procedure Zl_材料领用_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  No_In         In 药品收发记录.No%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type,
  批次_In       In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  审核日期_In   In 药品收发记录.审核日期%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  审核方式_In   In Number := 0
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  v_负成本计算 Zlparameters.参数值%Type;
  v_编码       收费项目目录.编码%Type;
  v_批准文号   药品库存.批准文号%Type;

  d_上次生产日期 药品库存.上次生产日期%Type;
  d_效期         药品库存.效期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;

  n_可用数量     药品库存.可用数量%Type;
  n_实际数量     药品库存.实际数量%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_小数         Number(2);
  v_上次扣率     药品库存.上次扣率%Type;
  n_数量差       药品收发记录.实际数量%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  v_下库存       Zlparameters.参数值%Type;
Begin
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select Nvl(zl_GetSysParameter(95), '0') Into v_下库存 From Dual;
  --由于领用处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。

  Begin
    Select Nvl(可用数量, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_可用数量, n_实际数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  
  Exception
    When Others Then
      n_可用数量 := 0;
      n_实际数量 := 0;
      v_上次扣率 := 100;
      v_商品条码 := Null;
      v_内部条码 := Null;
  End;

  --取上次供应商ID
  Begin
    Select 供药单位id, 生产日期, 批准文号, 效期, 灭菌效期, 零售价
    Into n_上次供应商id, d_上次生产日期, v_批准文号, d_效期, d_灭菌效期, n_零售价
    From 药品收发记录
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 记录状态 = 1 And 序号 = 序号_In And Rownum = 1;
  
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_效期         := 效期_In;
  End;

  If 审核方式_In = 0 Then
    --出库审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率, 商品条码 = v_商品条码, 内部条码 = v_内部条码
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 审核人 Is Null;
  Elsif 审核方式_In = 1 Then
    --财务审核
    Begin
      Select 实际数量 - 实际数量_In
      Into n_数量差
      From 药品收发记录
      Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
    Exception
      When Others Then
        n_数量差 := Null;
    End;
  
    If n_数量差 Is Null Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 药品收发记录
    Set 配药人 = Nvl(审核人_In, 配药人), 配药日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = 成本价_In, 成本金额 = 成本金额_In, 零售金额 = 零售金额_In, 差价 = 差价_In,
        扣率 = v_上次扣率
    Where NO = No_In And 单据 = 20 And 药品id = 材料id_In And 序号 = 序号_In And 记录状态 = 1 And 配药人 Is Null;
  End If;

  If 批次_In > 0 And (n_可用数量 + n_数量差) < 0 Then
    Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
    v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的分批核算材料' || Chr(10) || Chr(13) || '可用库存数量不够！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  If 审核方式_In = 0 Then
    --审核
    If v_下库存 = 0 Then
      n_数量差 := -1 * 实际数量_In;
    End If;
  Else
    --核查
    If v_下库存 = 0 Then
      n_数量差 := 0;
    End If;
  End If;

  If 审核方式_In = 0 Then
    --出库审核处理实际库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差, 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In,
        实际差价 = Nvl(实际差价, 0) - 差价_In,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null), 商品条码 = v_商品条码,
        内部条码 = v_内部条码
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率,
         商品条码, 内部条码, 平均成本价)
      Values
        (库房id_In, 材料id_In, 批次_In, 1, -实际数量_In, -实际数量_In, -零售金额_In, -差价_In, d_效期, d_灭菌效期, n_上次供应商id, 成本价_In, 批号_In,
         d_上次生产日期, 产地_In, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码,
         成本价_In);
    End If;
  
    --重新计算库存表中的平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And Nvl(实际数量, 0) <> 0;
  
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 材料id_In;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 性质 = 1 And 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
    End If;
  
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  Elsif 审核方式_In = 1 Then
    --财务审核仅处理可用库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + n_数量差
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Verify;
/


--94404:张德婷,2016-04-08,静配中心性能问题
--94311:张德婷,2016-04-08,静配中心性能问题
CREATE OR REPLACE Procedure Zl_输液配药记录_销帐审核
(
  配药id_In   In Varchar2, --ID串:ID1,审核标志1,ID2,审核标志2....
  操作人员_In In 输液配药记录.操作人员%Type,
  操作时间_In In 输液配药记录.操作时间%Type
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_Usercode   Varchar2(100);
  v_发药id     药品收发记录.Id%Type;
  n_Count      Number(1);
  d_审核时间   药品收发记录.审核日期%Type;
  v_No         药品收发记录.No%Type;
  v_上次no     药品收发记录.No%Type;
  n_审核标志   Number(1);
  n_操作状态   Number(2);
  v_收发ids    Varchar2(4000);
  v_退药待发id 药品收发记录.Id%Type;
  v_原始id     药品收发记录.Id%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  Cursor c_销帐记录 Is
    Select Distinct a.费用id, b.操作时间
    From 药品收发记录 A, 输液配药记录 B, 输液配药内容 C
    Where a.Id = c.收发id And b.Id = c.记录id And b.Id = v_Tansid And b.操作状态 = 9;

  v_销帐记录 c_销帐记录%RowType;

  Cursor c_退药记录 Is
    Select Distinct a.Id As 退药id, c.收发id, c.数量
    From 药品收发记录 A, 药品收发记录 B, 输液配药内容 C
    Where c.记录id = v_Tansid And b.Id = c.收发id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And
          a.药品id + 0 = b.药品id And a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  v_退药记录 c_退药记录%RowType;

  Cursor c_费用销帐 Is
    Select a.No, a.序号 || ':' || c.数量 || ':' || c.记录id As 费用序号
    From 住院费用记录 A, 药品收发记录 B, 输液配药内容 C
    Where a.Id = b.费用id And b.Id = c.收发id And  Mod(b.记录状态, 3) = 1 and c.记录id = v_Tansid;

  v_费用销帐 c_费用销帐%RowType;

Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid   := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
    n_审核标志 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

    v_收发ids := Null;

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态<>9 then
        v_Error := '该数据已被操作，不能进行销帐审核！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    If n_审核标志 = 1 Then
      n_操作状态 := 10;
    Elsif n_审核标志 = 2 Then
      n_操作状态 := 11;
    End If;

    --查找输液单对应的收发NO
    Begin
      Select NO
      Into v_No
      From 药品收发记录
      Where ID In (Select 收发id From 输液配药内容 Where 记录id In (Select ID From 输液配药记录 Where ID = v_Tansid)) And Rownum < 2;
    Exception
      When Others Then
        v_No := '';
    End;

    --收发NO相同的配药ID，审核时间以此设置为延长1秒
    If v_No = v_上次no Then
      d_审核时间 := d_审核时间 + 1 / 24 / 60 / 60;
    Else
      d_审核时间 := 操作时间_In;
      v_上次no   := v_No;
    End If;

    --销帐记录处理
    For v_销帐记录 In c_销帐记录 Loop
      Zl_病人费用销帐_Audit(v_销帐记录.费用id, v_销帐记录.操作时间, 操作人员_In, d_审核时间, n_审核标志);
    End Loop;

    Select Count(*) Into n_Count From 输液配药状态 Where 配药id = v_Tansid And 操作时间 = 操作时间_In;

    If n_Count <> 1 Then
      Insert Into 输液配药状态
        (配药id, 操作类型, 操作人员, 操作时间)
      Values
        (v_Tansid, n_操作状态, 操作人员_In, 操作时间_In);
    End If;
    Update 输液配药记录 Set 操作人员 = 操作人员_In, 操作时间 = 操作时间_In, 操作状态 = n_操作状态 Where ID = v_Tansid;

    --退药处理
    If n_审核标志 = 1 Then
      For v_退药记录 In c_退药记录 Loop
        Zl_药品收发记录_部门退药(v_退药记录.退药id, 操作人员_In, 操作时间_In, Null, Null, Null, v_退药记录.数量, Null, 操作人员_In);

        --取退药待发id
        Select a.Id
        Into v_发药id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 1 And a.审核日期 Is Null;
              
        --输液配药内容中的收发ID更新为退药待发的收发ID
        Update 输液配药内容 Set 收发id = v_发药id Where 记录id = v_Tansid And 收发id = v_退药记录.收发id;

        If v_收发ids Is Null Then
          v_收发ids := v_发药id;
        Else
          v_收发ids := v_收发ids || ',' || v_发药id;
        End If;

        --取原始id
        Select a.Id
        Into v_原始id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 0 And a.审核日期 Is Not Null;
              
        insert into 输液配药内容(记录id,收发id,数量) select 记录id,v_原始id ,数量 from 输液配药内容 where 记录id=v_Tansid and 收发id=v_发药id;
        
        v_收发ids := v_收发ids || ',' || v_原始id;
      End Loop;
      
      --费用销帐
      For v_费用销帐 In c_费用销帐 Loop
        Zl_住院记帐记录_Delete(v_费用销帐.No, v_费用销帐.费用序号, v_Usercode, Zl_Username, 2, 1, 1, d_审核时间);
      End Loop;
    End If;
  End Loop;
Exception
   When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_销帐审核;
/

--93299:刘尔旋,2016-04-07,结帐三方卡处理
Create Or Replace Procedure Zl_结帐预交记录_三方退款
(
  Id_In         病人预交记录.Id%Type,
  No_In         病人预交记录.No%Type,
  是否退现_In   Number,
  冲预交_In     病人预交记录.冲预交%Type,
  结帐id_In     病人结帐记录.Id%Type,
  病人id_In     病人预交记录.病人id%Type,
  操作员编号_In 病人预交记录.操作员编号%Type := Null,
  操作员姓名_In 病人预交记录.操作员姓名%Type := Null,
  收款时间_In   病人预交记录.收款时间%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null
) As
  -----------------------------------------------------------
  --功能：处理一行病人结帐时的冲预交记录
  --     冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  --说明：ID_IN=空：表示冲历史余额预交记录
  -----------------------------------------------------------

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  n_返回值   病人余额.预交余额%Type;
  n_类别     病人预交记录.预交类别%Type;
  n_病人id   病人预交记录.病人id%Type;
  n_缴款组id 病人预交记录.缴款组id%Type;
  v_现金     结算方式.名称%Type;

  Cursor c_Balance_Record Is
    Select Max(m.病人id) As 病人id, Max(NO) As NO, Max(实际票号) As 实际票号, Max(Nvl(收款时间_In, m.收费时间)) As 收款时间,
           Max(Nvl(操作员编号_In, m.操作员编号)) As 操作员编号, Max(Nvl(m.操作员姓名, 操作员姓名_In)) As 操作员姓名,
           Max(Nvl(n_缴款组id, m.缴款组id)) As 缴款组id, Max(结帐类型) As 结帐类型
    From 病人结帐记录 M
    Where m.Id = 结帐id_In;
  r_Balance_Record c_Balance_Record%RowType;

Begin
  If 操作员姓名_In Is Null Then
    n_缴款组id := Null;
  Else
    n_缴款组id := Zl_Get组id(操作员姓名_In);
  End If;

  Open c_Balance_Record;

  Fetch c_Balance_Record
    Into r_Balance_Record;

  If c_Balance_Record%RowCount = 0 Then
    v_Err_Msg := '未找到结帐记录,可能因为并发原因删除了结帐数据,无法继续退款!';
    Raise Err_Item;
  End If;

  If Id_In <> 0 Then
    --第一次冲预交
    Update 病人预交记录
    Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2
    Where ID = Id_In
    Returning 预交类别 Into n_类别;
    If Nvl(n_类别, 0) = 0 Then
      n_类别 := 2;
    End If;
  End If;

  If 是否退现_In = 1 Then
    --冲上次剩余额
    Select 名称
    Into v_现金
    From (Select 名称 From 结算方式 Where 性质 = 1 Order By Nvl(缺省标志, 0) Desc, 编码)
    Where Rownum < 2;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 冲预交_In
    Where 结算方式 = 结算方式_In And NO = No_In And 结帐id = 结帐id_In And 记录性质 = 11;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, 冲预交_In, 结帐id_In,
               r_Balance_Record.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 + (-1 * 冲预交_In)
    Where 结算方式 = v_现金 And 结帐id = 结帐id_In And Mod(记录性质, 10) = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, Null, v_现金, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, -1 * 冲预交_In, 结帐id_In,
               r_Balance_Record.缴款组id, 预交类别, Null, Null, Null, Null, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = 结帐id_In And Mod(记录性质, 10) = 2 And Rownum < 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, r_Balance_Record.No, r_Balance_Record.实际票号, 2, 1, 病人id, 主页id, 科室id, Null, v_现金, 结算号码,
                 摘要, 缴款单位, 单位开户行, 单位帐号, r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号,
                 -1 * 冲预交_In, 结帐id_In, r_Balance_Record.缴款组id, Null, Null, Null, Null, Null, Null, 合作单位, 2
          From 病人预交记录
          Where 结帐id = 结帐id_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
      End If;
    End If;
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + (-1 * 冲预交_In)
    Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_现金 And 性质 = 1
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (r_Balance_Record.操作员姓名, v_现金, 1, -1 * 冲预交_In);
      n_返回值 := 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_现金 And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  
    Begin
      Select 预交类别, 病人id
      Into n_类别, n_病人id
      From 病人预交记录
      Where NO = No_In And 记录性质 In (1, 11) And Rownum < 2;
    Exception
      When Others Then
        n_类别 := 2;
    End;
    n_病人id := Nvl(n_病人id, 病人id_In);
  
    --病人余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (n_病人id, 1, Nvl(n_类别, 2), -1 * 冲预交_In, 0);
      n_返回值 := -1 * 冲预交_In;
    End If;
  
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  Else
    --原样退
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 冲预交_In
    Where 结算方式 = 结算方式_In And NO = No_In And 结帐id = 结帐id_In And 记录性质 = 11;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 1, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, 冲预交_In, 结帐id_In,
               r_Balance_Record.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 - 冲预交_In
    Where 结算方式 = 结算方式_In And 结帐id = 结帐id_In And Mod(记录性质, 10) = 2;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, r_Balance_Record.No, r_Balance_Record.实际票号, 2, 1, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码,
               摘要, 缴款单位, 单位开户行, 单位帐号, r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, -1 * 冲预交_In,
               结帐id_In, r_Balance_Record.缴款组id, Null, 卡类别id, 结算卡序号, Null, Null, Null, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
    Begin
      Select 预交类别, 病人id
      Into n_类别, n_病人id
      From 病人预交记录
      Where NO = No_In And 记录性质 In (1, 11) And Rownum < 2;
    Exception
      When Others Then
        n_类别 := 2;
    End;
    n_病人id := Nvl(n_病人id, 病人id_In);
  
    --病人余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (n_病人id, 1, Nvl(n_类别, 2), -1 * 冲预交_In, 0);
      n_返回值 := -1 * 冲预交_In;
    End If;
  
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  End If;
  Close c_Balance_Record;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐预交记录_三方退款;
/

--97401:刘尔旋,2016-06-14,结帐使用门诊票据作废问题
--92159:刘尔旋,2016-05-30,结帐作废红票
--94759:刘尔旋,2016-04-06,结帐误差费处理问题
Create Or Replace Procedure Zl_病人结帐记录_Delete
(
  No_In           病人结帐记录.No%Type,
  操作员编号_In   病人结帐记录.操作员编号%Type,
  操作员姓名_In   病人结帐记录.操作员姓名%Type,
  误差金额_In     病人预交记录.冲预交%Type := 0, --医保或预交退现金产生的误差
  结帐作废结算_In Varchar2 := Null, --结算方式|结算金额|结算号码||......
  预交退现金_In   Number := 0, --当预交款退现金时，结算方式及金额通过参数结帐作废结算_In传入
  冲销id_In       病人预交记录.结帐id%Type := Null,
  冲销时间_In     Date := Null,
  缴预交id_In     病人预交记录.Id%Type := Null, --在作废时将相关的金额充值到预交款时填写
  票据号_In       病人结帐记录.实际票号%Type := Null,
  领用id_In       票据领用记录.Id%Type := Null,
  票种_In         票据使用明细.票种%Type := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --该游标用于预交记录相关信息
  Cursor c_Deposit(v_Id 病人预交记录.结帐id%Type) Is
    Select 病人id, 记录性质, 结算方式, 冲预交, 预交类别 From 病人预交记录 Where 结帐id = v_Id;
  r_Depositrow c_Deposit%RowType;

  --该游标用于处理费用相关汇总表
  Cursor c_Money(v_Id 病人预交记录.结帐id%Type) Is
    Select NO, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 病人id, 主页id, 收入项目id, 门诊标志, 结帐金额
    From 住院费用记录
    Where 结帐id = v_Id
    Union All
    Select NO, 开单部门id, 病人科室id, 执行部门id, 0 As 病人病区id, 病人id, 0 As 主页id, 收入项目id, 门诊标志, 结帐金额
    From 门诊费用记录
    Where 结帐id = v_Id;

  r_Moneyrow c_Money%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_实际票号 病人预交记录.实际票号%Type;
  v_误差no   住院费用记录.No%Type;
  v_误差     结算方式.名称%Type;
  n_病人id   病人信息.病人id%Type;

  n_原id   病人结帐记录.Id%Type;
  n_结帐id 病人结帐记录.Id%Type;
  n_打印id 票据打印内容.Id%Type;

  n_来源     Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值   病人余额.预交余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_预交类别 Number;
  d_Date     Date;
  n_预交id   病人预交记录.Id%Type;
  n_卡结算id 病人结帐记录.Id%Type;
  v_打印id   票据打印内容.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select 名称 Into v_误差 From 结算方式 Where 性质 = 9 And Rownum = 1;

  Begin
    Select ID, 病人id, 实际票号 Into n_原id, n_病人id, v_实际票号 From 病人结帐记录 Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  d_Date := 冲销时间_In;
  If d_Date Is Null Then
    Select Sysdate Into d_Date From Dual;
  End If;

  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
  
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 3, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 票种_In, 票据号_In, 1, 6, 领用id_In, v_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  End If;

  n_结帐id := 冲销id_In;
  If Nvl(n_结帐id, 0) = 0 Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  End If;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, d_Date, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 In (1,3) And 性质 = 1;
  End If;

  --病人预交记录(冲预交及缴款)
  If 结帐作废结算_In Is Null Then
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id, Null,
             结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 合作单位, 2
      From 病人预交记录
      Where 结帐id = n_原id And (记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0 Or 记录性质 Not In (1, 11));
  
    --消费卡处理
    For c_消费卡结算 In (Select a.Id, a.结算卡序号, Nvl(b.名称, '消费卡') As 卡名称
                    From 病人预交记录 A, 卡消费接口目录 B
                    Where a.结算卡序号 = b.编号(+) And a.结帐id = n_原id And Nvl(a.结算卡序号, 0) <> 0) Loop
      Select ID
      Into n_预交id
      From 病人预交记录
      Where 结帐id = n_结帐id And 结算卡序号 = Nvl(c_消费卡结算.结算卡序号, 0);
    
      For c_消费卡 In (Select a.Id, a.接口编号, a.消费卡id, a.序号, a.记录状态, a.结算方式, a.结算金额, a.卡号, a.交易流水号, a.交易时间, a.备注, a.结算标志,
                           b.停用日期, b.回收时间
                    From 病人卡结算记录 A, 消费卡目录 B
                    Where a.消费卡id = b.Id(+) And
                          a.Id In (Select 卡结算id From 病人卡结算对照 Where 预交id = c_消费卡结算.Id)) Loop
      
        If Nvl(c_消费卡.停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经被他人停用，不能再进行结帐作废,请检查！';
          Raise Err_Item;
        End If;
      
        If c_消费卡.回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Select 病人卡结算记录_Id.Nextval Into n_卡结算id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_卡结算id, c_消费卡结算.结算卡序号, c_消费卡.消费卡id, c_消费卡.序号, 2, c_消费卡.结算方式, -1 * c_消费卡.结算金额, c_消费卡.卡号, c_消费卡.交易流水号, d_Date,
           Null, 0);
      
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_卡结算id);
      
        Update 消费卡目录 Set 余额 = 余额 + c_消费卡.结算金额 Where ID = c_消费卡.消费卡id;
        If Sql%NotFound Then
          v_Err_Msg := '卡号为' || c_消费卡.卡号 || '的' || c_消费卡结算.卡名称 || '未找到!';
          Raise Err_Item;
        End If;
      End Loop;
    End Loop;
  
  Else
    --1.先处理冲预交部分
    If 预交退现金_In = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = n_原id And 记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0;
    End If;
  
    --2.再处理结帐结算,包括医保和非医保
    v_结算内容 := 结帐作废结算_In || ' ||'; --以空格分开以|结尾,没有结算号码的
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐作废退款',
         Null, Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, -1 * n_结算金额, n_结帐id, n_组id, 2);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;
  --确定结帐的费用记录来源
  Begin
    Select Case
             When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
              3
             When Nvl(Max(住院), 0) = 1 Then
              2
             Else
              1
           End
    Into n_来源
    From (Select 1 As 住院, 0 As 门诊
           From 住院费用记录
           Where 结帐id = n_原id And Rownum = 1
           Union All
           Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原id And Rownum = 1);
  
  Exception
    When Others Then
      n_来源 := 3;
  End;

  If 误差金额_In <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 误差金额_In
    Where NO = No_In And 记录性质 = 12 And 记录状态 = 1 And 结帐id = n_结帐id;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_误差, Null, '结帐作废退款', Null,
         Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, 误差金额_In, n_结帐id, n_组id, 2);
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原id;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原id;
  End If;
  --相关汇总表处理
  For r_Depositrow In c_Deposit(n_结帐id) Loop
    If r_Depositrow.记录性质 In (1, 11) Then
    
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Depositrow.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Depositrow.病人id And 类型 = Nvl(r_Depositrow.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Depositrow.病人id, 1, Nvl(r_Depositrow.预交类别, 2), -1 * r_Depositrow.冲预交, 0);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 性质 = 1 And 病人id = r_Depositrow.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Depositrow.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Depositrow.结算方式, 1, r_Depositrow.冲预交);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;

  For r_Moneyrow In c_Money(n_结帐id) Loop
    --病人余额 ,误差项已结帐,所以不需要更新这两个汇总表
    If Nvl(v_误差no, 'sc') <> Nvl(r_Moneyrow.No, 'sc') Then
      If Nvl(r_Moneyrow.门诊标志, 0) = 1 Or Nvl(r_Moneyrow.门诊标志, 0) = 2 Then
        n_预交类别 := r_Moneyrow.门诊标志;
      Elsif Nvl(r_Moneyrow.主页id, 0) = 0 Or Nvl(r_Moneyrow.门诊标志, 0) = 4 Then
        --体检:门诊病人
        n_预交类别 := 1;
      Else
        n_预交类别 := 2;
      End If;
    
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - r_Moneyrow.结帐金额 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Moneyrow.病人id And 类型 = n_预交类别 And 性质 = 1
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, n_预交类别, 0, -1 * r_Moneyrow.结帐金额);
        n_返回值 := -1 * r_Moneyrow.结帐金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_Moneyrow.结帐金额
      Where 病人id = r_Moneyrow.病人id And Nvl(主页id, 0) = Nvl(r_Moneyrow.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Moneyrow.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Moneyrow.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Moneyrow.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Moneyrow.执行部门id, 0) And
            收入项目id + 0 = r_Moneyrow.收入项目id And 来源途径 + 0 = r_Moneyrow.门诊标志;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Moneyrow.病人id, Decode(r_Moneyrow.主页id, Null, Null, 0, Null, r_Moneyrow.主页id),
           Decode(r_Moneyrow.病人病区id, Null, Null, 0, Null, r_Moneyrow.病人病区id), r_Moneyrow.病人科室id, r_Moneyrow.开单部门id,
           r_Moneyrow.执行部门id, r_Moneyrow.收入项目id, r_Moneyrow.门诊标志, -1 * r_Moneyrow.结帐金额);
      End If;
    End If;
  End Loop;

  If Nvl(缴预交id_In, 0) <> 0 Then
    --作废时将退款金额充值到预交款帐户,这里标明是本次结帐缴存的
    Update 病人预交记录 Set 结帐id = 冲销id_In Where ID = 缴预交id_In And 结帐id Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '未找到对应的预交款记录！';
      Raise Err_Item;
    End If;
  End If;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Delete;
/


--94920:许华峰,2016-04-06,依赖性接口获取报告内容
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2
) Return Xmltype
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
 Is
  File_Id Varchar2(32);
  Docxml  Xmltype;
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  n_Adviceid Number(18);
  v_Ftppath  Varchar2(200);

  n_Count Number(1);
  --标记变量
  n_i       Number(2);
  n_Len     Number(3);
  n_Width   Number(4);
  n_Height  Number(4);
  v_Id      Varchar2(100);
  v_Ftppath Varchar2(500);
  v_Title   Varchar2(100);
  v_Newline Varchar2(2);
  v_Text    Varchar2(4000);
  v_Name    Varchar2(100);
  v_Type    Varchar2(20);

  x_Content    Xmltype;
  Section_Node Xmldom.Domnode;
  Element_Node Xmldom.Domnode;
  Xcdom        Xmldom.Domdocument;
  Node_List    Xmldom.Domnodelist;
  Section_List Xmldom.Domnodelist;

  Function Getorigpic(Pic_Id In 电子病历记录.Id%Type) Return Xmltype Is
    --读取病历图形，以多个 <OrigPic>节点返回，每个节点<=2000长度
    l_Blob   Blob;
    v_Buffer Varchar2(32767);
    n_Amount Number := 2000;
    n_Offset Number := 1;
    Pos_In   Number := 0;
    Origpic  Xmltype;
    Origpics Xmltype;
  Begin
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = Pic_Id;
    While True Loop
      n_Offset := 1 + Pos_In * n_Amount;
      n_Amount := 2000;
      v_Buffer := '';
      Begin
        Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
      Exception
        When No_Data_Found Then
          Exit;
      End;
    
      If Length(v_Buffer) = 0 Then
        Exit;
      Else
        Select Xmlelement("OrigPic", Xmlattributes(Pos_In As "序号"), v_Buffer) Into Origpic From Dual;
      End If;
      Select Xmlconcat(Origpics, Origpic) Into Origpics From Dual;
      Pos_In := Pos_In + 1;
    End Loop;
    Return Origpics;
  End Getorigpic;
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';

  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    If File_Id Is Null Then
      Exit;
    Else
      --判断是新版报告还是老版报告,有记录则是新版报告
      Select Count(1)
      Into n_Count
      From 影像报告记录 A, 病人医嘱报告 B
      Where a.Id = Hextoraw(File_Id) And a.Id = b.检查报告id;
    
      If n_Count > 0 Then
        --开始某个文件读取
        Begin
          Select a.医嘱id,
                 Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                            Rawtohex(a.Id) As "文件ID")))
          Into n_Adviceid, Docxml
          From 影像报告记录 A, 病人医嘱记录 B
          Where a.Id = Hextoraw(File_Id) And a.医嘱id = b.Id;
        Exception
          --给定的文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;
      
        --开始读取内容
        Select b.报告内容 Into x_Content From 影像报告记录 B Where b.Id || '' = File_Id;
      
        Xcdom := Xmldom.Newdomdocument(x_Content);
      
        n_i := -1;
      
        Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
        Section_Node := Xmldom.Item(Section_List, 0);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);
      
        For I In 0 .. n_Len - 1 Loop
          Element_Node := Xmldom.Item(Node_List, I);
        
          v_Name    := Xmldom.Getnodename(Element_Node);
          v_Newline := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');
        
          If v_Newline Is Null Then
            v_Newline := '1';
          End If;
        
          If v_Name = 'section' Then
            --提纲
            v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Id    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');
          
            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                                   Xmlelement("Compend", Xmlattributes(v_Title As "Name", v_Id As "ID")))
            Into Docxml
            From Dual;
          Elsif v_Name = 'utext' Then
            --文本
            v_Text := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml
              From Dual;
            End If;
          Elsif v_Name = 'element' Then
            --要素
            v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Text  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                       Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                                 v_Text))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                                 v_Text))
              Into Docxml
              From Dual;
            End If;
          Elsif v_Name = 'image' Then
            --图片
            n_Width  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
            n_Height := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
            v_Name   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');
            v_Type   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'class');
          
            If Nvl(v_Name, ' ') <> ' ' Then
              If Nvl(v_Id, ' ') = ' ' Then
                Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                                  n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                                  v_Name As "PicName", n_Adviceid As "AdviceID",
                                                                  v_Type As "Type")))
                Into Docxml
                From Dual;
              Else
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                                  n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                                  v_Name As "PicName", n_Adviceid As "AdviceID",
                                                                  v_Type As "Type")))
                Into Docxml
                From Dual;
              End If;
            End If;
          
          Elsif v_Name = 'signature' Then
            --签名
            v_Text := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');
          
            If Nvl(v_Id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      
        For Aa In (Select '/' || a.Ftp目录 || '/ReportImages/' || To_Char(b.创建时间, 'YYYYMMDD') || '/' || b.Id || '/' As v_Ftppath
                   From 影像设备目录 A, 影像报告记录 B
                   Where a.设备号 = b.设备号 And b.Id = File_Id) Loop
        
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
          Into Docxml
          From Dual;
        End Loop;
      Else
        --开始某个病历文件读取
        Begin
          Select Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                            a.Id As "文件ID")))
          Into Docxml
          From 电子病历记录 A, 病人信息 B
          Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;
        
          Select 医嘱id Into n_Adviceid From 病人医嘱报告 Where 病历id = File_Id;
        Exception
          --给定的病历文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;
      
        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                               Xmlelement("Text", Xmlattributes(Nvl(Null, 0) As "NewLine"), '内容文本'))
        Into Docxml
        From Dual;
      
        For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                   From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                          From 电子病历内容
                          Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
                   Start With 父id Is Null
                   Connect By Prior ID = 父id
                   Order Siblings By 对象序号, 内容行次) Loop
          If Rs.对象类型 = 1 Then
            --提纲
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 2 Then
            --文本
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 3 Then
            --表格
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          
            ---对表格的单元格进行填充
            For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                            From 电子病历内容
                            Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                            Order By 内容行次, ID) Loop
              If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
                If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
                  --兼容历史病历
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                Else
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
              
                If Nvl(n_Adviceid, 0) = 0 Then
                  n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                        ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                        Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
                --制作标记子节点集
                v_Mark  := '';
                Makxml  := Null;
                Maksxml := Null;
                For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                                From 电子病历内容
                                Where 父id = Rs_Cell.Id
                                Order By 内容行次) Loop
                  v_Marks := v_Mark || Rs_Mark.内容文本;
                  v_Marks := Replace(v_Marks, '||', '^');
                  For I In 1 .. 100 Loop
                    v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                    If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                      --最后一个标记信息不全，存在下一行中
                      Exit;
                    Else
                      Select Xmlelement("Mark",
                                         Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型",
                                                    Zl_Eprsplit(v_Mark, '|', 3) As "内容", Zl_Eprsplit(v_Mark, '|', 4) As "点集",
                                                    Zl_Eprsplit(v_Mark, '|', 5) As "X1", Zl_Eprsplit(v_Mark, '|', 6) As "Y1",
                                                    Zl_Eprsplit(v_Mark, '|', 7) As "X2", Zl_Eprsplit(v_Mark, '|', 8) As "Y2",
                                                    Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                    Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                    Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                    Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                    Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                    Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                    Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                      Into Makxml
                      From Dual;
                      Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                    End If;
                  End Loop;
                End Loop;
                --向Picture插入标记子节点
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                       Maksxml)
                Into Docxml
                From Dual;
              End If;
            End Loop;
          Elsif Rs.对象类型 = 4 Then
            --要素
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
            --图片
            /*Picxml := Getorigpic(Rs.Id);--由Webservice直接读取BLOB之后直接写文件以提高速度*/
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            End If;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                Zl_Eprsplit(v_Mark, '|', 11) As "线条色", Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          Elsif Rs.对象类型 = 7 Then
            --诊断
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 8 Then
            --签名
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      
        For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
                   From 影像检查记录 L, 影像设备目录 A1
                   Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop
        
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
          Into Docxml
          From Dual;
        End Loop;
      End If;
    End If;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--94539:刘尔旋,2016-04-05,三方机构退号处理预交缴款挂号记录的问题
Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  n_退号重用       Number(3);
  n_预交支付       Number(3);
  n_正常支付       Number(3);
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;
Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Custom;
  End If;
  v_操作员编号 := Zl_操作员(1, v_Temp);
  v_操作员姓名 := Zl_操作员(2, v_Temp);

  n_组id := Zl_Get组id(v_操作员姓名);

  d_退号时间 := 退号时间_In;
  If d_退号时间 Is Null Then
    d_退号时间 := Sysdate;
  End If;

  --首先判断要退号/取消预约的记录是否存在
  Begin
    Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0), Decode(记录状态, 0, 1, 0)
    Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
  Exception
    When Others Then
      n_预约挂号 := -1;
  End;

  If n_预约挂号 = -1 Then
    v_Error := '单据可能已经被退号或单据输入错误!';
    Raise Err_Custom;
  End If;

  Begin
    Select 1
    Into n_启用分时段
    From 挂号安排 A, 挂号安排时段 B
    Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --预约检查是否添加合作单位控制
  --如果设置了合作单位控制 则
  Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
  --更新挂号序号状态
  n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
  If n_退号重用 = 0 Then
    Update 挂号序号状态
    Set 状态 = 4
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  Else
    Delete 挂号序号状态
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  End If;
  If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
    If Nvl(n_无效单据, 0) = 0 Then
      --N天内不能取消预约号
      n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
      If n_Count <> 0 Then
        If Trunc(Sysdate - n_Count) < d_登记时间 Then
          v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_状态 := Case n_无效单据
              When 1 Then
               0
              Else
               1
            End;
    --减少已约数
    Open c_Registinfo(n_状态, 2, n_无效单据);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
    End If;
  
    If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
      Update 合作单位挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
            序号 = Nvl(n_号序, 0);
      If Sql%RowCount = 0 Then
        Insert Into 合作单位挂号汇总
          (日期, 号码, 已约数, 合作单位, 序号, 已接数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
      End If;
    End If;
    Close c_Registinfo;
  
    If Nvl(n_无效单据, 0) = 0 Then
      --删除门诊费用记录
      Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
      --如果预约生成队列时需要清除队列
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If Nvl(n_挂号生成队列, 0) = 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
        If Nvl(n_预约生成队列, 0) = 1 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    End If;
  Else
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  
    --更新挂号序号状态
  
    --病人就诊状态
    Select 病人id Into n_病人id From 门诊费用记录 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
  
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
    End If;
  
    --门诊费用记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
             Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  
    Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    Select 结帐id
    Into n_原结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
  
    Select Count(Distinct 结算方式) Into n_Count From 病人预交记录 Where 结帐id = n_原结帐id;
    If n_Count > 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    n_预交id := 预交id_In;
    If Nvl(预交id_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    Begin
      Select 1
      Into n_预交支付
      From 病人预交记录
      Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
    Exception
      When Others Then
        n_预交支付 := 0;
    End;
    Begin
      Select 1
      Into n_正常支付
      From 病人预交记录
      Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
    Exception
      When Others Then
        n_正常支付 := 0;
    End;
    If n_预交支付 = 1 And n_正常支付 = 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    If n_预交支付 = 1 Then
      --原样退回预交
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select n_预交id, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间, v_操作员姓名,
               v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
      --处理病人预交余额 
      For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                   Group By 病人id, 预交类别) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
        Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 预交余额, 性质, 类型)
          Values
            (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
          n_返回值 := Nvl(c_预交.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明, 合作单位,
         结算序号, 卡类别id, 结算性质)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
               交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
        From 病人预交记录
        Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
    
      Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
    End If;
    --退卡收回票据(可能上次挂号使用票据,不能收回)
    Begin
      --从最后一次的打印内容中取
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If n_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
        From 票据使用明细
        Where 打印id = n_打印id And 性质 = 1;
    End If;
  
    --相关汇总表的处理
  
    --病人挂号汇总
    Open c_Registinfo(1, 1);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
        Into n_预约挂号, n_执行状态
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
      --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
      If n_执行状态 > 0 Then
        If n_执行状态 = 1 Then
          v_Error := '该病人已经完成就诊,不能再退号!';
        Else
          v_Error := '该病人正在就诊, 不能退号!';
        End If;
        Raise Err_Custom;
      End If;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
        End If;
      End If;
      Close c_Registinfo;
    End If;
  
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
  End If;

  If Nvl(n_无效单据, 0) = 0 Then
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
    If Sql%NotFound Then
      v_Error := '未找到挂号单据,请检查!';
      Raise Err_Custom;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
      Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
             发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 = 3;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/

--94851:涂建华,2016-04-05,Pacs文档编辑器词句或插件加载时机
CREATE OR REPLACE Package b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	);
  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
	Stop_Flag    Number,
	Condition_In Varchar2
	);
  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
	种类_In         影像报告原型清单.种类%Type,
	编码_In         影像报告原型清单.编码%Type,
	名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
	说明_In         影像报告原型清单.说明%Type,
	可否重置页面_In 影像报告原型清单.可否重置页面%Type,
	可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
	是否禁用_In     影像报告原型清单.是否禁用%Type,
	创建人_In       影像报告原型清单.创建人%Type,
	内容_In         影像报告原型清单.内容%Type,
	控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
	专用插件_In     影像报告原型清单.专用插件%Type,
	Copy_Id_In      影像报告原型清单.ID%Type,
	Only_Head_In    Varchar2,
	分组_In         影像报告原型清单.分组%Type
	);
  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_Id_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	);
  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);
  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	);
  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind;
  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);
  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
	编码_In 影像报告预备提纲.编码%Type,
	名称_In 影像报告预备提纲.名称%Type,
	说明_In 影像报告预备提纲.说明%Type
	);
  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline;
  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	);
  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	);
  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	);
  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
    Val           Out t_Refcur,		
	原型ID_In 影像报告原型片段.原型ID%Type,
    片段ID_In 影像报告原型片段.片段ID%Type
	);
  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    Id_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	);
  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	);
  --21.获取已经设置了关联的原型片段类别的信息

  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型id_In Varchar2
	);
  --23.获取能复制的原型名称

  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型id_In 影像报告原型清单.Id%Type
	);
  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	);
  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	);
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	);
  --29.获取关于原型导出的重复信息

  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
    Id_In        影像报告原型清单.Id%Type,
    编码_In      Varchar2,
    名称_In      Varchar2
	);
  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,	
	Id_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	);
  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	);

  ----32.获取元素或者提纲的名称集合
  --Procedure p_Get_Antetype_Ele_Section(
  --原型ID_In  影像报告原型清单.Id%Type,
  --Val     Out t_Refcur);

  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型id_In 影像报告动作.原型id%Type
	);

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	);
  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	);

  --37.获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	);
  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	);
  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	);
  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	);
  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	);
  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type
	);
  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	);
  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	);
  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	);
  --50.删除文档处理
  Procedure p_Del_Doc_Process(
    Id_In        影像报告动作.ID%Type,
	Del_Event_In Number
	);

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	);
  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	);
  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
	Val           Out t_Refcur,
	ID_In Varchar2
	);
  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	);
  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
    编码_In 影像报告插件.编码%Type,
    名称_In 影像报告插件.名称%Type
	);
  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	);
  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
    条件_In Varchar2
	);
  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	);
  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
	应用场合_In   影像报告原型应用.应用场合%Type,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	);
  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
    名称_In 影像报告原型清单.名称%Type,
    ID_In  影像报告原型清单.ID%Type
	);

  --69  获取影像存储设备
  Procedure p_GetStorageDevice(
		Val           Out t_Refcur);

End b_PACS_RptAntetype;
/

--影像报告原型管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, a.名称, a.编码 || '-' || a.名称 As 标题
        From 影像报告种类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelistkind;

  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
    Stop_Flag    Number,
    Condition_In Varchar2
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And a.分组 Is Not Null
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.
               种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelis_By_Kind;

  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    创建人_In       影像报告原型清单.创建人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str Xmltype;
  Begin
    Begin
      If Copy_ID_In Is Null or Copy_ID_In = 0 Then
        x_Str := 内容_In;
      Else
        Select Decode(Only_Head_In,
                      1,
                      Deletexml(a.内容, '/zlxml/document/node()'),
                      a.内容)
          Into x_Str
          From 影像报告原型清单 A
         Where a.id = Copy_ID_In;
      End If;
    Exception
      When Others Then
        x_Str := 内容_In;
    End;
  
    Insert Into 影像报告原型清单
      (ID,
       种类,
       编码,
       名称,
	   设备号,
       说明,
       可否重置页面,
       可否重置格式,
	   可否书写多份,
       是否禁用,
       创建人,
       创建时间,
       内容,
       控制选项,
	   词句加载时机,
	   插件加载时机,
       专用插件,
       分组)
    Values
      (ID_In,
       种类_In,
       编码_In,
       名称_In,
	   设备号_In,
       说明_In,
       可否重置页面_In,
       可否重置格式_In,
	   可否书写多份_In,
       是否禁用_In,
       创建人_In,
       sysdate,
       x_Str,
       控制选项_In,
	   词句加载时机_In,
	   插件加载时机_In,
       专用插件_In,
       分组_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetypelist;

  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str     Xmltype;
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告原型清单 A
     Where (a.编码 = 编码_In Or a.名称 = 名称_In)
       And ID <> ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在相同的文档编码或者名称，请重新填写！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Copy_ID_In Is Null or Copy_ID_In = 0 Then
      x_Str := 内容_In;
    Else
      Select Decode(Only_Head_In,
                    1,
                    Deletexml(a.内容, '/zlxml/document/node()'),
                    a.内容)
        Into x_Str
        From 影像报告原型清单 A
       Where a.id = Copy_ID_In;
    End If;
  
    Update 影像报告原型清单
       Set 种类         = 种类_In,
           编码         = 编码_In,
           名称         = 名称_In,
		   设备号		= 设备号_In,
           说明         = 说明_In,
           可否重置页面 = 可否重置页面_In,
           可否重置格式 = 可否重置格式_In,
		   可否书写多份 = 可否书写多份_In,
           是否禁用     = NVL(是否禁用_In, 是否禁用),
           修改人       = 修改人_In,
           修改时间     = sysdate,
           内容         = x_Str,
           控制选项     = 控制选项_In,
		   词句加载时机 =词句加载时机_In,
		   插件加载时机 =插件加载时机_In,
           专用插件     = 专用插件_In,
           分组         = 分组_In
     Where ID = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist;

  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(ID) Into n_Num From 影像报告记录 A Where a.原型id = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该原型已经被文档使用，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(原型ID)
      Into n_Num
      From 影像报告原型片段
     Where 影像报告原型片段.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该文档下存在词句关联，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(ID)
      Into n_Num
      From 影像报告范文清单
     Where 影像报告范文清单.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在以此原型建立的范文信息，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告原型清单 C Where c.Id = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetypelist;

  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select rawtohex(a.ID) ID,
             a.种类,
             a.编码,
             a.名称,
			 a.设备号,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
			 a.可否书写多份,
             Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
             Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
             Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
             Nvl(a.控制选项.GetClobVal(), '<NULL/>') as 控制选项,
			 a.词句加载时机,
			 a.插件加载时机,
             a.是否禁用,
             Nvl(a.专用插件.GetClobVal(), '<NULL/>') as 专用插件,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             a.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_By_Id;

  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Content;

  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 是否禁用 = Decode(是否禁用, 1, 0, 0, 1)
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Stop_Antetypelist;

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告种类 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 编码_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告种类
      (编码, 名称, 说明)
    Values
      (编码_In, 名称_In, 说明_In);
  
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Kind;

  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind As
  Begin
    Delete From 影像报告种类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Kind;

  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID, 编码, 名称, 说明, 最后编辑时间
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Pre_Outline;

  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
    编码_In 影像报告预备提纲.编码%Type,
    名称_In 影像报告预备提纲.名称%Type,
    说明_In 影像报告预备提纲.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告预备提纲 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 名称_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告预备提纲
      (ID, 编码, 名称, 说明, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, sysdate);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Pre_Outline;

  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline As
  Begin
    Delete From 影像报告预备提纲;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Pre_Outline;

  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select '类别' As 类别,
             b.编码 As ID,
             Null As 种类,
             b.名称 As 种类名称,
             b.编码 As 编码,
             b.名称 As 名称,
             b.说明 As 说明,
             Null As 可否重置页面,
             Null As 可否重置格式,
             Null As 是否禁用,
             Null As 创建人,
             Null As 创建时间,
             Null As 修改人,
             Null As 修改时间,
             Null As 内容
        From 影像报告种类 B
      Union All
      Select '原型' 类别,
             RawToHex(a.Id) ID,
             a.种类,
             b.名称 种类名称,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             a.是否禁用,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             Null As 内容
        From 影像报告原型清单 A, 影像报告种类 B
       Where a.种类 = b.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Output_Antetypelist;

  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type) As
  Begin
    Insert Into 影像报告原型片段
      (原型ID, 片段ID)
    Values
      (原型ID_In, 片段ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetype_Fragments;

  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Delete From 影像报告原型片段 Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetype_Fragments;

  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments;

  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In
         And a.片段ID = 片段ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_f_Byaidfid;

  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    ID_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 内容 = 内容_In, 修改人 = 修改人_In, 修改时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist_Content;

  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             编码 || '-' || 名称 As 名称,
             分组,
             a.种类,
             a.是否禁用,
             a.说明,
             Decode(a.是否禁用, 1, 2, 1) Imageindex,
             Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Antetype_Lists;

  --21.获取已经设置了关联的原型片段类别的信息
  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             a.名称,
             a.编码 || '-' || a.名称 标题,
             a.说明
        From 影像报告片段清单 A
       Where a.Id In (Select b.片段id
                        From 影像报告原型片段 B
                       Where b.原型id = 原型ID_In)
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments_Info;

  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型ID_In Varchar2
	) As
    v_Sql  Varchar2(4000);
    v_Aids Varchar2(4000);
    v_Msg  Varchar2(4000);
    Err Exception;
  Begin
    For Myrow In (Select RawtoHex(a.片段id) ID
                    From 影像报告原型片段 A
                   Where a.原型id = 原型ID_In) Loop
      If v_Aids Is Null Then
        v_Aids := '''' || Myrow.Id || '''';
      Else
        v_Aids := v_Aids || ',''' || Myrow.Id || '''';
      End If;
    End Loop;
  
    If v_Aids Is Null Then
      If Substr(原型ID_In, 0, 1) <> '''' Then
        v_Aids := '''' || 原型ID_In || '''';
      Else
        v_Aids := 原型ID_In;
      End If;
    End If;
  
    v_Sql := 'Select Distinct  RawtoHex(a.id) ID,  RawtoHex(a.上级ID) 上级ID , a.编码, a.编码 || ''-'' || a.名称 标题,Decode(a.节点类型, 0, 0, 1) 节点类型
      From 影像报告片段清单 A
      Start With a.Id In (' || v_Aids || ')
      Connect By Prior a.Id = a.上级ID
      Order By a.编码';
  
    Open Val For v_Sql;
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Selected_Fragments;

  --23.获取能复制的原型名称
  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID, a.编码 || '-' || a.名称 标题
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Copy_Antetype;

  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select Distinct a.分组 As 分组
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
         and a.分组 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Category;

  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型ID_In 影像报告原型清单.Id%Type
	) As
    x_Content Xmltype;
    x_Result  Xmltype;
    Cursor c_Antetype Is
      Select Extractvalue(c.Column_Value, '/section/@iid') Iid,
             Extractvalue(c.Column_Value, '/section/@title') Title,
             c.Column_Value As Content
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.内容, '/zlxml//section'))) C
       Where a.Id = 原型ID_In;
    n_i               Number;
    n_j               Number;
    n_Count           Number;
    x_Subdocuments    Xmltype;
    x_Docparameters   Xmltype;
    x_Antetypecontent Xmltype;
    v_Textstyleno     Varchar2(10);
    v_Parastyleno     Varchar2(10);
    x_Acontent        Xmltype;
  Begin
    For Mysample In (Select b.id, b.内容
                       From 影像报告范文清单 B
                      Where b.原型id = 原型ID_In) Loop
      x_Content := Mysample.内容;
      n_i       := 1;
      If x_Content Is Null Then
        Select a.内容
          Into x_Result
          From 影像报告原型清单 A
         Where a.Id = 原型ID_In;
      Else
        Begin
          Select Extractvalue(c.Column_Value, '/section/@textstyleno') Textstyleno,
                 Extractvalue(c.Column_Value, '/section/@parastyleno') Parastyleno
            Into v_Textstyleno, v_Parastyleno
            From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C
           Where Rownum = 1;
        Exception
          When Others Then
            v_Textstyleno := '1';
            v_Parastyleno := '1';
        End;
      
        For Myantetype In c_Antetype Loop
          For I In 1 .. 1 Loop
            If n_i <> 1 Or n_Count <> 0 Or n_Count Is Null Then
              Select Count(*)
                Into n_Count
                From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C;
            End If;
            If n_Count < n_i Then
              Select Updatexml(Myantetype.Content,
                               '//section/@textstyleno',
                               v_Textstyleno)
                Into x_Acontent
                From Dual;
              Select Updatexml(x_Acontent,
                               '//section/@parastyleno',
                               v_Parastyleno)
                Into x_Acontent
                From Dual;
              Select Appendchildxml(x_Content,
                                    '/zlxml/document',
                                    x_Acontent)
                Into x_Content
                From Dual;
              Exit;
            End If;
            n_j := 1;
            For Mysample In (Select Extractvalue(c.Column_Value,
                                                 '/section/@iid') Iid,
                                    Extractvalue(c.Column_Value,
                                                 '/section/@title') Title
                               From Table(Xmlsequence(Extract(x_Content,
                                                              '/zlxml//section'))) C) Loop
              If n_i = n_j Then
                If Myantetype.Iid <> Mysample.Iid Then
                  Select Updatexml(Myantetype.Content,
                                   '//section/@textstyleno',
                                   v_Textstyleno)
                    Into x_Acontent
                    From Dual;
                  Select Updatexml(x_Acontent,
                                   '//section/@parastyleno',
                                   v_Parastyleno)
                    Into x_Acontent
                    From Dual;
                  Select Deletexml(x_Content,
                                   '//section[@iid="' || Myantetype.Iid || '"]')
                    Into x_Content
                    From Dual;
                  Select Insertxmlbefore(x_Content,
                                         '//section[@iid="' || Mysample.Iid || '"]',
                                         x_Acontent)
                    Into x_Content
                    From Dual;
                  n_j := n_j + 1;
                  Exit;
                Else
                  n_j := n_j + 1;
                  Exit;
                End If;
              End If;
              n_j := n_j + 1;
            End Loop;
            n_i := n_i + 1;
          End Loop;
        End Loop;
        x_Result := x_Content;
        For Mysample2 In (Select Iid
                            From (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From Table(Xmlsequence(Extract(x_Content,
                                                                   '/zlxml//section'))) C) C
                           Where c.Iid Not In
                                 (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From 影像报告原型清单 A,
                                         Table(Xmlsequence(Extract(a.内容,
                                                                   '/zlxml//section'))) C
                                   Where a.Id = 原型ID_In)) Loop
          Select Deletexml(x_Result,
                           '//section[@iid="' || Mysample2.Iid || '"]')
            Into x_Result
            From Dual;
        End Loop;
      End If;
    
      Update 影像报告范文清单 X
         Set x.内容 = x_Result
       Where x.Id = Mysample.Id;
    End Loop;
  
    Select a.内容
      Into x_Antetypecontent
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
    Select Extract(x_Antetypecontent, 'zlxml/subdocuments')
      Into x_Subdocuments
      From Dual;
    Select Extract(x_Antetypecontent, 'zlxml/docparameters')
      Into x_Docparameters
      From Dual;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/subdocuments', x_Subdocuments)
     Where 原型ID = 原型ID_In;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/docparameters', x_Docparameters)
     Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Synchronous_Sample;

  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID,
             编码,
             标题,
             Parentid,
             种类,
             是否禁用,
             说明,
             Imageindex,
             名称
        From (Select a.编码 As ID,
                     a.编码 As 编码,
                     a.名称 As 标题,
                     '' As Parentid,
                     '-1' As 种类,
                     0 As 是否禁用,
                     a.说明 As 说明,
                     4 As Imageindex,
                     a.名称 名称
                From 影像报告种类 A
              Union
              Select Distinct a.种类 || '-' || a.分组 As ID,
                              (Select Min(编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              Max(a.分组) As 名称,
                              a.种类 As Parentid,
                              '0' As 种类,
                              0 As 是否禁用,
                              '' As 说明,
                              4 As Imageindex,
                              a.分组
                From 影像报告原型清单 A
               Where a.分组 Is Not Null
               Group By a.种类, a.分组
              Union
              Select RawTohex(ID),
                     a.编码,
                     编码 || '-' || 名称 As 标题,
                     Decode(a.分组, Null, a.种类, a.种类 || '-' || a.分组) Parentid,
                     a.种类 As 种类,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 1, 0, 2),
                     a.名称
                From 影像报告原型清单 A) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Out_Antetypelist;

  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明
        From 影像报告种类 A
       Where a.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Kind_By_Code;
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID,
             a.种类,
             a.原型id,
             a.编号,
             a.名称,
             a.说明,
             a.元素iid,
             a.扩展标记
        From 影像报告事件 A
       Where a.种类 <> 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event;

  --29.获取关于原型导出的重复信息
  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
	ID_In        影像报告原型清单.Id%Type,
	编码_In      Varchar2,
	名称_In      Varchar2
	) As
    n_Num    Number;
    v_Result Varchar2(100);
    v_Sql    Varchar2(4000);
  Begin
    If ID_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where id=' ||
               ID_In;
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        v_Result := 'ID重复';
      End If;
    End If;
    If 编码_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 编码=''' ||
               编码_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',编码重复';
        Else
          v_Result := '编码重复';
        End If;
      End If;
    End If;
    If 名称_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 名称=''' ||
               名称_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',名称重复';
        Else
          v_Result := '名称重复';
        End If;
      End If;
    End If;
    Open Val For
      Select v_Result Result From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Same_Info;

  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,
	ID_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	) As
    v_Same_Antetype Varchar2(50);
    n_Same_Id       Number;
    n_Same_Title    Number;
    n_Same_Seqnum   Number;
    n_Maxnum        Number;
  Begin
    Select Count(*)
      Into n_Same_Title
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.名称 = 名称_In;
    Select Count(*)
      Into n_Same_Seqnum
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.编号 = 编号_In;
    Begin
      Select a.Id
        Into v_Same_Antetype
        From 影像报告事件 A
       Where a.原型ID = 原型ID_In
         And a.元素IID = 元素IID_In;
    Exception
      When Others Then
        v_Same_Antetype := '';
    End;
  
    Select Count(*) Into n_Same_Id From 影像报告事件 A Where a.Id = ID_In;
    Select Max(a.编号) Into n_Maxnum From 影像报告事件 A;
  
    Open Val For
      Select v_Same_Antetype As Sameaid,
             n_Same_Id       As Sameid,
             n_Same_Title    As Sametitle,
             n_Same_Seqnum   As Sameseqnum,
             n_Maxnum        As Maxnum
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Event_Same_Info;

  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 动作类型
        From (Select Extractvalue(c.Column_Value, '/step/kind') As 动作类型
                From 影像报告动作 A,
                     Table(Xmlsequence(Extract(a.内容, '/root/step'))) C) B
       Where b.动作类型 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Process_Kind;


  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In 影像报告动作.原型id%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容.GetClobVal(), '<NULL/>')) As 内容, --Nvl(p.内容,'<NULL/>') As 内容,
             RawtoHex(p.事件ID) 事件ID,
             0 Is_Event
        From 影像报告动作 P
       Where p.原型ID = 原型ID_In
      Union All
      Select RawtoHex(e.id) ID,
             e.名称,
             e.种类,
             e.编号,
             e.说明,
             Null,
             To_CLOB('<Null/>') As 内容, --(Null,'<NULL/>') As 内容,
             Null,
             1
        From 影像报告事件 E
       Where e.Id In (Select RawtoHex(事件ID) 事件ID
                        From 影像报告动作
                       Where 原型ID = 原型ID_In)
       Order By Is_Event, 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process_Of_Antetype;

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	) As
  Begin
    Open Val For
      Select a.编号, a.名称, Rawtohex(a.字典id) As 字典ID
        From 影像字典内容 A
       Where a.字典id In (Select id From 影像字典清单 b Where b.名称 = 名称_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Dictitems_By_Title;

  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, a.编码, a.名称
        From 影像报告预备提纲 a
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Phr_Onlines;

  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	) As
  Begin
    If 学科_In <> '' Then
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Where (a.学科 In
               (Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(学科_In, ','))
                 Intersect
                 Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(a.学科, ','))) And
               a.节点类型 <> 0)
            Or a.节点类型 = 0
            Or a.学科 Is Null
         Order By a.编码, a.上级id;
    Else
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Order By a.上级id, a.节点类型, a.编码, a.名称;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment;

  --37. 获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(b.Id) ID,
               Rawtohex(b.上级id) 上级id,
               b.编码,
               b.名称,
               b.说明,
               b.节点类型,
               Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
               b.学科,
               b.标签,
               b.是否私有,
               b.作者,
               b.最后编辑时间
          From 影像报告原型片段 A, 影像报告片段清单 B
         Where a.片段id = b.id
           And a.原型id = 原型id_In;
    Else
      Open Val For
        Select /*+ rule*/
         Rawtohex(b.Id) ID,
         Rawtohex(b.上级id) 上级id,
         b.编码,
         b.名称,
         b.说明,
         b.节点类型,
         Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
         b.学科,
         b.标签,
         b.是否私有,
         b.作者,
         b.最后编辑时间
          From 影像报告片段清单 B
         Where b.上级id = 原型id_In
           And (b.是否私有 = 0 Or (b.是否私有 = 1 And b.作者 = 作者_In))
           And (b.学科 Is Null Or
               (b.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(b.学科, 学科_In) > 0));
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_Filter;

  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select Distinct b.标签
        From 影像报告片段清单 B
       Start With b.上级id In (Select a.片段id
                               From 影像报告原型片段 A
                              Where a.原型id = 原型ID_In)
      Connect By Prior b.Id = b.上级id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Label_By_Aid;

  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) ID,
             Rawtohex(a.上级id) 上级id,
             a.编码,
             a.名称,
             a.说明,
             a.节点类型
        From 影像报告片段清单 A
       Where a.节点类型 = 0
       Start With 上级id Is Null
      Connect By Prior id = 上级id
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment_Class;

  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Data_Last_Edit_Time;

  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    n_Seq_Num  影像报告事件.编号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = 原型ID_In
       And 种类 = 种类_In
       And 名称 = 名称_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上已存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (编号_In Is Null Or 编号_In = 0) Then
      Select Nvl(Max(编号), 0) + 1 Into n_Seq_Num From 影像报告事件;
    Else
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where 原型ID = 原型ID_In
         And 种类 = 种类_In
         And 编号 = 编号_In;
      If n_Is_Exist > 0 Then
        v_Err_Msg := '[ZLSOFT]原型上已存在相同编号的事件[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_Seq_Num := 编号_In;
    End If;
  
    Insert Into 影像报告事件
      (ID, 种类, 原型ID, 编号, 名称, 说明, 元素IID, 扩展标记)
    Values
      (ID_In,
       种类_In,
       原型ID_In,
       n_Seq_Num,
       名称_In,
       说明_In,
       元素IID_In,
       扩展标记_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Event;

  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    r_Aid      影像报告事件.原型ID%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告事件 Where ID = Id_In;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = r_Aid
       And 种类 = 种类_In
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 影像报告事件
       Set 种类     = 种类_In,
           名称     = 名称_In,
           说明     = 说明_In,
           元素IID  = 元素IID_In,
           扩展标记 = 扩展标记_In
     Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Event;

  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	) As
    n_Kind     影像报告事件.种类%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 种类 Into n_Kind From 影像报告事件 Where ID = Id_In;
  
    If n_Kind = 1 Then
      v_Err_Msg := '[ZLSOFT]不允许删除固定事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(*) Into n_Is_Exist From 影像报告动作 Where 事件ID = Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]事件已经被使用,不能被删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告事件 Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Doc_Event;

  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	) As
  Begin
    Delete From 影像报告事件
     Where 种类 <> 1
       And ID Not In
           (Select 事件ID From 影像报告动作 Where 事件ID Is Not Null);
    Count_Out := Sql%RowCount;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Unused_Doc_Events;

  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	) As
  Begin
    If Include_Base_In = 1 Then
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where (t.种类 = 1 Or t.原型id = 原型ID_In)
           And t.Id = p.事件ID(+)
         Order By t.编号;
    Else
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where t.原型id = 原型ID_In
           And t.种类 <> 1
           And t.Id = p.事件ID(+)
         Order By t.编号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event_Of_Antetype;

  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type) As
  Begin
    Update 影像报告动作 Set 序号 = 序号_In Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process_Seqnum;

  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	) As
    n_Seq_Num  影像报告动作.序号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = 原型ID_In
       And 名称 = 名称_In;
    If (序号_In Is Null Or 序号_In = 0) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 序号_In;
    End If;
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
    Insert Into 影像报告动作
      (ID, 原型ID, 事件ID, 动作类型, 名称, 说明, 可否手工执行, 序号, 内容)
    Values
      (Id_In,
       原型ID_In,
       事件ID_In,
       动作类型_In,
       名称_In,
       说明_In,
       可否手工执行_In,
       n_Seq_Num,
       内容_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Process;

  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	) As
    r_Aid          影像报告事件.原型ID%Type;
    r_Old_Event_Id 影像报告动作.事件ID%Type;
    n_Seq_Num      影像报告事件.编号%Type;
    n_Is_Exist     Number(1) := 0;
    v_Err_Msg      Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告动作 Where ID = Id_In;
    If (事件ID_In Is Not Null) Then
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where (原型ID Is Null Or 原型ID = r_Aid)
         And ID = 事件ID_In;
    
      If n_Is_Exist = 0 Then
        v_Err_Msg := '[ZLSOFT]关联的事件不存在[ZLSOFT]';
        Raise Err_Item;
      End If;
    
    End If;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = r_Aid
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (r_Old_Event_Id <> 事件ID_In Or
       (事件ID_In Is Null And r_Old_Event_Id Is Not Null)) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 0;
    End If;
  
    If n_Seq_Num > 0 Then
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In,
             序号         = n_Seq_Num
       Where ID = Id_In;
    Else
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In
       Where ID = Id_In;
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process;

  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	) As
    c_Content Clob;
  Begin
    /*Select To_Clob(a.内容)*/
    Select a.内容.getclobval()
      Into c_Content
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
  
    If Type_In = '1' Then
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/*/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '/zlxml/document//element[@sid and @title]|/zlxml/document//e_list[@sid and @title]|/zlxml/document//e_enum[@sid and @title]|/zlxml/document//e_etree[@sid and @title]|/zlxml/document//e_utree[@sid and @title]'))) C) A
         Where a.Name Is Not Null;
    Else
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/section/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '//section'))) C) A
         Where a.Name Is Not Null;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Ele_Section;

  --50.删除文档处理
  Procedure p_Del_Doc_Process(Id_In        影像报告动作.ID%Type,
                              Del_Event_In Number) As
    r_Event_Id   影像报告动作.事件ID%Type := Null;
    n_Event_Kind 影像报告事件.种类%Type;
    n_Is_Exist   Number(1) := 0;
  Begin
    If Del_Event_In = 1 Then
      Select Max(e.Id), Max(e.种类)
        Into r_Event_Id, n_Event_Kind
        From 影像报告动作 P, 影像报告事件 E
       Where p.Id = Id_In
         And p.事件id = e.Id;
    End If;
  
    Delete From 影像报告动作 Where ID = Id_In;
  
    If Del_Event_In = 1 Then
      If (r_Event_Id Is Not Null And n_Event_Kind <> 1) Then
        Select Count(*)
          Into n_Is_Exist
          From 影像报告动作
         Where 事件id = r_Event_Id;
        If n_Is_Exist = 0 Then
          Delete From 影像报告事件
           Where ID = r_Event_Id
             And 种类 <> 1;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Process;

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	) As
    v_Result  Varchar2(50);
    v_Id      Varchar2(50);
    v_Code_Id Varchar2(50);
    n_Num     Number;
  Begin
    If Flag_In = 1 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.Id = Id_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.编码 = Code_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素分类 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 2 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 3 Then
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告值域清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    Open Val For
      Select v_Result As Result, v_Id As ID, v_Code_Id As Codesameid
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Ele_Same_Info;

  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             Decode(显示样式, '1', '嵌入式', '弹出式') 显示样式II,
             Decode(种类, '1', '专用插件', '共享插件') 种类II,
             类名,
             库名,
             是否禁用,
             Decode(是否禁用, '1', '停用', '启用') IsEnable
        From 影像报告插件;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocPluginList;

  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
    Val           Out t_Refcur,
	ID_In Varchar2
	) As
    CURSOR C_EVENT Is
      Select t.专用插件.getclobval() 专用插件 From 影像报告原型清单 t;
    anum Int := 0;
    sult Varchar2(6666);
  Begin
    For temp In C_EVENT Loop
      If instr(temp.专用插件, ID_In) > 0 Then
        anum := anum + 1;
      End If;
    End Loop;
    Open Val For
      Select anum From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExit_DocPluginByID;

  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Insert Into 影像报告插件
      (ID, 编码, 名称, 说明, 显示样式, 种类, 类名, 库名, 是否禁用)
    Values
      (ID_In,
       编码_In,
       名称_In,
       说明_In,
       显示样式_In,
       种类_In,
       类名_In,
       库名_In,
       是否禁用_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddDocPlugin;

  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Update 影像报告插件
       Set 编码     = 编码_In,
           名称     = 名称_In,
           说明     = 说明_In,
           显示样式 = 显示样式_In,
           种类     = 种类_In,
           类名     = 类名_In,
           库名     = 库名_In,
           是否禁用 = 是否禁用_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDocPlugin;

  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Delete From 影像报告插件 Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDocPlugin;

  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Update 影像报告插件 a
       Set 是否禁用 = Decode(a.是否禁用, 1, 0, 1)
     Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsEnableDocPlugin;

  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocPluginByID;

  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
	编码_In 影像报告插件.编码%Type,
	名称_In 影像报告插件.名称%Type
	) As
  Begin
    Open Val For
      Select Count(id)
        From 影像报告插件 a
       Where (a.编码 = 编码_In Or a.名称 = 名称_In)
         and a.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExitDocPlugin;

  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In
         And 种类 = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocSpecPluginByID;

  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
	条件_In Varchar2
	) As
  Begin
    Open Val For
      Select to_char(a.id) ID,
             a.编码,
             a.名称,
             (Select b.名称 From 诊疗项目类别 b Where b.编码 = a.类别) 类别
        From 诊疗项目目录 a
       Where (a.id In (Select t.诊疗项目id From 影像检查项目 t) And a.类别 = 类别_In)
         And (a.编码 Like 条件_In || '%' Or a.名称 Like 条件_In || '%');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisList;

  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.编码, t.名称, t.简码 From 诊疗项目类别 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisClass;

  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
    应用场合_In   影像报告原型应用.应用场合%Type,
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Insert Into 影像报告原型应用
      (诊疗项目ID, 应用场合, 报告原型ID)
    Values
      (诊疗项目ID_In, 应用场合_In, 报告原型ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMedicalAntetype;

  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告原型应用 Where 报告原型ID = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMedicalAntetype;

  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Open Val For
      Select id,
             x.编码,
             x.名称,
             x.类别,
             Sum(x.门诊) 门诊,
             Sum(x.住院) 住院,
             Sum(x.外诊) 外诊,
             Sum(x.体检) 体检
        From (Select id,
                     编码,
                     名称,
                     类别,
                     Decode(应用场合, '1', 1, 0) as 门诊,
                     Decode(应用场合, '2', 1, 0) as 住院,
                     Decode(应用场合, '3', 1, 0) as 外诊,
                     Decode(应用场合, '4', 1, 0) as 体检
                From (Select to_Char(a.诊疗项目id) ID,
                             (Select b.编码
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 编码,
                             (Select b.名称
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 名称,
                             (Select c.名称
                                From 诊疗项目类别 c
                               Where c.编码 = (Select b.类别
                                               From 诊疗项目目录 b
                                              Where b.id = a.诊疗项目id)) As 类别,
                             a.应用场合
                        From 影像报告原型应用 a
                       Where a.报告原型id = 报告原型ID_In)) x
       Group By x.id, x.编码, x.名称, x.类别;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMedicalByAID;

  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告动作 t Where t.原型id = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     a.名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAntetypeTreeByID;

  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
	名称_In 影像报告原型清单.名称%Type,
	ID_In  影像报告原型清单.ID%Type
	) As
  begin
    Open Val For
      Select Count(*) AS num
        From 影像报告原型清单 t
       where (t.编码 = 编码_In
          or t.名称 = 名称_In) and t.id<>ID_In;
  End p_IsExitAntetype;

  --7  获取影像存储设备
  Procedure p_GetStorageDevice(
	Val           Out t_Refcur
	) Is 
  Begin 
	Open Val For
		Select 设备号||' - '||设备名 As 存储设备, 设备号, IP地址, FTP目录, FTP用户名, FTP密码, 共享目录用户名, 共享目录密码, 共享目录  
		From 影像设备目录 Where 类型 = 1;
	Exception
	  When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStorageDevice;
End b_PACS_RptAntetype;
/

--93761:梁经伙,2016-04-14,待入住的病人，则不产生变动，直接修改已有变动
Create Or Replace Procedure Zl_病案主页_首页整理
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  年龄_In         病案主页.年龄%Type,
  国籍_In         病案主页.国籍%Type,
  区域_In         病案主页.区域%Type,
  职业_In         病案主页.职业%Type,
  身高_In         病案主页.身高%Type,
  体重_In         病案主页.体重%Type,
  血型_In         病案主页.血型%Type,
  婚姻状况_In     病案主页.婚姻状况%Type,
  医疗付款方式_In 病案主页.医疗付款方式%Type,
  家庭地址_In     病案主页.家庭地址%Type,
  家庭电话_In     病案主页.家庭电话%Type,
  家庭邮编_In     病案主页.家庭地址邮编%Type,
  户口地址_In     病案主页.户口地址%Type,
  户口邮编_In     病案主页.户口地址邮编%Type,
  单位地址_In     病案主页.单位地址%Type,
  单位电话_In     病案主页.单位电话%Type,
  单位邮编_In     病案主页.单位邮编%Type,
  联系人姓名_In   病案主页.联系人姓名%Type,
  联系人关系_In   病案主页.联系人关系%Type,
  联系人电话_In   病案主页.联系人电话%Type,
  联系人地址_In   病案主页.联系人地址%Type,
  入院病况_In     病案主页.入院病况%Type,
  入院方式_In     病案主页.入院方式%Type,
  出院方式_In     病案主页.出院方式%Type,
  再入院_In       病案主页.再入院%Type,
  是否确诊_In     病案主页.是否确诊%Type,
  确诊日期_In     病案主页.确诊日期%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  随诊标志_In     病案主页.随诊标志%Type,
  随诊期限_In     病案主页.随诊期限%Type,
  新发肿瘤_In     病案主页.新发肿瘤%Type,
  中医治疗类别_In 病案主页.中医治疗类别%Type,
  抢救次数_In     病案主页.抢救次数%Type,
  成功次数_In     病案主页.成功次数%Type,
  门诊医师_In     病案主页.门诊医师%Type,
  住院医师_In     病案主页.住院医师%Type,
  主治医师_In     病案主页.住院医师%Type,
  主任医师_In     病案主页.住院医师%Type,
  责任护士_In     病案主页.责任护士%Type,
  操作员编号_In   病案主页.编目员编号%Type := Null,
  操作员姓名_In   病案主页.编目员姓名%Type := Null
) As
  --功能：用于住院医护工作站对病人进行首页整理
  v_住院医师 病案主页.住院医师%Type;
  v_主治医师 病案主页.住院医师%Type;
  v_主任医师 病案主页.住院医师%Type;
  v_责任护士 病案主页.责任护士%Type;
  v_病人性质 病案主页.病人性质%Type;
  v_原因     病人变动记录.开始原因%Type;
  v_出院科室 病案主页.出院科室id%Type;
  v_Curdate  Date;
  v_Count    Number;
  v_Change   Varchar2(500);
  n_出院     Number(1);
  v_Info     Varchar2(100);
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate)) A, 病人变动记录 B
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= v_Curdate;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%RowType;
  r_Endinfo  c_Endinfo%RowType;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin
  --取更改前的内容(用NoneData和新的比较)
  Select 病人性质, Nvl(住院医师, 'NoneData'), Nvl(出院科室id, 入院科室id), Nvl(责任护士, 'NoneData')
  Into v_病人性质, v_住院医师, v_出院科室, v_责任护士
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主治医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
  Exception
    When Others Then
      v_主治医师 := 'NoneData';
    
  End;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主任医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
  
  Exception
    When Others Then
      v_主任医师 := 'NoneData';
    
  End;

  Update 病案主页
  Set 婚姻状况 = 婚姻状况_In, 年龄 = 年龄_In, 职业 = 职业_In, 国籍 = 国籍_In, 区域 = 区域_In, 医疗付款方式 = 医疗付款方式_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
      家庭地址邮编 = 家庭邮编_In, 单位地址 = 单位地址_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
      联系人电话 = 联系人电话_In, 联系人地址 = 联系人地址_In, 再入院 = 再入院_In, 入院病况 = 入院病况_In, 是否确诊 = 是否确诊_In, 确诊日期 = 确诊日期_In, 抢救次数 = 抢救次数_In,
      成功次数 = 成功次数_In, 尸检标志 = 尸检标志_In, 随诊标志 = 随诊标志_In, 随诊期限 = 随诊期限_In, 血型 = 血型_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In,
      新发肿瘤 = 新发肿瘤_In, 中医治疗类别 = 中医治疗类别_In, 身高 = 身高_In, 体重 = 体重_In, 出院方式 = 出院方式_In, 入院方式 = 入院方式_In, 责任护士 = 责任护士_In,
      户口地址 = 户口地址_In, 户口地址邮编 = 户口邮编_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  Select Decode(出院日期, Null, 0, 1) Into n_出院 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_出院 = 0 Then
    If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Or v_主治医师 <> Nvl(主治医师_In, 'NoneData') Or v_主任医师 <> Nvl(主任医师_In, 'NoneData') Or
       v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
    
      v_原因 := Null;
      Select Max(Decode(开始原因, 10, '预出院', Null))
      Into v_Info
      From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
    
      If v_Info Is Null Then
        Select Max(Decode(开始原因, 3, '转科待入科', 15, '转病区待接收', Null))
        Into v_Info
        From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
      End If;
    
      If v_Info Is Not Null Then
        Select f_List2str(Cast(Collect(a.信息) As t_Strlist))
        Into v_Change
        From (Select 姓名 信息
               From 人员表
               Where 0 = 1
               Union All
               Select '住院医师(原:' || v_住院医师 || ')' 信息
               From Dual
               Where v_住院医师 <> Nvl(住院医师_In, 'NoneData')
               Union All
               Select '主治医师(原:' || v_主治医师 || ')'
               From Dual
               Where v_主治医师 <> Nvl(主治医师_In, 'NoneData')
               Union All
               Select '主任医师(原:' || v_主任医师 || ')'
               From Dual
               Where v_主任医师 <> Nvl(主任医师_In, 'NoneData')
               Union All
               Select '责任护士(原:' || v_责任护士 || ')'
               From Dual
               Where v_责任护士 <> Nvl(责任护士_In, 'NoneData')) A;
        v_Error := '该病人正在' || v_Info || '，不能进行如下变动：' || v_Change || '！';
        Raise Err_Custom;
      End If;
      Select Sysdate Into v_Curdate From Dual;
      Open c_Oldinfo;
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        --出院病人不进行变动处理
        Close c_Endinfo;
      Else
        --如果终止时间<>NULL ，就记录下终止时间和终止原因。
        If r_Oldinfo.终止时间 Is Not Null Then
          v_终止时间 := r_Oldinfo.终止时间;
          v_终止原因 := r_Oldinfo.终止原因;
          v_终止人员 := r_Oldinfo.终止人员;
        End If;
        --如果是待入住的病人，则不产生变动，直接修改已有变动
        If r_Oldinfo.开始原因 = 1 And r_Oldinfo.终止时间 Is Null Then
          Update 病人变动记录
          Set 经治医师 = 住院医师_In, 主治医师 = 主治医师_In, 责任护士 = 责任护士_In, 主任医师 = 主任医师_In
          Where ID = r_Oldinfo.Id;
        Else
          If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Then
            v_原因 := 7;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 经治医师 = 住院医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            --产生病历书写时机
            Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '交班', r_Oldinfo.科室id, 住院医师_In, v_Curdate, v_Curdate);
          
            While c_Oldinfo%Found Loop
              --注意:有附加床位时有多条记录
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, 住院医师_In,
                 r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
          
            Close c_Oldinfo;
            Open c_Oldinfo; --重新打开,以便取最新信息
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_主治医师 <> Nvl(主治医师_In, 'NoneData') Then
            Update 病案主页从表
            Set 信息值 = 主治医师_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
          
            If Sql%RowCount = 0 Then
              Insert Into 病案主页从表
                (病人id, 主页id, 信息名, 信息值)
              Values
                (病人id_In, 主页id_In, '主治医师', 主治医师_In);
            
            End If;
          
            v_原因 := 11;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 主治医师 = 主治医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
                 主治医师_In, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
          
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
            v_原因 := 8;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录，如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 责任护士 = 责任护士_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, 责任护士_In, r_Oldinfo.经治医师,
                 r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
            --如果存在停止到将来的变动就更新终止原因
            If v_终止时间 Is Not Null Then
              v_终止原因 := v_原因;
              v_终止时间 := v_Curdate;
              v_终止人员 := 操作员姓名_In;
            End If;
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          If v_主任医师 <> Nvl(主任医师_In, 'NoneData') Then
            Update 病案主页从表
            Set 信息值 = 主任医师_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
          
            If Sql%RowCount = 0 Then
              Insert Into 病案主页从表
                (病人id, 主页id, 信息名, 信息值)
              Values
                (病人id_In, 主页id_In, '主任医师', 主任医师_In);
            
            End If;
          
            v_原因 := 12;
            If v_终止时间 Is Null Then
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
            
            Else
              Update 病人变动记录
              Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
              --更新将来的记录如果有停止到将来的则删除上次计算时间
              Update 病人变动记录
              Set 主任医师 = 主任医师_In, 上次计算时间 = Null
              Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
            End If;
          
            While c_Oldinfo%Found Loop
              Insert Into 病人变动记录
                (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
                 操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
              Values
                (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
                 r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
                 r_Oldinfo.主治医师, 主任医师_In, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            
              Fetch c_Oldinfo
                Into r_Oldinfo;
            End Loop;
          
            Close c_Oldinfo;
            Open c_Oldinfo;
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End If;
        
          Close c_Oldinfo;
          Close c_Endinfo;
          Select Count(*)
          Into v_Count
          From 病人变动记录
          Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
        
          If v_Count > 1 Then
            v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
            Raise Err_Custom;
          End If;
        
        End If;
      
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
  
End Zl_病案主页_首页整理;
/

--95914:李南春,2016-05-06,绑定卡不需检查是否有使用记录
--94761:李南春,2016-03-31,检查卡号是否重复使用
Create Or Replace Procedure Zl_医疗卡变动_Insert
(
  变动类型_In   Number,
  病人id_In     住院费用记录.病人id%Type,
  卡类别id_In   病人医疗卡信息.卡类别id%Type,
  原卡号_In     病人医疗卡信息.卡号%Type,
  医疗卡号_In   病人医疗卡信息.卡号%Type,
  变动原因_In   病人医疗卡变动.变动原因%Type,
  密码_In       病人信息.卡验证码%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  变动时间_In   住院费用记录.登记时间%Type,
  Ic卡号_In     病人信息.Ic卡号%Type := Null,
  挂失方式_In   病人医疗卡变动.挂失方式%Type := Null
) As
  --参数：发卡类型=1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
  --变动原因_In:如果密码调整，变动原因为密码.加密的
  Err_Item Exception;
  v_Err_Msg        Varchar2(500);
  n_医疗卡重复使用 Number(3);
  n_一卡通         Number(1);
  n_Count          Number;
  n_Bound          Number(2);
  n_Id             病人医疗卡变动.ID%Type;
  v_原密码         病人医疗卡信息.密码%Type;

  Cursor c_医疗卡(Id_In 病人医疗卡信息.卡类别id%Type) Is
    Select ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, Nvl(是否刷卡, 0) As 是否刷卡,
           Nvl(是否自制, 0) As 是否自制, Nvl(是否存在帐户, 0) As 是否存在帐户, Nvl(是否全退, 0) As 是否全退, 部件, 备注,
           特定项目, 结算方式, 是否启用, 卡号密文, Nvl(是否重复使用, 0) As 是否重复使用
    From 医疗卡类别
    Where ID = Id_In;
  r_医疗卡 c_医疗卡%Rowtype;

Begin
  If 变动类型_In <> 14 Then
    Open c_医疗卡(卡类别id_In);
    Fetch c_医疗卡
      Into r_医疗卡;
    If c_医疗卡%Rowcount = 0 Then
      Close c_医疗卡;
      v_Err_Msg := '[ZLSOFT]没有发现原医疗卡的相应类别,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;

    n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
  End If;
  If Instr('1,11,2,3', 变动类型_In) > 0 Then
    Select Count(*)
    Into n_Count
    From 病人医疗卡信息
    Where 卡类别id = 卡类别id_In And 卡号 = 医疗卡号_In And 病人id <> 病人id_In And 状态 In (0, 1, 2);
    If n_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]新卡号:' || 医疗卡号_In || ' 正在使用，请换一张新卡,请检查![ZLSOFT]';
      Raise Err_Item;
    End If;
    If n_医疗卡重复使用 = 0 And Nvl(r_医疗卡.是否自制, 0) = 1 Then
      Begin
        Select 1 Into n_Count From 病人医疗卡变动 Where 卡类别id = 卡类别id_In And 卡号 = 医疗卡号_In And Rownum = 1;
      Exception
        When Others Then
          n_Count := -1;
      End;
      If n_Count = 1 Then
        Close c_医疗卡;
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '不能重复使用,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
  End If;
  If Mod(变动类型_In, 10) = 1 Then
    --发卡和绑定卡
    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
       Null, 密码_In, 操作员姓名_In, 变动时间_In);
  End If;

  If 变动类型_In = 2 Then
    --换卡
    v_Err_Msg := Null;
    Begin
      Select 密码
      Into v_原密码
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 原卡号_In;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 原卡号_In || '未找到,不能换卡！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;

    Delete 病人医疗卡信息 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 原卡号_In;
    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 现密码, 挂失方式, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In, 密码_In, Null,
       操作员姓名_In, 变动时间_In);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 原卡号_In, n_Id, 变动类型_In, 变动时间_In, 变动原因_In, Null,
       v_原密码, 操作员姓名_In, 变动时间_In);
  End If;

  If 变动类型_In = 3 Then
    --补卡/
    --全部停用,发新卡
    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 3, 变动时间_In, 变动原因_In, Null, 操作员姓名_In, 变动时间_In);

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 原密码, 操作员姓名, 登记时间)
      Select 病人医疗卡变动_Id.Nextval, 病人id, 卡类别id, 卡号, n_Id, 13, 变动时间_In, '补卡停用', Null, 密码_In,
             操作员姓名_In, 变动时间_In
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And Nvl(状态, 0) = 0;

    Update 病人医疗卡信息 Set 状态 = 2 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And Nvl(状态, 0) = 0;

    Insert Into 病人医疗卡信息
      (病人id, 卡类别id, 卡号, 密码, 状态, 发卡日期, 发卡人, 挂失时间, 挂失方式, 挂失人)
    Values
      (病人id_In, 卡类别id_In, 医疗卡号_In, 密码_In, 0, 变动时间_In, 操作员姓名_In, Null, Null, Null);
  End If;

  If 变动类型_In = 4 Then
    -- 退卡
    Delete 病人医疗卡信息 Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
       Null, 操作员姓名_In, 变动时间_In);
       Delete 病人医疗卡属性 Where 病人id=病人id_In;
  End If;
  If 变动类型_In = 14 Then
    -- 取消绑定卡
    --处理宁波一卡通的发卡数据,根据启用=2来判断.
    Begin
      Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
    Exception
      When Others Then
        n_一卡通 := 0;
    End;

    n_Count := 0;
    For v_医疗卡 In (Select A.卡号, A.病人id, A.卡类别id, Nvl(B.是否重复使用, 0) As 是否重复使用,
                            Decode(B.名称, '就诊卡', Decode(Nvl(B.是否固定, 0), 1, B.ID, 0), 0) As 就诊卡id
                     From 病人医疗卡信息 A, 医疗卡类别 B
                     Where A.卡类别id = B.ID And A.病人id = 病人id_In And Nvl(A.状态, 0) = 0 And
                           (A.卡类别id = 卡类别id_In Or Nvl(卡类别id_In, 0) = 0) And
                           (A.卡号 = 医疗卡号_In Or 医疗卡号_In Is Null)) Loop
      n_医疗卡重复使用 := Nvl(r_医疗卡.是否重复使用, 0);
      ---只有在住院费用记录中不存在时,才会进行取消绑定操作
      Begin
        Select 1
        Into n_Bound
        From 住院费用记录
        Where 病人id = 病人id_In And 记录性质 = 5 And
              Decode(结论, Null, v_医疗卡.就诊卡id, To_Number(结论)) = v_医疗卡.卡类别id And 实际票号 = v_医疗卡.卡号 And
              Rownum = 1;
      Exception
        When Others Then
          n_Bound := 0;
      End;
      If n_Bound = 0 Then
        Delete 病人医疗卡信息 Where 卡类别id = v_医疗卡.卡类别id And 病人id = 病人id_In And 卡号 = v_医疗卡.卡号;
        Insert Into 病人医疗卡变动
          (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
        Values
          (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In,
           Null, 操作员姓名_In, 变动时间_In);

        --就诊卡处理
        If Nvl(v_医疗卡.就诊卡id, 0) <> 0 And n_一卡通 = 1 Then
          Update 病人信息
          Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
          Where 病人id = 病人id_In;
        End If;
        n_Count := n_Count + 1;
      End If;
      --检查是否成功更新
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]未找到绑定的卡号,不能取消绑定！[ZLSOFT]';
        Raise Err_Item;
      End If;
    End Loop;
    Delete 病人医疗卡属性 Where 病人id=病人id_In;
  End If;

  If Mod(变动类型_In, 10) = 5 Then
    -- ５-密码调整(只记录)
    v_Err_Msg := Null;
    Begin
      Select 密码
      Into v_原密码
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '未找到,不能密码调整！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Select 病人医疗卡变动_Id.Nextval Into n_Id From Dual;
    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 原密码, 现密码, 操作员姓名, 登记时间)
    Values
      (n_Id, 病人id_In, 卡类别id_In, 医疗卡号_In, Null, 变动类型_In, 变动时间_In, 变动原因_In, v_原密码, 密码_In,
       操作员姓名_In, 变动时间_In);

    Update 病人医疗卡信息
    Set 密码 = 密码_In
    Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    If r_医疗卡.名称 = '就诊卡' And Nvl(r_医疗卡.是否固定, 0) = 1 Then
      Update 病人信息 Set 卡验证码 = 密码_In Where 病人id = 病人id_In;
    End If;

    Return;
  End If;
  If Mod(变动类型_In, 10) = 6 Then
    -- 6挂失(16取消挂失)
    v_Err_Msg := Null;
    Begin
      Select 1
      Into n_Count
      From 病人医疗卡信息
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
    Exception

      When Others Then
        v_Err_Msg := '[ZLSOFT]卡号:' || 医疗卡号_In || '未找到,不能' || Case When 变动类型_In = 6 Then '挂失' Else '取消挂失' End || '！[ZLSOFT]';
    End;
    If v_Err_Msg Is Not Null Then
      Close c_医疗卡;
      Raise Err_Item;
    End If;

    Insert Into 病人医疗卡变动
      (ID, 病人id, 卡类别id, 卡号, 变动id, 变动类别, 变动时间, 变动原因, 挂失方式, 操作员姓名, 登记时间)
    Values
      (病人医疗卡变动_Id.Nextval, 病人id_In, 卡类别id_In, 医疗卡号_In, n_Id, 变动类型_In, 变动时间_In, 变动原因_In,
       挂失方式_In, 操作员姓名_In, 变动时间_In);

    If 变动类型_In = 6 Then
      Update 病人医疗卡信息
      Set 挂失方式 = 挂失方式_In, 状态 = 1, 挂失时间 = Sysdate, 挂失人 = 操作员姓名_In
      Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
     else
  Update 病人医疗卡信息
  Set 挂失方式 = NULL, 状态 = 0, 挂失时间 = NULL, 挂失人 =NULL
  Where 卡类别id = 卡类别id_In And 病人id = 病人id_In And 卡号 = 医疗卡号_In;
     End if;

    Return;

  End If;

  If r_医疗卡.名称 = '就诊卡' And Nvl(r_医疗卡.是否固定, 0) = 1 Then
    --处理宁波一卡通的发卡数据,根据启用=2来判断.
    Begin
      Select 1 Into n_一卡通 From 一卡通目录 Where 启用 = 2 And Rownum <= 1;
    Exception
      When Others Then
        n_一卡通 := 0;
    End;
    If n_一卡通 = 1 Then

      If Mod(变动类型_In, 10) = 4 Then
        --退卡或取消绑定卡
        Update 病人信息
        Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
        Where 病人id = 病人id_In;
        --处理规则:
        --  如果上传了卡号的，则不能退卡
        --  如果未上传,则将新卡号更新为NULL
        --如果本身未存在病人发卡记录,则允许退卡
        If 变动类型_In = 4 Then
          Update 病人发卡记录
          Set 新卡号 = Null
          Where 病人id = 病人id_In And 发卡时间 In (Select Max(发卡时间) From 病人发卡记录 Where 病人id = 病人id_In) And
                Nvl(上传标志, 0) = 0;
          If Sql%NotFound Then
            Begin
              Select 1 Into n_一卡通 From 病人发卡记录 Where 病人id = 病人id_In;
            Exception
              When Others Then
                n_一卡通 := 0;
            End;
            If n_一卡通 = 1 Then
              v_Err_Msg := '[ZLSOFT]没有发现要退卡的记录,该记录可能已经退除！[ZLSOFT]';
              Raise Err_Item;
            End If;
          End If;
        End If;
        Return;

      End If;
      If 变动类型_In = 11 Then
        --绑定卡
        Update 病人信息
        Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In,
            Ic卡号 = Decode(Ic卡号_In, Null, Nvl(Ic卡号, 医疗卡号_In), Ic卡号_In)
        Where 病人id = 病人id_In;
        If 医疗卡号_In Is Not Null Then
          Update 病人发卡记录 Set 新卡号 = 医疗卡号_In, 发卡时间 = Sysdate Where 病人id = 病人id_In And 新卡号 Is Null;
        End If;
      End If;

      If Ic卡号_In Is Null Then
        If n_医疗卡重复使用 = 1 Then
          Update 病人信息 Set 就诊卡号 = Null Where 病人id <> 病人id_In And 就诊卡号 = 医疗卡号_In;
        End If;
        Update 病人信息 Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In Where 病人id = 病人id_In;
      Else
        --档案号以IC卡号传入
        Update 病人信息 Set Ic卡号 = Ic卡号_In Where 病人id = 病人id_In;
      End If;

      --处理发卡数据
      --病人发卡记录表中至少存在一条记录，当该病人第一次在本院医疗时由zlICCard部件在ReadCard 后产生，此时的数据没有新卡号
      --发卡程序检查病人发卡记录，如果存在新卡号为空的记录（最多只有一条），则更新新卡号字段；否则产生一条新记录，插入旧卡号，新卡号，过程如下：
      Update 病人发卡记录 Set 新卡号 = 医疗卡号_In, 发卡时间 = Sysdate Where 病人id = 病人id_In And 新卡号 Is Null;
      If Sql%NotFound Then
        Insert Into 病人发卡记录
          (病人id, 旧卡号, 旧卡类型, 旧卡发卡医院, 新卡号, 发卡时间)
          Select 病人id_In, Nvl(原卡号_In, ' '), 2, 医院编码, 医疗卡号_In, Sysdate
          From 一卡通目录
          Where 启用 = 2 And Rownum <= 1 And Not Exists
           (Select 1 From 病人发卡记录 Where 病人id = 病人id_In And 旧卡号 = Nvl(原卡号_In, ' '));
      End If;
    Else
      --病人医疗卡信息变化
      If n_医疗卡重复使用 = 1 Then
        --需要检查其他病人是否使用了该卡号，如果使用了，则将医疗卡号设置为NULL
        Update 病人信息
        Set 就诊卡号 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
        Where 病人id <> 病人id_In And 就诊卡号 = 医疗卡号_In;
      End If;
      Update 病人信息
      Set 就诊卡号 = 医疗卡号_In, 卡验证码 = 密码_In, Ic卡号 = Decode(Ic卡号, 就诊卡号, 医疗卡号_In, Ic卡号)
      Where 病人id = 病人id_In;
    End If;

  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医疗卡变动_Insert;
/

--94674:刘兴洪,2016-03-31,普通治疗类在收费后没有更新计费状态
CREATE OR REPLACE Procedure Zl_医嘱发送_计费状态_Update
(
  场合_In    Integer := 0, --0:门诊;1-住院
  性质_In    Integer := 1, --1-收费单;2-记帐单
  操作_In    Integer := 0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  No_In      门诊费用记录.No%Type,
  医嘱ids_In Varchar2 := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_医嘱id   t_Numlist := t_Numlist();
  l_医嘱id1  t_Numlist := t_Numlist();
  l_计费状态 t_Numlist := t_Numlist();
  n_Count    Number(18);
  v_医嘱ids  Varchar2(4000);

Begin
  v_医嘱ids := 医嘱ids_In;

  If 医嘱ids_In Is Null Then
    If 场合_In = 0 Then
      Select ID Bulk Collect
      Into l_医嘱id1
      From (Select Distinct 医嘱序号 As ID
             From 门诊费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    Else
      Select ID Bulk Collect
      Into l_医嘱id1
      From (Select Distinct 医嘱序号 As ID
             From 住院费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    End If;
  Else
    Select ID Bulk Collect
    Into l_医嘱id1
    From (Select Distinct Column_Value As ID From Table(f_Str2list(医嘱ids_In)) B);
  End If;
  If l_医嘱id1.Count = 0 Then
    Return;
  End If;
  If v_医嘱ids Is Null And Nvl(操作_In, 0) = 1 Then
    For I In 1 .. l_医嘱id1.Count Loop
      v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || l_医嘱id1(I);
    End Loop;
    If Not v_医嘱ids Is Null Then
      v_医嘱ids := ',' || v_医嘱ids || ',';
    End If;
  Elsif Not v_医嘱ids Is Null Then
    v_医嘱ids := ',' || v_医嘱ids || ',';
  End If;

  For c_医嘱 In (With c_医嘱信息 As
                  (Select Column_Value As 医嘱id From Table(l_医嘱id1))
                 Select ID, 相关id, 诊疗类别
                 From 病人医嘱记录 A
                 Where a.Id In (Select 医嘱id
                                From c_医嘱信息
                                Union All
                                Select Distinct 相关id
                                From 病人医嘱记录 A1, c_医嘱信息 B1
                                Where A1.Id = B1.医嘱id And 相关id Is Not Null)) Loop
    --1.划价单删除
    If Nvl(操作_In, 0) = 0 Then
      --D    检查       JC
      --F    手术       SS
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') > 0 Then
        If 场合_In = 0 Then
          Select Nvl(Count(*), 0)
          Into n_Count
          From 门诊费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        Else
          Select Nvl(Count(*), 0)
          Into n_Count
          From 住院费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        End If;
      Else
        If 场合_In = 0 Then
          Select Nvl(Count(*), 0)
          Into n_Count
          From 门诊费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        Else
          Select Nvl(Count(*), 0)
          Into n_Count
          From 住院费用记录 A, (Select ID From 病人医嘱记录 A Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id) B, 病人医嘱发送 C
          Where a.医嘱序号 = b.Id And a.No = No_In And a.记录性质 = 性质_In And a.No = c.No And a.记录性质 = c.记录性质 And c.计费状态 = 1 And
                Nvl(a.附加标志, 0) <> 9;
        End If;
      End If;
      If Nvl(n_Count, 0) = 0 Then
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := 0; --未计费
      
      End If;
    End If;
  
    --1.收费或记帐
    If Nvl(操作_In, 0) = 1 Then
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      n_Count := 0;
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') = 0 And
         Instr(Nvl(v_医嘱ids, '-'), ',' || c_医嘱.Id || ',') = 0 Then
        n_Count := 1;
      End If;
    
      If Nvl(n_Count, 0) = 0 Then
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := 3; --全部收费
      
      End If;
    End If;
  
    --2.退费或销帐
    If Nvl(操作_In, 0) = 2 Then
      --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      If c_医嘱.相关id Is Null And Instr(',D,F,', ',' || c_医嘱.诊疗类别 || ',') > 0 Then
        If 场合_In = 0 Then
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                            When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                             0
                            When 剩余数量 = 0 Then
                             2
                            Else
                             3
                          End As 状态
                 
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 门诊费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And
                               医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id)
                         Group By 序号));
        Else
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                           When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                            0
                           When 剩余数量 = 0 Then
                            2
                           Else
                            3
                         End As 状态
                 
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 住院费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And
                               医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = c_医嘱.Id Or 相关id = c_医嘱.Id)
                         Group By 序号));
        
        End If;
      Else
        If 场合_In = 0 Then
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                            When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                             0
                            When 剩余数量 = 0 Then
                             2
                            Else
                             3
                          End As 状态
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 门诊费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.Id
                         Group By 序号));
        Else
        
          Select Case
                   When Min(状态) = Max(状态) Then
                    Max(状态)
                   Else
                    3
                 End
          Into n_Count
          From (
                 
                 Select Case
                           When 剩余数量 = 原始数量 And 原始数量 <> 0 Then
                            0
                           When 剩余数量 = 0 Then
                            2
                           Else
                            3
                         End As 状态
                 From (Select 序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0) * Decode(记录性质, 11, 0, 1) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                         From 住院费用记录
                         Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                               Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.Id
                         Group By 序号));
        
        End If;
      
      End If;
    
      If n_Count <> 0 Then
      
        l_医嘱id.Extend;
        l_医嘱id(l_医嘱id.Count) := c_医嘱.Id;
        l_计费状态.Extend;
        l_计费状态(l_计费状态.Count) := Case
                                  When Nvl(n_Count, 0) = 2 Then
                                   4
                                  Else
                                   2
                                End;
      End If;
    End If;
  End Loop;

  Forall I In 1 .. l_医嘱id.Count
    Update 病人医嘱发送 A
    Set a.计费状态 = l_计费状态(I)
    Where 医嘱id = l_医嘱id(I) And 记录性质 = 性质_In And NO = No_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医嘱发送_计费状态_Update;
/

--91998:冉俊明,2016-05-31,退费发票(红票)
--94654:冉俊明,2016-03-30,作废医嘱不能退费。
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差, Nvl(j.医嘱状态, 0) As 医嘱状态
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();

  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And Mod(a.记录性质, 10) = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行) 
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            --: 3.医嘱作废了的,则以剩余数量为准(病人医嘱记录.医嘱状态=4表示作废医嘱，会删除"病人医嘱发送",门诊药嘱先作废后退药)
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null And r_Bill.医嘱状态 <> 4 Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And Mod(j.记录性质, 10) = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And Mod(j.记录性质, 10) = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             Mod(a.记录性质, 10) = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          If n_准退数量 < 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --该笔项目第几次退费 
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数) 
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        
          --          Update 门诊费用记录 Set 记录状态 = 3 Where ID = r_Bill.Id;
        
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --标记原费用记录 
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--94658:梁唐彬,2016-04-06,先作废后退药处理
CREATE OR REPLACE Procedure Zl_病人医嘱记录_作废
(
  Id_In         病人医嘱记录.Id%Type,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  护理医嘱id_In 病人医嘱记录.Id%Type := Null,
  作废时间_In   病人医嘱状态.操作时间%Type := Null
) Is
  --功能：作废指定的医嘱(未发送的长嘱或临嘱)
  --说明：一并给药的只能调用一次(界面显示有多行)
  --参数：ID_IN=组医嘱ID
  --      护理医嘱id_In 取除开本次作废的护理等级医嘱外的最近的自动停止的护理等级医嘱id

  v_发送号       病人医嘱发送.发送号%Type;
  v_费用no       门诊费用记录.No%Type;
  v_记录性质     门诊费用记录.记录性质%Type;
  v_费用序号     Varchar2(255);
  n_自动取消执行 Number(1) := 0;
  n_先作废后退药 Number(1) := 0;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  --包含医嘱相关信息
  Cursor c_Advice Is
    Select a.病人id, a.挂号单, a.主页id, a.婴儿, a.医嘱状态, a.上次执行时间, a.医嘱内容, a.诊疗类别, b.操作类型, a.病人来源, a.执行科室id, b.执行频率, a.诊疗项目id,
           a.开始执行时间
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = Id_In;

  r_Advice c_Advice%RowType;

  --门诊医嘱作废时，取对应的费用销帐或作废(收费划价单)：
  --根据医嘱及发送NO求出本次回退要销帐或退费的记录
  --一组医嘱并不是都填写了发送记录,也不一定都计费了,且可能NO不同
  --只管记录状态为1的记录,如果已经销帐或部份销帐的记录,不再处理
  --费用只求价格父号为空的,以便取序号销帐
  --如果"门诊药嘱先作废后退药",则不对相应费用(包括给药途径的)进行检查和处理,除非是还没有执行的记帐单,或未执行、收费的划价单，可以先删了。



  Cursor c_Rollmoney(v_发送号 病人医嘱发送.发送号%Type) Is
    Select a.记录性质, a.记录状态, a.No, a.序号, a.执行状态 As 费用执行, c.执行状态 As 医嘱执行, c.执行部门id, b.病人科室id,B.诊疗类别,I.操作类型
    From 门诊费用记录 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 I
    Where c.医嘱id = b.Id And c.发送号 = v_发送号 And (b.Id = Id_In Or b.相关id = Id_In) And a.医嘱序号 = b.Id And a.记录状态 In (0, 1) And
          a.No = c.No And a.记录性质 = c.记录性质 And b.诊疗项目id = i.Id And a.价格父号 Is Null And
          (n_先作废后退药 = 0 Or n_先作废后退药 = 1 And Not (Exists (Select 1
                                                         From 门诊费用记录 D
                                                         Where d.医嘱序号 = b.Id And d.记录状态 In (0, 1) And d.No = c.No And
                                                               d.记录性质 = c.记录性质 And d.收费类别 In ('5', '6', '7'))
       ) Or Nvl(a.执行状态, 0) = 0 And Not (a.记录性质 = 1 And a.记录状态 <> 0))
    Order By a.记录性质, a.No, a.序号, a.收费细目id;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能作废。';
    Raise Err_Custom;
  End If;

  If r_Advice.挂号单 Is Null And r_Advice.病人来源 <> 3 Then
    If r_Advice.医嘱状态 In (4, 8, 9) Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经被作废或停止，不能再作废。';
      Raise Err_Custom;
    Elsif r_Advice.上次执行时间 Is Not Null Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经发送，不能被作废。';
      Raise Err_Custom;
    End If;

    --持续性护理等级无须发送，校对后就可能已自动计费，作废及回退作废都应按停止流程处理。
    If r_Advice.诊疗类别 = 'H' And r_Advice.操作类型 = '1' And r_Advice.执行频率 = '2' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --(已取消，由于存在无费退院的情况，问题号：45977)a.开始时间是当天之前的，说明已生效（自动费用计算），不允许作废。
      --医嘱的时间只精确到了分钟，所以变动记录的开始时间要去掉秒来比较。
      v_Count := 0;
      Begin
        Select b.终止时间
        Into v_Date
        From 病人变动记录 B, 病人医嘱计价 C
        Where b.病人id = r_Advice.病人id And b.主页id = r_Advice.主页id And c.医嘱id = Id_In And c.收费细目id = b.护理等级id And
              b.开始原因 = 6 And b.附加床位 = 0 And
              To_Char(b.开始时间, 'yyyy-mm-dd hh24:mi') = To_Char(r_Advice.开始执行时间, 'yyyy-mm-dd hh24:mi');
      Exception
        When Others Then
          v_Count := 1;
      End;
      If v_Count = 0 Then
        --d.后续有其他变动发生
        If v_Date Is Not Null Then
          v_Error := '由于护理等级医嘱生效后已经产生了其他变动记录,不能作废该医嘱。';
          Raise Err_Custom;
        Else
          --本次有要自动启用的护理等级，如果和原来护理等级相同则不用撤消护理变动记录
          If Nvl(护理医嘱id_In, 0) <> 0 Then
            Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
            Select 操作类型
            Into v_Count
            From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
            Where Rownum < 2;
            Update 病人医嘱记录
            Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
            Where ID = 护理医嘱id_In;
            --排除过于频繁的操作
            Select Count(a.Id)
            Into v_Count
            From 病人医嘱记录 A, 诊疗收费关系 B, 病案主页 C
            Where a.诊疗项目id = b.诊疗项目id And c.护理等级id = b.收费项目id And c.病人id = a.病人id And c.主页id = a.主页id And
                  a.Id = 护理医嘱id_In;
          End If;
          If v_Count = 0 Then
            --c.护理等级是最后一条变动
            Zl_病人变动记录_Undo(r_Advice.病人id, r_Advice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
          End If;
        End If;
      Else
        --恢复最近一次被自动停止的护理等级
        If Nvl(护理医嘱id_In, 0) <> 0 Then
          Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
          Select 操作类型
          Into v_Count
          From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
          Where Rownum < 2;
          Update 病人医嘱记录
          Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
          Where ID = 护理医嘱id_In;
        Else
          --病人入院时指定的护理级产生的变动记录和医嘱新开产生的变动记录不同，这里要先判断
          Select Count(a.Id)
          Into v_Count
          From 病人变动记录 A
          Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id And a.开始原因 = 6;
          If v_Count <> 0 Then
            --b.如果与以前的护理等级相同，则校对时没有产生护理等级变动,产生护理等级停止变动
            Zl_病人变动记录_Nurse(r_Advice.病人id, r_Advice.主页id, Null, Sysdate, v_人员编号, v_人员姓名);
          End If;
        End If;
      End If;
    End If;
  Else
    If r_Advice.医嘱状态 <> 8 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"尚未发送或已经作废。';
      Raise Err_Custom;
    End If;

    Begin
      --医嘱ID为传入值的这条医嘱不一定发送了的,甚至无发送。
      Select Distinct 发送号
      Into v_发送号
      From 病人医嘱发送
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    Exception
      When Others Then
        v_发送号 := Null;
    End;

    Select Zl_To_Number(Nvl(zl_GetSysParameter(68), 0)) Into n_先作废后退药 From Dual;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('门诊本科自动执行', '1252'), 0)) Into n_自动取消执行 From Dual;
    If n_自动取消执行 = 1 And v_发送号 Is Not Null Then
      --先更新医嘱和费用的执行状态，因为后续的判断，以及过程Zl_门诊记帐记录_Delete中有检查
      For Rc In (Select a.医嘱id, a.执行部门id
                 From 病人医嘱发送 A, 病人医嘱记录 B
                 Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In) And a.执行部门id = b.病人科室id) Loop
        Zl_病人医嘱执行_Cancel(Rc.医嘱id, v_发送号, Null, 1, Rc.执行部门id);
      End Loop;
    End If;

    --门诊医嘱只可能发送一次
    --后面退费时还有检查，因为可能医嘱没有费用，所以要检查一次执行状态
    Select Count(*)
    Into v_Count
    From 病人医嘱发送 A, 病人医嘱记录 B, 诊疗项目目录 I
    Where a.医嘱id = b.Id And b.诊疗项目id = i.Id And a.执行状态 In (1, 3) And (b.Id = Id_In Or b.相关id = Id_In) And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And Not (b.诊疗类别 In ('5', '6', '7') Or b.诊疗类别 = 'E' And i.操作类型 In ('2', '3', '4')));
    If v_Count > 0 Then
      v_Error := '该医嘱已经执行或正在执行，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  If 作废时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 作废时间_In;
  End If;

  Update 病人医嘱记录 Set 医嘱状态 = 4 Where ID = Id_In Or 相关id = Id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 4, v_人员姓名, v_Date From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In;

  --住院医嘱作废时,未打印的情况下,缺省设置为屏蔽打印
  If r_Advice.挂号单 Is Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱打印
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    If Nvl(v_Count, 0) = 0 Then
      Zl_病人医嘱记录_屏蔽打印(Id_In, 1);
    End If;
  Else
    --门诊医嘱(临嘱)作废时还需要回退相关内容:只有一次发送
    --回退划价或记帐费用
    If v_发送号 Is Not Null Then
      --将该组医嘱的费用删除或销帐(按一组医嘱可能有不同NO处理)
      --门诊记帐：如果原始费用已被销帐(或部分销帐),调用过程中有判断
      --门诊划价：如果已收费，则不允许删除
      v_费用no   := Null;
      v_费用序号 := Null;
      For r_Rollmoney In c_Rollmoney(v_发送号) Loop
        If Nvl(r_Rollmoney.医嘱执行, 0) In (1, 3) Then
          --1-完全执行;3-正在执行
          v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经执行或正在执行，不能作废。';
          Raise Err_Custom;
        End If;
        If Nvl(r_Rollmoney.费用执行, 0) In (1, 2) Then
          --1-完全执行;2-部份执行
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的内容已经全部或部分执行，不能作废。';
          Raise Err_Custom;
        End If;
        If r_Rollmoney.费用执行 = 9 Then
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的收费结算产生异常，不能作废。';
          Raise Err_Custom;
        End If;
        If (n_先作废后退药 = 0 or Not(r_Rollmoney.诊疗类别='E' And r_Rollmoney.操作类型 IN('2','3','4'))) Then
          If r_Rollmoney.记录性质 = 1 And r_Rollmoney.记录状态 <> 0 Then
            v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"已经收费，不能作废。';
            Raise Err_Custom;
          End If;

          If Nvl(v_费用no, '空') <> r_Rollmoney.No Then
            If v_费用序号 Is Not Null And v_费用no Is Not Null Then
              v_费用序号 := Substr(v_费用序号, 2);
              If v_记录性质 = 1 Then
                Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
              Elsif v_记录性质 = 2 Then
                Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
              End If;
            End If;
            v_费用序号 := Null;
          End If;
          v_记录性质 := r_Rollmoney.记录性质;
          v_费用no   := r_Rollmoney.No;
          v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
        End If;
      End Loop;
      If v_费用序号 Is Not Null And v_费用no Is Not Null Then
        v_费用序号 := Substr(v_费用序号, 2);
        If v_记录性质 = 1 Then
          Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
        Elsif v_记录性质 = 2 Then
          Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
        End If;
      End If;

      --如果"门诊药嘱先作废后退药"，则对应的给药途径费用设置为未执行，以便退费
      If n_先作废后退药 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 0
        Where 执行状态 = 1 And 医嘱序号 = Id_In And Exists
         (Select 1
               From 病人医嘱记录 A, 诊疗项目目录 B
               Where a.诊疗项目id = b.Id And b.类别 = 'E' And b.操作类型 In ('2', '3', '4') And a.Id = Id_In);
      End If;

      --回退医嘱发送记录(及执行记录)
      Delete From 病人医嘱执行 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
      Delete From 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);

      --回退特殊医嘱的处理
      If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '1' And r_Advice.执行科室id Is Not Null Then
          --留观医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And 病人性质 In (1, 2);
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        Elsif r_Advice.操作类型 = '2' And r_Advice.执行科室id Is Not Null Then
          --住院医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And Nvl(病人性质, 0) = 0;
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        End If;
      End If;
    End If;
  End If;

  --删除过敏登记记录
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    --Update 病人医嘱记录 Set 皮试结果=Null Where ID=ID_IN; --保留最后的皮试结果
    --删除不过敏的记录，过敏记录保留，因为不管医嘱是否作废，病人对该药过敏
    For r_Test In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10) Loop
      Delete From 病人过敏记录
      Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 记录时间 = r_Test.操作时间;
    End Loop;
  End If;

  Close c_Advice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_作废;
/

--96044:陈刘,2016-05-17,新增参数不同护理文件之间允许数据同步
--94604:陈刘,2016-03-29,体温单不能同步应用方式为1(单独使用)之外的护理项目值
Create Or Replace Procedure Zl_病人护理数据_Update
(
  文件id_In   In 病人护理数据.文件id%Type,
  发生时间_In In 病人护理数据.发生时间%Type,
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，签名记录=5，审签记录=15
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容；37或38/37
  体温部位_In In 病人护理明细.体温部位%Type := Null,
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  审签_In     In Number := 0,
  操作员_In   In 病人护理数据.保存人%Type := Null,
  记录组号_In In 病人护理明细.记录组号%Type := Null, --适用分类汇总(一条数据对应多条相同项目的明细)
  相关序号_In In 病人护理明细.相关序号%Type := Null, --适用分类汇总(记录汇总项目关联的名称项目序号)
  未记说明_In In 病人护理明细.未记说明%Type := Null --入量导入存储医嘱ID:发送号
) Is
  Intins      Number(18);
  Int共用     Number(1);
  n_Newid     病人护理数据.Id%Type;
  n_Oldid     病人护理数据.Id%Type;
  n_行数      病人护理打印.行数%Type;
  n_Mutilbill Number(1);
  n_Syntend   Number(1);
  n_Synchro   Number(1);

  n_汇总类别     病人护理数据.汇总类别%Type;
  v_科室id       部门表.Id%Type;
  v_保存人       人员表.姓名%Type;
  v_记录人       人员表.姓名%Type;
  n_文件id       病人护理数据.文件id%Type;
  n_记录id       病人护理数据.Id%Type;
  n_明细id       病人护理明细.Id%Type;
  n_来源id       病人护理明细.来源id%Type;
  v_数据来源     病人护理明细.数据来源%Type;
  n_最高版本     病人护理明细.开始版本%Type;
  n_项目性质     护理记录项目.项目性质%Type;
  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  --提取该病人当前科室所有未结束的护理文件，且文件开始时间小于等于记录发生时间的文件列表供同步数据使用
  Cursor Cur_Fileformats Is
    Select a.Id As 格式id, b.Id As 文件id, a.保留, a.子类, b.婴儿
    From 病历文件列表 A, 病人护理文件 B, 病人护理文件 C, 病人护理数据 D
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id <> c.Id And b.结束时间 Is Null And b.开始时间 <= d.发生时间 And
          (a.通用 = 1 Or (a.通用 = 2 And b.科室id = c.科室id)) And c.病人id = b.病人id And c.主页id = b.主页id And c.婴儿 = b.婴儿 And
          c.Id = d.文件id And d.Id = n_记录id And c.Id = 文件id_In
    Order By a.编号;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --取记录ID
  Int共用     := 0;
  n_记录id    := 0;
  n_Mutilbill := 0;
  n_Syntend   := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;

  --如果是对应多份护理文件值为1，表示需同步其它护理文件；否则不处理文件同步
  n_Mutilbill := Zl_To_Number(zl_GetSysParameter('对应多份护理文件', 1255));
  --如果允许多份护理文件之间数据同步,则自动同步,否则不同步
  n_Syntend := Zl_To_Number(zl_GetSysParameter('允许数据同步', 1255));

  Begin
    Select ID, 汇总类别
    Into n_记录id, n_汇总类别
    From 病人护理数据
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 And 审签_In = 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '你无权修改他人登记的护理数据！';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否入科
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '59', 'YYYY-MM-DD HH24:MI:SS') >= a.开始时间 And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '00', 'YYYY-MM-DD HH24:MI:SS') < = Nvl(a.终止时间, Sysdate) Or
            a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or 发生时间_In > d_婴儿出院时间 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;

  --如果数据来源<>0则退出
  n_来源id := 0;
  If n_记录id > 0 Then
    Begin
      Select 数据来源, Nvl(来源id, 0)
      Into v_数据来源, n_来源id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0);
    Exception
      When Others Then
        v_数据来源 := 0;
    End;
    If v_数据来源 > 0 And n_来源id > 0 Then
      Return;
    End If;
  End If;

  --取最高版本
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1, Count(b.Id)
  Into n_最高版本, Intins
  From 病人护理明细 A, 病人护理数据 B
  Where b.Id = n_记录id And a.记录id = b.Id And Mod(a.记录类型, 10) = 5;

  --目前已经签名的数据不能修改，只有在审签模式下进行修改，即审签_In=1
  If 审签_In <> 1 And Intins > 0 Then
    v_Error := '发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 所对应的数据已经签名或审签，不能继续操作！' || Chr(13) || Chr(10) ||
               '这可能是由于网络并发操作引起的，请刷新后再试！';
    Raise Err_Custom;
  End If;
  Intins := 0;

  --无内容时,要清除数据（审签回退时会自动清除审签过程中修改的数据，所以此处只需考虑普签即可）
  If 记录内容_In Is Null Then
    Begin
      Select ID
      Into n_明细id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      --无数据退出
      When Others Then
        Return;
    End;
  
    --查找除了本条要删除的数据，是否还存其他有效的数据，如果存在只删除本条数据，否则删除此发生时间对应的所有数据。
    Select Count(ID)
    Into Intins
    From 病人护理明细
    Where 记录id = n_记录id And Mod(记录类型, 10) <> 5 And 终止版本 Is Null And ID <> n_明细id;
    If Intins = 0 Then
      Delete From 病人护理明细 Where 记录id = n_记录id;
    Else
      Delete From 病人护理明细 Where ID = n_明细id;
    End If;
  
    Delete From 病人护理数据 A
    Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理明细 B Where b.记录id = a.Id);
  
    --如果是删除签名后修改产生的最后一条数据,则应将签名记录的终止版本清为空
    Begin
      Select 1
      Into Intins
      From 病人护理明细
      Where 开始版本 = n_最高版本 And 终止版本 Is Null And 记录类型 = 1 And 记录id = n_记录id;
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Update 病人护理明细 Set 终止版本 = Null Where 记录类型 = 5 And 开始版本 = n_最高版本 - 1 And 记录id = n_记录id;
    End If;
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --清除共用数据
    --############
    For Rsdel In (Select Distinct 记录id From 病人护理明细 Where 来源id = n_明细id) Loop
    
      Delete 病人护理明细 Where 来源id = n_明细id And 记录id = Rsdel.记录id;
      --删除对应的打印数据
      Begin
        Select Count(*) Into Intins From 病人护理明细 Where 记录id = Rsdel.记录id;
      Exception
        When Others Then
          Intins := 0;
      End;
      If Intins = 0 Then
        --提取清除数据对应的文件ID
        Begin
          Select b.Id, a.保留
          Into n_文件id, Intins
          From 病历文件列表 A, 病人护理文件 B, 病人护理数据 C
          Where a.Id = b.格式id And b.Id = c.文件id And c.Id = Rsdel.记录id;
        Exception
          When Others Then
            n_文件id := 0;
        End;
        Delete 病人护理数据 Where ID = Rsdel.记录id;
        If Intins <> -1 Then
          Zl_病人护理打印_Update(n_文件id, 发生时间_In, 1, 1);
        End If;
      End If;
    End Loop;
  Else
    --检查录入的项目是否属于该记录单
    Begin
      Select 1
      Into Intins
      From (Select b.项目序号
             From 病历文件结构 A, 护理记录项目 B
             Where a.要素名称 = b.项目名称 And b.项目序号 = 项目序号_In And
                   父id = (Select b.Id
                          From 病人护理文件 A, 病历文件结构 B
                          Where a.Id = 文件id_In And a.格式id = b.文件id And b.父id Is Null And b.对象序号 = 4)
             Union
             Select 项目序号
             From 护理记录项目
             Where 项目性质 = 2 And 项目序号 = 项目序号_In);
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Return;
    End If;
    If n_记录id = 0 Then
      Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    
      Insert Into 病人护理数据
        (ID, 文件id, 发生时间, 最后版本, 保存人, 保存时间)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_最高版本, v_保存人, Sysdate);
    End If;
  
    --插入本次登记的病人护理明细
    Update 病人护理明细
    Set 记录内容 = 记录内容_In, 数据来源 = 数据来源_In, 未记说明 = 未记说明_In, 记录人 = v_保存人, 记录时间 = Sysdate
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    If Sql%RowCount = 0 Then
      Select 病人护理明细_Id.Nextval Into n_明细id From Dual;
      Insert Into 病人护理明细
        (ID, 记录id, 记录类型, 项目分组, 项目id, 相关序号, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录组号, 体温部位, 数据来源, 共用, 未记说明, 开始版本, 终止版本,
         记录人, 记录时间)
        Select n_明细id, n_记录id, 记录类型_In, a.分组名, a.项目id, 相关序号_In, a.项目序号, Upper(a.项目名称), a.项目类型, 记录内容_In, a.项目单位, 0,
               记录组号_In, 体温部位_In, 数据来源_In, Nvl(b.共用, 0), 未记说明_In, n_最高版本, Null, v_保存人, Sysdate
        From 护理记录项目 A, 病人护理明细 B
        Where a.项目序号 = b.项目序号(+) And b.终止版本(+) Is Null And b.记录id(+) = n_记录id And a.项目序号 = 项目序号_In And Rownum < 2;
    End If;
    Select ID
    Into n_明细id
    From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    --填写历史数据及签名记录的终止版本
    Update 病人护理明细
    Set 终止版本 = n_最高版本
    Where 记录id = n_记录id And ((Mod(记录类型, 10) <> 5 And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0)) Or 记录类型 = Decode(审签_In, 1, 15, 5)) And 开始版本 <= n_最高版本 - 1 And 终止版本 Is Null;
  
    --如果是未签名数据，最后修改操作员做为该记录的保存人更新
    If n_最高版本 = 1 Then
      Update 病人护理数据 Set 保存人 = v_保存人, 保存时间 = Sysdate Where ID = n_记录id;
    End If;
  
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --同步共用数据
    --############
    --1\先处理体温单（一个病人始终只存在一份有效的体温单文件）
    --如果体温表存在相同发生时间的数据，使用它的ID
    --CL,2015-12-30,记录单同步文字项目到体温单
    For Row_Format In Cur_Fileformats Loop
      If Row_Format.保留 = -1 Then
        If Row_Format.子类 = '1' Then
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (Select To_Char(f.项目序号) As 序号, g.项目性质
                   From 体温记录项目 F, 护理记录项目 G
                   Where f.项目序号 = g.项目序号 And g.项目性质 = 2 And
                         (g.适用科室 = 1 Or
                         (g.适用科室 = 2 And Exists
                          (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id))) And Nvl(g.应用方式, 0) <> 0 And
                         (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2))
                   Union All
                   Select b.内容文本 As 序号, 1 As 项目性质
                   From 病历文件结构 A, 病历文件结构 B
                   Where a.文件id = Row_Format.格式id And a.父id Is Null And a.对象序号 In (2, 3) And b.父id = a.Id) H
            Where Instr(',' || h.序号 || ',', ',' || 项目序号_In || ',', 1) > 0;
          Exception
            When Others Then
              Intins := 0;
          End;
        Else
          Begin
            Select 1, g.项目性质
            Into Intins, n_项目性质
            From 体温记录项目 F, 护理记录项目 G
            Where f.项目序号 = g.项目序号 And Nvl(g.应用方式, 0) <> 0 And g.护理等级 >= 0 And
                  (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2)) And f.项目序号 = 项目序号_In And
                  (g.适用科室 = 1 Or (g.适用科室 = 2 And Exists
                   (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id)));
          Exception
            When Others Then
              Intins := 0;
          End;
        End If;
      
        If Intins > 0 Then
          --LPF,2013-01-23,检查此项目是否需要进行同步(对于以前已经同步过的数据，为了保证记录单和体温单数据一直将不根据此函数判断。)
          n_Synchro := Zl_Temperatureprogram(文件id_In, v_科室id, 项目序号_In, 发生时间_In);
          Begin
            Select b.Id
            Into n_Newid
            From 病人护理文件 A, 病人护理数据 B
            Where a.Id = Row_Format.文件id And b.文件id = a.Id And b.发生时间 = 发生时间_In;
          Exception
            When Others Then
              n_Newid := 0;
          End;
          n_Oldid := n_Newid;
          If n_Newid = 0 And n_Synchro = 1 Then
            Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            --产生体温单主记录
            Insert Into 病人护理数据
              (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
            Values
              (n_Newid, Row_Format.文件id, v_保存人, Sysdate, 发生时间_In, 1);
          End If;
        
          If n_Newid > 0 Then
            --插入未同步的体温单数据(仍然要联接多表查询)
            Select Count(*)
            Into v_数据来源
            From 病人护理明细
            Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                  Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
            If v_数据来源 = 0 Then
              --说明在同步开始已经进行过检查
              If n_Synchro = 1 Then
                --没有检查此项目是否需要同步
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 开始版本, 终止版本, 记录人,
                   记录时间, 记录组号)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, 1, Null, b.记录人, Sysdate, 1
                  From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                         From Dual
                         Minus
                         Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                         From 病人护理明细 E, 护理记录项目 F
                         Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            Else
              Update 病人护理明细
              Set 记录内容 = 记录内容_In, 来源id = n_明细id
              Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                    Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
              If Sql%RowCount > 0 Then
                Int共用 := 1;
              End If;
            End If;
          End If;
        End If;
        --2\再循环处理记录单
      Else
        If n_Mutilbill = 1 And n_Syntend = 1 Then
          --提取记录单与当前记录单存在重叠的且有数据的固定项目
          Select Count(*)
          Into Intins
          From (Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B
                 Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                       父id =
                       (Select ID From 病历文件结构 Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                 Intersect
                 Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                 Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                       b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                       a.父id = (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4));
        
          If Intins > 0 Then
            n_Newid := 0;
            --可能指定文件已经存在相同发生时间的数据，直接用它的ID即可
            Begin
              Select c.Id
              Into n_Newid
              From 病人护理数据 C
              Where c.文件id = Row_Format.文件id And c.发生时间 = 发生时间_In;
            Exception
              When Others Then
                n_Newid := 0;
            End;
          
            If n_Newid = 0 Then
              --产生记录单主记录
              Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            
              Insert Into 病人护理数据
                (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
                Select n_Newid, Row_Format.文件id, c.保存人, c.保存时间, c.发生时间, 1
                From 病人护理数据 C
                Where c.Id = n_记录id;
            End If;
          
            If n_Newid > 0 Then
              --插入未同步的记录单数据
              Select Count(*) Into v_数据来源 From 病人护理明细 Where 记录id = n_Newid And 项目序号 = 项目序号_In;
              If v_数据来源 = 0 Then
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                   记录人, 记录时间)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, b.未记说明, 1, Null, b.记录人, Sysdate
                  From (Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B
                         Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                               父id = (Select ID
                                      From 病历文件结构
                                      Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                         Intersect
                         Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                         Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                               b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                               a.父id =
                               (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4)) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                  --原行数不要动
                  Begin
                    Select 行数 Into n_行数 From 病人护理打印 Where 文件id = Row_Format.文件id And 记录id = n_Newid;
                  Exception
                    When Others Then
                      n_行数 := 1;
                  End;
                  Zl_病人护理打印_Update(Row_Format.文件id, 发生时间_In, n_行数, 0);
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 未记说明 = 未记说明_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;
  
    If Int共用 = 1 Then
      Update 病人护理明细 Set 共用 = 1 Where ID = n_明细id;
      --将历史数据的共用标志设置为NULL
      Update 病人护理明细 Set 共用 = Null Where 记录id = n_记录id And 项目序号 = 项目序号_In And ID <> n_明细id;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理数据_Update;
/

--94391:刘尔旋,2016-03-29,执行登记门诊记帐划价处理
Create Or Replace Procedure Zl_病人费用记录_Execute
(
  No_In         住院费用记录.No%Type,
  记录性质_In   住院费用记录.记录性质%Type,
  序号_In       Varchar2,
  来源_IN       Number := 2,
  结论_In       住院费用记录.结论%Type,
  执行人_In     住院费用记录.执行人%Type,
  执行时间_In   住院费用记录.执行时间%Type,
  仅更新费用_In Number := 0
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --来源_IN :1-门诊;2-住院
  -- 仅更新费用_In:1表示:只更新病人费用记录.执行人,执行时间,结论;0-根据执行情况填写相关表

  n_医嘱id 病人医嘱发送.医嘱id%Type;
  v_发送号 病人医嘱发送.发送号%Type;

  n_执行 Number(1);
  v_Temp Varchar2(255);

  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_发料号  药品收发记录.汇总发药号%Type;
  n_库房id  药品收发记录.库房id%Type;
  v_收发ids Varchar2(4000);
  d_Date    Date;
  n_Count   Number(8);

  --执行跟踪在用的未发卫料时，根据参数设置是否自动发料
  Cursor c_Stuff_Mz Is
    Select ID, 库房id
    From 药品收发记录 M
    Where NO = No_In And (单据 = 25 And 记录性质_In = 2 Or 单据 = 24 And 记录性质_In = 1) And 库房id Is Not Null And Mod(记录状态, 3) = 1 And
          审核人 Is Null And Exists (Select 1
           From 门诊费用记录 A, 材料特性 B
           Where a.Id = m.费用id + 0 And a.记录性质 = 记录性质_In And a.记录状态 = 1 And a.No = No_In And
                 (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or
                 序号_In Is Null) And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id, 药品id;

  Cursor c_Stuff_Zy Is
    Select ID, 库房id
    From 药品收发记录 M
    Where NO = No_In And 单据 In (25, 26) And 记录性质_In = 2 And 库房id Is Not Null And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          Exists (Select 1
           From 住院费用记录 A, 材料特性 B
           Where a.Id = m.费用id + 0 And a.记录性质 = 记录性质_In And a.记录状态 = 1 And a.No = No_In And
                 (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And
                 a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id, 药品id;

Begin
  --执行后自动审核对应的划价费用
  If Nvl(仅更新费用_In, 0) = 1 Then
  
    If 来源_IN = 1 Then
      Update 门诊费用记录 A
      Set a.执行人 = 执行人_In, a.执行时间 = 执行时间_In, a.执行状态 = 1, a.结论 = 结论_In
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
            Nvl(a.执行状态, 0) <> 9;
    Else
      Update 住院费用记录 A
      Set a.执行人 = 执行人_In, a.执行时间 = 执行时间_In, a.执行状态 = 1, a.结论 = 结论_In
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1);
    End If;
    Return;
  End If;
  Select Zl_To_Number(Nvl(zl_GetSysParameter(81), '0')) Into n_执行 From Dual;

  If n_执行 = 1 Then
    --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Zl_Username;
  
    --不用检查是否已审核,审核过程自动读取
    If 来源_In = 1 Then
      Zl_门诊记帐记录_Verify(No_In, v_人员编号, v_人员姓名, 序号_In);
    Elsif 来源_In = 2 Then
      Zl_住院记帐记录_Verify(No_In, v_人员编号, v_人员姓名, 序号_In);
    End If;
  End If;
  --执行之后卫材自动发料
  Select Nvl(zl_GetSysParameter(33), '0') Into v_Temp From Dual;

  --填写执行情况及状态
  ---执行之后卫材自动发料,则不需要更新跟踪在用的卫材
  If 来源_IN = 1 Then
    Update 门诊费用记录 A
    Set a.执行人 = 执行人_In, a.执行时间 = 执行时间_In, a.执行状态 = 1, a.结论 = 结论_In
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          Nvl(a.执行状态, 0) <> 9 And a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  Else
    Update 住院费用记录 A
    Set a.执行人 = 执行人_In, a.执行时间 = 执行时间_In, a.执行状态 = 1, a.结论 = 结论_In
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  End If;

  --处理并发，若单据全部是药品或非跟踪在用状态下的卫材，程序里面已做禁止执行
  --若单据中存在跟踪在用卫材，且执行之后卫材自动发料，此时不抛出错误
  If Sql%NotFound Then
    If v_Temp = '1' Then
      If 来源_IN = 1 Then
        Select Count(1)
        Into n_Count
        From 门诊费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              Nvl(a.执行状态, 0) <> 9 And a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      Else
        Select Count(1)
        Into n_Count
        From 住院费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      End If;
    
      If n_Count <> 0 Then
        v_Err_Msg := '未找到相关的费用数据,可能该单据正在进行收费,不能执行登记或与系统管理员联系!';
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '未找到相关的费用数据,可能该单据正在进行收费,不能执行登记或与系统管理员联系!';
      Raise Err_Item;
    End If;
  End If;

  Begin
    If 来源_IN = 1 Then
      Select a.医嘱id, a.发送号
      Into n_医嘱id, v_发送号
      From 病人医嘱发送 A, 门诊费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    Else
      Select a.医嘱id, a.发送号
      Into n_医嘱id, v_发送号
      From 病人医嘱发送 A, 住院费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    End If;
  Exception
    When Others Then
      Null;
  End;
  --执行之后卫材自动发料
  --虽然Zl_住院记帐记录_Verify可能已执行了自动发料,但是取消执行后,再次执行时,不会再次审核,所以需要调自动发料

  v_人员姓名 := Zl_Username;
  If v_Temp = '1' Then
    Select Sysdate Into d_Date From Dual;
    If 来源_IN = 1 Then
      For r_Stuff In c_Stuff_Mz Loop
        If v_发料号 Is Null Then
          v_发料号 := Nextno(20);
        End If;
        If r_Stuff.库房id <> Nvl(n_库房id, 0) Then
          If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
            v_收发ids := Substr(v_收发ids, 2);
            Zl_药品收发记录_批量发料(v_收发ids, n_库房id, v_人员姓名, d_Date, 1, v_人员姓名, v_发料号, v_人员姓名);
          End If;
        
          n_库房id  := r_Stuff.库房id;
          v_收发ids := Null;
        End If;
      
        v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
      End Loop;
    Else
      For r_Stuff In c_Stuff_Zy Loop
        If v_发料号 Is Null Then
          v_发料号 := Nextno(20);
        End If;
        If r_Stuff.库房id <> Nvl(n_库房id, 0) Then
          If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
            v_收发ids := Substr(v_收发ids, 2);
            Zl_药品收发记录_批量发料(v_收发ids, n_库房id, v_人员姓名, d_Date, 1, v_人员姓名, v_发料号, v_人员姓名);
          End If;
        
          n_库房id  := r_Stuff.库房id;
          v_收发ids := Null;
        End If;
      
        v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
      End Loop;
    End If;
    If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, n_库房id, v_人员姓名, d_Date, 1, v_人员姓名, v_发料号, v_人员姓名);
    End If;
  End If;

  If n_医嘱id Is Not Null And v_发送号 Is Not Null Then
    --处理医嘱的执行状态
    --如果同一张医嘱发送单都执行完了,才更新执行状态为已执行
    If Not 序号_In Is Null Then
      If 来源_IN = 1 Then
        Select Count(*)
        Into n_Count
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 医嘱序号 = n_医嘱id And 执行状态 = 0 And 记录状态 In (1, 3);
      Else
        Select Count(*)
        Into n_Count
        From 住院费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 医嘱序号 = n_医嘱id And 执行状态 = 0 And 记录状态 In (1, 3);
      End If;
    Else
      n_Count := 0;
    End If;
  
    If n_Count = 0 Then
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = Sysdate
      Where 发送号 = v_发送号 And 医嘱id = n_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 In (0, 3);
    Else
      Update 病人医嘱发送
      Set 执行状态 = 3
      Where 发送号 = v_发送号 And 医嘱id = n_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 = 0;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用记录_Execute;
/

--93964:胡俊勇,2016-03-25,变动记录错误问题

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_参数值   Zlparameters.参数值%Type;
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select zl_GetSysParameter(25) Into v_参数值 From Dual;
    If Nvl(v_参数值, '0') <> '0' Then
      Select zl_GetSysParameter(26) Into v_参数值 From Dual;
      If v_前提id Is Null Then
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 1;
      Else
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 3;
      End If;
      If Nvl(Substr(v_参数值, 2, 1), '0') = '1' And v_前提id Is Null And v_Count > 0 Or
         Nvl(Substr(v_参数值, 3, 1), '0') = '1' And v_前提id Is Not Null And v_Count > 0 Then
        Select Nvl(Max(是否停用), 0)
        Into v_Count
        From (Select a.是否停用, a.注册时间
               From 人员证书记录 A, 人员表 B
               Where a.人员id = b.Id And b.姓名 = v_开嘱医生
               Order By a.注册时间 Desc)
        Where Rownum < 2;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;
      
        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;
  
    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
  
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;
  
    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;
      
        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;
    
      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;
    
      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;
      
        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;
      
        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;
      
        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--93964:胡俊勇,2016-03-25,变动记录错误问题

--95134:余伟节,2016-06-03,变动记录终止时间小于上次计算时间需要将上次计算时间填为NULL
Create Or Replace Procedure Zl_病人医嘱记录_停止
(
  --功能：停止指定的医嘱 
  --说明：一并给药的只能调用一次 
  --参数：ID_IN=相关ID为NULL的医嘱的ID(给药途径,中药用法,检查项目,主要手术,及独立医嘱) 
  --      内部调用_IN=是否其他过程内部在调用，主要区分是否手工调用停止护理等级 
  Id_In         病人医嘱记录.Id%Type,
  终止时间_In   病人医嘱记录.执行终止时间%Type,
  停嘱医生_In   病人医嘱记录.停嘱医生%Type,
  内部调用_In   Number := 0,
  医师资格_In   Number := 0,
  停嘱审核_In   Number := 0,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_病人id     病案主页.病人id%Type;
  v_主页id     病案主页.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;

  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= 终止时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%Rowtype;
  r_Endinfo  c_Endinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 病人变动记录.操作员编号%Type;
  v_人员姓名 病人变动记录.操作员姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作 
  Select a.医嘱状态, a.医嘱内容, a.病人id, a.主页id, Nvl(a.婴儿, 0), Nvl(a.诊疗类别, '*') As 诊疗类别, b.操作类型
  Into v_状态, v_医嘱内容, v_病人id, v_主页id, v_婴儿, v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id(+) And a.Id = Id_In;
  If v_状态 In (4, 8, 9) Then
    v_Error := '医嘱"' || v_医嘱内容 || '"已经被作废或停止，不能再停止。';
    Raise Err_Custom;
  End If;

  --检查是否是输液配液记录，并是否已经锁定 
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In And 执行时间 > 终止时间_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能停止。';
    Raise Err_Custom;
  End If;

  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  Select Sysdate Into v_Date From Dual;

  --判断是否具有执业医师或助理医师的资格和参数是否勾选 
  If 医师资格_In > 0 Or 停嘱审核_In = 0 Then
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 终止时间_In, 停嘱医生 = Decode(审核标记, 2, 停嘱医生_In || Decode(停嘱医生, Null, '', '/' || 停嘱医生), 停嘱医生_In),
        停嘱时间 = v_Date, 审核标记 = Decode(审核标记, 2, 3, 审核标记)
    Where ID = Id_In Or 相关id = Id_In;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, v_Date --护士停时记录为护士 
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  Else
    --否则只修改审核标记，产生新的状态,实习医生名字填写 
    Update 病人医嘱记录 Set 审核标记 = 2, 停嘱医生 = 停嘱医生_In Where ID = Id_In Or 相关id = Id_In;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
      Select ID, 13, v_人员姓名, v_Date, To_Char(终止时间_In, 'YYYY-MM-DD HH24:MI:SS') --护士停时记录为护士 
      From 病人医嘱记录
      Where ID = Id_In Or 相关id = Id_In;
  End If;

  --其他特殊处理 
  If Nvl(内部调用_In, 0) = 0 And (医师资格_In > 0 Or 停嘱审核_In = 0) Then
    --停止病情医嘱时，变动病人病情 
    If v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') Then
      Open c_Oldinfo; --必须在处理之前先打开 
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%Rowcount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页 Set 当前病况 = '一般' Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动 
      If r_Oldinfo.终止时间 Is Not Null Then
        v_终止时间 := r_Oldinfo.终止时间;
        v_终止原因 := r_Oldinfo.终止原因;
        v_终止人员 := r_Oldinfo.终止人员;
        --取消上次变动 
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间 
        Update 病人变动记录
        Set 病情 = '一般', 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > 终止时间_In;
      Else
        Update 病人变动记录
        Set 终止时间 = 终止时间_In, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, 终止时间_In) - 终止时间_In), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, 终止时间_In, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, '一般', v_人员编号, v_人员姓名, v_终止时间, v_终止原因, v_终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'H' And v_操作类型 = '1' And v_婴儿 = 0 Then
      --停止护理等级时，同时取消病人的护理等级费用 
      Begin
        Select c.收费细目id
        Into v_护理等级id
        From 病人医嘱记录 A, 病人医嘱计价 C, 收费项目目录 D
        Where a.Id = c.医嘱id And c.收费细目id = d.Id And d.类别 = 'H' And Nvl(d.项目特性, 0) <> 0 And a.Id = Id_In And Rownum = 1 And
              Exists
         (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = c.收费细目id);
      Exception
        When Others Then
          Null;
      End;
      If v_护理等级id Is Not Null Then
        --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作 
        v_Date := To_Date(To_Char(终止时间_In, 'yyyy-mm-dd hh24:mi') || To_Char(v_Date, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, Null, v_Date, v_人员编号, v_人员姓名);
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人医嘱记录_停止;
/

--94427:刘尔旋,2016-03-29,医嘱发送生成条码接口
--94337:刘尔旋,2016-03-22,是否持卡消费
Create Or Replace Procedure Zl_医疗卡类别_Update
(
  Id_In             In 医疗卡类别.Id%Type,
  编码_In           In 医疗卡类别.编码%Type,
  名称_In           In 医疗卡类别.名称%Type,
  短名_In           In 医疗卡类别.短名%Type,
  前缀文本_In       In 医疗卡类别.前缀文本%Type,
  卡号长度_In       In 医疗卡类别.卡号长度%Type,
  缺省标志_In       In 医疗卡类别.缺省标志%Type,
  是否固定_In       In 医疗卡类别.是否固定%Type,
  是否严格控制_In   In 医疗卡类别.是否严格控制%Type,
  是否刷卡_In       In 医疗卡类别.是否刷卡%Type,
  是否自制_In       In 医疗卡类别.是否自制%Type,
  是否存在帐户_In   In 医疗卡类别.是否存在帐户%Type,
  是否全退_In       In 医疗卡类别.是否全退%Type,
  部件_In           In 医疗卡类别.部件%Type,
  备注_In           In 医疗卡类别.备注%Type,
  特定项目_In       In 医疗卡类别.特定项目%Type,
  收费细目id_In     In 收费项目目录.Id%Type,
  结算方式_In       In 医疗卡类别.结算方式%Type,
  是否启用_In       In 医疗卡类别.是否启用%Type,
  卡号密文_In       In 医疗卡类别.卡号密文%Type,
  是否重复使用_In   In 医疗卡类别.是否重复使用%Type,
  密码长度_In       In 医疗卡类别.密码长度%Type,
  密码长度限制_In   In 医疗卡类别.密码长度限制%Type,
  密码规则_In       In 医疗卡类别.密码规则%Type,
  是否退现_In       In 医疗卡类别.是否退现%Type,
  操作方式_In       In Integer := 0,
  是否模糊查找_In   In 医疗卡类别.是否模糊查找%Type := 0,
  密码输入限制_In   In 医疗卡类别.密码输入限制%Type := 0,
  是否缺省密码_In   In 医疗卡类别.是否缺省密码%Type := 0,
  是否制卡_In       In 医疗卡类别.是否制卡%Type := 0,
  是否发卡_In       In 医疗卡类别.是否发卡%Type := 0,
  是否写卡_In       In 医疗卡类别.是否写卡%Type := 0,
  险类_In           In 医疗卡类别.险类%Type := 0,
  发卡性质_In       In 医疗卡类别.发卡性质%Type := 0,
  是否转帐及代扣_In In 医疗卡类别.是否转帐及代扣%Type := 0,
  是否持卡消费_In   In 医疗卡类别.是否持卡消费%Type := 0,
  发送调用接口_In   In 医疗卡类别.发送调用接口%Type := 0
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  If Nvl(是否自制_In, 0) = 1 And Nvl(是否存在帐户_In, 0) = 1 Then
    v_Err_Msg := '[ZLSOFT]是否存在帐户只有非自制卡才会存在,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 0 And Nvl(是否存在帐户_In, 0) = 1 And 结算方式_In Is Null Then
    v_Err_Msg := '[ZLSOFT]第三方机构的卡结算，必须要设置结算方式,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 1 And 特定项目_In Is Null Then
    v_Err_Msg := '[ZLSOFT]特定项目必须输入,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  If 操作方式_In = 0 Then
    Insert Into 医疗卡类别
      (ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, 是否刷卡, 是否自制, 是否存在帐户, 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, 是否重复使用,
       密码长度, 密码长度限制, 密码规则, 是否退现, 是否模糊查找, 密码输入限制, 是否缺省密码, 是否制卡, 是否发卡, 是否写卡, 险类, 发卡性质, 是否转帐及代扣, 是否持卡消费, 发送调用接口)
    Values
      (Id_In, 编码_In, 名称_In, 短名_In, 前缀文本_In, 卡号长度_In, 缺省标志_In, 是否固定_In, 是否严格控制_In, 是否刷卡_In, 是否自制_In, 是否存在帐户_In, 是否全退_In,
       部件_In, 备注_In, 特定项目_In, 结算方式_In, 是否启用_In, 卡号密文_In, 是否重复使用_In, 密码长度_In, 密码长度限制_In, 密码规则_In, 是否退现_In, 是否模糊查找_In,
       密码输入限制_In, 是否缺省密码_In, 是否制卡_In, 是否发卡_In, 是否写卡_In, 险类_In, 发卡性质_In, 是否转帐及代扣_In, 是否持卡消费_In, 发送调用接口_In);
  
  Else
  
    Delete 收费特定项目 Where 特定项目 = (Select Max(特定项目) From 医疗卡类别 Where ID = Id_In);
  
    Update 医疗卡类别
    Set 编码 = 编码_In, 名称 = 名称_In, 短名 = 短名_In, 前缀文本 = 前缀文本_In, 卡号长度 = 卡号长度_In, 缺省标志 = 缺省标志_In, 是否严格控制 = 是否严格控制_In,
        是否刷卡 = 是否刷卡_In, 是否自制 = 是否自制_In, 是否存在帐户 = 是否存在帐户_In, 是否全退 = 是否全退_In, 部件 = 部件_In, 备注 = 备注_In, 特定项目 = 特定项目_In,
        结算方式 = 结算方式_In, 是否启用 = 是否启用_In, 卡号密文 = 卡号密文_In, 是否重复使用 = 是否重复使用_In, 密码长度 = 密码长度_In, 密码长度限制 = 密码长度限制_In,
        密码规则 = 密码规则_In, 是否退现 = 是否退现_In, 是否模糊查找 = 是否模糊查找_In, 密码输入限制 = 密码输入限制_In, 是否缺省密码 = 是否缺省密码_In, 是否制卡 = 是否制卡_In,
        是否发卡 = 是否发卡_In, 是否写卡 = 是否写卡_In, 险类 = 险类_In, 发卡性质 = 发卡性质_In, 是否转帐及代扣 = 是否转帐及代扣_In, 是否持卡消费 = 是否持卡消费_In,
        发送调用接口 = 发送调用接口_In
    Where ID = Id_In;
    If Nvl(缺省标志_In, 0) = 1 Then
      Update 医疗卡类别 Set 缺省标志 = 0 Where ID <> Id_In;
    End If;
  
  End If;
  If Not 特定项目_In Is Null And Nvl(收费细目id_In, 0) <> 0 Then
    Insert Into 收费特定项目 (特定项目, 收费细目id) Values (特定项目_In, 收费细目id_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡类别_Update;
/

--94362:胡俊勇,2016-03-23,临床护士调整输液批次
Create Or Replace Procedure Zl_输液配药记录_Update
(
  配药id_In   In Varchar2,
  是否打包_In In 输液配药记录.是否打包%Type,
  配药批次_In In 输液配药记录.配药批次%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  n_Ct    Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Count(1)
  Into n_Ct
  From 输液配药记录
  Where ID = 配药id_In And 操作状态 In (1, 2, 3) And Nvl(配药批次, 0) <> Nvl(配药批次_In, 0);
  
  Update 输液配药记录
  Set 是否打包 = 是否打包_In, 配药批次 = 配药批次_In, 打包时间 = Decode(是否打包_In, 1, 核查时间_In, Null), 批次标记 = Decode(n_Ct, 1, 2, 批次标记)
  Where ID = 配药id_In And 操作状态 In (1, 2, 3);

  If Sql%RowCount = 0 Then
    v_Error := '由于并发操作,当前修改的配药记录已配药,操作失败.';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_Update;
/

--95362:刘尔旋,2016-04-21,医生站划价收费推送消息问题
--94248:刘兴洪,2016-03-21,并发引起的预交余额不正确
Create Or Replace Procedure Zl_划价收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  三方卡结算_In Varchar2 := Null,
  登记时间_In   门诊费用记录.登记时间%Type := Null,
  结算序号_In   病人预交记录.结算序号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  简单收费_In   Number := 0
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n
  --        病人来源_IN:1-门诊;2-住院
  --        收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --        保险结算_IN:格式="结算方式|结算金额||....."
  --        三方卡结算_In:格式=卡类别Id|是否消费卡|结算金额|卡号|备注||...
  --        交易流水号_In和交易说明_In:收费结算_IN时有效.
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容

  --=================================
  --备注：该过程目前只有简单收费使用！
  --=================================

  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, Nvl(a.预交类别, 2) As 预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, Nvl(预交类别, 2) As 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(预交类别, 2) = 1 And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id = v_病人id Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, Nvl(预交类别, 2))
    Order By ID, 预交类别 Desc, NO;

  --预交与结算相关变量
  n_预交金额 病人预交记录.冲预交%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  v_标识号   门诊费用记录.标识号%Type;
  v_付款方式 医疗付款方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;

  --临时变量
  n_Count      Number;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_组id     财务缴款分组.Id%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  n_消费卡   Number;
  v_卡号     病人预交记录.卡号%Type;
  v_卡名称   Varchar2(100);
  n_自制卡   Number;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_金额     病人预交记录.金额%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    v_Err_Msg := '不能读取划价单内容,该单据可能已经删除或已经收费！';
    Raise Err_Item;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = v_标识号, 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
          性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      v_Err_Msg := '由于并发操作,该单据可能已经删除或已经收费！';
      Raise Err_Item;
    End If;
  End Loop;
  Close c_Price;
  ------------------------------------------------------------------------------------------------------------------------

  --预交款相关结算
  --收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 交易流水号,
           交易说明, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, v_Date,
           操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 结算序号_In, 交易流水号_In, 交易说明_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, v_Date, 操作员编号_In,
           操作员姓名_In, n_结算金额, 结帐id_In, n_组id, 结算序号_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := v_当前结算;
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 卡类别id, 结算卡序号, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id,
           结算序号, 卡号, 结算性质)
        Values
          (n_预交id, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, Decode(n_消费卡, 1, Null, n_卡类别id),
           Decode(n_消费卡, 0, Null, n_卡类别id), v_结算方式, v_结算号码, v_Date, 操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Null, Null,
           n_组id, 结算序号_In, v_卡号, 3);
      
        --卡结算对照
        If n_消费卡 = 1 Then
          n_消费卡id := Null;
          If n_自制卡 = 1 Then
            Select ID
            Into n_消费卡id
            From 消费卡目录
            Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                  序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
          End If;
          Zl_病人卡结算记录_Insert(n_卡类别id, n_消费卡id, v_结算方式, n_结算金额, v_卡号, Null, Null, v_结算摘要, 结帐id_In, n_预交id);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
    --病人余额检查
    Begin
      Select Sum(Nvl(预交余额, 0) - Nvl(费用余额, 0))
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
  
    If n_预交金额 < 冲预交额_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交额_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(病人id_In) Loop
    
      n_金额 := Case
                When r_Deposit.金额 - n_预交金额 < 0 Then
                 r_Deposit.金额
                Else
                 n_预交金额
              End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 校对标志, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_Date,
               操作员姓名_In, 操作员编号_In, n_金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号_In, 校对标志, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 类型, 性质) Values (病人id_In, -n_金额, Nvl(r_Deposit.预交类别, 2), 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If n_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
  End If;

  --相关汇总表的处理

  --汇总"人员缴款余额"
  --收费结算
  n_返回值 := 0;
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') + 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
  End If;

  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And b.No = No_In And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    If Nvl(简单收费_In, 0) <> 0 Then
      Update 门诊费用记录
      Set 发药窗口 = 发药窗口_In
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 收费类别 = 'Z';
    Else
      For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
        Update 门诊费用记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
      
        Update 药品收发记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              费用id + 0 In (Select ID
                           From 门诊费用记录
                           Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      
        Update 未发药品记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                               From 门诊费用记录
                               Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      End Loop;
    End If;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄), 姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_划价收费记录_Insert;
/

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Create Or Replace Procedure Zl_疾病编码目录_Insert
(
  Id_In       In 疾病编码目录.Id%Type,
  编码_In     In 疾病编码目录.编码%Type,
  序号_In     In 疾病编码目录.序号%Type,
  附码_In     In 疾病编码目录.附码%Type,
  统计码_In   In 疾病编码目录.统计码%Type,
  名称_In     In 疾病编码目录.名称%Type,
  简码_In     In 疾病编码目录.简码%Type,
  说明_In     In 疾病编码目录.说明%Type,
  性别限制_In In 疾病编码目录.性别限制%Type,
  疗效限制_In In 疾病编码目录.疗效限制%Type,
  类别_In     In 疾病编码目录.类别%Type,
  手术类型_In In 疾病编码目录.手术类型%Type,
  分类id_In   In 疾病编码目录.分类id%Type,
  分娩_In     In 疾病编码目录.分娩%Type := Null,
  五笔码_In   In 疾病编码目录.五笔码%Type := Null,
  参数_In     In Varchar2, --科室ID串:科室ID1,科室ID2,科室ID3...
  应用_In     In Number := 0, --应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类;3-应用于当前类别
  适用范围_In In 疾病编码目录.适用范围%Type := 0,
  适用应用_In In Number := 0 --适用应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类;3-应用于当前类别
) Is
  v_Infotmp Varchar2(4000);
  n_科室id  疾病编码科室.科室id%Type;
Begin
  Insert Into 疾病编码目录
    (ID, 编码, 序号, 附码, 统计码, 名称, 简码, 说明, 性别限制, 疗效限制, 手术类型, 分娩, 类别, 分类id, 五笔码, 适用范围)
  Values
    (Id_In, 编码_In, 序号_In, 附码_In, 统计码_In, 名称_In, 简码_In, 说明_In, 性别限制_In, 疗效限制_In, 手术类型_In, 分娩_In, 类别_In, 分类id_In, 五笔码_In,
     适用范围_In);

  If 参数_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 参数_In || ',';
  End If;

  Delete 疾病编码科室 Where 疾病id = Id_In;
  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    n_科室id  := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    v_Infotmp := Replace(',' || v_Infotmp, ',' || n_科室id || ',');
    Insert Into 疾病编码科室 (疾病id, 科室id) Values (Id_In, n_科室id);
  End Loop;

  If 应用_In <> 0 Then
    If 应用_In = 1 Then
      --应用于同级项目
      Delete 疾病编码科室 Where 疾病id In (Select ID From 疾病编码目录 Where 分类id = 分类id_In) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From 疾病编码目录 A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.分类id = 分类id_In And a.Id <> Id_In;
    Elsif 应用_In = 2 Then
      --应用于当前分类
      Delete From 疾病编码科室
      Where 疾病id In (Select ID
                     From 疾病编码目录
                     Where 分类id In (Select ID
                                    From 疾病编码分类
                                    Where 类别 = 类别_In
                                    Start With ID = 分类id_In
                                    Connect By Prior ID = 上级id)) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From (Select ID
               From 疾病编码目录
               Where 分类id In (Select ID
                              From 疾病编码分类
                              Where 类别 = 类别_In
                              Start With ID = 分类id_In
                              Connect By Prior ID = 上级id)) A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.Id <> Id_In;
    Elsif 应用_In = 3 Then
      --应用于当前类别      
      Delete From 疾病编码科室 Where 疾病id In (Select ID From 疾病编码目录 Where 类别 = 类别_In) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From (Select ID From 疾病编码目录 Where 类别 = 类别_In) A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.Id <> Id_In;
    End If;
  End If;

  --适用范围应用
  If 适用应用_In = 1 Then
    --应用于同级项目
    Update 疾病编码目录 Set 适用范围 = 适用范围_In Where 类别 = 类别_In And 分类id = 分类id_In;
  Elsif 适用应用_In = 2 Then
    --应用于当前分类
    Update 疾病编码目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 类别_In And
          分类id In
          (Select ID From 疾病编码分类 Where 类别 = 类别_In Start With ID = 分类id_In Connect By Prior ID = 上级id);
  Elsif 适用应用_In = 3 Then
    --应用于当前类别
    Update 疾病编码目录 Set 适用范围 = 适用范围_In Where 类别 = 类别_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病编码目录_Insert;
/

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Create Or Replace Procedure Zl_疾病编码目录_Update
(
  Id_In       In 疾病编码目录.Id%Type,
  编码_In     In 疾病编码目录.编码%Type,
  序号_In     In 疾病编码目录.序号%Type,
  附码_In     In 疾病编码目录.附码%Type,
  统计码_In   In 疾病编码目录.统计码%Type,
  名称_In     In 疾病编码目录.名称%Type,
  简码_In     In 疾病编码目录.简码%Type,
  说明_In     In 疾病编码目录.说明%Type,
  性别限制_In In 疾病编码目录.性别限制%Type,
  疗效限制_In In 疾病编码目录.疗效限制%Type,
  类别_In     In 疾病编码目录.类别%Type,
  手术类型_In In 疾病编码目录.手术类型%Type,
  分类id_In   In 疾病编码目录.分类id%Type,
  分娩_In     In 疾病编码目录.分娩%Type,
  五笔码_In   In 疾病编码目录.五笔码%Type := Null,
  参数_In     In Varchar2, --科室ID串:科室ID1,科室ID2,科室ID3...
  应用_In     In Number := 0, --应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类;3-应用于当前类别
  适用范围_In In 疾病编码目录.适用范围%Type := 0,
  适用应用_In In Number := 0 --适用应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类;3-应用于当前类别
) Is
  v_Infotmp Varchar2(4000);
  n_科室id  疾病编码科室.科室id%Type;
Begin
  Update 疾病编码目录
  Set 编码 = 编码_In, 序号 = 序号_In, 附码 = 附码_In, 统计码 = 统计码_In, 名称 = 名称_In, 简码 = 简码_In, 说明 = 说明_In, 性别限制 = 性别限制_In,
      疗效限制 = 疗效限制_In, 手术类型 = 手术类型_In, 分娩 = 分娩_In, 分类id = 分类id_In, 五笔码 = 五笔码_In, 适用范围 = 适用范围_In
  Where ID = Id_In;

  If 参数_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 参数_In || ',';
  End If;

  Delete 疾病编码科室 Where 疾病id = Id_In;
  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    n_科室id  := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    v_Infotmp := Replace(',' || v_Infotmp, ',' || n_科室id || ',');
  
    Insert Into 疾病编码科室 (疾病id, 科室id) Values (Id_In, n_科室id);
  End Loop;

  If 应用_In <> 0 Then
    If 应用_In = 1 Then
      --应用于同级项目
      Delete 疾病编码科室 Where 疾病id In (Select ID From 疾病编码目录 Where 分类id = 分类id_In) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From 疾病编码目录 A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.分类id = 分类id_In And a.Id <> Id_In;
    Elsif 应用_In = 2 Then
       --应用于当前分类
      Delete From 疾病编码科室
      Where 疾病id In (Select ID
                     From 疾病编码目录
                     Where 分类id In (Select ID
                                    From 疾病编码分类
                                    Where 类别 = 类别_In
                                    Start With ID = 分类id_In
                                    Connect By Prior ID = 上级id)) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From (Select ID
               From 疾病编码目录
               Where 分类id In (Select ID
                              From 疾病编码分类
                              Where 类别 = 类别_In
                              Start With ID = 分类id_In
                              Connect By Prior ID = 上级id)) A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.Id <> Id_In;
    Elsif 应用_In = 3 Then
      --应用于当前类别      
      Delete From 疾病编码科室 Where 疾病id In (Select ID From 疾病编码目录 Where 类别 = 类别_In) And 疾病id <> Id_In;
    
      Insert Into 疾病编码科室
        (疾病id, 科室id)
        Select a.Id, b.科室id
        From (Select ID From 疾病编码目录 Where 类别 = 类别_In) A, 疾病编码科室 B
        Where b.疾病id = Id_In And a.Id <> Id_In;
    End If;
  End If;

  --适用范围应用
  If 适用应用_In = 1 Then
    --应用于同级项目
    Update 疾病编码目录 Set 适用范围 = 适用范围_In Where 类别 = 类别_In And 分类id = 分类id_In;
  Elsif 适用应用_In = 2 Then
    --应用于当前分类
    Update 疾病编码目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 类别_In And
          分类id In
          (Select ID From 疾病编码分类 Where 类别 = 类别_In Start With ID = 分类id_In Connect By Prior ID = 上级id);
  Elsif 适用应用_In = 3 Then
    --应用于当前类别
    Update 疾病编码目录 Set 适用范围 = 适用范围_In Where 类别 = 类别_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病编码目录_Update;
/

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Create Or Replace Procedure Zl_疾病病种对应_Update
(
  Id_In     In 疾病编码目录.ID%Type,
  类别_In   In 疾病编码目录.类别%Type,
  分类id_In In 疾病编码目录.分类id%Type,
  病种_In   In Varchar2 := Null, --病种id串,险类1|病种id1,险类2|病种id2.....
  应用_In   In Number := 0 --病种的应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类;3-应用于当前类别
) Is
  v_Infotmp Varchar2(4000);
  n_顶层id  疾病编码目录.ID%Type;
  n_险类    疾病病种对应.险类%Type;
  n_病种id  疾病病种对应.病种id%Type;
  v_Temp    Varchar2(200);

Begin
  If 病种_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 病种_In || ',';
  End If;

  Delete 疾病病种对应 Where 疾病id = Id_In;

  While v_Infotmp Is Not Null Loop
    v_Temp    := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    n_险类    := Substr(v_Temp, 1, Instr(v_Temp, '|') - 1);
    n_病种id  := Substr(v_Temp, Instr(v_Temp, '|') + 1, Length(v_Temp));
    v_Infotmp := Replace(',' || v_Infotmp, ',' || v_Temp || ',');
    Insert Into 疾病病种对应 (疾病id, 险类, 病种id) Values (Id_In, n_险类, n_病种id);
  End Loop;

  If 应用_In <> 0 Then
    If 应用_In = 1 Then
      --应用于同级项目
      Delete 疾病病种对应 Where 疾病id In (Select ID From 疾病编码目录 Where 分类id = 分类id_In) And 疾病id <> Id_In;

      Insert Into 疾病病种对应
        (疾病id, 险类, 病种id)
        Select A.ID, B.险类, B.病种id
        From 疾病编码目录 A, 疾病病种对应 B
        Where B.疾病id = Id_In And A.分类id = 分类id_In And A.ID <> Id_In;

    Elsif 应用_In = 2 Then
      --应用于当前分类
      Select ID
      Into n_顶层id
      From 疾病编码分类
      Where 类别 = 类别_In And 上级id Is Null
      Start With ID = 分类id_In
      Connect By ID = Prior 上级id;

      Delete From 疾病病种对应
      Where 疾病id In (Select ID
                       From 疾病编码目录
                       Where 分类id In (Select ID
                                        From 疾病编码分类
                                        Where 类别 = 类别_In
                                        Start With ID = n_顶层id
                                        Connect By Prior ID = 上级id)) And 疾病id <> Id_In;

      Insert Into 疾病病种对应
        (疾病id, 险类, 病种id)
        Select A.ID, B.险类, B.病种id
        From (Select ID
               From 疾病编码目录
               Where 分类id In (Select ID
                                From 疾病编码分类
                                Where 类别 = 类别_In
                                Start With ID = n_顶层id
                                Connect By Prior ID = 上级id)) A, 疾病病种对应 B
        Where B.疾病id = Id_In And A.ID <> Id_In;
    Elsif 应用_In = 3 Then
      --应用于当前类别
      Delete From 疾病病种对应
      Where 疾病id In (Select ID
                       From 疾病编码目录
                       Where  类别 = 类别_In) And 疾病id <> Id_In;

      Insert Into 疾病病种对应
        (疾病id, 险类, 病种id)
        Select A.ID, B.险类, B.病种id
        From (Select ID
               From 疾病编码目录
               Where 类别 = 类别_In) A, 疾病病种对应 B
        Where B.疾病id = Id_In And A.ID <> Id_In;
    End If;
  End If;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_疾病病种对应_Update;
/

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Create Or Replace Procedure Zl_疾病诊断目录_Insert
(
  Id_In       疾病诊断目录.Id%Type,
  诊断编码_In 疾病诊断目录.编码%Type,
  诊断名称_In 疾病诊断目录.名称%Type,
  名称拼音_In 疾病诊断别名.简码%Type,
  名称五笔_In 疾病诊断别名.简码%Type,
  英文名称_In 疾病诊断别名.名称%Type,
  其他别名_In 疾病诊断别名.名称%Type,
  别名拼音_In 疾病诊断别名.简码%Type,
  别名五笔_In 疾病诊断别名.简码%Type,
  诊断说明_In 疾病诊断目录.说明%Type,
  诊断类别_In 疾病诊断目录.类别%Type,
  v_Classes   Varchar2, --所属分类和对应的标准编码
  v_Collates  Varchar2,
  分类id_In   疾病诊断属类.分类id%Type,
  对应科室_In In Varchar2 := Null, --科室ID串:科室ID1,科室ID2,科室ID3...
  应用_In     In Number := 0, --应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类
  适用范围_In In 疾病编码目录.适用范围%Type := 0,
  适用应用_In In Number := 0 --适用应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类
) As
  v_String  Varchar2(100); --临时记录的字符串
  v_Current Varchar2(20); --包含在单项目中的一个项目
  v_Infotmp Varchar2(4000);
  n_科室id  疾病诊断科室.科室id%Type;
  n_上级id  Number;
Begin
  Insert Into 疾病诊断目录
    (ID, 编码, 名称, 类别, 说明, 适用范围)
  Values
    (Id_In, 诊断编码_In, 诊断名称_In, 诊断类别_In, 诊断说明_In, 适用范围_In);

  If 名称拼音_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称拼音_In, 1);
  End If;
  If 名称五笔_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称五笔_In, 2);
  End If;
  If 英文名称_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 英文名称_In, 2, '', 9);
  End If;
  If 其他别名_In Is Not Null And 别名拼音_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名拼音_In, 1);
  End If;
  If 其他别名_In Is Not Null And 别名五笔_In Is Not Null Then
    Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名五笔_In, 2);
  End If;

  v_String := v_Classes || ',';
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断属类 (分类id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  If v_Collates Is Null Then
    v_String := Null;
  Else
    v_String := v_Collates || ',';
  End If;
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断对照 (疾病id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  --设置疾病诊断科室
  Delete 疾病诊断科室 Where 诊断id = Id_In;

  If 对应科室_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 对应科室_In || ',';
  End If;

  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    n_科室id  := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    v_Infotmp := Replace(',' || v_Infotmp, ',' || n_科室id || ',');
    Insert Into 疾病诊断科室 (诊断id, 科室id) Values (Id_In, n_科室id);
  End Loop;

  If 应用_In = 1 Then
    --应用于同级项目
    Delete 疾病诊断科室
    Where 诊断id In (Select Distinct 诊断id From 疾病诊断属类 Where 分类id = 分类id_In) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From 疾病诊断属类 A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.分类id = 分类id_In And a.诊断id <> Id_In;
  Elsif 应用_In = 2 Then
    --应用于当前分类
    Select ID
    Into n_上级id
    From 疾病诊断分类
    Where 类别 = 诊断类别_In And 上级id Is Null
    Start With ID = 分类id_In
    Connect By ID = Prior 上级id;
  
    Delete 疾病诊断科室
    Where 诊断id In (Select 诊断id
                   From 疾病诊断属类
                   Where 分类id In (Select ID
                                  From 疾病诊断分类
                                  Where 类别 = 诊断类别_In
                                  Start With ID = n_上级id
                                  Connect By Prior ID = 上级id)) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From (Select 诊断id
             From 疾病诊断属类
             Where 分类id In (Select ID
                            From 疾病诊断分类
                            Where 类别 = 诊断类别_In
                            Start With ID = n_上级id
                            Connect By Prior ID = 上级id)) A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.诊断id <> Id_In;
  End If;

  --适用范围应用
  If 适用应用_In = 1 Then
    --应用于同级项目
    Update 疾病诊断目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 诊断类别_In And ID In (Select 诊断id From 疾病诊断属类 Where 分类id = 分类id_In);
  Elsif 适用应用_In = 2 Then
    --应用于当前分类
    Update 疾病诊断目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 诊断类别_In And ID In (Select 诊断id
                                  From 疾病诊断属类
                                  Where 分类id In (Select ID
                                                 From 疾病诊断分类
                                                 Where 类别 = 诊断类别_In
                                                 Start With ID = 分类id_In
                                                 Connect By Prior ID = 上级id));
  
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病诊断目录_Insert;
/

--94463:李业庆,2016-03-24,疾病编码目录,疾病诊断目录增加适用范围
Create Or Replace Procedure Zl_疾病诊断目录_Update
(
  Id_In       疾病诊断目录.Id%Type,
  诊断编码_In 疾病诊断目录.编码%Type,
  诊断名称_In 疾病诊断目录.名称%Type,
  名称拼音_In 疾病诊断别名.简码%Type,
  名称五笔_In 疾病诊断别名.简码%Type,
  英文名称_In 疾病诊断别名.名称%Type,
  其他别名_In 疾病诊断别名.名称%Type,
  别名拼音_In 疾病诊断别名.简码%Type,
  别名五笔_In 疾病诊断别名.简码%Type,
  诊断说明_In 疾病诊断目录.说明%Type,
  诊断类别_In 疾病诊断目录.类别%Type,
  v_Classes   Varchar2,
  v_Collates  Varchar2, --所属分类和对应的标准编码
  分类id_In   疾病诊断属类.分类id%Type,
  对应科室_In In Varchar2 := Null, --科室ID串:科室ID1,科室ID2,科室ID3...
  应用_In     In Number := 0, --应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类
  适用范围_In In 疾病编码目录.适用范围%Type := 0,
  适用应用_In In Number := 0 --适用应用范围:0-应用于当前项目;1-应用于同级项目;2-应用于当前分类
) As
  v_String  Varchar2(100); --临时记录的字符串
  v_Current Varchar2(20); --包含在单项目中的一个项目
  v_Infotmp Varchar2(4000);
  n_科室id  疾病诊断科室.科室id%Type;
  n_上级id  Number;
  Err_Notfind Exception;
Begin
  Update 疾病诊断目录
  Set 编码 = 诊断编码_In, 名称 = 诊断名称_In, 说明 = 诊断说明_In, 适用范围 = 适用范围_In
  Where ID = Id_In;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;

  If 名称拼音_In Is Null Then
    Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 1 And 码类 = 1;
  Else
    Update 疾病诊断别名 Set 名称 = 诊断名称_In, 简码 = 名称拼音_In Where 诊断id = Id_In And 性质 = 1 And 码类 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称拼音_In, 1);
    End If;
  End If;
  If 名称五笔_In Is Null Then
    Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 1 And 码类 = 2;
  Else
    Update 疾病诊断别名 Set 名称 = 诊断名称_In, 简码 = 名称五笔_In Where 诊断id = Id_In And 性质 = 1 And 码类 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 诊断名称_In, 1, 名称五笔_In, 2);
    End If;
  End If;

  If 英文名称_In Is Null Then
    Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 2;
  Else
    Update 疾病诊断别名 Set 名称 = 英文名称_In Where 诊断id = Id_In And 性质 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 英文名称_In, 2, '', 9);
    End If;
  End If;

  If 其他别名_In Is Null Then
    Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 9;
  Else
    If 别名拼音_In Is Null Then
      Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 9 And 码类 = 1;
    Else
      Update 疾病诊断别名 Set 名称 = 其他别名_In, 简码 = 别名拼音_In Where 诊断id = Id_In And 性质 = 9 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名拼音_In, 1);
      End If;
    End If;
    If 别名五笔_In Is Null Then
      Delete 疾病诊断别名 Where 诊断id = Id_In And 性质 = 9 And 码类 = 2;
    Else
      Update 疾病诊断别名 Set 名称 = 其他别名_In, 简码 = 别名五笔_In Where 诊断id = Id_In And 性质 = 9 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 疾病诊断别名 (诊断id, 名称, 性质, 简码, 码类) Values (Id_In, 其他别名_In, 9, 别名五笔_In, 2);
      End If;
    End If;
  End If;

  Delete From 疾病诊断属类 Where 诊断id = Id_In;
  v_String := v_Classes || ',';
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断属类 (分类id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  Delete From 疾病诊断对照 Where 诊断id = Id_In;
  If v_Collates Is Null Then
    v_String := Null;
  Else
    v_String := v_Collates || ',';
  End If;
  While v_String Is Not Null Loop
    v_Current := Substr(v_String, 1, Instr(v_String, ',') - 1);
    Insert Into 疾病诊断对照 (疾病id, 诊断id) Values (To_Number(v_Current), Id_In);
    v_String := Replace(',' || v_String, ',' || v_Current || ',');
  End Loop;

  --设置疾病诊断科室
  Delete 疾病诊断科室 Where 诊断id = Id_In;

  If 对应科室_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := 对应科室_In || ',';
  End If;

  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    n_科室id  := Substr(v_Infotmp, 1, Instr(v_Infotmp, ',') - 1);
    v_Infotmp := Replace(',' || v_Infotmp, ',' || n_科室id || ',');
    Insert Into 疾病诊断科室 (诊断id, 科室id) Values (Id_In, n_科室id);
  End Loop;

  If 应用_In = 1 Then
    --应用于同级项目
    Delete 疾病诊断科室
    Where 诊断id In (Select Distinct 诊断id From 疾病诊断属类 Where 分类id = 分类id_In) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From 疾病诊断属类 A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.分类id = 分类id_In And a.诊断id <> Id_In;
  Elsif 应用_In = 2 Then
    --应用于当前分类
    Select ID
    Into n_上级id
    From 疾病诊断分类
    Where 类别 = 诊断类别_In And 上级id Is Null
    Start With ID = 分类id_In
    Connect By ID = Prior 上级id;
  
    Delete 疾病诊断科室
    Where 诊断id In (Select 诊断id
                   From 疾病诊断属类
                   Where 分类id In (Select ID
                                  From 疾病诊断分类
                                  Where 类别 = 诊断类别_In
                                  Start With ID = n_上级id
                                  Connect By Prior ID = 上级id)) And 诊断id <> Id_In;
  
    Insert Into 疾病诊断科室
      (诊断id, 科室id)
      Select a.诊断id, b.科室id
      From (Select 诊断id
             From 疾病诊断属类
             Where 分类id In (Select ID
                            From 疾病诊断分类
                            Where 类别 = 诊断类别_In
                            Start With ID = n_上级id
                            Connect By Prior ID = 上级id)) A, 疾病诊断科室 B
      Where b.诊断id = Id_In And a.诊断id <> Id_In;
  End If;

  --适用范围应用
  If 适用应用_In = 1 Then
    --应用于同级项目
    Update 疾病诊断目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 诊断类别_In And ID In (Select 诊断id From 疾病诊断属类 Where 分类id = 分类id_In);
  Elsif 适用应用_In = 2 Then
    --应用于当前分类
    Update 疾病诊断目录
    Set 适用范围 = 适用范围_In
    Where 类别 = 诊断类别_In And ID In (Select 诊断id
                                  From 疾病诊断属类
                                  Where 分类id In (Select ID
                                                 From 疾病诊断分类
                                                 Where 类别 = 诊断类别_In
                                                 Start With ID = 分类id_In
                                                 Connect By Prior ID = 上级id));
  
  End If;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该项目不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_疾病诊断目录_Update;
/

Delete From zlFilesUpgrade Where Upper(文件名) = UPPER('zlQueueShow.exe');
Insert Into zlFilesUpgrade
  (文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, 安装路径, 文件说明, 强制覆盖, 自动注册, 加入日期, 序号)
  Select 1, 'zlQueueShow.exe', '', Null, '1', 'zlQueueManage', '[Appsoft]\ZLQUEUESHOW', '新版排队叫号显示程序', '0', '0', Sysdate, 序号
  From Dual A, (Select Max(To_Number(序号)) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From zlFilesUpgrade Where Upper(文件名) =  UPPER('zlQueueShow.exe'));

Delete From zlFilesUpgrade Where Upper(文件名) = UPPER('zlSoftShowArchive.exe');
Insert Into zlFilesUpgrade
  (文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, 安装路径, 文件说明, 强制覆盖, 自动注册, 加入日期, 序号)
  Select 0, 'zlSoftShowArchive.exe', '', Null, '1', '', '[Appsoft]\APPLY', '新版RIS系统查看新版电子病历独立的EXE', '0', '0', Sysdate, 序号
  From Dual A, (Select Max(To_Number(序号)) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From zlFilesUpgrade Where Upper(文件名) =  UPPER('zlSoftShowArchive.exe'));

 
Delete From zlFilesUpgrade Where Upper(文件名) = UPPER('zlRisDumpTool.exe');
Insert Into zlFilesUpgrade
  (文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, 安装路径, 文件说明, 强制覆盖, 自动注册, 加入日期, 序号)
  Select 0, 'zlRisDumpTool.exe', '', Null, '1', '', '[Appsoft]\APPLY', 'HIS基础数据导入新版RIS的工具', '0', '0', Sysdate, 序号
  From Dual A, (Select Max(To_Number(序号)) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From zlFilesUpgrade Where Upper(文件名) =  UPPER('zlRisDumpTool.exe'));
---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.34.80' Where 编号=&n_System;
--部件版本号
Commit;