--[连续升级]1
--[管理工具版本号]10.34.30
--本脚本支持从ZLHIS+ v10.34.20 升级到 v10.34.30
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--86628:胡俊勇,2015-07-17,外键删除
alter table 抗菌药物抽样手术 drop constraint 抗菌药物抽样手术_FK_手术ID;

--84458:涂建华,2015-07-02,新版Pacs报告编辑器处理
--84458:黄捷,2015-07-21,影像报告操作记录增加转出处理

Create Table 影像报告元素分类(
       ID               Raw(16),
       上级ID            Raw(16),  
       编码             Varchar2(6),
       名称             Varchar2(80),
       说明             Varchar2(200),
       最后编辑时间     Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告元素分类 Add Constraint 影像报告元素分类_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告元素分类 Add Constraint 影像报告元素分类_FK_上级ID Foreign Key (上级ID) References 影像报告元素分类(ID) On Delete Cascade;
Alter Table 影像报告元素分类 Add Constraint 影像报告元素分类_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告元素分类 Add Constraint 影像报告元素分类_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 

Create Table 影像报告值域清单(
       ID                 Raw(16),
       分类ID             Raw(16),
       编码               Varchar2(20),
       名称               Varchar2(80),
       说明               Varchar2(200),
       数据类型           Varchar2(2),    
       值域种类           Number(1), 
       值域描述           Xmltype,
       最后编辑时间       Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告值域清单 Add Constraint 影像报告值域清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告值域清单 Add Constraint 影像报告值域清单_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告值域清单 Add Constraint 影像报告值域清单_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 
Alter Table 影像报告值域清单 Add Constraint 影像报告值域清单_FK_分类ID Foreign Key (分类ID) References 影像报告元素分类(ID) On Delete Cascade;
Create Index 影像报告值域清单_IX_分类ID On 影像报告值域清单(分类ID) Tablespace zlPacsBaseIndex;

Create Table 影像报告元素清单(
       ID                  Raw(16),
       分类ID              Raw(16),
       编码                Varchar2(30),
       名称                Varchar2(80),
       前缀                Varchar2(80),
       后缀                Varchar2(80),
       说明                Varchar2(200),
       数据类型            Varchar2(2),
       数值形态            Varchar2(3),
       最小长度            Number(8),
       最大长度            Number(8),
       最小小数位          Number(8),
       最大小数位          Number(8),
       计量单位            Varchar2(20),
       扩展描述            Xmltype,
       值域ID              Raw(16),
       值域种类            Number(1), 
       最后编辑时间        Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告元素清单 Add Constraint 影像报告元素清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告元素清单 Add Constraint 影像报告元素清单_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告元素清单 Add Constraint 影像报告元素清单_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告元素清单 Add Constraint 影像报告元素清单_FK_分类ID Foreign Key (分类ID) References 影像报告元素分类(ID) On Delete Cascade;
Alter Table 影像报告元素清单 Add Constraint 影像报告元素清单_FK_值域ID Foreign Key (值域ID) References 影像报告值域清单(ID) On Delete Cascade;
Create Index 影像报告元素清单_IX_分类ID On 影像报告元素清单(分类ID) Tablespace zlPacsBaseIndex;
Create Index 影像报告元素清单_IX_值域ID On 影像报告元素清单(值域ID) Tablespace zlPacsBaseIndex;

Create Table 影像报告计量单位(
       编码             Varchar2(20),
       名称             Varchar2(80),
       说明             Varchar2(200),
       前缀             Varchar2(10)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告计量单位 Add Constraint 影像报告计量单位_PK Primary Key (编码) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告计量单位 Add Constraint 影像报告计量单位_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex;

Create Table 影像报告组句清单(
       ID               Raw(16),
       编码             Varchar2(30),
       名称             Varchar2(80),
       说明             Varchar2(200),
       分组             Varchar2(60),
       多组             Number(1),
       组成             Xmltype,
       编辑人           Varchar2(100),         
       最后编辑时间     Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告组句清单 Add Constraint 影像报告组句清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告组句清单 Add Constraint 影像报告组句清单_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告组句清单 Add Constraint 影像报告组句清单_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex;

Create Table 影像报告片段清单(
       ID               Raw(16),
       上级ID           Raw(16),    
       编码             Varchar2(10),
       名称             Varchar2(80),
       说明             Varchar2(200),
       节点类型         Number(1),
       组成             Xmltype,
       学科             Varchar2(200),
       标签             Varchar2(200),
       是否私有         Number(1),          
       作者             Varchar2(100),         
       最后编辑时间     Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告片段清单 Add Constraint  影像报告片段清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告片段清单 Add Constraint 影像报告片段清单_UQ_编码 Unique (上级ID,编码) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告片段清单 Add Constraint 影像报告片段清单_UQ_名称 Unique (上级ID,名称) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告片段清单 Add Constraint 影像报告片段清单_FK_上级ID Foreign Key (上级ID) References 影像报告片段清单(ID) On Delete Cascade;
Create Index 影像报告片段清单_IX_上级ID On 影像报告片段清单(上级ID) Tablespace zlPacsBaseIndex;

Create Table 影像报告预备提纲(
       ID                    Raw(16),
       编码                  Varchar2(3),
       名称                  Varchar2(80),
       说明                  Varchar2(200),
       最后编辑时间          Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告预备提纲 Add Constraint 影像报告预备提纲_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告预备提纲 Add Constraint 影像报告预备提纲_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告预备提纲 Add Constraint 影像报告预备提纲_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 

Create Table 影像报告原型清单(
       ID                    Raw(16),
       种类                  Varchar2(2),   
       编码                  Varchar2(30),
       名称                  Varchar2(80),
       说明                  Varchar2(200),
       分组                   Varchar2(60),
       内容                  Xmltype,
       可否重置页面          Number(1),
       可否重置格式          Number(1),
       是否禁用               Number(1),
       专用插件              Xmltype,
       控制选项              Xmltype,
       创建人                Varchar2(100),
       创建时间              Date,
       修改人                Varchar2(100),  
       修改时间              Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告原型清单 Add Constraint 影像报告原型清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告原型清单 Add Constraint 影像报告原型清单_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告原型清单 Add Constraint 影像报告原型清单_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 

Create Table 影像报告原型应用(
       诊疗项目ID         Number(18),
       应用场合           Number(3),
       报告原型ID         Raw(16)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告原型应用 Add Constraint 影像报告原型应用_PK Primary Key (诊疗项目ID,报告原型ID,应用场合) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告原型应用 Add Constraint 影像报告原型应用_FK_诊疗项目ID Foreign Key (诊疗项目ID) References 诊疗项目目录(ID) On Delete Cascade;
Alter Table 影像报告原型应用 Add Constraint 影像报告原型应用_FK_报告原型ID Foreign Key (报告原型ID) References 影像报告原型清单(ID) On Delete Cascade;

Create Table 影像报告原型片段(
       原型ID      Raw(16),
       片段ID      Raw(16)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告原型片段 Add Constraint 影像报告原型片段_PK Primary Key (原型ID,片段ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告原型片段 Add Constraint 影像报告原型片段_FK_原型ID Foreign Key (原型ID) References 影像报告原型清单(ID) On Delete Cascade;
Alter Table 影像报告原型片段 Add Constraint 影像报告原型片段_FK_片段ID Foreign Key (片段ID) References 影像报告片段清单(ID) On Delete Cascade;

Create Table 影像报告事件(
       ID              Raw(16),
       种类            Number(1),
       原型ID          Raw(16), 
       编号            Number(8),
       名称            Varchar2(80),
       说明            Varchar2(200),
       元素IID         Varchar2(36),
       扩展标记        Varchar2(200)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告事件 Add Constraint 影像报告事件_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告事件 Add Constraint 影像报告事件_UQ_编号 Unique (原型ID,种类,编号) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告事件 Add Constraint 影像报告事件_UQ_名称 Unique (原型ID,种类,名称) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告事件 Add Constraint 影像报告事件_FK_原型ID Foreign Key (原型ID) References 影像报告原型清单(ID) On Delete Cascade;

Create Table 影像报告动作(
       ID               Raw(16),
       原型ID           Raw(16), 
       事件ID           Raw(16),       
       动作类型         Number(1),
       名称             Varchar2(80),
       说明             Varchar2(200),
       可否手工执行     Number(1),
       序号             Number(8),
       内容             Xmltype
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告动作 Add Constraint 影像报告动作_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告动作 Add Constraint 影像报告动作_FK_原型ID Foreign Key (原型ID) References 影像报告原型清单(ID) On Delete Cascade;
Alter Table 影像报告动作 Add Constraint 影像报告动作_FK_事件ID Foreign Key (事件ID) References 影像报告事件(ID) On Delete Cascade;
Create Index 影像报告动作_IX_原型ID On 影像报告动作(原型ID) Tablespace zlPacsBaseIndex;
Create Index 影像报告动作_IX_事件ID On 影像报告动作(事件ID) Tablespace zlPacsBaseIndex;

Create Table 影像报告插件(
       ID               Raw(16),
       编码             Varchar2(30), 
       名称             Varchar2(80),       
       说明             Varchar2(200),       
       显示样式         Number(1),       
       种类             Number(1),
       类名             Varchar2(100),   
       库名             Varchar2(100),   
       是否禁用         Number(1)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告插件 Add Constraint 影像报告插件_PK Primary Key (ID)   Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告插件 Add Constraint 影像报告插件_UQ_编码 Unique (编码) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告插件 Add Constraint 影像报告插件_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 

Create Table 影像报告种类(
       编码             Varchar2(2), 
       名称             Varchar2(80),       
       说明             Varchar2(200)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告种类 Add Constraint 影像报告种类_PK Primary Key (编码) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告种类 Add Constraint 影像报告种类_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex;  

Create Table 影像报告范文清单(
       ID               Raw(16),
       原型ID           Raw(16),   
       编号             Number(8),
       名称             Varchar2(80),
       说明             Varchar2(200),
       内容             Xmltype,
       学科             Varchar2(200),
       标签             Varchar2(200),
       是否私有         Number(1),
       作者             Varchar2(100),  
       最后编辑时间     Date
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告范文清单 Add Constraint 影像报告范文清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告范文清单 Add Constraint 影像报告范文清单_UQ_原型ID Unique (原型ID,名称) Using Index Tablespace zlPacsBaseIndex;  
Alter Table 影像报告范文清单 Add Constraint 影像报告范文清单_FK_原型ID Foreign Key (原型ID) References 影像报告原型清单(ID) On Delete Cascade;


--11g数据库下面使用，由于11g和10g在xml存储选项有差别，因此需要将11g的表结构创建脚本放在10g脚本之前
Create Table 影像报告记录(
         ID             Raw(16),
         医嘱ID          Number(18),
         原型ID         Raw(16),   
         文档标题       Varchar2(60),
         报告内容       Xmltype,
         报告状态       Number(1),
         待处理人        Varchar2(100),
         创建时间       Date,
         创建人         Varchar2(100),
         最后编辑时间   Date,
         最后编辑人     Varchar2(100),
         锁定人         Varchar2(100),       
         诊断意见       Varchar2(1024),
         检查部位       Varchar2(500),
         编辑日志       Xmltype,
         报告质量       NUMBER(1),
         结果阳性        NUMBER(1),
         报告打印       NUMBER(1) default 0,
         报告发放       NUMBER(1) default 0,
         报告发放人     VARCHAR2(100),
         最后审核人     VARCHAR2(100),
         最后审核时间   DATE,
         记录人         VARCHAR2(100),
         待转出         Number(3)
    )TABLESPACE zlPacsBizTab
     XMLTYPE COLUMN 报告内容 STORE AS SECUREFILE BINARY XML(
      TABLESPACE zlPacsBizXml 
      DISABLE STORAGE IN ROW  
      NOCACHE LOGGING 
      COMPRESS HIGH)
     XMLTYPE COLUMN 编辑日志 STORE AS SECUREFILE BINARY XML(
      TABLESPACE zlPacsBizXml 
      DISABLE STORAGE IN ROW  
      NOCACHE LOGGING 
      COMPRESS HIGH);

--10G数据库下面使用
Create Table 影像报告记录(
         ID             Raw(16),
         医嘱ID          Number(18),
         原型ID         Raw(16),   
         文档标题       Varchar2(60),
         报告内容       Xmltype,
         报告状态       Number(1),
         待处理人        Varchar2(100),
         创建时间       Date,
         创建人         Varchar2(100),
         最后编辑时间   Date,
         最后编辑人     Varchar2(100),
         锁定人         Varchar2(100),       
         诊断意见       Varchar2(1024),
         检查部位       Varchar2(500),
         编辑日志       Xmltype,         
         报告质量       NUMBER(1),
         结果阳性        NUMBER(1),
         报告打印       NUMBER(1) default 0,
         报告发放       NUMBER(1) default 0,
         报告发放人     VARCHAR2(100),
         最后审核人     VARCHAR2(100),
         最后审核时间   DATE,
         记录人         VARCHAR2(100),
         待转出         Number(3)
    )TABLESPACE zlPacsBizTab
     XMLTYPE COLUMN 报告内容 STORE AS Clob(
      TABLESPACE zlPacsBizXml 
      DISABLE STORAGE IN ROW  
      NOCACHE LOGGING)
     XMLTYPE COLUMN 编辑日志 STORE AS Clob(
      TABLESPACE zlPacsBizXml 
      DISABLE STORAGE IN ROW  
      NOCACHE LOGGING);

Alter Table 影像报告记录 Add Constraint 影像报告记录_PK Primary Key (ID) Using Index Tablespace zlPacsBizIndex;
Alter Table 影像报告记录 Add Constraint 影像报告记录_FK_原型ID Foreign Key (原型ID) References 影像报告原型清单(ID) On Delete Cascade;
Alter Table 影像报告记录 Add Constraint 影像报告记录_FK_医嘱ID Foreign Key (医嘱ID) References 病人医嘱记录(ID) ;
Create Index 影像报告记录_IX_原型ID On 影像报告记录(原型ID) Tablespace zlPacsBizIndex;
Create Index 影像报告记录_IX_待转出 On 影像报告记录(待转出) Tablespace zlPacsBizIndex;
Create Index 影像报告记录_IX_医嘱ID On 影像报告记录(医嘱ID) Tablespace zlPacsBizIndex;

Create Table 影像参数说明(
       ID               Raw(16),
       PID              Raw(16),
       系统              Number(5),               
       模块             Varchar2(100),   
       分组             Varchar2(60),
       参数序号          Number(18),     
       参数名           Varchar2(100),
       默认值           Varchar2(4000),
       参数级别         Number(1),
       取值范围         Varchar2(4000),
       启用条件          Varchar2(255),
       说明             Varchar2(255)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像参数说明 Add Constraint 影像参数说明_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像参数说明 Add Constraint 影像参数说明_UQ_参数名 Unique (参数名,模块) Using Index Tablespace zlPacsBaseIndex;  

Alter Table 影像参数说明 Add Constraint 影像参数说明_FK_PID Foreign Key (PID) References 影像参数说明(ID) On Delete Cascade;
Create Index 影像参数说明_IX_PID On 影像参数说明(PID) Tablespace zlPacsBaseIndex;

Create Table 影像参数取值(
       ID              Raw(16),
       参数ID          Raw(16),   
       参数标识        Varchar2(100),
       参数值          Varchar2(4000)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像参数取值 Add Constraint 影像参数取值_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像参数取值 Add Constraint 影像参数取值_UQ_参数名 Unique (参数ID,参数标识) Using Index Tablespace zlPacsBaseIndex; 
Alter Table 影像参数取值 Add Constraint 影像参数取值_FK_参数ID Foreign Key (参数ID) References 影像参数说明(ID) On Delete Cascade;


Create Table 影像字典清单(
       ID            Raw(16),
       分组          Varchar2(60),
       编号          Varchar2(20),
       名称           Varchar2(80),
       说明          Varchar2(500),
       是否系统      Number(1)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像字典清单 Add Constraint 影像字典清单_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像字典清单 Add Constraint 影像字典清单_UQ_编号 Unique (编号) Using Index Tablespace zlPacsBaseIndex; 
Alter Table 影像字典清单 Add Constraint 影像字典清单_UQ_名称 Unique (名称) Using Index Tablespace zlPacsBaseIndex; 


Create Table 影像字典内容(
       字典ID        Raw(16),
       编号          Varchar2(20),
       名称           Varchar2(80),
       简码          Varchar2(10),
       说明          Varchar2(500)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像字典内容 Add Constraint 影像字典内容_PK Primary Key (字典ID,编号) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像字典内容 Add Constraint 影像字典内容_FK_字典ID Foreign Key (字典ID) References 影像字典清单(ID) On Delete Cascade;

Create Table 影像报告操作记录(
       	   ID			   Raw(16),
	   报告ID		   Raw(16),
	   医嘱ID		   Number(18),
	   操作类型                Number(1),
	   操作人		   Varchar2(100),
	   操作时间	           Date,
	   作废人		   Varchar2(100),
	   作废时间	           Date,
	   作废说明	           Varchar2(500),
	   待转出		   Number(3)
)TABLESPACE zlPacsBaseTab;

Alter Table 影像报告操作记录 Add Constraint 影像报告操作记录_PK Primary Key (ID) Using Index Tablespace zlPacsBaseIndex;
Alter Table 影像报告操作记录 Add Constraint 影像报告操作记录_FK_报告ID Foreign Key (报告ID) References 影像报告记录(ID) On Delete Cascade;
Alter Table 影像报告操作记录 Add Constraint 影像报告操作记录_FK_医嘱ID Foreign Key (医嘱ID) References 病人医嘱记录(ID) ;
Create Index 影像报告操作记录_IX_报告ID On 影像报告操作记录(报告ID) Tablespace zlPacsBaseIndex;
Create Index 影像报告操作记录_IX_待转出 On 影像报告操作记录(待转出) Tablespace zlPacsBizIndex;
Create Index 影像报告操作记录_IX_医嘱ID On 影像报告操作记录(医嘱ID) Tablespace zlPacsBizIndex;



Alter Table 影像报告驳回 Add 检查报告ID Raw(16);
Alter Table 影像报告驳回 Add 是否撤销 Number(1);
Alter Table 影像报告驳回 Add Constraint 影像报告驳回_FK_检查报告ID Foreign Key(检查报告ID) References 影像报告记录(ID) On Delete Cascade;
Create Index 影像报告驳回_IX_检查报告ID On 影像报告驳回(检查报告ID) Tablespace zlPacsBaseIndex;



--84345:许华峰,2015-06-30,是否发送WorkList
Alter Table 影像检查记录 Add 是否安排 Number(1);

--85180:胡俊勇,2015-05-31,历史消息的长期积累带来的性能问题
Alter Table 业务消息类型 Add 保留天数 number(6);

--84958:许华峰,2015-05-22,PACS依赖性接口封装
Alter Table 病人医嘱报告 Add 检查报告ID Raw(16);
Alter Table 病人医嘱报告 Drop Constraint 病人医嘱报告_PK Cascade Drop Index;
Alter Table 病人医嘱报告 Add Constraint 病人医嘱报告_UQ_医嘱ID Unique (医嘱ID,病历ID,检查报告ID) Using Index Tablespace ZL9INDEXHIS; 
Alter Table 病人医嘱报告 Modify 医嘱ID Constraint 病人医嘱报告_NN_医嘱ID Not Null;

Alter Table 报告查阅记录 Add 检查报告ID Raw(16);
Alter Table 报告查阅记录 Drop Constraint 报告查阅记录_PK Cascade Drop Index;
Alter Table 报告查阅记录 Add Constraint 报告查阅记录_UQ_医嘱ID Unique (医嘱ID,病历ID,检查报告ID,查阅人,查阅时间) Using Index Tablespace ZL9INDEXHIS; 
Alter Table 报告查阅记录 Modify 医嘱ID Constraint 报告查阅记录_NN_医嘱ID Not Null;

--84897:马政,2015-05-15,供应商表中帐号字段长度调整
alter table 供应商 modify  帐号 varchar2(50);

--84393:胡俊勇,2015-05-12,消息提醒性能问题
alter table 业务消息状态 initrans 20;
alter table 业务消息提醒人员 initrans 20;
alter table 业务消息提醒部门 initrans 20;
alter table 业务消息清单 initrans 20;


--84110:余智勇,2015-04-28,接收门诊留观病人与医嘱
Alter Table 排队记录 Add 主页id Number(18);

Alter Table 排队记录 Drop Constraint 排队记录_Uq_挂号单 Cascade Drop Index;
Alter Table 排队记录 Add Constraint 排队记录_Uq_病人id Unique(病人id, 科室id, 挂号单, 主页id) Using Index Tablespace Zl9indexcis;

alter table 门诊穿刺台 add 待穿病人ID number(18);
alter table 门诊穿刺台 rename column 挂号单1 to 挂号单1_bak;
alter table 门诊穿刺台 rename column 挂号单2 to 挂号单2_bak;

alter table 门诊穿刺台 add constraint 门诊穿刺台_FK_待穿病人id foreign key (待穿病人id) references 病人信息(病人id);

--85224:余智勇,2015-05-28,门诊输液操作日志包含门诊留观病人
alter table 门诊输液操作日志 add 病人ID number(18);
alter table 门诊输液操作日志 add 主页ID number(18);

--00000:刘硕,2015-05-15,脚本检查未登记问题
Alter Table 病人信息 Modify 联系人身份证号 Varchar2(18);
Alter Table 病案主页 Add 联系人身份证号 Varchar2(18);
Alter Table 病案主页 Modify 联系人身份证号 Varchar2(18);
Alter Table 器械导管使用情况 Modify 感染累计时间 varchar2(20);

-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--81901,2015-07-22,参数号修正
Update Zlparameters Set 参数号 = 51 Where 系统 = &n_System And 模块 = 1290 And 参数名 = '影像执行间过滤';

--84475:张德婷,2015-07-13,一卡通收费发药分离
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 54,'一卡通收费与发药分离', Null, '0', '一卡通发药，刷卡同时进行发药和收费操作:0-同时进行;1-分开进行'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1341 And 参数名 = '一卡通收费与发药分离');

--86229:马政,2015-07-07,药品结存修改
Update zlparameters set 参数说明 = '-1表示手动结存；0、空、>0表示自动结存及每月结存的日期，默认为每月最后一天；如果设置为0表示每月最后一天；如果设置的日期大于当月实际天数，则以当月最后一天结存'
Where 系统 = &n_System And 参数号 = 221 And 模块 Is Null;

--85790:李南春,2015-07-06,费用清单打印方式
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1806, 0, 1, 0, 0, 7,'费用清单打印方式', Null, '1', '控制是否支持打印历史费用明细:0-不打印;1-打印'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1806 And 参数名 = '费用清单打印方式');
--86422:李南春,2015-07-10,参数号调整
Update zlParameters Set  参数号=7 Where Nvl(系统, 0) = &n_System And Nvl(模块, 0) = 1806 And 参数名 = '费用清单打印方式';

--83330:许华峰,2015-07-06,XW查看关键图像
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1288, 0, 0, 0, 0, 19,'XW关键图像地址', 0, 'http://127.0.0.1:8080/KeyImage.aspx?colid0=22&'||'colvalue0=[@STU_NO]', 'XW PACS WEB服务器的地址。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1288 And 参数名 = 'XW关键图像地址');

--84458:涂建华,2015-07-02,新版Pacs报告编辑器处理
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2280,'影像报告元素值域','管理影像报告的元素值域',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2281,'影像报告组句管理','管理影像报告的组句设置',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2282,'影像报告片段管理','管理影像报告的片段信息',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2283,'影像报告原型管理','管理影像报告的原型设计',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2284,'影像报告范文管理','管理影像报告的范文内容',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2285,'影像报告编辑管理','管理影像报告的编辑书写权限',&n_System,'zl9PacsWork'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 2286,'影像报告配置管理','管理影像常用的数据字典及参数',100,'zl9PacsWork'); 

Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,9,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All
Select '影像报告操作记录',6,1,-NULL From Dual Union All
Select '影像报告记录',7,1,-NULL From Dual Union All
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0) A;

Delete zlMenus Where 标题='工作流程管理' And 组别='缺省' And 系统=&n_System; 
Delete zlMenus Where 标题='影像检查项目' And 组别='缺省' And 系统=&n_System; 
Delete zlMenus Where 标题='影像设备目录' And 组别='缺省' And 系统=&n_System; 
Delete zlMenus Where 标题='检查部位设置' And 组别='缺省' And 系统=&n_System; 
Delete zlMenus Where 标题='病理标本设置' And 组别='缺省' And 系统=&n_System; 
Delete zlMenus Where 标题='影像基础设置' And 组别='缺省' And 系统=&n_System; 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明)
	Select 组别,Zlmenus_Id.Nextval,ID,'影像基础设置' ,'B' ,&n_System,-NULL ,'影像基础设置' ,99 ,'对影像系统相关的基础数据进行配置' 
         From zlMenus Where 标题 = '医学影像系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null;                 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,系统,模块,短标题,图标,说明) 
       Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
                 Select 组别,ID From zlMenus Where 标题 = '影像基础设置' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
                (Select 标题,快键,系统,模块,短标题,图标,说明 From zlMenus Where 1 = 0 Union All
						Select '工作流程设置' ,'F'  ,&n_System, 1292, '工作流程' ,99, '设置各个科室的工作流程。'  From Dual Union All
						Select '设备目录设置' ,'D' ,&n_System, 1057,  '影像设备' ,99, '设置医院网络连接的各类影像存储、打印等设备。' From Dual Union All
						Select '检查部位设置' ,'P'  ,&n_System, 1049, '部位设置' ,99, '设置调整各种类型检查的部位划分和检查技术组织方式。' From Dual Union All
						Select '诊疗项目设置' ,'B'  ,&n_System, 1054, '诊疗项目' ,99, '用于病人诊断治疗护理等各类操作措施的管理和诊疗应用参考的编写。' From Dual Union All
						Select '检查项目关联' ,'R'  ,&n_System, 1056, '影像项目' ,99, '设置各类影像检查所对应的项目及相关检查属性。' From Dual Union All
						Select '老版词句设置' ,'W'  ,&n_System, 1073, '老版词句' ,99, '集中统一增删调整病历词句示范的分类和词句条目内容适用条件。' From Dual Union All	
						Select '老版单据设置' ,'H'  ,&n_System, 1076, '老版单据' ,99, '医院各科室协作进行诊疗活动的信息传递的单据的管理和设置。' From Dual Union All		
						Select '病理标本设置' ,'K'  ,&n_System, 1079, '病理标本', 99, '配置在进行病理检查申请时所需的病理检查标本。' From Dual Union All						
                        Select '报告元素管理' ,'E' ,&n_System,  2280, '报告元素' ,99, '用于对影像报告的元素及值域进行管理。' From Dual Union All
                        Select '报告组句管理' ,'C' ,&n_System, 2281,  '报告组句' ,99, '用于对影像报告的组句进行管理。'  From Dual Union All
                        Select '报告片段管理' ,'S' ,&n_System, 2282,  '报告片段' ,99, '用于对影像报告的片段进行管理。'  From Dual Union All
                        Select '报告原型管理' ,'A' ,&n_System, 2283,  '报告原型' ,99, '用于对影像报告的原型进行管理。'  From Dual Union All
						Select '报告范文管理' ,'T' ,&n_System, 2284,  '报告范文' ,99, '用于对影像报告的范文进行管理。' From Dual Union All
						Select '报告配置管理' ,'M' ,&n_System, 2286,  '配置管理' ,99, '用于对常用的数据进行管理。' From Dual Union All
                        Select 标题,快键,系统,模块,短标题,图标,说明 From zlMenus Where 1 = 0) B;          


Insert into zltools.zlmodulerelas(系统,模块,功能,相关类型,相关系统,相关模块)Values(&n_System,1290,'影像报告编辑',0,&n_System,2285);
Insert into zltools.zlmodulerelas(系统,模块,功能,相关类型,相关系统,相关模块)Values(&n_System,1291,'影像报告编辑',0,&n_System,2285);
Insert into zltools.zlmodulerelas(系统,模块,功能,相关类型,相关系统,相关模块)Values(&n_System,1294,'影像报告编辑',0,&n_System,2285);


Insert Into 影像报告事件(ID, 种类, 编号, 名称)
				Select ID, 种类, 编号, 名称 From 影像报告事件 Where 1=0 Union All
				Select HexToRaw('0BCA735D61294F05A0BFA5E93B409771'), 1, 1, '文档加载' From Dual Union All
				Select HexToRaw('B8F0478CFF9B4BEC8AD733779739494E'), 1, 2, '编辑保存' From Dual Union All
				Select HexToRaw('2A17D53BD9794BB6A86AC3201A1335C2'), 1, 3, '编辑签名' From Dual Union All
				Select HexToRaw('3ED424CA8F37473F93F457FEBE8369D0'), 1, 4, '审定签名' From Dual;


Insert Into 影像报告预备提纲(ID,编码, 名称, 说明)
				Select ID, 编码, 名称,说明 From 影像报告预备提纲 Where 1=0 Union All
				Select HexToRaw('6B3594CE8A7742F0854B2D15B56EA2B7'), '0', '检查方法', '检查所采用的方式方法' From Dual Union All
				Select HexToRaw('A767B8E7A7A34B79ADD2D8289C96A042'), '1', '检查所见', '检查过程中所看见的现象' From Dual Union All
				Select HexToRaw('32D862CC317A48E8BC88950BECD5D1F8'), '2', '检查结果', '根据检查所见得到的结果' From Dual Union All
				Select HexToRaw('9B2257C119E841128728608C6B400203'), '3', '诊断建议', '提供诊断的一些建议' From Dual Union All
				Select HexToRaw('5B49FF8C92B44127AB929D80BE59E3FA'), '4', '诊断意见', '提供诊断的一些意见' From Dual Union All
				Select HexToRaw('1F2CF257D94A40048862E4C7C93AA4E5'), '5', '专科报告', '' From Dual;

Insert Into  影像报告插件(ID,编码,名称,显示样式,种类,类名,库名,是否禁用)
				Select ID,编码,名称,显示样式,种类,类名,库名,是否禁用 From 影像报告插件 Where 1=0 Union All
				Select HexToRaw('791DF464AF9049F49502FE913140D72D'),'1', '历史报告',   1, 0, 'ZLSoft.ZLPacs.PlugIn.ReportHistory','zlPacsPlugin.ReportHistory.dll',0 From Dual Union All
				Select HexToRaw('80919C36340B463B95A75076AEDFA5D4'),'2', '报告缩略图', 1, 0, 'ZLSoft.ZLPacs.PlugIn.StudyImage','zlPacsPlugin.StudyImage.dll',0 From Dual Union All
				Select HexToRaw('AA71B69DF128432F943F61723F594445'),'3', '医学符号',   1, 0, 'ZLSoft.ZLPacs.PlugIn.MedicalSymbol','zlPacsPlugin.MedicalSymbols.dll',0 From Dual Union All
                Select HexToRaw('86DBCFC3BA0F4AE39B3EE2ECF950A04F'),'4', '图像处理',   0, 0, 'ZLSoft.ZLPacs.PlugIn.FImageEditor','ZLPacsPlugIn.ImageEditor.dll',0 From Dual Union All
				Select HexToRaw('FD3E0FCCE5924B8C9C0AFEF880ABB1A6'),'5', '专科报告',   1, 1, 'ZLSoft.ZLPacs.PlugIn.SpecialReport','zlPacsPlugin.SpecialReport.dll',0 From Dual;	

Insert Into 影像字典清单(ID,分组,编号,名称,说明,是否系统)Values(sys_guid(),'医技工作',1,'影像图像备注','影像图像备注',0);


Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'2285',null,1,'启用签名图章','1',3,null,null,'根据此参数判断报告签名时，是否使用图章进行签名.');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'2285',null,2,'是否显示签名时间','0',3,null,null,'根据此参数配置签名后的签名时间是否显示.');




Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'StudyImage','检查图像',1,'报告中显示大图','0',4,'0,1,2','','在缩略图中是否可以进行显示大图操作，0-不显示；1-鼠标移动时显示；2-双击时显示');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'StudyImage','检查图像',2,'报告大图放大倍数','1.0',4,'大于0','','在缩略图中显示大图时，图像放大倍数');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'StudyImage','检查图像',3,'每页显示图像数','6',4,'大于0','','在缩略图中，每页显示的图像数量');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'StudyImage','检查图像',4,'双击图像后续操作','0',4,'-1，0，1','','在缩略图中，双击图像后的处理，-1-不做处理；0-将图像加入报告；1-将图像进行编辑');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'StudyImage','检查图像',5,'嵌入图像编辑器','0',4,'0,1','','在缩略图中，是否嵌入简易图像编辑器');



Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'ReportHistory','历史报告',1,'查看他科历史报告','0',4,'0，1','','在PACS报告编辑器中，通过历史报告功能查看其他科室的报告。');

Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'ReportHistory','历史报告',1,'查看历史报告','0',4,'0，1，2','','历史报告读取方式，0-电子病历编辑器模式；1-PACS报告编辑器模式；2-报告文档编辑器模式');


Insert Into 影像参数说明(ID,PID,系统,模块,分组,参数序号,参数名,默认值,参数级别,取值范围,启用条件,说明)
Values(sys_guid(),'',100,'ImageEditor','图像处理',1,'备注字体设置','',4,'','','设置图像备注字体。');




--85463:许华峰,2015-07-20,检查列表按影像类别和检查部位过滤
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 1, 0, 0, 1, 49,'影像类别过滤', 0, 0, '检查列表数据按影像类别过滤'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1290 And 参数名 = '影像类别过滤');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 1, 0, 0, 1, 53,'影像类别过滤', 0, 0, '检查列表数据按影像类别过滤'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1291 And 参数名 = '影像类别过滤');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 1, 0, 0, 1, 50,'检查部位过滤', 0, 0, '检查列表数据按检查部位过滤'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1290 And 参数名 = '检查部位过滤');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 1, 0, 0, 1, 54,'检查部位过滤', 0, 0, '检查列表数据按检查部位过滤'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1291 And 参数名 = '检查部位过滤');

--85971:胡俊勇,2015-06-29,医嘱用药天数反算
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 240, '医嘱用药天数反算', '0', '0',
         '药品医嘱在允许输入天数时，天数可根据单量总量等信息反算天数， 0-不反算， 1-要反算'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 Is Null And 参数号 = 240);


--85773:许华峰,2015-06-29,XW3D观片
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1288, 0, 0, 0, 0, 17,'XWWEB观片地址', 0, 'http://127.0.0.1:8080/imageweb/imageAction.action?ColID0=22&'||'ColValue0=[@STU_NO]', 'XW PACS WEB服务器的地址。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1288 And 参数名 = 'XWWEB观片地址');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1288, 0, 0, 0, 0, 18,'XW3D观片类型', 0, 'Study3D', 'XW PACS 3D观片时的观片类型，“Study3D”为直接打开该检查的图像，第一个序列加载3D，“SeriesList3D” 为打开该检查的序列，由用户选择加载某个序列的3D后打开'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1288 And 参数名 = 'XW3D观片类型');

--86000:刘尔旋,2015-06-25,新增预约接收模式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 64, '预约接收模式', '0', '0',
         '决定门诊挂号管理预约接收后病人是否立即就诊 0-预约接收立即就诊模式 1-预约接收不就诊模式'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 参数名 = '预约接收模式' And 模块 = 1111 And 系统 = &n_System);

--85849:王振涛,2015-06-17,刷卡方式变更
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1208, 0, 1, 0, 0,146 , '打印输入方式', '0', '0',
           '导诊系统中，用户选择的输入方式 0-样本条码，1-住院号，2-门诊号，3-消费卡'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '打印输入方式' And 模块 = 1208 And 系统 = &n_System);

--74393:刘尔旋,2015-06-09,导诊系统刷卡改进
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1804, 0, 0, 0, 0, 15, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1804 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1804, 0, 0, 0, 0, 16, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1804 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1806, 0, 0, 0, 0, 4, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1806 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1806, 0, 0, 0, 0, 5, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1806 And 系统 = &n_System);
--86422:李南春,2015-07-10,参数号调整
Update zlParameters Set  参数号=5 Where Nvl(系统, 0) = &n_System And Nvl(模块, 0) = 1806 And 参数名 = '身份识别键盘控制';

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1807, 0, 0, 0, 0, 10, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1807 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1807, 0, 0, 0, 0, 11, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1807 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1216, 0, 0, 0, 0, 4, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1216 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1216, 0, 0, 0, 0, 5, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1216 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1290, 0, 0, 0, 0, 46, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1290 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1290, 0, 0, 0, 0, 47, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1290 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1805, 0, 0, 0, 0, 22, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1805 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1805, 0, 0, 0, 0, 23, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1805 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 26, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1802 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 27, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1802 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 26, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1803 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 27, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1803 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1208, 0, 0, 0, 0, 140, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1208 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1208, 0, 0, 0, 0, 141, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1208 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1808, 0, 0, 0, 0, 7, '身份识别读卡模式', Null, Null,
           '主要是针对自助机各身份识别的读卡模式配置,格式为:卡类别ID,读卡性质(1-刷卡;2-扫描,3-接触式读卡;4-非接触式读卡)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别读卡模式' And 模块 = 1808 And 系统 = &n_System);
    
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1808, 0, 0, 0, 0, 8, '身份识别键盘控制', Null, Null,
           '主要是针对自助机身份识别时软键盘的配置,格式为:卡类别ID,键盘控制方式 (0-禁止使用软键盘;1-使用数字软键盘 ,2-使用字符软键盘)||...'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '身份识别键盘控制' And 模块 = 1808 And 系统 = &n_System);

--85475:李南春,2015-06-05,取N天内的预约号
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 36,'取N天内的预约号', Null, '1','0-表示不限制,>0表示能够取多少天内的号。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1082 And 参数名 = '取N天内的预约号');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 36,'取N天内的预约号', Null, '1','0-表示不限制,>0表示能够取多少天内的号。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1083 And 参数名 = '取N天内的预约号');

--85292:胡俊勇,2015-06-03,医嘱核对参数调整
declare 
  v_Tmp varchar2(200);
begin
  select decode(参数值,null,'00','0','00','1','11',参数值)
  into v_Tmp
  from zlparameters where 系统=100 and 参数号=186 and 参数名='输血和皮试医嘱执行后需要核对';
  update zlparameters set 参数值=v_Tmp,参数说明='医嘱执行登记后必须核对后才允许完成；按位控制，第一位输血医嘱，第二皮试医嘱；1-是，0-否。'
  where 系统=100 and 参数号=186 and 参数名='输血和皮试医嘱执行后需要核对';
end;
/

--85180:胡俊勇,2015-05-31,历史消息的长期积累带来的性能问题
Update 业务消息类型 set 保留天数=7 where 编码 not in ('ZLHIS_LIS_002','ZLHIS_PACS_005');

Insert Into 业务消息类型(编码,名称,说明,保留天数) 
Select 'ZLHIS_CIS_026','新嘱审核提醒','实习医生下达的医嘱需要正式医生审核时产生的一个通知道消息。',7 From Dual Union All
Select 'ZLHIS_CIS_027','新停审核提醒','实习医生停止长医嘱需要正式医生审核时产生的一个通知道消息。',7 From Dual Union All
Select 'ZLHIS_CIS_028','手术审核提醒','医生下达的手术医嘱需要审核时产生的一个通知消息。',7 From Dual Union All
Select 'ZLHIS_CIS_029','抗菌药物审核提醒','医生下达的抗菌药物医嘱需要审核时产生的一个通知消息。',7 From Dual Union All
Select 'ZLHIS_CIS_030','输血审核提醒','在未启用血库系统时，医生下达的输血医嘱需要审核时产生的一个通知消息。',7 From Dual;

--84958:许华峰,2015-05-20,PACS依赖性接口部件
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 9004,'PACS公共模块','用于PACS公共接口访问的相关对象授权',&n_System,'zlPublicPACS');

--84458:许华峰,2015-05-20,新版报告最终状态显示
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 0, 1, 1, 1, 48,'最终状态显示', 0, 0, '报告最终状态显示'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1290 And 参数名 = '最终状态显示');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 0, 1, 1, 1, 52,'最终状态显示', 0, 0, '报告最终状态显示'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1291 And 参数名 = '最终状态显示');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 1, 1, 1, 108,'最终状态显示', 0, 0, '报告最终状态显示'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1294 And 参数名 = '最终状态显示');


--84929:冉俊明,2015-05-15,增加参数“补结算有效天数”，通过该参数提取可进行保险补充结算的费用。
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1124, 0, 0, 0, 0, 16, '补结算有效天数',
         (Select Decode(Substr(Nvl(参数值, 缺省值), 1, 1), '0', '3', Substr(Nvl(参数值, 缺省值), 1, 1)) As Validday
           From zlParameters
           Where 系统 = &n_System And 模块 Is Null And 参数名 = '挂号有效天数'), '3', '可进行医保补充结算的费用有效天数。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1124 And 参数名 = '补结算有效天数');

--83068:李南春,2015-04-13,通过医生姓名查找医生
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 33,'查找医生图标对照', Null, Null, '自助挂号查找医生图标对照:图标|按下图标'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1802 And 参数名 = '查找医生图标对照');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 33,'查找医生图标对照', Null, Null, '自助挂号查找医生图标对照:图标|按下图标'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1803 And 参数名 = '查找医生图标对照');






-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--84458:涂建华,2015-07-02,新版Pacs报告编辑器处理
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2280,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select '元素管理',1,'对影像报告元素进行配置修改。',1 From Dual Union All
       Select '值域管理',2,'对影像报告的取值范围进行设置。',1 From Dual Union All
       Select '分类管理',3,'对影像报告元素进行分类配置。',1 From Dual Union All
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2280,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_PACS_RptElement','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--2281模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2281,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2281,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCombo','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--2282模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2282,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select '学科片段',1,'管理学科类型片段(已废弃)。',1 From Dual Union All
       Select '所有片段',2,'对所有片段进行管理。',1 From Dual Union All
       Select '他人片段',3,'允许管理其他人的报告片段。',1 From Dual Union All
       Select '分类管理',4,'对片段分类进行管理。',1 From Dual Union All
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2282,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_PACS_RptFragments','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--2283模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2283,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select '原型管理',1,'对报告原型进行分类管理。',1 From Dual Union All 
       Select '报告种类',2,'对报告原型进行分类管理。',1 From Dual Union All 
       Select '预备提纲',3,'设置报告预备提纲。',1 From Dual Union All 
       Select '片段关联',4,'设置报告关联片段。',1 From Dual Union All 
       Select '诊疗项目关联',5,'设置报告关联片段。',1 From Dual Union All 
       Select '插件管理',6,'设置报告关联片段。',1 From Dual Union All 
       Select '事件管理',7,'授予报告插件管理权限。',1 From Dual Union All 
       Select '报告动作',8,'设置报告触发动作。',1 From Dual Union All 
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A; 
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2283,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_PACS_RptAntetype','EXECUTE' From Dual Union All
	Select 'b_PACS_RptPluginCustom','EXECUTE' From Dual Union All
	Select 'b_PACS_RptPluginOriginal','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--2284模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2284,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select '学科范文',1,'管理学科类范文。',1 From Dual Union All
       Select '所有范文',2,'管理所有类型的范文。',1 From Dual Union All
       Select '他人范文',3,'允许管理他人范文。',1 From Dual Union All
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;       
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2284,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_Pacs_RptSampleList','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--2285模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select &n_System,2285,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All    
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select &n_System,2285,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select '影像报告记录','SELECT' From Dual Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCommon','EXECUTE' From Dual Union All
	Select 'b_PACS_RptManage','EXECUTE' From Dual Union All
	Select 'b_Pacs_RptSampleList','EXECUTE' From Dual Union All
	Select 'b_PACS_RptAntetype','EXECUTE' From Dual Union All
	Select 'b_PACS_RptFragments','EXECUTE' From Dual Union All
	Select 'b_PACS_RptElement','EXECUTE' From Dual Union All
	Select 'b_PACS_RptCombo','EXECUTE' From Dual Union All
	Select 'b_PACS_RptPluginCustom','EXECUTE' From Dual Union All
	Select 'b_PACS_RptPluginOriginal','EXECUTE' From Dual Union All
	Select 'b_PACS_RptParam','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;       

--2286模块

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
       Select 100,2286,A.* From (
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '基本',-NULL,NULL,1 From Dual Union All
       Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
	Select 100,2286,'基本',User,A.* From (
	Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
	Select 'b_PACS_Config','EXECUTE' From Dual Union All
	Select 'b_PACS_Common','EXECUTE' From Dual Union All
	Select 'b_PACS_RptParam','EXECUTE' From Dual Union All
	Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--影像医技工作站													
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1290,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select 'PACS报告终审',36,'对Pacs报告进行最终审核，审核后将不能继续审核和编辑。',1 From Dual Union All
  Select '补录报告',        37,'对已经完成的检查，补充新增，修改，删除报告。',0 From Dual Union All
  Select 'PACS报告审核',    38,'对PACS报告进行审核。',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;


--影像采集工作站	
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1291,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select 'PACS报告终审',33,'对Pacs报告进行最终审核，审核后将不能继续审核和编辑。',1 From Dual Union All
  Select '补录报告',         34,'对已经完成的检查，补充新增，修改，删除报告。',0 From Dual Union All
  Select 'PACS报告审核',    35,'对PACS报告进行审核。',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;


--影像病理工作站	
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1294,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select 'PACS报告终审',57,'对Pacs报告进行最终审核，审核后将不能继续审核和编辑。',1 From Dual Union All
  Select '补录报告',         58,'对已经完成的检查，补充新增，修改，删除报告。',0 From Dual Union All
  Select 'PACS报告审核',    59,'对PACS报告进行审核。',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;


--84345:许华峰,2015-06-30,是否发送WorkList
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'ZL_影像检查记录_发送安排', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And Upper(对象) = Upper('ZL_影像检查记录_发送安排'));

--84958:许华峰,2015-05-20,PACS依赖性接口部件
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,9004,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',-NULL,NULL,1 From Dual Union All
Select '全院影像查询',1,'用于查询全院的影像报告及图像',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;
       
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9004,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '部门表','SELECT' From Dual Union All
Select '部门人员','SELECT' From Dual Union All
Select '人员表','SELECT' From Dual Union All
Select '人员性质说明','SELECT' From Dual Union All
Select '部门性质说明','SELECT' From Dual Union All
Select '病案主页','SELECT' From Dual Union All
Select '病人信息','SELECT' From Dual Union All
Select '病人医嘱记录','SELECT' From Dual Union All
Select '病人医嘱报告','SELECT' From Dual Union All
Select '病人医嘱发送','SELECT' From Dual Union All
Select '电子病历记录','SELECT' From Dual Union All
Select '电子病历内容','SELECT' From Dual Union All
Select '电子病历图形','SELECT' From Dual Union All
Select '影像检查记录','SELECT' From Dual Union All
Select '影像设备目录','SELECT' From Dual Union All
Select '影像检查序列','SELECT' From Dual Union All
Select '影像流程参数','SELECT' From Dual Union All
Select '影像报告记录','SELECT' From Dual Union All
Select '诊疗项目目录','SELECT' From Dual Union All
Select '报告查阅记录','SELECT' From Dual Union All
Select 'Zlpub_Pacs_获取报告列表','EXECUTE' From Dual Union All
Select 'Zlpub_Pacs_获取报告提纲','EXECUTE' From Dual Union All
Select 'Zlpub_Pacs_获取报告文本','EXECUTE' From Dual Union All
Select 'Zlpub_Pacs_获取提纲内容','EXECUTE' From Dual Union All
Select 'Zl_影像报告查阅记录_Insert','EXECUTE' From Dual Union All
Select 'Zl_影像报告查阅记录_Cancel','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--86691:刘硕,2015-07-20,临床增加PACS报告检查权限
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1259, Null, &n_System, 9004, 1, Null, 0 From Dual;
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1252, Null, &n_System, 9004, 1, Null, 0 From Dual;
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 1253, Null, &n_System, 9004, 1, Null, 0 From Dual;

Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9004, 角色, '基本'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1259 And 功能 = '基本' And Not Exists
   (Select 1 From zlRoleGrant B Where b.系统 = &n_System And b.序号 = 9004 And b.角色 = a.角色 And b.功能 = '基本');
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9004, 角色, '基本'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1252 And 功能 = '基本' And Not Exists
   (Select 1 From zlRoleGrant B Where b.系统 = &n_System And b.序号 = 9004 And b.角色 = a.角色 And b.功能 = '基本');
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9004, 角色, '基本'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1253 And 功能 = '基本' And Not Exists
   (Select 1 From zlRoleGrant B Where b.系统 = &n_System And b.序号 = 9004 And b.角色 = a.角色 And b.功能 = '基本');

--84458:许华峰,2015-05-18,新版报告状态更新
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1290, '基本', User, 'Zl_影像检查_状态更新', 'EXECUTE'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1290 And 功能 = '基本' And 对象 = 'Zl_影像检查_状态更新'); 
  
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1291, '基本', User, 'Zl_影像检查_状态更新', 'EXECUTE'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1291 And 功能 = '基本' And 对象 = 'Zl_影像检查_状态更新'); 
  
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1294, '基本', User, 'Zl_影像检查_状态更新', 'EXECUTE'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1294 And 功能 = '基本' And 对象 = 'Zl_影像检查_状态更新'); 

--84833:王振涛,2015-05-14,流水线表权限
Insert Into zlProgPrivs
(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1208, '基本', User, '检验流水线指标', 'SELECT'
From Dual
Where Not Exists
(Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1208 And 功能 = '基本' And 对象 = '检验流水线指标');

Insert Into zlProgPrivs
(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1208, '基本', User, '检验流水线标本', 'SELECT'
From Dual
Where Not Exists
(Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1208 And 功能 = '基本' And 对象 = '检验流水线标本');

--84688:刘兴洪,2015-05-12,病人结帐管理中支持支付宝
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1137, '基本', User, '保险结算明细', 'SELECT'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1137 And 功能 = '基本' And 对象 = '保险结算明细');   

--84087:李南春,2015-04-22,自助挂号获取病人费别
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1802,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'Zl_Custom_Getpatifeetype','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0 ) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1803,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'Zl_Custom_Getpatifeetype','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0 ) A;

--84007:余伟节,2015-04-15,增加入院管理和入出管理模块基本功能表的查询权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '血型', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And 对象 = '血型');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '病人医嘱记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And 对象 = '病人医嘱记录');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, '病人诊断医嘱', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And 对象 = '病人诊断医嘱');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1132, '基本', User, '病人诊断医嘱', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1132 And 功能 = '基本' And 对象 = '病人诊断医嘱');

--82922:张德婷,2015-04-13,处方明细增加体重信息
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1341, '基本', User, '病人护理记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1341 And 功能 = '基本' And 对象 = '病人护理记录');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1341, '基本', User, '病人护理内容', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1341 And 功能 = '基本' And 对象 = '病人护理内容');

--83815:张德婷,2015-04-13,支付宝支付后返回提示信息
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1341, '基本', User, 'Zl_MSG_PointOut', 'EXECUTE'
  From Dual
  Where Not Exists
  (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1341 And 功能 = '基本' And 对象 = 'Zl_MSG_PointOut');   

--86283:余伟节,2015-07-09,江苏宿迁北京CA接口
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1252,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1341,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1342,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1250,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1251,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1208,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1255,'护理记录签名',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1255,'取消记录签名',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,2285,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_人员证书记录_insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------






-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--86530:刘鹏飞,2015-7-20,撤销检查是否是对最后一次住院进行撤销操作
Create Or Replace Procedure Zl_病人变动记录_Undo
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type,
  数据_In       Varchar2 := Null, --a.转为住院时,清除住院号,b-检查自动记帐费用是否已结帐
  床号_In       Varchar2 := Null, --传入时表示撤销出院时安排到新的床号，原床位被占用在程序中判断
  主床位_In     Varchar2 := Null, --传入时表示撤销出院时安排到新的主床位，原床位被占用在程序中判断
  撤销方式_In   Varchar2 := Null --指明具体撤销操作，如撤销出院、转科等必须输入
) As
  -----------------------------------------------------------
  --说明：1.撤消病人最近一次的变动
  --        2.前提：当病人包床时,对其中一张床位作变动,则所有床位相应产生变动
  -----------------------------------------------------------
  --要撤消的变动记录(如果包床,可能多条)
  Cursor c_Curlog Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Curlogrow c_Curlog%Rowtype;

  --撤消后要恢复的变动记录(如果包床,可能多条)
  Cursor c_Prelog
  (
    v_终止时间 病人变动记录.终止时间%Type,
    v_终止原因 病人变动记录.终止原因%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prelogrow c_Prelog%Rowtype;

  --获取病人原床位所住病人信息
  Cursor c_Prebed
  (
    v_病人id 病案主页.病人id%Type,
    v_主页id 病案主页.主页id%Type
  ) Is
    Select a.床号, c.出院病床, c.出院科室id, c.当前病区id
    From 病人变动记录 a, 床位状况记录 b, 病案主页 c
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And
          a.主页id = c.主页id And a.床号 = b.床号
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedrow c_Prebed%Rowtype;

  Cursor c_Prebedpati
  (
    v_出院科室id 病人变动记录.科室id%Type,
    v_病区id     病人变动记录.病区id%Type,
    v_原床号     病人变动记录.床号%Type
  ) Is
    Select a.病人id, c.主页id, a.床号, c.出院病床
    From 病人变动记录 a, 病案主页 c,
         (Select 病人id
           From 床位状况记录
           Where (科室id Is Null Or 科室id = v_出院科室id Or 共用 = 1) And 病区id = v_病区id And 床号 = v_原床号) d
    Where a.病人id = d.病人id And a.主页id = (Select 主页id From 病人信息 Where 病人id = d.病人id) And a.终止原因 = 4 And a.病人id = c.病人id And
          a.主页id = c.主页id
    Order By 终止时间 Desc, 开始时间 Desc;
  r_Prebedpati c_Prebedpati%Rowtype;

  v_开始时间 病人变动记录.开始时间%Type;
  v_开始原因 病人变动记录.开始原因%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Count       Number;
  v_Countcurlog Number;
  v_Countprelog Number;

  Err_Custom Exception;
  v_Error Varchar2(255);

  v_撤销方式     Varchar2(100);
  v_共享号       Zlsystems.共享号%Type;
  v_病案状态     Number(3);
  v_床号串       Varchar2(255);
  v_床号         病人变动记录.床号%Type;
  v_病人id       病人变动记录.病人id%Type;
  v_主页id       病人变动记录.主页id%Type;
  v_病区id       病人变动记录.病区id%Type;
  v_原床号1      病人变动记录.床号%Type;
  v_原床号2      病人变动记录.床号%Type;
  v_当前床号1    病人变动记录.床号%Type;
  v_当前床号2    病人变动记录.床号%Type;
  v_出院科室id   病人变动记录.科室id%Type;
  v_床位等级id   病人变动记录.床位等级id%Type;
  v_险类         病案主页.险类%Type;
  v_姓名         病人信息.姓名%Type;
  n_原科室id     病案主页.出院科室id%Type;
  n_原病区id     病案主页.当前病区id%Type;
  v_母婴转科标志 病案主页.母婴转科标志%Type;
  v_Tmp          Varchar2(100);
Begin
  If 撤销方式_In Is Null Then
    v_Error := '[ZLSOFT]没有指明具体的撤销操作！[ZLSOFT]';
    Raise Err_Custom;
  Else
    v_撤销方式 := 撤销方式_In;
  End If;

  Open c_Curlog;
  Fetch c_Curlog
    Into r_Curlogrow;
  If c_Curlog%Rowcount = 0 Then
    v_Error := '[ZLSOFT]病人当前没有可以撤消的操作！[ZLSOFT]';
    Close c_Curlog;
    Raise Err_Custom;
  End If;
  
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id > 主页id_In;
  If v_Count > 0 Then
    v_Error := '[ZLSOFT]您只能对病人的最后一次住院进行撤销操作,本次撤销操作终止![ZLSOFT]';
    Raise Err_Custom;
  End If;
  
  Select Count(Id)
  Into v_Countcurlog
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And (终止时间 Is Null Or 终止原因 = 1)
  Order By 终止时间 Desc, 开始时间 Desc;

  Select Count(a.床号)
  Into v_Countprelog
  From 病人变动记录 a, 床位状况记录 b, 病案主页 c
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And 终止原因 = 4 And a.病区id = b.病区id And a.病人id = c.病人id And a.主页id = c.主页id And
        a.床号 = b.床号
  Order By 终止时间 Desc, 开始时间 Desc;

  --判断是否撤消床位对换
  If v_撤销方式 = '换床' And v_Countcurlog <= 1 And v_Countprelog <= 1 Then
    Open c_Prebed(病人id_In, 主页id_In);
    Fetch c_Prebed
      Into r_Prebedrow;
  
    v_出院科室id := r_Prebedrow.出院科室id;
    v_病区id     := r_Prebedrow.当前病区id;
    v_原床号1    := r_Prebedrow.床号;
    v_当前床号1  := r_Prebedrow.出院病床;
  
    For r_Prebedpati In c_Prebedpati(v_出院科室id, v_病区id, v_原床号1) Loop
      v_病人id    := r_Prebedpati.病人id;
      v_主页id    := r_Prebedpati.主页id;
      v_原床号2   := r_Prebedpati.床号;
      v_当前床号2 := r_Prebedpati.出院病床;
    
      If v_病人id <> 0 And v_主页id <> 0 And v_原床号1 = v_当前床号2 And v_原床号2 = v_当前床号1 Then
        v_撤销方式 := '床位对换';
        Select 险类 Into v_险类 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id;
        If v_险类 Is Null Then
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, Null, 床号_In, 主床位_In, v_撤销方式);
        Else
          Zl_病人变动记录_Undo(v_病人id, v_主页id, 操作员编号_In, 操作员姓名_In, '1', 床号_In, 主床位_In, v_撤销方式);
        End If;
      End If;
    
      --只对最近一次床位是对方床位的记录进行处理
      Exit;
    End Loop;
  End If;

  If r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 3;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Null And r_Curlogrow.开始时间 Is Null And r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区' Then
    --撤消转科(标志)
    Delete From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null And 开始原因 = 15;
  
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Close c_Curlog;
  Elsif r_Curlogrow.终止时间 Is Not Null And r_Curlogrow.终止原因 = 1 And v_撤销方式 = '出院' Then
    --撤消出院
    v_开始时间 := r_Curlogrow.终止时间; --新增的变动记录的开始时间
  
    Select Zl_住院日报_Count(r_Curlogrow.科室id, r_Curlogrow.终止时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
    --是否进行过电子病案审查
    Select Nvl(病案状态, 0) Into v_病案状态 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If v_病案状态 Not In (0, 2) Then
      v_Error := '[ZLSOFT]病人的电子病案已提交审查，不能再撤消出院。[ZLSOFT]';
      Close c_Curlog;
      Raise Err_Custom;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
  
    --恢复入院
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Not Null And 终止原因 = 1;
  
    Select 开始原因
    Into v_开始原因
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And Nvl(附加床位, 0) = 0;
  
    Update 病案主页
    Set 状态 = Decode(v_开始原因, 10, 3, 状态), 出院日期 = Null, 出院方式 = Null, 随诊标志 = Null, 随诊期限 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --处理床位
    If 床号_In Is Null Then
      --原床位没有被占用,家庭病床也不会被占用(程序中已判断被占用情况,占用会传入床号_In)
      Close c_Curlog;
      For r_Curlogrow In c_Curlog Loop
        If r_Curlogrow.床号 Is Not Null Then
          --检查床位
          Select Count(*)
          Into v_Count
          From 床位状况记录
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号 And 状态 = '空床';
          If v_Count = 0 Then
            v_Error := '[ZLSOFT]操作失败,床位 ' || r_Curlogrow.床号 || ' 不是空床！[ZLSOFT]';
            Raise Err_Custom;
          End If;
          --重新占用床位
          Update 床位状况记录
          Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Curlogrow.床位等级id, 科室id = r_Curlogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
          Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
        End If;
      
        If Nvl(r_Curlogrow.附加床位, 0) = 0 Then
          Update 病人信息
          Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = r_Curlogrow.床号, 在院 = 1
          Where 病人id = 病人id_In;
        
          --更新在院病人
          Begin
            Update 在院病人
            Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id
            Where 病人id = 病人id_In;
            If Sql%Rowcount = 0 Then
              Insert Into 在院病人
                (病人id, 科室id, 病区id)
              Values
                (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
            End If;
          Exception
            When Others Then
              Null;
          End;
        
        End If;
      End Loop;
    Else
      --原床位被占用，传入新安排的床位,入住一张或多张病床病床
      v_床号串 := 床号_In || ',';
      --如果病人出院前状态为预出院，则撤消预出院
      If v_开始原因 = 10 Then
        --撤消预出院
        Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
        --恢复变动
        Delete From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
      
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 4, 终止人员 = 操作员姓名_In
        Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
      End If;
    
      While v_床号串 Is Not Null Loop
        v_床号 := Substr(v_床号串, 1, Instr(v_床号串, ',') - 1);
        --原始床位等级与新床位等级及数量在程序中判断
        --检查床位
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '操作失败,床位 ' || v_床号 || ' 不是空床！';
          Close c_Curlog;
          Raise Err_Custom;
        End If;
        --更新床位状况记录
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 科室id = r_Curlogrow.科室id
        Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
      
        Select 等级id Into v_床位等级id From 床位状况记录 Where 病区id = r_Curlogrow.病区id And 床号 = v_床号;
        ----新增原因为4
        Insert Into 病人变动记录
          (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
           操作员姓名)
        Values
          (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_开始时间, 4, Decode(主床位_In, v_床号, 0, 1), r_Curlogrow.病区id,
           r_Curlogrow.科室id, r_Curlogrow.医疗小组id, r_Curlogrow.护理等级id, v_床位等级id, v_床号, r_Curlogrow.责任护士, r_Curlogrow.经治医师,
           r_Curlogrow.主治医师, r_Curlogrow.主任医师, r_Curlogrow.病情, 操作员编号_In, 操作员姓名_In);
      
        v_床号串 := Substr(v_床号串, Instr(v_床号串, ',') + 1);
      End Loop;
      --更新病人信息
      Update 病人信息
      Set 出院时间 = Null, 当前病区id = r_Curlogrow.病区id, 当前科室id = r_Curlogrow.科室id, 当前床号 = 主床位_In, 在院 = 1
      Where 病人id = 病人id_In;
    
      --更新在院病人
      Begin
        Update 在院病人 Set 病区id = Nvl(r_Curlogrow.病区id, 0), 科室id = r_Curlogrow.科室id Where 病人id = 病人id_In;
        If Sql%Rowcount = 0 Then
          Insert Into 在院病人
            (病人id, 科室id, 病区id)
          Values
            (病人id_In, r_Curlogrow.科室id, Nvl(r_Curlogrow.病区id, 0));
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      --更新病案主页出院病床
      Update 病案主页 Set 出院病床 = 主床位_In Where 病人id = 病人id_In And 主页id = 主页id_In;
      Close c_Curlog;
    End If;
    --删除出院诊断 保留该诊断信息
    --Delete From 病人诊断记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 in (3,13) And 记录来源 = 2;
  
    Begin
      Select 共享号 Into v_共享号 From Zlsystems Where Floor(编号 / 100) = 3;
    Exception
      When Others Then
        Null;
    End;
    --删除该病人的随诊记录
    If v_共享号 = 100 Then
      Execute Immediate 'Delete From 随诊记录 Where 病人id =:1 And 主页id =:2'
        Using 病人id_In, 主页id_In;
    End If;
  Elsif r_Curlogrow.开始原因 = 1 And v_撤销方式 = '入院入住' Then
    --撤消入科(入院同时入科)
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    Close c_Curlog;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Update 病案主页 Set 入院病床 = Null, 出院病床 = Null, 状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
  
    --恢复变动(入院同时入科不会有包床)
    --因为是同一条记录中的撤消,所以不处理人员
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 1 And 终止时间 Is Null;
  Elsif r_Curlogrow.开始原因 = 2 And v_撤销方式 = '入住' Then
    --撤消入院入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件 a, 病人护理数据 b
    Where a.Id = b.文件id And 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And Rownum < 2;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生有数据的护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
    Delete From 病人护理文件 Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --相关信息还原
    Open c_Prelog(v_开始时间, 2);
    Fetch c_Prelog
      Into r_Prelogrow;
    Update 病案主页
    Set 入院病床 = Null, 出院病床 = Null, 状态 = 1, 当前病况 = r_Prelogrow.病情, 入院病况 = r_Prelogrow.病情, 医疗小组id = r_Prelogrow.医疗小组id,
        护理等级id = r_Prelogrow.护理等级id
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    Close c_Prelog;
  
    Update 病人信息 Set 当前床号 = Null Where 病人id = 病人id_In;
    Delete 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And (信息名 = '主治医师' Or 信息名 = '主任医师');
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 2 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 2 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 3 And v_撤销方式 = '转科入住' Then
    --撤消转科入科
    v_开始时间 := r_Curlogrow.开始时间;
    Select Zl_住院日报_Count(r_Curlogrow.科室id, v_开始时间) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]已产生业务时间内的住院日报,不能办理该业务![ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into v_Count
    From 病人护理文件
    Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = r_Curlogrow.科室id And 创建时间 >= r_Curlogrow.开始时间;
    If v_Count > 0 Then
      v_Error := '[ZLSOFT]病人已产生护理文件，不能办理该业务！[ZLSOFT]';
      Raise Err_Custom;
    End If;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '转科', r_Curlogrow.科室id);
    Close c_Curlog;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 3) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该科室前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        --判断是否有婴儿
        Select Count(1) Into v_Count From 病人新生儿记录 Where 病人id = 病人id_In And 主页id = 主页id_In;
        If v_Count > 0 Then
          Select 母婴转科标志 Into v_母婴转科标志 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
          If v_母婴转科标志 Is Not Null Then
            If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
              --如果是1表示母亲和婴儿未分开，则清空“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”；
              Update 病案主页 Set 婴儿科室id = Null, 婴儿病区id = Null Where 病人id = 病人id_In And 主页id = 主页id_In;
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
              Else
                v_母婴转科标志 := '';
              End If;
            Else
              --如果是0，表示是上次转科是母亲单独转走的，则重新将原产科科室和病区填写到“病案主页.婴儿科室ID”和”病案主页.婴儿病区ID”（从病人变动记录中取），并清除最后一位标识
              If Length(v_母婴转科标志) > 1 Then
                v_母婴转科标志 := Substr(v_母婴转科标志, 1, Length(v_母婴转科标志) - 1);
                --查看上一次转科的标识
                If Substr(v_母婴转科标志, Length(v_母婴转科标志)) = '1' Then
                  Update 病案主页
                  Set 婴儿科室id = Null, 婴儿病区id = Null
                  Where 病人id = 病人id_In And 主页id = 主页id_In;
                Else
                  --取出转科前的婴儿科室病区ID
                  v_Tmp   := v_母婴转科标志;
                  v_Count := 1;
                  While v_Tmp Is Not Null Loop
                    v_Count := v_Count + 1;
                    If Substr(v_Tmp, Length(v_Tmp)) = '1' Then
                      Select Max(a.科室id) As 科室id, Max(a.病区id) As 科室id
                      Into n_原科室id, n_原病区id
                      From (Select 科室id, 病区id, Rownum As 序号
                             From (Select 科室id, 病区id
                                    From 病人变动记录
                                    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 附加床位 = 0
                                    Order By 开始时间 Desc)) a
                      Where 序号 = v_Count;
                    End If;
                    If Length(v_Tmp) = 1 Then
                      v_Tmp := '';
                    Else
                      v_Tmp := Substr(v_Tmp, 1, Length(v_Tmp) - 1);
                    End If;
                  End Loop;
                  If Nvl(n_原科室id, 0) = 0 Then
                    --如果没有找到，则取入院科室
                    Select Max(b.科室id), Max(b.病区id)
                    Into n_原科室id, n_原病区id
                    From 病人变动记录 b
                    Where b.病人id = 病人id_In And b.主页id = 主页id_In And b.科室id Is Not Null And b.病区id Is Not Null And
                          b.开始时间 = (Select Min(a.开始时间)
                                    From 病人变动记录 a
                                    Where a.病人id = b.病人id And a.主页id = b.主页id And a.科室id Is Not Null And
                                          a.病区id Is Not Null And a.附加床位 = 0);
                  End If;
                
                  If Nvl(n_原科室id, 0) <> 0 Then
                    Update 病案主页
                    Set 婴儿科室id = n_原科室id, 婴儿病区id = n_原病区id
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  Else
                    --之前没有转科记录,清空婴儿科室ID和婴儿病区ID
                    Update 病案主页
                    Set 婴儿科室id = Null, 婴儿病区id = Null
                    Where 病人id = 病人id_In And 主页id = 主页id_In;
                  End If;
                End If;
              Else
                --只有这一次转科,回退后清空婴儿科室病区ID
                v_母婴转科标志 := '';
                Update 病案主页
                Set 婴儿科室id = Null, 婴儿病区id = Null
                Where 病人id = 病人id_In And 主页id = 主页id_In;
              End If;
            End If;
            --去除最后一位标识
            Update 病案主页 Set 母婴转科标志 = v_母婴转科标志 Where 病人id = 病人id_In And 主页id = 主页id_In;
          End If;
        
        End If;
      
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主治医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        Update 病案主页从表
        Set 信息值 = r_Prelogrow.主任医师
        Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
      
        Update 病人信息
        Set 当前病区id = r_Prelogrow.病区id, 当前科室id = r_Prelogrow.科室id, 当前床号 = r_Prelogrow.床号
        Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0), 科室id = r_Prelogrow.科室id Where 病人id = 病人id_In;
      
      End If;
    End Loop;
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 病区id = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 3 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 3 And 终止时间 = v_开始时间;
  
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '换床' Then
    --撤消换床
    v_开始时间 := r_Curlogrow.开始时间;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人最近一次换床前所入住的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 4 And v_撤销方式 = '床位对换' Then
    --撤消床位对换
    v_开始时间 := r_Curlogrow.开始时间;
    Select 姓名 Into v_姓名 From 病人信息 Where 病人id = 病人id_In;
    Close c_Curlog;
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]病人 ' || v_姓名 || ' 的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --退除当前床位
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 4) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = Decode(共用, 1, r_Prelogrow.科室id, 科室id)
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --病人信息、病案主页,仅当病区与科室独立时,换床才可以换病区,此处为简化判断,统一还原病区
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 出院病床 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前床号 = r_Prelogrow.床号, 当前病区id = r_Prelogrow.病区id Where 病人id = 病人id_In;
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 4 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 4 And 终止时间 = v_开始时间;
  Elsif r_Curlogrow.开始原因 = 5 And v_撤销方式 = '床位等级变动' Then
    --撤消床位等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.床位等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
    --还原原床位的等级
    For r_Prelogrow In c_Prelog(r_Curlogrow.开始时间, 5) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 等级id = r_Prelogrow.床位等级id
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
    End Loop;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 5 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 5 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 6 And v_撤销方式 = '护理等级变动' Then
    --撤消护理等级变动
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 收费细目id = r_Curlogrow.护理等级id And
                          登记时间 >= r_Curlogrow.开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        Close c_Curlog;
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(r_Curlogrow.开始时间, 6);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原护理等级
    Update 病案主页 Set 护理等级id = r_Prelogrow.护理等级id Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 6 And 终止时间 Is Null;
  
    --医嘱产生的护理等级变动没有记录秒，可能前一等级的停止时间与当前等级的开始时间是同一分钟，所以要取max(id)
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 6 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 7 And v_撤销方式 = '经治医师改变' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
    --撤消经治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 7);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医师
    Update 病案主页 Set 住院医师 = r_Prelogrow.经治医师 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 7 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 7 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 8 And v_撤销方式 = '责任护士改变' Then
    --撤消责任护士改变
    Open c_Prelog(r_Curlogrow.开始时间, 8);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原责任护士
    Update 病案主页 Set 责任护士 = r_Prelogrow.责任护士 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 8 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 8 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 9 And v_撤销方式 = '转为住院病人' Then
    --撤消转为住院病人
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '入院', r_Curlogrow.科室id);
    Update 病案主页 Set 病人性质 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 9 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 9 And 终止时间 = r_Curlogrow.开始时间;
  
    If 主页id_In = 1 And Nvl(数据_In, '0') = '1' Then
      Update 病人信息 Set 住院号 = Null Where 病人id = 病人id_In;
      Update 病案主页 Set 住院号 = Null Where 病人id = 病人id_In;
    End If;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 10 And v_撤销方式 = '预出院' Then
    --撤消预出院
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '出院', r_Curlogrow.科室id);
    --恢复住院状态
    Update 病案主页 Set 状态 = 0 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 10 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 上次计算时间 = Null, 终止人员 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 11 And v_撤销方式 = '主治医师变动' Then
    --撤消主治医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 11);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 11 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 11 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 12 And v_撤销方式 = '主任医师变动' Then
    --撤消主任医师改变
    Open c_Prelog(r_Curlogrow.开始时间, 12);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原主任医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主任医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 12 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 12 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 13 And v_撤销方式 = '病况变动' Then
    --撤消病情改变
    Open c_Prelog(r_Curlogrow.开始时间, 13);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原病情
    Update 病案主页 Set 当前病况 = r_Prelogrow.病情 Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 13 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 13 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  
  Elsif r_Curlogrow.开始原因 = 14 And v_撤销方式 = '转医疗小组' Then
    --删除病历书写时机
    Zl_电子病历时机_Delete(病人id_In, 主页id_In, '交班', r_Curlogrow.科室id);
  
    --撤消医疗小组改变
    Open c_Prelog(r_Curlogrow.开始时间, 14);
    Fetch c_Prelog
      Into r_Prelogrow;
    --恢复原医疗小组
    Update 病案主页
    Set 医疗小组id = r_Prelogrow.医疗小组id, 住院医师 = r_Prelogrow.经治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In;
    --恢复原主治医师
    Update 病案主页从表
    Set 信息值 = r_Prelogrow.主治医师
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
    --恢复变动
    Delete From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 14 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 14 And 终止时间 = r_Curlogrow.开始时间;
  
    Close c_Prelog;
    Close c_Curlog;
  Elsif r_Curlogrow.开始原因 = 15 And v_撤销方式 = '转病区入住' Then
    --撤消入病区
    v_开始时间 := r_Curlogrow.开始时间;
  
    If 数据_In = '1' Then
      For r_Fee In (Select No
                    From 住院费用记录
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Mod(记录性质, 10) = 3 And 登记时间 >= v_开始时间
                    Group By No, 序号, Mod(记录性质, 10)
                    Having Sum(结帐金额) <> 0) Loop
        v_Error := '[ZLSOFT]该病人的自动记帐费用已结帐,不能进行撤销操作！[ZLSOFT]';
        Raise Err_Custom;
      End Loop;
    End If;
  
    Open c_Prelog(v_开始时间, 15);
    Fetch c_Prelog
      Into r_Prelogrow;
  
    --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
    Update 病人医嘱记录
    Set 执行科室id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Curlogrow.病区id And 医嘱状态 Not In (4, 8, 9) And 开嘱时间 < v_开始时间;
    --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
    Update 住院费用记录
    Set 执行部门id = r_Prelogrow.病区id
    Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Curlogrow.病区id And 记录状态 = 0;
    Close c_Prelog;
    Close c_Curlog;
  
    --退除当前床位
    For r_Curlogrow In c_Curlog Loop
      If r_Curlogrow.床号 Is Not Null Then
        Update 床位状况记录
        Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
        Where 病区id = r_Curlogrow.病区id And 床号 = r_Curlogrow.床号;
      End If;
    End Loop;
    --检查及还原原床位
    For r_Prelogrow In c_Prelog(v_开始时间, 15) Loop
      If r_Prelogrow.床号 Is Not Null Then
        Select Count(*)
        Into v_Count
        From 床位状况记录
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号 And 状态 = '空床';
        If v_Count = 0 Then
          v_Error := '[ZLSOFT]病人转入该病区前的床位 ' || r_Prelogrow.床号 || ' 当前非空床或已经撤消！[ZLSOFT]';
          Raise Err_Custom;
        End If;
      
        Update 床位状况记录
        Set 状态 = '占用', 病人id = 病人id_In, 等级id = r_Prelogrow.床位等级id, 科室id = r_Prelogrow.科室id --强行恢复以前的科室,共用床也不用处理了。
        Where 病区id = r_Prelogrow.病区id And 床号 = r_Prelogrow.床号;
      End If;
      --相关信息还原
      If Nvl(r_Prelogrow.附加床位, 0) = 0 Then
        Update 病案主页
        Set 状态 = 2, 当前病区id = r_Prelogrow.病区id, 出院科室id = r_Prelogrow.科室id, 医疗小组id = r_Prelogrow.医疗小组id,
            出院病床 = r_Prelogrow.床号, 护理等级id = r_Prelogrow.护理等级id, 责任护士 = r_Prelogrow.责任护士, 住院医师 = r_Prelogrow.经治医师,
            当前病况 = r_Curlogrow.病情
        Where 病人id = 病人id_In And 主页id = 主页id_In;
      
        Update 病人信息 Set 当前病区id = r_Prelogrow.病区id, 当前床号 = r_Prelogrow.床号 Where 病人id = 病人id_In;
      
        --更新在院病人
        Update 在院病人 Set 病区id = Nvl(r_Prelogrow.病区id, 0) Where 病人id = 病人id_In;
      
      End If;
    End Loop;
  
    --恢复变动(恢复到临时转科标记状态)
    Delete From 病人变动记录
    Where 附加床位 = 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Select 终止人员
    Into v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间 And Nvl(附加床位, 0) = 0;
    --临时记录的操作员信息记录的是终止人员,因为没有记录终止人员编号,就不恢复
    Update 病人变动记录
    Set 开始时间 = Null, 医疗小组id = Null, 护理等级id = Null, 床位等级id = Null, 床号 = Null, 责任护士 = Null, 经治医师 = Null, 操作员编号 = Null,
        操作员姓名 = v_终止人员, 上次计算时间 = Null, 附加床位 = Null, 主治医师 = Null, 病情 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 终止时间 Is Null;
  
    Update 病人变动记录
    Set 终止时间 = Null, 终止原因 = Null, 终止人员 = Null, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 15 And 终止时间 = v_开始时间;
  Else
    Close c_Curlog;
    v_Error := '[ZLSOFT]你执行的撤销' || v_撤销方式 || '操作已经被其他人执行,请刷新界面！[ZLSOFT]';
    Raise Err_Custom;
  End If;
  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, v_Error);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Undo;
/

--86399:刘尔旋,2015-07-17,取消执行时重复退料的问题
Create Or Replace Procedure Zl_病人费用记录_Unexecute
(
  No_In         住院费用记录.No%Type,
  记录性质_In   住院费用记录.记录性质%Type,
  序号_In       Varchar2,
  来源_In       Number := 2,
  仅更新费用_In Number := 0
) As
  --  来源_IN :1-门诊;2-住院 
  --  序号_In：费用行的行号，收入项目子行以父行为序号为准,为空表示单据所有行 
  --  仅更新费用_In:1表示:只更新病人费用记录.执行人,执行时间,结论;0-根据执行情况填写相关表

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_审核人 药品收发记录.审核人%Type;
  v_医嘱id 病人医嘱发送.医嘱id%Type;
  v_发送号 病人医嘱发送.发送号%Type;
  v_Temp   Varchar2(100);
  n_Count  Number(8);
  n_卫材   Number(18);
  n_药品   Number(18);
  Cursor c_Stuff_Mz Is
    Select a.Id
    From 药品收发记录 A, 门诊费用记录 B, 材料特性 C
    Where a.费用id = b.Id And a.药品id = c.材料id And Nvl(c.跟踪在用, 0) = 1 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0) And
          a.审核人 Is Not Null And b.No = No_In And b.记录性质 = 记录性质_In And instr( ',8,9,10,24,25,26,',','||a.单据||',')>0 And
          (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 = 1;

  Cursor c_Stuff_Zy Is
    Select a.Id
    From 药品收发记录 A, 住院费用记录 B, 材料特性 C
    Where a.费用id = b.Id And a.药品id = c.材料id And Nvl(c.跟踪在用, 0) = 1 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0) And
          a.审核人 Is Not Null And b.No = No_In And b.记录性质 = 记录性质_In And instr( ',8,9,10,24,25,26,',','||a.单据||',')>0 And
          (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 = 1;
Begin

  If Nvl(仅更新费用_In, 1) = 1 Then
    If 来源_In = 1 Then
      Update 门诊费用记录 A
      Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1);
    
    Else
      Update 住院费用记录 A
      Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
      Where a.No = No_In And a.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1);
    End If;
    Return;
  End If;

  Select Nvl(zl_GetSysParameter(33), '0') Into v_Temp From Dual;
  If v_Temp = '1' Then
    If 来源_In = 1 Then
      --执行之后卫材自动发料,取消执行时自动退料 
      For r_Stuff In c_Stuff_Mz Loop
        --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名 
        If v_审核人 Is Null Then
          v_审核人 := Zl_Username;
        End If;
        Zl_材料收发记录_部门退料(r_Stuff.Id, v_审核人, Sysdate, Null, Null, Null, Null, 0, v_审核人);
      End Loop;
    Else
      --执行之后卫材自动发料,取消执行时自动退料 
      For r_Stuff In c_Stuff_Zy Loop
        --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名 
        If v_审核人 Is Null Then
          v_审核人 := Zl_Username;
        End If;
        Zl_材料收发记录_部门退料(r_Stuff.Id, v_审核人, Sysdate, Null, Null, Null, Null, 0, v_审核人);
      End Loop;
    End If;
  End If;

  ---执行之后卫材自动发料,则不需要更新跟踪在用的卫材 
  If 来源_In = 1 Then
    Update 门诊费用记录 A
    Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  
  Else
    Update 住院费用记录 A
    Set a.执行人 = Null, a.执行时间 = Null, a.执行状态 = 0, a.结论 = Null
    Where a.No = No_In And a.记录性质 = 记录性质_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
          a.收费类别 Not In ('5', '6', '7') And Not Exists
     (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
  End If;
  --处理并发，若单据全部是药品或非跟踪在用状态下的卫材，程序里面已做禁止执行 
  --若单据中全部是跟踪在用卫材，且执行之后卫材自动发料，此时不抛出错误（药品已经在程序里禁止） 

  If Sql%NotFound Then
    If v_Temp = '1' Then
      If 来源_In = 1 Then
        Select Count(1)
        Into n_Count
        From 门诊费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              Nvl(a.执行状态, 0) <> 9 And a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      Else
        Select Count(1)
        Into n_Count
        From 住院费用记录 A
        Where a.No = No_In And a.记录性质 = 记录性质_In And
              (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And a.记录状态 In (0, 1) And
              a.收费类别 Not In ('5', '6', '7') And Not Exists
         (Select 1 From 材料特性 B Where a.收费细目id = b.材料id And a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);
      End If;
    
      If n_Count <> 0 Then
        v_Err_Msg := '未找到相关的费用数据,可能该单据正在进行收费,不能执行登记或与系统管理员联系!';
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '未找到相关的费用数据,可能该单据正在进行收费,不能执行登记或与系统管理员联系!';
      Raise Err_Item;
    End If;
  
  End If;

  If 来源_In = 1 Then
    Begin
      Select Max(a.医嘱id), Max(a.发送号)
      Into v_医嘱id, v_发送号
      From 病人医嘱发送 A, 门诊费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    Exception
      When Others Then
        Null;
    End;
  Else
    Begin
      Select Max(a.医嘱id), Max(a.发送号)
      Into v_医嘱id, v_发送号
      From 病人医嘱发送 A, 住院费用记录 B
      Where a.医嘱id = b.医嘱序号 And a.No = b.No And a.记录性质 = b.记录性质 And b.No = No_In And b.记录性质 = 记录性质_In And
            (Instr(',' || 序号_In || ',', ',' || Nvl(b.价格父号, b.序号) || ',') > 0 Or 序号_In Is Null) And b.记录状态 In (0, 1);
    Exception
      When Others Then
        Null;
    End;
  End If;

  If v_医嘱id Is Not Null And v_发送号 Is Not Null Then
    --处理医嘱的执行状态 
    --1.如果同一张医嘱发送单都取消执行完了,才更新执行状态为未执行 
    --2.如果同一医嘱发送单中存在卫材和药品被发料和发药的,则不允许取消执行登记
    If Not 序号_In Is Null Then
      If 来源_In = 1 Then
        Select Count(*), Sum(Decode(a.收费类别, '5', 1, '6', 1, '7', 1, 0)),
               Sum(Decode(a.收费类别, '4', Decode(Nvl(b.跟踪在用, 0), 1, 1, 0), 0))
        Into n_Count, n_药品, n_卫材
        From 门诊费用记录 A, 材料特性 B
        Where a.No = No_In And a.记录性质 = 记录性质_In And a.医嘱序号 = v_医嘱id And a.执行状态 In (1, 2) And a.记录状态 In (1, 3) And
              a.收费细目id = b.材料id(+);
      Else
        Select Count(*), Sum(Decode(a.收费类别, '5', 1, '6', 1, '7', 1, 0)),
               Sum(Decode(收费类别, '4', Decode(Nvl(b.跟踪在用, 0), 1, 1, 0), 0))
        Into n_Count, n_药品, n_卫材
        From 住院费用记录 A, 材料特性 B
        Where a.No = No_In And a.记录性质 = 记录性质_In And a.医嘱序号 = v_医嘱id And a.执行状态 In (1, 2) And a.记录状态 In (1, 3) And
              a.收费细目id = b.材料id(+);
      End If;
      If Nvl(n_药品, 0) <> 0 Then
        v_Err_Msg := '存在已经发药的药品,不能取消执行登记,请先退药!';
        Raise Err_Item;
      End If;
      If Nvl(n_卫材, 0) <> 0 Then
        v_Err_Msg := '存在已经发料的卫生材料,不能取消执行登记,请先退料!';
        Raise Err_Item;
      End If;
    Else
      n_Count := 0;
    End If;
  
    If n_Count = 0 Then
      Update 病人医嘱发送
      Set 执行状态 = 0, 完成人 = Null, 完成时间 = Null
      Where 发送号 = v_发送号 And 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 In (1, 3);
    Else
      Update 病人医嘱发送
      Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null
      Where 发送号 = v_发送号 And 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 记录性质_In And 执行状态 = 1;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用记录_Unexecute;
/

--86597:冉俊明,2015-07-16,医保项目的门诊费用记录保险信息保存不正确
Create Or Replace Procedure Zl_门诊划价记录_Update
(
  --功能：用于采用划价收费模式时,在收费界面输入划价单后,
  --        医保病人身份验证成功后,更新划价单中的病人身份信息,
  --        以及相关的保险项目、金额信息。
  险类_In   保险帐户.险类%Type,
  病人id_In 病人信息.病人id%Type,
  No_In     门诊费用记录.No%Type,
  病人_In   Number := 0 --是否只更新病人信息(用于医保病人信息更新)
) As
  --病人相关信息
  Cursor c_Patiinfo Is
    Select a.病人id, a.住院次数, a.门诊号, a.住院号, a.姓名, a.性别, a.年龄, a.当前病区id, a.当前科室id, a.医疗付款方式, Nvl(b.全额统筹, 0) As 全额统筹
    From 病人信息 A,
         (Select a.病人id, Nvl(b.全额统筹, 0) As 全额统筹
           From 保险帐户 A, 保险年龄段 B
           Where a.险类 = b.险类 And Nvl(a.中心, 0) = Nvl(b.中心, 0) And Nvl(a.在职, 0) = Nvl(b.在职, 0) And b.下限 <= Nvl(a.年龄段, 0) And
                 (a.年龄段 <= b.上限 Or b.上限 = 0) And a.病人id = 病人id_In And a.险类 = 险类_In) B
    Where a.病人id = b.病人id(+) And a.病人id = 病人id_In;
  r_Patiinfo c_Patiinfo%RowType;

  --划价单据原内容
  Cursor c_Bill Is
    Select ID, 收费细目id, 实收金额 From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In Order By 序号;

  v_保险项目否 门诊费用记录.保险项目否%Type;
  v_统筹金额   门诊费用记录.统筹金额%Type;
  v_保险大类id 门诊费用记录.保险大类id%Type;

  v_收费细目id   保险支付项目.收费细目id%Type;
  v_项目是否医保 保险支付项目.是否医保%Type;
  v_大类是否医保 保险支付大类.是否医保%Type;
  v_算法         保险支付大类.算法%Type;
  v_统筹比额     保险支付大类.统筹比额%Type;
  v_服务对象     保险支付大类.服务对象%Type;
  v_医疗付款方式 门诊费用记录.付款方式%Type;
  v_Dec          Number;
Begin
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;

  Open c_Patiinfo;
  Fetch c_Patiinfo
    Into r_Patiinfo;
  If c_Patiinfo%RowCount > 0 Then
    If Nvl(病人_In, 0) = 0 Then
      For r_Bill In c_Bill Loop
        --计算保险字段
        Begin
          Select a.收费细目id, a.大类id, Nvl(a.是否医保, 0), Nvl(b.是否医保, 0), Nvl(b.算法, 0), Nvl(b.统筹比额, 0), Nvl(b.服务对象, 3)
          Into v_收费细目id, v_保险大类id, v_项目是否医保, v_大类是否医保, v_算法, v_统筹比额, v_服务对象
          From 保险支付项目 A, 保险支付大类 B
          Where a.大类id = b.Id(+) And b.险类(+) = 险类_In And a.险类 = 险类_In And a.收费细目id = r_Bill.收费细目id;
        Exception
          When Others Then
            v_收费细目id := Null;
            Null;
        End;
      
        If v_收费细目id Is Not Null Then
          v_保险项目否 := 1;
          If v_保险大类id Is Not Null Then
            If v_保险项目否 = 1 And v_大类是否医保 = 1 Then
              v_保险项目否 := 1;
            Else
              v_保险项目否 := 0;
            End If;
            If v_算法 = 1 Then
              v_统筹金额 := Round(r_Bill.实收金额 * v_统筹比额 / 100, v_Dec);
              If v_保险项目否 = 1 And v_统筹比额 > 0 Then
                v_保险项目否 := 1;
              Else
                v_保险项目否 := 0;
              End If;
            End If;
          
            --如果服务对象不对，也认为它不是医保项目
            If v_保险项目否 = 1 And v_服务对象 <> 1 And v_服务对象 <> 3 Then
              v_保险项目否 := 0;
            End If;
          End If;
        
          If v_保险项目否 = 1 And v_项目是否医保 = 1 Then
            v_保险项目否 := 1;
          Else
            v_保险项目否 := 0;
          End If;
        
          --全额统筹病人
          --                IF r_PatiInfo.全额统筹=1 And v_保险项目否=1 Then
          --                    v_统筹金额:=r_Bill.实收金额;
          --                End IF;
        Else
          v_保险项目否 := 0;
          v_保险大类id := Null;
          v_统筹金额   := 0;
        End If;
      
        --更新费用记录
        Update 门诊费用记录
        Set 保险项目否 = Nvl(v_保险项目否, 0), 保险大类id = Decode(保险大类id, Null, v_保险大类id, 保险大类id), 统筹金额 = Nvl(v_统筹金额, 0)
        Where ID = r_Bill.Id;
      End Loop;
    Else
      --更新费用记录:因为未产生对应的汇总费用,所以可以更新科室等字段
      Begin
        Select 编码 Into v_医疗付款方式 From 医疗付款方式 Where 名称 = r_Patiinfo.医疗付款方式;
      Exception
        When Others Then
          v_医疗付款方式 := Null;
      End;
      Update 门诊费用记录
      Set 姓名 = r_Patiinfo.姓名, 性别 = r_Patiinfo.性别, 年龄 = r_Patiinfo.年龄, 病人id = r_Patiinfo.病人id,
          标识号 = Decode(门诊标志, 2, r_Patiinfo.住院号, r_Patiinfo.门诊号), 付款方式 = Decode(门诊标志, 2, Nvl(v_医疗付款方式, 付款方式), 付款方式),
          病人科室id = Decode(门诊标志, 2, r_Patiinfo.当前科室id, 病人科室id)
      Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In;
    End If;
  End If;
  Close c_Patiinfo;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Update;
/

--86505:张险华,2015-07-15,门诊病人按病人查阅报错
Create Or Replace Procedure Zl_电子病历时机_Makeup
(
  病人id_In   In 电子病历时机.病人id%Type,
  主页id_In   In 电子病历时机.主页id%Type,
  病人来源_In In Number
) Is
  -------只有门诊和住院 分别是1 和 2
  -------电子病历时机改造前已在院的病人，在对应的HIS事件发生后不生成电子病历时机记录
  -------本过程主要目的是用于在需要时补充对应病人的相应记录，只适用于住院病人
  n_Count      Number;
  d_入院时间   Date;
  d_出院时间   Date;
  d_假出时间   Date;
  d_开始时间   Date;
  d_到期时间   Date;
  n_完成记录id Number;
  d_完成时间   Date;
  n_周期号     Number;
  v_责任人     Varchar2(64);
  n_Is_Again   Number;
  n_Out_24h    Number;
  n_Cur_Dept   Number;
  v_Cur_Nurse  Varchar2(64);
  Cursor c_Writed
  (
    n_Fileid Number,
    n_科室id Number
  ) Is
  --查找已经书写过的病历，并且不能是已经在电子病历时机中使用过的病历,当存在多条记录时以时间靠前记录为准,用于填写事件要求的病历完成时间
    Select a.Id, a.完成时间
    From 电子病历记录 A
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.科室id = n_科室id And
          (a.文件id = n_Fileid Or a.文件id In (Select 替代id From 病历替代关系 Where 文件id = n_Fileid)) And
          a.Id Not In
          (Select b.完成记录id
           From 电子病历时机 B
           Where b.病人id = a.病人id And b.主页id = a.主页id And b.文件id = a.文件id And b.科室id = a.科室id And Nvl(b.完成记录id, 0) <> 0) And
          Rownum < 2
    Order By a.完成时间;
  r_Writed c_Writed%RowType;

  --住院病人入院时间:存在留观转住院时，从该事件发生时间开始
  Function Zl_From_Time Return Date Is
    d_Return Date;
  Begin
    --提取入科时间，住院留观转住院时生成开始原因=9的记录
    --办理入院时直接入院按当时间时间算,含家庭病床
    --病区安床按入科时间
    Select Max(a.开始时间)
    Into d_Return
    From 病人变动记录 A, 病案主页 B
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.开始原因 In (1, 2, 9) And Nvl(a.附加床位, 0) = 0 And a.病人id = b.病人id And
          a.主页id = b.主页id And b.状态 <> 1;
    Return d_Return;
  End Zl_From_Time;

  --住院病人出院时间:存在预出院时，以预出院时间为结束时间
  Function Zl_To_Time(d_Tmp Date) Return Date Is
    d_Return Date;
  Begin
    Select Min(终止时间) A
    Into d_Return
    From 病人变动记录 R
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 10;
    If d_Return Is Null Then
      Select Nvl(Min(终止时间), d_Tmp)
      Into d_Return
      From 病人变动记录 R
      Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 = 1;
    End If;
    Return d_Return;
  End Zl_To_Time;
Begin
  Select Count(ID) Into n_Count From 电子病历时机 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_Count > 0 Then
    --已经有记录，表明不是升级前就在院的病人或已经通过本过程生成过数据，不适用于本过程处理。
    Return;
  End If;

  If 病人来源_In = 1 Then
    --门诊病历监测：
    For r_Out In (Select r.变动事件, r.事件时间, r.科室id, r.书写人, l.Id As 文件id, l.编号, l.名称, r.完成时间
                  From (Select l.Id, l.编号, l.名称, l.通用, a.科室id, q.事件
                         From 病历文件列表 L, 病历应用科室 A, 病历时限要求 Q
                         Where l.Id = a.文件id(+) And l.Id = q.文件id And l.种类 = 1 And q.必须 = 1) L,
                       (Select Decode(r.急诊, 1, '急诊', Decode(复诊, 1, '复诊', '门诊')) As 变动事件, Nvl(r.执行时间, Sysdate) As 事件时间,
                                r.执行部门id As 科室id, r.执行人 As 书写人, Nvl(r.完成时间, 执行时间) 完成时间
                         From 病人挂号记录 R
                         Where r.病人id + 0 = 病人id_In And r.Id = 主页id_In And r.记录性质 = 1 And r.记录状态 = 1) R
                  Where r.变动事件 = l.事件 And (l.通用 = 1 Or l.通用 = 2 And l.科室id = r.科室id)) Loop
      Open c_Writed(r_Out.文件id, r_Out.科室id);
      Fetch c_Writed
        Into r_Writed;
      If c_Writed%RowCount <> 0 Then
        n_完成记录id := r_Writed.Id;
        d_完成时间   := r_Writed.完成时间;
      Else
        n_完成记录id := Null;
        d_完成时间   := Null;
      End If;
      Close c_Writed;
    
      Insert Into 电子病历时机
        (ID, 病人id, 主页id, 病人来源, 科室id, 责任人, 文件id, 病历种类, 病历编号, 病历名称, 事件, 必须, 唯一, 事件时间, 开始时间, 到期时间, 完成记录id, 完成时间)
      Values
        (电子病历时机_Id.Nextval, 病人id_In, 主页id_In, 1, r_Out.科室id, r_Out.书写人, r_Out.文件id, 1, r_Out.编号, r_Out.名称, r_Out.变动事件,
         1, 1, r_Out.事件时间, r_Out.事件时间, r_Out.完成时间, n_完成记录id, d_完成时间);
    End Loop;
  Else
    d_假出时间 := Sysdate + 10; --表示未出院,给定一个假出院时间
    d_入院时间 := Zl_From_Time;
    If d_入院时间 Is Null Then
      --尚未入科
      Return;
    End If;
    d_出院时间 := Zl_To_Time(d_假出时间);
    If d_出院时间 - d_入院时间 < 1 Then
      n_Out_24h := 1;
    Else
      n_Out_24h := 0;
    End If;
  
    Select 入院科室id, Nvl(再入院, 0), 责任护士
    Into n_Cur_Dept, n_Is_Again, v_Cur_Nurse
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  
    For r_Event In (Select r.变动事件, r.事件时间, r.事后, r.科室id, r.书写人, r.责任护士, l.Id As 文件id, l.种类, l.编号, l.名称, l.唯一,
                           Nvl(l.书写时限, 0) As 书写时限,
                           Nvl(Decode(r.病情, '一般', Decode(l.一般周期, 0, 72, l.一般周期), '危', Decode(l.病危周期, 0, 24, l.病危周期),
                                       Decode(l.病重周期, 0, 48, l.病重周期)), 0) As 周期, l.一般周期, l.病重周期, l.病危周期
                    From (Select l.Id, l.种类, l.编号, l.名称, l.通用, a.科室id, q.事件, q.唯一, q.书写时限, q.一般周期, q.病危周期, q.病重周期
                           From 病历文件列表 L, 病历应用科室 A, 病历时限要求 Q
                           Where l.Id = a.文件id(+) And l.Id = q.文件id And l.种类 In (2, 4) And q.必须 = 1 And l.通用 <> 0) L,
                         (Select Decode(n_Is_Again, 0, '入院', '再次入院') As 变动事件, 1 As 事后, Max(开始时间) As 事件时间, Max(病情) As 病情,
                                  Max(科室id) As 科室id, Max(经治医师) As 书写人, Max(责任护士) As 责任护士
                           From 病人变动记录
                           Where n_Out_24h <> 1 And 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 In (1, 9)
                           
                           Union All
                           Select Decode(开始原因, 3, '转科', 7, '交班') As 变动事件, 1 As 事后, 开始时间 As 事件时间, 病情, 科室id, 经治医师 As 书写人,
                                  责任护士
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 In (3, 7)
                           
                           Union All
                           Select Decode(终止原因, 3, '转科', 7, '交班', Decode(n_Out_24h, 1, '24小时出院', '出院')) As 变动事件,
                                  Decode(终止原因, 3, 0, 7, 0, 1) As 事后, 终止时间 As 事件时间, 病情, 科室id, 经治医师 As 书写人, 责任护士
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 终止原因 In (3, 7, 1, 10) And 终止时间 <= d_出院时间
                           Union All
                           Select Decode(r.诊疗类别, 'F', '手术', Decode(i.操作类型, '7', '会诊', '8', '抢救')) As 变动事件, 0 As 事后,
                                  r.开始执行时间 As 事件时间, '一般' As 病情, r.开嘱科室id As 科室id, r.开嘱医生 As 书写人, v_Cur_Nurse As 责任护士
                           From 病人医嘱记录 R, 诊疗项目目录 I
                           Where r.病人id = 病人id_In And r.主页id = 主页id_In And r.诊疗项目id = i.Id And
                                 (r.诊疗类别 = 'F' Or i.操作类型 In ('7', '8')) And r.相关id Is Null And
                                 (r.医嘱期效 = 0 And r.医嘱状态 >= 3 And r.医嘱状态 <> 4 Or r.医嘱期效 = 1 And r.医嘱状态 In (8, 9))
                           
                           Union All
                           Select Decode(r.诊疗类别, '7', '手术',
                                          Decode(i.操作类型, '7', '会诊', '8', '抢救', Decode(n_Out_24h, 1, '24小时死亡', '死亡'))) As 变动事件,
                                  1 As 事后, Decode(m.执行时间, Null, Decode(k.完成时间, Null, r.开始执行时间, k.完成时间), m.执行时间) As 事件时间,
                                  '一般' As 病情, r.执行科室id, Decode(m.执行人, Null, Decode(k.完成人, Null, '', k.完成人), m.执行人) As 书写人,
                                  v_Cur_Nurse As 责任护士
                           From 病人医嘱记录 R, 诊疗项目目录 I, 病人医嘱发送 K, 病人医嘱执行 M
                           Where r.病人id = 病人id_In And r.主页id = 主页id_In And r.诊疗项目id = i.Id And
                                 (r.诊疗类别 = 'F' Or i.操作类型 In ('7', '8', '11')) And r.相关id Is Null And
                                 (r.医嘱期效 = 0 And r.医嘱状态 >= 3 And r.医嘱状态 <> 4 Or r.医嘱期效 = 1 And r.医嘱状态 In (8, 9)) And
                                 r.Id = k.医嘱id(+) And r.Id = m.医嘱id(+)) R
                    Where r.变动事件 = l.事件 And
                          (l.唯一 = 0 And r.事后 = 1 Or l.唯一 = 1 And (r.事后 = 0 And l.书写时限 < 0 Or r.事后 = 1 And l.书写时限 >= 0)) And
                          (l.通用 = 1 Or l.通用 = 2 And l.科室id = r.科室id)
                    Order By r.事件时间, l.编号, r.事后) Loop
    
      If n_Cur_Dept <> r_Event.科室id Then
        Delete 电子病历时机
        Where 病人id = 病人id_In And 主页id = 主页id_In And 科室id = n_Cur_Dept And 唯一 = 0 And 开始时间 > r_Event.事件时间;
        n_Cur_Dept := r_Event.科室id;
      End If;
    
      If r_Event.唯一 = 1 Then
        --书写一次
        Open c_Writed(r_Event.文件id, r_Event.科室id);
        Fetch c_Writed
          Into r_Writed;
        If c_Writed%RowCount <> 0 Then
          n_完成记录id := r_Writed.Id;
          d_完成时间   := r_Writed.完成时间;
        Else
          n_完成记录id := Null;
          d_完成时间   := Null;
        End If;
        Close c_Writed;
        If r_Event.种类 = 2 Then
          v_责任人 := r_Event.书写人;
        Else
          v_责任人 := r_Event.责任护士;
        End If;
        d_开始时间 := r_Event.事件时间;
        n_周期号   := 1;
        If r_Event.事后 = 1 Then
          --事后书写
          d_到期时间 := d_开始时间 + r_Event.书写时限 / 24;
        Else
          --事前书写
          d_到期时间 := d_开始时间;
        End If;
        Insert Into 电子病历时机
          (ID, 病人id, 主页id, 病人来源, 科室id, 责任人, 文件id, 病历种类, 病历编号, 病历名称, 事件, 必须, 唯一, 事件时间, 开始时间, 到期时间, 一般周期, 病重周期, 病危周期, 周期号,
           完成记录id, 完成时间)
        Values
          (电子病历时机_Id.Nextval, 病人id_In, 主页id_In, 2, r_Event.科室id, v_责任人, r_Event.文件id, r_Event.种类, r_Event.编号,
           r_Event.名称, r_Event.变动事件, 1, r_Event.唯一, r_Event.事件时间, d_开始时间, d_到期时间, r_Event.一般周期, r_Event.病重周期,
           r_Event.病危周期, n_周期号, n_完成记录id, d_完成时间);
      Else
        d_开始时间 := r_Event.事件时间;
        d_到期时间 := d_开始时间 + r_Event.周期 / 24;
        n_周期号   := 1;
        If r_Event.种类 = 2 Then
          v_责任人 := r_Event.书写人;
        Else
          v_责任人 := r_Event.责任护士;
        End If;
      
        While d_开始时间 <= d_出院时间 Loop
          Open c_Writed(r_Event.文件id, r_Event.科室id);
          Fetch c_Writed
            Into r_Writed;
          If c_Writed%RowCount <> 0 Then
            n_完成记录id := r_Writed.Id;
            d_完成时间   := r_Writed.完成时间;
          Else
            n_完成记录id := Null;
            d_完成时间   := Null;
          End If;
          Close c_Writed;
        
          Insert Into 电子病历时机
            (ID, 病人id, 主页id, 病人来源, 科室id, 责任人, 文件id, 病历种类, 病历编号, 病历名称, 事件, 必须, 唯一, 事件时间, 开始时间, 到期时间, 一般周期, 病重周期, 病危周期,
             周期号, 完成记录id, 完成时间)
          Values
            (电子病历时机_Id.Nextval, 病人id_In, 主页id_In, 2, r_Event.科室id, v_责任人, r_Event.文件id, r_Event.种类, r_Event.编号,
             r_Event.名称, r_Event.变动事件, 1, 0, r_Event.事件时间, d_开始时间, d_到期时间, r_Event.一般周期, r_Event.病重周期, r_Event.病危周期,
             n_周期号, n_完成记录id, d_完成时间);
        
          d_开始时间 := d_到期时间;
          d_到期时间 := d_开始时间 + r_Event.周期 / 24;
          n_周期号   := n_周期号 + 1;
        End Loop;
      End If;
    End Loop;
  End If;

  For r_Must In (Select '诊断:' || a.诊断描述 As 变动事件, a.记录日期 As 事件时间, 1 As 事后, d.科室id, e.住院医师 As 书写人, c.Id As 文件id, c.编号, c.名称,
                        5 As 种类
                 From 病人诊断记录 A, 疾病报告前提 B, 病历文件列表 C, 病历应用科室 D, 病案主页 E
                 Where a.病人id = 病人id_In And a.主页id = 主页id_In And (a.疾病id = b.疾病id Or a.诊断id = b.诊断id) And c.Id = b.文件id And
                       c.种类 = 5 And (c.通用 = 1 Or c.通用 = 2 And e.出院科室id = d.科室id) And c.Id = d.文件id(+) And
                       a.病人id = e.病人id And a.主页id = e.主页id
                 Union All
                 Select '医嘱:' || m.医嘱内容 As 变动事件, m.开始执行时间 As 事件时间, 0 As 前后, m.病人科室id As 科室id, m.开嘱医生 As 书写人, f.Id As 文件id,
                        f.编号, f.名称, 6 As 种类
                 From 病人医嘱记录 M, 病历单据应用 A,
                      (Select f.Id, f.编号, f.名称, f.通用, a.科室id
                        From 病历文件列表 F, 病历应用科室 A
                        Where f.通用 <> 0 And f.种类 = 6 And f.Id = a.文件id(+)) F
                 Where m.诊疗项目id = a.诊疗项目id And a.病历文件id = f.Id And m.病人id = 病人id_In And m.主页id = 主页id_In And
                       (f.通用 = 1 Or f.通用 = 2 And f.科室id = m.病人科室id) And
                       (m.医嘱期效 = 0 And m.医嘱状态 >= 3 And m.医嘱状态 <> 4 Or m.医嘱期效 = 1 And m.医嘱状态 In (8, 9))) Loop
    Open c_Writed(r_Must.文件id, r_Must.科室id);
    Fetch c_Writed
      Into r_Writed;
    If c_Writed%RowCount <> 0 Then
      n_完成记录id := r_Writed.Id;
      d_完成时间   := r_Writed.完成时间;
    Else
      n_完成记录id := Null;
      d_完成时间   := Null;
    End If;
    Close c_Writed;
  
    Insert Into 电子病历时机
      (ID, 病人id, 主页id, 病人来源, 科室id, 责任人, 文件id, 病历种类, 病历编号, 病历名称, 事件, 必须, 唯一, 事件时间, 开始时间, 到期时间, 周期号, 完成记录id, 完成时间)
    Values
      (电子病历时机_Id.Nextval, 病人id_In, 主页id_In, 病人来源_In, r_Must.科室id, r_Must.书写人, r_Must.文件id, r_Must.种类, r_Must.编号,
       r_Must.名称, r_Must.变动事件, 0, 1, r_Must.事件时间, r_Must.事件时间, r_Must.事件时间, 1, n_完成记录id, d_完成时间);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_电子病历时机_Makeup;
/
--84278:张险华,2015-04-23,护理等级提取错误
CREATE OR REPLACE Function Zl_Replace_Element_Value
(
  元素名_In   In 诊治所见项目.中文名%Type,
  病人id_In   In 电子病历记录.病人id%Type,
  就诊id_In   In 电子病历记录.主页id%Type,
  病人来源_In In 电子病历记录.病人来源%Type,
  医嘱id_In   In 病人医嘱记录.Id%Type := Null,
  婴儿_In     In Number := 0,
  时间_In     In Date := Null
) Return Varchar2 Is
  v_Return Varchar2(4000) := Null;

  Cursor c_Pati Is
    Select 姓名, 性别, 年龄, 职业, 民族, 国籍, 婚姻状况, 出生日期, 出生地点, 身份证号, 身份, 学历, 家庭地址, 家庭电话, 工作单位, 单位电话, 门诊号, 住院次数, 联系人姓名, 联系人关系,
           联系人地址, 联系人电话
    From 病人信息
    Where 病人id = 病人id_In;
  r_Patient c_Pati%RowType;

  Cursor c_Reg Is
    Select 摘要, 登记时间, 急诊, 执行部门id From 病人挂号记录 Where 病人id + 0 = 病人id_In And ID = 就诊id_In;
  r_Regist c_Reg%RowType;

  Cursor c_Inpage Is
    Select Nvl(b.姓名, a.姓名) 姓名, Nvl(b.性别, a.性别) 性别, Nvl(b.年龄, a.年龄) 年龄, b.住院号, b.入院日期, b.出院日期, b.住院目的, b.入院科室id, b.入院病区id,
           b.出院病床, b.当前病区id, b.当前病况, b.住院医师, b.责任护士, b.二级院转入, b.入院方式, b.护理等级id, b.出院方式, b.入院病床, b.联系人姓名, b.联系人关系,
           b.联系人地址, b.联系人电话, b.出院科室id
    From 病人信息 A, 病案主页 B
    Where a.病人id = b.病人id And b.病人id = 病人id_In And b.主页id = 就诊id_In;
  r_Inpage c_Inpage%RowType;

  Cursor c_Order Is
    Select 婴儿, 紧急标志, 开嘱科室id, 开嘱医生, 开嘱时间, 执行科室id, 开始执行时间, 医生嘱托, 诊疗类别, 诊疗项目id, 标本部位, 检查方法



    From 病人医嘱记录
    Where 病人id + 0 = 病人id_In And ID = 医嘱id_In;
  r_Order c_Order%RowType;

  Cursor c_Signs Is
    Select b.项目名称, b.记录内容
    From 病人护理记录 A, 病人护理内容 B
    Where a.病人id = 病人id_In And a.主页id = 就诊id_In And a.病人来源 = 病人来源_In And a.Id = b.记录id And b.记录类型 = 1 And
          b.项目名称 = 元素名_In;
  r_Signs c_Signs%RowType;

  v_Subtype 诊疗项目目录.操作类型%Type := Null;

  Type t_Str_Table Is Table Of Varchar2(2000);
  a_Return t_Str_Table := t_Str_Table();

  n_主页id 病案主页.主页id%Type;
  n_Times  Number;
  n_Have   Number(3);
  v_Sql    Varchar2(2000);

  --获取指定表的行类型
  Procedure p_Get_Rowtype(Table_In In Varchar2) Is
  Begin
    If Table_In = '病人信息' Then
      Open c_Pati;
      Fetch c_Pati
        Into r_Patient;
    Elsif Table_In = '病人挂号记录' Then
      Open c_Reg;
      Fetch c_Reg
        Into r_Regist;
    Elsif Table_In = '病案主页' Then
      Open c_Inpage;
      Fetch c_Inpage
        Into r_Inpage;
    Elsif Table_In = '病人医嘱记录' Then
      Open c_Order;
      Fetch c_Order
        Into r_Order;
    Elsif Table_In = '病人护理内容' Then
      Open c_Signs;
      Fetch c_Signs
        Into r_Signs;
    End If;
  Exception
    When Others Then
      Null;
  End p_Get_Rowtype;

  --从电子病历内容获取指定预制提纲的最新内容
  Function f_Latest_Epr_Content(提纲标题_In In 病历文件结构.内容文本%Type) Return Varchar2 Is
    v_Content Varchar2(32767);
    n_预制id  病历文件结构.Id%Type;
  Begin
    Select ID Into n_预制id From 病历文件结构 Where 内容文本 = 提纲标题_In And 文件id Is Null;
    Select c.内容文本 || Decode(c.要素类型, 0, c.要素单位) Bulk Collect
    Into a_Return
    From 电子病历内容 C,
         (Select ID
           From (Select r.Id 记录id, c.Id
                  From 电子病历记录 R, 电子病历内容 C
                  Where r.Id = c.文件id And r.病人id = 病人id_In And c.预制提纲id + 0 = n_预制id
                  Order By r.创建时间 Desc)
           Where Rownum = 1) P
    Where c.父id = p.Id And (c.对象类型 = 2 Or c.对象类型 = 4)
    Order By c.对象序号, c.内容行次;
    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      v_Content := v_Content || a_Return(n_Count);
    End Loop;
    v_Content := Replace(v_Content, ' ', '');
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Epr_Content;

  --从病人医嘱附件获取指定要素的最新内容，实际只有“病历摘要”需要
  Function f_Latest_Advice_Annex Return Varchar2 Is
    v_Content Varchar2(32767);
    n_要素id  病人医嘱附件.要素id%Type;
    v_挂号单  病人医嘱记录.挂号单%Type;
  Begin
    Select ID Into n_要素id From 诊治所见项目 Where 中文名 = 元素名_In;
    If 病人来源_In = 1 Then
      Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
    End If;
    Select 内容
    Into v_Content
    From (Select l.Id, a.内容, l.开嘱时间
           From 病人医嘱记录 L, 病人医嘱附件 A
           Where l.Id = a.医嘱id And l.病人id = 病人id_In And a.要素id = n_要素id
           Order By l.开嘱时间 Desc)
    Where Rownum = 1;
    Return v_Content;
  Exception
    When Others Then
      Return Null;
  End f_Latest_Advice_Annex;

  --获得病人指定就诊次数的最新诊断
  Function f_Latest_Diagnose
  (
    主页id_In In 病人诊断记录.主页id%Type,
    时间_In   In Date := Null
  ) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    If 时间_In Is Null Then
      --如果已经整理首页或病案中的诊断，则以这些诊断为最后诊断返回
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
             From 病人诊断记录
             Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And 诊断类型 In (1, 11, 2, 12, 3, 13)) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;

      --否则，获取最后书写的病历中诊断作为最后诊断(隐含包括，如果还没有写病历，则以入院时填写的诊断为最后诊断)：
      Select d.诊断描述 || Decode(Nvl(d.是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select 病历id
             From (Select Distinct a.病历id, b.创建时间
                    From 病人诊断记录 A, 电子病历记录 B
                    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊断类型 In (1, 11, 2, 12, 3, 13) And Nvl(a.病历id, 0) <> 0 And
                          a.病历id = b.Id
                    Order By b.创建时间 Desc)
             Where Rownum = 1) M
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.诊断类型 In (1, 11, 2, 12, 3, 13) And d.病历id = m.病历id
      Order By d.诊断次序;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      Return Trim(v_Content);
    Else
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
      Into a_Return
      From 病人诊断记录 D,
           (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
             From 病人诊断记录
             Where 病人id = 病人id_In And 主页id = 主页id_In And 记录日期 < 时间_In And 诊断类型 In (1, 11, 2, 12, 3, 13)) F
      Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
      Order By d.诊断次序;
      v_Content := Null;
      For n_Count In 1 .. a_Return.Count Loop
        If a_Return.Count > 1 Then
          v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
        Else
          v_Content := v_Content || a_Return(n_Count);
        End If;
      End Loop;
      If v_Content Is Not Null Then
        Return Trim(v_Content);
      End If;
    End If;

  Exception
    When Others Then
      Return Null;
  End f_Latest_Diagnose;

  --获取病人最新疾病ID和诊断ID
  Function f_Last_Diagnoseid(主页id_In In 病人诊断记录.主页id%Type) Return Varchar2 Is
    v_Returndiagnose Varchar2(500);
  Begin
    For r_Diagnose In (Select 疾病id, 诊断id
                       From 病人诊断记录 D,
                            (Select Max(记录来源) As 记录来源, Max(Mod(诊断类型, 10)) As 诊断类型
                              From 病人诊断记录
                              Where 病人id = 病人id_In And 主页id = 主页id_In And 病历id Is Null And 记录来源 > 1 And
                                    诊断类型 In (1, 11, 2, 12, 3, 13)) F
                       Where d.病人id = 病人id_In And d.主页id = 主页id_In And d.记录来源 = f.记录来源 And Mod(d.诊断类型, 10) = f.诊断类型
                       Order By d.诊断次序) Loop
      v_Returndiagnose := r_Diagnose.疾病id || '|' || r_Diagnose.诊断id;
      Return v_Returndiagnose;
    End Loop;
    --没取到则返回
    v_Returndiagnose := '|';
    Return v_Returndiagnose;
  Exception
    When Others Then
      Return Null;
  End f_Last_Diagnoseid;

  --获得病人指定住院诊断
  Function f_Diagnose(Inttype_In In Number) Return Varchar2 Is
    v_Content Varchar2(32767);
  Begin
    --intType_IN:1-西医门诊诊断;2-中医门诊诊断;3-西医入院诊断;4-中医入院诊断;
    --       5,所有西医出院诊断;6,只取西医出院主要诊断(诊断次序)=1;7,只取西医出院其他诊断(诊断次序)>1;8-中医出院诊断
    Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') Bulk Collect
    Into a_Return
    From 病人诊断记录 D,
         (Select Max(记录来源) As 记录来源, Max(诊断类型) As 诊断类型
           From 病人诊断记录
           Where 病人id = 病人id_In And 主页id = 就诊id_In And 病历id Is Null And 记录来源 > 1 And
                 诊断类型 = Decode(Inttype_In, 1, 1, 2, 11, 3, 2, 4, 12, 8, 13, 3)) F
    Where d.病人id = 病人id_In And d.主页id = 就诊id_In And d.记录来源 = f.记录来源 And d.诊断类型 = f.诊断类型 And
          d.诊断次序 > Decode(Inttype_In, 7, 1, 0) And Rownum < Decode(Inttype_In, 6, 2, 10)
    Order By d.诊断次序;

    v_Content := Null;
    For n_Count In 1 .. a_Return.Count Loop
      If a_Return.Count > 1 Then
        v_Content := v_Content || '  ' || n_Count || '、' || a_Return(n_Count);
      Else
        v_Content := v_Content || a_Return(n_Count);
      End If;
    End Loop;
    If v_Content Is Not Null Then
      Return Trim(v_Content);
    End If;

  Exception
    When Others Then
      Return Null;
  End f_Diagnose;

  --获取病人本次就诊的医嘱内容
  Function f_Get_Advice_Text Return Varchar2 Is
    v_Text   Varchar2(4000);
    v_挂号单 病人挂号记录.No%Type;
  Begin
    If 病人来源_In = 1 Then
      Begin
        Select NO Into v_挂号单 From 病人挂号记录 Where ID = 就诊id_In;
      Exception
        When Others Then
          Return Null;
      End;
    End If;

    --提取病人医嘱：界面可见行医嘱内容，不含作废的
    For r_Row In (Select a.医嘱内容
                  From 病人医嘱记录 A, 诊疗项目目录 B
                  Where a.诊疗项目id = b.Id And a.开始执行时间 Is Not Null And a.医嘱状态 <> 4 And Nvl(a.婴儿, 0) = 0 And
                        Not (a.诊疗类别 In ('F', 'G', 'D', 'C', 'E') And a.相关id Is Not Null) And a.诊疗类别 <> '7' And
                        Not (a.诊疗类别 = 'E' And b.操作类型 In ('2', '4')) And a.病人来源 = 病人来源_In And a.病人id = 病人id_In And
                        (病人来源_In = 1 And a.挂号单 = v_挂号单 Or a.主页id = 就诊id_In)
                  Order By a.序号) Loop
      If Lengthb(v_Text || r_Row.医嘱内容) <= 4000 Then
        v_Text := v_Text || Chr(13) || Chr(10) || r_Row.医嘱内容;
      Else
        Exit;
      End If;
    End Loop;

    Return Substr(v_Text, 3);
  End f_Get_Advice_Text;
Begin
  Case
    When Instr('体温,呼吸,脉搏,收缩压,舒张压', 元素名_In) > 0 And 病人来源_In = 1 Then
      p_Get_Rowtype('病人护理内容');
      v_Return := r_Signs.记录内容;
    When Instr(',当前日期,当前时间,DQSJ', ',' || Upper(元素名_In)) > 0 Then
      --无需读取任何表数据的元素
      Case Upper(元素名_In)
        When '当前日期' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '当前时间' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        When 'DQSJ' Then
          v_Return := To_Char(Sysdate, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      End Case;
    When Instr(',职业,民族,国籍,婚姻状况,出生日期,出生地点,身份证号,身份,学历,家庭地址,家庭电话,工作单位,单位电话,门诊号,住院次数', ',' || 元素名_In) > 0 Then
      --只查病人信息表的元素
      p_Get_Rowtype('病人信息');
      Case 元素名_In
        When '职业' Then
          v_Return := r_Patient.职业;
        When '民族' Then
          v_Return := r_Patient.民族;
        When '国籍' Then
          v_Return := r_Patient.国籍;
        When '婚姻状况' Then
          v_Return := r_Patient.婚姻状况;
        When '出生日期' Then
          v_Return := To_Char(r_Patient.出生日期, 'yyyy-mm-dd');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日';
        When '出生地点' Then
          v_Return := r_Patient.出生地点;
        When '身份证号' Then
          v_Return := r_Patient.身份证号;
        When '身份' Then
          v_Return := r_Patient.身份;
        When '学历' Then
          v_Return := r_Patient.学历;
        When '家庭地址' Then
          v_Return := r_Patient.家庭地址;
        When '家庭电话' Then
          v_Return := r_Patient.家庭电话;
        When '工作单位' Then
          v_Return := r_Patient.工作单位;
        When '单位电话' Then
          v_Return := r_Patient.单位电话;
        When '门诊号' Then
          v_Return := r_Patient.门诊号;
        When '住院次数' Then
          v_Return := Nvl(r_Patient.住院次数, 0);
        Else
          v_Return := '';
      End Case;
    When Instr(',住院号,入院日期,出院日期,住院目的,入院科室,入院病区,当前床号,当前病区,当前病况,住院医师,责任护士,住院天数,入院方式,护理等级,出院方式,入院病室,出院病室,当前病室',
               ',' || 元素名_In) > 0 Then
      --只查病人主页的元素
      p_Get_Rowtype('病案主页');
      Case 元素名_In
        When '住院号' Then
          v_Return := r_Inpage.住院号;
        When '入院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.入院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          End If;
        When '出院日期' Then
          If 病人来源_In = 2 Then
            v_Return := To_Char(r_Inpage.出院日期, 'yyyy-mm-dd hh24:mi');
            v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                        Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
          End If;
        When '住院目的' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院目的;
          End If;

        When '入院科室' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.科室id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院科室id;
            End If;
          End If;
        When '入院病区' Then
          If 病人来源_In = 2 Then
            Select Max(d.名称)
            Into v_Return
            From 部门表 D, 病人变动记录 P
            Where d.Id = p.病区id And p.病人id = 病人id_In And p.主页id = 就诊id_In And p.开始原因 = 9;
            If v_Return Is Null Then
              Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.入院病区id;
            End If;
          End If;
        When '当前床号' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院病床;
          End If;
        When '当前病区' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.当前病区id;
          End If;
        When '当前病况' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.当前病况;
          End If;
        When '住院医师' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.住院医师;
          End If;
        When '责任护士' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.责任护士;
          End If;
        When '住院天数' Then
          If 病人来源_In = 2 Then
            v_Return := Trunc(Nvl(r_Inpage.出院日期, Sysdate)) - Trunc(r_Inpage.入院日期);
          End If;
        When '入院方式' Then
          If 病人来源_In = 2 Then
            If r_Inpage.二级院转入 = 1 Then
              v_Return := '转入';
            Else
              v_Return := r_Inpage.入院方式;
            End If;
          End If;
        When '护理等级' Then
          If 病人来源_In = 2 Then
            Select 名称 Into v_Return From 收费项目目录 Where ID = r_Inpage.护理等级id;
          End If;
        When '出院方式' Then
          If 病人来源_In = 2 Then
            v_Return := r_Inpage.出院方式;
          End If;
        When '入院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.入院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.入院病区id And 床号 = r_Inpage.入院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '出院病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        When '当前病室' Then
          If 病人来源_In = 2 Then
            If v_Return Is Null And r_Inpage.出院病床 Is Not Null Then
              Begin
                Select 房间号
                Into v_Return
                From 床位状况记录
                Where 病区id = r_Inpage.当前病区id And 床号 = r_Inpage.出院病床;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        Else
          v_Return := '';
      End Case;
    When Instr(',姓名,性别,年龄', ',' || 元素名_In) > 0 Then
      p_Get_Rowtype('病人医嘱记录');
      p_Get_Rowtype('病人信息');
      If Nvl(r_Order.婴儿, 0) = 0 And 婴儿_In = 0 Then
        If 病人来源_In = 2 Then
          p_Get_Rowtype('病案主页');
          If 元素名_In = '姓名' Then
            v_Return := r_Inpage.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Inpage.性别;
          Elsif 元素名_In = '年龄' Then
            v_Return := r_Inpage.年龄;
          End If;
        Else
          If 元素名_In = '姓名' Then
            v_Return := r_Patient.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Patient.性别;
          Elsif 元素名_In = '年龄' Then
            v_Return := r_Patient.年龄;
          End If;
        End If;
      Else
        If 元素名_In = '姓名' Then
          p_Get_Rowtype('病案主页');
          Select Decode(婴儿姓名, Null, r_Inpage.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '性别' Then
          Select 婴儿性别
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        Elsif 元素名_In = '年龄' Then
          Select To_Char(出生时间, 'yyyy-mm-dd hh24:mi')
          Into v_Return
          From 病人新生儿记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 序号 = Decode(婴儿_In, 0, Nvl(r_Order.婴儿, 0), 婴儿_In);
        End If;
      End If;
    When Instr(',标识号,联系人姓名,联系人关系,联系人地址,联系人电话', ',' || 元素名_In) > 0 Then
      If 病人来源_In = 2 Then
        p_Get_Rowtype('病案主页');
        If 元素名_In = '标识号' Then
          v_Return := r_Inpage.住院号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Inpage.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Inpage.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Inpage.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Inpage.联系人电话;
        End If;
      Else
        p_Get_Rowtype('病人信息');
        If 元素名_In = '标识号' Then
          v_Return := r_Patient.门诊号;
        Elsif 元素名_In = '联系人姓名' Then
          v_Return := r_Patient.联系人姓名;
        Elsif 元素名_In = '联系人关系' Then
          v_Return := r_Patient.联系人关系;
        Elsif 元素名_In = '联系人地址' Then
          v_Return := r_Patient.联系人地址;
        Elsif 元素名_In = '联系人电话' Then
          v_Return := r_Patient.联系人电话;
        End If;
      End If;
    When Instr(',门诊就诊摘要,就诊科室,就诊时间,是否急诊,当前科室', ',' || 元素名_In) > 0 Then
      --只查病人挂号记录的元素
      If 病人来源_In = 1 Then
        p_Get_Rowtype('病人挂号记录');
        If 元素名_In = '门诊就诊摘要' Then
          v_Return := r_Regist.摘要;
        Elsif 元素名_In = '就诊科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        Elsif 元素名_In = '就诊时间' Then
          v_Return := To_Char(r_Regist.登记时间, 'yyyy-mm-dd hh24:mi');
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        Elsif 元素名_In = '是否急诊' Then
          If r_Regist.急诊 = 1 Then
            v_Return := '急诊';
          End If;
        Elsif 元素名_In = '当前科室' Then
          Select 名称 Into v_Return From 部门表 Where ID = r_Regist.执行部门id;
        End If;
      Else
        If 元素名_In = '当前科室' Then
          p_Get_Rowtype('病案主页');
          Select 名称 Into v_Return From 部门表 Where ID = r_Inpage.出院科室id;
        End If;
      End If;
    When Instr(',紧急程度,开单科室,开单医生,开单时间,开单时间,执行科室,要求时间,医生嘱托,诊疗类别,申请项目,检查类型,部位方法,检验标本', ',' || 元素名_In) > 0 Then
      --只查病人医嘱记录的元素
      p_Get_Rowtype('病人医嘱记录');
      If 元素名_In = '紧急程度' Then
        If r_Order.紧急标志 = 1 Then
          v_Return := '急';
        End If;
      Elsif 元素名_In = '开单科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.开嘱科室id;
      Elsif 元素名_In = '开单医生' Then
        v_Return := r_Order.开嘱医生;
      Elsif 元素名_In = '开单时间' Then
        v_Return := To_Char(r_Order.开嘱时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行科室' Then
        Select 名称 Into v_Return From 部门表 Where ID = r_Order.执行科室id;
      Elsif 元素名_In = '要求时间' Then
        v_Return := To_Char(r_Order.开始执行时间, 'yyyy-mm-dd hh24:mi');
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '医生嘱托' Then
        v_Return := r_Order.医生嘱托;
      Elsif 元素名_In = '诊疗类别' Then
        Select 名称 Into v_Return From 诊疗项目类别 Where 编码 = r_Order.诊疗类别;
      Elsif 元素名_In = '申请项目' Then
        Select 操作类型 Into v_Subtype From 诊疗项目目录 Where ID = r_Order.诊疗项目id;
        If r_Order.诊疗类别 = 'E' And v_Subtype = '6' Then
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I, (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In) A
          Where i.Id = a.诊疗项目id
          Order By a.序号;
        Else
          Select i.名称 Bulk Collect
          Into a_Return
          From 诊疗项目目录 I,
               (Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where ID = 医嘱id_In
                 Union All
                 Select 序号, 诊疗项目id
                 From 病人医嘱记录
                 Where 相关id = 医嘱id_In And 诊疗类别 <> 'G') A
          Where i.Id = a.诊疗项目id
          Group By i.名称
          Order By Max(a.序号);
        End If;
        If a_Return.Count > 1 Then
          For n_Count In 1 .. a_Return.Count Loop
            v_Return := v_Return || ' ' || n_Count || ')' || a_Return(n_Count);
          End Loop;
        Else
          v_Return := a_Return(1);
        End If;
        v_Return := Trim(v_Return);
      Elsif 元素名_In = '检查类型' Then
        Select 操作类型 Into v_Return From 诊疗项目目录 Where ID = r_Order.诊疗项目id And 类别 = 'D';
      Elsif 元素名_In = '部位方法' Then
        Select 部位 || Chr(9) || 方法 Bulk Collect
        Into a_Return
        From (Select 标本部位 As 部位, 检查方法 As 方法
               From 病人医嘱记录
               Where 相关id = 医嘱id_In And 诊疗类别 = 'D'
               Union All
               Select r_Order.标本部位, r_Order.检查方法
               From Dual) A,
             (Select p.编码, p.名称
               From 诊疗检查部位 P, 诊疗项目目录 I
               Where p.类型 = i.操作类型 And ID = r_Order.诊疗项目id And 类别 = 'D') P
        Where a.部位 = p.名称
        Order By p.编码;
        For n_Count In 1 .. a_Return.Count Loop
          If Instr(v_Return, ' ' || Substr(a_Return(n_Count), 1, Instr(a_Return(n_Count), Chr(9)))) > 0 Then
            v_Return := v_Return || '、' || Substr(a_Return(n_Count), Instr(a_Return(n_Count), Chr(9)) + 1);
          Else
            v_Return := v_Return || '  ' || a_Return(n_Count);
          End If;
        End Loop;
        v_Return := Replace(v_Return, Chr(9), ':');
      Elsif 元素名_In = '检验标本' Then
        v_Return := r_Order.标本部位;
      Else
        v_Return := '';
      End If;
    Else
      --自行查询SQL返回值的元素
      If 元素名_In = '单位名称' Then
        Select 内容 Into v_Return From Zlregaudit Where 项目 = '单位名称';
        If Instr(v_Return, ';') > 0 Then
          v_Return := Substr(v_Return, 1, Instr(v_Return, ';') - 1);
        End If;
      Elsif 元素名_In = '入科时间' Then
        If 病人来源_In = 2 Then
          Select Count(*)
          Into n_Times
          From 病人变动记录
          Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          If n_Times = 0 Then
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 1;
          Else
            Select To_Char(开始时间, 'yyyy-mm-dd hh24:mi')
            Into v_Return
            From 病人变动记录
            Where 病人id = 病人id_In And 主页id = 就诊id_In And 开始原因 = 2;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;

      Elsif 元素名_In = 'ABO' Or 元素名_In = 'RH' Then
        Select 信息值 Into v_Return From 病人信息从表 P Where p.病人id = 病人id_In And p.信息名 = 元素名_In;
      Elsif 元素名_In = '一次住院时间' Or 元素名_In = '二次住院时间' Or 元素名_In = '上次住院时间' Then
        If 病人来源_In = 2 Then
          Select To_Char(入院日期, 'yyyy-mm-dd hh24:mi') Bulk Collect
          Into a_Return
          From 病案主页
          Where 病人id = 病人id_In And 主页id < 就诊id_In
          Order By 入院日期;
          If 元素名_In = '一次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(1);
          Elsif 元素名_In = '二次住院时间' And a_Return.Count > 1 Then
            v_Return := a_Return(2);
          Elsif 元素名_In = '上次住院时间' And a_Return.Count > 0 Then
            v_Return := a_Return(a_Return.Count);
          Else
            Return Null;
          End If;
          v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                      Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
        End If;
      Elsif 元素名_In = '最后诊断' Then
        v_Return := f_Latest_Diagnose(就诊id_In, 时间_In);
      Elsif 元素名_In = '最后诊断ID' Then
        v_Return := f_Last_Diagnoseid(就诊id_In);
      Elsif 元素名_In = '门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '一次住院诊断' Or 元素名_In = '二次住院诊断' Or 元素名_In = '上次住院诊断' Then
        Select 主页id Bulk Collect
        Into a_Return
        From 病案主页
        Where 病人id = 病人id_In And 主页id < 就诊id_In
        Order By 入院日期;
        If 元素名_In = '一次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(1));
        Elsif 元素名_In = '二次住院诊断' And a_Return.Count > 1 Then
          n_主页id := To_Number(a_Return(2));
        Elsif 元素名_In = '上次住院诊断' And a_Return.Count > 0 Then
          n_主页id := To_Number(a_Return(a_Return.Count));
        Else
          Return Null;
        End If;
        v_Return := f_Latest_Diagnose(n_主页id);
      Elsif 元素名_In = '西医门诊诊断' Then
        v_Return := f_Diagnose(1);
      Elsif 元素名_In = '中医门诊诊断' Then
        v_Return := f_Diagnose(2);
      Elsif 元素名_In = '西医入院诊断' Then
        v_Return := f_Diagnose(3);
      Elsif 元素名_In = '中医入院诊断' Then
        v_Return := f_Diagnose(4);
      Elsif 元素名_In = '西医出院诊断' Then
        v_Return := f_Diagnose(5);
      Elsif 元素名_In = '西医出院主要诊断' Then
        v_Return := f_Diagnose(6);
      Elsif 元素名_In = '西医出院其他诊断' Then
        v_Return := f_Diagnose(7);
      Elsif 元素名_In = '中医出院诊断' Then
        v_Return := f_Diagnose(8);
      Elsif 元素名_In = '过敏药物' Then
        Select d.药物名 Bulk Collect
        Into a_Return
        From 病人过敏记录 D, (Select Max(记录时间) As 时间 From 病人过敏记录 Where 病人id = 病人id_In And 结果 = 1) M
        Where d.病人id = 病人id_In And d.结果 = 1 And d.记录时间 = m.时间;
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || '；' || a_Return(n_Count);
        End Loop;
        If v_Return Is Not Null Then
          v_Return := Substr(v_Return, 2);
        End If;
      Elsif 元素名_In = '病人主诉' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
        v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '病历摘要' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        If v_Return Is Null Then
          v_Return := f_Latest_Advice_Annex();
        End If;
        If v_Return Is Null Then
          v_Return := f_Latest_Epr_Content('病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '病人主诉：'), '病人主诉:'), '病人主诉');
          v_Return := Replace(Replace(Replace(v_Return, '主诉：'), '主诉:'), '主诉');
        End If;
      Elsif 元素名_In = '现病史' Or 元素名_In = '体格检查' Or 元素名_In = '辅助检查' Or 元素名_In = '专科检查' Or 元素名_In = '既往史' Then
        v_Return := f_Latest_Epr_Content(元素名_In);
        v_Return := Replace(Replace(Replace(v_Return, Chr(13)), Chr(10)), ' ');
      Elsif 元素名_In = '检验类型' Then
        Select 操作类型
        Into v_Return
        From 诊疗项目目录 I,
             (Select 序号, 诊疗项目id From 病人医嘱记录 Where 相关id = 医嘱id_In And 诊疗类别 = 'C' And Rownum < 2) A
        Where i.Id = a.诊疗项目id;
      Elsif 元素名_In = '麻醉方式' Then
        Select i.名称
        Into v_Return
        From 病人医嘱记录 A, 诊疗项目目录 I
        Where a.诊疗项目id = i.Id And a.相关id = 医嘱id_In And a.诊疗类别 = 'G';
      Elsif 元素名_In = '本次医嘱' Then
        v_Return := f_Get_Advice_Text();
      Elsif 元素名_In = '报到时间' Then
        Select To_Char(Max(报到时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '执行间' Then
        Select Max(执行间) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '费用单号' Then
        Select Max(记录性质 || NO) Into v_Return From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行人' Then
        Select Max(执行人) Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '执行时间' Then
        Select To_Char(Max(执行时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 病人医嘱执行 Where 医嘱id = 医嘱id_In;
        v_Return := Substr(v_Return, 1, 4) || '年' || Substr(v_Return, 6, 2) || '月' || Substr(v_Return, 9, 2) || '日' ||
                    Substr(v_Return, 12, 2) || '时' || Substr(v_Return, 15, 2) || '分';
      Elsif 元素名_In = '设备型号' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select a.名称
               From (Select r.仪器id
                      From 检验标本记录 L, 检验普通结果 R
                      Where r.检验标本id = l.Id And l.医嘱id = 医嘱id_In
                      Union
                      Select l.仪器id
                      From 检验标本记录 L
                      Where l.医嘱id = 医嘱id_In) L, 检验仪器 A
               Where l.仪器id = a.Id
               Union All
               Select 检查设备
               From 影像检查记录
               Where 医嘱id = 医嘱id_In);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);

      Elsif 元素名_In = '采样人' Then
        Select Max(采样人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '采样时间' Then
        Select To_Char(Max(采样时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '样本条码' Then
        Select Max(样本条码) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本序号' Then
        Select Max(标本序号) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '标本类型' Then
        Select Max(标本类型) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收人' Then
        Select Max(核收人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '核收时间' Then
        Select To_Char(Max(核收时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验人' Then
        Select Max(检验人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验时间' Then
        Select To_Char(Max(检验时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核人' Then
        Select Max(审核人) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '审核时间' Then
        Select To_Char(Max(审核时间), 'yyyy-mm-dd hh24:mi') Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验评语' Then
        Select Max(备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验备注' Then
        Select Max(检验备注) Into v_Return From 检验标本记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检验项目' Then
        Select 名称 Bulk Collect
        Into a_Return
        From (Select i.名称
               From 诊疗项目目录 I, 病人医嘱记录 A,
                    (Select r.医嘱id From 检验标本记录 L, 检验项目分布 R Where r.标本id = l.Id And l.医嘱id = 医嘱id_In) L
               Where i.Id = a.诊疗项目id And a.相关id = l.医嘱id
               Order By a.序号);
        For n_Count In 1 .. a_Return.Count Loop
          v_Return := v_Return || ' ' || a_Return(n_Count);
        End Loop;
        v_Return := Trim(v_Return);

      Elsif 元素名_In = '影像类别' Then
        Select Max(影像类别) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '检查号' Then
        Select Max(检查号) Into v_Return From 影像检查记录 Where 医嘱id = 医嘱id_In;
      Elsif 元素名_In = '服用造影剂' Then
        Select 造影剂 || '  用量:' || 用量 || '  浓度:' || 浓度 Into v_Return From 服用造影剂 Where 医嘱id = 医嘱id_In;

      Elsif 元素名_In = '手术规模' Or 元素名_In = '手术执行间' Or 元素名_In = '手术麻醉质量' Or 元素名_In = '手术麻醉方式' Or 元素名_In = '手术开始时间' Or
            元素名_In = '手术结束时间' Or 元素名_In = '麻醉开始时间' Or 元素名_In = '麻醉结束时间' Or 元素名_In = '输氧开始时间' Or 元素名_In = '输氧结束时间' Or
            元素名_In = '主刀医生' Or 元素名_In = '助手医生' Or 元素名_In = '麻醉医生' Or 元素名_In = '洗手护士' Or 元素名_In = '巡回护士' Or
            元素名_In = '其他手术人员' Or 元素名_In = '拟行主手术' Or 元素名_In = '拟行附手术' Or 元素名_In = '已行主手术' Or 元素名_In = '已行附手术' Or
            元素名_In = '术前主诊断' Or 元素名_In = '术前次诊断' Or 元素名_In = '术后主诊断' Or 元素名_In = '术后次诊断' Or 元素名_In = '输液总量' Or
            元素名_In = '拟施手术时间' Or 元素名_In = '拟施麻醉方式' Then

        --这些要素从手麻子系统中获取

        n_Have := 0;
        Begin
          Select 1 Into n_Have From zlSystems Where Floor(编号 / 100) = 24;
        Exception
          When Others Then
            Null;
        End;

        If n_Have = 1 Then
          If 医嘱id_In Is Null Then
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,Null) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In));
            Exception
              When Others Then
                Null;
            End;
          Else
            v_Sql := 'Select Zl24_Replace_Element_Value(:v1,:v2,:v3,:v4,:v5) From Dual';
            Begin
              Execute Immediate v_Sql
                Into v_Return
                Using 元素名_In, Trim(To_Char(病人id_In)), Trim(To_Char(就诊id_In)), Trim(To_Char(病人来源_In)), Trim(To_Char(医嘱id_In));
            Exception
              When Others Then
                Null;
            End;
          End If;
        End If;

      Else
        v_Sql := 'Select Zl_Replace_Element_Value_User(:v1,:v2,:v3,:v4,:v5,:v6) From Dual';
        Begin
          Execute Immediate v_Sql
            Into v_Return
            Using 元素名_In, 病人id_In, 就诊id_In, 病人来源_In, 医嘱id_In, 婴儿_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
  End Case;

  Return Trim(v_Return);
Exception
  When Others Then
    Return Null;
End Zl_Replace_Element_Value;
/
--86310:胡俊勇,2015-07-07,记账划价单没有审核生记账单
Create Or Replace Procedure Zl_住院医嘱执行_Finish
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 住院费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;

  Cursor c_Finish(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 住院费用记录 A, 病人医嘱记录 B,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 住院费用记录 A,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And a.记录性质 = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --执行中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id, Decode(d.高值材料, 1, a.执行部门id, b.库房id) As 库房id
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 材料特性 D,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where d.材料id = a.收费细目id And a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id Is Not Null And
          a.收费类别 = '4' And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And a.记录性质 = n.记录性质 And b.单据 In (25, 26) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.库房id, b.药品id;

  --执行中包含的未发药品，本科执行的自动发药
  Cursor c_Drug(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id, b.库房id
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 病案主页 D,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id = d.当前病区id And a.收费类别 In ('5', '6', '7') And
          a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And c.病人id = d.病人id And c.主页id = d.主页id And
          (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质
    Order By b.库房id, b.药品id;

  --未审核的费用行(包含药品和卫材)
  Cursor c_Verify(r_No t_Strlist) Is
    Select /*+ RULE */
    Distinct a.No, a.序号
    From 住院费用记录 A, 病人医嘱记录 C,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 = c.Id And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And a.记录性质 = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  Cursor c_Verifyone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.No, a.序号
    From 住院费用记录 A,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 + 0 = 医嘱id_In And a.No = n.No And a.记录性质 = n.记录性质 And
          (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  v_No   病人医嘱发送.No%Type;
  v_序号 Varchar2(1000);

  v_发料号  药品收发记录.汇总发药号%Type;
  v_库房id  药品收发记录.库房id%Type;
  v_收发ids Varchar2(4000);

  v_医嘱期效 病人医嘱记录.医嘱期效%Type;
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;
  Forall I In 1 .. r_Finish.Count
    Update 住院费用记录 Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 操作员姓名_In Where ID = r_Finish(I);

  --执行时自动审核对应的记帐划价单费用
  --包含医嘱对应的药品及卫材费用，因为医嘱已执行，费用应该生效。
  If Nvl(Zl_Getsysparameter(81), '0') = '1' Then
    If nvl(单独执行_In,0) = 0 Then
      For r_Verify In c_Verify(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_住院记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    Else
      For r_Verify In c_Verifyone(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_住院记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    End If;
    If v_序号 Is Not Null Then
      Zl_住院记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
    End If;
  End If;

  --处理跟踪在用卫材自动发料
  If Nvl(Zl_Getsysparameter(33), '0') = '1' Then
    For r_Stuff In c_Stuff(r_No_Stuff) Loop
      If v_发料号 Is Null Then
        v_发料号 := Nextno(20);
      End If;
    
      If r_Stuff.库房id <> Nvl(v_库房id, 0) Then
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
        End If;
        v_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
    End If;
  End If;

  --处理药品自动发药(只在护士站，本科药品才处理,本科由参数和游标判断)
  Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
  If Substr(Zl_Getsysparameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
    v_发料号  := Null;
    v_收发ids := Null;
    For r_Drug In c_Drug(r_No_Stuff) Loop
      If v_发料号 Is Null Then
        v_发料号 := Nextno(20);
      End If;
    
      If r_Drug.库房id <> Nvl(v_库房id, 0) Then
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发药(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号);
        End If;
        v_库房id  := r_Drug.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Drug.Id || ',0';
    End Loop;
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发药(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号);
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_住院医嘱执行_Finish;
/

--86310:胡俊勇,2015-07-07,记账划价单没有审核生记账单
Create Or Replace Procedure Zl_门诊医嘱执行_Finish
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;

  Cursor c_Finish(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A, 病人医嘱记录 B,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And a.记录性质 = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And a.记录性质 = n.记录性质 And a.记录状态 In (0, 1, 3)  And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --执行中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id, Decode(d.高值材料, 1, a.执行部门id, b.库房id) As 库房id
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 材料特性 D,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where d.材料id = a.收费细目id And a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id Is Not Null And
          a.收费类别 = '4' And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And a.记录性质 = n.记录性质 And b.单据 = 24 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.库房id, b.药品id;

  --未审核的费用行(包含药品和卫材)
  Cursor c_Verify(r_No t_Strlist) Is
    Select /*+ RULE */
    Distinct a.No, a.序号
    From 门诊费用记录 A, 病人医嘱记录 C,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 = c.Id And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And a.记录性质 = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  Cursor c_Verifyone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.No, a.序号
    From 门诊费用记录 A,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 + 0 = 医嘱id_In And a.No = n.No And a.记录性质 = n.记录性质 And
          (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  v_No   病人医嘱发送.No%Type;
  v_序号 Varchar2(1000);

  v_发料号  药品收发记录.汇总发药号%Type;
  v_库房id  药品收发记录.库房id%Type;
  v_收发ids Varchar2(4000);
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;
  Forall I In 1 .. r_Finish.Count
    Update 门诊费用记录 Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 操作员姓名_In Where ID = r_Finish(I);

  --执行时自动审核对应的记帐划价单费用
  --包含医嘱对应的药品及卫材费用，因为医嘱已执行，费用应该生效。
  If Nvl(Zl_Getsysparameter(81), '0') = '1' Then
    If nvl(单独执行_In,0) = 0 Then
      For r_Verify In c_Verify(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    Else
      For r_Verify In c_Verifyone(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    End If;
    If v_序号 Is Not Null Then
      Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
    End If;
  End If;

  --处理跟踪在用卫材自动发料
  If Nvl(Zl_Getsysparameter(33), '0') = '1' Then
    For r_Stuff In c_Stuff(r_No_Stuff) Loop
      If v_发料号 Is Null Then
        v_发料号 := Nextno(20);
      End If;
    
      If r_Stuff.库房id <> Nvl(v_库房id, 0) Then
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
        End If;
        v_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_门诊医嘱执行_Finish;
/

--85214:胡俊勇,2015-07-06,医嘱单打印清上次打印
Create Or Replace Procedure Zl_病人医嘱打印_Update
(
  医嘱id_In     病人医嘱打印.医嘱id%Type,
  页号_In       病人医嘱打印.页号%Type,
  行号_In       病人医嘱打印.行号%Type,
  病人id_In     病人医嘱打印.病人id%Type := Null,
  主页id_In     病人医嘱打印.主页id%Type := Null,
  婴儿_In       病人医嘱打印.婴儿%Type := Null,
  期效_In       病人医嘱打印.期效%Type := Null,
  时间_In       病人医嘱打印.打印时间%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  打印模式_In   Number := 0, --0-校对后打印，1-新开后打印,
  标记_In       病人医嘱打印.打印标记%Type := Null
) Is
  ----标记_In 停嘱打印时传入，否则认为是常规打印
  v_标记     病人医嘱打印.打印标记%Type;
  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱打印.打印人%Type;
Begin
  If 标记_In <> 0 Then
    If 医嘱id_In Is Not Null Then
      Select Decode(确认停嘱时间, Null, Decode(执行终止时间, Null, 0, 1), 2)
      Into v_标记
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    End If;
    Update 病人医嘱打印 Set 打印标记 = v_标记 Where 医嘱id = 医嘱id_In And 页号 = 页号_In And 行号 = 行号_In;
  Else
    --当前操作人员
    If 操作员姓名_In Is Not Null Then
      v_人员姓名 := 操作员姓名_In;
    Else
      v_Temp     := Zl_Identity;
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End If;
  
    --打印时已确认停止的医嘱标记为已打印停止标记
    v_标记 := 0;
    If 医嘱id_In Is Not Null And 期效_In = 0 Then
      Select Decode(确认停嘱时间, Null, Decode(打印模式_In, 1, Decode(执行终止时间, Null, 0, 1), 0), 2)
      Into v_标记
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    End If;
  
    Update 病人医嘱打印
    Set 打印标记 = v_标记, 打印人 = v_人员姓名, 打印时间 = 时间_In
    Where 医嘱id = 医嘱id_In And 页号 = 页号_In And 行号 = 行号_In And 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And
          期效 = 期效_In And 打印时间 Is Null;
  
    If 医嘱id_In Is Null Then
      ----特殊医嘱标记为打印
      Update 病人医嘱打印
      Set 打印标记 = v_标记, 打印人 = v_人员姓名, 打印时间 = 时间_In
      Where 医嘱id Is Null And 页号 = 页号_In And 行号 = 行号_In And 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And
            期效 = 期效_In And 打印时间 Is Null;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Update;
/

--86229:马政,2015-08-08,药品结存开放期间多次结存
CREATE OR REPLACE Procedure Zl_药品结存记录_Insert
(
  库房id_In In 药品结存记录.库房id%Type := Null,
  填制人_In In 药品结存记录.填制人%Type := Null,
  转结_In   In Number := 1
) Is
  v_Lngid      药品结存记录.Id%Type;
  d_开始日期   药品结存记录.期初日期%Type;
  d_结束日期   药品结存记录.期末日期%Type;
  n_结存时点   Number(2);
  n_上次结存id 药品结存记录.Id%Type;
  v_上次期间   药品结存记录.期间%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
  n_未审核记录 Number(1) := 0;
Begin
  If 转结_In = 0 Then
    --初始结存，期初日期 = 期末日期= 当前系统日期
    d_开始日期 := Sysdate;
    d_结束日期 := d_开始日期;
  Else
    --检查是否存在未审核的结存记录，如果存在则不能结存
    Select Count(ID) Into n_未审核记录 From 药品结存记录 Where 库房id = 库房id_In And 审核日期 Is Null;

    If n_未审核记录 > 0 Then
      v_Error := '上次结存未审核，不能再次结存';
      Raise Err_Custom;
    End If;

    --取结存时点，默认每月最后一日结存
    n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);

    If n_结存时点 <> -1 Then
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Trunc(Max(期末日期)) + 1, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In;

      --自动结存
      If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(d_开始日期 - 1)), 'dd')) Then
        --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
        d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
      Else
        d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
      End If;
      --检查日期，在结存时点后才能进行结存
      If Sysdate - d_结束日期 < 0 Then
        v_Error := '本月结存时点未到，不能提前结存！';
        Raise Err_Custom;
      End If;

      --检查期间
      If v_上次期间 = To_Char(Trunc(d_结束日期), 'yyyymm') Then
        v_Error := '本月已经结存，不能再次结存！';
        Raise Err_Custom;
      End If;
    Else
      --手工结存
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Max(期末日期) + 1 / 24 / 60 / 60, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In;

      d_结束日期 := Sysdate;
    End If;
  End If;

  Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;

  --产生药品结存主表
  Insert Into 药品结存记录
    (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 审核人, 审核日期, 上次结存id, 期间, 性质)
  Values
    (v_Lngid, 库房id_In, d_开始日期, d_结束日期, Nvl(填制人_In, Zl_Username), Sysdate,
     Decode(d_开始日期, Null, Nvl(填制人_In, Zl_Username), Null), Decode(d_开始日期, Null, Sysdate, Null), n_上次结存id,
     To_Char(Trunc(d_结束日期), 'yyyymm'), Decode(转结_In, 0, 0, 1));

  If 转结_In = 0 Then
    --初始结存，以当前库存为准期末 = 期初=当前库存数据
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, Nvl(a.实际数量, 0) As 期初数量, Nvl(a.实际金额, 0) As 期初金额,
                    Nvl(a.实际差价, 0) As 期初差价, Nvl(a.实际数量, 0) As 期末数量, Nvl(实际金额, 0) As 期末金额, Nvl(实际差价, 0) As 期末差价
             From 药品库存 A, 药品规格 B
             Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期初数量,
                    -1 * a.入出系数 * a.零售金额 As 期初金额, -1 * a.入出系数 * a.差价 As 期初差价, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量,
                    -1 * a.入出系数 * a.零售金额 As 期末金额, -1 * a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 > d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  Else
    --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select 库房id, 药品id, Nvl(批次, 0) As 批次, 期末数量 As 期初数量, 期末金额 As 期初金额, 期末差价 As 期初差价, 期末数量, 期末金额, 期末差价
             From 药品结存明细
             Where 结存id = n_上次结存id
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                    a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 Between d_开始日期 And d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;

    --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
    Insert Into 药品结存误差
      (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
      Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
      From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
             From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                           Nvl(a.期末差价, 0) As 实际差价
                    From 药品结存明细 A, 药品规格 B
                    Where a.药品id = b.药品id And a.结存id = v_Lngid
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量, -1 * Nvl(a.实际金额, 0) As 实际金额,
                           -1 * Nvl(a.实际差价, 0) As 实际差价
                    From 药品库存 A, 药品规格 B
                    Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                           a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                    From 药品收发记录 A, 药品规格 B
                    Where a.药品id = b.药品id And a.库房id = 库房id_In And a.审核日期 > d_结束日期) A
             Group By 库房id, 药品id, 批次) A
      Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Insert;
/

--86229:马政,2015-08-08,药品结存开放期间多次结存
Create Or Replace Procedure Zl1_Autocloseaccount Is
  v_Lngid    药品结存记录.Id%Type;
  d_开始日期 药品结存记录.期初日期%Type;
  d_结束日期 药品结存记录.期末日期%Type;
  n_结存时点 Number(2);
  v_Error    Varchar2(255);
  Err_Custom Exception;
  d_计算日期     药品结存记录.期末日期%Type;
  n_结存id       药品结存记录.Id%Type;
  n_未审核结存id 药品结存记录.Id%Type;

  Cursor c_Stock Is
    Select Distinct b.Id
    From 部门性质说明 A, 部门表 B
    Where a.部门id = b.Id And a.工作性质 In ('西药库', '成药库', '中药库', '西药房', '成药房', '中药房', '制剂室') And
          To_Char(b.撤档时间, 'yyyy-MM-dd') = '3000-01-01'
    Order By b.Id;
  r_Stock c_Stock%RowType;
Begin
  --取结存时点，默认每月最后一日结存
  n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);

  --只有自动结存才走此过程，手工结存不在走此过程
  If n_结存时点 <> -1 Then
    --计算本次结存的结束日期；因为自动结存是对前一天数据进行结存，所以需要按当前日期提前一天来计算或判断，
    If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(Sysdate - 1)), 'dd')) Then
      --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
      d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
    Else
      d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
    End If;
  
    --检查日期，在结存时点后才能进行自动结存
    If Sysdate - d_结束日期 > 0 Then
      For r_Stock In c_Stock Loop
        --判断期间内是否有结存(不算转结)
        Select Nvl(Max(ID), 0)
        Into n_结存id
        From 药品结存记录
        Where 库房id = r_Stock.Id And 性质 = 1 And 期间 = To_Char(Trunc(d_结束日期), 'yyyymm');
      
        If n_结存id > 0 Then
          --如果当前期间已经结存过了，就不再结存，一个期间只结存一次
          Null;
        Else
          --取库房最大的结存ID和本次结存的开始日期
          Select Nvl(Max(ID), 0), Max(期末日期) + 1 / 24 / 60 / 60
          Into n_结存id, d_开始日期
          From 药品结存记录
          Where 库房id = r_Stock.Id;
        
          If n_结存id > 0 Then
            --检查是否存在未审核的结存，如果存在则自动审核(通常情况都是在期间内手工审核)
            Select Nvl(Max(ID), 0)
            Into n_未审核结存id
            From 药品结存记录
            Where 库房id = r_Stock.Id And 审核日期 Is Null;
          
            If n_未审核结存id > 0 Then
              Zl_药品结存记录_Verify(n_未审核结存id, Zl_Username);
            End If;
          
            --产生新的结存记录
            Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;
          
            Insert Into 药品结存记录
              (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 上次结存id, 期间, 性质)
            Values
              (v_Lngid, r_Stock.Id, d_开始日期, d_结束日期, Zl_Username, Sysdate, n_结存id, To_Char(Trunc(d_结束日期), 'yyyymm'), 1);
          
            --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
            Insert Into 药品结存明细
              (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
              Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
              From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.期末数量 As 期初数量, a.期末金额 As 期初金额, a.期末差价 As 期初差价, a.期末数量,
                            a.期末金额, a.期末差价
                     From 药品结存明细 A, 药品规格 B
                     Where a.药品id = b.药品id And a.结存id = n_结存id
                     Union All
                     Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                            a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
                     From 药品收发记录 A, 药品规格 B
                     Where a.药品id = b.药品id And a.库房id + 0 = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期)
              Group By 库房id, 药品id, 批次
              Order By 库房id, 药品id, 批次;
          
            --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
            Insert Into 药品结存误差
              (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
              Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
              From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
                     From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                                   Nvl(a.期末差价, 0) As 实际差价
                            From 药品结存明细 A, 药品规格 B
                            Where a.药品id = b.药品id And a.结存id = v_Lngid
                            Union All
                            Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量,
                                   -1 * Nvl(a.实际金额, 0) As 实际金额, -1 * Nvl(实际差价, 0) As 实际差价
                            From 药品库存 A, 药品规格 B
                            Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = r_Stock.Id
                            Union All
                            Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                                   a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                            From 药品收发记录 A, 药品规格 B
                            Where a.药品id = b.药品id And a.库房id = r_Stock.Id And a.审核日期 > d_结束日期) A
                     Group By 库房id, 药品id, 批次) A
              Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
          End If;
        End If;
        --按库房提交
        Commit;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autocloseaccount;
/

--84458:涂建华,2015-07-06,新版Pacs报告编辑器数据转移处理
--84458:黄捷,2015-07-21,影像报告操作记录增加转出处理
Create Or Replace Procedure Zl1_Datamove_Reb
(
  System_In    In Number,
  Speedmode_In In Number,
  Func_In      In Number,
  Enable_In    In Number := 0,
  Parallel_In  In Number := 0,
  Rebscope_In  In Number := 0
) As
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间
  --参数：
  --System_In:    应用系统编号,100=标准版
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作）
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部)

  v_Sql Varchar2(1000);
  n_Do  Number(1);
  v_Tbs Varchar2(100);

  --转出标记中的SQL查询所需的索引
  v_Indexeswithtag Varchar2(4000) := '门诊费用记录_IX_结帐ID,住院费用记录_IX_结帐ID,费用补充记录_IX_结算ID,费用补充记录_IX_登记时间,病人预交记录_IX_主页ID,病人预交记录_IX_结帐ID,病人预交记录_IX_收款时间,门诊费用记录_IX_登记时间,门诊费用记录_IX_医嘱序号,住院费用记录_IX_登记时间,病人结帐记录_IX_收费时间,病人结帐记录_IX_病人id' ||
                                     ',药品收发记录_IX_费用ID,收发记录补充信息_IX_收发ID,输液配药内容_IX_收发ID,药品留存计划_IX_留存ID,药品签名明细_IX_收发ID' ||
                                     ',人员借款记录_IX_借出时间,人员收缴记录_IX_登记时间,人员暂存记录_IX_收缴ID,人员暂存记录_IX_登记时间,票据领用记录_IX_登记时间,票据使用明细_IX_领用ID,票据打印明细_IX_使用ID' ||
                                     ',病人挂号记录_IX_登记时间,病人医嘱发送_IX_发送时间,病人医嘱记录_IX_挂号单,病人医嘱记录_IX_主页ID,病人医嘱记录_IX_相关ID' ||
                                     ',病案主页_IX_出院日期,住院费用记录_IX_病人ID,病人过敏记录_IX_病人ID,病人诊断记录_IX_病人ID,病人手麻记录_IX_主页ID' ||
                                     ',病人护理记录_IX_主页ID,病人护理内容_IX_记录id,病人护理文件_IX_主页ID,病人护理数据_IX_文件ID,病人护理明细_IX_记录ID,病人护理打印_IX_文件ID' ||
                                     ',电子病历记录_IX_病人ID,病人医嘱报告_IX_病历ID,影像报告驳回_IX_医嘱ID,报告查阅记录_IX_病历ID,病人诊断记录_IX_病历ID' ||
                                     ',病人临床路径_IX_病人ID,病人合并路径_IX_首要路径记录ID,病人路径执行_IX_路径记录ID,病人出径记录_IX_路径记录ID,病人诊断医嘱_IX_医嘱ID' ||
                                     ',影像报告记录_IX_医嘱ID,影像报告操作记录_IX_医嘱ID,影像申请单图像_IX_医嘱ID,影像收藏内容_IX_医嘱ID,检验标本记录_IX_医嘱ID,检验项目分布_IX_标本ID,检验分析记录_IX_标本ID' ||
                                     ',检验操作记录_IX_标本ID,检验图像结果_IX_标本ID,检验拒收记录_IX_医嘱ID,检验普通结果_IX_检验标本ID';

  --转出标记中的SQL查询所需的索引(主键及唯一键对应的索引)
  v_Constraintswithtag Varchar2(4000) := '病人预交记录_UQ_NO,病人结帐记录_UQ_NO,病人结帐记录_PK,门诊费用记录_UQ_NO,住院费用记录_UQ_NO' ||
                                         ',病人卡结算对照_PK,费用补充记录_PK,病人卡结算记录_PK,三方结算交易_PK,输液配药记录_PK,药品签名记录_PK,票据打印内容_PK,病人挂号记录_PK,病人挂号汇总_UQ_日期,病人转诊记录_UQ_NO' ||
                                         ',病人护理活动项目_UQ_页号,病人护理要素内容_UQ_页号,产程要素内容_PK,电子病历记录_PK,电子病历附件_PK,电子病历格式_PK,电子病历内容_UQ_对象序号,电子病历图形_PK,疾病申报记录_PK' ||
                                         ',病人合并路径评估_PK,病人路径评估_PK,病人路径变异_PK,病人路径指标_UQ_评估指标,病人路径医嘱_PK' ||
                                         ',病人医嘱记录_PK,病人医嘱报告_PK,病人医嘱计价_UQ_收费细目ID,病人医嘱附费_PK,病人医嘱附件_PK,病人医嘱执行_PK,医嘱执行时间_PK,医嘱执行打印_PK,病人医嘱打印_UQ_医嘱ID,输血申请记录_PK,输血检验结果_PK' ||
                                         ',病人诊断记录_PK,病人医嘱状态_PK,医嘱签名记录_PK,病人医嘱发送_PK,诊疗单据打印_PK,医嘱执行计价_PK,执行打印记录_PK' ||
                                         ',影像检查记录_PK,影像检查序列_UQ_序列号,影像检查图象_UQ_图像号,影像危急值记录_UQ_医嘱ID' ||
                                         ',检验申请项目_PK,检验质控记录_PK,检验签名记录_PK,检验试剂记录_PK,检验质控报告_PK,检验药敏结果_PK,人员收缴记录_PK,人员收缴明细_PK,人员收缴票据_PK,人员收缴对照_PK';

  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。
  Procedure Setconstraintstatus As
  Begin
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键
    If Enable_In = 0 Then
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED'
                Order By a.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      If Speedmode_In = 1 Then
        --禁用主键或唯一键索引(必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录)
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引)
        For R In (Select a.Table_Name, a.Constraint_Name
                  From User_Constraints A, zlBakTables T, User_Tables B
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And
                        a.Constraint_Name Not In
                        (Select Upper(Column_Value) As Constraint_Name From Table(f_Str2list(v_Constraintswithtag)))
                  Order By Constraint_Name) Loop
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name ||
                   ' Cascade Drop Index';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    Else
      --启用时，先启用主键和唯一键，再启用引用转出表主键的他表外键
      If Speedmode_In = 1 Then
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式
        For R In (Select d.Table_Name, d.Constraint_Name, LTrim(Max(Sys_Connect_By_Path(d.Column_Name, ',')), ',') Colstr
                  From User_Cons_Columns D,
                       (Select a.Table_Name, a.Constraint_Name
                         From User_Constraints A, zlBakTables T
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And
                               a.Constraint_Type In ('P', 'U')) A
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name
                  Start With d.Position = 1
                  Connect By Prior d.Position + 1 = d.Position And Prior d.Constraint_Name = d.Constraint_Name
                  Group By d.Table_Name, d.Constraint_Name
                  Order By Constraint_Name) Loop
          Update Zldatamovelog
          Set 当前进度 = '正在恢复约束:' || r.Constraint_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2;
        
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr ||
                   ') Tablespace ' || v_Tbs || ' Nologging';
          Begin
            Execute Immediate v_Sql;
          Exception
            When Others Then
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错
          End;
        
          --会自动建立约束与索引的关联
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --启用引用转出表主键的他表外键
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED'
                Order By a.Table_Name) Loop
        --为了加快速度，采用novalidate，不验证已有数据
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    End If;
  End Setconstraintstatus;

  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID)
  --说明：禁用索引是为了提高删除数据的性能
  Procedure Setindexstatus As
  Begin
    If Speedmode_In = 1 Then
      --保留转出标记中的SQL查询所需的索引
      For R In (Select /*+ rule*/
                 a.Index_Name
                From User_Indexes A, zlBakTables T
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And
                      a.Index_Name Not In
                      (Select Upper(Column_Value) As Index_Name From Table(f_Str2list(v_Indexeswithtag))) And
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists
                 (Select 1
                       From User_Constraints C
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U'))
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
          Execute Immediate v_Sql;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
          Begin
            Execute Immediate v_Sql;
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源



          Exception
            When Others Then
              If SQLErrM Like 'ORA-00054%' Then
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
                Execute Immediate v_Sql;
              End If;
          End;
        End If;
      End Loop;
    Else
      For R In (Select a.Index_Name
                From (Select d.Table_Name, d.Index_Name, LTrim(Max(Sys_Connect_By_Path(d.Column_Name, ',')), ',') Colstr
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name
                       Start With d.Column_Position = 1
                       Connect By Prior d.Column_Position + 1 = d.Column_Position And Prior d.Index_Name = d.Index_Name
                       Group By d.Table_Name, d.Index_Name) A,
                     (Select e.Table_Name, LTrim(Max(Sys_Connect_By_Path(e.Column_Name, ',')), ',') Colstr
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And
                             Not Exists
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In)
                       Start With Nvl(e.Position, 1) = 1
                       Connect By Prior Nvl(e.Position, 1) + 1 = Nvl(e.Position, 1) And
                                  Prior e.Constraint_Name = e.Constraint_Name
                       Group By e.Table_Name, e.Constraint_Name) B
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '人员收缴记录_IX_缴款组ID') Then
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
            Execute Immediate v_Sql;
          End If;
        Else
          Update Zldatamovelog
          Set 当前进度 = '正在重建索引:' || r.Index_Name
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源  
        End If;
      End Loop;
    End If;
  End Setindexstatus;

  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复
  Procedure Settriggerstatus As
  Begin
    For R In (Select Distinct a.Table_Name, t.停用触发器
              From User_Triggers A, zlBakTables T
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And
                    t.系统 = System_In) Loop
      If Enable_In = 0 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name;
      Elsif Nvl(r.停用触发器, 0) = 1 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name;
      End If;
      Execute Immediate v_Sql;
    End Loop;
    Commit;
  End Settriggerstatus;

  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用
  Procedure Setjobstatus As
    v_Jobs Varchar2(4000);
  Begin
    --停用
    If Enable_In = 0 Then
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop
        Dbms_Job.Broken(r.Job, True);
        v_Jobs := v_Jobs || ',' || r.Job;
      End Loop;
    
      If v_Jobs Is Not Null Then
        v_Jobs := Substr(v_Jobs, 2);
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1;
      End If;
    Else
      --启用
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1;
      If v_Jobs Is Not Null Then
        For R In (Select Job
                  From User_Jobs
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop
          Dbms_Job.Broken(r.Job, False);
        End Loop;
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1;
      End If;
    End If;
    --作业设置后必须提交事务才生效
    Commit;
  End Setjobstatus;
Begin
  If Parallel_In < 2 Then
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL';
  Else
    If Speedmode_In = 1 And (Func_In In (6, 7) Or Func_In In (3, 4) And Enable_In = 1) Then
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度）
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度



      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In;
    End If;
  End If;

  If Func_In = 1 Then
    --1.设置触发器
    Settriggerstatus;
  Elsif Func_In = 2 Then
    --2.设置自动作业
    Setjobstatus;
  Elsif Func_In = 3 Then
    --3.设置约束状态
    Setconstraintstatus;
  Elsif Func_In = 4 Then
    --4.设置索引状态
    Setindexstatus;
  Elsif Func_In = 5 Then
    --5.重建"待转出"索引
    For R In (Select b.Index_Name
              From zlBakTables A, User_Indexes B
              Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And b.Index_Name = b.Table_Name || '_IX_待转出'
              Union All
              Select '病案主页_IX_待转出' From Dual Where System_In = 100) Loop
      Update Zldatamovelog
      Set 当前进度 = '正在重建索引:' || r.Index_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --耗时太短，无须并行DDL
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源
      If Speedmode_In = 1 Then
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Else
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
      End If;
      Begin
        Execute Immediate v_Sql;
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
  
  Elsif Func_In = 6 Then
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间）
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.系统 = System_In And a.表名 = b.Table_Name And
                    b.Index_Name In
                    (Select Upper(Column_Value)
                     From Table(f_Str2list(v_Indexeswithtag))
                     Union
                     Select Upper(Column_Value) From Table(f_Str2list(v_Constraintswithtag)))
              Order By Index_Name) Loop
      n_Do := 0;
      If Rebscope_In = 0 Then
        If r.组号 < 5 Then
          n_Do := 1; --仅经济核算类
        End If;
      Elsif Rebscope_In = 1 Then
        If r.组号 < 5 Or r.组号 = 8 Then
          n_Do := 1; --仅经济核算类、医嘱类
        End If;
      Else
        n_Do := 1;
      End If;
    
      If n_Do = 1 Then
        Update Zldatamovelog
        Set 当前进度 = '正在重建索引:' || r.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space';
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍
        If Speedmode_In = 1 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
        Else
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
        End If;
        Begin
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源



        Exception
          When Others Then
            If SQLErrM Like 'ORA-00054%' Then
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
              Execute Immediate v_Sql;
            End If;
        End;
      End If;
    End Loop;
  
    --重组表的数据(在线转出时会影响业务的使用，所以不支持)
  Elsif Func_In = 7 And Speedmode_In = 1 Then
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组
    For R In (Select a.表名 As Table_Name
              From zlBakTables A
              Where a.直接转出 = 1 And (组号 < Decode(Rebscope_In, 0, 5, 100))
              Order By 组号, 序号) Loop
    
      Update Zldatamovelog
      Set 当前进度 = '正在重组表:' || r.Table_Name
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
    
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩
      --在前面设置了会话级的强制并行
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging';
      Execute Immediate v_Sql;
    
      --单独移动Lob对象
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' ||
                 l.Tablespace_Name || ') Nologging';
        Execute Immediate v_Sql;
      End Loop;
    
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel';
      Execute Immediate v_Sql;
    
      --move后，表相关的索引会全部失效，需要全部重建
      For S In (Select Index_Name
                From User_Indexes
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE' And
                      (Index_Name = r.Table_Name || '_IX_待转出' Or
                      Index_Name In
                      (Select Upper(Column_Value)
                        From Table(f_Str2list(v_Indexeswithtag))
                        Union
                        Select Upper(Column_Value) From Table(f_Str2list(v_Constraintswithtag))))
                Order By Index_Name) Loop
        Update Zldatamovelog
        Set 当前进度 = '正在恢复失效索引:' || s.Index_Name
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
      
        --在前面设置了会话级的强制并行
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging';
        Execute Immediate v_Sql;
      End Loop;
    End Loop;
  End If;

  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢)
  ---------------------------------------------------------------------------------------------------
  If Speedmode_In = 1 And Parallel_In > 1 And (Func_In In (6, 7) Or Func_In In (3, 4) And Enable_In = 1) Then
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL';
  
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel';
      Execute Immediate v_Sql;
    End Loop;
  End If;

  Update Zldatamovelog
  Set 当前进度 = '重建完成'
  Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In);
  Commit;
  --本过程不进行错误处理，错误由调用过程处理
End Zl1_Datamove_Reb;
/

--84458:涂建华,2015-07-06,新版Pacs报告编辑器数据转移处理
--84458:黄捷,2015-07-21,影像报告操作记录增加转出处理
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End    In Date,
  n_批次   In Number,
  n_System In Number
) As
  --功能：标记待转出的数据
  --说明：为避免Undo表空间膨胀过大，分段提交
Begin
  --1.经济核算（费用,药品,收款和票据等）

  --*****特殊处理遵义医院特殊数据:
  --病人ID为1的"医保病人",为2的"旧病人":不检查是否结清，不限制预交款未冲完的，强制转出
  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录(排除之后退号和退费的,一张单据中只要其中一行退了)
         From 门诊费用记录 A
         Where a.待转出 Is Null And a.登记时间 < d_End And a.记录性质 In (1, 4) And
               (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
         Union All
         Select Distinct a.结算id --2.医保补结算
         From 费用补充记录 A
         Where a.待转出 Is Null And a.登记时间 < d_End And a.记录性质 = 1 And
               (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 费用补充记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 In (1, 2) And b.登记时间 >= d_End))
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了)
         From 住院费用记录 A
         Where a.待转出 Is Null And a.登记时间 < d_End And a.记录性质 = 5 And a.记帐费用 = 0 And
               (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 住院费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
         Union All --4.门诊(记帐单)和住院的结帐结算记录
         Select 结帐id
         From (With Settle As (Select Distinct a.Id As 结帐id, a.病人id --3.门诊(记帐单)和住院的结帐结算记录(排除之后结帐作废的)
                               From 病人结帐记录 A
                               Where a.待转出 Is Null And a.收费时间 < d_End And
                                     (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                                      (Select 1
                                       From 病人结帐记录 B
                                       Where a.No = b.No And b.记录状态 = 2 And b.收费时间 >= d_End)))
                Select 结帐id
                From Settle
                Minus
                --1.一张预交款被多笔结帐冲完（结帐ID不同），这些结帐ID要整体排除,避免部分被转出后影响后续的计算是否冲完 
                --2.这些费用单据的结帐ID对应的可能还有其他NO的其他结帐ID(结帐作废后分多次结帐结清，可能部分在转出时间之后)，这些结帐ID要整体排除,避免部分被转出后影响后续的计算是否结清
                --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除
                Select Distinct d.Id
                From 病人结帐记录 D,
                     (Select Distinct c.病人id --多次住院可以一起结，以及门诊记帐和住院记帐可以一起结且冲同一笔预交，所以这里不加主页ID
                       From 住院费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 住院费用记录 D,
                                   (Select s.结帐id
                                     From Settle S, 病人结帐记录 E
                                     Where s.病人id = e.病人id And
                                           (e.收费时间 > d_End Or Exists (Select 1 From 在院病人 F Where s.病人id = f.病人id))) S --没有结清且之后没有再结过就成了呆帐，这种就不排除
                              Where d.结帐id = s.结帐id) D
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号 --结帐后作废后，再对包含记帐单销帐的结帐ID为空的记录,一起汇总计算是否结清,这种结帐ID为空的数据转出在后面单独转出                                        
                       Group By c.No, Mod(c.记录性质, 10), c.病人id --一张单据中的一行可部分结帐，以单据为对象来判断，避免一张单据的其中一部分被转出
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1 --排除转出时间之后再次结帐的(作废后再次结帐)，避免原始单据转走后，后续结帐时无法正确判断
                                                                                   From 住院费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And
                                                                                         Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And
                                                                                         e.结帐id = s.Id And s.收费时间 >= d_End)
                       Union All
                       Select Distinct c.病人id
                       From 门诊费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 门诊费用记录 D, Settle S
                              Where d.结帐id = s.结帐id) D --因为是门诊病人，所以，只要没有结清,该病人的都不转出
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号
                       Group By c.No, Mod(c.记录性质, 10), c.病人id
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1
                                                                                    From 门诊费用记录 E, 病人结帐记录 S
                                                                                    Where e.No = c.No And
                                                                                          Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                          e.记录性质 In (12, 13, 15) And
                                                                                          e.结帐id = s.Id And s.收费时间 >= d_End)) N
                Where d.病人id = n.病人id)
                
         
         );

  --排除预交款未冲完的和转出时间之后发药的记录
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除
  --由于可能存在数据异常(住院费用结帐冲预交类别为1的门诊预交)，所以没有加预交类别条件限定
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In
        (Select Distinct d.结帐id
         From 病人预交记录 D,
              --连接D表是为了查冲同一预交单据的其他结帐ID（退预交款，冲预交作废的，再次冲同一预交单据）
              --该病人的所有结帐ID的都不转出，避免部分冲预交的结帐ID被排除后，原始预交单被转走，或者其他结帐ID将费用单据的一部分(原始结帐、结帐作废、再次结一部分、再次结全部)转走
              (Select Distinct l.病人id
                From 病人预交记录 L, 病人预交记录 P --可能本次结帐冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID
                Where l.记录性质 In (1, 11) And l.No = p.No And p.记录性质 In (1, 11) And p.待转出 = n_批次
                Group By l.No, l.病人id
                Having Nvl(Sum(l.金额), 0) <> Nvl(Sum(l.冲预交), 0) And (Exists (Select 1
                                                                           From 病人预交记录 E
                                                                           Where l.病人id = e.病人id And e.收款时间 > d_End) Or Exists (Select 1
                                                                                                                               From 在院病人 E
                                                                                                                               Where l.病人id =
                                                                                                                                     e.病人id)) --没有冲完且之后没有再冲过或结算过就成了呆帐（存在用负的结帐补款来表示冲预交当成冲完的清况），这种就不排除 
                Or Nvl(Sum(l.金额), 0) = Nvl(Sum(l.冲预交), 0) And (Exists (Select 1
                                                                      From 病人预交记录 E, 病人结帐记录 F --排除转出时间之后的其他结帐ID冲的
                                                                      Where e.No = l.No And e.记录性质 = 11 And e.结帐id = f.Id And --冲预交时的收款时间填的是交预交款的时间，所以这里需要用其他表的时间
                                                                            f.收费时间 >= d_End) Or Exists (Select 1
                                                                                                       From 病人预交记录 E,
                                                                                                            门诊费用记录 F
                                                                                                       Where e.No = l.No And
                                                                                                             e.记录性质 = 11 And
                                                                                                             e.结帐id =
                                                                                                             f.结帐id And
                                                                                                             f.登记时间 >=
                                                                                                             d_End And
                                                                                                             f.记录性质 In
                                                                                                             (1, 4) And
                                                                                                             Nvl(f.记帐费用, 0) <> 1) Or Exists (Select 1
                                                                                                                                            From 病人预交记录 E,
                                                                                                                                                 住院费用记录 F
                                                                                                                                            Where e.No = l.No And
                                                                                                                                                  e.记录性质 = 11 And
                                                                                                                                                  e.结帐id =
                                                                                                                                                  f.结帐id And
                                                                                                                                                  f.登记时间 >=
                                                                                                                                                  d_End And
                                                                                                                                                  f.记录性质 In (5,
                                                                                                                                                             15) And
                                                                                                                                                  Nvl(f.记帐费用,
                                                                                                                                                      0) <> 1))) N
         
         Where d.病人id = n.病人id);

  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 

  --预交款没有使用就直接退了的记录(结帐ID为空)
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --冲预交款作废的记录（记录性质为2），没有结帐ID
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 2 And NO In (Select a.No From 病人预交记录 A Where a.待转出 = n_批次 And a.记录性质 = 3);

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐)
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  --挂号打折后实收金额为0的(没有对应的预交记录),即使之后有退号费用也不管，因为金额为零不影响计算),而卡费即使为零也有预交记录                 
  --根据挂号记录再找门诊费用，比直接按时间查门诊费用要快
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where NO In (Select NO From 病人挂号记录 Where 待转出 Is Null And 登记时间 < d_End) And 记录性质 = 4 And 实收金额 = 0;

  --没有结帐的已冲销的记帐单或打折后实收金额为零的，且没有其他记帐单的强制转出
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 记录性质 = 2 And
        NO In
        (Select NO
         From (Select b.挂号单, a.No, a.序号, Sum(a.实收金额)
                From 门诊费用记录 A, 病人医嘱记录 B
                Where a.医嘱序号 = b.Id And a.结帐id Is Null And a.记录性质 = 2 And b.病人来源 <> 4 And a.待转出 Is Null And a.登记时间 < d_End
                Group By a.No, a.序号, b.挂号单
                Having Sum(a.实收金额) = 0 And Not Exists (Select 1
                                                      From 门诊费用记录 C, 病人医嘱记录 D
                                                      Where b.挂号单 = d.挂号单 And d.Id = c.医嘱序号 And d.病人来源 <> 4 And c.记录性质 = 2 And
                                                            c.待转出 Is Null
                                                      Group By c.No, c.序号
                                                      Having Sum(a.实收金额) > 0)));

  --直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id
                 From 病人预交记录
                 Where 待转出 = n_批次
                 Union
                 Select ID From 病人结帐记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);

  --从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id
                 From 病人预交记录
                 Where 待转出 = n_批次
                 Union
                 Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --1.转出结帐作废后，记帐单销帐的记录（记帐状态为2且没有结帐ID且(记录状态为3的有结帐ID的)在最前面已转出）
  --2.未结帐的零费用(已冲销的记帐单)
  --3.没有结帐ID的划价记录处理为转出
  --4.不收费也没有冲预交的零费用处理为转出
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 门诊费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 门诊费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 Or 记录状态 = 0 Or 记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And
        结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --1.转出结帐作废后，记帐单销帐的记录（记帐状态为2且没有结帐ID且(记录状态为3的有结帐ID的)在最前面已转出）
  --2.未结帐的零费用(已冲销的记帐单)
  --3.没有结帐ID的划价记录处理为转出
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 Or 记录状态 = 0) And 结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --由于存在赖帐病人离院未结的情况，对于很久以前的这些数据，如果预交已冲完，则处理为要转出
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.预交类别 = 2 And b.记录性质 In (1, 11) Having
                                 Nvl(Sum(b.金额), 0) - Nvl(Sum(b.冲预交), 0) <> 0));

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists
   (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_End) And 待转出 Is Null And 剩余数量 = 0 And 登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据
  --不转出的条件：挂号费用未转出的，转出时间之后存在医嘱，医嘱对应的费用未转出的
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1
                From 门诊费用记录 A
                Where r.No = a.No And a.登记时间 < d_End And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_End) And Not Exists
          (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And r.待转出 Is Null And
               r.登记时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

  --通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人当时并未出院(一次住院多次结帐)。
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低）
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
        数据转出 Is Null And 出院日期 < d_End And
        (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单号)
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID
  --不管医嘱发送记录的执行状态，因为可能没有启用执行登记
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where ID In (Select c.病历id
               From 病人医嘱发送 A, 病人医嘱记录 B, 病人医嘱报告 C
               Where c.医嘱id = b.Id And b.Id = a.医嘱id And b.相关id Is Null And Nvl(b.主页id, 0) = 0 And b.挂号单 Is Null And
                     a.发送数次 = 1 And a.待转出 Is Null And a.发送时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径    
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);  
  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/

--84458:涂建华,2015-07-06,新版Pacs报告编辑器数据转移处理
--84458:黄捷,2015-07-21,影像报告操作记录增加转出处理
Create Or Replace Procedure Zl_Retu_Clinic
(
  n_Patiid In Number,
  v_Times  In Varchar2,
  n_Flag   In Number
) As
  --------------------------------------------
  --参数:n_Patiid,病人id
  --     v_Times,挂号单号或住院主页id（体检时，挂号单是体检单号）
  --     n_Flag,门诊或住院标志:0-门诊,1-住院,2-体检（此时，只有n_Patiid参数无效）
  --------------------------------------------
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_System     Number(5);
  n_Opersystem Number(5);
  n_只读       Number(2);

  v_Table    Varchar2(100);
  v_Subtable Varchar2(100);
  v_Field    Varchar2(100);
  v_Subfield Varchar2(100);
  v_Sql      Varchar2(4000);
  v_Fields   Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定病人ID和主页的相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Other
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  
  Begin
  
    For R In (Select Column_Value From Table(f_Str2list('病人过敏记录,病人诊断记录,病人手麻记录'))) Loop
      v_Table  := r.Column_Value;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    End Loop;
  End Zl_Retu_Other;

  --------------------------------------------
  --返回指定病人ID和主页的临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Path
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
    v_Table  := '病人临床路径';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select ID As 路径记录id From H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人路径执行,病人合并路径,病人路径评估,病人路径变异,病人路径指标,病人合并路径评估,病人出径记录'))) Loop
        v_Table := r.Column_Value;
        If v_Table = '病人合并路径' Then
          v_Field := '首要路径记录id';
        Else
          v_Field := '路径记录id';
        End If;
     
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                    ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      End Loop;
    End Loop;
  
    Delete H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Path;

  --------------------------------------------
  --返回指定病人ID和主页的护理相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Tend
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
  
    v_Table  := '病人护理文件';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID As 文件id From H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value From Table(f_Str2list('病人护理数据,病人护理打印,病人护理活动项目,病人护理要素内容,产程要素内容'))) Loop
        v_Table  := r.Column_Value;
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                    ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      
        If v_Table = '病人护理数据' Then
          v_Fields := Getfields('病人护理明细');
          v_Sql    := 'Insert Into 病人护理明细(' || v_Fields || ') Select ' || v_Fields ||
                      ' From H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        
          v_Sql := 'Delete H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        End If;
      
        v_Sql := 'Delete H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      End Loop;
    End Loop;
  
    Delete H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;


                   --老版护理系统数据
                   ------------------------------------------------------------------------
                   v_Table  := '病人护理记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
                   
                   For P In (Select ID From H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop      
        v_Table  := '病人护理内容';
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                    ' Where 记录ID = :1';
        Execute Immediate v_Sql
          Using p.ID;
      
        v_Sql := 'Delete H' || v_Table || ' Where 记录ID = :1';
        Execute Immediate v_Sql
          Using p.ID;     
    End Loop;
  
    Delete H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Tend;

  --------------------------------------------
  --返回指定ID的病人新版电子病历记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Epr(n_Rec_Id H电子病历记录.Id%Type) As
    v_Field Varchar(100);
  Begin
    v_Table  := '电子病历记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --病人诊断记录在Zl_Retu_Other中已转回（无病历ID外键）
    --影像报告驳回,病人医嘱报告,报告查阅记录,这几张表的数据在Zl_Retu_Order中转回医嘱后再处理
    For R In (Select Column_Value From Table(f_Str2list('电子病历附件,电子病历格式,电子病历内容,疾病申报记录'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '电子病历附件' Then
        v_Field := '病历id';
      Else
        v_Field := '文件id';
      End If;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '电子病历内容' Then
        v_Fields := Getfields('电子病历图形');
        v_Sql    := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = n_Rec_Id And 对象类型 = 5);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    Delete H电子病历记录 Where ID = n_Rec_Id;
  End Zl_Retu_Epr;
  --------------------------------------------
  --返回指定ID的病人医嘱记录子过程，必须在病历、临床路径转出之后执行(病人医嘱报告,影像报告驳回，病人路径医嘱)
  --在Zl_Retu_Other中已转回了"病人诊断记录",转回"病人诊断医嘱"时不用再转
  --------------------------------------------
  Procedure Zl_Retu_Order(n_Rec_Id H病人医嘱记录.Id%Type) As
  Begin
    v_Table  := '病人医嘱记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --以"医嘱ID,发送号"为外键的，都按医嘱ID直接转回，只需要排在"病人医嘱发送"之后即可
    --由于外键关系，"报告查阅记录"须在"病人医嘱报告"后面
    For P In (Select Column_Value
              From Table(f_Str2list('病人医嘱计价,病人医嘱状态,病人医嘱发送,病人医嘱附费,病人医嘱附件,病人医嘱执行,病人医嘱打印,输血申请记录,输血检验结果,' ||
                                     '医嘱执行打印,医嘱执行时间,医嘱执行计价,执行打印记录,病人诊断医嘱,病人路径医嘱,病人医嘱报告,报告查阅记录,' ||
                                     '影像报告驳回,影像报告记录,影像报告操作记录,影像检查记录,影像申请单图像,影像收藏内容,影像危急值记录,检验标本记录,检验试剂记录,检验拒收记录'))) Loop
      v_Table := p.Column_Value;
      If Instr('病人路径医嘱', v_Table) > 0 Then
        v_Field := '病人医嘱ID';
      Else
        v_Field := '医嘱ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '病人医嘱状态' Then
        v_Fields := Getfields('医嘱签名记录');
        v_Sql    := 'Insert Into 医嘱签名记录(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H医嘱签名记录 Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = :1 And 签名id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H医嘱签名记录
        Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = n_Rec_Id And 签名id Is Not Null);
      
      Elsif v_Table = '病人医嘱发送' Then
        v_Fields := Getfields('诊疗单据打印');
        v_Sql    := 'Insert Into 诊疗单据打印(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '影像检查记录' Then
        v_Fields := Getfields('影像检查序列');
        v_Sql    := 'Insert Into 影像检查序列(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('影像检查图象');
        v_Sql    := 'Insert Into 影像检查图象(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H影像检查图象 Where 序列uid In (Select b.序列uid From H影像检查记录 A, H影像检查序列 B Where a.医嘱id = :1 And a.检查uid = b.检查uid)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H影像检查图象
        Where 序列uid In (Select b.序列uid
                        From H影像检查记录 A, H影像检查序列 B
                        Where a.医嘱id = n_Rec_Id And a.检查uid = b.检查uid);
        Delete H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '检验标本记录' Then
        For R In (Select Column_Value
                  From Table(f_Str2list('检验申请项目,检验分析记录,检验项目分布,检验质控记录,检验操作记录,检验签名记录,检验图像结果'))) Loop
          v_Subtable := r.Column_Value;
          If v_Subtable = '检验签名记录' Then
            v_Subfield := '检验标本ID';
          Else
            v_Subfield := '标本ID';
          End If;
          v_Fields := Getfields(v_Subtable);
          v_Sql    := 'Insert Into ' || v_Subtable || '(' || v_Fields || ') Select ' || v_Fields || ' From H' ||
                      v_Subtable || ' Where ' || v_Subfield || ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        
          v_Sql := 'Delete H' || v_Subtable || ' Where ' || v_Subfield ||
                   ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        End Loop;
      
        v_Fields := Getfields('检验普通结果');
        v_Sql    := 'Insert Into 检验普通结果(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验药敏结果');
        v_Sql    := 'Insert Into 检验药敏结果(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H检验药敏结果 Where 细菌结果id In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验质控报告');
        v_Sql    := 'Insert Into 检验质控报告(' || v_Fields || ') Select ' || v_Fields ||
                    ' From H检验质控报告 Where 结果ID In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H检验药敏结果
        Where 细菌结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
        Delete H检验质控报告
        Where 结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
      
        Delete H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --手麻数据
    If n_Opersystem > 0 Then
      Execute Immediate 'zl24_Retu_Oper(:1)'
        Using n_Rec_Id;
    End If;
  
    Delete H病人医嘱记录 Where ID = n_Rec_Id;
  End Zl_Retu_Order;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --对基于视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From Zlbakspaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  --对基于视图的转储方案进行了只读判断.
  n_Opersystem := 0;
  Select 编号 Into n_Opersystem From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '24%';
  If n_Opersystem > 0 Then
    Begin
      Select Nvl(只读, 0) Into n_只读 From Zlbakspaces Where 系统 = n_Opersystem And 当前 = 1;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]当前没有可用的手麻子系统历史数据空间,不能继续![ZLSOFT]';
        Raise Err_Item;
    End;
    If n_只读 = 1 Then
      v_Err_Msg := '[ZLSOFT]手麻子系统历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
     Raise Err_Item;
    End If;
  End If;

  --1.门诊病人，按挂号单抽回
  If n_Flag = 0 Then
    v_Table  := '病人挂号记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where NO =:1 ';
    Execute Immediate v_Sql
      Using v_Times;
  
    For r_Other In (Select ID, 病人id From H病人挂号记录 Where NO = v_Times) Loop
      Zl_Retu_Other(r_Other.病人id, r_Other.Id);
    End Loop;
  
    For r_Epr In (Select /*+ Rule*/
                   b.Id
                  From H病人挂号记录 A, H电子病历记录 B
                  Where a.No = v_Times And a.病人id = n_Patiid And b.病人id = a.病人id And b.主页id = a.Id) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人来源 <> 4 And 病人id = n_Patiid And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    --转诊记录
    v_Table  := '病人转诊记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where NO =:1';
   Execute Immediate v_Sql
      Using v_Times;
  
    Delete H病人转诊记录 Where NO = v_Times;
    Delete H病人挂号记录 Where NO = v_Times;
  
    --2.住院病人，按病人ID和主页ID抽回
  Elsif n_Flag = 1 Then
    Zl_Retu_Other(n_Patiid, To_Number(v_Times));
    Zl_Retu_Path(n_Patiid, To_Number(v_Times));
  
    --先转病历，再转医嘱（影像报告驳回，病人医嘱报告这类又有病历又有医嘱的子表，在医嘱转回后处理）
    For r_Epr In (Select ID From H电子病历记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    Zl_Retu_Tend(n_Patiid, To_Number(v_Times));
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
    Update 病案主页 Set 数据转出 = 0 Where 病人id = n_Patiid And 主页id = To_Number(v_Times);
  
    --3.体检病人
  Elsif n_Flag = 2 Then
    Zl_Retu_Other(n_Patiid, v_Times);
  
    For r_Cpr In (Select ID From H病人医嘱记录 Where 病人来源 = 4 And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Cpr.Id);
    End Loop;
  
  End If;

  Begin
    Execute Immediate 'Update zlbakInfo  set 最后转储日期=sysdate where 系统=' || n_System;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm || ':' || v_Sql);
End Zl_Retu_Clinic;
/

--83705:余伟节,2015-07-02,字符串缓冲区太小
Create Or Replace Procedure Zl_临床路径版本_Copy
(
  源路径id_In     临床路径版本.路径id%Type,
  源版本号_In     临床路径版本.版本号%Type,
  目标路径id_In   临床路径版本.路径id%Type,
  目标版本号_In   临床路径版本.版本号%Type,
  源分支id_In     临床路径分支.Id%Type := Null,
  是否分支路径_In Number := Null,
  目标分支id_In   临床路径分支.Id%Type := Null
  --功能：复制产生新的临床路径版本
  --参数：
  --  源版本号_In：如果未指定(0或NULL)，则取最新有效的版本号
  --  目标本号_In：如果未指定(0或NULL)，则产生新的版本号
  --  是否分支路径_In：编辑分支路径时从其他分支或主路径复制路径结构,1-是，0否。
  --  目标分支ID_In:编辑分支路径时复制其他分支的结构，其他分支的ID。
) Is
  n_源版本号   临床路径版本.版本号%Type;
  n_目标版本号 临床路径版本.版本号%Type;

  n_Advice_New_Id    Number;
  n_Advice_Parent_Id Number;

  n_Step_New_Id    Number;
  n_Step_Parent_Id Number;

  n_Item_New_Id Number;

  n_Eval_New_Id Number;
  n_Eval_Old_Id Number;

  n_Mark_New_Id Number;

  n_Branch_New_Id Number;

  v_Error Varchar2(255);
  Err_Custom Exception;

  n_前一阶段序号 临床路径阶段.序号%Type;
  n_结束天数     临床路径阶段.结束天数%Type;
  v_标准住院日   临床路径分支.标准住院日%Type;
  v_继承医嘱ids  Varchar2(4000);

  --临床路径分支
  Procedure 临床路径分支_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    名称_In       临床路径分支.名称%Type := Null,
    说明_In       临床路径分支.说明%Type := Null,
    前一阶段id_In 临床路径分支.前一阶段id%Type := Null,
    标准住院日_In 临床路径分支.标准住院日%Type := Null,
    标准费用_In   临床路径分支.标准费用%Type := Null
  ) Is
  Begin
    If Nvl(源id_In, 0) <> 0 Then
      Insert Into 临床路径分支
        (ID, 路径id, 版本号, 名称, 说明, 前一阶段id, 标准住院日, 标准费用, 创建人, 创建时间)
        Select New_Id_In, 路径id_In, 版本号_In, Nvl(名称_In, 名称), 说明, 前一阶段id, 标准住院日, 标准费用, Zl_Username, Sysdate
        From 临床路径分支
        Where ID = 源id_In;
    Else
      --如果是复制主路径，则如果标准住院日超出了，自动修改。
      Insert Into 临床路径分支
        (ID, 路径id, 版本号, 名称, 说明, 前一阶段id, 标准住院日, 标准费用, 创建人, 创建时间)
        Select New_Id_In, 路径id_In, 版本号_In, 名称_In, 说明_In, 前一阶段id_In, 标准住院日_In, 标准费用_In, Zl_Username, Sysdate
        From Dual;
    End If;
  
  End;

  --临床路径阶段
  Procedure 临床路径阶段_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    New_父id_In   Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径阶段
      (ID, 路径id, 版本号, 父id, 序号, 名称, 开始天数, 结束天数, 标志, 说明, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, New_父id_In, 序号, 名称, 开始天数, 结束天数, 标志, 说明, 分支id_New_In
      From 临床路径阶段
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;
  ---临床路径项目
  Procedure 临床路径项目_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    New_阶段id_In Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径项目
      (ID, 路径id, 版本号, 阶段id, 分类, 项目序号, 项目内容, 内容要求, 执行方式, 执行者, 生成者, 项目结果, 图标id, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, New_阶段id_In, 分类, 项目序号, 项目内容, 内容要求, 执行方式, 执行者, 生成者, 项目结果, 图标id, 分支id_New_In
      From 临床路径项目
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;
  --路径医嘱内容
  Procedure 路径医嘱内容_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    New_相关id_In Number
  ) Is
  Begin
    Insert Into 路径医嘱内容
      (ID, 相关id, 序号, 期效, 诊疗项目id, 医嘱内容, 单次用量, 总给予量, 收费细目id, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质, 执行科室id, 时间方案,
       是否缺省, 是否备选, 组合项目id)
      Select New_Id_In, New_相关id_In, 序号, 期效, 诊疗项目id, 医嘱内容, 单次用量, 总给予量, 收费细目id, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托,
             执行性质, 执行科室id, 时间方案, 是否缺省, 是否备选, 组合项目id
      From 路径医嘱内容
      Where ID = 源id_In;
  End;
  --临床路径医嘱
  Procedure 临床路径医嘱_Inset
  (
    路径项目id_In Number,
    医嘱内容id_In Number
  ) Is
  Begin
    Insert Into 临床路径医嘱 (路径项目id, 医嘱内容id) Values (路径项目id_In, 医嘱内容id_In);
  End;
  --临床路径病历
  Procedure 临床路径病历_Inset
  (
    源项目id_In   Number,
    项目id_New_In Number
  ) Is
  Begin
    Insert Into 临床路径病历
      (项目id, 文件id, 原型id,名称,序号)
      Select 项目id_New_In, 文件id, 原型id,名称,序号 From 临床路径病历 Where 项目id = 源项目id_In;
  End;
  ---临床路径评估
  Procedure 临床路径评估_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    路径id_In     Number,
    版本号_In     Number,
    阶段id_In     Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
  Begin
    Insert Into 临床路径评估
      (ID, 路径id, 版本号, 阶段id, 评估类型, 分支id)
      Select New_Id_In, 路径id_In, 版本号_In, 阶段id_In, 评估类型, 分支id_New_In
      From 临床路径评估
      Where ID = 源id_In And Nvl(分支id, 0) = Nvl(分支id_Old_In, 0);
  End;

  Procedure 路径评估指标_Insert
  (
    源id_In   Number,
    New_Id_In Number,
    评估id_In Number
  ) Is
  Begin
    Insert Into 路径评估指标
      (ID, 评估id, 序号, 评估指标, 指标类型, 指标结果)
      Select New_Id_In, 评估id_In, 序号, 评估指标, 指标类型, 指标结果 From 路径评估指标 Where ID = 源id_In;
  End;
  --路径评估条件
  Procedure 路径评估条件_Insert
  (
    源评估id_In   Number,
    源指标id_In   Number,
    源项目id_In   Number,
    New_评估id_In Number,
    New_指标id_In Number,
    New_项目id_In Number
  ) Is
  Begin
    If 源指标id_In Is Null Then
      Insert Into 路径评估条件
        (评估id, 指标id, 项目id, 关系式, 条件值, 条件组合)
        Select New_评估id_In, New_指标id_In, New_项目id_In, 关系式, 条件值, 条件组合
        From 路径评估条件
        Where 评估id = 源评估id_In And 指标id Is Null And 项目id = 源项目id_In;
    Elsif 源项目id_In Is Null Then
      Insert Into 路径评估条件
        (评估id, 指标id, 项目id, 关系式, 条件值, 条件组合)
        Select New_评估id_In, New_指标id_In, New_项目id_In, 关系式, 条件值, 条件组合
        From 路径评估条件
        Where 评估id = 源评估id_In And 指标id = 源指标id_In And 项目id Is Null;
    End If;
  End;
  --临床路径阶段
  Procedure 临床路径阶段cascade_Insert
  (
    源id_In       Number,
    New_Id_In     Number,
    Old路径id_In  Number,
    New路径id_In  Number,
    Old版本号_In  Number,
    New版本号_In  Number,
    分支id_Old_In Number := Null,
    分支id_New_In Number := Null
  ) Is
    n_After   Number(10);
    n_Count   Number(10);
    n_Inherit Number;
    v_Oldid   Varchar2(4000);
    n_Start   Number(10);
    Arr_Id    t_Numlist;
  Begin
    ---临床路径评估(阶段，指标类评估条件）
    Select Max(a.Id)
    Into n_Eval_Old_Id
    From 临床路径评估 A
    Where a.路径id = Old路径id_In And a.版本号 = Old版本号_In And a.阶段id = 源id_In And a.评估类型 = 2 And
          Nvl(a.分支id, 0) = Nvl(分支id_Old_In, 0);
  
    If Nvl(n_Eval_Old_Id, 0) <> 0 Then
      Select 临床路径评估_Id.Nextval Into n_Eval_New_Id From Dual;
      临床路径评估_Insert(n_Eval_Old_Id, n_Eval_New_Id, New路径id_In, New版本号_In, New_Id_In, 分支id_Old_In, 分支id_New_In);
      ---路径评估指标
      For r_路径评估指标 In (Select ID From 路径评估指标 Where 评估id = n_Eval_Old_Id) Loop
        Select 路径评估指标_Id.Nextval Into n_Mark_New_Id From Dual;
        路径评估指标_Insert(r_路径评估指标.Id, n_Mark_New_Id, n_Eval_New_Id);
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, r_路径评估指标.Id, Null, n_Eval_New_Id, n_Mark_New_Id, Null);
      End Loop;
    End If;
    --临床路径项目
    For r_临床路径项目 In (Select ID
                     From 临床路径项目
                     Where 阶段id = 源id_In And 路径id = Old路径id_In And 版本号 = Old版本号_In And
                           Nvl(分支id, 0) = Nvl(分支id_Old_In, 0)) Loop
    
      Select 临床路径项目_Id.Nextval Into n_Item_New_Id From Dual;
      临床路径项目_Insert(r_临床路径项目.Id, n_Item_New_Id, New路径id_In, New版本号_In, New_Id_In, 分支id_Old_In, 分支id_New_In);
      ---临床路径评估（阶段评估，项目类评估条件）
      If Nvl(n_Eval_Old_Id, 0) <> 0 Then
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, Null, r_临床路径项目.Id, n_Eval_New_Id, Null, n_Item_New_Id);
      End If;
      ---临床路径病历
      临床路径病历_Inset(r_临床路径项目.Id, n_Item_New_Id);
    
      --路径医嘱内容
      For r_临床路径医嘱 In (Select b.Id
                       From 临床路径医嘱 A, 路径医嘱内容 B
                       Where a.路径项目id = r_临床路径项目.Id And a.医嘱内容id = b.Id And b.相关id Is Null) Loop
        --继承的医嘱判断
        Select Count(1) Into n_Inherit From 临床路径医嘱 Where 医嘱内容id = r_临床路径医嘱.Id;
        v_Oldid := '';
        If n_Inherit > 1 Then
          If Instr(v_继承医嘱ids, ',' || r_临床路径医嘱.Id) > 0 Then
            v_Oldid := Substr(v_继承医嘱ids, Instr(v_继承医嘱ids, ',' || r_临床路径医嘱.Id) + Length(r_临床路径医嘱.Id || ',') + 1);
            If Instr(v_Oldid, ',') > 0 Then
              v_Oldid := Substr(v_Oldid, 1, Instr(v_Oldid, ',') - 1);
            End If;
          End If;
        End If;
        If v_Oldid Is Null Then
          ---b.序号 > a.序号 and b.ID >a.ID --获取父医嘱ID大于子医嘱ID并且父医嘱序号大于子医嘱序号的记录数
          Select Count(1)
          Into n_After
          From 路径医嘱内容 A
          Where a.相关id = r_临床路径医嘱.Id And Exists
           (Select 1 From 路径医嘱内容 B Where b.Id = r_临床路径医嘱.Id And b.序号 > a.序号 And b.Id > a.Id);
        
          Select Count(1) + 1 Into n_Count From 路径医嘱内容 A Where a.相关id = r_临床路径医嘱.Id;
          Select 路径医嘱内容_Id.Nextval Bulk Collect Into Arr_Id From Dual Connect By Rownum <= n_Count;
          If n_After = 0 Then
            n_Advice_Parent_Id := Arr_Id(1);
            n_Start            := 2;
          Else
            n_Advice_Parent_Id := Arr_Id(n_Count);
            n_Start            := 1;
          End If;
        
          路径医嘱内容_Insert(r_临床路径医嘱.Id, n_Advice_Parent_Id, Null);
          If n_Inherit > 1 Then
            v_继承医嘱ids := v_继承医嘱ids || ',' || r_临床路径医嘱.Id || ':' || n_Advice_Parent_Id;
          End If;
        Else
          n_Advice_Parent_Id := To_Number(v_Oldid);
        End If;
        ---临床路径医嘱
        临床路径医嘱_Inset(n_Item_New_Id, n_Advice_Parent_Id);
        --路径医嘱内容相应子节点
        For r_路径医嘱内容 In (Select ID From 路径医嘱内容 Where 相关id = r_临床路径医嘱.Id) Loop
          If v_Oldid Is Null Then
            n_Advice_New_Id := Arr_Id(n_Start);
            n_Start         := n_Start + 1;
          
            路径医嘱内容_Insert(r_路径医嘱内容.Id, n_Advice_New_Id, n_Advice_Parent_Id);
            If n_Inherit > 1 Then
              v_继承医嘱ids := v_继承医嘱ids || ',' || r_路径医嘱内容.Id || ':' || n_Advice_New_Id;
            End If;
          Else
            --继承医嘱，未产生新的ID
            If n_Inherit > 1 Then
              If Instr(v_继承医嘱ids, ',' || r_路径医嘱内容.Id) > 0 Then
                v_Oldid := Substr(v_继承医嘱ids, Instr(v_继承医嘱ids, ',' || r_路径医嘱内容.Id) + Length(r_路径医嘱内容.Id || ',') + 1);
                If Instr(v_Oldid, ',') > 0 Then
                  v_Oldid := Substr(v_Oldid, 1, Instr(v_Oldid, ',') - 1);
                End If;
              End If;
            End If;
            n_Advice_New_Id := To_Number(v_Oldid);
          End If;
          ---临床路径医嘱
          临床路径医嘱_Inset(n_Item_New_Id, n_Advice_New_Id);
        End Loop;
      End Loop;
    End Loop;
  End;
Begin
  --确定源路径版本号
  n_源版本号 := Nvl(源版本号_In, 0);
  If n_源版本号 = 0 Then
    Select 最新版本 Into n_源版本号 From 临床路径目录 Where ID = 源路径id_In;
    If Nvl(n_源版本号, 0) = 0 Then
      v_Error := '要复制的来源临床路径中没有可用的有效版本。';
      Raise Err_Custom;
    End If;
  End If;

  --确定目标路径版本号
  n_目标版本号 := Nvl(目标版本号_In, 0);
  If n_目标版本号 = 0 Then
    Select Nvl(Max(版本号), 0) + 1 Into n_目标版本号 From 临床路径版本 Where 路径id = 目标路径id_In;
  Else
    If Nvl(是否分支路径_In, 0) = 1 Then
      --从其他分支或主路径复制时
      --记录下前一阶段序号
      Select Max(a.序号)
      Into n_前一阶段序号
      From 临床路径阶段 A, 临床路径分支 B
      Where a.Id = b.前一阶段id And b.Id = Nvl(目标分支id_In, 0);
    
      For r_目标分支 In (Select * From 临床路径分支 Where ID = Nvl(目标分支id_In, 0)) Loop
        Zl_临床路径分支_Delete(目标分支id_In);
        Select 临床路径分支_Id.Nextval Into n_Branch_New_Id From Dual;
        --先确定是否超出标准住院日
        v_标准住院日 := r_目标分支.标准住院日;
        If 源分支id_In = 0 Then
          Select Max(Nvl(结束天数, 开始天数))
          Into n_结束天数
          From 临床路径阶段
          Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And Nvl(分支id, 0) = Nvl(源分支id_In, 0);
          If Instr(v_标准住院日, '-') > 0 Then
            If Substr(v_标准住院日, Instr(v_标准住院日, '-') + 1) < n_结束天数 Then
              v_标准住院日 := Substr(v_标准住院日, 1, Instr(v_标准住院日, '-')) || n_结束天数;
            End If;
          End If;
        End If;
        临床路径分支_Insert(源分支id_In, n_Branch_New_Id, 目标路径id_In, n_目标版本号, r_目标分支.名称, r_目标分支.说明, r_目标分支.前一阶段id, v_标准住院日,
                      r_目标分支.标准费用);
      End Loop;
    Else
      --从其他路径复制或是新增版本是
      Zl_临床路径版本_Delete(目标路径id_In, 目标版本号_In);
    End If;
  End If;
  If Nvl(是否分支路径_In, 0) <> 1 Then
    --从其他路径复制或是新增版本是
    --临床路径版本
    Insert Into 临床路径版本
      (路径id, 版本号, 标准住院日, 标准费用, 版本说明, 创建人, 创建时间)
      Select 目标路径id_In, n_目标版本号, 标准住院日, 标准费用, 版本说明, Zl_Username, Sysdate
      From 临床路径版本
      Where 路径id = 源路径id_In And 版本号 = n_源版本号;
    --路径导入评估
    Select Max(ID)
    Into n_Eval_Old_Id
    From 临床路径评估
    Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 评估类型 = 1;
    If Nvl(n_Eval_Old_Id, 0) <> 0 Then
      Select 临床路径评估_Id.Nextval Into n_Eval_New_Id From Dual;
      临床路径评估_Insert(n_Eval_Old_Id, n_Eval_New_Id, 目标路径id_In, n_目标版本号, Null);
      ---路径评估指标
      For r_路径评估指标 In (Select ID From 路径评估指标 Where 评估id = n_Eval_Old_Id) Loop
        Select 路径评估指标_Id.Nextval Into n_Mark_New_Id From Dual;
        路径评估指标_Insert(r_路径评估指标.Id, n_Mark_New_Id, n_Eval_New_Id);
        ---路径评估条件
        路径评估条件_Insert(n_Eval_Old_Id, r_路径评估指标.Id, Null, n_Eval_New_Id, n_Mark_New_Id, Null);
      End Loop;
    End If;
  Else
    --从其他分支或主路径复制时
    Insert Into 临床路径分类
      (路径id, 版本号, 序号, 名称, 分支id)
      Select 目标路径id_In, n_目标版本号, 序号, 名称, n_Branch_New_Id
      From 临床路径分类
      Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And Nvl(分支id, 0) = Nvl(源分支id_In, 0);
  
    For r_临床路径阶段 In (Select ID, 序号
                     From 临床路径阶段
                     Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And 父id Is Null And Nvl(分支id, 0) = Nvl(源分支id_In, 0)
                     Order By 序号) Loop
      If Nvl(源分支id_In, 0) <> 0 Or r_临床路径阶段.序号 > n_前一阶段序号 Then
        --临床路径阶段的父级行插入
        Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
        临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null, 源分支id_In, n_Branch_New_Id);
      
        临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, 源分支id_In,
                             n_Branch_New_Id);
        --临床路径阶段的子级行
        For r_临床路径子阶段 In (Select ID
                          From 临床路径阶段
                          Where 路径id = 源路径id_In And 版本号 = n_目标版本号 And 父id = r_临床路径阶段.Id And
                                Nvl(分支id, 0) = Nvl(源分支id_In, 0)) Loop
          --生成新的阶段ID
          Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
          临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id, 源分支id_In, n_Branch_New_Id);
        
          临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, 源分支id_In,
                               n_Branch_New_Id);
        End Loop;
      End If;
    End Loop;
  End If;

  --临床路径分支
  If Nvl(源分支id_In, 0) = 0 And Nvl(目标分支id_In, 0) = 0 Then
    --新增版本时
    For r_临床路径分支 In (Select ID From 临床路径分支 Where 路径id = 源路径id_In And 版本号 = n_源版本号) Loop
      Select 临床路径分支_Id.Nextval Into n_Branch_New_Id From Dual;
      临床路径分支_Insert(r_临床路径分支.Id, n_Branch_New_Id, 目标路径id_In, n_目标版本号);
    
      Insert Into 临床路径分类
        (路径id, 版本号, 序号, 名称, 分支id)
        Select 目标路径id_In, n_目标版本号, 序号, 名称, n_Branch_New_Id
        From 临床路径分类
        Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 分支id = r_临床路径分支.Id;
    
      For r_临床路径阶段 In (Select ID
                       From 临床路径阶段
                       Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id Is Null And 分支id = r_临床路径分支.Id
                       Order By 序号) Loop
        --临床路径阶段的父级行插入
        Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
        临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null, r_临床路径分支.Id, n_Branch_New_Id);
      
        临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, r_临床路径分支.Id,
                             n_Branch_New_Id);
        --临床路径阶段的子级行
        For r_临床路径子阶段 In (Select ID
                          From 临床路径阶段
                          Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id = r_临床路径阶段.Id And 分支id = r_临床路径分支.Id) Loop
          --生成新的阶段ID
          Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
          临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id, r_临床路径分支.Id, n_Branch_New_Id);
        
          临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号, r_临床路径分支.Id,
                               n_Branch_New_Id);
        End Loop;
      End Loop;
    End Loop;
  
  End If;

  If Nvl(是否分支路径_In, 0) <> 1 Then
    --从其他路径复制或是新增版本是
    --临床路径分类
    Insert Into 临床路径分类
      (路径id, 版本号, 序号, 名称)
      Select 目标路径id_In, n_目标版本号, 序号, 名称
      From 临床路径分类
      Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 分支id Is Null;
  
    --临床路径项目
    --临床路径医嘱
    --路径医嘱内容
    --临床路径病历
    --临床路径评估
    --路径评估指标
    --路径评估条件
  
    For r_临床路径阶段 In (Select ID
                     From 临床路径阶段
                     Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id Is Null And 分支id Is Null
                     Order By 序号) Loop
      --临床路径阶段的父级行插入
      Select 临床路径阶段_Id.Nextval Into n_Step_Parent_Id From Dual;
      临床路径阶段_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 目标路径id_In, n_目标版本号, Null);
      If Nvl(源分支id_In, 0) = 0 And Nvl(目标分支id_In, 0) = 0 Then
        --新增版本时,更新前一阶段ID
        Update 临床路径分支
        Set 前一阶段id = n_Step_Parent_Id
        Where 前一阶段id = r_临床路径阶段.Id And 版本号 = n_目标版本号;
      End If;
    
      临床路径阶段cascade_Insert(r_临床路径阶段.Id, n_Step_Parent_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号);
      --临床路径阶段的子级行
      For r_临床路径子阶段 In (Select ID
                        From 临床路径阶段
                        Where 路径id = 源路径id_In And 版本号 = n_源版本号 And 父id = r_临床路径阶段.Id And 分支id Is Null) Loop
        --生成新的阶段ID
        Select 临床路径阶段_Id.Nextval Into n_Step_New_Id From Dual;
        临床路径阶段_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 目标路径id_In, n_目标版本号, n_Step_Parent_Id);
      
        临床路径阶段cascade_Insert(r_临床路径子阶段.Id, n_Step_New_Id, 源路径id_In, 目标路径id_In, 源版本号_In, n_目标版本号);
      End Loop;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床路径版本_Copy;
/


--85579:马政,2015-07-01,差价调整未保存原成本价
Create Or Replace Procedure Zl_药品库存差价调整_Insert
(
  入出类别id_In In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type,
  可用数量_In   In 药品收发记录.实际数量%Type,
  库存金额_In   In 药品收发记录.零售价%Type,
  库存差价_In   In 药品收发记录.成本价%Type,
  调整额_In     In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  供药单位id_In In 药品收发记录.供药单位id%Type := Null,
  原成本价_In   In 药品收发记录.扣率%Type := Null,
  新成本价_In   In 药品收发记录.单量%Type := Null,
  业务模式_In   In 药品收发记录.发药方式%Type := Null --0或空-库存差价调整;1-成本价调价
) Is
  v_入出系数     药品收发记录.入出系数%Type; --收发ID
  v_最大序号     药品收发记录.序号%Type;
  v_序号         药品收发记录.序号%Type;
  v_调整额       药品收发记录.差价%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_批准文号     药品库存.批准文号%Type;
  n_金额调整额   药品收发记录.零售金额%Type;
Begin
  v_入出系数 := 1;

  If 业务模式_In <> 1 Then
    Begin
      Select 上次供应商id, 上次生产日期, 批准文号
      Into n_上次供应商id, d_上次生产日期, v_批准文号
      From 药品库存
      Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
    Exception
      When Others Then
        n_上次供应商id := Null;
        d_上次生产日期 := Null;
        v_批准文号     := Null;
    End;
  
    n_金额调整额 := 0;
    If 可用数量_In = 0 Then
      n_金额调整额 := -1 * 库存金额_In;
    End If;
  
    Insert Into 药品收发记录
      (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 供药单位id, 生产日期,
       批准文号, 零售金额, 单量, 扣率)
    Values
      (药品收发记录_Id.Nextval, 1, 5, No_In, 序号_In, 库房id_In, 入出类别id_In, v_入出系数, 药品id_In, 批次_In, 产地_In, 批号_In, 效期_In, 可用数量_In,
       库存金额_In, 库存差价_In, 调整额_In, 摘要_In, 填制人_In, 填制日期_In, n_上次供应商id, d_上次生产日期, v_批准文号, n_金额调整额, 新成本价_In, 原成本价_In);
  Else
    Select Nvl(Max(序号), 0) Into v_最大序号 From 药品收发记录 Where 单据 = 5 And NO = No_In;
    v_序号 := v_最大序号 + 1;
  
    For v_药品收发记录 In (Select 库房id, 药品id, Nvl(批次, 0) 批次, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 灭菌效期
                     From 药品库存
                     Where 性质 = 1 And 药品id = 药品id_In And 实际数量 > 0) Loop
      If v_药品收发记录.实际金额 - v_药品收发记录.实际差价 <> Round(v_药品收发记录.实际数量 * 新成本价_In, 2) Then
        v_调整额 := (v_药品收发记录.实际金额 - v_药品收发记录.实际差价) - Round(新成本价_In * v_药品收发记录.实际数量, 2);
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           单量, 发药方式)
        Values
          (药品收发记录_Id.Nextval, 1, 5, No_In, v_序号, v_药品收发记录.库房id, 入出类别id_In, 供药单位id_In, v_入出系数, 药品id_In, v_药品收发记录.批次,
           v_药品收发记录.上次产地, v_药品收发记录.上次批号, v_药品收发记录.灭菌效期, v_药品收发记录.实际数量, v_药品收发记录.实际金额, v_药品收发记录.实际差价, v_调整额, 摘要_In,
           填制人_In, 填制日期_In, 新成本价_In, 1);
      
        v_序号 := v_序号 + 1;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存差价调整_Insert;
/


--84458:涂建华,2015-07-01,新Pacs报告编辑器处理
--84458:黄捷,2015-07-06, 把影像报告打印记录表修改成影像报告操作记录，调整对应的存储过程
--84458:黄捷,2015-07-08，f_Get_Personal_Info_By_Account取消对医生护士的限制
--84458:涂建华,2015-07-08,增加create type语句
--影像报告原型管理(---定义部分---)***************************************************
CREATE OR REPLACE Type t_Edits   As Object
(
  编辑人   Varchar2(64),
  编辑时间 Date,
  签名     Number(1),
  审订签名 Number(1)
)
/

CREATE Type T_EditList As Table Of T_Edits
/

CREATE Type T_RAWID As Object (ID Raw(16))
/

CREATE Type T_RAWID_ROWSET As Table Of t_Rawid
/

CREATE OR REPLACE Package b_PACS_Common Is
  Type t_Refcur Is Ref Cursor;

--1 获取参数的缓冲数据
Procedure p_GetParInfBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In  In 影像参数说明.模块%Type
  );
  
--2 功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
  Function f_Str2list
  (
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined;
  
--3  获取参数值的缓冲数据
--当前用户所在计算机的参数值
Procedure p_GetParValueBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  科室ID_In In Varchar2,
  机器名_In In Varchar2,
  用户ID_In In Number);

--4  获取权限的缓冲数据
Procedure p_GetPopedomBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_IN In 影像参数说明.模块%Type,
  用户名_In In Varchar2);

--5  设置参数值
Procedure p_SetParameterValue(
  参数ID_In    In 影像参数取值.参数ID%Type,
  参数标识_In In 影像参数取值.参数标识%Type,
  参数值_In    In 影像参数取值.参数值%Type);

--6  获取用户账号信息
Function f_Get_Personal_Info_By_Account(
	Account_In In Varchar2
) Return Xmltype;

end b_PACS_Common ;

/



--*************************************************************************************
--*                  影像报告原型管理(---实现部分---)                                                        *
--*************************************************************************************
CREATE OR REPLACE Package Body b_PACS_Common  Is

--1 获取参数的缓冲数据
Procedure p_GetParInfBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In  In 影像参数说明.模块%Type
) Is
Begin
Open  Val For
   Select RawToHex(ID) As ID,RawToHex(PID) As PID,系统,模块,参数名,默认值,参数级别,启用条件
   From 影像参数说明
   Where 系统=系统_In And 模块=模块_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_GetParInfBuf;

--2 功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined As
    v_Str Long;
    P     Number;
    --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
    --参数：Str_In,如:甲抗,胃溃疡,胃出血...,Split_In,分隔符,缺省为,号
    --说明：
    --1．当SQL语句中涉及“IN(常量1, 常量2,…) ”子句时使用这种方式以便利用绑定变量。
    --2．使用这两个函数时，需要在SQL语句中加入“/*+ Rule*/”提示，因为Cbo下临时内存表没有统计数据,。
    --3．两种调用示例
    --Select /*+ Rule*/ * From Sample_List Where Title In (Select * From Table(f_Str2list('甲抗,胃溃疡,胃出血'));
    --Select /*+ Rule*/ A.* From Sample_List A, Table(f_Str2list('甲抗,胃溃疡,胃出血')) B Where A.Title = B.Column_Value;
  Begin
    If Str_In Is Null Then
      Return;
    End If;
    v_Str := Str_In || Split_In;
    Loop
      P := Instr(v_Str, Split_In);
      Exit When(Nvl(P, 0) = 0);
      Pipe Row(Trim(Substr(v_Str, 1, P - 1)));
      v_Str := Substr(v_Str, P + 1);
    End Loop;
    Return;
  End;

--3  获取参数值的缓冲数据
--当前用户所在计算机的参数值
Procedure p_GetParValueBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  科室ID_In In Varchar2,
  机器名_In In Varchar2,
  用户ID_In In Number
) Is
Begin
	Open  Val For
	    Select RawToHex(b.ID) As ID, RawToHex(b.参数ID) As 参数ID,b.参数标识,b.参数值
		From 影像参数说明 a, 影像参数取值 b
		Where  a.id=b.参数id And a.系统=系统_In And a.模块=模块_In and (a.参数级别=0 or a.参数级别=1 or (a.参数级别=2 and b.参数标识=科室ID_In) or (a.参数级别=3 and b.参数标识=用户ID_In) or (a.参数级别=4 and b.参数标识=机器名_In));
Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
End 	p_GetParValueBuf;

--4  获取权限的缓冲数据
Procedure p_GetPopedomBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  用户名_In In Varchar2
)Is
Begin
    --返回用户, 模块号,功能
	Open  Val For
	    Select a.用户,b.系统, b.序号 as 模块, b.功能
		From zluserroles a, zlrolegrant b
		Where a.角色=b.角色 And a.用户=用户名_In And b.系统=系统_In And b.序号=模块_In;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_GetPopedomBuf;

--5  更新参数值
Procedure p_SetParameterValue(
  参数ID_In    In 影像参数取值.参数ID%Type,
  参数标识_In In 影像参数取值.参数标识%Type,
  参数值_In    In 影像参数取值.参数值%Type
)Is
Begin
	Update 影像参数取值 Set 参数值=参数值_In Where 参数ID=参数ID_In And 参数标识=参数标识_In;
	If Sql%RowCount = 0 Then
	  Insert Into 影像参数取值(ID, 参数ID,参数标识,参数值)
	  Values(sys_guid(), 参数ID_In,参数标识_In,参数值_In);
	End If;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_SetParameterValue;

--6  获取用户账号信息
Function f_Get_Personal_Info_By_Account(
	Account_In In Varchar2
) Return Xmltype Is
  Docxml   Xmltype;
Begin 
  Select Xmltype('<root></root>') Into Docxml From Dual;  
  Select Appendchildxml(Docxml, '/root',
                         Xmlconcat(Xmlelement("code", a.Id), Xmlelement("full_name", a.姓名),
                                    Xmlelement("sex", Xmlattributes(a.性别 As "display"),
                                                Decode(a.性别, '男', '1', '女', '2', '未知', '0', '9')),
                                    Xmlelement("birthday", To_Char(a.出生日期, 'yyyy-mm-dd')),
                                    Xmlelement("idcard_num", a.身份证号)))
  Into Docxml
  From 人员表 A, 上机人员表 B
  Where b.用户名 = Account_In And b.人员id = a.Id And Nvl(a.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate;  

  Select Appendchildxml(Docxml, '/root',
                         Xmlelement("departments",
                                     Xmlagg(Xmlelement("department", Xmlattributes(c.名称 As "display", d.缺省 As "current"),
                                                        Xmlelement("dept_value", c.Id)))))
  Into Docxml
  From 上机人员表 B, 部门表 C, 部门人员 D
  Where b.用户名 = Account_In And b.人员id = d.人员id And d.部门id = c.Id;

  For r_Record In (Select d.部门id, Xmlelement("subjects", Xmlagg(Xmlelement("subject", c.名称))) As 部门学科
                   From 临床部门 A, 上机人员表 B, 部门人员 D, 临床性质 C
                   Where b.用户名 = Account_In And b.人员id = d.人员id And a.部门id = d.部门id And a.工作性质 = c.编码
                   Group By d.部门id
                   Order By d.部门id) Loop
    Select Appendchildxml(Docxml, '/root/departments/department[dept_value=' || r_Record.部门id || ']', r_Record.部门学科)
    Into Docxml
    From Dual;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End f_Get_Personal_Info_By_Account;

End b_PACS_Common;

/


--*************************************************************************************
--*								   (---声明部分---)                                    *
--*************************************************************************************
Create Or Replace Package b_PACS_Config Is
  Type t_Refcur Is Ref Cursor;

  -- 功    能：获取影像字典清单
  Procedure p_GetAllDictList(
	Val			Out t_Refcur
  );

  -- 功    能：获取影像字典内容
  Procedure p_GetAllDictItems(
    Val           Out t_Refcur,
	字典ID_In	In 影像字典内容.字典ID%Type
  );

  -- 功    能：新增或修改影像字典内容
  Procedure p_EditDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	旧编号_In		In 影像字典内容.编号%Type,
	编号_In			In 影像字典内容.编号%Type,
	名称_In			In 影像字典内容.名称%Type,
	简码_In			In 影像字典内容.简码%Type,
	说明_In			In 影像字典内容.说明%Type
  );

  -- 功    能：删除影像字典内容
  Procedure p_DelDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	编号_In			In 影像字典内容.编号%Type
  );
End b_PACS_Config;
/

--*************************************************************************************
--*								   (---实现部分---)                                    *
--*************************************************************************************
Create Or Replace Package Body b_PACS_Config  Is
  -- 功    能：获取影像字典清单
  Procedure p_GetAllDictList(
	Val			Out t_Refcur
  )
  Is
	strSql varchar2(100);
  Begin
	strSql := 'select Rawtohex(ID) ID,编号,名称,说明,是否系统,分组 From 影像字典清单';
	Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllDictList;

  -- 功    能：获取影像字典内容
  Procedure p_GetAllDictItems(
    Val           Out t_Refcur,
	字典ID_In		In 影像字典内容.字典ID%Type
  )
  Is
	strSql varchar2(200);
  Begin
	strSql := 'Select Rawtohex(A.字典id) Rid, A.编号, A.名称, A.简码, A.说明 '||
			  'From 影像字典内容 A Where A.字典id = '''|| 字典ID_In ||'''';
	Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllDictItems;

  -- 功    能：新增或修改影像字典内容
  Procedure p_EditDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	旧编号_In		In 影像字典内容.编号%Type,
	编号_In			In 影像字典内容.编号%Type,
	名称_In			In 影像字典内容.名称%Type,
	简码_In			In 影像字典内容.简码%Type,
	说明_In			In 影像字典内容.说明%Type
  )
  Is
	n_Num Number;
	v_Msg Varchar2(50);
	Err	  Exception;
  Begin
	If 旧编号_In<>'-1' Then
	  Select Count(字典ID) Into n_Num From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In And 编号<>旧编号_In;
	  If n_Num > 0 Then
		v_Msg:='所属字典ID和编号重复!';
		Raise Err;
	  End IF;

	  Update 影像字典内容 A
	  Set A.编号 = 编号_In,A.名称 = 名称_In,A.简码 = 简码_In,A.说明 = 说明_In
	  Where A.字典ID = 字典ID_In And A.编号 = 旧编号_In;
	Else
	  Select Count(字典ID) Into n_Num From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In;
	  If n_Num > 0 Then
		v_Msg:='所属字典ID和编号重复!';
		Raise Err;
	  End IF;
	
	  Insert Into 影像字典内容(字典ID,编号,名称,简码,说明)
	  Values(字典ID_In,编号_In,名称_In,简码_In,说明_In);
	End If;
  Exception
	When Err Then
	  Raise_Application_Error(-20101,v_Msg);
	When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDictItem;

  -- 功    能：删除影像字典内容
  Procedure p_DelDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	编号_In			In 影像字典内容.编号%Type
  )
  Is
  Begin
	Delete From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In;
  Exception
	When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDictItem;
End b_PACS_Config;
/




Create Or Replace Package b_PACS_RptPublic Is
  Type t_Strlist Is Table Of Varchar2(4000);
  --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
  Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
    ) Return t_Strlist
    Pipelined;

  --功能:跟据传入的表名称提取表中最大的Code并递增
  Function f_Get_Nextcode(
    Tablename_In Varchar2,
    Len_In       Number := 0,
    Mount_In     Number := 0,
    Pre_In       Varchar2 := Null
    ) Return Varchar2;

  --功能：生成字符串拼音首码
  Function f_Spellcode(
    v_Instr  In Varchar2,
    v_Outnum In Integer := 10
    ) Return Varchar2;

  --错误处理中心
  Procedure zl_ErrorCenter(
    Err_Num In Number,
    Err_Msg In Varchar2
    );

 --从传入的XML中提取编辑记录
  Function f_Geteditlist(
    Content_In In Xmltype
	) Return t_Editlist;

  Function Xml2clob(
    Xml_In Xmltype
	) Return Clob;

  Function f_Getlastedit(
    Content_In In Xmltype
	) Return t_Editlist;
  
  ----拆分匿名数据
  --Function f_Disjoin_Anonym
  --(
    --Content_In    In Xmltype,
    --x_Anonym_Data Out Xmltype
  --) Return Xmltype;

  ----合并匿名数据
  --Function f_Incorporate_Anonym
  --(
    --Content_In    In Xmltype,
    --x_Anonym_Data In Xmltype
  --) Return Clob;

  --设置XML的节点值,当节点为<ele></ele>此类闭合节点时，Updatexml函数无效
  Procedure p_Set_Elementtext(
    Texture In Out Xmltype,
    Ename   In Varchar2,
    Eaname  In Varchar2,
    Eatext  In Varchar2,
    Etext   In Varchar2
    );
  --根据子文档ID提取子文档当前状态
 Function f_Get_Docstatus(
    Content_In In Xmltype
    ) Return Varchar2;

  Function f_If_Intersect(
    Str1 Varchar2,
    Str2 Varchar2
    ) Return Number;

End b_PACS_RptPublic;
/

Create Or Replace Package Body b_PACS_RptPublic Is

  Function Xml2clob(
    Xml_In Xmltype
	) Return Clob As
  Begin
    Return Xml_In.Getclobval();
  End Xml2clob;

  Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined As
    v_Str Long;
    P     Number;
    --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
    --参数：Str_In,如:甲抗,胃溃疡,胃出血...,Split_In,分隔符,缺省为,号
    --说明：
    --1．当SQL语句中涉及“IN(常量1, 常量2,…) ”子句时使用这种方式以便利用绑定变量。
    --2．使用这两个函数时，需要在SQL语句中加入“/*+ Rule*/”提示，因为Cbo下临时内存表没有统计数据,。
    --3．两种调用示例
    --Select /*+ Rule*/ * From Sample_List Where Title In (Select * From Table(f_Str2list('甲抗,胃溃疡,胃出血'));
    --Select /*+ Rule*/ A.* From Sample_List A, Table(f_Str2list('甲抗,胃溃疡,胃出血')) B Where A.Title = B.Column_Value;
  Begin
    If Str_In Is Null Then
      Return;
    End If;
    v_Str := Str_In || Split_In;
    Loop
      P := Instr(v_Str, Split_In);
      Exit When(Nvl(P, 0) = 0);
      Pipe Row(Trim(Substr(v_Str, 1, P - 1)));
      v_Str := Substr(v_Str, P + 1);
    End Loop;
    Return;
  End;

  Function f_Get_Nextcode(
    Tablename_In Varchar2,
    Len_In       Number := 0,
    Mount_In     Number := 0,
    Pre_In       Varchar2 := Null
  ) Return Varchar2 Is
    --跟据传入的表名称提取表中最大的Code并递增
    --Len_In        当指定长度时，按指定长度最大Code递增，大于表字段长度或不传时为表字段长度
    --Mount_In      当指定长度时，最大Code每位不能再进位时是否扩容长度，=0不扩容，＝1扩容 比如当前最大Code为 Z99,如果扩容则返回1A00否则返回Z99
    --递增规则：数字0123456789 字母A...Z,递增到达9或Z时前一位增长并且当前位转为0或A，如果前一个为非数字或字母则向前一位递增
    --字母全部为大写，无小写,当无指定长度Code时返回指定长度01，比如指定长度为5，则返回 00001
    v_Sql      Varchar2(100);
    v_Maxcode  Varchar2(150);
    v_Origcode Varchar2(150);
    v_Old      Varchar2(6);
    v_New      Varchar2(6);
    v_Return   Varchar2(150);
    n_Collen   Number;
    n_Length   Number;
    Err_Custom Exception;
    v_Msg Varchar2(200);
    Function f_Char_Carry(Word_In Varchar2) Return Varchar2 As
      v_Temp Varchar2(6);
      n_Asc  Number;
    Begin
      Select Ascii(Upper(Word_In)) Into n_Asc From Dual;
      If n_Asc = 57 Then
        v_Temp := '0';
      Elsif n_Asc = 90 Then
        v_Temp := 'A';
      Elsif n_Asc >= 48 And n_Asc <= 56 Or n_Asc >= 65 And n_Asc <= 89 Then
        v_Temp := Chr(Ascii(Word_In) + 1);
      Else
        v_Temp := Word_In;
      End If;
      Return v_Temp;
    End;
  Begin
    Begin
      Select Data_Length
      Into n_Collen
      From User_Tab_Cols
      Where Table_Name = Upper(Tablename_In) And Upper(Column_Name) = '编码';
    Exception
      When Others Then
        Null;
        v_Msg := '没有当前要查找的表，或表中没有【编码】字段！';
        Raise Err_Custom;
    End;
  
    --当传入长度为0或大于字段长度时取当前最大长度，否则取传入长度相当的最大编码
    If Len_In = 0 Or Len_In > n_Collen Then
      v_Sql := 'Select Max(Length(编码)) From ' || Tablename_In;
      Execute Immediate v_Sql
        Into n_Length;
    Else
      n_Length := Len_In;
    End If;
  
    If Nvl(n_Length, 0) = 0 Then
      Return '1';
    End If;
    
    If (Pre_In Is Not Null) And Length(Pre_In) >= n_Length Then
      v_Msg := '指定编码的长度应该大于前缀长度';
      Raise Err_Custom;
    End If;
  
    --查找指定前缀编码的最大值
    If Pre_In Is Not Null Then
      v_Sql := 'Select Max(编码) From ' || Tablename_In || ' Where upper(substr(code,1,length(''' || Pre_In ||
               '''))) =' || '' || 'upper(''' || Pre_In || ''')';
      Execute Immediate v_Sql
        Into v_Maxcode;
    Else
      v_Sql := 'Select Max(编码) From ' || Tablename_In || ' Where Length(编码)=' || n_Length;
      Execute Immediate v_Sql
        Into v_Maxcode;
    End If;
  
    --如果最大的code为空，那么赋值为1,前面增加0的数量由最长长度决定
    If v_Maxcode Is Null Then
      If Pre_In Is Null Then
        Select LPad('1', n_Length, '0') Into v_Maxcode From Dual;
        Return v_Maxcode;
      Else
        Select Pre_In || LPad('1', n_Length - Length(Pre_In), '0') Into v_Maxcode From Dual;
        Return v_Maxcode;
      End If;
    Else
      If Pre_In Is Null Then
        v_Maxcode  := Upper(v_Maxcode);
        v_Origcode := v_Maxcode;
      Else
        --补充为指定长度
        v_Maxcode := Upper(Pre_In || LPad(Substr(v_Maxcode, Length(Pre_In) + 1), n_Length - Length(Pre_In), '0'));
        --指定前缀时，仅以前缀后的字符串作为计算的值
        v_Origcode := Substr(v_Maxcode, Length(Pre_In) + 1);
        v_Maxcode  := v_Origcode;
      End If;
      
      For I In 0 .. Length(v_Maxcode) Loop
        If I = Length(v_Maxcode) Then
          If Len_In <> 0 And Mount_In = 0 Then
            --指定长度并且不扩容长度，已在到最大时，不再进位
            Return v_Origcode;
          Else
            v_Old := 'Z';
            v_New := '1';
          End If;
        Else
          v_Old := Substr(v_Maxcode, Length(v_Maxcode) - I, 1);
          v_New := f_Char_Carry(v_Old);
        End If;
      
        --新旧值相等表明为非数字或字母,需要向前查找
        If v_Old != v_New Then
          v_Return := Substr(v_Maxcode, 0, Length(v_Maxcode) - I - 1) || v_New ||
                      Substr(v_Maxcode, Length(v_Maxcode) - I + 1);
          If v_New != '0' And v_New != 'A' Then
            If Pre_In Is Null Then
              Return v_Return;
            Else
              Return Pre_In || v_Return;
            End If;
          Else
            --等于‘0’表明当前进位,前一位递增
            v_Maxcode := v_Return;
          End If;
        End If;
      End Loop;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

  --功能：生成字符串拼音首码
  --参数：v_Instr需要生成拼音的字符串；v_Outnum 生成首码长度，默认10，超过40个字符最大10
  Function f_Spellcode(
    v_Instr  In Varchar2,
    v_Outnum In Integer := 10
  ) Return Varchar2 Is
    v_Spell     Varchar2(40);
    v_Input     Varchar2(1000);
    v_Bitchar   Varchar2(100);
    r_Bitchar   Varchar2(100);
    v_Bitnum    Integer;
    v_Outmaxnum Integer;
    Function f_Nlssort(p_Word In Varchar2) Return Varchar2 As
    Begin
      Return Nlssort(p_Word, 'NLS_SORT=SCHINESE_PINYIN_M');
    End;
  Begin
    If v_Outnum < 1 Or v_Outnum > 40 Then
      v_Outmaxnum := 10;
    Else
      v_Outmaxnum := v_Outnum;
    End If;
  
    If v_Instr Is Null Or Length(LTrim(v_Instr)) = 0 Then
      v_Spell := '';
    Else
      v_Input := Upper(v_Instr);
      v_Spell := '';
      For v_Bitnum In 1 .. Length(v_Input) Loop
        v_Bitchar := Substr(v_Input, v_Bitnum, 1);
        r_Bitchar := f_Nlssort(v_Bitchar);
        If r_Bitchar >= f_Nlssort('吖') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'A';
        Elsif r_Bitchar >= f_Nlssort('八') And r_Bitchar <= f_Nlssort('簿') Then
          v_Spell := v_Spell || 'B';
        Elsif r_Bitchar >= f_Nlssort('嚓') And r_Bitchar <= f_Nlssort('e') Then
          v_Spell := v_Spell || 'C';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('z') Then
          v_Spell := v_Spell || 'D';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'E';
        Elsif r_Bitchar >= f_Nlssort('发') And r_Bitchar <= f_Nlssort('g') Then
          v_Spell := v_Spell || 'F';
        Elsif r_Bitchar >= f_Nlssort('旮') And r_Bitchar <= f_Nlssort('B') Then
          v_Spell := v_Spell || 'G';
        Elsif r_Bitchar >= f_Nlssort('o') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'H';
        Elsif r_Bitchar >= f_Nlssort('丌') And r_Bitchar <= f_Nlssort('h') Then
          v_Spell := v_Spell || 'J';
        Elsif r_Bitchar >= f_Nlssort('咔') And r_Bitchar <= f_Nlssort('i') Then
          v_Spell := v_Spell || 'K';
        Elsif r_Bitchar >= f_Nlssort('垃') And r_Bitchar <= f_Nlssort('^') Then
          v_Spell := v_Spell || 'L';
        Elsif r_Bitchar >= f_Nlssort('`') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'M';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'N';
        Elsif r_Bitchar >= f_Nlssort('p') And r_Bitchar <= f_Nlssort('a') Then
          v_Spell := v_Spell || 'O';
        Elsif r_Bitchar >= f_Nlssort('r') And r_Bitchar <= f_Nlssort('曝') Then
          v_Spell := v_Spell || 'P';
        Elsif r_Bitchar >= f_Nlssort('七') And r_Bitchar <= f_Nlssort('d') Then
          v_Spell := v_Spell || 'Q';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('U') Then
          v_Spell := v_Spell || 'R';
        Elsif r_Bitchar >= f_Nlssort('仨') And r_Bitchar <= f_Nlssort('R') Then
          v_Spell := v_Spell || 'S';
        Elsif r_Bitchar >= f_Nlssort('@') And r_Bitchar <= f_Nlssort('X') Then
          v_Spell := v_Spell || 'T';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('F') Then
          v_Spell := v_Spell || 'W';
        Elsif r_Bitchar >= f_Nlssort('夕') And r_Bitchar <= f_Nlssort('R') Then
          v_Spell := v_Spell || 'X';
        Elsif r_Bitchar >= f_Nlssort('丫') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'Y';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'Z';
        Elsif Instr('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.+-*/', v_Bitchar) > 0 Then
          v_Spell := v_Spell || v_Bitchar;
        Elsif Instr('ⅠⅡⅢⅣⅤⅥⅦⅧⅨ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || Chr(Ascii(v_Bitchar) - 41664);
        Elsif Instr('ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || Chr(Ascii(v_Bitchar) - 41856);
        Elsif Instr('Αα', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'A';
        Elsif Instr('Ββ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'B';
        Elsif Instr('Γγ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'G';
        End If;
        Exit When Length(v_Spell) > Nvl(v_Outmaxnum, 40) - 1;
      End Loop;
    End If;
    Return(v_Spell);
  End;

  Procedure zl_ErrorCenter(
    Err_Num In Number,
    Err_Msg In Varchar2
  ) Is
    v_Outnum Number := 0;
    v_Outmsg Varchar2(1000) := '';
    v_Temp   Varchar2(1000) := '';
  
    Cursor Cur_Ind_Cols Is
      Select Table_Name, Column_Name From All_Ind_Columns Where Instr(Err_Msg, Index_Owner || '.' || Index_Name) > 0;
  
    Cursor Cur_Con_Cols Is
      Select Table_Name, Column_Name
      From All_Cons_Columns
      Where (Owner, Constraint_Name) =
            (Select r_Owner, r_Constraint_Name
             From All_Constraints
             Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 0 And Rownum < 2);
  Begin
    If Err_Num = -1 Then
      For Row_Cols In Cur_Ind_Cols Loop
        v_Temp   := Row_Cols.Table_Name;
        v_Outmsg := v_Outmsg || '、' || Row_Cols.Column_Name;
      End Loop;
    
      v_Outmsg := '[ZLSOFT]' || v_Temp || '的(' || Substr(v_Outmsg, 2) || ')出现重复！[ZLSOFT]';
      v_Outnum := -20000;
    Elsif Err_Num = -1000 Then
      v_Outmsg := '[ZLSOFT]打开的数据表太多，必要时请系统管理员修改数据库的Open_Cursors配置。';
      v_Outnum := -20001;
    Elsif Err_Num = -1400 Or Err_Num = -1407 Then
      Select Table_Name, Column_Name
      Into v_Temp, v_Outmsg
      From All_Tab_Columns
      Where Instr(Err_Msg, '"' || Owner || '"."' || Table_Name || '"."' || Column_Name || '"') > 0 And Rownum < 2;
      v_Outmsg := '[ZLSOFT]' || v_Temp || '的(' || v_Outmsg || ')必须输入！[ZLSOFT]';
      v_Outnum := -20002;
    Elsif Err_Num = -1401 Then
      v_Outmsg := '[ZLSOFT]由于赋予的值超过了列宽限制，导致增加或更新失败。[ZLSOFT]';
      v_Outnum := -20003;
    Elsif Err_Num = -2290 Then
      Select Table_Name, Search_Condition
      Into v_Temp, v_Outmsg
      From All_Constraints
      Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 1 And Rownum < 2;
    
      If Instr(v_Outmsg, 'IS NOT NULL') > 0 Then
        v_Outmsg := '[ZLSOFT]' || v_Temp || ' 的 ' || Replace(v_Outmsg, 'IS NOT NULL', '必须输入！') || '[ZLSOFT]';
        v_Outnum := -20004;
      Else
        v_Outmsg := Err_Msg;
        v_Outnum := -20999;
      End If;
    Elsif Err_Num = -2292 Then
      Select Table_Name
      Into v_Temp
      From All_Constraints
      Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 1 And Rownum < 2;
    
      For Row_Cols In Cur_Con_Cols Loop
        v_Outmsg := v_Outmsg || '、' || Row_Cols.Column_Name;
      End Loop;
    
      v_Outmsg := '[ZLSOFT]该记录在 ' || v_Temp || ' 中已经使用,' || Chr(13) || '不能删除或修改(' || Substr(v_Outmsg, 2) || ')[ZLSOFT]';
      v_Outnum := -20005;
    Else
      v_Outmsg := Err_Msg;
      v_Outnum := -20999;
    End If;
    Raise_Application_Error(v_Outnum, Substr(v_Outmsg, 1, 100));
  End zl_ErrorCenter;

  --从文档中提取的编辑记录
  Function f_Geteditlist(
    Content_In In Xmltype
	) Return t_Editlist As
    --提取文档编辑、签名及修订记录,返回格式可能如下（独立文档SUBIID为空）：
    --  Subiid  Subaid  编辑人  编辑时间             签名 审订签名
    --  AAAAAA  AID     Null    Null                 0    0     第一条用于表示创建记录
    --  AAAAAA  AID     张险华  2012-05-31 12:01:02  1    0
    --  AAAAAA  AID     韩洪    2012-05-31 12:05:02  0    0
    --  AAAAAA  AID     韩洪    2012-05-31 12:06:02  1    1
    --  AAAAAA  AID     韩洪    2012-05-31 12:07:02  0    0
    --  AAAAAA  AID     张险华  2012-05-31 12:08:02  0    0
    --  AAAAAA  AID     张险华  2012-05-31 12:09:02  1    1
    --  BBBBBB............
    Content_c Clob;
    Xcdoc     Xmldom.Domdocument;
  
    Targetdoc Dbms_Xmldom.Domdocument;
  
    Signlist     Xmldom.Domnodelist;
    l_s          Number;
    n_Isnull     Number;
    Signname     Varchar2(64);
    Signtime     Date;
    Isaduit      Number(1);
    Xxdoc        Xmltype;
    Xaudit       Xmltype;
    Xa_Text      Xmltype;
    Textlist     Xmldom.Domnodelist;
    l_t          Number;
    Starttime    Date;
    Aftertime    Date;
    Aduitname    Varchar2(64);
    Aduittime    Date;
    Revisiontime Varchar2(20);
    Ts_Editlist  t_Editlist;
    Ta_Editlist  t_Editlist;
    r_Editlist   t_Editlist := t_Editlist();
    
    Function Sortbytime(t_e t_Editlist) Return t_Editlist Is
      Tm_List t_Editlist := t_Editlist();
    Begin
      For Rs In (Select * From Table(Cast(t_e As t_Editlist)) A Order By a.编辑时间) Loop
        Tm_List.Extend;
        Tm_List(Tm_List.Count) := t_Edits( Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
      End Loop;
      Return Tm_List;
    End Sortbytime;
    
  Begin
    If Content_In Is Null Then
      r_Editlist := t_Editlist();
      Return r_Editlist;
    End If;
    --图片可能会超过64K,单节点超过64K时Newdomdocument会宕机,Newdomdocument(clob)方式会偶尔导致"通信通道文件结束"
    Content_c := Xml2clob(Content_In);
    
    --独立文档,直接给文档赋值
    Xcdoc   := Xmldom.Newdomdocument(Content_c);
    
    Signlist    := Xmldom.Getelementsbytagname(Xcdoc, 'signature');
    l_s         := Xmldom.Getlength(Signlist);
    l_s         := Nvl(l_s, 0);
    Ts_Editlist := t_Editlist();
    
    --遍历所有签名记录
    For L In 0 .. l_s - 1 Loop
      --提取签名位；1-签名位；0-真实签名
      n_Isnull := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'isnull');
      
      If Nvl(n_Isnull, 0) = 0 Then
        --如果不是签名位，那就是一个真实签名
        --displayinfo 签名显示信息
        Signname := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'displayinfo');
        If Signname Is Not Null Then
          --“签名显示信息”不为空
          Select Substr(Signname, 1, Decode(Instr(Signname, ','), 0, Length(Signname) + 1, Instr(Signname, ',')) - 1)
          Into Signname
          From Dual;
          --signtime 签名时间
          Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'signtime');
          Signtime     := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
          --isaudit 审签标记
          Isaduit      := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'isaudit');
          Isaduit      := Nvl(Isaduit, 0);
          Ts_Editlist.Extend;
          Ts_Editlist(Ts_Editlist.Count) := t_Edits( Signname, Signtime, 1, Isaduit);
        End If;
      End If;
    End Loop;
    
    Xxdoc := Xmldom.Getxmltype(Xcdoc);
    --遍历所有以新增或删除为标记的修订记录
    --ratag 修订新增标记,取值为系统登录账号名称;  rdtag 修订删除标记,取值为系统登录账号名称
    Xa_Text     := Xxdoc.Extract('//*[@ratag!=""]|//*[@rdtag!=""]');
    Xaudit      := Xmltype('<root></root>');
    Xaudit      := Xaudit.Appendchildxml('/root', Xa_Text);
    Textlist    := Xmldom.Getchildnodes(Xmldom.Getfirstchild(Xmldom.Makenode(Xmldom.Newdomdocument(Xaudit))));
    l_t         := Xmldom.Getlength(Textlist);
    Ta_Editlist := t_Editlist();
    For L In 0 .. l_t - 1 Loop
      --ratag 修订新增标记,取值为系统登录账号名称
      Aduitname := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'ratag');
      If Nvl(Aduitname, 'a') = 'a' Then
        --从ratag取不到值，说明是删除记录
        Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'rdtime');
        Aduittime    := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
        Aduitname    := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'rdtag');
      Else
        Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'ratime');
        Aduittime    := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
      End If;
      Ta_Editlist.Extend;
      Ta_Editlist(Ta_Editlist.Count) := t_Edits( Aduitname, Aduittime, 0, 0);
    End Loop;
    --先按时间排序
    Ts_Editlist := Sortbytime(Ts_Editlist);
    Ta_Editlist := Sortbytime(Ta_Editlist);
    --虚拟第一条用于表示创建记录
    r_Editlist.Extend;
    r_Editlist(r_Editlist.Count) := t_Edits( Null,
                                            To_Date('1945-08-06 09:16:02', 'yyyy-mm-dd hh24:mi:ss'), 0, 0);
    
    --当次签名与下次签名之间被认定为修订记录,重新生成编辑列表
    For L In 1 .. Ts_Editlist.Count Loop
      Starttime := Ts_Editlist(L).编辑时间;
      If L = Ts_Editlist.Count Then
        --只是作为审订时间在两次签名时间之间的判断参照，当循环到最后一次签名时，此参照失去意义,所以赋值可以大于当前系统时间
        Aftertime := Sysdate + 1;
      Else
        Aftertime := Ts_Editlist(L + 1).编辑时间;
      End If;
      r_Editlist.Extend;
      r_Editlist(r_Editlist.Count) := Ts_Editlist(L);
      
      Aduitname := 'A';
      For N In 1 .. Ta_Editlist.Count Loop
        Aduittime := Ta_Editlist(N).编辑时间;
        If Aduittime Between Starttime And Aftertime Then
          Starttime := Aduittime;
          If Aduitname <> Ta_Editlist(N).编辑人 Then
            --不同人的修订记录或第一条修订记录
            Aduitname := Ta_Editlist(N).编辑人;
            r_Editlist.Extend;
            r_Editlist(r_Editlist.Count) := t_Edits( Aduitname, Aduittime, 0, 0);
          Else
            --同一人不同时间多处修订,只取最后一次时间
            r_Editlist(r_Editlist.Count).编辑时间 := Aduittime;
          End If;
        Elsif Aduittime>Aftertime then
          --因为修订记录经过时间排序，如果不在签名记录之间则是下次签名后的修订
          Exit;
        End If;
      End Loop;
    End Loop;
  
    If Not Xmldom.Isnull(Xcdoc) Then
      Xmldom.Freedocument(Xcdoc);
    End If;
  
    If Not Xmldom.Isnull(Targetdoc) Then
      Xmldom.Freedocument(Targetdoc);
    End If;
  
    Return r_Editlist;
  End f_Geteditlist;

  Function f_Getlastedit(
    Content_In In Xmltype
	) Return t_Editlist As
    t_List   t_Editlist := t_Editlist();
    r_List   t_Editlist := t_Editlist();
    
    Function Lastlist(
      t_e       t_Editlist
    ) Return t_Editlist Is
      Tm_List t_Editlist := t_Editlist();
    Begin
      For Rs In (Select * From Table(Cast(t_e As t_Editlist)) A  Order By a.编辑时间 Desc) Loop
        Tm_List.Extend;
        Tm_List(Tm_List.Count) := t_Edits( Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
        Return Tm_List;
      End Loop;
    End Lastlist;
    
  Begin
    Select f_Geteditlist(Content_In) Into t_List From Dual;
    r_List.Extend;
    r_List(r_List.Count) := Lastlist(t_List) (1);
    Return r_List;
  End f_Getlastedit;
  
  
  --设置XML的节点值,当节点为<ele></ele>此类闭合节点时，Updatexml函数无效
  Procedure p_Set_Elementtext(
    Texture In Out Xmltype,
    Ename   In Varchar2,
    Eaname  In Varchar2,
    Eatext  In Varchar2,
    Etext   In Varchar2
  ) Is
    --参数：     Texture 操作的XML
    --           Ename 需要设置的节点名称
    --           Eaname 需要设置的节点内属性名称，用于精确定位
    --           Eatext 需要设置的节点内属性值，用于精确定位
    --           Ttext 需要设置的元素值
    x_Dom   Xmldom.Domdocument;
    x_Nlist Xmldom.Domnodelist;
    x_Text  Xmldom.Domnode;
    x_Node  Xmldom.Domnode;
    n_Len   Number;
    v_Val   Varchar2(2000);
    Procedure Freeall Is
    Begin
      If Not Xmldom.Isnull(x_Text) Then
        Xmldom.Freenode(x_Text);
      End If;
    
      If Not Xmldom.Isnull(x_Node) Then
        Xmldom.Freenode(x_Node);
      End If;
    
      If Not Xmldom.Isnull(x_Dom) Then
        Xmldom.Freedocument(x_Dom);
      End If;
    End Freeall;
  Begin
    If Texture Is Null Then
      Return;
    End If;
  
    x_Dom   := Xmldom.Newdomdocument(Texture);
    x_Nlist := Xmldom.Getelementsbytagname(x_Dom, Ename);
    n_Len   := Xmldom.Getlength(x_Nlist);
    For I In 0 .. n_Len - 1 Loop
      If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(x_Nlist, I)), Eaname) = Eatext Then
        For J In 0 .. Xmldom.Getlength(Xmldom.Getchildnodes(Xmldom.Item(x_Nlist, I))) - 1 Loop
          x_Node := Xmldom.Item(Xmldom.Getchildnodes(Xmldom.Item(x_Nlist, I)), J);
          If Xmldom.Getnodetype(x_Node) = Xmldom.Text_Node Then
            --找到文本节点
            v_Val := Xmldom.Getnodevalue(x_Node);
            Exit;
          Else
            v_Val := Null;
          End If;
        End Loop;
      
        If v_Val Is Null Then
          x_Text := Xmldom.Makenode(Xmldom.Createtextnode(x_Dom, Etext));
          x_Text := Xmldom.Importnode(x_Dom, x_Text, True);
          x_Node := Xmldom.Appendchild(Xmldom.Item(x_Nlist, I), x_Text);
        Else
          Xmldom.Setnodevalue(x_Node, Etext);
        End If;
        Texture := Xmldom.Getxmltype(x_Dom);
        Freeall;
        Return;
      End If;
    End Loop;
  
    Freeall;
  End p_Set_Elementtext;

  --根据子文档ID提取子文档当前状态
  Function f_Get_Docstatus(
    Content_In In Xmltype
  ) Return Varchar2 Is
    n_Sign   Number;
    n_Audit  Number;
    v_Editor Varchar2(200);
    v_n      Varchar2(20);
  Begin
    For Rs In (Select *
               From Table(Cast((Select b_PACS_RptPublic.f_Geteditlist(Content_In) From Dual) As t_Editlist))
               Order By 编辑时间 Asc) Loop
      n_Sign   := Rs.签名;
      n_Audit  := Rs.审订签名;
      v_Editor := Rs.编辑人;
    End Loop;
    If n_Sign = 0 And n_Audit = 0 And v_Editor Is Null Then
      v_n := '编辑中';
    Elsif n_Sign = 1 And n_Audit = 0 Then
      v_n := '已签名';
    Elsif n_Sign = 0 And n_Audit = 0 And v_Editor Is Not Null Then
      v_n := '审订中';
    Elsif n_Sign = 1 And n_Audit = 1 Then
      v_n := '已审签';
    End If;
    Return v_n;
  End f_Get_Docstatus;

  Function f_If_Intersect
  (
    Str1 Varchar2,
    Str2 Varchar2
  ) Return Number As
    n_Num Number;
  Begin
  
    Select Count(*)
    Into n_Num
    From (Select a.Column_Value Value
           From Table(b_PACS_RptPublic.f_Str2list(Str1, ',')) A
           Intersect
           Select b.Column_Value Value From Table(b_PACS_RptPublic.f_Str2list(Str2, ',')) B);
  
    Return n_Num;
  End;

Begin
  -- Initialization
  Null;

End b_PACS_RptPublic;
/


--影像报告原型管理(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptCommon Is
  Type t_Refcur Is Ref Cursor;

  --获取预备提纲>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);

  --元素分类>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Eleclass(
    Val Out t_Refcur
	);

  --原型片段>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --原型列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_By_Id(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);

  --原型内容>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_Content(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);

  --范文清单>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Samplelist_By_Aid(
    Val           Out t_Refcur,
	Antetypelist_Id_In Varchar2,
	Condition_In       影像报告范文清单.名称%Type,
	Author_In          影像报告范文清单.作者%Type,
	Subjects_In        影像报告范文清单.学科%Type
	);

  --获取插件配置根据插件ID获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigById(
    Val           Out t_Refcur,
	Id_In 影像报告插件.ID%Type
	);

  --获取插件配置根据原型清单获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigByAId(
    Val           Out t_Refcur,
	Aid_In 影像报告原型清单.ID%Type
	);

  --获取元素>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Element(
    Val Out t_Refcur
	);

  --获取片段列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	);

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Range_List(
    Val Out t_Refcur
	);

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Combo_List(
    Val Out t_Refcur
	);

  --获取原型片段根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentDirectory_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --根据原型id获取片段数据
  Procedure p_Get_FragmentData_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --获取数据表的最后更新时间>>>>>>>>>>>>>>>>>>>>>>>>>>>
  procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
	Table_Name_In Varchar2
	);

  --获取片段列表根据上级ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Bypid(
    Val           Out t_Refcur,
	Pid_In 影像报告片段清单.上级ID%Type
	);

  --获取片段列表根据节点类型>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Byleaf(
    Val           Out t_Refcur,
	Leaf_In 影像报告片段清单.节点类型%Type
	);

  --获取值域信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Range_List_Byid(
    Val           Out t_Refcur,
	Id_In 影像报告值域清单.Id%Type
	);

  --根据元素ID获取值域ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Getelementrid_By_Eid(
    Val           Out t_Refcur,
	Eid_In 影像报告元素清单.Id%Type
	);

  --获取计量单位列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_GetMasure_UnitList(
    Val Out t_Refcur
	);

  --获取文档种类信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Doc_Kind(
    Val Out t_Refcur
	);

  --功能：获取所有学科信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Subjects(
    Val Out t_Refcur
	);

  --查看是否存在相应的编码或者名称(用于导入导出)>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exits_Doc_Kinds(
    Val           Out t_Refcur,
	编码_In      Varchar2,
	名称_In      Varchar2,
	Tablename_In Varchar2
	);

  --是否存在相同的ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exist_Id(
    Val           Out t_Refcur,
	Id_In        Number,
	Tablename_In Varchar2
	);

  --通过名称获取ID信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Id_By_Title(
    Val           Out t_Refcur,
	名称_In      Varchar2,
	Tablename_In Varchar2,
	Type_In      Varchar2
	);

  --通过简称片段清单
  procedure p_Get_FragmentSampleName(
    Val           Out t_Refcur,
	简称_In Varchar2
	);

  --更新ID对应的片段内容
  procedure p_Update_PhraseContent(
    Id_In      影像报告片段清单.ID%type,
	Name_In		影像报告片段清单.名称%Type,
	Content_In Varchar2
	);
  --获取原型ID对应的第一层片段节点
  procedure p_Get_FragmentData_LevelOne(
    Val           Out t_Refcur,
	AId_In 影像报告原型清单.ID%type
	);

  -- 获取片段的下层节点
  procedure p_GetFragmentDataListByFID(
    Val           Out t_Refcur,
	FId_In 影像报告片段清单.ID%type
	);
end b_PACS_RptCommon;
/



--*************************************************************************************
--*                  影像报告原型管理(---实现部分---)                                                        *
--*************************************************************************************
CREATE OR REPLACE Package Body b_PACS_RptCommon Is
  -- 功    能：该方法只用于演示...

  --获取预备提纲>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) As ID, a.编码, a.名称, a.说明
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --元素分类>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Eleclass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(A.ID) As ID,
             A.编码,
             A.名称,
             A.说明,
             RawToHex(A.上级ID) 上级ID
        From 影像报告元素分类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型片段>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(A.片段ID) As 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = Aid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型清单>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_By_Id(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select /*+rule*/
       RawToHex(A.ID) As ID,
       a.种类,
       a.编码,
       a.名称,
       a.说明,
       a.可否重置页面 As 页面重置,
       a.可否重置格式 As 格式重置,
       Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
       Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
       Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
       Nvl(a.控制选项, '<NULL/>') As 控制选项,
       a.创建人,
       a.创建时间,
       a.修改人,
       a.修改时间,
       a.是否禁用,
       A.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型内容>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_Content(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select Nvl(a.内容, '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Where a.Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过原型ID获得相应的范文信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Samplelist_By_Aid(
    Val           Out t_Refcur,
	Antetypelist_Id_In Varchar2,
	Condition_In       影像报告范文清单.名称%Type,
	Author_In          影像报告范文清单.作者%Type,
	Subjects_In        影像报告范文清单.学科%Type
	) As
  Begin
    --直接获取该原型下的范文列表
    If Length(Antetypelist_Id_In) > 30 Then
      Open Val For
        Select /*+rule*/
         RawToHex(A.ID) as ID,
         a.名称,
         a.作者,
         a.说明,
         a.学科,
         a.编号,
         a.标签,
         a.是否私有
          From 影像报告范文清单 A
         Where a.原型ID = Hextoraw(Antetypelist_Id_In)
           And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
               Subjects_In Is Null Or
               (a.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
               a.是否私有 = 0));
    Else
      --获得一个存在原型信息的范文树形结构
      Open Val For
        Select Distinct a.分组 As ID,
                        a.分组 As 名称,
                        '' as 说明,
                        '' As 原型ID,
                        'category' As 类型,
                        '' As 作者,
                        '' As 学科,
                        Null as 最后编辑时间,
                        '' As 标签,
                        0 As 是否私有,
                        0 As Imgindex
          From 影像报告原型清单 A
         Where a.种类 = Antetypelist_Id_In
           And Exists
         (Select ID From 影像报告范文清单 C Where c.原型ID = a.Id)
           And a.分组 Is Not Null
        Union
        Select m.*
          From (Select RawToHex(B.ID) As ID,
                       b.名称,
                       b.说明,
                       b.分组 As 原型ID,
                       'antetype' As 类型,
                       '' As 作者,
                       '' As 学科,
                       Null as 最后编辑时间,
                       '' As 标签,
                       0 As 是否私有,
                       0 As Imgindex
                  From 影像报告原型清单 B
                 Where b.种类 = Antetypelist_Id_In
                   And Exists (Select ID
                          From 影像报告范文清单 C
                         Where c.原型ID = b.Id)
                 Order By b.编码) M
        
        Union All
        Select n.*
          From (Select /*+rule*/
                 RawToHex(A.ID) As ID,
                 a.名称,
                 a.说明,
                 RawToHex(A.原型ID) As 原型ID,
                 'sample' As 类型,
                 a.作者,
                 a.学科,
                 a.最后编辑时间,
                 a.标签,
                 a.是否私有,
                 Decode(a.是否私有, 1, 2, 1) As Imgindex
                  From 影像报告范文清单 A, 影像报告原型清单 C
                 Where a.原型ID = c.Id
                   And c.种类 = Antetypelist_Id_In
                   And ((a.名称 Like '%' || Condition_In || '%' And
                       Condition_In Is Not Null) Or Condition_In Is Null)
                   And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
                       Subjects_In Is Null Or
                       (a.学科 Is Not Null And
                       b_PACS_RptPublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
                       a.是否私有 = 0))
                 Order By a.编号, a.名称) N;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取插件配置根据插件ID获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigById(
    Val           Out t_Refcur,
	Id_In 影像报告插件.ID%Type
	) As
    v_Sql Varchar2(1000);
  Begin
    If (Id_In Is Not Null) Then
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式  From 影像报告插件 T Where t.Id =:Id_In And Rownum = 1';
      
        Open Val For v_Sql
          Using Id_In;
      End;
    Else
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 From 影像报告插件 T where 是否禁用 = 0 order by t.编码';
      
        Open Val For v_Sql;
      End;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取插件配置根据原型清单获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigByAId(
    Val           Out t_Refcur,
	Aid_In 影像报告原型清单.ID%Type
	) As
    v_Sql Varchar2(1000);
  Begin
    If (Aid_In Is Not Null) Then
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 ' ||
                 ' From 影像报告插件 T ' || ' Where t.Id in ( ' ||
                 ' Select X.pluginid from 影像报告原型清单 K, ' ||
                 '  (XMLTable(''*//pluginid''  Passing K.专用插件 Columns pluginid varchar2(32) Path ''/pluginid''))  X ' ||
                 ' Where K.id=:Aid_In) And 是否禁用 = 0' || ' Union All ' ||
                 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 ' ||
                 ' From 影像报告插件 T ' || ' Where 是否禁用 = 0 And t.种类=0 ';
      
        Open Val For v_Sql
          Using Aid_In;
      End;
    Else
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 From 影像报告插件 T where 是否禁用 = 0 order by t.编码';
      
        Open Val For v_Sql;
      End;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取所有元素>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Element(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) as ID,
             RawToHex(T.分类ID) as 分类ID,
             T.编码,
             T.名称,
             T.前缀,
             T.后缀,
             T.说明,
             T.数据类型,
             T.数值形态,
             T.最小长度,
             T.最大长度,
             T.最小小数位,
             T.最大小数位,
             T.计量单位,
             Nvl(T.扩展描述, '<NULL/>') As 扩展描述,
             T.值域ID,
             T.值域种类
        From 影像报告元素清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取片段列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             t.编码,
             t.名称,
             t.说明,
             t.节点类型,
             Nvl(t.组成, '<NULL/>') As 组成,
             t.学科,
             t.标签,
             t.是否私有,
             t.作者,
             t.最后编辑时间
        From 影像报告片段清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Range_List(
    Val Out t_Refcur
	) as
  begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.分类ID) As 分类ID,
             T.编码,
             T.名称,
             T.说明,
             T.数据类型,
             T.值域种类,
             Nvl(t.值域描述, '<NULL/>') As 值域描述,
             t.最后编辑时间
        From 影像报告值域清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end;

  --获取组句列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Combo_List(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             T.编码,
             T.名称,
             T.说明,
             T.多组,
             Nvl(t.组成, '<NULL/>') As 组成,
             T.编辑人,
             T.最后编辑时间,
             T.分组
        From 影像报告组句清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取原型片段目录根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentDirectory_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select 名称,
             RawToHex(ID) As ID,
             4 as ImageIndex,
             RawToHex(上级ID) As 上级ID,
             '<NULL/>' As 组成,
             编码,
             节点类型,
             是否私有,
             作者,
             标签,
			 说明,
             学科
        From 影像报告片段清单
       Where ID In (Select ID
                      From 影像报告片段清单
                     Start With ID In (Select 片段ID
                                         From 影像报告原型片段
                                        Where 原型ID = Aid_In)
                    Connect By Prior 上级ID = ID)
       order by 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取原型片段数据根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentData_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      With TabFragmentId As
       (Select 片段ID From 影像报告原型片段 Where 原型ID = Aid_In)
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             Nvl(组成, '<NULL/>') As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单
       Where Id Not In (Select 片段ID From TabFragmentId)
       Start With ID In (Select 片段ID From TabFragmentId)
      Connect By Prior 上级ID = ID
      Union All
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             Nvl(组成, '<NULL/>') As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单
       Start With ID In (Select 片段ID From TabFragmentId)
      Connect By Prior ID = 上级ID
       order by 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取数据表的最后更新时间>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取片段列表根据上级ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Bypid(
    Val           Out t_Refcur,
	Pid_In 影像报告片段清单.上级ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             T.编码,
             T.名称,
             T.说明,
             T.节点类型,
             Nvl(T.组成, '<NULL/>') As 组成,
             T.学科,
             T.标签,
             T.是否私有,
             T.作者,
             T.最后编辑时间
        From 影像报告片段清单 T
       Where T.上级ID = Pid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过节点类型获取词句列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Byleaf(
    Val           Out t_Refcur,
	Leaf_In 影像报告片段清单.节点类型%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             T.编码,
             T.名称,
             T.说明,
             T.节点类型,
             Nvl(T.组成, '<NULL/>') As 组成,
             T.学科,
             T.标签,
             T.是否私有,
             T.作者,
             T.最后编辑时间
        From 影像报告片段清单 T
       Where t.节点类型 = Leaf_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取值域信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Range_List_Byid(
    Val           Out t_Refcur,
	Id_In 影像报告值域清单.Id%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.分类ID) As 分类ID,
             T.编码,
             T.名称,
             T.说明,
             T.数据类型,
             T.值域种类,
             Nvl(T.值域描述, '<NULL/>') As 值域描述
        From 影像报告值域清单 T
       Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --根据元素ID获取值域ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Getelementrid_By_Eid(
    Val           Out t_Refcur,
	Eid_In 影像报告元素清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(A.值域ID) As 值域ID
        From 影像报告元素清单 A
       Where a.Id = Eid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取计量单位列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_GetMasure_UnitList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, 名称, 说明, 前缀 From 影像报告计量单位;
  End p_GetMasure_UnitList;

  --获取文档种类信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Doc_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明 From 影像报告种类 A Order By a.编码;
  End;

  --功能：获取所有学科信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Subjects(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select rawtohex(b.字典id) ID, b.编号 As 编码, b.名称, b.简码, b.说明
        From 影像字典清单 A, 影像字典内容 B
       Where a.名称 = '专业学科'
         And a.Id = b.字典id
       Order By 编码;
  End;

  --查看是否存在相应的编码或者名称(用于导入导出)>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exits_Doc_Kinds(
    Val           Out t_Refcur,
	编码_In      Varchar2,
	名称_In      Varchar2,
	Tablename_In Varchar2
	) As
    v_Type Varchar2(50);
    n_Num  Number;
    v_Sql  Varchar2(100);
  Begin
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' AND 名称 =''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '1';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 <>''' ||
             编码_In || ''' AND 名称 = ''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '2';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' or 名称 =''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num = 0 Then
      v_Type := '3';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' AND 名称 <>''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '4';
    End If;
    Open Val For
      Select v_Type As Type From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --是否存在相同的ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exist_Id(
    Val           Out t_Refcur,
	Id_In        Number,
	Tablename_In Varchar2
	) As
    v_Sql Varchar2(100);
    n_Num Number;
  Begin
    v_Sql := 'select count(id) from ' || Tablename_In || ' where id=''' ||
             Id_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    Open Val For
      Select Decode(n_Num, 0, 0, 1) Num From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过名称获取ID信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Id_By_Title(
    Val           Out t_Refcur,
	名称_In      Varchar2,
	Tablename_In Varchar2,
	Type_In      Varchar2
	) As
    v_Id  Varchar2(50);
    v_Sql Varchar2(100);
  Begin
    If Type_In = '1' Then
      v_Sql := 'select id from ' || Tablename_In || ' where 名称=''' || 名称_In || '''';
    Else
      v_Sql := 'select 编码 from ' || Tablename_In || ' where 名称=''' || 名称_In || '''';
    End If;
    v_Id := '';
    Execute Immediate v_Sql
      Into v_Id;
    Open Val For
      Select v_Id ID From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过简称片段清单
  Procedure p_Get_FragmentSampleName(
	Val           Out t_Refcur,
	简称_In Varchar2
	) as
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             t.编码,
             t.名称,
             t.说明,
             t.节点类型,
             Nvl(t.组成, '<NULL/>') As 组成,
             t.学科,
             t.标签,
             t.是否私有,
             t.作者,
             t.最后编辑时间
        From 影像报告片段清单 T
      Where t.名称 LIKE '%' || 简称_In || '%';
      --Where  F_TRANS_PINYIN_CAPITAL(t.名称) LIKE '%' || 简称_In || '%';
  End p_Get_FragmentSampleName;

  --更新ID对应的片段内容
  Procedure p_Update_PhraseContent(
	Id_In      影像报告片段清单.ID%Type,
	Name_In		影像报告片段清单.名称%Type,
	Content_In Varchar2
	) as
  Begin
    Update 影像报告片段清单 t 
	Set t.组成 = Content_In, t.名称=Name_In 
	Where t.id = Id_In;
  End p_Update_PhraseContent;

  --获取原型ID对应的第一层片段节点
  Procedure p_Get_FragmentData_LevelOne(
	Val           Out t_Refcur,
	AId_In 影像报告原型清单.ID%Type
	) as
  Begin
    Open Val For
      With TabFragmentId As
       (Select 片段ID From 影像报告原型片段 Where 原型ID = Aid_In)
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             Nvl(组成, '<NULL/>') As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单
       Where Id In (Select 片段ID From TabFragmentId);
  
  End p_Get_FragmentData_LevelOne;

  -- 获取片段的下层节点
  Procedure p_GetFragmentDataListByFID(
	Val           Out t_Refcur,
	FId_In 影像报告片段清单.ID%Type
	) as
  Begin
    Open Val For
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             Nvl(组成, '<NULL/>') As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单
       Where 上级ID = FId_In;
  End p_GetFragmentDataListByFID;

End b_PACS_RptCommon;

/


   --影像报告参数---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptParam Is
  Type t_Refcur Is Ref Cursor;

  --功能1：获得活动的参数列表
  Procedure p_GetPrograms(
    Val Out t_Refcur
	);
  --功能2：通过模块号获取影像参数信息
  Procedure p_GetParamByQum(
    Val           Out t_Refcur,
	模块_In 影像参数说明.模块%Type
	);
  --功能3：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue(
    Val           Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能4：获得部门信息
  Procedure p_GetDepart(
    Val Out t_Refcur
	);
  --功能5：获得人员信息
  Procedure p_GetUsersInfo(
    Val Out t_Refcur
	);
  --功能6：获得机器名信息
  Procedure p_GetMachinesInfo(
    Val Out t_Refcur
	);
  --功能7：获取所有的影像参数信息
  Procedure p_GetAllParam(
    Val Out t_Refcur
	);
  --功能8：获得所有部门的所有的参数取值信息
  Procedure p_GetValueAllDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能9：得ID对应部门的所有的参数取值信息
  Procedure p_GetValueByDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	部门ID_In 部门表.ID%Type
	);
  --功能9：获取所有的用户对应的参数值
  Procedure p_GetValueAllUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能10：获取用户ID对应的参数信息
  Procedure p_GetValueByUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	用户ID_In 人员表.ID%Type
	);
  --功能11：获取所有的工作站对应的参数值
  Procedure p_GetValueAllMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能12：获取工作站名称对应的参数信息
  Procedure p_GetValueByMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	机器名_In zlclients.工作站%Type
	);
  --功能13：添加参数信息
  Procedure p_AddParamValue(
    ID_In       影像参数取值.ID%Type,
    参数ID_In   影像参数取值.参数ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	);

  --功能14：修改参数信息
  Procedure p_EditParamValue(
    ID_In       影像参数取值.ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	);

  --功能15:通过ID获得参数信息
  Procedure p_GetParamByID(
    Val Out t_Refcur,
	ID_In 影像参数说明.ID%Type
	);
  --功能16：修改ID对应的参数级别
  Procedure p_ChangeAdjustByID(
    ID_In     影像参数说明.ID%Type,
	Adjust_In 影像参数说明.参数级别%Type
	);
  --功能17：获得对应参数标识的参数取值信息
  Procedure p_GetValueBySign(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能18：修改ID对应的参数信息的默认值
  Procedure p_EditDaultValue(
    ID_In     影像参数说明.ID%Type,
	默认值_In 影像参数说明.默认值%Type);

  --功能19：通过部门获得人员信息
  Procedure p_GetUserByDID(
    Val Out t_Refcur,
	DID_In 部门人员.部门ID%Type
	);
  --功能21:通过ID获得参数取值
  Procedure p_GetParamValueByCID(
    Val Out t_Refcur,
	CID_In 影像参数取值.参数ID%Type
	);
  --功能22:通过ID获得模块号的参数取值
  Procedure p_GetValueLevel0(
    Val Out t_Refcur,
	参数ID_In   影像参数取值.参数ID%Type,
	参数标识_In 影像参数取值.参数标识%Type
	);
end b_PACS_RptParam;
/

--影像报告参数---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptParam Is
  --create by hwei;

  --功能1：获得活动的参数列表
  Procedure p_GetPrograms(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 序号, 标题, Decode(A.标题, '', 序号, 序号 || '-' || 标题) 名称
        From (Select Distinct (t.模块) 序号,
                              (Select y.标题
                                 From zlprograms y
                                Where to_char(y.序号) = t.模块) 标题
                From 影像参数说明 t) A;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetPrograms;
  --功能2：通过模块号获取影像参数信息
  Procedure p_GetParamByQum(
    Val Out t_Refcur,
	模块_In 影像参数说明.模块%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明,
             '― ―' 参数值
        From 影像参数说明 t
       Where t.模块 = 模块_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamByQum;

  --功能3：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
    paramPiont nvarchar2(50);
    paramLevel Number := -1;
    paramCount Number := -1;
  Begin
    Select a.参数级别
      Into paramLevel
      From 影像参数说明 a
     Where a.id = 参数ID_In
       And rownum <= 1;
    If paramLevel = 1 Then
      Select count(t.id)
        Into paramCount
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      IF paramCount <> 0 THEN
        Select t.参数标识
          Into paramPiont
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
      End If;
      IF paramCount <> 0 And
         Replace(translate(paramPiont, '0123456789', '0'), '0', '') IS NULL THEN
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 (Select a.标题
                    From zlprograms a
                   Where a.序号 = t.参数标识
                     And rownum <= 1) As 标识名称,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      Else
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 t.参数标识 As 标识名称,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      End If;
    Elsif paramLevel = 2 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               (Select a.名称 From 部门表 a Where a.id = t.参数标识) as 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Elsif paramLevel = 3 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               (Select a.姓名
                  From 人员表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Else
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               t.参数标识 As 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValue;

  --功能4：获得部门信息
  Procedure p_GetDepart(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID, 上级ID, t.编码, t.名称 from 部门表 t Order by t.名称;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDepart;
  --功能5：获得人员信息
  Procedure p_GetUsersInfo(Val Out t_Refcur) As
  Begin
    Open Val For
      Select ID, t.编号, t.姓名, t.简码, t.身份证号
        From 人员表 t
       Order by t.姓名;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetUsersInfo;

  --功能6：获得机器名信息
  Procedure p_GetMachinesInfo(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.工作站, t.ip, t.部门 From zlclients t Order by t.工作站;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMachinesInfo;

  --功能7：获取所有的影像参数信息
  Procedure p_GetAllParam(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明
        From 影像参数说明 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllParam;
  --功能8：获得所有部门的所有的参数取值信息
  Procedure p_GetValueAllDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.id, t.参数id, t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllDepart;

  --功能9：得ID对应部门的所有的参数取值信息
  Procedure p_GetValueByDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	部门ID_In 部门表.ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 部门表 s
       Where s.id = 部门ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByDepart;

  --功能9：获取所有的用户对应的参数值
  Procedure p_GetValueAllUser(
    Val Out t_Refcur,
    参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 人员表 s;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllUser;

  --功能10：获取用户ID对应的参数信息
  Procedure p_GetValueByUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	用户ID_In 人员表.ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 人员表 s
       Where s.id = 用户ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByUser;

  --功能11：获取所有的工作站对应的参数值
  Procedure p_GetValueAllMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.工作站 As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) As 参数值
        From zlclients s;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllMachine;

  --功能12：获取工作站名称对应的参数信息
  Procedure p_GetValueByMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	机器名_In zlclients.工作站%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) as ID,
             RawToHex(参数ID_In) as 参数ID,
             s.工作站 as 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) as 参数值
        From zlclients s
       Where s.工作站 = 机器名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByMachine;
  --功能13：添加参数信息
  Procedure p_AddParamValue(
    ID_In       影像参数取值.ID%Type,
    参数ID_In   影像参数取值.参数ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	) As
  Begin
    Insert Into 影像参数取值 t
      (ID, 参数ID, 参数标识, 参数值)
    ValueS
      (ID_In, 参数ID_In, 参数标识_In, 参数值_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddParamValue;

  --功能14：修改参数信息
  Procedure p_EditParamValue(
    ID_In       影像参数取值.ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	) As
  Begin
    Update 影像参数取值 t
       Set 参数标识 = 参数标识_In, 参数值 = 参数值_In
     Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditParamValue;
  --功能15:通过ID获得参数信息
  Procedure p_GetParamByID(
    Val Out t_Refcur,
	ID_In 影像参数说明.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明
        From 影像参数说明 t
       Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamByID;
  --功能16：修改ID对应的参数级别
  Procedure p_ChangeAdjustByID(
    ID_In     影像参数说明.ID%Type,
	Adjust_In 影像参数说明.参数级别%Type) As
  Begin
    Delete From 影像参数取值 a Where a.参数id = ID_In;
    Update 影像参数说明 t Set t.参数级别 = Adjust_In Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_ChangeAdjustByID;

  --功能17：获得对应参数标识的参数取值信息
  Procedure p_GetValueBySign(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.id, t.参数id, t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueBySign;

  --功能18：修改ID对应的参数信息的默认值
  Procedure p_EditDaultValue(
    ID_In     影像参数说明.ID%Type,
	默认值_In 影像参数说明.默认值%Type) As
  Begin
    Update 影像参数说明 t Set t.默认值 = 默认值_In Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDaultValue;

  --功能19：通过部门获得人员信息
  Procedure p_GetUserByDID(
    Val Out t_Refcur,
	DID_In 部门人员.部门ID%Type
	) As
  Begin
    Open Val For
      Select ID, t.编号, t.姓名, t.简码, t.身份证号
        From 人员表 t
       Where t.id In
             (Select a.人员id From 部门人员 a Where a.部门id = DID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetUserByDID;
  --功能20：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue1(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
    paramLevel number := -1;
    paramPiont nvarchar2(50);
    paramCount number := -1;
  Begin
    Select a.参数级别
      Into paramLevel
      From 影像参数说明 a
     Where a.id = 参数ID_In
       And rownum <= 1;
    If paramLevel = 1 then
      Select Count(t.id)
        into paramCount
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      Select t.参数标识
        into paramPiont
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      IF paramCount <> 0 and
         Replace(translate(paramPiont, '0123456789', '0'), '0', '') IS NULL THEN
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 (Select a.标题
                    From zlprograms a
                   Where a.序号 = t.参数标识
                     And rownum <= 1) As 参数标识,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      Else
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      End if;
    Elsif paramLevel = 2 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               (Select a.名称
                  From 部门表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Elsif paramLevel = 3 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               (Select a.姓名
                  From 人员表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Else
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValue1;
  --功能21:通过ID获得参数取值
  Procedure p_GetParamValueByCID(
    Val Out t_Refcur,
	CID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = CID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValueByCID;

  --功能22:通过ID获得模块号的参数取值
  Procedure p_GetValueLevel0(
    Val Out t_Refcur,
	参数ID_In   影像参数取值.参数ID%Type,
	参数标识_In 影像参数取值.参数标识%Type
	) As
  Begin
    Open Val For
      Select t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In
         And t.参数标识 = 参数标识_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueLevel0;
End b_PACS_RptParam;
/


	--影像报告元素值域(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptElement Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  Procedure p_GetElementClassList(
    Val Out t_Refcur
	);

  --2.功  能：新增影像报告元素分类信息
  Procedure p_AddElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	);

  --3.功  能：修改影像报告元素分类信息
  Procedure p_EditElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	);

  --4.功  能：删除影像报告元素分类信息
  Procedure p_DelelEmentClass(
    ID_In In 影像报告元素分类.ID%Type
	);

  --5.功  能：获得分类对应的影像报告值域信息列表
  Procedure p_GetRangeByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告值域清单.分类ID%Type
	);

  --6.功  能：获得ID对应的影像报告值域信息
  Procedure p_GetRangeByID(
    Val           Out t_Refcur,
	ID_In In 影像报告值域清单.ID%Type
	);

  --7.功  能：新增影像报告值域信息
  Procedure p_AddRange(
    ID_In          In 影像报告值域清单.ID%Type,
	分类ID_In    In 影像报告值域清单.分类ID%Type,
	编码_In       In 影像报告值域清单.编码%Type,
	名称_In       In 影像报告值域清单.名称%Type,
	说明_In       In 影像报告值域清单.说明%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	值域描述_In In Varchar2);

  --8.功  能：修改影像报告值域信息
  Procedure p_EditRange(
    ID_In         In 影像报告值域清单.ID%Type,
	分类ID_In   In 影像报告值域清单.分类ID%Type,
	编码_In       In 影像报告值域清单.编码%Type,
	名称_In       In 影像报告值域清单.名称%Type,
	说明_In       In 影像报告值域清单.说明%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	值域描述_In In Varchar2
	);

  --9.功  能：删除影像报告值域信息
  Procedure p_DelRange(
    ID_In In 影像报告值域清单.ID%Type
	);

  --10.功  能：获得分类对应的影像报告元素列表
  Procedure p_GetElementByClass(
    Val           Out t_Refcur,
    分类ID_In In 影像报告元素清单.分类ID%Type
	);

  --11.功  能：获得ID对应的影像报告元素信息
  Procedure p_GetElementByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素清单.ID%Type
	);

  --12.功 能：新增影像报告元素信息
  Procedure p_AddElement(
    ID_In           In 影像报告元素清单.ID%Type,
	分类ID_In     In 影像报告元素清单.分类ID%Type,
	编码_In         In 影像报告元素清单.编码%Type,
	名称_In         In 影像报告元素清单.名称%Type,
	说明_In         In 影像报告元素清单.说明%Type,
	前缀_In         In 影像报告元素清单.前缀%Type,
	后缀_In         In 影像报告元素清单.后缀%Type,
	数据类型_In   In 影像报告元素清单.数据类型%Type,
	数值形态_In   In 影像报告元素清单.数值形态%Type,
	最小长度_In   In 影像报告元素清单.最小长度%Type,
	最大长度_In   In 影像报告元素清单.最大长度%Type,
	最小小数位_In In 影像报告元素清单.最小小数位%Type,
	最大小数位_In In 影像报告元素清单.最大小数位%Type,
	计量单位_In   In 影像报告元素清单.计量单位%Type,
	扩展描述_In   In Varchar2,
	值域ID_In      In 影像报告元素清单.值域ID%Type,
	值域种类_In   In 影像报告元素清单.值域种类%Type
	);

  --13.功 能：修改影像报告元素信息
  Procedure p_EditElement(
    ID_In         In 影像报告元素清单.ID%Type,
	分类ID_In     In 影像报告元素清单.分类ID%Type,
	编码_In       In 影像报告元素清单.编码%Type,
	名称_In       In 影像报告元素清单.名称%Type,
	前缀_In       In 影像报告元素清单.前缀%Type,
    后缀_In       In 影像报告元素清单.后缀%Type,
    说明_In       In 影像报告元素清单.说明%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In   In 影像报告元素清单.计量单位%Type,
    扩展描述_In   In Varchar2,
    值域ID_In     In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	);

  --14.功 能：删除影像报告元素信息
  Procedure p_DelElement(
    ID_In 影像报告元素清单.ID%Type
	);

  --15.功 能：通过ID获取影像报告分类信息
  Procedure p_GetElementClassByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素分类.ID%Type
	);
  --16.功  能：获取元素的下一个编码
  Procedure p_Get_ElementNextCode(
    Val Out t_Refcur
	);
  --17.功  能：获取元素分类的下一个编码
  Procedure p_Get_ElementClassNextCode(
    Val Out t_Refcur
	);
  --18.功  能：获取对应的值域类型所在的元素类别
  Procedure p_Get_ElementClassByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	);
  --19.功  能：获取值域类型对应的值域信息
  Procedure p_Get_RangeByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	);
  --20.功  能：获取对应的值域类型和数据类型所在的元素类别
  Procedure p_Get_ElementClassByKindType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	);
  --21.功  能：获取值域类型和数据类型对应的值域信息
  Procedure p_Get_RangeByKindAndType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	);
  --22.功 能：获取最后修改影像报告元素分类信息
  Procedure p_GetElementClassLastID(
    Val Out t_Refcur
	);
  --23.功 能：获取编辑人对应的最后修改影像报告元素信息ID
  Procedure p_GetElementLastID(
    Val Out t_Refcur
	);
  --24.功 能：获取最后修改影像报告值域信息ID
  Procedure p_GetRangeLastID(
    Val Out t_Refcur
	);
  --25.功 能：添加计量单位信息
  Procedure p_AddMasure_Unit(
    编码_In 影像报告计量单位.编码%Type,
    名称_In 影像报告计量单位.名称%Type,
    说明_In 影像报告计量单位.说明%Type,
    前缀_In 影像报告计量单位.前缀%Type
	);
  --26.功  能：修改计量单位
  Procedure p_EditMasure_Unit(
    原编码_In 影像报告计量单位.编码%Type,
    编码_In   影像报告计量单位.编码%Type,
    名称_In   影像报告计量单位.名称%Type,
    说明_In   影像报告计量单位.说明%Type,
    前缀_In   影像报告计量单位.前缀%Type
	);
  --27.功  能：删除计量单位
  Procedure p_DelMasure_Unit(
    编码_In 影像报告计量单位.编码%Type
	);
  --28.功  能：判断计量单位的编码是否已存在
  Procedure p_If_Exist_Masure_Unit(
    Val           Out t_Refcur,
	编码_In 影像报告计量单位.编码%Type
	);
  --29.功  能： 判断元素编码是否已存在
  Procedure p_If_Exist_ElementCode(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	编码_In 影像报告元素清单.编码%Type
	);
  --30.功  能： 判断元素名称是否已存在
  Procedure p_If_Exist_ElementName(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	名称_In 影像报告元素清单.名称%Type
	);
  --31.功  能： 判断值域编码是否已存在
  Procedure p_If_Exist_RangeCode(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	编码_In 影像报告值域清单.编码%Type
	);
  --32.功  能： 判断值域标题是否已存在
  Procedure p_If_Exist_RangeName(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	名称_In 影像报告值域清单.名称%Type
	);
  --33.获得元素列表
  Procedure p_GetElementList(
    Val Out t_Refcur
	);
  --34.获得值域列表
  Procedure p_GetRangeList(
    Val Out t_Refcur
	);
  --35.判断元素分类的标题和编码是否存在
  Procedure p_If_Exist_ElementClass(
    Val           Out t_Refcur,
	ID_In   影像报告元素分类.ID%Type,
	编码_In 影像报告元素分类.编码%Type,
	名称_In 影像报告元素分类.名称%Type
	) ;
    --36.判断该元素分类下面是否有值域或者元素
  Procedure p_Is_CanDel_ElementClass(
    Val           Out t_Refcur,
	ID_In 影像报告元素分类.ID%Type
	);
End b_PACS_RptElement;
/

	--影像报告元素值域(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptElement Is

  --1.功   能：获取全部的影像报告元素分类
  Procedure p_GetElementClassList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(上级ID) 上级ID,
             编码,
             名称,
             '[' || 编码 || ']' || 名称 As 标题,
             说明,
             最后编辑时间
        From 影像报告元素分类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassList;

  --2.功  能：新增影像报告元素分类信息
  Procedure p_AddElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	) As
  Begin
    Insert Into 影像报告元素分类
      (ID, 编码, 名称, 说明, 最后编辑时间,上级ID)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, Sysdate,上级ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddElementClass;

  --3.功  能：修改影像报告元素分类信息
  Procedure p_EditElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	) As
  Begin
    Update 影像报告元素分类
       Set 编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           最后编辑时间 = Sysdate,
           上级ID=上级ID_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditElementClass;

  --4.功  能：删除影像报告元素分类信息
  Procedure p_DelelEmentClass(
    ID_In In 影像报告元素分类.ID%Type
	) As
  Begin
    Delete From 影像报告元素分类 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelelEmentClass;

  --5.功  能：获得分类对应的影像报告值域信息列表
  Procedure p_GetRangeByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告值域清单.分类ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             说明,
             数据类型,
             值域种类,
             Nvl(t.值域描述, '<NULL/>') As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t
       Where 分类ID = 分类ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeByClass;

  --6.功  能：获得ID对应的影像报告值域信息
  Procedure p_GetRangeByID(
    Val           Out t_Refcur,
	ID_In In 影像报告值域清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             '[' || 编码 || ']' || 名称 标题,
             说明,
             数据类型,
             值域种类,
             Nvl(t.值域描述, '<NULL/>') As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeByID;

  --7.功  能：新增影像报告值域信息
  Procedure p_AddRange(
    ID_In       In 影像报告值域清单.ID%Type,
	分类ID_In   In 影像报告值域清单.分类ID%Type,
    编码_In     In 影像报告值域清单.编码%Type,
    名称_In     In 影像报告值域清单.名称%Type,
    说明_In     In 影像报告值域清单.说明%Type,
    数据类型_In In 影像报告值域清单.数据类型%Type,
    值域种类_In In 影像报告值域清单.值域种类%Type,
    值域描述_In In Varchar2
	) As
  Begin
    Insert Into 影像报告值域清单
      (ID, 分类ID, 编码, 名称, 说明, 数据类型, 值域种类, 值域描述, 最后编辑时间)
    Values
      (ID_In, 分类ID_In, 编码_In, 名称_In, 说明_In, 数据类型_In, 值域种类_In, 值域描述_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddRange;

  --8.功  能：修改影像报告值域信息
  Procedure p_EditRange(
    ID_In       In 影像报告值域清单.ID%Type,
    分类ID_In   In 影像报告值域清单.分类ID%Type,
    编码_In     In 影像报告值域清单.编码%Type,
    名称_In     In 影像报告值域清单.名称%Type,
    说明_In     In 影像报告值域清单.说明%Type,
    数据类型_In In 影像报告值域清单.数据类型%Type,
    值域种类_In In 影像报告值域清单.值域种类%Type,
    值域描述_In In Varchar2
	) As
  Begin
    Update 影像报告值域清单
       Set 分类ID       = 分类ID_In,
           编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           数据类型     = 数据类型_In,
           值域种类     = 值域种类_In,
           值域描述     = 值域描述_In,
           最后编辑时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditRange;

  --9.功  能：删除影像报告值域信息
  Procedure p_DelRange(
    ID_In In 影像报告值域清单.ID%Type
	) As
  Begin
    Delete From 影像报告值域清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelRange;

  --10.功  能：获得分类对应的影像报告元素列表
  Procedure p_GetElementByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告元素清单.分类ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             前缀,
             后缀,
             说明,
             数据类型,
             数值形态,
             最小长度,
             最大长度,
             最小小数位,
             最大小数位,
             计量单位,
             Nvl(t.扩展描述, '<NULL/>') As 扩展描述,
             RawToHex(值域ID) 值域ID,
             值域种类,
             最后编辑时间
        From 影像报告元素清单 t
       Where 分类ID = 分类ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementByClass;

  --11.功  能：获得ID对应的影像报告元素信息
  Procedure p_GetElementByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             前缀,
             后缀,
             说明,
             数据类型,
             数值形态,
             最小长度,
             最大长度,
             最小小数位,
             最大小数位,
             计量单位,
             Nvl(t.扩展描述, '<NULL/>') As 扩展描述,
             RawToHex(值域ID) 值域ID,
             值域种类,
             最后编辑时间
        From 影像报告元素清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementByID;

  --12.功 能：新增影像报告元素信息
  Procedure p_AddElement(
    ID_In            In 影像报告元素清单.ID%Type,
    分类ID_In     In 影像报告元素清单.分类ID%Type,
    编码_In         In 影像报告元素清单.编码%Type,
    名称_In         In 影像报告元素清单.名称%Type,
    说明_In         In 影像报告元素清单.说明%Type,
    前缀_In         In 影像报告元素清单.前缀%Type,
    后缀_In         In 影像报告元素清单.后缀%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In   In 影像报告元素清单.计量单位%Type,
    扩展描述_In   In Varchar2,
    值域ID_In      In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	) As
  Begin
    Insert Into 影像报告元素清单
      (ID, 分类ID, 编码, 名称,  前缀, 后缀, 说明,  数据类型,  数值形态,  最小长度,  最大长度,
       最小小数位,  最大小数位,  计量单位,   扩展描述, 值域ID,  值域种类, 最后编辑时间)
    Values
      (ID_In, 分类ID_In, 编码_In, 名称_In, 前缀_In, 后缀_In, 说明_In, 数据类型_In, 数值形态_In, 最小长度_In, 最大长度_In,
       最小小数位_In, 最大小数位_In, 计量单位_In, 扩展描述_In, 值域ID_In, 值域种类_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddElement;

  --13.功 能：修改影像报告元素信息
  Procedure p_EditElement(
    ID_In           In 影像报告元素清单.ID%Type,
    分类ID_In     In 影像报告元素清单.分类ID%Type,
    编码_In        In 影像报告元素清单.编码%Type,
    名称_In        In 影像报告元素清单.名称%Type,
    前缀_In        In 影像报告元素清单.前缀%Type,
    后缀_In        In 影像报告元素清单.后缀%Type,
    说明_In        In 影像报告元素清单.说明%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In    In 影像报告元素清单.计量单位%Type,
    扩展描述_In    In Varchar2,
    值域ID_In      In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	) As
  Begin

    Update 影像报告元素清单
       Set 分类ID       = 分类ID_In,
           编码         = 编码_In,
           名称         = 名称_In,
           前缀         = 前缀_In,
           后缀         = 后缀_In,
           说明         = 说明_In,
           数据类型     = 数据类型_In,
           数值形态     = 数值形态_In,
           最小长度     = 最小长度_In,
           最大长度     = 最大长度_In,
           最小小数位   = 最小小数位_In,
           最大小数位   = 最大小数位_In,
           计量单位     = 计量单位_In,
           扩展描述     = 扩展描述_In,
           值域ID       = 值域ID_In,
           值域种类     = 值域种类_In,
           最后编辑时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditElement;

  --14.功 能：删除影像报告元素信息
  Procedure p_DelElement(
    ID_In 影像报告元素清单.ID%Type
	) As
  Begin
    Delete From 影像报告元素清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelElement;

  --15.功 能：通过ID获取影像报告分类信息
  Procedure p_GetElementClassByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素分类.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID, 编码, 名称, 说明, 最后编辑时间,RawToHex(上级id) 上级ID
        From 影像报告元素分类 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassByID;

  --16.功  能：获取元素的下一个编码
  Procedure p_Get_ElementNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告元素清单') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementNextCode;

  --17.功  能：获取元素分类的下一个编码
  Procedure p_Get_ElementClassNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告元素分类') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassNextCode;

  --18.功  能：获取对应的值域类型所在的元素类别
  Procedure p_Get_ElementClassByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	) As
  Begin
    Open Val For
      Select Distinct 分类名称, 分类ID
        From (Select RawToHex(分类ID) 分类ID,
                     (Select a.名称
                        From 影像报告元素分类 A
                       Where a.Id = t.分类id) As 分类名称
                From 影像报告值域清单 T
               Where t.值域种类 = 值域种类_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassByKind;

  --19.功  能：获取值域类型对应的值域信息
  Procedure p_Get_RangeByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             RawToHex(分类ID) 分类ID,
             名称,
             数据类型,
             (Select a.名称 From 影像报告元素分类 A Where a.Id = t.分类id) As 分类名称,
             值域种类
        From 影像报告值域清单 T
       Where t.值域种类 = 值域种类_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RangeByKind;

  --20.功  能：获取对应的值域类型和数据类型所在的元素类别
  Procedure p_Get_ElementClassByKindType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	) As
  Begin
    Open Val For
      Select Distinct 分类名称, 分类ID
        From (Select RawToHex(分类id) 分类ID,
                     (Select a.名称
                        From 影像报告元素分类 A
                       Where a.Id = t.分类id) As 分类名称
                From 影像报告值域清单 T
               Where t.值域种类 = 值域种类_In
                 and t.数据类型 = 数据类型_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassByKindType;

  --21.功  能：获取值域类型和数据类型对应的值域信息
  Procedure p_Get_RangeByKindAndType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             RawToHex(分类ID) 分类ID,
             名称,
             数据类型,
             (Select a.名称 From 影像报告元素分类 A Where a.Id = t.分类id) As 分类名称,
             值域种类
        From 影像报告值域清单 T
       Where t.值域种类 = 值域种类_In
         and t.数据类型 = 数据类型_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RangeByKindAndType;

  --22.功 能：获取编辑人对应的最后修改影像报告原型分类信息ID
  Procedure p_GetElementClassLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告元素分类 t1
       Where Not Exists (Select 1
                From 影像报告元素分类
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassLastID;

  --23.功 能：获取编辑人对应的最后修改影像报告元素信息ID
  Procedure p_GetElementLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告元素清单 t1
       Where Not Exists (Select 1
                From 影像报告元素清单
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementLastID;

  --24.功 能：获取最后修改影像报告值域信息ID
  Procedure p_GetRangeLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告值域清单 t1
       Where Not Exists (Select 1
                From 影像报告值域清单
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeLastID;

  --25.功 能：添加计量单位信息
  Procedure p_AddMasure_Unit(
    编码_In 影像报告计量单位.编码%Type,
    名称_In 影像报告计量单位.名称%Type,
    说明_In 影像报告计量单位.说明%Type,
    前缀_In 影像报告计量单位.前缀%Type
	) As
  Begin
    Insert Into 影像报告计量单位
      (编码, 名称, 说明, 前缀)
    Values
      (编码_In, 名称_In, 说明_In, 前缀_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMasure_Unit;

  --26.功  能：修改计量单位
  Procedure p_EditMasure_Unit(
    原编码_In 影像报告计量单位.编码%Type,
    编码_In   影像报告计量单位.编码%Type,
    名称_In   影像报告计量单位.名称%Type,
    说明_In   影像报告计量单位.说明%Type,
    前缀_In   影像报告计量单位.前缀%Type
	) As
  Begin
    Update 影像报告计量单位
       Set 编码 = 编码_In, 名称 = 名称_In, 说明 = 说明_In, 前缀 = 前缀_In
     Where 编码 = 原编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditMasure_Unit;

  --27.功  能：删除计量单位
  Procedure p_DelMasure_Unit(
    编码_In 影像报告计量单位.编码%Type
	) As
  Begin
    Delete from 影像报告计量单位 Where 编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMasure_Unit;

  --28.功  能：判断计量单位的编码是否已存在
  Procedure p_If_Exist_Masure_Unit(
    Val           Out t_Refcur,
	编码_In 影像报告计量单位.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.编码) 数量
        From 影像报告计量单位 t
       Where t.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_Masure_Unit;

  --29.功  能： 判断元素编码是否已存在
  Procedure p_If_Exist_ElementCode(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	编码_In 影像报告元素清单.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素清单 t
       Where t.编码 = 编码_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementCode;

  --30.功  能： 判断元素名称是否已存在
  Procedure p_If_Exist_ElementName(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	名称_In 影像报告元素清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素清单 t
       Where t.名称 = 名称_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementName;

  --31.功  能： 判断值域编码是否已存在
  Procedure p_If_Exist_RangeCode(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	编码_In 影像报告值域清单.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告值域清单 t
       Where t.编码 = 编码_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_RangeCode;

  --32.功  能： 判断值域名称是否已存在
  Procedure p_If_Exist_RangeName(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	名称_In 影像报告值域清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告值域清单 t
       Where t.名称 = 名称_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_RangeName;

  --33.获得元素列表
  Procedure p_GetElementList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(t.ID) ID,
             RawToHex(t.分类ID) 分类ID,
             t.编码,
             t.名称,
             t.前缀,
             t.后缀,
             t.说明,
             t.数据类型,
             t.数值形态,
             t.最小长度,
             t.最大长度,
             t.最小小数位,
             t.最大小数位,
             t.计量单位,
             Nvl(t.扩展描述, '<NULL/>') As 扩展描述,
             RawToHex(t.值域ID) 值域ID,
             (select a.名称 from 影像报告值域清单 a Where a.id=t.值域ID)as 值域名称,
             t.值域种类,
             t.最后编辑时间
        From 影像报告元素清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementList;

  --34.获得值域列表
  Procedure p_GetRangeList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             说明,
             数据类型,
             值域种类,
             Nvl(t.值域描述, '<NULL/>') As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeList;

  --35.判断元素分类的标题和编码是否存在
  Procedure p_If_Exist_ElementClass(
    Val           Out t_Refcur,
    ID_In   影像报告元素分类.ID%Type,
	编码_In 影像报告元素分类.编码%Type,
	名称_In 影像报告元素分类.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素分类 t
       Where (t.名称 = 名称_In or t.编码 = 编码_In)
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementClass;

  --36.判断该元素分类下面是否有值域或者元素
  Procedure p_Is_CanDel_ElementClass(
    Val           Out t_Refcur,
	ID_In 影像报告元素分类.ID%Type
	) As
    ElementCount int;
    RangeCount   int;
    ElementClassCout int;
  Begin
    Select Count(*)
      into ElementCount
      From 影像报告元素清单 a
     Where a.分类id = ID_In;
    Select Count(*)
      into RangeCount
      From 影像报告值域清单 b
     Where b.分类id = ID_In;
     Select Count(*)
      into ElementClassCout
      From 影像报告元素分类 b
     Where b.上级id = ID_In;
    ElementCount := ElementCount + RangeCount+ElementClassCout;
    Open Val For
      Select ElementCount Count From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Is_CanDel_ElementClass;

End b_PACS_RptElement;
/



--影像报告组句管理(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptCombo Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.功  能：获得影像报告组句列表
  Procedure p_GetComboList(
    Val Out t_Refcur
	);
  --2.功  能：添加影像报告组句信息
  Procedure p_AddComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --3.功  能;修改影像报告组句信息
  Procedure p_EditComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --4.功  能：通过ID删除影像报告组句信息
  Procedure p_DelComboInfo(
    ID_In In 影像报告组句清单.ID%Type
	);
  --5.功  能：根据ID获得影像报告组句信息
  Procedure p_GetComboInfoByID(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	);
  --6.功  能：获得影像报告组句的所有分组信息
  Procedure p_GetComboAllGroup(
    Val Out t_Refcur
	);
  --7.功  能：获得ID对应的影像报告组句的短语信息
  Procedure p_GetComboContent(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	);
  --8.功  能：更新ID对应的影像报告组句的短语信息
  Procedure p_EditComboContent(
	ID_In   In 影像报告组句清单.ID%Type,
	组成_In Varchar2
	);
  --9.功 能：获取编辑人对应的最后修改影像报告组句信息
  Procedure p_GetComboInfoByEditor(
	Val           Out t_Refcur,
	编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --10.功  能：新增片段到组合句
  Procedure p_Append_Fragment_Tocombo(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type
	);

  --11.功  能：修改片段到组合句
  Procedure p_Update_Combo_Fragment(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type,
    Pid_In  In Varchar2
	);
  --12.功  能：根据分类ID查询词句
  Procedure p_Get_Fragment_By_Typeid(
	Val           Out t_Refcur,
	Id_In In 影像报告组句清单.ID%Type
	);
  --13.功  能：获取下一个编码
  Procedure p_Get_ComboNextCode(
    Val Out t_Refcur
	);
end b_PACS_RptCombo;
/

--影像报告组句管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptCombo Is
  --Create By Hwei;
  --2014/11/25

  --1.功  能：获得影像报告组句列表
  Procedure p_GetComboList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             名称,
             说明,
             分组,
             多组,
             Nvl(t.组成, '<NULL/>') As 组成,
             编辑人,
             最后编辑时间
        From 影像报告组句清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboList;

  --2.功  能：添加影像报告组句信息
  Procedure p_AddComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	) As
  Begin
    Insert Into 影像报告组句清单
      (ID, 编码, 名称, 说明, 分组, 多组, 组成, 编辑人, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, 分组_In, 多组_In, 组成_In, 编辑人_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddComboInfo;

  --3.功  能;修改影像报告组句信息
  Procedure p_EditComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	) As
  Begin
    Update 影像报告组句清单
       set 编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           分组         = 分组_In,
           多组         = 多组_In,
           组成         = 组成_In,
           编辑人       = 编辑人_In,
           最后编辑时间 = SysDate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditComboInfo;

  --4.功  能：通过ID删除影像报告组句信息
  Procedure p_DelComboInfo(
    ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Delete From 影像报告组句清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelComboInfo;

  --5.功  能：根据ID获得影像报告组句信息
  Procedure p_GetComboInfoByID(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             名称,
             说明,
             分组,
             多组,
             Nvl(t.组成, '<NULL/>') As 组成,
             编辑人,
             最后编辑时间
        From 影像报告组句清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboInfoByID;

  --6.功  能：获得影像报告组句的所有分组信息
  Procedure p_GetComboAllGroup(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 分组 From 影像报告组句清单;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboAllGroup;

  --7.功  能：获得ID对应的影像报告组句的短语信息
  Procedure p_GetComboContent(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select Nvl(t.组成, '<NULL/>') As 组成
        From 影像报告组句清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboContent;

  --8.功  能：更新ID对应的影像报告组句的短语信息
  Procedure p_EditComboContent(
    ID_In   In 影像报告组句清单.ID%Type,
    组成_In In Varchar2
	) As
  Begin
    Update 影像报告组句清单 Set 组成 = 组成_In Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditComboContent;

  --9.功 能：获取编辑人对应的最后修改影像报告组句信息
  Procedure p_GetComboInfoByEditor(
	Val           Out t_Refcur,
	编辑人_In In 影像报告组句清单.编辑人%Type
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 编辑人, 最后编辑时间
        From 影像报告组句清单 t1
       Where Not Exists (Select 1
                From 影像报告组句清单
               Where 最后编辑时间 > t1.最后编辑时间)
         And 编辑人 = 编辑人_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboInfoByEditor;

  --10.功  能：新增片段到组合句
  Procedure p_Append_Fragment_Tocombo(
    Text_In In XmlType,
	Id_In   In 影像报告组句清单.ID%Type
	) As
  Begin
    Update 影像报告组句清单 A
       Set a.组成 = Appendchildxml(a.组成, '/root', Text_In)
     Where a.ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Append_Fragment_Tocombo;

  --11.功  能：修改片段到组合句
  Procedure p_Update_Combo_Fragment(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type,
    Pid_In  In Varchar2
	) As
  Begin
    Update 影像报告组句清单 A
       Set a.组成 = Updatexml(a.组成,
                            '/root/sentence[@sid="' || Pid_In || '"]',
                            Text_In)
     Where a.ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Combo_Fragment;

  --12.功  能：根据分类ID查询词句
  Procedure p_Get_Fragment_By_Typeid(
	Val           Out t_Refcur,
	Id_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             上级id,
             编码,
             名称,
             说明,
             节点类型,
             Nvl(a.组成, '<NULL/>') As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单 A
       Where a.上级id = Id_In
         And a.节点类型 <> 0;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_By_Typeid;

  --13.功  能：获取下一个编码
  Procedure p_Get_ComboNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告组句清单') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ComboNextCode;
End b_PACS_RptCombo;
/



CREATE OR REPLACE Package b_PACS_RptFragments Is
  Type t_Refcur Is Ref Cursor;


  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) ;


  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.ID%Type
	) ;


   Procedure p_Get_Label_By_Typeid(
     Val           Out t_Refcur,
	 Id_In 影像报告片段清单.ID%Type
	 ) ;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：删除短语分类
   Procedure p_Del_Fragmenttype(
     Id_In 影像报告片段清单.ID%Type
	 );

    --功能：添加短语
  Procedure p_Add_Fragment(
     Id_In      影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

   --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    );
   --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.ID%Type
	);

  procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	);

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

procedure p_Get_Data_Last_Edit_Time(
  Val           Out t_Refcur,
  Table_Name_In varchar2
  );

   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	);

  End  b_PACS_RptFragments;
/
CREATE OR REPLACE Package Body b_PACS_RptFragments Is

  ------------------------------------------------------------------------
  --片段模块
  ------------------------------------------------------------------------

  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, 编码, 名称 From 影像报告预备提纲 Order By 编码;
  End p_Get_All_Phr_Onlines;

  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型
      From 影像报告片段清单 A
      Where a.节点类型 = 0
      Start With 上级id Is Null
      Connect By Prior ID = 上级id
      Order By 编码;
  End p_Get_All_Fragment_Class;

  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) As
  Begin
    If Subjects_In <> '' Then
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成, '<NULL/>') As 组成, a.学科, a.标签, a.是否私有, a.作者
        From 影像报告片段清单 A
        Where (a.学科 In (Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(Subjects_In, ','))
                        Intersect
                        Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(a.学科, ','))) And a.节点类型 <> 0) Or a.节点类型 = 0 Or a.学科 Is Null
        Order By 编码, 上级id;
    Else
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成, '<NULL/>') As 组成, a.学科, a.标签, a.是否私有, a.作者,
               a.节点类型 As Image
        From 影像报告片段清单 A
        Order By 上级id, 节点类型, 编码, 名称;
    End If;
  End p_Get_All_Fragment;

  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
  ) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, a.编码, a.名称, a.说明, a.节点类型, Nvl(a.组成, '<NULL/>') As 组成, a.学科, a.标签, a.是否私有, a.作者
      From 影像报告片段清单 A
      Where a.上级id = Hextoraw(Id_In) And a.节点类型 <> 0;
  End p_Get_Fragment_By_Typeid;

  --功能：查找某分类下所有短语标签
  Procedure p_Get_Label_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
    ) As
  Begin
    Open Val For
      Select Distinct 标签 From 影像报告片段清单 Where 上级id = Hextoraw(Id_In) And 标签 Is Not Null;
  End p_Get_Label_By_Typeid;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 编码 = Code_In Or 名称 = Title_In And 节点类型 = 0 And 上级id = Hextoraw(Pid_In);

    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Author_In, Sysdate);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragmenttype;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 = 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 作者 = Author_In,
          最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragmenttype;

  --功能：删除短语分类
  Procedure p_Del_Fragmenttype(
    Id_In 影像报告片段清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 节点类型 <> 0 And
          ID In (Select ID From 影像报告片段清单 Connect By Prior ID = 上级id Start With ID = Hextoraw(Id_In));

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该分类下存在短语，暂不能删除！[ZLSOFT]';
      Raise Err_Item;
    Else
      Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragmenttype;

  --功能：添加短语
  Procedure p_Add_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
  Begin

      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragment;

  --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 <> 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]短语的名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 组成 = Content_In,
          学科 = Subjects_In, 标签 = Label_In, 是否私有 = Private_In, 作者 = Author_In, 最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragment;

  --
  Procedure p_Get_All_Fragment_List(Val Out t_Refcur) As
  Begin
    Open Val For
      Select Rawtohex(t.Id) As ID, Rawtohex(t.上级id) As 上级id, t.编码, t.名称, t.说明, t.节点类型, Nvl(t.组成, '<NULL/>') As 组成, t.学科, t.标签, t.是否私有, t.作者,
             t.最后编辑时间
      From 影像报告片段清单 T;
  End p_Get_All_Fragment_List;

  --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragment;

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    v_Num Number(2);
  Begin
    Select Count(ID)
    Into v_Num
    From 影像报告片段清单
    Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
          (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));

    If v_Num > 0 Then
      Update 影像报告片段清单
      Set 组成 = Content_In, 最后编辑时间 = Sysdate, 是否私有 = 0
      Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
            (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);
    End If;

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Import_Fragment;

  --
  Procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
    Table_Name_In Varchar2
    ) As
    v_Sql Varchar2(4000);
  Begin
    v_Sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open Val For v_Sql;
  End p_Get_Data_Last_Edit_Time;
  
   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Open Val For
      Select Count(t.id) Count
        From 影像报告片段清单 t
       Where 上级id = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_IsCanDel_FragmentType;

End  b_PACS_RptFragments;
/



--影像报告原型管理(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	);
  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
	Stop_Flag    Number,
	Condition_In Varchar2
	);
  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
	种类_In         影像报告原型清单.种类%Type,
	编码_In         影像报告原型清单.编码%Type,
	名称_In         影像报告原型清单.名称%Type,
	说明_In         影像报告原型清单.说明%Type,
	可否重置页面_In 影像报告原型清单.可否重置页面%Type,
	可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	是否禁用_In     影像报告原型清单.是否禁用%Type,
	创建人_In       影像报告原型清单.创建人%Type,
	内容_In         影像报告原型清单.内容%Type,
	控制选项_In     影像报告原型清单.控制选项%Type,
	专用插件_In     影像报告原型清单.专用插件%Type,
	Copy_Id_In      影像报告原型清单.ID%Type,
	Only_Head_In    Varchar2,
	分组_In         影像报告原型清单.分组%Type
	);
  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_Id_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	);
  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);
  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	);
  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind;
  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);
  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
	编码_In 影像报告预备提纲.编码%Type,
	名称_In 影像报告预备提纲.名称%Type,
	说明_In 影像报告预备提纲.说明%Type
	);
  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline;
  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	);
  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	);
  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	);
  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
    Val           Out t_Refcur,		
	原型ID_In 影像报告原型片段.原型ID%Type,
    片段ID_In 影像报告原型片段.片段ID%Type
	);
  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    Id_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	);
  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	);
  --21.获取已经设置了关联的原型片段类别的信息

  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型id_In Varchar2
	);
  --23.获取能复制的原型名称

  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型id_In 影像报告原型清单.Id%Type
	);
  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	);
  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	);
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	);
  --29.获取关于原型导出的重复信息

  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
    Id_In        影像报告原型清单.Id%Type,
    编码_In      Varchar2,
    名称_In      Varchar2
	);
  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,	
	Id_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	);
  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	);

  ----32.获取元素或者提纲的名称集合
  --Procedure p_Get_Antetype_Ele_Section(
  --原型ID_In  影像报告原型清单.Id%Type,
  --Val     Out t_Refcur);

  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型id_In 影像报告动作.原型id%Type
	);

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	);
  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	);

  --37.获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	);
  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	);
  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	);
  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	);
  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	);
  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type
	);
  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	);
  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	);
  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	);
  --50.删除文档处理
  Procedure p_Del_Doc_Process(
    Id_In        影像报告动作.ID%Type,
	Del_Event_In Number
	);

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	);
  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	);
  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
	Val           Out t_Refcur,
	ID_In Varchar2
	);
  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	);
  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
    编码_In 影像报告插件.编码%Type,
    名称_In 影像报告插件.名称%Type
	);
  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	);
  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
    条件_In Varchar2
	);
  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	);
  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
	应用场合_In   影像报告原型应用.应用场合%Type,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	);
  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
    名称_In 影像报告原型清单.名称%Type,
    ID_In  影像报告原型清单.ID%Type
	);
End b_PACS_RptAntetype;
/

--影像报告原型管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, a.名称, a.编码 || '-' || a.名称 As 标题
        From 影像报告种类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelistkind;

  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
    Stop_Flag    Number,
    Condition_In Varchar2
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And a.分组 Is Not Null
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.
               种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelis_By_Kind;

  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    创建人_In       影像报告原型清单.创建人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str Xmltype;
  Begin
    Begin
      If Copy_ID_In Is Null or Copy_ID_In = 0 Then
        x_Str := 内容_In;
      Else
        Select Decode(Only_Head_In,
                      1,
                      Deletexml(a.内容, '/zlxml/document/node()'),
                      a.内容)
          Into x_Str
          From 影像报告原型清单 A
         Where a.id = Copy_ID_In;
      End If;
    Exception
      When Others Then
        x_Str := 内容_In;
    End;
  
    Insert Into 影像报告原型清单
      (ID,
       种类,
       编码,
       名称,
       说明,
       可否重置页面,
       可否重置格式,
       是否禁用,
       创建人,
       创建时间,
       内容,
       控制选项,
       专用插件,
       分组)
    Values
      (ID_In,
       种类_In,
       编码_In,
       名称_In,
       说明_In,
       可否重置页面_In,
       可否重置格式_In,
       是否禁用_In,
       创建人_In,
       sysdate,
       x_Str,
       控制选项_In,
       专用插件_In,
       分组_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetypelist;

  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str     Xmltype;
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告原型清单 A
     Where (a.编码 = 编码_In Or a.名称 = 名称_In)
       And ID <> ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在相同的文档编码或者名称，请重新填写！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Copy_ID_In Is Null or Copy_ID_In = 0 Then
      x_Str := 内容_In;
    Else
      Select Decode(Only_Head_In,
                    1,
                    Deletexml(a.内容, '/zlxml/document/node()'),
                    a.内容)
        Into x_Str
        From 影像报告原型清单 A
       Where a.id = Copy_ID_In;
    End If;
  
    Update 影像报告原型清单
       Set 种类         = 种类_In,
           编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           可否重置页面 = 可否重置页面_In,
           可否重置格式 = 可否重置格式_In,
           是否禁用     = NVL(是否禁用_In, 是否禁用),
           修改人       = 修改人_In,
           修改时间     = sysdate,
           内容         = x_Str,
           控制选项     = 控制选项_In,
           专用插件     = 专用插件_In,
           分组         = 分组_In
     Where ID = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist;

  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(ID) Into n_Num From 影像报告记录 A Where a.原型id = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该原型已经被文档使用，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(原型ID)
      Into n_Num
      From 影像报告原型片段
     Where 影像报告原型片段.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该文档下存在词句关联，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(ID)
      Into n_Num
      From 影像报告范文清单
     Where 影像报告范文清单.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在以此原型建立的范文信息，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告原型清单 C Where c.Id = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetypelist;

  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select rawtohex(a.ID) ID,
             a.种类,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
             Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
             Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
             Nvl(a.控制选项, '<NULL/>') as 控制选项,
             a.是否禁用,
             Nvl(a.专用插件, '<NULL/>') as 专用插件,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             a.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_By_Id;

  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select Nvl(a.内容, '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Content;

  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 是否禁用 = Decode(是否禁用, 1, 0, 0, 1)
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Stop_Antetypelist;

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告种类 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 编码_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告种类
      (编码, 名称, 说明)
    Values
      (编码_In, 名称_In, 说明_In);
  
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Kind;

  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind As
  Begin
    Delete From 影像报告种类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Kind;

  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID, 编码, 名称, 说明, 最后编辑时间
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Pre_Outline;

  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
    编码_In 影像报告预备提纲.编码%Type,
    名称_In 影像报告预备提纲.名称%Type,
    说明_In 影像报告预备提纲.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告预备提纲 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 名称_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告预备提纲
      (ID, 编码, 名称, 说明, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, sysdate);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Pre_Outline;

  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline As
  Begin
    Delete From 影像报告预备提纲;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Pre_Outline;

  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select '类别' As 类别,
             b.编码 As ID,
             Null As 种类,
             b.名称 As 种类名称,
             b.编码 As 编码,
             b.名称 As 名称,
             b.说明 As 说明,
             Null As 可否重置页面,
             Null As 可否重置格式,
             Null As 是否禁用,
             Null As 创建人,
             Null As 创建时间,
             Null As 修改人,
             Null As 修改时间,
             Null As 内容
        From 影像报告种类 B
      Union All
      Select '原型' 类别,
             RawToHex(a.Id) ID,
             a.种类,
             b.名称 种类名称,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             a.是否禁用,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             Null As 内容
        From 影像报告原型清单 A, 影像报告种类 B
       Where a.种类 = b.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Output_Antetypelist;

  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type) As
  Begin
    Insert Into 影像报告原型片段
      (原型ID, 片段ID)
    Values
      (原型ID_In, 片段ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetype_Fragments;

  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Delete From 影像报告原型片段 Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetype_Fragments;

  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments;

  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In
         And a.片段ID = 片段ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_f_Byaidfid;

  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    ID_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 内容 = 内容_In, 修改人 = 修改人_In, 修改时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist_Content;

  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             编码 || '-' || 名称 As 名称,
             分组,
             a.种类,
             a.是否禁用,
             a.说明,
             Decode(a.是否禁用, 1, 2, 1) Imageindex,
             Nvl(a.内容, '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Antetype_Lists;

  --21.获取已经设置了关联的原型片段类别的信息
  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             a.名称,
             a.编码 || '-' || a.名称 标题,
             a.说明
        From 影像报告片段清单 A
       Where a.Id In (Select b.片段id
                        From 影像报告原型片段 B
                       Where b.原型id = 原型ID_In)
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments_Info;

  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型ID_In Varchar2
	) As
    v_Sql  Varchar2(4000);
    v_Aids Varchar2(4000);
    v_Msg  Varchar2(4000);
    Err Exception;
  Begin
    For Myrow In (Select RawtoHex(a.片段id) ID
                    From 影像报告原型片段 A
                   Where a.原型id = 原型ID_In) Loop
      If v_Aids Is Null Then
        v_Aids := '''' || Myrow.Id || '''';
      Else
        v_Aids := v_Aids || ',''' || Myrow.Id || '''';
      End If;
    End Loop;
  
    If v_Aids Is Null Then
      If Substr(原型ID_In, 0, 1) <> '''' Then
        v_Aids := '''' || 原型ID_In || '''';
      Else
        v_Aids := 原型ID_In;
      End If;
    End If;
  
    v_Sql := 'Select Distinct  RawtoHex(a.id) ID,  RawtoHex(a.上级ID) 上级ID , a.编码, a.编码 || ''-'' || a.名称 标题,Decode(a.节点类型, 0, 0, 1) 节点类型
      From 影像报告片段清单 A
      Start With a.Id In (' || v_Aids || ')
      Connect By Prior a.Id = a.上级ID
      Order By a.编码';
  
    Open Val For v_Sql;
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Selected_Fragments;

  --23.获取能复制的原型名称
  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID, a.编码 || '-' || a.名称 标题
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Copy_Antetype;

  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select Distinct a.分组 As 分组
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
         and a.分组 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Category;

  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型ID_In 影像报告原型清单.Id%Type
	) As
    x_Content Xmltype;
    x_Result  Xmltype;
    Cursor c_Antetype Is
      Select Extractvalue(c.Column_Value, '/section/@iid') Iid,
             Extractvalue(c.Column_Value, '/section/@title') Title,
             c.Column_Value As Content
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.内容, '/zlxml//section'))) C
       Where a.Id = 原型ID_In;
    n_i               Number;
    n_j               Number;
    n_Count           Number;
    x_Subdocuments    Xmltype;
    x_Docparameters   Xmltype;
    x_Antetypecontent Xmltype;
    v_Textstyleno     Varchar2(10);
    v_Parastyleno     Varchar2(10);
    x_Acontent        Xmltype;
  Begin
    For Mysample In (Select b.id, b.内容
                       From 影像报告范文清单 B
                      Where b.原型id = 原型ID_In) Loop
      x_Content := Mysample.内容;
      n_i       := 1;
      If x_Content Is Null Then
        Select a.内容
          Into x_Result
          From 影像报告原型清单 A
         Where a.Id = 原型ID_In;
      Else
        Begin
          Select Extractvalue(c.Column_Value, '/section/@textstyleno') Textstyleno,
                 Extractvalue(c.Column_Value, '/section/@parastyleno') Parastyleno
            Into v_Textstyleno, v_Parastyleno
            From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C
           Where Rownum = 1;
        Exception
          When Others Then
            v_Textstyleno := '1';
            v_Parastyleno := '1';
        End;
      
        For Myantetype In c_Antetype Loop
          For I In 1 .. 1 Loop
            If n_i <> 1 Or n_Count <> 0 Or n_Count Is Null Then
              Select Count(*)
                Into n_Count
                From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C;
            End If;
            If n_Count < n_i Then
              Select Updatexml(Myantetype.Content,
                               '//section/@textstyleno',
                               v_Textstyleno)
                Into x_Acontent
                From Dual;
              Select Updatexml(x_Acontent,
                               '//section/@parastyleno',
                               v_Parastyleno)
                Into x_Acontent
                From Dual;
              Select Appendchildxml(x_Content,
                                    '/zlxml/document',
                                    x_Acontent)
                Into x_Content
                From Dual;
              Exit;
            End If;
            n_j := 1;
            For Mysample In (Select Extractvalue(c.Column_Value,
                                                 '/section/@iid') Iid,
                                    Extractvalue(c.Column_Value,
                                                 '/section/@title') Title
                               From Table(Xmlsequence(Extract(x_Content,
                                                              '/zlxml//section'))) C) Loop
              If n_i = n_j Then
                If Myantetype.Iid <> Mysample.Iid Then
                  Select Updatexml(Myantetype.Content,
                                   '//section/@textstyleno',
                                   v_Textstyleno)
                    Into x_Acontent
                    From Dual;
                  Select Updatexml(x_Acontent,
                                   '//section/@parastyleno',
                                   v_Parastyleno)
                    Into x_Acontent
                    From Dual;
                  Select Deletexml(x_Content,
                                   '//section[@iid="' || Myantetype.Iid || '"]')
                    Into x_Content
                    From Dual;
                  Select Insertxmlbefore(x_Content,
                                         '//section[@iid="' || Mysample.Iid || '"]',
                                         x_Acontent)
                    Into x_Content
                    From Dual;
                  n_j := n_j + 1;
                  Exit;
                Else
                  n_j := n_j + 1;
                  Exit;
                End If;
              End If;
              n_j := n_j + 1;
            End Loop;
            n_i := n_i + 1;
          End Loop;
        End Loop;
        x_Result := x_Content;
        For Mysample2 In (Select Iid
                            From (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From Table(Xmlsequence(Extract(x_Content,
                                                                   '/zlxml//section'))) C) C
                           Where c.Iid Not In
                                 (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From 影像报告原型清单 A,
                                         Table(Xmlsequence(Extract(a.内容,
                                                                   '/zlxml//section'))) C
                                   Where a.Id = 原型ID_In)) Loop
          Select Deletexml(x_Result,
                           '//section[@iid="' || Mysample2.Iid || '"]')
            Into x_Result
            From Dual;
        End Loop;
      End If;
    
      Update 影像报告范文清单 X
         Set x.内容 = x_Result
       Where x.Id = Mysample.Id;
    End Loop;
  
    Select a.内容
      Into x_Antetypecontent
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
    Select Extract(x_Antetypecontent, 'zlxml/subdocuments')
      Into x_Subdocuments
      From Dual;
    Select Extract(x_Antetypecontent, 'zlxml/docparameters')
      Into x_Docparameters
      From Dual;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/subdocuments', x_Subdocuments)
     Where 原型ID = 原型ID_In;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/docparameters', x_Docparameters)
     Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Synchronous_Sample;

  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID,
             编码,
             标题,
             Parentid,
             种类,
             是否禁用,
             说明,
             Imageindex,
             名称
        From (Select a.编码 As ID,
                     a.编码 As 编码,
                     a.名称 As 标题,
                     '' As Parentid,
                     '-1' As 种类,
                     0 As 是否禁用,
                     a.说明 As 说明,
                     4 As Imageindex,
                     a.名称 名称
                From 影像报告种类 A
              Union
              Select Distinct a.种类 || '-' || a.分组 As ID,
                              (Select Min(编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              Max(a.分组) As 名称,
                              a.种类 As Parentid,
                              '0' As 种类,
                              0 As 是否禁用,
                              '' As 说明,
                              4 As Imageindex,
                              a.分组
                From 影像报告原型清单 A
               Where a.分组 Is Not Null
               Group By a.种类, a.分组
              Union
              Select RawTohex(ID),
                     a.编码,
                     编码 || '-' || 名称 As 标题,
                     Decode(a.分组, Null, a.种类, a.种类 || '-' || a.分组) Parentid,
                     a.种类 As 种类,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 1, 0, 2),
                     a.名称
                From 影像报告原型清单 A) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Out_Antetypelist;

  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明
        From 影像报告种类 A
       Where a.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Kind_By_Code;
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID,
             a.种类,
             a.原型id,
             a.编号,
             a.名称,
             a.说明,
             a.元素iid,
             a.扩展标记
        From 影像报告事件 A
       Where a.种类 <> 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event;

  --29.获取关于原型导出的重复信息
  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
	ID_In        影像报告原型清单.Id%Type,
	编码_In      Varchar2,
	名称_In      Varchar2
	) As
    n_Num    Number;
    v_Result Varchar2(100);
    v_Sql    Varchar2(4000);
  Begin
    If ID_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where id=' ||
               ID_In;
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        v_Result := 'ID重复';
      End If;
    End If;
    If 编码_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 编码=''' ||
               编码_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',编码重复';
        Else
          v_Result := '编码重复';
        End If;
      End If;
    End If;
    If 名称_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 名称=''' ||
               名称_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',名称重复';
        Else
          v_Result := '名称重复';
        End If;
      End If;
    End If;
    Open Val For
      Select v_Result Result From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Same_Info;

  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,
	ID_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	) As
    v_Same_Antetype Varchar2(50);
    n_Same_Id       Number;
    n_Same_Title    Number;
    n_Same_Seqnum   Number;
    n_Maxnum        Number;
  Begin
    Select Count(*)
      Into n_Same_Title
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.名称 = 名称_In;
    Select Count(*)
      Into n_Same_Seqnum
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.编号 = 编号_In;
    Begin
      Select a.Id
        Into v_Same_Antetype
        From 影像报告事件 A
       Where a.原型ID = 原型ID_In
         And a.元素IID = 元素IID_In;
    Exception
      When Others Then
        v_Same_Antetype := '';
    End;
  
    Select Count(*) Into n_Same_Id From 影像报告事件 A Where a.Id = ID_In;
    Select Max(a.编号) Into n_Maxnum From 影像报告事件 A;
  
    Open Val For
      Select v_Same_Antetype As Sameaid,
             n_Same_Id       As Sameid,
             n_Same_Title    As Sametitle,
             n_Same_Seqnum   As Sameseqnum,
             n_Maxnum        As Maxnum
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Event_Same_Info;

  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 动作类型
        From (Select Extractvalue(c.Column_Value, '/step/kind') As 动作类型
                From 影像报告动作 A,
                     Table(Xmlsequence(Extract(a.内容, '/root/step'))) C) B
       Where b.动作类型 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Process_Kind;


  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In 影像报告动作.原型id%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容, '<NULL/>')) As 内容, --Nvl(p.内容,'<NULL/>') As 内容,
             RawtoHex(p.事件ID) 事件ID,
             0 Is_Event
        From 影像报告动作 P
       Where p.原型ID = 原型ID_In
      Union All
      Select RawtoHex(e.id) ID,
             e.名称,
             e.种类,
             e.编号,
             e.说明,
             Null,
             To_CLOB('<Null/>') As 内容, --(Null,'<NULL/>') As 内容,
             Null,
             1
        From 影像报告事件 E
       Where e.Id In (Select RawtoHex(事件ID) 事件ID
                        From 影像报告动作
                       Where 原型ID = 原型ID_In)
       Order By Is_Event, 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process_Of_Antetype;

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	) As
  Begin
    Open Val For
      Select a.编号, a.名称, Rawtohex(a.字典id) As 字典ID
        From 影像字典内容 A
       Where a.字典id In (Select id From 影像字典清单 b Where b.名称 = 名称_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Dictitems_By_Title;

  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, a.编码, a.名称
        From 影像报告预备提纲 a
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Phr_Onlines;

  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	) As
  Begin
    If 学科_In <> '' Then
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成, '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Where (a.学科 In
               (Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(学科_In, ','))
                 Intersect
                 Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(a.学科, ','))) And
               a.节点类型 <> 0)
            Or a.节点类型 = 0
            Or a.学科 Is Null
         Order By a.编码, a.上级id;
    Else
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成, '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Order By a.上级id, a.节点类型, a.编码, a.名称;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment;

  --37. 获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(b.Id) ID,
               Rawtohex(b.上级id) 上级id,
               b.编码,
               b.名称,
               b.说明,
               b.节点类型,
               Nvl(b.组成, '<NULL/>') As 组成,
               b.学科,
               b.标签,
               b.是否私有,
               b.作者,
               b.最后编辑时间
          From 影像报告原型片段 A, 影像报告片段清单 B
         Where a.片段id = b.id
           And a.原型id = 原型id_In;
    Else
      Open Val For
        Select /*+ rule*/
         Rawtohex(b.Id) ID,
         Rawtohex(b.上级id) 上级id,
         b.编码,
         b.名称,
         b.说明,
         b.节点类型,
         Nvl(b.组成, '<NULL/>') As 组成,
         b.学科,
         b.标签,
         b.是否私有,
         b.作者,
         b.最后编辑时间
          From 影像报告片段清单 B
         Where b.上级id = 原型id_In
           And (b.是否私有 = 0 Or (b.是否私有 = 1 And b.作者 = 作者_In))
           And (b.学科 Is Null Or
               (b.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(b.学科, 学科_In) > 0));
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_Filter;

  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select Distinct b.标签
        From 影像报告片段清单 B
       Start With b.上级id In (Select a.片段id
                               From 影像报告原型片段 A
                              Where a.原型id = 原型ID_In)
      Connect By Prior b.Id = b.上级id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Label_By_Aid;

  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) ID,
             Rawtohex(a.上级id) 上级id,
             a.编码,
             a.名称,
             a.说明,
             a.节点类型
        From 影像报告片段清单 A
       Where a.节点类型 = 0
       Start With 上级id Is Null
      Connect By Prior id = 上级id
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment_Class;

  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Data_Last_Edit_Time;

  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    n_Seq_Num  影像报告事件.编号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = 原型ID_In
       And 种类 = 种类_In
       And 名称 = 名称_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上已存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (编号_In Is Null Or 编号_In = 0) Then
      Select Nvl(Max(编号), 0) + 1 Into n_Seq_Num From 影像报告事件;
    Else
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where 原型ID = 原型ID_In
         And 种类 = 种类_In
         And 编号 = 编号_In;
      If n_Is_Exist > 0 Then
        v_Err_Msg := '[ZLSOFT]原型上已存在相同编号的事件[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_Seq_Num := 编号_In;
    End If;
  
    Insert Into 影像报告事件
      (ID, 种类, 原型ID, 编号, 名称, 说明, 元素IID, 扩展标记)
    Values
      (ID_In,
       种类_In,
       原型ID_In,
       n_Seq_Num,
       名称_In,
       说明_In,
       元素IID_In,
       扩展标记_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Event;

  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    r_Aid      影像报告事件.原型ID%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告事件 Where ID = Id_In;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = r_Aid
       And 种类 = 种类_In
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 影像报告事件
       Set 种类     = 种类_In,
           名称     = 名称_In,
           说明     = 说明_In,
           元素IID  = 元素IID_In,
           扩展标记 = 扩展标记_In
     Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Event;

  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	) As
    n_Kind     影像报告事件.种类%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 种类 Into n_Kind From 影像报告事件 Where ID = Id_In;
  
    If n_Kind = 1 Then
      v_Err_Msg := '[ZLSOFT]不允许删除固定事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(*) Into n_Is_Exist From 影像报告动作 Where 事件ID = Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]事件已经被使用,不能被删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告事件 Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Doc_Event;

  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	) As
  Begin
    Delete From 影像报告事件
     Where 种类 <> 1
       And ID Not In
           (Select 事件ID From 影像报告动作 Where 事件ID Is Not Null);
    Count_Out := Sql%RowCount;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Unused_Doc_Events;

  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	) As
  Begin
    If Include_Base_In = 1 Then
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where (t.种类 = 1 Or t.原型id = 原型ID_In)
           And t.Id = p.事件ID(+)
         Order By t.编号;
    Else
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where t.原型id = 原型ID_In
           And t.种类 <> 1
           And t.Id = p.事件ID(+)
         Order By t.编号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event_Of_Antetype;

  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type) As
  Begin
    Update 影像报告动作 Set 序号 = 序号_In Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process_Seqnum;

  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	) As
    n_Seq_Num  影像报告动作.序号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = 原型ID_In
       And 名称 = 名称_In;
    If (序号_In Is Null Or 序号_In = 0) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 序号_In;
    End If;
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
    Insert Into 影像报告动作
      (ID, 原型ID, 事件ID, 动作类型, 名称, 说明, 可否手工执行, 序号, 内容)
    Values
      (Id_In,
       原型ID_In,
       事件ID_In,
       动作类型_In,
       名称_In,
       说明_In,
       可否手工执行_In,
       n_Seq_Num,
       内容_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Process;

  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	) As
    r_Aid          影像报告事件.原型ID%Type;
    r_Old_Event_Id 影像报告动作.事件ID%Type;
    n_Seq_Num      影像报告事件.编号%Type;
    n_Is_Exist     Number(1) := 0;
    v_Err_Msg      Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告动作 Where ID = Id_In;
    If (事件ID_In Is Not Null) Then
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where (原型ID Is Null Or 原型ID = r_Aid)
         And ID = 事件ID_In;
    
      If n_Is_Exist = 0 Then
        v_Err_Msg := '[ZLSOFT]关联的事件不存在[ZLSOFT]';
        Raise Err_Item;
      End If;
    
    End If;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = r_Aid
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (r_Old_Event_Id <> 事件ID_In Or
       (事件ID_In Is Null And r_Old_Event_Id Is Not Null)) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 0;
    End If;
  
    If n_Seq_Num > 0 Then
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In,
             序号         = n_Seq_Num
       Where ID = Id_In;
    Else
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In
       Where ID = Id_In;
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process;

  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	) As
    c_Content Clob;
  Begin
    /*Select To_Clob(a.内容)*/
    Select a.内容.getclobval()
      Into c_Content
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
  
    If Type_In = '1' Then
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/*/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '/zlxml/document//element[@sid and @title]|/zlxml/document//e_list[@sid and @title]|/zlxml/document//e_enum[@sid and @title]|/zlxml/document//e_etree[@sid and @title]|/zlxml/document//e_utree[@sid and @title]'))) C) A
         Where a.Name Is Not Null;
    Else
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/section/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '//section'))) C) A
         Where a.Name Is Not Null;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Ele_Section;

  --50.删除文档处理
  Procedure p_Del_Doc_Process(Id_In        影像报告动作.ID%Type,
                              Del_Event_In Number) As
    r_Event_Id   影像报告动作.事件ID%Type := Null;
    n_Event_Kind 影像报告事件.种类%Type;
    n_Is_Exist   Number(1) := 0;
  Begin
    If Del_Event_In = 1 Then
      Select Max(e.Id), Max(e.种类)
        Into r_Event_Id, n_Event_Kind
        From 影像报告动作 P, 影像报告事件 E
       Where p.Id = Id_In
         And p.事件id = e.Id;
    End If;
  
    Delete From 影像报告动作 Where ID = Id_In;
  
    If Del_Event_In = 1 Then
      If (r_Event_Id Is Not Null And n_Event_Kind <> 1) Then
        Select Count(*)
          Into n_Is_Exist
          From 影像报告动作
         Where 事件id = r_Event_Id;
        If n_Is_Exist = 0 Then
          Delete From 影像报告事件
           Where ID = r_Event_Id
             And 种类 <> 1;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Process;

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	) As
    v_Result  Varchar2(50);
    v_Id      Varchar2(50);
    v_Code_Id Varchar2(50);
    n_Num     Number;
  Begin
    If Flag_In = 1 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.Id = Id_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.编码 = Code_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素分类 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 2 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 3 Then
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告值域清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    Open Val For
      Select v_Result As Result, v_Id As ID, v_Code_Id As Codesameid
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Ele_Same_Info;

  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             Decode(显示样式, '1', '嵌入式', '弹出式') 显示样式II,
             Decode(种类, '1', '专用插件', '共享插件') 种类II,
             类名,
             库名,
             是否禁用,
             Decode(是否禁用, '1', '停用', '启用') IsEnable
        From 影像报告插件;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocPluginList;

  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
    Val           Out t_Refcur,
	ID_In Varchar2
	) As
    CURSOR C_EVENT Is
      Select t.专用插件.getclobval() 专用插件 From 影像报告原型清单 t;
    anum Int := 0;
    sult Varchar2(6666);
  Begin
    For temp In C_EVENT Loop
      If instr(temp.专用插件, ID_In) > 0 Then
        anum := anum + 1;
      End If;
    End Loop;
    Open Val For
      Select anum From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExit_DocPluginByID;

  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Insert Into 影像报告插件
      (ID, 编码, 名称, 说明, 显示样式, 种类, 类名, 库名, 是否禁用)
    Values
      (ID_In,
       编码_In,
       名称_In,
       说明_In,
       显示样式_In,
       种类_In,
       类名_In,
       库名_In,
       是否禁用_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddDocPlugin;

  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Update 影像报告插件
       Set 编码     = 编码_In,
           名称     = 名称_In,
           说明     = 说明_In,
           显示样式 = 显示样式_In,
           种类     = 种类_In,
           类名     = 类名_In,
           库名     = 库名_In,
           是否禁用 = 是否禁用_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDocPlugin;

  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Delete From 影像报告插件 Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDocPlugin;

  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Update 影像报告插件 a
       Set 是否禁用 = Decode(a.是否禁用, 1, 0, 1)
     Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsEnableDocPlugin;

  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocPluginByID;

  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
	编码_In 影像报告插件.编码%Type,
	名称_In 影像报告插件.名称%Type
	) As
  Begin
    Open Val For
      Select Count(id)
        From 影像报告插件 a
       Where (a.编码 = 编码_In Or a.名称 = 名称_In)
         and a.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExitDocPlugin;

  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In
         And 种类 = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocSpecPluginByID;

  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
	条件_In Varchar2
	) As
  Begin
    Open Val For
      Select to_char(a.id) ID,
             a.编码,
             a.名称,
             (Select b.名称 From 诊疗项目类别 b Where b.编码 = a.类别) 类别
        From 诊疗项目目录 a
       Where (a.id In (Select t.诊疗项目id From 影像检查项目 t) And a.类别 = 类别_In)
         And (a.编码 Like 条件_In || '%' Or a.名称 Like 条件_In || '%');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisList;

  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.编码, t.名称, t.简码 From 诊疗项目类别 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisClass;

  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
    应用场合_In   影像报告原型应用.应用场合%Type,
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Insert Into 影像报告原型应用
      (诊疗项目ID, 应用场合, 报告原型ID)
    Values
      (诊疗项目ID_In, 应用场合_In, 报告原型ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMedicalAntetype;

  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告原型应用 Where 报告原型ID = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMedicalAntetype;

  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Open Val For
      Select id,
             x.编码,
             x.名称,
             x.类别,
             Sum(x.门诊) 门诊,
             Sum(x.住院) 住院,
             Sum(x.外诊) 外诊,
             Sum(x.体检) 体检
        From (Select id,
                     编码,
                     名称,
                     类别,
                     Decode(应用场合, '1', 1, 0) as 门诊,
                     Decode(应用场合, '2', 1, 0) as 住院,
                     Decode(应用场合, '3', 1, 0) as 外诊,
                     Decode(应用场合, '4', 1, 0) as 体检
                From (Select to_Char(a.诊疗项目id) ID,
                             (Select b.编码
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 编码,
                             (Select b.名称
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 名称,
                             (Select c.名称
                                From 诊疗项目类别 c
                               Where c.编码 = (Select b.类别
                                               From 诊疗项目目录 b
                                              Where b.id = a.诊疗项目id)) As 类别,
                             a.应用场合
                        From 影像报告原型应用 a
                       Where a.报告原型id = 报告原型ID_In)) x
       Group By x.id, x.编码, x.名称, x.类别;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMedicalByAID;

  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告动作 t Where t.原型id = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     a.名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAntetypeTreeByID;

  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
	名称_In 影像报告原型清单.名称%Type,
	ID_In  影像报告原型清单.ID%Type
	) As
  begin
    Open Val For
      Select Count(*) AS num
        From 影像报告原型清单 t
       where (t.编码 = 编码_In
          or t.名称 = 名称_In) and t.id<>ID_In;
  End p_IsExitAntetype;

End b_PACS_RptAntetype;
/



CREATE OR REPLACE Package b_Pacs_RptSampleList Is
  Type t_Refcur Is Ref Cursor;

  -- Author  : SEEKING
  -- Created : 2014/10/30 10:05:38
  -- Purpose : 范文管理

  --查找范文的原型类别

  Procedure p_Get_Sample_List_Type(
    Val Out t_Refcur,
    Type_In Varchar2,
    Kind_In varchar2
	);

  --新增文档原型
  Procedure p_Add_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
	Aid_In      影像报告范文清单.原型id%Type,
	Seq_Num_In  影像报告范文清单.编号%Type,
	Title_In    影像报告范文清单.名称%Type,
	Note_In     影像报告范文清单.说明%Type,
	Content_In  影像报告范文清单.内容%Type,
	Subject_In  影像报告范文清单.学科%Type,
	Label_In    影像报告范文清单.标签%Type,
	Private_In  影像报告范文清单.是否私有%Type,
	Author_In   影像报告范文清单.作者%Type,
	Lasttime_In 影像报告范文清单.最后编辑时间%Type
	);

  --编辑范文信息
  Procedure p_Edit_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
    Aid_In      影像报告范文清单.原型id%Type,
    Seq_Num_In  影像报告范文清单.编号%Type,
    Title_In    影像报告范文清单.名称%Type,
    Note_In     影像报告范文清单.说明%Type,
    Content_In  影像报告范文清单.内容%Type,
    Subject_In  影像报告范文清单.学科%Type,
    Label_In    影像报告范文清单.标签%Type,
    Private_In  影像报告范文清单.是否私有%Type,
    Author_In   影像报告范文清单.作者%Type,
    Lasttime_In 影像报告范文清单.最后编辑时间%Type
	);
  --删除文档范文
  Procedure p_Del_Sample_List(
    Id_In 影像报告范文清单.Id%Type
	);

  --通过原型ID获得相应的范文信息
  Procedure p_Get_Samplelist_By_Aid(
    Val Out t_Refcur,
    Antetypelist_Id_In 影像报告范文清单.原型id%Type,
    Author_In          影像报告范文清单.作者%Type,
    Subjects_In        Varchar2
	);

  --通过种类id获取范文树
  Procedure p_Get_Samplelist_By_Kind(
    Val Out t_Refcur,
    Kind_In      Varchar2,
    Condition_In Varchar2,
    Author_In    影像报告范文清单.作者%Type,
    Subjects_In  Varchar2
	);

  --通过ID查找相应的范文信息
  Procedure p_Get_Samplelist_By_Id(
    Val Out t_Refcur,                                   
    Id_In 影像报告范文清单.Id%Type
	);

  --查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val Out t_Refcur,
	Aid_In 影像报告范文清单.原型id%Type
	);

  --获取范文XML信息
  Procedure p_Get_Samplexml(
    Val Out t_Refcur,     
	Id_In 影像报告范文清单.Id%Type
	);

  --修改范文XML信息
  Procedure p_Edit_Samplexml(
    Id_In      影像报告范文清单.Id%Type,
	Content_In 影像报告范文清单.内容%Type
	);

  --导出的范文列表
  Procedure p_Output_Samplelist(
    Val Out t_Refcur
	);

  --是否存在相应的原型类别
  Procedure p_If_Exist_Antetypelist(
    Val Out t_Refcur,
	Title_In 影像报告原型清单.名称%Type
	);

  --同一个类别下是否存在相同名称的范文
  Procedure p_If_Exist_Samplelist(
    Val Out t_Refcur,
    Type_In  影像报告原型清单.名称%Type,
    Title_In 影像报告范文清单.名称%Type
	);

  --通过范文ID获得范文对应的树形结构
  Procedure p_Get_SamplelistTree_By_Id(
    Val Out t_Refcur,
    Id_In 影像报告范文清单.Id%Type
	);

End b_Pacs_RptSampleList;
/

CREATE OR REPLACE Package Body b_Pacs_RptSampleList Is

  ------------------------------------------------------------------------
  --范文管理
  ------------------------------------------------------------------------

  --查找范文的原型类别

  Procedure p_Get_Sample_List_Type(
    Val Out t_Refcur,
    Type_In Varchar2,
    Kind_In Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(a.Id) ID, a.编码 || '-' || a.名称 名称
          From 影像报告原型清单 A
         Where a.Id In (Select Distinct b.原型id From 影像报告范文清单 B)
           and a.种类 = Kind_In;
    Else
      Open Val For
        Select Rawtohex(a.Id) ID, a.编码 || '-' || a.名称 名称
          From 影像报告原型清单 A
         where a.种类 = Kind_In
         Order By a.编码;
    End If;
  
  End p_Get_Sample_List_Type;
  --新增文档原型
  Procedure p_Add_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
	Aid_In      影像报告范文清单.原型id%Type,
	Seq_Num_In  影像报告范文清单.编号%Type,
	Title_In    影像报告范文清单.名称%Type,
	Note_In     影像报告范文清单.说明%Type,
	Content_In  影像报告范文清单.内容%Type,
	Subject_In  影像报告范文清单.学科%Type,
	Label_In    影像报告范文清单.标签%Type,
	Private_In  影像报告范文清单.是否私有%Type,
	Author_In   影像报告范文清单.作者%Type,
	Lasttime_In 影像报告范文清单.最后编辑时间%Type
	) As
    n_Num Number;
    v_Msg Varchar2(200);
    Err Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告范文清单 A
     Where a.原型id = Hextoraw(Aid_In)
       And a.名称 = Title_In;
  
    If n_Num > 0 Then
      v_Msg := '[ZLSOFT]在同一个原型下的范文名称不能相同！[ZLSOFT]';
      Raise Err;
    End If;
  
    Insert Into 影像报告范文清单
      (ID,
       原型id,
       编号,
       名称,
       说明,
       内容,
       学科,
       标签,
       是否私有,
       作者,
       最后编辑时间)
    Values
      (Hextoraw(Id_In),
       Hextoraw(Aid_In),
       Seq_Num_In,
       Title_In,
       Note_In,
       Content_In,
       Subject_In,
       Label_In,
       Private_In,
       Author_In,
       Sysdate);
  
    --这里添加对于该范文的处理,页眉页脚，页面设置
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/subdocuments',
                          (Select Extract(内容, 'zlxml/subdocuments')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页眉页脚
  
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/docparameters',
                          (Select Extract(内容, 'zlxml/docparameters')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页面设置
  
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Sample_List;

  --编辑范文信息
  Procedure p_Edit_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
    Aid_In      影像报告范文清单.原型id%Type,
    Seq_Num_In  影像报告范文清单.编号%Type,
    Title_In    影像报告范文清单.名称%Type,
    Note_In     影像报告范文清单.说明%Type,
    Content_In  影像报告范文清单.内容%Type,
    Subject_In  影像报告范文清单.学科%Type,
    Label_In    影像报告范文清单.标签%Type,
    Private_In  影像报告范文清单.是否私有%Type,
    Author_In   影像报告范文清单.作者%Type,
    Lasttime_In 影像报告范文清单.最后编辑时间%Type
	) As
    n_Num Number;
    v_Msg Varchar2(200);
    Err Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告范文清单 A
     Where a.原型id = Hextoraw(Aid_In)
       And a.名称 = Title_In
       And a.Id <> Hextoraw(Id_In);
  
    If n_Num > 0 Then
      v_Msg := '[ZLSOFT]在同一个原型下的范文名称不能相同！[ZLSOFT]';
      Raise Err;
    End If;
    Update 影像报告范文清单
       Set 原型id       = Hextoraw(Aid_In),
           编号         = Decode(Seq_Num_In, 0, 编号, Seq_Num_In),
           名称         = Title_In,
           说明         = Note_In,
           内容         = Content_In,
           学科         = Subject_In,
           标签         = Label_In,
           是否私有     = Private_In,
           作者         = Author_In,
           最后编辑时间 = Sysdate
     Where ID = Hextoraw(Id_In);
  
    --这里添加对于该范文的处理,页眉页脚，页面设置
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/subdocuments',
                          (Select Extract(内容, 'zlxml/subdocuments')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页眉页脚
  
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/docparameters',
                          (Select Extract(内容, 'zlxml/docparameters')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页面设置
  
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Sample_List;

  --删除文档范文
  Procedure p_Del_Sample_List(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单
     Where 影像报告范文清单.Id = Hextoraw(Id_In);
  End p_Del_Sample_List;

  --通过原型ID获取该原型下的范文列表
  Procedure p_Get_Samplelist_By_Aid(
    Val Out t_Refcur,
    Antetypelist_Id_In 影像报告范文清单.原型id%Type,
    Author_In          影像报告范文清单.作者%Type,
    Subjects_In        Varchar2
	) As
  Begin
    Open Val For
      Select /*+rule*/
       Rawtohex(a.Id) As ID,
       a.名称,
       a.作者,
       a.说明,
       a.学科,
       a.编号 Seqnum,
       a.标签,
       a.是否私有
        From 影像报告范文清单 A
       Where a.原型id = Hextoraw(Antetypelist_Id_In)
         And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
             Subjects_In Is Null Or
             (a.学科 Is Not Null And
             b_pacs_rptpublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
             a.是否私有 = 0));
  End p_Get_Samplelist_By_Aid;

  --通过种类id获取范文树
  Procedure p_Get_Samplelist_By_Kind(
    Val Out t_Refcur,
    Kind_In      Varchar2,
    Condition_In Varchar2,
    Author_In    影像报告范文清单.作者%Type,
    Subjects_In  Varchar2
	) As
  Begin
  
    --获得一个存在原型信息的范文树形结构
    Open Val For
      Select a.分组 As ID,
             a.分组 As 名称,
             '' 说明,
             '' As 上级id,
             ' category' As Type,
             '' As 作者,
             '' As 学科,
             Null 修改时间,
             '' As 标签,
             0 As Private,
             0 As Imgindex
        From 影像报告原型清单 A
       Where a.种类 = Kind_In
         And Exists
       (Select ID From 影像报告范文清单 C Where c.原型id = a.Id)
         And a.分组 Is Not Null
      Union
      Select m.*
        From (Select Rawtohex(b.Id) As ID,
                     b.名称,
                     b.说明,
                     b.分组 上级id,
                     'antetype' As Type,
                     '' As 作者,
                     '' As 学科,
                     Null 修改时间,
                     '' As 标签l,
                     0 As Private,
                     0 As Imgindex
                From 影像报告原型清单 B
               Where b.种类 = Kind_In
                 And Exists
               (Select ID From 影像报告范文清单 C Where c.原型id = b.Id)
               Order By b.编码) M
      Union All
      Select n.*
        From (Select /*+rule*/
               Rawtohex(a.Id) As ID,
               a.名称,
               a.说明,
               Rawtohex(a.原型id) As 上级id,
               'sample' As Type,
               a.作者,
               a.学科,
               a.最后编辑时间 As 修改时间,
               a.标签,
               a.是否私有 As Private,
               Decode(a.是否私有, 1, 2, 1) As Imgindex
                From 影像报告范文清单 A, 影像报告原型清单 C
               Where a.原型id = c.Id
                 And c.种类 = Kind_In
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
                     Subjects_In Is Null Or
                     (a.学科 Is Not Null And
                     b_pacs_rptpublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
                     a.是否私有 = 0))
               Order By a.编号, a.名称) N;
  
  End p_Get_Samplelist_By_Kind;

  --通过ID查找相应的范文信息
  Procedure p_Get_Samplelist_By_Id(
    Val Out t_Refcur,
	Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID,
             Rawtohex(a.原型id) As 原型id,
             a.编号,
             a.名称,
             a.说明,
             a.学科,
             a.标签,
             a.是否私有,
             a.作者,
             a.最后编辑时间 Lasttime
        From 影像报告范文清单 A
       Where a.Id = Hextoraw(Id_In);
  
  End p_Get_Samplelist_By_Id;

  --查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val Out t_Refcur,
    Aid_In 影像报告范文清单.原型id%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型id = Hextoraw(Aid_In);
  End p_Get_Samplelist_Maxseqnum;

  --获取范文XML信息
  Procedure p_Get_Samplexml(
    Val Out t_Refcur,
	Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Open Val For
      Select A.内容.getclobval() 内容 From 影像报告范文清单 A Where a.Id = Id_In;
  End p_Get_Samplexml;

  --修改范文XML信息
  Procedure p_Edit_Samplexml(
    Id_In      影像报告范文清单.Id%Type,
	Content_In 影像报告范文清单.内容%Type
	) As
  Begin
    Update 影像报告范文清单
       Set 内容 = Content_In
     Where ID = Hextoraw(Id_In);
  End p_Edit_Samplexml;

  --导出的范文列表
  Procedure p_Output_Samplelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select *
        From (Select Rawtohex(a.Id) As ID,
                     Null As Aid,
                     a.名称 As Antetypename,
                     Null As Code,
                     a.名称 As Title,
                     a.说明 As Note,
                     Null As Content,
                     Null As Subject,
                     Null As Label,
                     Null As Private,
                     Null As Author,
                     Null As Lasttime,
                     '' As Flag,
                     1 As Image,
                     'antetype' As Type
                From 影像报告原型清单 A
               Where Exists (Select b.Id
                        From 影像报告范文清单 B
                       Where b.原型id = a.Id)
               Order By a.编码)
      Union All
      Select Rawtohex(c.Id) As ID,
             Rawtohex(c.原型id) As Aid,
             d.名称,
             c.编号,
             c.名称,
             c.说明,
             '',
             c.学科,
             c.标签,
             c.是否私有,
             c.作者,
             c.最后编辑时间,
             '',
             0,
             'sample'
        From 影像报告范文清单 C, 影像报告原型清单 D
       Where c.原型id = d.Id;
  
  End p_Output_Samplelist;

  --是否存在相应的原型类别
  Procedure p_If_Exist_Antetypelist(
    Val Out t_Refcur,
	Title_In 影像报告原型清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(a.Id) Num
        From 影像报告原型清单 A
       Where a.名称 = Title_In;
  End p_If_Exist_Antetypelist;

  --同一个类别下是否存在相同名称的范文
  Procedure p_If_Exist_Samplelist(
    Val Out t_Refcur,
    Type_In  影像报告原型清单.名称%Type,
    Title_In 影像报告范文清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(a.Id) Num, Max(a.Id) ID
        From 影像报告范文清单 A, 影像报告原型清单 B
       Where a.原型id = b.Id
         And a.名称 = Title_In
         And b.名称 = Type_In;
  End p_If_Exist_Samplelist;
  
  --通过范文ID获得范文对应的树形结构
  Procedure p_Get_SamplelistTree_By_Id(
    Val Out t_Refcur,
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    --'EE7CD4A510B045A9BBE6D8CC7DB6EE30'
    Open Val For
      Select RawToHex(t.ID) as ID,
             t.名称,
             T.说明,
             RawToHex(T.原型ID) 原型ID,
             'sample' 类型,
             t.作者,
             t.学科,
             t.最后编辑时间,
             t.标签,
             t.是否私有,
             2 IMGINDEX
        From 影像报告范文清单 t
       Where t.id = Id_In
      Union All
      Select RawToHex(x.id) as ID,
             x.名称,
             x.说明,
             x.分组 原型ID,
             'antetype' 类型,
             null 作者,
             null 学科,
             null 最后编辑时间,
             null 标签,
             0 是否私有,
             0 IMGINDEX
        From 影像报告原型清单 x
       Where x.id = (Select t.原型id
                       From 影像报告范文清单 t
                      where t.id = Id_In
                        and rownum <= 1)
      Union All
      Select x.分组 as ID,
             x.分组 名称,
             null 说明,
             null 原型ID,
             'category' 类型,
             null 作者,
             null 学科,
             null 最后编辑时间,
             null 标签,
             0 是否私有,
             0 IMGINDEX
        From 影像报告原型清单 x
       Where x.ID = (Select t.原型id
                       From 影像报告范文清单 t
                      where t.id = Id_In
                        and rownum <= 1);
  End p_Get_SamplelistTree_By_Id;
End b_Pacs_RptSampleList;
/



--影像报告业务(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptManage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	);

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In 影像报告记录.报告质量%Type
	);
                                
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	);
                                
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	);

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type 
	);

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	);

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor);

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	);

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	);

  --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add(Id_In   影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type);

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	);

  --12、获取签名类型
  Procedure p_Get_SysConfigSignature(
    Val           Out t_Refcur,
	科室ID_In		In 部门表.ID%Type
	);

--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  );


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  );

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  );

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  );

--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In	影像报告驳回.医嘱ID%Type, 
  报告ID_In	影像报告驳回.检查报告ID%Type, 
  驳回理由_In 影像报告驳回.驳回理由%Type, 
  驳回时间_In 影像报告驳回.驳回时间%Type, 
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  );

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  );

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In	影像报告驳回.检查报告ID%Type
  );

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型id_In 影像报告动作.原型id%Type
  );

--20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In  Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In    Varchar2
    );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    );

  --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
    );

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );
  
  --24、提取文档标题
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱ID_IN  影像报告记录.医嘱ID%TYPE   
    );
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,  
    科室ID_IN  影像流程参数.科室ID%TYPE
    );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    );

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
    Val           Out t_Refcur,
    医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
    报告ID_IN  影像报告记录.ID%TYPE
    );
  

end b_PACS_RptManage;
/

--影像报告业务(---实现部分---)***************************************************

CREATE OR REPLACE Package Body b_PACS_RptManage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	) Is
  Begin
  
    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 A Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 A
         Set a.锁定人 = 锁定人_In
       Where a.Id = 报告_Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In  影像报告记录.报告质量%Type
	) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatRptQuality;
  
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	) Is
  Begin
     Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatResult;
  
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	) Is
    v_报告发放     影像报告记录.报告发放%Type; 
  Begin
    
    Begin 
		  Select nvl(报告发放,0) Into v_报告发放 From 影像报告记录 where ID=报告Id_In; 
    Exception 
      When Others Then 
        v_报告发放 :=0; 
    End; 
     
    Update 影像报告记录 Set 报告发放 =decode(v_报告发放,0,1,0),报告发放人=decode(v_报告发放,0,当前操作人_In,'') Where ID=报告Id_In; 
     
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_ReportRelease; 

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type
	) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_报告序号  number;
    x_报告内容  Xmltype;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       number;
    Err_Custom Exception;

    Function Elist_Filter(
	  Source_t t_Editlist
	  ) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin

      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                   From Table(Cast(Source_t As t_Editlist)) A
                  Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人,
                                            Rs.编辑时间,
                                            Rs.签名,
                                            Rs.审订签名);
      End Loop;
      Return Target_t;
    End;

    Function Build_Editlog(
	  Tn_Edit t_Editlist,
	  To_Edit t_Editlist,
	  v_Did   影像报告记录.Id%Type) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录

      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;

      Function Atitle(原型ID 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型ID Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where ID = 原型ID;
          Return v_原型名称;
        End If;
      End;

    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;

        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4)
          Into n_Class
          From Dual;
        Select Appendchildxml(x_Return,
                              '/root',
                              Xmlelement("operate",
                                         Xmlforest(r_Saveid As "saving_id",
                                                   n_Class As "class",
                                                   To_Char(Cur_Time,
                                                           'yyyy-mm-dd hh24:mi:ss') As
                                                   "cur_time",
                                                   最后编辑人_In As "operator",
                                                   Decode(n_Class,
                                                          4,
                                                          Tns_Edit(Tns_Edit.Count).编辑人,
                                                          '') As "signer",
                                                   '' As Adjunct)))
          Into x_Return
          From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;

        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;

        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                '/root',
                                Xmlelement("operate",
                                           Xmlforest(r_Saveid As "saving_id",
                                                     n_Class As "class",
                                                     To_Char(Cur_Time,
                                                             'yyyy-mm-dd hh24:mi:ss') As
                                                     "cur_time",
                                                     最后编辑人_In As "operator",
                                                     Decode(n_Class,
                                                            4,
                                                            v_Signor,
                                                            6,
                                                            v_Signor,
                                                            '') As "signer",
                                                     v_Adjunct As Adjunct)))
            Into x_Return
            From Dual;
        End If;

      End If;
      Return x_Return;
    End Build_Editlog;

    Function Get_NextRPTNum(
	  AntetypeName 影像报告原型清单.名称%Type, 
	  Order_ID 影像报告记录.医嘱Id%Type
	  ) 
      Return Number Is
        v_序号 Number;
        v_count Number;
        v_num Number;
      Begin
        
        v_count :=0;
        v_num :=1;
        loop
             select count(*)+v_num into v_序号 from 影像报告记录 where 医嘱ID=Order_ID; 
             select count(*) into v_count from 影像报告记录 where 医嘱ID=Order_ID and 文档标题=AntetypeName||'_'||v_序号;
             
             if v_count =0 then 
               exit;
             end if;
             
             v_num := v_num +1;
         end loop;
        
         return v_序号;                                                     
     End;
      
  Begin

    Select 名称, Sysdate
      Into v_原型名称, Cur_Time
      From 影像报告原型清单
     Where ID = 原型ID_In;

    ---------------------1 匿名数据处理-----------------------------

    x_报告内容 := 报告内容_In;

    --------------------2 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_PACS_RptPublic.f_Geteditlist(报告内容_In);


    --------------------3 处理编辑日志--------------------
    select count(*) into v_New from 影像报告记录 where ID=Id_In;

    If v_New=0 Then
      --新增报告
      v_报告id:=Id_In;
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);
      
      --取报告序号  
      v_报告序号 := Get_NextRPTNum(v_原型名称,医嘱ID_In);

      Insert Into 影像报告记录
        (ID,
         原型ID,
         文档标题,
         报告内容,
         创建时间,
         创建人,
         报告状态,
         最后编辑时间,
         最后编辑人,
         编辑日志,
         医嘱ID,
         记录人)
      Values
        (v_报告id,
         原型ID_In,
         v_原型名称||'_'||v_报告序号,
         x_报告内容,
         Cur_Time,
         最后编辑人_In,
         1,
         Cur_Time,
         最后编辑人_In,
         x_Editlog,
         医嘱ID_In,
         记录人_In);
      Insert Into 病人医嘱报告(医嘱ID,检查报告ID)Values(医嘱ID_In,v_报告id);

    Else
      --提取文件原始编辑记录,必需在更新之前提取
      v_报告id := Id_In;
      Select b_PACS_RptPublic.f_Geteditlist(报告内容)
        Into To_Editlist
        From 影像报告记录
       Where ID = v_报告id;

      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志,
                            '/root',
                            Extract(x_Editlog, '/root/*'))
             Into x_Editlog From 影像报告记录 Where ID = v_报告id;

       Update 影像报告记录
                Set 报告内容     = 报告内容_In,
                最后编辑时间 = Cur_Time,
                最后编辑人   = 最后编辑人_In,
                编辑日志     = x_Editlog,
                记录人       =记录人_In
                Where ID = v_报告id;
       end if;

  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	) As
  Begin
    Open Val For
      Select  Nvl(a.报告内容, '<ZLXML/>') As 报告内容 From 影像报告记录 A Where a.Id = DocID_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor) As
  Begin
    Open Val For
      Select 操作人, 操作时间
        From 影像报告操作记录
       Where 报告ID = 报告ID_In
         And 操作类型=1
         And 操作时间 >= Signdate_In
         And 作废时间 Is Null
       Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 B
       Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
     Where 报告ID = 报告ID_In And 操作类型=1
       And 操作时间 >= Signdate_In;

  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型ID = 原型ID_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;
  
 --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add(Id_In   影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type) As
  n_医嘱ID 影像报告操作记录.医嘱ID%Type;                              
  Begin
    
  Begin
    Select 医嘱ID Into n_医嘱ID From 影像报告记录 Where ID = 报告ID_In;
  Exception
    When Others Then
      null;
  End;
  if n_医嘱ID is not null then 
    Insert Into 影像报告操作记录
      (ID, 报告ID,医嘱ID, 操作人, 操作时间,操作类型)
    Values
      (Id_In, 报告ID_In, n_医嘱ID, 操作人_In, sysdate,操作类型_In);
    if 操作类型_In=1 then 
        update 影像报告记录 set 报告打印=1 where ID=报告ID_In;
    end if;
  end if;
  Exception
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	) As
  Begin    

    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);

    Delete From 病人医嘱报告 Where 检查报告ID =hextoraw(报告_Id_In);

  Exception   
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_删除;


--12、获取签名类型
Procedure p_Get_SysConfigSignature(
  Val           Out t_Refcur,
  科室ID_In		In 部门表.ID%Type
  )Is
Begin
    --返回用户, 模块号,功能
	Open  Val For 
	    select Zl_Fun_Getsignpar(7, 科室ID_In) as 签名类型 from dual;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  )Is
  v_sql Varchar2(1000);
  n_count Number(5);
Begin                
  Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');
  
  If n_Count > 0 Then
     v_sql := 'Truncate Table 影像签名图片';
     Execute Immediate v_sql;   
     
     v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
     Execute Immediate v_sql;  
  Else
     v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;  
     Execute Immediate v_sql;    
  End If; 
    
  v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';
    --返回用户, 模块号,功能
	Open  Val For v_sql Using ID_In;  

Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select ID, CertDN,CertSN,SignCert,EncCert From 人员证书记录 Where ID=证书ID_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  )Is
Begin
  --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
  --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
  if (报告状态_In=1) or (报告状态_In=2) or (报告状态_In=5) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=null,最后审核时间=null Where ID=报告Id_In;
  elsif (报告状态_In=3) or (报告状态_In=4) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=审核人_In,最后审核时间=sysdate Where ID=报告Id_In;
  else
    Update 影像报告记录 Set 报告状态=报告状态_In Where ID=报告Id_In;
  end if;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select 报告状态 From 影像报告记录 Where ID=报告Id_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;



--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In  影像报告驳回.医嘱ID%Type,
  报告ID_In  影像报告驳回.检查报告ID%Type,
  驳回理由_In 影像报告驳回.驳回理由%Type,
  驳回时间_In 影像报告驳回.驳回时间%Type,
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  )Is
Begin
  Insert Into 影像报告驳回(ID, 医嘱ID,检查报告ID,驳回理由,驳回时间,驳回人)
  Values(影像报告驳回_ID.NEXTVAL, 医嘱ID_IN, 报告ID_In, 驳回理由_IN, 驳回时间_IN, 驳回人_IN);

  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人=待处理人_In Where ID=报告ID_In;

  --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  )Is
Begin
  Update 影像报告驳回 Set 是否撤销=1 Where ID=ID_In;
  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人='' Where ID=报告ID_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In  影像报告驳回.检查报告ID%Type
  )Is
Begin
  Open  Val For
    Select A.ID, A.驳回理由, A.驳回时间, A.驳回人, Nvl( A.是否撤销,0) As 驳回状态, B.报告状态
    From 影像报告驳回 A, 影像报告记录 B Where A.检查报告ID=报告Id_In And A.检查报告ID = B.ID Order by 驳回时间;
End;

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型ID_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称 As 动作名称,
			 e.名称 As 事件名称,
			 e.种类 As 事件种类,
			 e.元素IID As 元素IID,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容,'<NULL/>')) As 内容, 
             RawtoHex(p.事件ID) 事件ID
        From 影像报告动作 P, 影像报告事件 E
       Where p.事件ID = e.Id(+) And p.原型ID=原型ID_In
       Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In          Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In          Varchar2
  ) As
  Begin

    Open Val For
      Select /*+ rule*/ Rawtohex(a.Id) ID, a.名称, a.作者, a.说明,
             Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 A
      Where a.原型ID = Hextoraw(原型id_In) And
            ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And  b_PACS_RptPublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0)) And
            (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_PACS_RptPublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;

  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    )Is
  begin
       open val for
       select 名称 from 部门表 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_部门名称_By_ID;
    

 --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
  )Is
  begin
       open val for
       Select Rawtohex(ID) ID, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_AllPreOutlines;

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  begin
       open val for
       select 文档标题 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_reportTitle_By_ID;

  --24、提取文档标题
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  Begin
       Open Val For
         Select 锁定人 From 影像报告记录 Where id =ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_报告锁定人_By_ID;

 --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
	医嘱ID_IN  影像报告记录.医嘱ID%TYPE
    )Is
  Begin
       Open Val For
       Select RawToHex(ID) As REPORTID, RawToHex(原型ID) As ANTETYPEID, 医嘱ID As ORDERID,文档标题 As REPORTNAME,
              创建时间 As REPORTDATE, Decode(Nvl(报告状态,0),1,'编辑中',2,'已诊断',3,'已审核',4,'已终审',5,'诊断驳回','审核驳回') As REPORTSTATE,
              创建人 As CreateUser,最后审核人 As ExamineyUser,Decode(Nvl(结果阳性,0),1,'阳性','') As RESULTPOSITIVE,
              Nvl(报告质量,0) As INNERQUALITY,' ' As REPORTQUALITY, Decode(Nvl(报告打印,0),0,'未打印','已打印') As ReportPrint,
              Decode(Nvl(报告发放,0),0,'未发放','已发放') As REPORTRELEASE ,记录人 as RECDOCTOR From 影像报告记录 Where 医嘱ID =医嘱ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱ID;
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,
	科室ID_IN  影像流程参数.科室ID%TYPE
    )Is
  Begin
       Open val For
       Select 参数名,参数值 From 影像流程参数 Where 科室ID=科室ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    )Is
  Begin
       Open Val For
       Select rawtohex(c.id) As ANTETYPEID , c.名称 As ANTETYPENAME,c.说明 
       From 病人医嘱记录 a,影像报告原型应用 b,影像报告原型清单 c 
       Where a.id=医嘱_IN And a.诊疗项目id=b.诊疗项目ID And b.报告原型ID=c.id And a.病人来源 =b.应用场合;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱ID;

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  )is
  begin
       open val for
       Select  c.文档标题 , b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
               To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
               From 影像报告操作记录 B, 影像报告记录 C
               Where c.Id = 报告_IN And b.报告ID = c.Id And 操作类型=1 Order By b.操作时间;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_ReportPrintLog_By_报告ID;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    )Is
  Begin
       Open val For
       Select rawtohex(ID) As 报告ID, 文档标题 As 报告名称,最后编辑时间 as 报告日期,
              decode(nvl(报告发放,0),0,'未发放','已发放') As 报告发放 
              From 影像报告记录 Where 报告状态 Between 2 And 4 And 医嘱ID =医嘱_IN;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ReportReleaseList;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    )Is
  Begin
       Open val For
       Select count(*) As 驳回数量 From 影像报告驳回 Where 检查报告ID=报告_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RejectedCount;

   --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    )Is
  Begin
       open val for
       select ID as 医嘱ID,主页ID,挂号单 from 病人医嘱记录 where ID=医嘱_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocProcess_IDs;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
       Val           Out t_Refcur,
       医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
       报告ID_IN  影像报告记录.ID%TYPE
  )Is
  Begin
      If 报告ID_IN Is Null Then 
        Open Val For 
        Select 执行科室ID,'创建人' As 创建人 From 影像检查记录 Where 医嘱ID=医嘱ID_IN;
      Else
        Open Val For
        Select 执行科室ID,创建人 From 影像检查记录 A,影像报告记录 b Where a.医嘱ID=B.医嘱ID and b.id=报告ID_IN;
      End if;
       

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocInfo;

End b_PACS_RptManage;
/


--影像报告范文管理(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptPluginOriginal Is
  Type t_Refcur Is Ref Cursor;

  -- 功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
	);

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     In varchar2,
    EditorType_In Number := 0 --0:PACS报告编辑器，1--电子病历编辑器，2--报告文档编辑器
    );
  --功    能：根据医嘱ID获取检查UID
  Procedure p_GetStudyUid(
    Val       Out t_Refcur,
	医嘱id_In In 影像检查记录.医嘱id%Type
	);
  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur, 
    查询条件_In In varchar2,
    是否临时_In In number:=0
	);
  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
	);
  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val         Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
	);
  
  --功能;获取图像备注
  procedure P_Get_NormalNote(
    Val         Out t_Refcur
	);
  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in in 影像字典内容.名称%Type,
	code_In 影像字典内容.简码%Type
	);
  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
	num_In  影像字典内容.编号%Type
	);
  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
	);

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
	);
  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
	类名_In In 影像报告插件.类名%Type
	);
  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2, 
	user_In nvarchar2
	);
  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2
	);
  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2, 
	user_In nvarchar2
	);
  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
	user_In nvarchar2
	);
End b_PACS_RptPluginOriginal;
/

--影像报告范文管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptPluginOriginal Is

  --功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
	) Is
    strSql     varchar2(4000);
    strSqlBack varchar2(4000);
    strFilter  varchar2(400);
  Begin
    If 查看其他科历史报告_In = 1 Then
      strFilter := ' ';
    Else
      strFilter := ' And c.执行科室id+0 in (select 部门id from 部门人员 where 人员id = '|| 人员id_In || 
                   ' union all select to_Number(' || 当前科室id_In || ') from dual) ';
    End If;

    strSql := 'Select 2 as 报告类型, c.Id As 医嘱id, a.影像类别 as 类别,b.创建人 as 报告人, to_char(b.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间, c.医嘱内容, TO_CHAR(RAWTOHEX(b.id)) 报告ID ' ||
              'From 影像检查记录 A, 影像报告记录 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id =' ||
              医嘱id_In || ' And b.医嘱id = c.Id And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null ' || strFilter ||
              ' union all ' ||
              'Select 1 as 报告类型, c.Id As 医嘱id, a.影像类别 as 类别, a.报告人, to_char(f.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间, c.医嘱内容,TO_CHAR( b.病历id) as 报告ID ' ||
              'From 影像检查记录 A, 病人医嘱报告 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 电子病历记录 F ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id = ' ||
              医嘱id_In || '  And b.医嘱id = c.Id And b.病历ID Is Not Null And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null And b.病历id = f.id ' || strFilter;
              
    strSqlBack := strSql;
    strSqlBack := replace(strSqlBack, '影像检查记录', 'H影像检查记录');
    strSqlBack := replace(strSqlBack, '病人医嘱报告', 'H病人医嘱报告');
    strSqlBack := replace(strSqlBack, '病人医嘱记录', 'H病人医嘱记录');

    strSql := strSql || ' UNION ALL ' || strSQLBack || ' Order By 创建时间 Asc';

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportHistory;

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     varchar2,
    EditorType_In Number := 0 --0:电子病历编辑器，1--PACS报告编辑器，2--报告文档编辑器
    ) Is
    strSql varchar2(1000);
  Begin
    If EditorType_In = 1 Then
      strSql := 'Select a.内容文本 As 标题, b.对象属性, b.内容文本 As 正文,b.开始版 as 版本 From 电子病历内容 a,电子病历内容 b ' ||
                'Where a.文件id = ' || 报告ID_In ||
                ' And a.对象类型 = 3 And a.Id = b.父ID And b.对象类型 = 2 and b.终止版=0 ';
    ElsIf EditorType_In = 0 Then
      strSql := 'select 内容 from 电子病历格式 where 文件ID=' || 报告ID_In;
    Else
      strSql := 'Select 报告内容 As 内容 From 影像报告记录 Where ID=HexToRaw(''' ||
                报告ID_In || ''')';
    End If;
  
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportContent;

  --功    能：根据医嘱ID获取检查UID
  Procedure p_GetStudyUid(
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
	) Is
    strSql varchar2(100);
  Begin
    strSql := 'Select 检查UID from 影像检查记录 where 医嘱ID =' || 医嘱id_In;
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyUid;

  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur, 
    查询条件_In In varchar2,
    是否临时_In In number:=0 
	) Is
    strSql varchar2(2000);
  Begin
    if 是否临时_In = 0 then
      strSql := 'select T1.返回值+T2.返回值 as 返回值 from ' ||
              '(select count(1) as 返回值 from 影像检查图象 a, 影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T1,' ||
              '(select count(1) as 返回值 from H影像检查图象 a, H影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T2';
    else
      strSql := 'select count(1)  as 返回值 from 影像临时图象  where  序列UID='''||查询条件_In || '''';
    end if;
  
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageCount;

  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
	) Is
    strSql    varchar2(2000);
    strFilter varchar2(100);
  Begin
    if 查询方式_In = 0 then
      strFilter := 'and c.医嘱ID=''' || 查询条件_In || '''';
    elsif 查询方式_In = 1 then
      strFilter := 'and B.序列UID=''' || 查询条件_In || '''';
    else
      strFilter := 'and A.图像UID=''' || 查询条件_In || '''';
    end if;
    
    strSql := 'Select * from (Select rownum as 顺序号, T.* from(' ||
              'Select A.图像号,D.FTP用户名 As User1,D.FTP密码 As Pwd1,D.IP地址 As Host1,''/''||D.Ftp目录||''/'' As Root1,' ||
              'Decode(C.接收日期,Null,'''',to_Char(C.接收日期,''YYYYMMDD'')||''/'')||C.检查UID||''/''||A.图像UID As URL,d.设备号 as 设备号1,' ||
              'E.FTP用户名 As User2,E.FTP密码 As Pwd2,E.IP地址 As Host2,''/''||E.Ftp目录||''/'' As Root2,' ||
              'e.设备号 as 设备号2, A.图像UID,C.检查UID,B.序列UID,A.动态图,A.编码名称,A.采集时间, A.录制长度 ' ||
              'From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像设备目录 D,影像设备目录 E ' ||
              'Where A.序列UID=B.序列UID And B.检查UID=C.检查UID And C.位置一=D.设备号(+) And C.位置二=E.设备号(+) ' ||
              strFilter || ' '|| 'Order by 序列UID, 图像号) T ) ' ||
              'Where 顺序号>=' || 开始位置_In || ' and 顺序号<=' || 结束位置_In || '';
              
    if 是否临时_In = 1 then
      strSql:= replace(strSql,'影像检查','影像临时');
    end if;
    
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageData;
  
  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
	) As
  Begin
    If 姓名_In Is Null Then
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate
        order by 序号;
    Else
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate and a.姓名 = 姓名_In
        order by 序号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：获取图像备注
  Procedure p_Get_Normalnote(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b.编号 As 编号, b.名称 As 名称
        From 影像字典清单 A, 影像字典内容 B
       Where a.Id = b.字典id
         And a.名称 = '影像图像备注';
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in In 影像字典内容.名称%Type,
	code_In 影像字典内容.简码%Type
	) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Select Decode(Max(to_number(编号)), Null, 0, Max(to_number(编号)))
      Into n_Num
      From 影像字典内容
     Where 字典id = dictionary_id;
    n_Num := n_Num + 1;
    Insert Into 影像字典内容
      (字典id, 编号, 名称, 说明)
    Values
      (dictionary_id, to_char(n_Num), note_in, '影像图像备注');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Insert_Normalnote;

  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
	num_In  影像字典内容.编号%Type
	) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Update 影像字典内容 t
       Set t.名称 = note_in
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Normalnote;

  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
	) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Delete 影像字典内容 t
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Normalnote;

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
	) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Open Val For
      Select Decode(Max(to_number(编号)), Null, 1, Max(to_number(编号) + 1)) 编号
        From 影像字典内容 t
       Where t.字典id = dictionary_id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_NormalNum;

  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
	) Is
  Begin
    Open Val For
      Select RawToHex(ID) ID From 影像报告插件 Where 类名 = 类名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_PlugID;

  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2, 
	user_In nvarchar2
	) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = font_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, font_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFontParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2	
	) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFontParam;

  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2, 
	user_In nvarchar2
	) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = form_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, form_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFormParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
	user_In nvarchar2
	) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFormParam;
End b_PACS_RptPluginOriginal;
/


--影像报告范文管理(---定义部分---)***************************************************
Create Or Replace Package b_PACS_RptPluginCustom Is
  Type t_Refcur Is Ref Cursor;
-- 功    能：该方法只用于演示...
  Procedure Demo1;

end b_PACS_RptPluginCustom ;
/

--影像报告范文管理(---实现部分---)***************************************************
Create Or Replace Package Body b_PACS_RptPluginCustom  Is
-- 功    能：该方法只用于演示...
  Procedure Demo1
  Is
  Begin
      --TODO:
      Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End Demo1;

End b_PACS_RptPluginCustom;
/


--84345:许华峰,2015-06-30,是否发送WorkList
CREATE OR REPLACE Procedure ZL_影像检查记录_发送安排
( 
  医嘱ID_In       影像检查记录.医嘱ID%Type,
  发送号_In       影像检查记录.发送号%Type,
  是否安排_In     影像检查记录.是否安排%Type,
  检查技师_In     影像检查记录.检查技师%Type, 
  检查技师二_In   影像检查记录.检查技师二%Type, 
  执行间_In       病人医嘱发送.执行间%Type
) As 
Begin 
 
  Update 影像检查记录 
  Set    检查技师 = 检查技师_In, 检查技师二 = 检查技师二_In, 是否安排 = 是否安排_In
  Where  医嘱ID = 医嘱ID_In and 发送号 =发送号_In; 
 
  Update 病人医嘱发送 
  Set 执行间 = 执行间_In
  Where 医嘱ID=医嘱ID_In and 发送号=发送号_In; 
Exception 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End ZL_影像检查记录_发送安排;
/

--82076:刘尔旋,2015-07-01,门诊转住院三方结算修改
Create Or Replace Procedure Zl_门诊转住院_三方卡结算
(
  结算序号_In   病人预交记录.结算序号%Type,
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  三方退费_In   Number := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  v_结帐ids  Varchar2(3000);
  n_返回值   人员缴款余额.余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_退现     Number;
  v_预交no   病人预交记录.No%Type;
  v_结算方式 结算方式.名称%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  v_Nos      Varchar2(3000);
  n_Tempid   病人预交记录.Id%Type;
  v_流水号   病人预交记录.交易流水号%Type;
  v_说明     病人预交记录.交易说明%Type;
  n_预交id   病人预交记录.Id%Type;
  n_病人id   病人信息.病人id%Type;
  n_原结帐id 病人预交记录.结帐id%Type;
  n_部分退费 Number;
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_结帐id;
  Delete From 病人预交记录 Where 结帐id = n_结帐id And 校对标志 = 1;
  If No_In Is Null Then
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
    For r_结帐ids In (Select Distinct a.结帐id
                    From 门诊费用记录 A
                    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                          a.记录状态 <> 0) Loop
      v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
    End Loop;
    v_结帐ids := Substr(v_结帐ids, 2);
  
    Select 结帐id, 病人id
    Into n_原结帐id, n_病人id
    From 门诊费用记录
    Where 结帐id = Abs(结算序号_In) And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));
  
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                         a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And b.性质 = 7
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        Begin
          Select 1 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id And 是否退现 = 1;
        Exception
          When Others Then
            n_退现 := 0;
        End;
      
        If n_退现 = 0 And 三方退费_In = 0 Then
          v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
          Raise Err_Item;
        End If;
      
        If n_退现 = 1 Then
          Begin
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
          Exception
            When Others Then
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
          End;
        End If;
      
        If 三方退费_In = 1 Then
          v_结算方式 := c_预交.结算方式;
        End If;
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - c_预交.冲预交
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
          n_返回值 := c_预交.冲预交;
        End If;
      
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
        End If;
      
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
             c_预交.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
        End If;
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                          a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And b.性质 = 7
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        Begin
          Select 1 Into n_退现 From 医疗卡类别 Where ID = r_Pay.卡类别id And 是否退现 = 1;
        Exception
          When Others Then
            n_退现 := 0;
        End;
      
        If 三方退费_In = 1 Then
          v_结算方式 := r_Pay.结算方式;
        End If;
        If n_退现 = 0 And 三方退费_In = 0 Then
          v_结算方式 := r_Pay.结算方式;
        End If;
        If n_退现 = 1 And 三方退费_In = 0 Then
          Begin
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
          Exception
            When Others Then
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
          End;
        End If;
      
        If 三方退费_In = 0 Then
          If v_结算方式 = r_Pay.结算方式 Then
            Select 交易流水号, 交易说明 Into v_流水号, v_说明 From 病人预交记录 Where ID = r_Pay.预交id;
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位)
              Values
                (n_预交id, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In, Null, Null,
                 Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, v_流水号, v_说明,
                 r_Pay.合作单位);
              Update 三方结算交易 Set 交易id = n_预交id Where 交易id = r_Pay.预交id;
            End If;
          Else
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          End If;
        
          --病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
          Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
            n_返回值 := r_Pay.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End If;
        --4.2缴款数据处理
        --   因为没有实际收病人的钱,所以不处理
        --部分退费情况，退原预交记录
        If 三方退费_In = 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
            n_返回值 := r_Pay.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
             r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
        End If;
      End Loop;
    End If;
  Else
    Select 结帐id, 病人id
    Into n_原结帐id, n_病人id
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;
    Begin
      Select 1 Into n_部分退费 From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 2 And NO = No_In And Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
    Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id;
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And a.No = No_In And a.结算方式 = b.名称 And b.性质 = 7
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        Begin
          Select 1 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id And 是否退现 = 1;
        Exception
          When Others Then
            n_退现 := 0;
        End;
      
        If n_退现 = 0 And 三方退费_In = 0 Then
          v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
          Raise Err_Item;
        End If;
        If n_退现 = 1 Then
        
          Begin
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
          Exception
            When Others Then
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
          End;
        
        End If;
        If 三方退费_In = 1 Then
          v_结算方式 := c_预交.结算方式;
        End If;
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - c_预交.冲预交
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
          n_返回值 := c_预交.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
        End If;
      
        --部分退费情况，退原预交记录
      
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
             c_预交.合作单位, n_结帐id, n_结帐id, 0, 3);
        End If;
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And a.No = No_In And a.结算方式 = b.名称 And
                          (b.性质 = 7 And Exists (Select 1 From 医疗卡类别 Where ID = a.卡类别id And 是否退现 = 1))
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If n_部分退费 = 0 Then
          v_结算方式 := r_Pay.结算方式;
        Else
          Begin
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
          Exception
            When Others Then
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
          End;
        End If;
      
        If 三方退费_In = 0 Then
          If v_结算方式 = r_Pay.结算方式 Then
            Select 交易流水号, 交易说明 Into v_流水号, v_说明 From 病人预交记录 Where ID = r_Pay.预交id;
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位)
              Values
                (n_预交id, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In, Null, Null,
                 Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, v_流水号, v_说明,
                 r_Pay.合作单位);
              Update 三方结算交易 Set 交易id = n_预交id Where 交易id = r_Pay.预交id;
            End If;
          Else
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          End If;
        
          --病人余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
          Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
            n_返回值 := r_Pay.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End If;
        --4.2缴款数据处理
        --   因为没有实际收病人的钱,所以不处理
        --部分退费情况，退原预交记录
        If 三方退费_In = 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
            n_返回值 := r_Pay.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        Update 病人预交记录
        Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
        Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
             缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
             Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
             r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
        End If;
      End Loop;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_三方卡结算;
/

--85875:胡俊勇,2015-06-29,取消接诊
CREATE OR REPLACE Procedure Zl_病人接诊_Cancel
(
  病人id_In 病人信息.病人id%Type,
  No_In     病人挂号记录.No%Type
) As
  v_门诊号   病人信息.门诊号%Type;
  v_挂号id   病人挂号记录.Id%Type; 
  v_分诊方式 挂号安排.分诊方式%Type; 
Begin
  Select 门诊号 Into v_门诊号 From 病人信息 Where 病人id = 病人id_In;
  Select ID Into v_挂号id From 病人挂号记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;

  --确定原挂号号别的医生,用于还原 
  Begin
    Select Nvl(a.分诊方式, 0) Into v_分诊方式 From 挂号安排 A, 病人挂号记录 B Where a.号码 = b.号别 And b.No = No_In;
  Exception
    When Others Then
      Null;
  End;

  --就诊状态 
  Update 病人信息 Set 就诊时间 = Null, 就诊状态 = 1 Where 病人id = 病人id_In;

  Update 门诊费用记录
  Set 执行状态 = 0, 执行时间 = Null, 发药窗口 = Decode(v_分诊方式, 0, Null, 发药窗口), 结论 = Null
  Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);

  Update 病人挂号记录
  Set 执行状态 = 0, 执行时间 = Null, 诊室 = Decode(v_分诊方式, 0, Null, 诊室), 摘要 = Null
  Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;

  --删除过敏，诊断信息 
  Zl_病人过敏记录_Delete(病人id_In, v_挂号id);
  Zl_病人诊断记录_Delete(病人id_In, v_挂号id, Null, Null, '1,11');
  Update 排队叫号队列 Set 排队状态 = 0 Where 业务类型 = 0 And 业务id = v_挂号id;

  Delete From 病人医嘱记录 Where 病人id = 病人id_In And 挂号单 = No_In And 医嘱状态 = 1;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊_Cancel;
/

--85952:胡俊勇,2015-06-25,转科医嘱回退问题
Create Or Replace Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                --还原医嘱执行时间
                Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                Into v_Time
                From Dual;
                Insert Into 医嘱执行时间
                  (要求时间, 医嘱id, 发送号)
                  Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                  From Table(f_Str2list(v_Time));
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(是否锁定, 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,', Nvl(r_Rolladvice.类型, '0')) > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr('7,8,11', r_Rolladvice.类型) > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--85872:余伟节,2015-07-03,表格式电子病历缓慢并处理对象序号和对象属性的复制
Create Or Replace Procedure Zl_病人路径生成_Insert
(
  序号_In           Number, --医嘱界面产生路径项目时，序号为0
  病人id_In         病人临床路径.病人id%Type,
  主页id_In         病人临床路径.主页id%Type,
  婴儿_In           电子病历记录.婴儿%Type,
  科室id_In         病人临床路径.科室id%Type,
  路径记录id_In     病人路径执行.路径记录id%Type,
  阶段id_In         病人路径执行.阶段id%Type,
  日期_In           病人路径执行.日期%Type,
  天数_In           病人路径执行.天数%Type,
  分类_In           病人路径执行.分类%Type,
  项目id_In         病人路径执行.项目id%Type,
  医嘱ids_In        Varchar2,
  病历文件ids_In    Varchar2,
  病人病历ids_In    Varchar2,
  登记人_In         病人路径执行.登记人%Type,
  登记时间_In       病人路径执行.登记时间%Type,
  项目内容_In       病人路径执行.项目内容%Type := Null,
  执行者_In         病人路径执行.执行者%Type := Null,
  项目结果_In       病人路径执行.项目结果%Type := Null,
  图标id_In         病人路径执行.图标id%Type := Null,
  添加原因_In       病人路径执行.添加原因%Type := Null,
  变异原因_In       病人路径执行.变异原因%Type := Null,
  自动执行_In       Number := 0,
  电子病历id_In     电子病历记录.Id%Type := Null,
  合并路径阶段s_In  Varchar2 := Null, --用于修改合并路径的当前阶段ID，格式：合并路径记录ID:阶段ID,合并路径记录ID:阶段ID。。。。
  合并路径记录id_In 病人路径执行.合并路径记录id%Type := Null,
  合并路径阶段id_In 病人路径执行.合并路径阶段id%Type := Null,
  插入位置id_In     病人路径执行.Id%Type := 0,
  生成者_In         病人路径执行.生成者 %Type := 1,
  任务ids_In        Varchar2 := Null,
  生成时间性质_In   病人路径执行.生成时间性质%Type := Null --1-补录,2-暂存
) Is
  v_当前阶段id 病人临床路径.当前阶段id%Type;
  v_路径执行id 病人路径执行.Id%Type;
  v_病历id     电子病历记录.Id%Type;
  t_Advice     t_Numlist;
  t_File       t_Numlist;
  t_Doc        t_Numlist;

  v_Id             电子病历内容.Id%Type;
  v_父id           电子病历内容.父id%Type;
  v_当前父id       电子病历内容.父id%Type;
  v_原对象序号     电子病历内容.父id%Type;
  v_内容文本       电子病历内容.内容文本%Type;
  v_执行环节       Varchar2(20);
  n_当前天数       病人临床路径.当前天数%Type;
  n_合并路径记录id 病人路径执行.合并路径记录id%Type;
  n_合并路径阶段id 病人路径执行.合并路径阶段id%Type;
  n_天数           病人临床路径.当前天数%Type;
  v_合并路径阶段s  Varchar2(255);

  v_项目序号 病人路径执行.项目序号%Type;
  n_Count    Number;
  n_Minnum   Number;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  --项目序号处理
  Procedure p_Sort_项目序号
  (
    项目序号_In In 病人路径执行.项目序号%Type,
    执行id_In   In 病人路径执行.Id%Type
  ) Is
    n_Num Number;
  Begin
    n_Num := 项目序号_In;
    For r_Outpathitem In (Select a.Id, Nvl(a.项目序号, b.项目序号) As 项目序号
                          From 病人路径执行 A, 临床路径项目 B
                          Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And
                                a.项目id = b.Id(+) And Nvl(a.项目序号, b.项目序号) >= 项目序号_In
                          Order By Nvl(a.项目序号, b.项目序号)) Loop
      n_Num := n_Num + 1;
      --1-从插入位置处之后的所有路径外项目序号加 1
      Update 病人路径执行 A Set a.项目序号 = n_Num Where a.Id = r_Outpathitem.Id;
    End Loop;
    Update 病人路径执行 A Set a.项目序号 = 项目序号_In Where a.Id = 执行id_In;
  Exception
    When Others Then
      Null;
  End p_Sort_项目序号;
Begin
  If 序号_In = 1 And (项目内容_In Is Null Or 项目内容_In = '未生成任何项目' Or 项目内容_In = '路径外项目') Then
    --合并路径
    If 合并路径阶段s_In Is Not Null Then
      Select Nvl(当前天数, 1) Into n_当前天数 From 病人临床路径 Where ID = 路径记录id_In;
      --求出增量(首要路径提前合并路径就提前，首要路径延后，合并路径就延后)
      n_天数          := 天数_In - n_当前天数;
      v_合并路径阶段s := 合并路径阶段s_In || ',';
      While v_合并路径阶段s Is Not Null Loop
        n_合并路径记录id := To_Number(Substr(v_合并路径阶段s, 1, Instr(v_合并路径阶段s, ':') - 1));
        n_合并路径阶段id := To_Number(Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ':') + 1,
                                       Instr(v_合并路径阶段s, ',') - Instr(v_合并路径阶段s, ':') - 1));
        Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人合并路径 Where ID = n_合并路径记录id;
        If v_当前阶段id <> n_合并路径阶段id Then
          Update 病人合并路径 Set 前一阶段id = 当前阶段id, 当前阶段id = n_合并路径阶段id Where ID = n_合并路径记录id;
        End If;
        Update 病人合并路径 Set 当前天数 = Nvl(当前天数, 1) + n_天数 Where ID = n_合并路径记录id;
      
        v_合并路径阶段s := Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ',') + 1);
      End Loop;
    End If;
    --首要路径
    If 生成者_In = 1 Then
      Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人临床路径 Where ID = 路径记录id_In;
      If v_当前阶段id <> 阶段id_In Then
        Update 病人临床路径 Set 前一阶段id = 当前阶段id, 当前阶段id = 阶段id_In Where ID = 路径记录id_In;
      End If;
      Update 病人临床路径 Set 当前天数 = 天数_In Where ID = 路径记录id_In;
    End If;
  End If;

  --添加的路径外项目:即使有可选的项目可能还未生成,序号占用见后面补充项目调序处理
  If 项目内容_In Is Not Null Then
    Select Max(Nvl(a.项目序号, b.项目序号)) + 1
    Into v_项目序号
    From 病人路径执行 A, 临床路径项目 B
    Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id(+);
  End If;

  v_路径执行id := 0;
  If 序号_In = 0 And 项目内容_In Is Null Then
    --加max是为了容错以前的数据，实际上同一项目在当天只有一条执行记录
    Select Nvl(Max(ID), 0)
    Into v_路径执行id
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 项目id = 项目id_In;
  End If;

  --医嘱界面添加的非路径外项目
  If v_路径执行id = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 日期 = 日期_In;
    If n_Count = 0 Then
      --首次生成路径项目，转存前一天的暂存项目
      Update 病人路径执行
      Set 阶段id = 阶段id_In, 日期 = 日期_In, 天数 = 天数_In, 项目序号 = Null
      Where ID In (Select ID From 病人路径执行 Where 路径记录id = 路径记录id_In And 生成时间性质 = 2);
      --修改暂存标识
      Update 病人路径执行
      Set 生成时间性质 = Null
      Where ID In (Select a.Id
                   From 病人路径执行 A, 病人路径医嘱 B, 病人医嘱记录 C
                   Where a.Id = b.路径执行id And b.病人医嘱id = c.Id And a.路径记录id = 路径记录id_In And a.生成时间性质 = 2 And
                         a.日期 = Trunc(c.开始执行时间));
    End If;
    Select 病人路径执行_Id.Nextval Into v_路径执行id From Dual;
    Insert Into 病人路径执行
      (ID, 路径记录id, 阶段id, 日期, 天数, 分类, 项目id, 登记人, 登记时间, 项目序号, 项目内容, 执行者, 生成者, 项目结果, 图标id, 添加原因, 变异原因, 合并路径记录id, 合并路径阶段id,
       生成时间性质)
    Values
      (v_路径执行id, 路径记录id_In, 阶段id_In, 日期_In, 天数_In, 分类_In, 项目id_In, 登记人_In, 登记时间_In, v_项目序号, 项目内容_In, 执行者_In, 生成者_In,
       项目结果_In, 图标id_In, 添加原因_In, 变异原因_In, 合并路径记录id_In, 合并路径阶段id_In, 生成时间性质_In);
  
    --路径外项目序号插入 排序
    If 插入位置id_In <> 0 Then
      --获取要插入的序号
      Select Nvl(a.项目序号, b.项目序号)
      Into v_项目序号
      From 病人路径执行 A, 临床路径项目 B
      Where a.Id = 插入位置id_In And a.项目id = b.Id(+);
      --序号调整
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
    --路径项目补充生成时,序号重整:假如临床路径项目存在A1,A2,A3这3个项目,首次生成A1,A2后,再生成路径外项目B1,B2,同时将B1,B2插入到A1的位置
    --         那么此时病人路径执行中的序号变为:B1(1),B2(2),A1(3),A2(4),如果再补充生成A3时,路径显示顺序变为：B1(1),B2(2),A1(3),A3(3),A2(4)
    --         这样就会出现路径项目中补充生成的A3不能按照临床路径项目的顺序A1,A2,A3 正确排序。
  
    --当前阶段，当前天数，当前分类下，存在路径内项目且路径内的项目序号被重新调整过。（未添加路径外项目时，路径内项目的序号为空）
    Select Nvl(Count(ID), 0)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 分类 = 分类_In And 项目id Is Not Null And 项目序号 Is Not Null;
    --补充生成的路径项目序号重整
    If n_Count > 0 And 项目id_In Is Not Null Then
      --查找补充生成的路径项目,应该插入的位置
      Select Min(b.项目序号)
      Into n_Minnum
      From 病人路径执行 A, 临床路径项目 B
      Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id;
    
      Select 项目序号 Into v_项目序号 From 临床路径项目 Where ID = 项目id_In;
      --确定该路径项目序号插入的位置：
      If v_项目序号 = n_Minnum Then
        --v_项目序号 = n_Minnum：病人路径执行记录已在此排序前插入到数据库，插入的这天数据就是最小的这条数据
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 > n_Minnum
               Order By b.项目序号)
        Where Rownum = 1;
      Else
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 < v_项目序号
               Order By b.项目序号 Desc)
        Where Rownum = 1;
        v_项目序号 := v_项目序号 + 1;
      End If;
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
  
    --如果是自动执行模式（连续提前多个阶段时调用）;补录路径外项目
    If 自动执行_In = 1 Then
      Select zl_GetSysParameter('是否启用路径执行环节', 1256) Into v_执行环节 From Dual;
      If v_执行环节 = '1' Then
        Select zl_GetSysParameter('路径执行环节启用场合', 1256) Into v_执行环节 From Dual;
      
        Select Nvl(Nvl(a.执行者, b.执行者), 0)
        Into n_Count
        From 病人路径执行 A, 临床路径项目 B
        Where a.项目id = b.Id(+) And a.Id = v_路径执行id;
        --当前执行者符合启用场合自动执行,当执行者取不到值时,统一处理。
        If n_Count = 0 Or Substr(v_执行环节, n_Count, 1) = '1' Then
          Update 病人路径执行
          Set 执行人 = 登记人_In, 执行时间 = 登记时间_In, 执行结果 = '已经执行', 执行说明 = '自动执行。'
          Where ID = v_路径执行id;
        End If;
      End If;
    End If;
  End If;
  --删除特殊项目：未生成任何项目（如果当前阶段，当前日期存在其他项目，需删除“未生成任何项目”）
  Select Count(ID)
  Into n_Count
  From 病人路径执行 T
  Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And t.项目内容 = '未生成任何项目';

  If n_Count > 0 Then
    Select Count(ID)
    Into n_Count
    From 病人路径执行 T
    Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And t.项目内容 <> '未生成任何项目';
    If n_Count > 0 Then
      Delete From 病人路径执行 T
      Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And t.项目内容 = '未生成任何项目';
    End If;
  End If;

  If 医嘱ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Advice From Table(f_Num2list(医嘱ids_In));
    Forall I In 1 .. t_Advice.Count
      Insert Into 病人路径医嘱 (路径执行id, 病人医嘱id) Values (v_路径执行id, t_Advice(I));
  End If;

  If 病人病历ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Doc From Table(f_Num2list(病人病历ids_In));
    Select Column_Value Bulk Collect Into t_File From Table(f_Num2list(病历文件ids_In));
    For I In 1 .. t_Doc.Count Loop
      v_病历id := t_Doc(I);
    
      Insert Into 电子病历记录
        (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间, 最后版本, 签名级别, 编辑方式, 路径执行id)
        Select v_病历id, 2, 病人id_In, 主页id_In, 婴儿_In, 科室id_In, 种类, ID, 名称, 登记人_In, 登记时间_In, 登记人_In, 登记时间_In, 1, 0, Decode(保留,2,1,0),
               v_路径执行id
        From 病历文件列表
        Where ID = t_File(I);

      For Rs In (Select ID, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机,
                        诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
                 From 病历文件结构
                 Where 文件id = t_File(I)
                 Order By 对象序号) Loop

        Select 电子病历内容_Id.Nextval Into v_Id From Dual;
      
        If Rs.父id = 0 Then
          v_当前父id := v_Id;
          v_父id     := Null;
        Else
          --对象序号为空的时候，父ID就不是按照顺序的了，需要重新查找
          If Rs.对象序号 Is Null Then
            Select 对象序号 Into v_原对象序号 From 病历文件结构 Where ID = Rs.父id;
            If v_原对象序号 Is Null Then
              v_父id := Null;
            Else
              Select ID Into v_父id From 电子病历内容 Where 文件id = v_病历id And 对象序号 = v_原对象序号;
            End If;
          Else
            v_父id := v_当前父id;
          End If;
        End If;
      
        If Rs.对象类型 = 4 And Rs.替换域 = 1 Then
          v_内容文本 := Zl_Replace_Element_Value(Rs.要素名称, 病人id_In, 主页id_In, 2, Null, 婴儿_In);
        Else
          v_内容文本 := Rs.内容文本;
        End If;
      
        Insert Into 电子病历内容
          (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 定义提纲id, 复用提纲, 使用时机, 诊治要素id,
           替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
        Values
          (v_Id, v_病历id, 1, 0, v_父id, Rs.对象序号, Rs.对象类型, Rs.对象标记, Rs.保留对象, Rs.对象属性, Rs.内容行次, v_内容文本, Rs.是否换行, Rs.预制提纲id,
           Decode(Rs.父id, 0, Rs.Id, Null), Rs.复用提纲, Rs.使用时机, Rs.诊治要素id, Rs.替换域, Rs.要素名称, Rs.要素类型, Rs.要素长度, Rs.要素小数,
           Rs.要素单位, Rs.要素表示, Rs.输入形态, Rs.要素值域);
      
        If Rs.对象类型 = 5 Then
          Insert Into 电子病历图形 (对象id, 图形) Values (v_Id, (Select 图形 From 病历文件图形 Where 对象id = Rs.Id));
        End If;
      
      End Loop;
    
      Insert Into 电子病历格式
        (文件id, 内容)
      Values
        (v_病历id, (Select 内容 From 病历文件格式 Where 文件id = t_File(I)));
    End Loop;
  End If;

  If Nvl(电子病历id_In, 0) <> 0 Then
    Update 电子病历记录 Set 路径执行id = v_路径执行id Where ID = 电子病历id_In;
  End If;
  If 任务ids_In Is Not Null Then
    For Rs In (Select /*+ Rule*/
                Column_Value As 任务id
               From Table(Cast(f_Str2list(任务ids_In, ',') As Zltools.t_Strlist))) Loop
      Insert Into 病人路径病历 (路径执行id, 任务id) Values (v_路径执行id, Rs.任务id);
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径生成_Insert;
/

--85896:马政,2015-07-15,财务审核价格改变调整
--85892:马政,2015-06-24,财务审核问题
--86467:马政,2015-07-17,药品盘点
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  Delete_In   In Number := 0,
  冲销方式_In In Number := 0,
  发药标志_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:根据明细数据更新库存
  --关键：根据下可用库存参数决定是否处理可用数量
  --业务规则：按照模块分开处理数据，便于后期维护
  --过程适用范围：药品流通业务，涉及到产生药品收发记录明细后再更新库存表并重算库存表平均成本价的业务，该过程
  --只能由其他过程内部调用，不能作为单独过程直接执行
  --参数:
  --     Id_In:药品业务新增、删除、审核、冲销时产生收发记录明细的id
  --     Delete_in: 0--非删除操作业务（新增、审核、冲销） 1--删除操作业务
  --     冲销方式_In: 0--正常冲销方式 1-产生冲销申请单据 2-发送 3-回退 目前只有移库模块有效
  --     发药标志_in: 0--不标记  1--标记  此参数只有药品处方、部门发药模块有效
  ----------------------------------------------------------------------------------------
  v_下可用数量 Zlparameters.参数值%Type;
  n_可用数量   药品库存.实际数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_差价       药品库存.实际差价%Type;
  n_时价分批   Number(1);
  n_成本价     药品收发记录.成本价%Type;
  n_零售价     药品库存.零售价%Type;

  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  v_Detail c_Detail%RowType;
Begin
  --取下可用库存参数
  Select Zl_Getsysparameter(96) Into v_下可用数量 From Dual;

  For v_Detail In c_Detail Loop
    n_实际数量 := v_Detail.入出系数 * v_Detail.实际数量 * Nvl(v_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_零售金额 := v_Detail.入出系数 * v_Detail.零售金额;
    n_差价     := v_Detail.入出系数 * v_Detail.差价;
  
    --外购入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，退库模式时在填单时要根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --冲销时直接按数量加减库存可用数量
    --用数量判断是入库还是退库
    If v_Detail.单据 = 1 Then
      If v_Detail.审核日期 Is Null Then
        --未审核单据，填单或删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --已审核或已冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            --退库要考虑填单时已经处理了可用数量
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --自制入库：对于自制药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于原料药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 2 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --协定入库：对于协定药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于组成药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 3 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --其他入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，负数入库模式时要根据参数处理可用数量，在审核时则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --用数量判断是入库还是退库
    If v_Detail.单据 = 4 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --差价调整，成本价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 5 Then
      n_可用数量 := 0;
    End If;
  
    --移库：移库有两条单据，一条出库单据，一条入库单据；出库单据需要根据下可用库存参数决定是否下可用库存，如果是冲销则可用库存则相反处理
    --在填单不减可用数量时，在发送时预减可用数量，审核时不处理可用数量
    --申请冲销模式时也要根据参数来处理可用数量
    --填单时出库业务根据参数决定是否下库存，入库业务不下库存；删除时出库业务更加参数要把库存还回去，入库业务不还库存
    If v_Detail.单据 = 6 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          --新增、修改、发送、回退、冲销申请
          If v_Detail.记录状态 = 1 Then
            If 冲销方式_In = 2 Then
              --发送
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Elsif 冲销方式_In = 3 Then
              --回退
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := -1 * n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Else
              --新增
              If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            End If;
          Else
            --申请冲销
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        Else
          --删除
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Elsif v_Detail.配药日期 Is Not Null And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = -1 Then
            --出的那笔
            n_可用数量 := 0;
          Else
            --入的那笔
            n_可用数量 := n_实际数量;
          End If;
        Else
          If 冲销方式_In = 0 Then
            --正常冲销审核
            n_可用数量 := n_实际数量;
          Else
            --申请冲销审核
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --领用：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 7 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --发药业务：在填单时固定处理可用数量，在审核时不处理
    --删除单据时要把填单时预减的加回去
    --不再发药标记的可用数量处理等同于删除，填单操作
    If v_Detail.单据 = 8 Or v_Detail.单据 = 9 Or v_Detail.单据 = 10 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          If 发药标志_In = 0 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := -1 * n_实际数量;
          End If;
        Else
          n_可用数量 := -1 * n_实际数量;
        End If;
      Else
        n_可用数量 := 0;
      End If;
    End If;
  
    --其他出库：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 11 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --冲销和审核
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --盘点：填单时盘盈业务不处理可用数量，盘亏业务固定处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    --用入出系数区分盘盈盘亏业务
    If v_Detail.单据 = 12 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --售价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 13 Then
      n_可用数量 := 0;
    End If;
  
    --药品留存：产生发药单据时，已经下了库存，部门发药时，需要将库存加回去
    If v_Detail.单据 = 27 Then
      n_可用数量 := n_实际数量;
    End If;
  
    If v_Detail.批次 > 0 And v_Detail.是否变价 = 1 Then
      n_时价分批 := 1;
    Else
      n_时价分批 := 0;
    End If;
  
    n_零售价 := v_Detail.零售价;
    --特殊单据需要处理成本价 特殊单据有单据=5 单据=12
    If v_Detail.单据 = 5 Or v_Detail.单据 = 12 Then
      If v_Detail.单据 = 5 Then
        If v_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(v_Detail.零售价, 0) / v_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If v_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := v_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(v_Detail.零售价, 0) - Nvl(v_Detail.成本价, 0)) / v_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = v_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := v_Detail.单量;
      End If;
    Else
      If v_Detail.单据 = 13 Then
        n_成本价 := Nvl(v_Detail.单量, 0) - Nvl(v_Detail.频次, 0);
      Else
        n_成本价 := v_Detail.成本价;
      End If;
    End If;
  
    --根据业务数据更新库存记录
    If v_Detail.审核日期 Is Null Then
      If n_可用数量 <> 0 Then
        --填单，删除时只更新可用数量
        Update 药品库存
        Set 可用数量 = 可用数量 + n_可用数量
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, 0, 0, 0, v_Detail.供药单位id, n_成本价,
             v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号, Decode(n_时价分批, 1, n_零售价, Null),
             v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        End If;
      End If;
    Else
      --审核时更新库存可用数量，实际数量，库存金额，库存差价等数据
      If v_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If v_Detail.摘要 = '外购退库差价误差自动修正' Or v_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        
          If v_Detail.摘要 = '财务审核价格变动修正' Then
            Update 药品库存
            Set 平均成本价 = Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量)
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
            If Sql%NotFound Then
              Update 药品库存
              Set 平均成本价 = n_成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, n_差价, v_Detail.批号, v_Detail.效期, v_Detail.产地,
               v_Detail.供药单位id, v_Detail.生产日期, v_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          End If;
        End If;
      Elsif v_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        Update 药品库存
        Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价分批, 1, n_零售价, Null));
        Else
          If n_时价分批 = 1 Then
            Update 药品库存
            Set 零售价 = 实际金额 / 实际数量
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
          End If;
        End If;
      Else
        --按入库和出库 状态分解
        --入库业务,出库冲销，不分批多种价格入库冲销需要更新库存表所有信息
        If (v_Detail.入出系数 = 1 And v_Detail.记录状态 = 1) Or (v_Detail.入出系数 = -1 And Mod(v_Detail.记录状态, 3) = 2) Or
           (v_Detail.入出系数 = 1 And Mod(v_Detail.记录状态, 3) = 2) Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = v_Detail.供药单位id,
              上次采购价 = Decode(v_Detail.单据, 1, Decode(v_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(v_Detail.批号, 上次批号), 上次生产日期 = Nvl(v_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(v_Detail.产地, 上次产地),
              灭菌效期 = Nvl(v_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(v_Detail.效期, 效期), 批准文号 = Nvl(v_Detail.批准文号, 批准文号),
              上次扣率 = Decode(v_Detail.单据, 1, v_Detail.扣率, 上次扣率), 商品条码 = Nvl(v_Detail.商品条码, 商品条码),
              内部条码 = Nvl(v_Detail.内部条码, 内部条码)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          --外购入库和其他入库审核时
          If ((v_Detail.单据 = 1 Or v_Detail.单据 = 4) And v_Detail.记录状态 = 1) Then
            Update 药品库存
            Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null)
            Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          End If;
          --不分批入库需要重算成本价，不分批出库冲销单据需要重算成本价如移库冲销,调价冲销也需要重算成本价，财务审核（修改价格情况）            
          --外购退货不更新平均成本价，写下面这句是为了方便写if条件
          If v_Detail.单据 = 1 And v_Detail.发药方式 = 1 Then
            Update 药品库存
            Set 平均成本价 = 平均成本价
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          Else
            Update 药品库存
            Set 平均成本价 = Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量)
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
          
            If Sql%NotFound Then
              Update 药品库存
              Set 平均成本价 = n_成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          --出库业务只需要更新数量、金额、差价
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        End If;
        --库存表未找到数据则需要产生库存表所有信息
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, v_Detail.供药单位id,
             n_成本价, v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号,
             Decode(n_时价分批, 1, n_零售价, Null), v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        End If;
        If n_时价分批 = 1 And v_Detail.单据 = 12 Then
          Update 药品库存
          Set 零售价 = 实际金额 / 实际数量
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                Nvl(实际数量, 0) <> 0;
          If Sql%NotFound Then
            Update 药品库存
            Set 零售价 = n_零售价
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          End If;
        End If;
      End If;
    End If;
  
    --删除多余的库存数据
    Delete From 药品库存
    Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And Nvl(可用数量, 0) = 0 And
          Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/


--85896:马政,2015-07-13,药品财务审核金额调整
Create Or Replace Procedure Zl_药品外购_Verify
(
  Newno_In    In 药品收发记录.No%Type := Null,
  Oldno_In    In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Isverified Exception;
  Err_Isbatch Exception;
  v_Druginf        Varchar2(50); --原不分批现在分批的药品信息
  v_供药单位id     药品收发记录.供药单位id%Type;
  v_发票金额       应付记录.发票金额%Type;
  v_可用数量       药品库存.可用数量%Type;
  v_时价分批       Number(1);
  n_原成本价       药品收发记录.成本价%Type;
  v_Newno          药品收发记录.No%Type;
  n_New序号        Number;
  n_收发id         药品收发记录.Id%Type;
  n_调整额         药品收发记录.零售金额%Type;
  n_入出类别id     药品收发记录.入出类别id%Type;
  n_售价入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数       药品收发记录.入出系数%Type;
  n_平均成本价     药品库存.平均成本价%Type;
  n_冲销成本价     药品收发记录.成本价%Type;
  n_冲销售价       药品收发记录.零售价%Type;

  Cursor c_药品收发记录 Is
    Select a.Id, a.零售价, a.实际数量, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期, a.产地, a.入出类别id, a.生产日期,
           a.批准文号, Nvl(b.是否变价, 0) As 时价, Nvl(a.发药方式, 0) As 退库, a.灭菌效期, a.扣率, Nvl(a.计划id, 0) As 计划id,
           Nvl(a.费用id, 0) As 费用id, a.序号
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1
    Order By a.药品id;
Begin

  n_New序号 := 1;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;

  Select 类别id Into n_售价入出类别id From 药品单据性质 Where 单据 = 13 And Rownum < 2;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = Newno_In And 单据 = 1 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = Newno_In And a.单据 = 1 And
          a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  --原分批现不分批的药品,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 药品规格 B
         Where b.药品id = a.药品id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.药库分批, 0) = 0 Or
               (Nvl(b.药房分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室')))));

  For v_药品收发记录 In c_药品收发记录 Loop
    --处理采购计划表中的执行数量，多次导入采用累加执行数量
    If v_药品收发记录.计划id > 0 Then
      Update 药品计划内容
      Set 执行数量 = Nvl(执行数量, 0) + v_药品收发记录.实际数量
      Where 计划id = v_药品收发记录.计划id And 药品id = v_药品收发记录.药品id;
    End If;
    --调用库存更新记录更新库存表
    Zl_药品库存_Update(v_药品收发记录.Id, 0);
  
    --如果是分批药品退库，取原来的成本价
    If v_药品收发记录.退库 = 1 Then
      Begin
        Select 平均成本价
        Into n_原成本价
        From 药品库存
        Where 性质 = 1 And 库房id = v_药品收发记录.库房id And 药品id = v_药品收发记录.药品id And Nvl(批次, 0) = Nvl(v_药品收发记录.批次, 0);
      Exception
        When Others Then
          n_原成本价 := 0;
      End;
    End If;
  
    If v_药品收发记录.时价 = 1 Then
      Update 药品规格 Set 上次售价 = v_药品收发记录.零售价 Where 药品id = v_药品收发记录.药品id;
    End If;
  
    If v_药品收发记录.退库 = 0 Then
      --更新该药品的成本价
      Update 药品规格
      Set 成本价 = v_药品收发记录.成本价, 上次供应商id = v_药品收发记录.供药单位id, 上次批号 = v_药品收发记录.批号, 上次生产日期 = v_药品收发记录.生产日期, 上次产地 = v_药品收发记录.产地,
          上次批准文号 = v_药品收发记录.批准文号
      Where 药品id = v_药品收发记录.药品id;
    End If;
  
    --如果是分批药品退库，则检查成本价是否变动，如果变动，则产生差价调整记录并修正库存差价
    If Oldno_In Is Null Then
      If v_药品收发记录.退库 = 1 Then
        If n_原成本价 <> 0 And n_原成本价 <> v_药品收发记录.成本价 Then
          If v_Newno Is Null Then
            v_Newno := Nextno(25, v_药品收发记录.库房id);
          End If;
        
          --产生库存差价调整单
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          n_调整额 := (v_药品收发记录.零售金额 - v_药品收发记录.差价) - Round(n_原成本价 * v_药品收发记录.实际数量, 2);
        
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
             审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Values
            (n_收发id, 1, 5, v_Newno, n_New序号, v_药品收发记录.库房id, n_入出类别id, v_药品收发记录.供药单位id, n_入出系数, v_药品收发记录.药品id,
             v_药品收发记录.批次, v_药品收发记录.产地, v_药品收发记录.批号, v_药品收发记录.效期, v_药品收发记录.实际数量, v_药品收发记录.零售金额, v_药品收发记录.差价, n_调整额,
             '外购退库差价误差自动修正', Nvl(审核人_In, Zl_Username), 审核日期_In, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.生产日期,
             v_药品收发记录.批准文号, v_药品收发记录.成本价, 0, n_原成本价, v_药品收发记录.灭菌效期, v_药品收发记录.Id);
        
          n_New序号 := n_New序号 + 1;
          --更新库存
          Zl_药品库存_Update(n_收发id);
        End If;
      End If;
    Else
      Select 成本价, 零售价
      Into n_冲销成本价, n_冲销售价
      From 药品收发记录
      Where NO = Oldno_In And 药品id = v_药品收发记录.药品id And Nvl(批次, 0) = Nvl(v_药品收发记录.批次, 0) And 序号 = v_药品收发记录.序号 And 单据 = 1 And
            Mod(记录状态, 3) = 2;
      If n_冲销成本价 <> v_药品收发记录.成本价 Then
        --产生库存差价调整单
        v_Newno := Nextno(25, v_药品收发记录.库房id);
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      
        n_调整额 := Round((v_药品收发记录.成本价 - n_冲销成本价) * v_药品收发记录.实际数量, 2);
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
        Values
          (n_收发id, 1, 5, v_Newno, n_New序号, v_药品收发记录.库房id, n_入出类别id, v_药品收发记录.供药单位id, n_入出系数, v_药品收发记录.药品id, v_药品收发记录.批次,
           v_药品收发记录.产地, v_药品收发记录.批号, v_药品收发记录.效期, v_药品收发记录.实际数量, v_药品收发记录.零售金额, v_药品收发记录.差价, n_调整额, '财务审核价格变动修正',
           Nvl(审核人_In, Zl_Username), 审核日期_In, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.生产日期, v_药品收发记录.批准文号,
           v_药品收发记录.成本价, 0, n_冲销成本价, v_药品收发记录.灭菌效期, v_药品收发记录.Id);
      
        n_New序号 := n_New序号 + 1;
      
        --更新库存
        Zl_药品库存_Update(n_收发id);
      End If;
    
      --更新售价
      If n_冲销售价 <> v_药品收发记录.零售价 Then
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      
        n_调整额 := Round((n_冲销售价 - v_药品收发记录.零售价) * v_药品收发记录.实际数量, 2);
      
        --产生调价修正记录
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
           填制日期, 库房id, 入出系数, 审核人, 审核日期, 费用id)
        Values
          (n_收发id, 1, 13, n_收发id, n_New序号, n_售价入出类别id, v_药品收发记录.药品id, v_药品收发记录.批次, v_药品收发记录.批号, v_药品收发记录.效期,
           v_药品收发记录.产地, 1, v_药品收发记录.实际数量, 0, n_冲销售价, 0, v_药品收发记录.零售价, 0, n_调整额, n_调整额, '财务审核价格变动修正',
           Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.库房id, 1, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.Id);
      
        n_New序号 := n_New序号 + 1;
        --更新药品库存
        Zl_药品库存_Update(n_收发id);
      End If;
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = Newno_In And 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into v_供药单位id, v_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = Newno_In And a.单据 = 1 And b.系统标识 = 1
    Group By b.单位id;
  
    If Nvl(v_供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, v_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Verify;
/

--85687:胡俊勇,2015-07-07,医嘱清单打印
--85214:胡俊勇,2015-07-06,医嘱单打印清上次打印
--85660:胡俊勇,2015-06-12,医嘱单打印
Create Or Replace Procedure Zl_病人医嘱打印_Delete
(
  病人id_In       病人医嘱记录.病人id%Type,
  主页id_In       病人医嘱记录.主页id%Type,
  婴儿_In         病人医嘱记录.婴儿%Type,
  期效_In         病人医嘱记录.医嘱期效%Type,
  起始页号_In     病人医嘱打印.页号%Type := Null,
  医嘱位置_In     Varchar2 := Null,
  清除方式_In     Number := 0,
  清除上次打印_In Number := Null
  --清除方式_In 1－清除未打印但已生成的预打印记录，0－清除已经打过的记录及之后的
  --清除上次打印_In 1 清除上次打印，2-删除打印数据，其它－按指定规则清除打印
) Is
  n_位置     Number(10);
  v_Max_Date Date;
  n_Tag      Number(1); --1-整页删除，2－按当前位置删除
  d_Last     Date;
Begin
  If 清除上次打印_In = 1 Or 清除上次打印_In = 2 Then
    Select Max(打印时间)
    Into d_Last
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In;
  
    If 清除上次打印_In = 1 Then
      Update 病人医嘱打印 Set 打印时间 = Null Where 打印时间 = d_Last;
    Else
      Delete 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And (打印时间 = d_Last Or 打印时间 Is Null);
    End If;
  Else
    n_Tag := 1;
    Select To_Number(Decode(医嘱位置_In, Null, '0', '', '0', 医嘱位置_In)) Into n_位置 From Dual;
    If n_位置 > 0 Then
      Select Count(1), Max(打印时间)
      Into n_位置, v_Max_Date
      From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) = To_Number(医嘱位置_In);
      If n_位置 = 1 And v_Max_Date Is Null Then
        n_Tag := 2;
      End If;
    End If;
  
    If n_Tag = 1 Then
    
      If 期效_In = 0 Then
        Select 医嘱重整时间 Into v_Max_Date From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
      Else
        v_Max_Date := Null;
      End If;
      If v_Max_Date Is Null Then
        Delete From 病人医嘱打印
        Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 页号 >= 起始页号_In;
      Else
        Delete From 病人医嘱打印
        Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 页号 >= 起始页号_In And
              (打印时间 > v_Max_Date Or 打印时间 Is Null);
      End If;
    Else
      Delete From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= To_Number(医嘱位置_In);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--85660:胡俊勇,2015-06-12,医嘱单打印
CREATE OR REPLACE Procedure Zl_病人医嘱打印_Insert
(
  病人id_In     病人医嘱记录.病人id%Type,
  主页id_In     病人医嘱记录.主页id%Type,
  婴儿_In       病人医嘱记录.婴儿%Type,
  期效_In       病人医嘱记录.医嘱期效%Type,
  序号_In       病人医嘱记录.序号%Type,
  页号_In       病人医嘱打印.页号%Type,
  行号_In       病人医嘱打印.行号%Type,
  打印模式_In   Number,
  打给药方式_In Number,
  位置_In       Number,
  重整标记_In   Number,
  转科_In       Number,
  行数_In       Number,
  重整日期_In   病案主页.医嘱重整时间%Type := Null
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印 中，页号，行号同时产生，默认一条医嘱只占用一行。
  --参数：行数_In：报表医嘱单一页可以打多少行,打印模式_In：0-校对后打印，1-新开时打印。
  --      序号_In： 病人医嘱打印 表中的最后一条医嘱 页号_In，行号_In 是最后一条记录对应的页号和行号
  --      打给药方式_In：西药中成药的给药方法是否单独打一行，1－单独打一行，0－不打给药方式，
  --      位置_In：转科、出院、死亡医嘱打印位置，0-长期医嘱单上，1-临时医嘱单上，2-两者都打印。
  --      重整标记_In：是否打重整医嘱字样，1－要打，0－不打。转科_n：前一条打印记录是不是转科医嘱，用于判断是否换页打重开字样
  --      行数_In医嘱单报表的行数通常是28行。
) Is
  v_Max_Date Date;
  n_换页打   Number;
  n_打重开   Number;
  n_转科     Number;
  n_页号     Number;
  n_行号     Number;
Begin
  n_页号 := 页号_In;
  n_行号 := 行号_In;
  n_转科 := 转科_In;

  If 期效_In = 0 Then
    n_换页打 := Zl_To_Number(zl_GetSysParameter('重整和术后医嘱换页打印', 1254));
    n_打重开 := Zl_To_Number(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254));
  End If;

  If 重整日期_In Is Null Or 期效_In = 1 Then
    v_Max_Date := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    v_Max_Date := 重整日期_In;
  End If;

  --插入重整医嘱，只插入一条
  If 重整标记_In = 1 Then
    --生成行号和页号
    If n_行号 = 行数_In Then
      n_行号 := 1;
      n_页号 := n_页号 + 1;
    Else
      n_行号 := n_行号 + 1;
    End If;
    If n_换页打 = 1 Then
      --如果行号为1说明已经是新的一页的第一行,否则换页
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    Insert Into 病人医嘱打印
      (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
    Values
      (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
  End If;

  --转科医嘱换页打医嘱重开字样
  If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
    If 重整标记_In = 1 Then
      --前面打了重整就不换页了
      If n_打重开 = 1 Then
        n_页号 := n_页号 + 1;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      End If;
    Else
      If n_打重开 = 1 Then
        --打重开字样
        If n_行号 = 行数_In Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        Else
          n_行号 := n_行号 + 1;
        End If;
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      Else
        --只是单纯换一页
        n_行号 := 0;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    n_转科 := 0;
  End If;

  --最近次重整后,需要打印的医嘱，考虑换页打印情况转科术后
  ---r_Print.换页 对特殊医嘱标记，4－术后，3－转科
  If v_Max_Date = To_Date('1900-01-01', 'YYYY-MM-DD') Then
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or 位置_In In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (位置_In = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (打印模式_In = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > 序号_In And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or
                                 l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 打给药方式_In = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;

      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;

      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;

        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);

        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱，
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  Else
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or 位置_In In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (位置_In = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (打印模式_In = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > 序号_In And Exists
                                               (Select 1
                                                     From 病人医嘱状态 C
                                                     Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or
                                 l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 打给药方式_In = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;

      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;

      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);

        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--85490:胡俊勇,2015-06-09,输血皮试医嘱核对
Create Or Replace Procedure Zl_病人医嘱执行_Finish
(
  医嘱id_In       病人医嘱执行.医嘱id%Type,
  发送号_In       病人医嘱执行.发送号%Type,
  阳性_In         病人医嘱发送.结果阳性%Type := Null,
  单独执行_In     Number := 0,
  操作员编号_In   人员表.编号%Type := Null,
  操作员姓名_In   人员表.姓名%Type := Null,
  执行部门id_In   门诊费用记录.执行部门id%Type := 0,
  检验项目记帐_In Number := 0
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验或检查医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态
) Is
  Cursor c_Advice Is
    Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源, 标本部位, 开始执行时间, 病人id, 主页id, 执行科室id
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  r_Advice c_Advice%RowType;

  v_Date     Date;
  v_开始时间 Date;
  v_诊疗类别 诊疗项目目录.类别%Type;
  v_操作类型 诊疗项目目录.操作类型%Type;
  v_Temp     Varchar2(255);
  v_费用性质 病人医嘱发送.记录性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_Cnt      Number;

Begin

  --如果启用了参数：输血和皮试医嘱执行后需要核对，则输血和皮试医嘱不自动完成
  Select b.类别, b.操作类型
  Into v_诊疗类别, v_操作类型
  From 病人医嘱记录 A, 诊疗项目目录 B
  Where a.诊疗项目id = b.Id And a.Id = 医嘱id_In;

  v_Temp := zl_GetSysParameter(186);
  If v_Temp = '11' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 In ('1', '8') Or v_诊疗类别 = 'K');
  Elsif v_Temp = '01' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And v_诊疗类别 = 'E' And v_操作类型 = '1';
  Elsif v_Temp = '10' Then
    Select Count(1)
    Into n_Cnt
    From 病人医嘱执行
    Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 核对人 Is Null And (v_诊疗类别 = 'E' And v_操作类型 = '8' Or v_诊疗类别 = 'K');
  End If;

  If n_Cnt > 0 Then
    Return;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  Select Sysdate Into v_Date From Dual;

  --执行状态
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  If 检验项目记帐_In = 0 Then
    If (r_Advice.诊疗类别 = 'C' And r_Advice.相关id Is Not Null) Or r_Advice.诊疗类别 = 'D' Then
      If Nvl(单独执行_In, 0) = 1 Then
        --单个检验或检查项目
        Update 病人医嘱发送
        Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
        Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
      Else
        --一并的检验项目或多部位的检查项目
        If r_Advice.诊疗类别 = 'D' Then
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id));
        Else
          Update 病人医嘱发送
          Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
          Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where 相关id = r_Advice.相关id);
        End If;
      End If;
    Else
      --包含附加手术,检查部位,以及其它独立医嘱;麻醉和中药煎法是单独安排
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = v_人员姓名, 完成时间 = v_Date, 结果阳性 = Decode(阳性_In, Null, 结果阳性, 阳性_In)
      Where 发送号 + 0 = 发送号_In And
            医嘱id In (Select ID
                     From 病人医嘱记录
                     Where (ID = r_Advice.组id Or 相关id = r_Advice.组id) And 诊疗类别 = r_Advice.诊疗类别);
    End If;
  End If;
  If r_Advice.病人来源 = 2 Then
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
    Into v_费用性质
    From 病人医嘱发送
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In;
  Else
    v_费用性质 := 1;
  End If;
  --检验自动完成采集
  If v_诊疗类别 = 'E' And v_操作类型 = '6' Then
    Update 病人医嘱发送 A
    Set a.采样人 = Nvl(a.采样人, v_人员姓名), a.采样时间 = Nvl(a.采样时间, v_Date)
    Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Advice.组id Or 相关id = r_Advice.组id)) And 发送号 = 发送号_In;
  End If;

  If v_费用性质 = 1 Then
    Zl_门诊医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  Else
    Zl_住院医嘱执行_Finish(医嘱id_In, 发送号_In, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, 执行部门id_In);
  End If;

  If r_Advice.诊疗类别 = 'F' Then
    If Not r_Advice.标本部位 Is Null Then
      v_开始时间 := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
    Else
      v_开始时间 := r_Advice.开始执行时间;
    End If;
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.执行科室id, v_人员姓名, v_开始时间, v_Date);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱执行_Finish;
/

--85359:刘尔旋,2015-06-04,挂号记录执行人错误变更的问题
Create Or Replace Procedure Zl_挂号安排_Autoupdate Is
  Err_Item Exception;
  v_Date Date;
  -- v_Err_Msg Varchar2(100); 
  v_Unitscount Number;
Begin
  --n_更新执行人 ：是否更新病人挂号记录 和门诊费用记录中的执行人 
  --               如果计划中更改了 挂号项目 则不允许更新 病人挂号记录和门诊费用记录中的数据 
  Select Sysdate Into v_Date From Dual;
  Select Count(0) Into v_Unitscount From 合作单位安排控制 Where Rownum = 1;

  For v_生效 In (Select a.Id, a.安排id, a.号码, a.生效时间, a.失效时间, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                      b.执行时间 As 上次生效时间, a.项目id, a.医生姓名, a.医生id, b.序号, b.科室id
               From 挂号安排计划 A, 挂号安排 B,
                    (Select 生效时间, 号码
                      From (Select Max(a.生效时间) As 生效时间, a.安排id, a.号码
                             From 挂号安排计划 A, 挂号安排 B
                             Where Sysdate Between a.生效时间 And a.失效时间 And a.安排id = b.Id And
                                   a.实际生效 >= To_Date('3000-01-01', 'yyyy-mm-dd') And a.生效时间 <= Sysdate And 审核时间 Is Not Null
                             Group By a.安排id, a.号码)
                      
                      ) C
               Where a.安排id = b.Id And a.实际生效 >= To_Date('3000-01-01', 'yyyy-mm-dd') And Sysdate > a.生效时间 And
                     a.号码 = c.号码 And a.生效时间 = c.生效时间 And 审核时间 Is Not Null And a.Id <> Nvl(b.执行计划id, 0) And
                     b.停用日期 Is Null) Loop
    Update 挂号安排计划 Set 实际生效 = v_生效.上次生效时间 Where ID = v_生效.安排id And 失效时间 < v_生效.失效时间;
  
    Update 挂号安排
    Set 周日 = v_生效.周日, 周一 = v_生效.周一, 周二 = v_生效.周二, 周三 = v_生效.周三, 周四 = v_生效.周四, 周五 = v_生效.周五, 周六 = v_生效.周六,
        分诊方式 = v_生效.分诊方式, 序号控制 = v_生效.序号控制, 开始时间 = Sysdate, 终止时间 = v_生效.失效时间, 项目id = Nvl(v_生效.项目id, 项目id), 执行时间 = v_Date,
        执行计划id = v_生效.Id, 序号 = 9999999, 医生姓名 = v_生效.医生姓名, 医生id = v_生效.医生id
    Where ID = v_生效.安排id;
  
    --重新调整序号 
    Update 挂号安排 A
    Set 序号 = -1 * 序号
    Where 项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
          Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0);
    For v_序号 In (Select a.Id, Rownum As 序号
                 From 挂号安排 A
                 Where a.项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
                       Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0)
                 Order By a.Id) Loop
      Update 挂号安排 A Set 序号 = v_序号.序号 Where ID = v_序号.Id;
    End Loop;
    Delete 挂号安排诊室 Where 号表id = v_生效.安排id;
    Insert Into 挂号安排诊室
      (号表id, 门诊诊室)
      Select v_生效.安排id, 门诊诊室 From 挂号计划诊室 Where 计划id = v_生效.Id;
    Delete 挂号安排限制 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排限制
      (安排id, 限制项目, 限号数, 限约数)
      Select v_生效.安排id, 限制项目, 限号数, 限约数 From 挂号计划限制 Where 计划id = v_生效.Id;
    Delete 挂号安排时段 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排时段
      (安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
      Select v_生效.安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期
      From 挂号计划时段
      Where 计划id = v_生效.Id;
    If Nvl(v_Unitscount, 0) > 0 Then
      Delete 合作单位安排控制 Where 安排id = v_生效.安排id;
      Insert Into 合作单位安排控制
        (安排id, 合作单位, 限制项目, 序号, 数量)
        Select v_生效.安排id, 合作单位, 限制项目, 序号, 数量 From 合作单位计划控制 Where 计划id = v_生效.Id;
    End If;
  End Loop;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Autoupdate;
/

--85049:张险华,2015-06-02,出院病人未结束反馈不能提交
Create Or Replace Procedure Zl_病案提交记录_Insert
--功能：提交病人病案 
(
  病人id_In 病案提交记录.病人id%Type,
  主页id_In 病案提交记录.主页id%Type
) Is
  v_Temp     Varchar2(255);
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(4000);
  Err_Custom Exception;
Begin
  --当前操作人员 
  v_Temp     := Zl_Identity(1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  --检查提交的必要条件 
  v_Error := Null;
  For r_Row In (Select 1 As 类型, '●病人还没有出院' As 说明, Null As 排序
                From 病案主页
                Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null
                Union All
                Select 2 As 类型, '●病案首页还没有签名' As 说明, Null As 排序
                From Dual
                Where Not Exists (Select 1
                       From 病案主页从表
                       Where 病人id = 病人id_In And 主页id = 主页id_In And
                             信息名 In ('住院医师签名', '主治医师签名', '主任医师签名', '科主任签名') And 信息值 Is Not Null)
                Union All
                Select 3 As 类型, '●医嘱[' || a.医嘱内容 || ']' || Decode(a.医嘱期效, 1, '还没有执行', '还没有停止') As 说明,
                       Nvl(a.婴儿, 0) || '_' || LPad(a.序号, 5, '0') As 排序
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊疗项目id = b.Id(+) And
                      (a.相关id Is Null And Not (a.诊疗类别 = 'E' And Nvl(b.操作类型, '无') = '2') Or a.诊疗类别 In ('5', '6')) And
                      a.医嘱状态 In (3, 5, 6, 7) And Nvl(a.执行标记, 0) <> -1
                Union All
                Select 4 As 类型, '●病历[' || 病历名称 || ']还没有归档' As 说明, To_Char(创建时间, 'YYYY-MM-DD HH24:MI:SS') As 排序
                From 电子病历记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And 病历种类 Not In (1, 3, 7) And 归档日期 Is Null
                Union All
                Select 5 As 类型, '●护理记录还没有归档' As 说明, Null As 排序
                From 病人护理记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And 归档时间 Is Null And Rownum = 1
                Union All
                Select 6 As 类型, '●新版护理记录还没有归档' As 说明, Null As 排序
                From 病人护理文件
                Where 病人id = 病人id_In And 主页id = 主页id_In And 归档时间 Is Null And Rownum = 1
                Union All
                Select 7 As 类型,
                       Decode(Rownum, 1, '●以下审查反馈未处理或未完成处理：' || Chr(13), '') || Decode(处理人, Null, '未处理：', '未完成：') ||
                        Decode(反馈对象, 1, '住院医嘱', 2, '住院病历', 3, '护理病历', 4, '护理记录', 5, '病案首页', 6, '医嘱报告', 7, '疾病证明', 8,
                               '知情文件') || '(' || 反馈意见 || ')', To_Char(Rownum) As 排序
                From 病案反馈记录
                Where 病人id = 病人id_In And 主页id = 主页id_In And 记录状态 = 1 And 记录性质 = 1
                Order By 类型, 排序) Loop
    If Length(v_Error) > 2000 Then
      v_Error := v_Error || '......';
      Exit;
    End If;
    v_Error := v_Error || Chr(13) || Chr(10) || r_Row.说明;
  End Loop;
  If v_Error Is Not Null Then
    v_Error := '因为以下原因，该病人的病案不能提交：' || Chr(13) || Chr(10) || v_Error;
    Raise Err_Custom;
  End If;

  Insert Into 病案提交记录
    (ID, 病人id, 主页id, 记录状态, 提交人, 提交时间)
  Values
    (病案提交记录_Id.Nextval, 病人id_In, 主页id_In, 1, v_人员姓名, Sysdate);

  Update 病案主页 Set 病案状态 = 1 Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(病案状态, 0) Not In (1, 10);
  If Sql%RowCount = 0 Then
    v_Error := '提交失败，该病人的病案可能已经提交。';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病案提交记录_Insert;
/

--85287:刘尔旋,2015-06-02,挂号安排设置是否预约
Create Or Replace Procedure Zl_挂号安排_Insert
(
  Id_In           挂号安排.Id%Type,
  号码_In         挂号安排.号码%Type,
  号类_In         挂号安排.号类%Type,
  科室id_In       挂号安排.科室id%Type,
  项目id_In       挂号安排.项目id%Type,
  医生_In         挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病案必须_In     挂号安排.病案必须%Type,
  周日_In         挂号安排.周日%Type,
  周一_In         挂号安排.周一%Type,
  周二_In         挂号安排.周二%Type,
  周三_In         挂号安排.周三%Type,
  周四_In         挂号安排.周四%Type,
  周五_In         挂号安排.周五%Type,
  周六_In         挂号安排.周六%Type,
  限号控制_In     Varchar2,
  分诊方式_In     挂号安排.分诊方式%Type,
  诊室_In         Varchar2,
  开始时间_In     挂号安排.开始时间%Type,
  终止时间_In     挂号安排.终止时间%Type,
  新增_In         Number,
  序号控制_In     挂号安排.序号控制%Type,
  处理类型_In     Number := 0,
  默认时间间隔_In 挂号安排.默认时段间隔%Type := 0
) As
  -----------------------------------------------------------
  --参数：
  --  诊室_IN=以';'号分隔的多个诊室名称
  --  限号控制_IN:|周一,22(限号),13(限约)|周二,20(限号),11(限约)....
  --  处理类型_IN:修改安排时 对时段数据的处理 0--不处理 1--删除时段信息
  --  默认时间间隔_In:为安排设置时段时默认的时间段间隔
  -----------------------------------------------------------
  v_诊室  Varchar2(1000);
  n_Count Number(18);
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_序号       Number(18);
  v_操作员姓名 挂号安排计划.审核人%Type;
  n_限号数     挂号安排限制.限号数%Type;
  n_限约数     挂号安排限制.限约数%Type;
  v_限制项目   挂号安排限制.限制项目%Type;
  v_限制控制   Varchar2(4000);
  v_当前项目   Varchar2(4000);

Begin
  Begin
    If Nvl(医生id_In, 0) <> 0 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生id = 医生id_In And ID + 0 <> Id_In;
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生姓名 = 医生_In And Nvl(医生id, 0) = 0 And ID + 0 <> Id_In;
    End If;
  Exception
    When Others Then
      n_序号 := 1;
  End;

  If 新增_In = 1 Then
    --新增挂号安排
    Begin
      Select b.姓名 Into v_操作员姓名 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
    Exception
      When Others Then
        Null;
    End;
    Insert Into 挂号安排
      (ID, 号码, 号类, 科室id, 项目id, 医生姓名, 医生id, 序号, 病案必须, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 开始时间, 终止时间, 序号控制, 默认时段间隔)
    Values
      (Id_In, 号码_In, 号类_In, 科室id_In, 项目id_In, 医生_In, Decode(医生id_In, 0, Null, 医生id_In), n_序号, 病案必须_In, 周日_In, 周一_In,
       周二_In, 周三_In, 周四_In, 周五_In, 周六_In, 分诊方式_In, 开始时间_In, 终止时间_In, 序号控制_In, 默认时间间隔_In);
    For r_合作单位 In (Select 名称 From 挂号合作单位) Loop
      Insert Into 合作单位安排控制
        (合作单位, 安排id, 限制项目, 序号, 数量)
        Select r_合作单位.名称, Id_In, '周日', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周一', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周二', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周三', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周四', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周五', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周六', 0, 0 From Dual;
    End Loop;
  
  Else
    --修改指定ID的挂号安排
    --1.先检查是否存在计划,存在计划，不能更改
    Begin
      Select Count(*) Into n_Count From 挂号安排计划 Where 安排id = Id_In;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]该安排已经制定了相关的计划,,不能再修改![ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(处理类型_In, 0) = 1 Then
      Delete 挂号安排时段 Where 安排id = Id_In;
    Else
      --针对存在时段这种情况需要先处理排班修改后的时段 在后再修改安排
      Delete 挂号安排时段
      Where 安排id = Id_In And 星期 In (Select 星期
                                    From (Select Case 周一
                                                     When 周一_In Then
                                                      Null
                                                     Else
                                                      '周一'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周二
                                                     When 周二_In Then
                                                      Null
                                                     Else
                                                      '周二'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周三
                                                     When 周三_In Then
                                                      Null
                                                     Else
                                                      '周三'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周四
                                                     When 周四_In Then
                                                      Null
                                                     Else
                                                      '周四'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周五
                                                     When 周五_In Then
                                                      Null
                                                     Else
                                                      '周五'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周六
                                                     When 周六_In Then
                                                      Null
                                                     Else
                                                      '周六'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周日
                                                     When 周日_In Then
                                                      Null
                                                     Else
                                                      '周日'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In) A
                                    Where a.星期 Is Not Null);
    End If;
  
    Update 挂号安排
    Set 号码 = 号码_In, 号类 = 号类_In, 科室id = 科室id_In, 项目id = 项目id_In, 医生姓名 = 医生_In, 医生id = Decode(医生id_In, 0, Null, 医生id_In),
        序号 = n_序号, 病案必须 = 病案必须_In, 周日 = 周日_In, 周一 = 周一_In, 周二 = 周二_In, 周三 = 周三_In, 周四 = 周四_In, 周五 = 周五_In, 周六 = 周六_In,
        开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 分诊方式 = 分诊方式_In, 序号控制 = 序号控制_In,
        默认时段间隔 = Decode(Nvl(默认时间间隔_In, 0), 0, 默认时段间隔, 默认时间间隔_In)
    Where ID = Id_In;
  
    Delete 挂号安排限制 Where 安排id = Id_In;
  End If;

  v_限制控制 := 限号控制_In || '|';
  While v_限制控制 Is Not Null Loop
    v_当前项目 := Substr(v_限制控制, 1, Instr(v_限制控制, '|') - 1);
    v_限制项目 := Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1);
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_限号数   := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    n_限约数   := To_Number(Substr(v_当前项目, Instr(v_当前项目, ',') + 1));
    Insert Into 挂号安排限制
      (安排id, 限制项目, 限号数, 限约数)
    Values
      (Id_In, v_限制项目, Decode(n_限号数, 0, Null, n_限号数), n_限约数);
    v_限制控制 := Substr(v_限制控制, Instr(v_限制控制, '|') + 1);
  End Loop;

  If 新增_In = 0 Then
    --挂号安排诊室处理
    Delete From 挂号安排诊室 Where 号表id = Id_In;
  End If;

  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ';';
    While v_诊室 Is Not Null Loop
      Insert Into 挂号安排诊室 (号表id, 门诊诊室) Values (Id_In, Substr(v_诊室, 1, Instr(v_诊室, ';') - 1));
      v_诊室 := Substr(v_诊室, Instr(v_诊室, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Insert;
/

--85287:刘尔旋,2015-06-02,挂号安排设置是否预约
Create Or Replace Procedure Zl_挂号安排计划_Insert
(
  Id_In       In 挂号安排计划.Id%Type,
  安排id_In   In 挂号安排计划.安排id%Type,
  号码_In     In 挂号安排计划.号码%Type,
  生效时间_In In 挂号安排计划.生效时间%Type,
  失效时间_In In 挂号安排计划.失效时间%Type,
  周日_In     In 挂号安排计划.周日%Type,
  周一_In     In 挂号安排计划.周一%Type,
  周二_In     In 挂号安排计划.周二%Type,
  周三_In     In 挂号安排计划.周三%Type,
  周四_In     In 挂号安排计划.周四%Type,
  周五_In     In 挂号安排计划.周五%Type,
  周六_In     In 挂号安排计划.周六%Type,
  限号控制_In In Varchar2,
  分诊方式_In In 挂号安排计划.分诊方式%Type,
  序号控制_In In 挂号安排计划.序号控制%Type,
  项目id_In   In 挂号安排计划.项目id%Type,
  医生姓名_In In 挂号安排计划.医生姓名%Type,
  医生id_In   In 挂号安排计划.医生id%Type,
  诊室_In     Varchar2,
  新增_In     Number := 1,
  处理类型_In Number := 0,
  时段间隔_In 挂号安排计划.默认时段间隔%Type := 0
) Is
  --  限号控制_IN:|周一,22(限号),13(限约)|周二,20(限号),11(限约)....
  --  处理类型 0-对时段信息不处理
  --            新增时 不提取安排的时段数据
  --            修改时 修改了排班后对时段数据不进行处理 ,只删除 去掉了排班的时段)
  --         1.新增时  自动提取挂号安排时段的数据作为计划时段的数据
  --           修改时  清除该计划所有的计划时段的数据
  --  时段间隔_IN:为计划设置时段是默认时间段间隔
  --立即启用_IN,立即审核_IN,此两个参数,暂时未使用
  Err_Item Exception;
  v_Err_Msg   Varchar2(500);
  v_User_Name 人员表.姓名%Type;
  v_诊室      Varchar2(4000);
  d_Date      Date;
  n_限号数    挂号安排限制.限号数%Type;
  n_限约数    挂号安排限制.限约数%Type;
  v_限制项目  挂号安排限制.限制项目%Type;
  v_限制控制  Varchar2(4000);
  v_当前项目  Varchar2(4000);
  v_Rowtotal  Number(9) := 1;
  v_Firstid   挂号安排计划.Id%Type;
Begin
  Begin
    Select p.姓名 Into v_User_Name From 上机人员表 O, 人员表 P Where o.人员id = p.Id And 用户名 = User;
  Exception
    When Others Then
      v_User_Name := Null;
  End;
  If v_User_Name Is Null Then
    v_Err_Msg := '[ZLSOFT]当前用户未设置对应的人员信息,请与' || Chr(10) || Chr(13) || '系统管理员联系,先到用户授权管理中设置！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --之所以要减,主要是避免当前立即生效的结果
  Select Sysdate - 20 * 1 / 24 / 60 / 60 Into d_Date From Dual;
  If 生效时间_In < d_Date Then
    v_Err_Msg := '[ZLSOFT]计划生效时间,必须大于当前时间,请检查！[ZLSOFT]';
    Raise Err_Item;
  End If;
  If 新增_In = 1 Then
    Select Count(1) Into v_Rowtotal From 挂号安排计划 Where 安排id = 安排id_In;
  
    Insert Into 挂号安排计划
      (ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 安排人, 安排时间, 审核人, 审核时间, 实际生效, 项目id, 医生姓名, 医生id,
       默认时段间隔)
      Select Id_In, 安排id_In, 号码_In, 生效时间_In, 失效时间_In, 周日_In, 周一_In, 周二_In, 周三_In, 周四_In, 周五_In, 周六_In, 分诊方式_In, 序号控制_In,
             v_User_Name, Sysdate, Null, Null, To_Date('3000-01-01', 'yyyy-mm-dd'), 项目id_In, 医生姓名_In, 医生id_In,
             Nvl(时段间隔_In, 5)
      From Dual;
    For r_合作单位 In (Select 名称 From 挂号合作单位) Loop
      Insert Into 合作单位计划控制
        (合作单位, 计划id, 限制项目, 序号, 数量)
        Select r_合作单位.名称, Id_In, '周日', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周一', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周二', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周三', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周四', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周五', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周六', 0, 0 From Dual;
    End Loop;
    --处理首次添加计划时 把原来挂号安排中的数据作为一个长期计划添加的挂号安排计划以及相关的表中
    If v_Rowtotal = 0 Then
      Select 挂号安排计划_Id.Nextval Into v_Firstid From Dual;
      Insert Into 挂号安排计划
        (ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 安排人, 安排时间, 审核人, 审核时间, 实际生效, 项目id, 医生姓名, 医生id,
         默认时段间隔)
        Select v_Firstid As ID, ID As 安排id, 号码, Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')),
               Nvl(终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')), 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, v_User_Name,
               Sysdate, v_User_Name, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'), 项目id, 医生姓名, 医生id, Nvl(默认时段间隔, 5)
        From 挂号安排
        Where ID = 安排id_In;
      Insert Into 挂号计划诊室
        (计划id, 门诊诊室)
        Select v_Firstid As 计划id, 门诊诊室 From 挂号安排诊室 Where 号表id = 安排id_In;
      Insert Into 挂号计划限制
        (计划id, 限号数, 限约数, 限制项目)
        Select v_Firstid As 计划id, 限号数, 限约数, 限制项目 From 挂号安排限制 Where 安排id = 安排id_In;
      Insert Into 挂号计划时段
        (计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
        Select v_Firstid As 计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期
        From 挂号安排时段
        Where 安排id = 安排id_In;
      Insert Into 合作单位计划控制
        (合作单位, 计划id, 限制项目, 序号, 数量)
        Select 合作单位, v_Firstid, 限制项目, 序号, 数量 From 合作单位安排控制 Where 安排id = 安排id_In;
    End If;
  
  Else
    Delete 挂号计划诊室 Where 计划id = Id_In;
    --修改计划时 先处理时段信息
    If Nvl(处理类型_In, 0) = 0 Then
      If Nvl(处理类型_In, 0) = 1 Then
        Delete 挂号计划时段 Where 计划id = Id_In; --
      Else
        --针对存在时段这种情况需要先处理排班修改后的时段 在后再修改安排
        Delete 挂号计划时段
        Where 计划id = Id_In And 星期 In (Select 星期
                                      From (Select Case 周一
                                                       When 周一_In Then
                                                        Null
                                                       Else
                                                        '周一'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周二
                                                       When 周二_In Then
                                                        Null
                                                       Else
                                                        '周二'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周三
                                                       When 周三_In Then
                                                        Null
                                                       Else
                                                        '周三'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周四
                                                       When 周四_In Then
                                                        Null
                                                       Else
                                                        '周四'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周五
                                                       When 周五_In Then
                                                        Null
                                                       Else
                                                        '周五'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周六
                                                       When 周六_In Then
                                                        Null
                                                       Else
                                                        '周六'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In
                                             Union All
                                             Select Case 周日
                                                       When 周日_In Then
                                                        Null
                                                       Else
                                                        '周日'
                                                     End As 星期
                                             From 挂号安排计划
                                             Where ID = Id_In) A
                                      Where a.星期 Is Not Null);
      End If;
    Else
      Delete 挂号计划时段 Where 计划id = Id_In;
    End If;
  
    Update 挂号安排计划
    Set ID = Id_In, 安排id = 安排id_In, 号码 = 号码_In, 生效时间 = 生效时间_In, 失效时间 = 失效时间_In, 周日 = 周日_In, 周一 = 周一_In, 周二 = 周二_In,
        周三 = 周三_In, 周四 = 周四_In, 周五 = 周五_In, 周六 = 周六_In, 分诊方式 = 分诊方式_In, 序号控制 = 序号控制_In, 安排人 = v_User_Name,
        安排时间 = Sysdate, 项目id = Nvl(项目id_In, 项目id), 医生姓名 = 医生姓名_In, 医生id = Decode(医生id_In, 0, Null, 医生id_In),
        默认时段间隔 = Decode(Nvl(时段间隔_In, 0), 0, 默认时段间隔, 时段间隔_In)
    Where ID = Id_In And 审核时间 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '[ZLSOFT]该计划安排已经被他人审核或删除,不能再修改![ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete 挂号计划限制 Where 计划id = Id_In;
  End If;

  v_限制控制 := 限号控制_In || '|';
  While v_限制控制 Is Not Null Loop
    v_当前项目 := Substr(v_限制控制, 1, Instr(v_限制控制, '|') - 1);
    v_限制项目 := Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1);
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_限号数   := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    n_限约数   := To_Number(Substr(v_当前项目, Instr(v_当前项目, ',') + 1));
    Insert Into 挂号计划限制
      (计划id, 限制项目, 限号数, 限约数)
    Values
      (Id_In, v_限制项目, Decode(n_限号数, 0, Null, n_限号数), n_限约数);
    v_限制控制 := Substr(v_限制控制, Instr(v_限制控制, '|') + 1);
  End Loop;
  --对挂号计划时段进行处理
  If Nvl(新增_In, 0) = 1 And 处理类型_In = 1 Then
    --提取挂号安排时段的数据作为计划时段的数据
    Insert Into 挂号计划时段
      (计划id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
      Select Id_In, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期 From 挂号安排时段 Where 安排id = 安排id_In;
  End If;
  --挂号安排诊室处理
  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ';';
    While v_诊室 Is Not Null Loop
      Insert Into 挂号计划诊室 (计划id, 门诊诊室) Values (Id_In, Substr(v_诊室, 1, Instr(v_诊室, ';') - 1));
      v_诊室 := Substr(v_诊室, Instr(v_诊室, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排计划_Insert;
/

--85490:胡俊勇,2015-06-09,输血皮试医嘱核对
--84826:胡俊勇,2015-06-02,医嘱停止消息处理
--84960:胡俊勇,2015-06-01,指定终止时间的长嘱发送回退问题
Create Or Replace Procedure Zl_病人医嘱发送_Insert
(
  医嘱id_In     病人医嘱发送.医嘱id%Type,
  发送号_In     病人医嘱发送.发送号%Type,
  记录性质_In   病人医嘱发送.记录性质%Type,
  No_In         病人医嘱发送.No%Type,
  记录序号_In   病人医嘱发送.记录序号%Type,
  发送数次_In   病人医嘱发送.发送数次%Type,
  首次时间_In   病人医嘱发送.首次时间%Type,
  末次时间_In   病人医嘱发送.末次时间%Type,
  发送时间_In   病人医嘱发送.发送时间%Type,
  执行状态_In   病人医嘱发送.执行状态%Type,
  执行部门id_In 病人医嘱发送.执行部门id%Type,
  计费状态_In   病人医嘱发送.计费状态%Type,
  First_In      Number := 0,
  样本条码_In   病人医嘱发送.样本条码%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  领药号_In     未发药品记录.领药号%Type := Null,
  门诊记帐_In   病人医嘱发送.门诊记帐%Type := Null,
  分解时间_In   Varchar2 := Null
  --功能：填写病人医嘱发送记录
  --参数：
  --      医嘱id_In=要发送的每个医嘱ID
  --      First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送)
  --      发送数次_IN,首次时间_IN,末次时间_IN:对"持续性"长嘱,不填写发送数次,可填写首末次时间(用于回退)。
  --      门诊记帐_In,住院临嘱发送到门诊记帐时才填写为1（因为记录性质是2，用于区分住院记帐），其余情况均填空。
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.主页id, a.婴儿, a.姓名, a.病人科室id, c.操作类型, a.诊疗类别, a.医嘱期效, a.医嘱状态, a.医嘱内容,
           a.开嘱医生, a.开嘱时间, a.开始执行时间, a.上次执行时间, a.执行终止时间, a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.开嘱科室id, a.标本部位, a.执行科室id,
           a.相关id, a.诊疗项目id
    From 病人医嘱记录 A, 诊疗项目目录 C
    Where a.诊疗项目id = c.Id And a.Id = 医嘱id_In;
  r_Advice c_Advice%RowType;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱),婴儿传入-1表示都处理
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后,婴儿传入-1表示都处理
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --其它临时变量
  v_婴儿     病人医嘱记录.婴儿%Type;
  v_持续性   Number(1); --是否持续性长嘱
  v_Autostop Number(1);
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_停止时间 病人医嘱记录.开嘱时间%Type;
  n_执行状态 病人医嘱发送.执行状态%Type;
  d_开始时间 病人医嘱记录.开始执行时间%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  v_Error         Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  If 首次时间_In Is Null Or 分解时间_In Is Null Or 末次时间_In Is Null Then
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In;
  End If;

  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;
  Close c_Advice;

  --是一组医嘱的第一行时处理医嘱内容
  If Nvl(First_In, 0) = 1 Then
    --并发操作检查
    ---------------------------------------------------------------------------------------
    If Nvl(r_Advice.医嘱状态, 0) = 4 Then
      --检查要发送的医嘱是否被作废
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人作废。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then
      --长嘱：含成药长嘱,配方长嘱,非药"可选频率"长嘱,非药"持续性"长嘱
    
      --检查长嘱是否已被发送
      If r_Advice.上次执行时间 Is Not Null Then
        If r_Advice.上次执行时间 >= 首次时间_In Then
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                     '该病人的医嘱发送失败。请重新读取发送清单再试。';
          Raise Err_Custom;
        End If;
      End If;
    
      --检查长嘱发送前是否已被自动停止(如术后)
      If r_Advice.执行终止时间 Is Not Null Then
        If 首次时间_In > r_Advice.执行终止时间 Then
          v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被停止。' || Chr(13) || Chr(10) ||
                     '该病人的医嘱发送失败。请重新读取发送清单再试。';
          Raise Err_Custom;
        End If;
      End If;
    Elsif Nvl(r_Advice.医嘱状态, 0) In (8, 9) Then
      --临嘱：含配方临嘱
    
      --检查是否已被发送(或因其它原因自动停止)
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理
    ---------------------------------------------------------------------------------------
    If Nvl(r_Advice.医嘱期效, 0) = 0 Then
      --长期医嘱:更新上次执行时间
      Update 病人医嘱记录 Set 上次执行时间 = 末次时间_In Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    
      --判断是否持续性长嘱
      v_持续性 := 0;
      If r_Advice.执行时间方案 Is Null And (Nvl(r_Advice.频率次数, 0) = 0 Or Nvl(r_Advice.频率间隔, 0) = 0 Or r_Advice.间隔单位 Is Null) Then
        v_持续性 := 1;
      End If;
    
      --预定了终止时间且未停止的自动停止
      If r_Advice.执行终止时间 Is Not Null And Nvl(r_Advice.医嘱状态, 0) Not In (8, 9) Then
        v_Autostop := 0;
        If v_持续性 = 1 Then
          --非药"持续性"长嘱
          If Trunc(末次时间_In) = Trunc(r_Advice.执行终止时间 - 1) Then
            v_Autostop := 1; --终止这天不执行
          End If;
        Elsif Zl_Advicenexttime(医嘱id_In) > r_Advice.执行终止时间 Then
          --成药长嘱或非药"可选频率"长嘱
          v_Autostop := 1; --如果是等于,还可以执行一次
        End If;
      
        If v_Autostop = 1 Then
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 停嘱时间 = 末次时间_In, 停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, r_Advice.开嘱医生, 发送时间_In
            From 病人医嘱记录
            Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Advice.组id;
        End If;
      End If;
    Else
      --临嘱停止。
      --住院医生发送时自动校对、停止：校对是以Sysdate取的,为避免重复,停止时间也取Sysdate
      Select Sysdate Into v_Date From Dual;
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
          --为一次性临嘱时没有
          上次执行时间 = 末次时间_In,
          --为一次性临嘱时没有
          停嘱时间 = v_Date,
          --发送时间_IN,
          停嘱医生 = r_Advice.开嘱医生
      Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, v_Date --发送时间_IN
        From 病人医嘱记录
        Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
    End If;
  
    --特殊医嘱的处理
    ---------------------------------------------------------------------------------------
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' Then
      --(1-留观;2-住院;)3-转科;4-术后(不发送);5-出院;6-转院,7-会诊,11-死亡
    
      --几种特殊医嘱要自动停止病人该医嘱之前(按时间算)所有未停的长嘱
      If r_Advice.操作类型 In ('3', '5', '6', '11') Then
        If Nvl(r_Advice.婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(r_Advice.婴儿, 0);
        End If;
        For r_Needstop In c_Needstop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop
          Select Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 发送时间_In, 停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(r_Advice.病人id, r_Advice.主页id, v_婴儿, r_Advice.开始执行时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - r_Advice.开始执行时间), 1, 开始执行时间, r_Advice.开始执行时间), 停嘱时间 = 发送时间_In,
              停嘱医生 = r_Advice.开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 发送时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）,同时处理临嘱
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And
              (医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) Or
              医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3) And 执行标记 <> -1;
      End If;
    
      --具体的特殊处理
      If Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '3' And 执行部门id_In Is Not Null And r_Advice.病人科室id Is Not Null And
           Nvl(r_Advice.病人科室id, 0) <> Nvl(执行部门id_In, 0) Then
          --转科医嘱,将病人登记转科到"执行科室ID"(在院病人且当前科室与转入科室不同才处理)
          Zl_病人变动记录_Change(r_Advice.病人id, r_Advice.主页id, 执行部门id_In, v_人员编号, v_人员姓名);
        Elsif r_Advice.操作类型 In ('5', '6', '11') Then
          --出院、转院、死亡医嘱,将病人标记为预出院
          Begin
            Select 开始时间
            Into v_Date
            From 病人变动记录
            Where 开始时间 Is Not Null And 终止时间 Is Null And 病人id = r_Advice.病人id And 主页id = r_Advice.主页id;
          Exception
            When Others Then
              v_Date := To_Date('1900-01-01', 'YYYY-MM-DD');
          End;
          If r_Advice.开始执行时间 <= v_Date Then
            v_Error := '医嘱"' || r_Advice.医嘱内容 || '"的开始时间应大于该病人上次变动时间 ' || To_Char(v_Date, 'YYYY-MM-DD HH24:Mi') || ' 。';
            Raise Err_Custom;
          End If;
          Zl_病人变动记录_Preout(r_Advice.病人id, r_Advice.主页id, r_Advice.开始执行时间);
        End If;
      End If;
    End If;
    --12小时未执行的备用临嘱处理为标记未用
    If r_Advice.医嘱期效 = 1 Then
      Update 病人医嘱记录
      Set 执行标记 = -1
      Where 病人id = r_Advice.病人id And 主页id = r_Advice.主页id And 执行标记 <> -1 And 医嘱期效 = 1 And 执行频次 = '需要时' And
            Sysdate - 开始执行时间 > 0.5 And 医嘱状态 = 3;
    End If;
  End If;

  --填写发送记录
  ---------------------------------------------------------------------------------------
  n_执行状态 := 执行状态_In;
  If 执行状态_In = 1 Then
    v_Temp := zl_GetSysParameter(186);
    If v_Temp = '11' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 in ('1','8') Or r_Advice.诊疗类别 = 'K' Then
        n_执行状态 := 0;
      End If;
    Elsif v_Temp = '01' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
        n_执行状态 := 0;
      End If;
    Elsif v_Temp = '10' Then
      If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '8' Or r_Advice.诊疗类别 = 'K' Then
        n_执行状态 := 0;
      End If;    
    End If;
  End If;

  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, n_执行状态, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, 门诊记帐_In);

  --领药号的填写
  If 领药号_In Is Not Null Then
    Update 未发药品记录 Set 领药号 = 领药号_In Where NO = No_In And 单据 = 9 And 领药号 Is Null;
    Update 药品收发记录 Set 产品合格证 = 领药号_In Where NO = No_In And 单据 = 9 And 产品合格证 Is Null;
  End If;

  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;

  --产生医嘱执行时间记录(只产生主记录的)
  If Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss')) Is Not Null Then
    If r_Advice.相关id Is Null Then
      Insert Into 医嘱执行时间
        (要求时间, 医嘱id, 发送号)
        Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, 发送号_In
        From Table(f_Str2list(Nvl(分解时间_In, To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi:ss'))));
    End If;
  End If;

  --病历书写时机的填写
  If r_Advice.诊疗类别 = 'F' Then
    --一组手术只调一次
    If r_Advice.相关id Is Null Then
      If Not r_Advice.标本部位 Is Null Then
        v_Date := To_Date(r_Advice.标本部位, 'yyyy-mm-dd hh24:mi:ss');
      Else
        v_Date := r_Advice.开始执行时间;
      End If;
      Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '手术', r_Advice.开嘱科室id, r_Advice.开嘱医生, v_Date, v_Date,
                       r_Advice.执行科室id);
    End If;
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '7' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '会诊', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '8' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '抢救', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  Elsif r_Advice.诊疗类别 = 'Z' And r_Advice.操作类型 = '11' Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '死亡', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id);
  End If;
  --额外调用(知情文件允许的诊疗类别才调用)
  If Instr('C,D,E,F,G,K,L', r_Advice.诊疗类别) > 0 Then
    Zl_电子病历时机_Insert(r_Advice.病人id, r_Advice.主页id, 2, '知情文书', r_Advice.开嘱科室id, r_Advice.开嘱医生, r_Advice.开始执行时间,
                     r_Advice.开始执行时间, r_Advice.执行科室id, r_Advice.诊疗项目id, r_Advice.医嘱内容);
  End If;
  --医嘱停止消息的处理
  If v_Stopadviceids Is Not Null Then
    v_Stopadviceids := Substr(v_Stopadviceids, 2);
    Select Max(a.Id)
    Into n_标记
    From 病人医嘱记录 A
    Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
          Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
    If n_标记 Is Not Null Then
      Select Max(a.Id)
      Into n_Adviceid
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
            a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_Adviceid Is Not Null Then
        Select Nvl(Max(0), 2)
        Into n_标记
        From 业务消息清单 A
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And
              a.是否已阅 = 0;
      Else
        n_Adviceid := n_标记;
        Select Nvl(Max(0), 1)
        Into n_标记
        From 业务消息清单 A
        Where a.病人id = r_Advice.病人id And a.就诊id = r_Advice.主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
      End If;
      If n_标记 > 0 Then
        For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                  From 病案主页 A
                  Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id) Loop
          Zl_业务消息清单_Insert(r_Advice.病人id, r_Advice.主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002',
                           n_Adviceid, n_标记, 0, Null, r.病区id);
        End Loop;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱发送_Insert;
/

--85180:胡俊勇,2015-05-31,历史消息的长期积累带来的性能问题
Create Or Replace Procedure Zl1_Autodelmsg As
  --功能：自动删除消息列表中的数据 
Begin
  If f_Is_Primary_Node = 0 Then
    Return;
  End If;
  Delete 业务消息清单 A
  Where a.登记时间 < (Select Sysdate - b.保留天数 From 业务消息类型 B Where b.编码 = a.类型编码 And Nvl(b.保留天数, 0) > 0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autodelmsg;
/

--84826:胡俊勇,2015-06-02,医嘱停止消息处理
Create Or Replace Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_参数值   Zlparameters.参数值%Type;
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select zl_GetSysParameter(25) Into v_参数值 From Dual;
    If Nvl(v_参数值, '0') <> '0' Then
      Select zl_GetSysParameter(26) Into v_参数值 From Dual;
      If v_前提id Is Null Then
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 1;
      Else
        Select Count(*) Into v_Count From 电子签名启用部门 Where 部门id = v_开嘱科室id And 场合 = 3;
      End If;
      If Nvl(Substr(v_参数值, 2, 1), '0') = '1' And v_前提id Is Null And v_Count > 0 Or
         Nvl(Substr(v_参数值, 3, 1), '0') = '1' And v_前提id Is Not Null And v_Count > 0 Then
        Select Nvl(Max(是否停用), 0)
        Into v_Count
        From (Select a.是否停用, a.注册时间
               From 人员证书记录 A, 人员表 B
               Where a.人员id = b.Id And b.姓名 = v_开嘱医生
               Order By a.注册时间 Desc)
        Where Rownum < 2;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;
      
        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;
  
    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
  
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;
  
    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;
      
        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;
    
      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;
    
      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;
      
        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;
      
        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;
      
        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--86279:马政,2015-07-07,药品调价产地问题
--84875:马政,2015-05-29,调价并发处理
--84873:马政,2015-05-27,调价供应商调整
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  Adjustid    In Number, --调价记录的ID
  Bln定价     In Number := 0, --是否转为定价销售（更新2004-06-08、收费细目中的变价）
  Billinfo_In In Varchar2 := Null, --用于时价药品按批次调价。格式:"批次1,现价1|批次2,现价2|....."
  药品id_In   In Number := 0 --当不为0时表示是成本价调价，不处理售价相关内容
) As
  Classid      Number(18); --入出类别
  Billno       Number(18); --调价单号
  Rundate      Date; --调价生效时间
  Blnrun       Number(1); --调价时刻到了
  Blncurprice  Number(1); --时价药品
  Lng细目id    Number(18); --收费细目ID
  Adjustdate   Date; --调价时间
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_序号       Number(8);
  n_原价id     收费价目.原价id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_变动原因   收费价目.变动原因%Type;

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, Billno NO, Rownum 序号, Classid 入出类别id, m.Id As 药品id, s.批次, Null 批号, Null 效期, s.上次产地 As 产地, 1 付数,
           s.上次供应商id As 供应商id, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率, '药品调价' 摘要, Zl_Username 填制人,
           Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(m.是否变价, 0) As 时价, s.实际金额 As 库存金额, s.实际差价 As 库存差价
    From 药品库存 S, 收费项目目录 M, 收费价目 A
    Where s.药品id = m.Id And m.Id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And a.执行日期 <= Sysdate;

  v_Data c_Price%RowType;

  Cursor c_时价按批次调价 --时价药品按批次调价
  Is
    Select 1 记录状态, 13 单据, Billno NO, n_序号 + Rownum 序号, Classid 入出类别id, m.药品id 药品id, s.批次 批次, Null 批号, Null 效期,
           s.上次产地 As 产地, s.上次供应商id As 供应商id, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '药品调价' 摘要, Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价,
           s.实际金额 As 库存金额, s.实际差价 As 库存差价
    From 药品库存 S, 药品目录 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = b.Id And s.药品id = m.药品id And m.药品id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;

  v_时价按批次调价 c_时价按批次调价%RowType;
Begin
  If 药品id_In <> 0 Then
    --成本价调价
    Zl_药品收发记录_成本价调价(药品id_In);
  Else
    n_变动原因 := 0;
    --取调价记录生效日期
    Select 收费细目id, 执行日期, 收入项目id Into Lng细目id, Rundate, n_收入项目id From 收费价目 Where ID = Adjustid;
  
    If Sysdate >= Rundate Then
      Blnrun := 1;
    Else
      Blnrun := 0;
    End If;
  
    If Blnrun = 1 Then
      --取入出类别ID
      Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;
    
      --取序列
      Select 药品收发记录_Id.Nextval Into Billno From Dual;
    
      --取该药品是否是时价药品
      Select Nvl(是否变价, 0) Into Blncurprice From 收费项目目录 Where ID = Lng细目id;
    
      --检查是否存在原价和现价相同的情况，相同时不执行调售价功能，并且删除这条收费价目记录，恢复原来的收费价目
      Begin
        Select 原价id Into n_原价id From 收费价目 Where ID = Adjustid And 原价 = 现价 And 原价id Is Not Null;
      Exception
        When Others Then
          n_原价id := 0;
      End;
    
      If n_原价id > 0 Then
        --如果现价=原价，这种情况下是单独调整收入项目，更新收入项目ID，删除调价记录
        Delete 收费价目 Where ID = Adjustid;
        Update 收费价目
        Set 收入项目id = n_收入项目id, 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
        Where ID = n_原价id;
      Else
        Adjustdate := Sysdate;
      
        Begin
          Select 变动原因 Into n_变动原因 From 收费价目 Where ID = Adjustid And 变动原因 = 1;
        Exception
          When Others Then
            n_变动原因 := 0;
        End;
        If n_变动原因 = 0 Then
          If Billinfo_In = '' Or Billinfo_In Is Null Then
            For v_Data In c_Price Loop
              Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              If Nvl(v_Data.填写数量, 0) = 0 And (Nvl(v_Data.库存金额, 0) <> 0 Or Nvl(v_Data.库存差价, 0) <> 0) Then
                --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据            
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                   填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量, v_Data.成本价, v_Data.成本金额,
                   v_Data.零售价, v_Data.扣率, v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id,
                   Zl_Username, Adjustdate, v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新库存零售价,只有时价分批药品才能更新零售价字段
                Zl_药品库存_Update(n_收发id);
              Else
                If Blncurprice = 1 Then
                  n_零售价 := v_Data.库存金额 / v_Data.填写数量;
                Else
                  n_零售价 := v_Data.成本价;
                End If;
                n_零售金额 := Round((v_Data.零售价 - n_零售价) * v_Data.填写数量, 2);
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
                   填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量, v_Data.成本价, v_Data.成本金额,
                   v_Data.零售价, v_Data.扣率, n_零售金额, n_零售金额, v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数,
                   v_Data.价格id, Zl_Username, Adjustdate, v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新药品库存
                Zl_药品库存_Update(n_收发id);
              End If;
            End Loop;
          Else
            n_序号 := 0;
            --时价药品按批次调价
            v_Infotmp := Billinfo_In || '|';
            While v_Infotmp Is Not Null Loop
              --分解单据ID串
              v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
              n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
              n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
              v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
            
              For v_时价按批次调价 In c_时价按批次调价 Loop
                If v_时价按批次调价.填写数量 <> 0 Then
                  n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
                Else
                  n_原价 := v_时价按批次调价.成本价;
                End If;
              
                Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
                If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
                  --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据              
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                     填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人,
                     v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username, Adjustdate,
                     v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存零售价,只有时价分批药品才能更新零售价字段
                  Zl_药品库存_Update(n_收发id);
                Else
                
                  n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
                  n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价,
                     摘要, 填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要,
                     v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username,
                     Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存
                  Zl_药品库存_Update(n_收发id);
                End If;
              End Loop;
            End Loop;
          End If;
        
          Update 收费价目 Set 变动原因 = 1 Where ID = Adjustid;
        
          --更新药品目录、收费细目中的变价
          If Bln定价 = 1 Then
            Update 收费项目目录 Set 是否变价 = 0 Where ID = Lng细目id;
            Update 收费细目 Set 是否变价 = 0 Where ID = Lng细目id;
          End If;
        End If;
      End If;
    
      If n_变动原因 = 0 Then
        --成本价调价
        Zl_药品收发记录_成本价调价(Lng细目id, Rundate);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/

--85355:刘尔旋,2015-06-03,取号过程计划不同医生的处理
--85287:刘尔旋,2015-06-02,挂号安排设置是否预约
--85137:刘尔旋,2015-05-28,获取号源剩余数量的问题
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD/>      //时间段
  --                  <SL/>      //数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;

  Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  n_合约剩余数量 := 0;
  If Nvl(n_科室id, 0) <> 0 Then
    --按科室过滤号别
    For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.科室id = n_科室id And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
      If r_No.计划id <> 0 Then
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排计划 Jh, 挂号计划时段 Sd
        Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      Else
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排 Ap, 挂号安排时段 Sd
        Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      End If;
      If n_分时段 = 0 Then
        v_Temp := '';
        If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
          If r_No.计划id <> 0 Then
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          Else
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          End If;
          If n_合约模式 = 0 Then
            If r_No.计划id <> 0 Then
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位计划控制
                     Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位安排控制
                     Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            End If;
          Else
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
          End If;
          If n_合约总数量 = 0 Then
            n_合约剩余数量 := 0;
          Else
            n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
            If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
              n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
            End If;
          End If;
        End If;
      Else
        v_Temp := '<SPANLIST>';
        If r_No.计划id <> 0 Then
          Select Max(结束时间)
          Into d_加号时间
          From 挂号计划时段
          Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Jh.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排计划 Jh, 挂号计划时段 Sd
                     Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
              Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
            End If;
          
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                           Order By Jh.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        Else
          Select Max(结束时间)
          Into d_加号时间
          From 挂号安排时段
          Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Ap.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排 Ap, 挂号安排时段 Sd
                     Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
              Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
            End If;
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  Begin
                    Select 1
                    Into n_是否预留
                    From 挂号序号状态
                    Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                  Exception
                    When Others Then
                      n_是否预留 := 0;
                  End;
                  If n_是否预留 = 0 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + 1;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                           Order By Ap.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        End If;
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 0
            Into n_非合约
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        Else
          Begin
            Select 0
            Into n_非合约
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        End If;
      End If;
      If v_合作单位 Is Null Or n_非合约 = 1 Then
        If r_No.限号数 = 0 Then
          v_剩余数量 := '';
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          Else
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          End If;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          Select Count(1)
          Into n_预留数量
          From 挂号序号状态
          Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
          If Trunc(d_日期) = Trunc(Sysdate) Then
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
            Else
              v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
            End If;
            n_已挂数 := r_No.已挂数;
            If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
              n_缓冲序号 := 1;
              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' || '<SL>' ||
                            To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
            Else
              n_缓冲序号 := 0;
            End If;
          Else
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
              If v_剩余数量 Is Null Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              End If;
            Else
              v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              If v_剩余数量 Is Null Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
            End If;
            n_已挂数 := r_No.已挂数;
          End If;
        End If;
      Else
        If Nvl(r_No.计划id, 0) <> 0 Then
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位计划控制
          Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        Else
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位安排控制
          Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        End If;
        If n_合约模式 = 0 Then
          v_剩余数量   := n_合约剩余数量;
          n_已挂数     := r_No.已挂数;
          n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
        Else
          n_已挂数 := r_No.已挂数;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          If Nvl(n_合约总数量, 0) = 0 Then
            v_剩余数量 := '0';
          Else
            v_剩余数量 := n_合约总数量 - n_合约已挂数;
          End If;
        End If;
      End If;
      Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_Timetemp || '-';
      Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_时间段 || v_Timetemp;
      If v_Temp Is Not Null Then
        v_Temp := v_Temp || '</SPANLIST>';
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 1
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        Else
          Begin
            Select 1
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        End If;
      End If;
      If Nvl(n_禁用, 0) = 0 Then
        --从项金额计算
        n_合计金额 := r_No.价格;
        For r_Subfee In (Select 现价, 从项数次
                         From 收费从属项目 A, 收费价目 B
                         Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                               Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
          n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
        End Loop;
        If Trunc(Sysdate) = Trunc(d_日期) Then
          Begin
            Select 1
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Exception
            When Others Then
              n_Exists := 0;
          End;
        Else
          n_Exists := 1;
        End If;
        If n_Exists = 1 Then
          If v_剩余数量 > 0 Then
            v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                         '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                         '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                         r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
          Else
            v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                         '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                         '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    If Nvl(n_医生id, 0) <> 0 Then
      --按医生ID过滤号别
      For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                                '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                                '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select Max(结束时间)
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          Else
            Select Max(结束时间)
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位计划控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位安排控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 1
              Into n_禁用
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          Else
            Begin
              Select 1
              Into n_禁用
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Begin
              Select 1
              Into n_Exists
              From (Select 时间段
                     From 时间段
                     Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                   '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
              Where 时间段 = r_No.排班;
            Exception
              When Others Then
                n_Exists := 0;
            End;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                           '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                           r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                           '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                           '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
            Else
              v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                           '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                           r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                           '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                           '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' ||
                           n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
            End If;
          End If;
        End If;
        n_合约剩余数量 := 0;
        n_合约总数量   := 0;
        n_时段数量     := 0;
        n_禁用         := 0;
        n_非合约       := 0;
      End Loop;
      v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                   '</HBLIST>' || '</GROUP>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
    Else
      If Nvl(v_医生姓名, '_') <> '_' Then
        --按医生姓名过滤号别
        For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5',
                                                  Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Ap.医生姓名 = v_医生姓名 And Ap.停用日期 Is Null And
                                         d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5',
                                                  Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生姓名 = v_医生姓名 And
                                         d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
          If r_No.计划id <> 0 Then
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排计划 Jh, 挂号计划时段 Sd
            Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          Else
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排 Ap, 挂号安排时段 Sd
            Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          End If;
          If n_分时段 = 0 Then
            v_Temp := '';
            If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
              If r_No.计划id <> 0 Then
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              Else
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              End If;
              If n_合约模式 = 0 Then
                If r_No.计划id <> 0 Then
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位计划控制
                         Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                Else
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位安排控制
                         Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                End If;
              Else
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
              End If;
              If n_合约总数量 = 0 Then
                n_合约剩余数量 := 0;
              Else
                n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                  n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
                End If;
              End If;
            End If;
          Else
            v_Temp := '<SPANLIST>';
            If r_No.计划id <> 0 Then
              Select Max(结束时间)
              Into d_加号时间
              From 挂号计划时段
              Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Jh.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排计划 Jh, 挂号计划时段 Sd
                         Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                  Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                        Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                               Order By Jh.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            Else
              Select Max(结束时间)
              Into d_加号时间
              From 挂号安排时段
              Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Ap.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排 Ap, 挂号安排时段 Sd
                         Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                  Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                        Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                               Order By Ap.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 0
                Into n_非合约
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            Else
              Begin
                Select 0
                Into n_非合约
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            End If;
          End If;
          If v_合作单位 Is Null Or n_非合约 = 1 Then
            If r_No.限号数 = 0 Then
              v_剩余数量 := '';
            Else
              If Nvl(r_No.计划id, 0) <> 0 Then
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              Else
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              Select Count(1)
              Into n_预留数量
              From 挂号序号状态
              Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
              If Trunc(d_日期) = Trunc(Sysdate) Then
                If Nvl(n_合约总数量, 0) = 0 Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                Else
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
                n_已挂数 := r_No.已挂数;
                If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                  n_缓冲序号 := 1;
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                                '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
                Else
                  n_缓冲序号 := 0;
                End If;
              Else
                If Nvl(n_合约总数量, 0) = 0 Then
                  v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                  If v_剩余数量 Is Null Then
                    v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                  End If;
                Else
                  v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                  If v_剩余数量 Is Null Then
                    v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                  End If;
                End If;
                n_已挂数 := r_No.已挂数;
              End If;
            End If;
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            Else
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            End If;
            If n_合约模式 = 0 Then
              v_剩余数量   := n_合约剩余数量;
              n_已挂数     := r_No.已挂数;
              n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
            Else
              n_已挂数 := r_No.已挂数;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := '0';
              Else
                v_剩余数量 := n_合约总数量 - n_合约已挂数;
              End If;
            
            End If;
          End If;
          Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_Timetemp || '-';
          Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_时间段 || v_Timetemp;
          If v_Temp Is Not Null Then
            v_Temp := v_Temp || '</SPANLIST>';
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 1
                Into n_禁用
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_禁用
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            End If;
          End If;
          If Nvl(n_禁用, 0) = 0 Then
            --从项金额计算
            n_合计金额 := r_No.价格;
            For r_Subfee In (Select 现价, 从项数次
                             From 收费从属项目 A, 收费价目 B
                             Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                   Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
              n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
            End Loop;
            If Trunc(Sysdate) = Trunc(d_日期) Then
              Begin
                Select 1
                Into n_Exists
                From (Select 时间段
                       From 时间段
                       Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                     '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
                Where 时间段 = r_No.排班;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
            Else
              n_Exists := 1;
            End If;
            If n_Exists = 1 Then
              If v_剩余数量 > 0 Then
                v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                             '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                             r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                             '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' ||
                             '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 ||
                             '</HCXH>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' ||
                             v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              Else
                v_Xmlmain := v_Xmlmain || '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' ||
                             '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' ||
                             r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                             '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' ||
                             '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 ||
                             '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                             r_No.排班 || '</FWMC>' || '</HB>';
              End If;
            End If;
          End If;
          n_合约剩余数量 := 0;
          n_合约总数量   := 0;
          n_时段数量     := 0;
          n_禁用         := 0;
          n_非合约       := 0;
        End Loop;
        v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                     '</HBLIST>' || '</GROUP>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Getnolist;
/

--85355:刘尔旋,2015-06-03,取号过程计划不同医生的处理
--85287:刘尔旋,2015-06-02,挂号安排设置预约
--85238:刘尔旋,2015-05-28,获取排班过程新增号类入参
--85137:刘尔旋,2015-05-25,获取号源和排班修改
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --   <HL>号类</HL>      //号类，可传多个，用逗号分隔，格式:普通,专家,...
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  v_号类         Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/HL')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位, v_号类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;
  If Nvl(n_科室id, 0) = 0 Then
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      n_安排存在 := 0;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  Else
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      n_安排存在 := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       Ap.科室id = n_科室id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
        
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  End If;
  v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Docarrange;
/

--85070:刘尔旋,2015-05-21,财务组轧帐结束时间无法选择的问题
Create Or Replace Procedure Zl_小组轧帐记录_Insert
(
  Id_In       In 人员收缴记录.Id%Type,
  单据号_In   In 人员收缴记录.No%Type,
  缴款组id_In In 人员收缴记录.缴款组id%Type,
  开始时间_In In 人员收缴记录.开始时间%Type,
  终止时间_In In 人员收缴记录.终止时间%Type,
  收款员_In   In 人员收缴记录.收款员%Type,
  收款时间_In In 人员收缴记录.小组收款时间%Type,
  轧帐信息_In In Varchar2,
  操作类型_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:财务组轧帐记录写入
  --参数:
  --     轧帐信息_IN:记录ID1,记录ID2,...记录IDn
  --     操作类型_IN:0-非批量添加 1-批量添加第一条记录 2-批量添加中记录 3-批量添加最后一条记录
  ----------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(100);
  Err_Item Exception;
  n_Exists   Number(2);
  v_No       人员收缴记录.No%Type;
  v_收款员   人员收缴记录.收款员%Type;
  n_冲预交款 人员收缴记录.冲预交款%Type := 0;
  n_借入合计 人员收缴记录.借入合计%Type := 0;
  n_借出合计 人员收缴记录.借出合计%Type := 0;

Begin
  --保存前的并发检查  
  n_Exists := 0;
  Begin
    Select /*+ Rule*/
     a.No, a.收款员, 1
    Into v_No, v_收款员, n_Exists
    From 人员收缴记录 A, Table(f_Num2list(轧帐信息_In)) B
    Where a.Id = b.Column_Value And 小组轧账id Is Not Null And Rownum < 2;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists = 1 Then
    v_Err_Msg := v_收款员 || '收款员的收款单号为[' || v_No || ']的记录已被轧帐，不允许再次轧帐！';
    Raise Err_Item;
  End If;
  Begin
    Select /*+ Rule*/
     a.No, a.收款员, 1
    Into v_No, v_收款员, n_Exists
    From 人员收缴记录 A, Table(f_Num2list(轧帐信息_In)) B
    Where a.Id = b.Column_Value And 财务收款时间 Is Not Null And Rownum < 2;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists = 1 Then
    v_Err_Msg := v_收款员 || '收款员的收款单号为[' || v_No || ']的记录已被财务科收款，不允许小组进行轧帐！';
    Raise Err_Item;
  End If;
  Begin
    Select /*+ Rule*/
     a.No, a.收款员, 1
    Into v_No, v_收款员, n_Exists
    From 人员收缴记录 A, Table(f_Num2list(轧帐信息_In)) B
    Where a.Id = b.Column_Value And 作废时间 Is Not Null And Rownum < 2;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists = 1 Then
    v_Err_Msg := v_收款员 || '收款员的收款单号为[' || v_No || ']的记录已被作废，不允许进行轧帐！';
    Raise Err_Item;
  End If;

  --汇总金额
  Select /*+ Rule*/
   Sum(a.冲预交款), Sum(a.借入合计), Sum(a.借出合计)
  Into n_冲预交款, n_借入合计, n_借出合计
  From 人员收缴记录 A, Table(f_Num2list(轧帐信息_In)) B
  Where a.Id = b.Column_Value
  Group By a.记录性质;

  If 操作类型_In = 0 Or 操作类型_In = 1 Then
    --插入轧帐记录
    Insert Into 人员收缴记录
      (ID, 记录性质, NO, 收款员, 缴款组id, 登记时间, 开始时间, 终止时间, 冲预交款, 借入合计, 借出合计, 小组轧账id, 登记人)
      Select Id_In, 3, 单据号_In, 收款员_In, 缴款组id_In, 收款时间_In, 开始时间_In, 终止时间_In, n_冲预交款, n_借入合计, n_借出合计, Id_In, 收款员_In
      From Dual;
    Update 财务缴款分组 Set 上次轧帐时间 = 终止时间_In Where ID = 缴款组id_In;
  End If;
  --更新轧帐记录
  If 操作类型_In = 2 Or 操作类型_In = 3 Then
    Update 人员收缴记录
    Set 冲预交款 = 冲预交款 + n_冲预交款, 借入合计 = 借入合计 + n_借入合计, 借出合计 = 借出合计 + n_借出合计
    Where ID = Id_In;
  End If;

  Update 人员收缴记录
  Set 小组轧账id = Id_In
  Where 小组收款id In (Select Column_Value From Table(f_Num2list(轧帐信息_In)));

  If 操作类型_In = 0 Or 操作类型_In = 3 Then
    --更新明细
    Insert Into 人员收缴明细
      (收缴id, 结算方式, 金额)
      Select Id_In, a.结算方式, Sum(a.金额)
      From 人员收缴明细 A, 人员收缴记录 B
      Where a.收缴id = b.Id And b.记录性质 = 2 And b.小组轧账id = Id_In
      Group By Id_In, 结算方式;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_小组轧帐记录_Insert;
/

--85040:许华峰,2015-05-21,新版报告消息发送
CREATE OR REPLACE Function zl_影像消息_XML内容获取
( 
    医嘱ID_In 病人医嘱记录.id%Type, 
    消息类型_In Varchar2, 
    当前用户_In Varchar2,
    消息标记_In Varchar2:=Null         --新版：检查报告ID 
) Return Varchar2 IS 
  v_Context Varchar2(4000); 
 
  --ZLHIS_CIS_005(医技执行安排完成) 
  Function Get_ZLHIS_CIS_005 Return Varchar As 
    v_Return Varchar2(4000); 
  Begin 
        Select 
          '<patient_info>' || 
             '<patient_id>' || a.病人id || '</patient_id>' || 
             '<patient_name>' || a.姓名 ||'</patient_name>' || 
          '</patient_info>' || 
          '<patient_clinic>' || 
             '<patient_source>' || b.病人来源 ||'</patient_source>' || 
             '<clinic_dept_id>' || b.病人科室id || '</clinic_dept_id>' || 
          '</patient_clinic>' || 
          '<patient_order>' || 
             '<order_id>' || c.医嘱id || '</order_id>' || 
             '<order_expiry>' || b.医嘱期效 ||'</order_expiry>' || 
             '<order_kind>' || b.诊疗类别 || '</order_kind>' || 
             '<operation_kind>' || d.操作类型 ||'</operation_kind>' || 
             '<order_item_id>' || c.医嘱id || '</order_item_id>' || 
             '<order_item_title>' || b.医嘱内容 ||'</order_item_title>' || 
          '</patient_order>' || 
          '<arrange_result>' || 
             '<arrange_time>' ||To_Char(c.安排时间,'yyyy/mm/dd hh24:mi:ss')|| '</arrange_time>' || 
          '</arrange_result>'   Into v_Return 
 
      From 病人信息 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 D 
      Where a.病人id = b.病人id And c.医嘱id = b.Id And b.诊疗项目id = d.Id And c.安排时间 Is Not Null And b.相关id Is Null And 
          b.诊疗类别 = 'D' And b.Id = 医嘱id_In; 
    Return v_Return; 
  End Get_ZLHIS_CIS_005; 
 
  --ZLHIS_CIS_017(患者检查申请) 
  Function Get_ZLHIS_CIS_017 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<check_request>' || 
               '<request_id>' || b.id || '</request_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<execute_dept_id>' || nvl(c.执行部门id,0) || '</execute_dept_id>' || 
               '<send_serial>' || c.发送号 || '</send_serial>' || 
               '<bill_no>' || c.NO || '</bill_no>' || 
               '<bill_kind>' || c.记录性质 || '</bill_kind>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_time>' || b.开嘱时间 || '</create_time>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
           '</check_request>' into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_CIS_017; 
 
  --ZLHIS_CIS_024(患者医嘱撤销) 
  Function Get_ZLHIS_CIS_024 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
       Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<cancel_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<order_kind>' || b.诊疗类别 || '</order_kind>' || 
               '<operation_kind>' || d.操作类型 || '</operation_kind>' || 
           '</cancel_order>' Into v_return 
 
       From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 诊疗项目目录 d, 病人挂号记录 e 
       Where a.病人id=b.病人id And b.id=c.医嘱id And b.诊疗项目id=d.id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_CIS_024; 
 
 
  --ZLHIS_PACS_001(检查报告完成) 
  Function Get_ZLHIS_PACS_001 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
    If 消息标记_In Is Null Then
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id, 0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_inf>' || 
               '<report_id>' || d.病历id || '</report_id>' || 
               '<report_doctor>' || c.完成人 || '</report_doctor>' || 
               '<result_positive>' || c.结果阳性 || '</result_positive>' || 
           '</report_inf>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.检查报告id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
    Else
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id, 0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_inf>' || 
               '<report_id>' || d.检查报告id || '</report_id>' || 
               '<report_doctor>' || c.完成人 || '</report_doctor>' || 
               '<result_positive>' || c.结果阳性 || '</result_positive>' || 
           '</report_inf>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.病历id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In And d.检查报告id=消息标记_In; 
    End If;
    
    Return v_return; 
  End Get_ZLHIS_PACS_001; 
 
  --ZLHIS_PACS_002(患者状态同步) 
  Function Get_ZLHIS_PACS_002 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<identity_card>' || a.身份证号 || '</identity_card>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<study_state>' || 
               '<study_cur_state>' || nvl(c.执行过程,0) || '</study_cur_state>' || 
               '<study_cur_time>' || sysdate || '</study_cur_time>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<study_item_id>' || b.诊疗项目id || '</study_item_id>' || 
               '<study_item_title>' || b.医嘱内容 || '</study_item_title>' || 
               '<study_oper_person>' || 当前用户_In || '</study_oper_person>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</study_state>' Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_002; 
 
 
  --ZLHIS_PACS_003(检查状态回退) 
  Function Get_ZLHIS_PACS_003 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<identity_card>' || a.身份证号 || '</identity_card>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(d.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id, 0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<study_state>' || 
               '<study_cur_state>' || nvl(c.执行过程,0) || '</study_cur_state>' || 
               '<study_cur_time>' || Sysdate || '</study_cur_time>' || 
               '<study_order_id>' || b.id || '</study_order_id>' || 
               '<study_item_id>' || b.诊疗项目id || '</study_item_id>' || 
               '<study_item_title>' || b.医嘱内容 || '</study_item_title>' || 
               '<study_oper_person>' || 当前用户_In || '</study_oper_person>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</study_state>' Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人挂号记录 d 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.挂号单=d.no(+) And b.相关ID Is Null 
              And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_003; 
 
 
  --ZLHIS_PACS_004(检查报告撤销) 
  Function Get_ZLHIS_PACS_004 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
    If 消息标记_In Is Null Then
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<cur_state>' || nvl(c.执行过程,0) || '</cur_state>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_info>' || 
               '<report_id>' || d.病历id || '</report_id>' || 
           '</report_info>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.检查报告id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
    Else
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(e.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_dept_id>' || nvl(a.当前科室id,0) || '</clinic_dept_id>' || 
           '</patient_clinic>' || 
           '<advice_info>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<cur_state>' || nvl(c.执行过程,0) || '</cur_state>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<create_doctor>' || b.开嘱医生 || '</create_doctor>' || 
               '<create_dept_id>' || nvl(b.开嘱科室id,0) || '</create_dept_id>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</advice_info>' || 
           '<report_info>' || 
               '<report_id>' || d.检查报告id || '</report_id>' || 
           '</report_info>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病人医嘱发送 c, 病人医嘱报告 d, 病人挂号记录 e 
        Where a.病人id=b.病人id And b.id=c.医嘱id And b.id=d.医嘱id And b.挂号单=e.no(+) And b.相关ID Is Null 
              And d.病历id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In And d.检查报告id=消息标记_In; 
    End If;
    
    Return v_return; 
  End Get_ZLHIS_PACS_004; 
  
  --ZLHIS_PACS_005(检查危急值通知) 
  Function Get_ZLHIS_PACS_005 Return Varchar As 
    v_return Varchar2(4000); 
  Begin 
        With t As (Select id, 姓名 From 人员表) 
        Select 
           '<patient_info>' || 
               '<patient_id>' || a.病人id || '</patient_id>' || 
               '<patient_name>' || a.姓名 || '</patient_name>' || 
               '<in_number>' || nvl(a.住院号,0) || '</in_number>' || 
               '<out_number>' || nvl(a.门诊号,0) || '</out_number>' || 
           '</patient_info>' || 
           '<patient_clinic>' || 
               '<patient_source>' || b.病人来源 || '</patient_source>' || 
               '<clinic_id>' || Case b.病人来源 When 1 Then nvl(i.id,0) When 2 Then nvl(b.主页id, 0) Else 0 End || '</clinic_id>' || 
               '<clinic_area_id>' || nvl(a.当前病区id,0) || '</clinic_area_id>' || 
               '<clinic_dept_id>' || nvl(b.开嘱科室id,0) || '</clinic_dept_id>' || 
               '<in_doctor_id>' || nvl(e.id,0) || '</in_doctor_id>' || 
               '<director_doctor_id>' || nvl(g.id,0) || '</director_doctor_id>' || 
               '<treat_doctor_id>' || nvl(h.id,0) || '</treat_doctor_id>' || 
               '<duty_nurse_id>' || nvl(f.id,0) || '</duty_nurse_id>' || 
           '</patient_clinic>' || 
           '<check_order>' || 
               '<order_id>' || b.id || '</order_id>' || 
               '<check_item_id>' || b.诊疗项目id || '</check_item_id>' || 
               '<check_item_title>' || b.医嘱内容 || '</check_item_title>' || 
               '<study_execute_id>' || nvl(b.执行科室id,0) || '</study_execute_id>' || 
           '</check_order>'  Into v_return 
 
        From 病人信息 a, 病人医嘱记录 b, 病案主页 c, 病人挂号记录 i, 
             (Select a.病人ID,a.主页ID,主任医师,主治医师 From 病人变动记录 a,病人医嘱记录 b 
              Where a.病人id=b.病人id And a.开始原因 Is Not Null And a.终止时间 Is Null And b.id=0) d, 
              t e, t f, t g, t h 
        Where b.病人id = a.病人id And b.挂号单=i.no(+) 
              And b.病人id=c.病人id(+) And b.主页id=c.主页id(+) 
              And c.住院医师=e.姓名(+) And c.责任护士=f.姓名(+) 
              And c.病人id =d.病人id(+) And c.主页id=d.主页id(+) 
              And d.主任医师=g.姓名(+) And d.主治医师=h.姓名(+) 
              And b.相关id Is Null And a.病人id=b.病人id And b.id=医嘱ID_In; 
 
      Return v_return; 
  End Get_ZLHIS_PACS_005; 
 
Begin 
  v_Context := ''; 
 
  Case 消息类型_In 
    When 'ZLHIS_CIS_005' Then 
      --ZLHIS_CIS_005(医技执行安排完成) 
      v_Context := Get_ZLHIS_CIS_005; 
 
    When 'ZLHIS_CIS_017' Then 
        --ZLHIS_CIS_017(患者检查申请) 
        v_Context := Get_ZLHIS_CIS_017; 
 
    When 'ZLHIS_CIS_024' Then 
        --ZLHIS_PACS_024(患者医嘱撤销) 
        v_Context := Get_ZLHIS_CIS_024; 
 
    When 'ZLHIS_PACS_001' Then 
        --ZLHIS_PACS_001(检查报告完成) 
        v_Context := Get_ZLHIS_PACS_001; 
 
    When 'ZLHIS_PACS_002' Then 
        --ZLHIS_PACS_002(检查状态同步) 
        v_Context := Get_ZLHIS_PACS_002; 
 
    When 'ZLHIS_PACS_003' Then 
        --ZLHIS_PACS_003(检查状态回退) 
        v_Context := Get_ZLHIS_PACS_003; 
 
    When 'ZLHIS_PACS_004' Then 
        --ZLHIS_PACS_004(检查报告撤销) 
        v_Context := Get_ZLHIS_PACS_004; 
 
    When 'ZLHIS_PACS_005' Then 
        --ZLHIS_PACS_005(检查危急值通知) 
        v_Context := Get_ZLHIS_PACS_005; 
    Else 
      Return ''; 
  End Case; 
 
  Return v_Context; 
End zl_影像消息_XML内容获取;
/

--84964:刘兴洪,2015-05-21,按最高价格计算护理费时的病区和开单科定
Create Or Replace Procedure Zl1_Autocptone
(
  病人id_In In Number,
  主页id_In In Number,
  期间_In   In Varchar2
) As

  -------------------------------------------------------------------------
  --功能说明：完成指定病人指定期间自动计价项目表设置自动计算的项目进行记帐处理
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志;
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费
  --             别等完成费用的正确计算：
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录;
  --             作废以前的错误计算的记录;
  --             统计本次变动(新增和作废)，填写余额表和汇总表;
  --入口参数：
  --       病人ID_IN  number    病人身份ID
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人
  --       期间_IN  varchar2     需要计算的最小期间
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程

  Cursor v_Autocur
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select Distinct 病人id, 主页id, 姓名, 性别, 年龄, 住院号, 费别, 科室id, 病区id, 床号, 附加床位, 收费细目id, 收入项目id, 标志, 标准单价, 开始日期, 终止日期, 天数,
                           数量, 经治医师, 责任护士, 操作员编号, 操作员姓名
           From 病人自动费用
           Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  n_Insure       病案主页.险类%Type;
  v_Billno       Varchar2(8); --费用表实际的自动记帐号码
  n_Datecount    Integer; --日期计数器
  d_Datefrom     Date; --开始计算日期
  d_Dateto       Date; --终止计算日期
  d_Datelast     Date;
  n_Billcount    Number(5) := 0; --单据序号计数器
  n_Exsetax      Number(16, 2) := 0; --费用收取比率
  n_Exsetax_Temp Number(16, 2) := 0; --费用收取比率
  n_Summoney     Number(16, 2) := 0; --金额

  Cursor v_Sumcur
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  n_Dec            Number; --金额小数位数
  d_登记时间       Date; --登记时间
  d_发生时间       Date; --发生时间
  n_Dates          Number(3, 1); --当前记录的天数，全天为1
  n_Do             Number(1);
  n_返回值         病人余额.预交余额%Type;
  n_Delete         Number;
  n_医疗小组id     住院费用记录.医疗小组id%Type;
  n_护理计算标准   Number(2); --护理费计算标准
  n_收费细目id     Number(18);
  n_Temp           Number(18);
  l_护理id         t_Numlist := t_Numlist();
  l_护理等级       t_Numlist := t_Numlist();
  n_护理项目       Number(2); --1:是护理项目;0-非不护理
  n_价格           收费价目.现价%Type;
  n_护理已处理     Number(2); --1-护理费已经处理,;0-未处理
  n_收入项目id     Number(18);
  n_从属项目       Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_Temp           Varchar2(20);
  d_Start_Date     Date;
  d_End_Date       Date;
  n_病人病区id     住院费用记录.病人病区id%Type;
  n_开单部门id     住院费用记录.开单部门id%Type;

  --已经计算了的护理类型
  Type t_护理_Rec Is Record(
    收费细目id 收费项目目录.Id%Type,
    日期       Date);
  Type t_护理 Is Table Of t_护理_Rec;
  c_护理 t_护理 := t_护理();

  n_Count Number(18);

Begin
  Begin
    Select 险类, Nvl(审核标志, 0), Nvl(状态, 0)
    Into n_Insure, n_审核标志, n_住院状态
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  Exception
    When Others Then
      Return;
  End;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 And Nvl(n_审核标志, 0) >= 1 Then
    Return;
  End If;
  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  v_Billno := Nextno(17);

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理计算标准
  From Dual;

  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  --锁定该病人的记录,以免重复计算
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  -----------------------------------------------------------------
  d_Datefrom := Sysdate + 1000;
  d_Dateto   := Sysdate - 1000;
  n_Do       := 0;
  --------------------------------------------------------------------
  If n_护理计算标准 = 1 Then
    --同天以最高价位的护理费为准,先将其护理等级记住,
    For v_护理 In (Select Distinct 护理等级id
                 From (Select 护理等级id
                        From 病人变动记录
                        Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In
                        Union All
                        Select i.从项id As 护理等级id
                        From 病人变动记录 B, 收费从属项目 I
                        Where b.护理等级id = i.主项id And 病人id = 病人id_In And 主页id = 主页id_In And b.开始原因 <> 10 And i.固有从属 > 0)) Loop
      If Nvl(v_护理.护理等级id, 0) <> 0 Then
        l_护理id.Extend;
        l_护理id(l_护理id.Count) := v_护理.护理等级id;
      End If;
    End Loop;
  End If;
  -----------------------------------------------------------------
  --循环检查计算情况，并增加正确和新计算的记录
  -----------------------------------------------------------------
  For v_Currrow In v_Autocur(期间_In, n_Insure) Loop
  
    n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
  
    If d_Datefrom > v_Currrow.开始日期 Then
      d_Datefrom := v_Currrow.开始日期;
      n_Do       := 1;
      --将本次开始计算时间以后的已计算记录标志修改
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= v_Currrow.开始日期;
    End If;
  
    If d_Dateto < v_Currrow.终止日期 Then
      If v_Currrow.终止日期 > Trunc(Sysdate) Then
        d_Dateto := Trunc(Sysdate);
      Else
        d_Dateto := v_Currrow.终止日期;
      End If;
    End If;
    n_收费细目id := v_Currrow.收费细目id;
    n_护理项目   := 0;
    --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。
    If n_护理计算标准 = 1 Then
      --先确定是否护理项目,如果是,则需要重新进行计算
      Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
    End If;
  
    --提取当前收入项目的收费比率
    Begin
      Select 实收比率
      Into n_Exsetax
      From (Select 实收比率
             From 费别明细
             Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                   (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
             Union All
             Select 实收比率
             From 费别明细
             Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                   (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
              (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
    Exception
      When Others Then
        n_Exsetax := 100.00;
    End;
  
    n_Exsetax := Nvl(n_Exsetax, 100);
  
    If v_Currrow.终止日期 > Trunc(Sysdate) Then
      n_Count := (Trunc(Sysdate + 0.5) - Trunc(v_Currrow.开始日期)) - 1;
    Else
      d_Start_Date := Trunc(v_Currrow.开始日期);
      d_End_Date   := Trunc(v_Currrow.终止日期 + 0.5);
    
      n_Count := d_End_Date - d_Start_Date;
    
      n_Count := n_Count - 1;
    End If;
  
    For n_Datecount In 0 .. n_Count Loop
    
      d_发生时间 := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
    
      v_Temp := To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss');
    
      n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                      Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
      n_护理已处理 := 0;
      If n_护理项目 = 1 Then
        --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准)
        n_从属项目 := 1;
        If l_护理等级.Count > 0 Then
          l_护理等级.Delete;
        End If;
        For v_护理 In (Select Distinct 护理等级id
                     From 病人变动记录
                     Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And
                           (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))) Loop
          If Nvl(v_护理.护理等级id, 0) <> 0 Then
            l_护理等级.Extend;
            l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
            If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
              n_从属项目 := 0;
            End If;
          End If;
        End Loop;
      
        If l_护理等级.Count > 1 Then
          --2. 存在两个以上变动,则取价位最高的
          n_Temp       := v_Currrow.收费细目id;
          n_价格       := Nvl(v_Currrow.标准单价, 0);
          n_收入项目id := v_Currrow.收入项目id;
          --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算
          If Nvl(n_从属项目, 0) = 1 Then
            n_护理已处理 := 1;
          End If;
          --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的
          For I In 1 .. c_护理.Count Loop
            If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
              n_护理已处理 := 1;
              Exit;
            End If;
          End Loop;
          If Nvl(n_护理已处理, 0) = 0 Then
            c_护理.Extend;
            c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
            c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
          End If;
        
          If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
            --3.处理最高价位
            For v_价位 In (Select /*+ rule */
                          a.Column_Value As 收费细目id, p.现价, p.收入项目id
                         From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                         Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                               Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1) Loop
              If Nvl(v_价位.现价, 0) > n_价格 Then
                n_价格       := Nvl(v_价位.现价, 0);
                n_Temp       := v_价位.收费细目id;
                n_收入项目id := v_价位.收入项目id;
              End If;
            End Loop;
          
            If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              n_开单部门id := v_Currrow.科室id;
              n_病人病区id := v_Currrow.病区id;
            
              For c_变动记录 In (Select 病区id, 科室id
                             From 病人变动记录
                             Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id + 0 = n_Temp And
                                   (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))
                             Order By 开始时间 Desc) Loop
                n_开单部门id := c_变动记录.科室id;
                n_病人病区id := c_变动记录.病区id;
                Exit;
              End Loop;
            
              --4. 不等的话,需要重新处理相关费用
              For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                           From Dual
                           Union All
                           Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                           From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                           Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                 d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate)) Loop
                --确定比例
                Begin
                  Select 实收比率
                  Into n_Exsetax_Temp
                  From (Select 实收比率
                         From 费别明细
                         Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                               (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                         Union All
                         Select 实收比率
                         From 费别明细
                         Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                               (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                          (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                Exception
                  When Others Then
                    n_Exsetax_Temp := 100.00;
                End;
                n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                --如果已经计算，原记录计算完全正确，则直接修改将标志改正
                Update 住院费用记录
                Set 附加标志 = 0
                Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And
                      Nvl(加班标志, 0) = v_Currrow.附加床位 And 病人科室id = Nvl(n_开单部门id, 0) And 病人病区id = Nvl(n_病人病区id, 0) And
                      Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And 收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And
                      发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And 标准单价 = v_费用.单价 And
                      应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                      实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
              
                If Sql%RowCount = 0 Then
                  --如果未计算或计算错误，则增加正确的计算记录
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                     姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                     收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                    Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                           Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, n_病人病区id, n_开单部门id,
                           n_开单部门id, n_病人病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                           v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1, v_费用.数量 * n_Dates,
                           Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                           Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                           j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                           Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                           Decode(v_Currrow.算法, 1,
                                   Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                   v_Currrow.统筹比额, 0), n_医疗小组id
                    From (Select 类别, 计算单位
                           From 收费细目
                           Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                         (Select 收据费目
                           From 收入项目
                           Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                  n_Billcount := n_Billcount + Sql%RowCount;
                End If;
                n_护理已处理 := 1;
              End Loop;
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(n_护理已处理, 0) = 0 Then
        --如果已经计算，原记录计算完全正确，则直接修改将标志改正
        Update 住院费用记录
        Set 附加标志 = 0
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And
              Nvl(加班标志, 0) = v_Currrow.附加床位 And 病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And
              Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And 收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And
              发生时间 = d_发生时间 And 数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
              应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
              实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
      
        If Sql%RowCount = 0 Then
          --如果未计算或计算错误，则增加正确的计算记录\
          Insert Into 住院费用记录
            (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
             年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
             操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
            Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                   Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                   v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                   v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1, v_Currrow.数量 * n_Dates,
                   Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                   Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                   j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                   Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                   Decode(v_Currrow.算法, 1,
                           Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                           2, v_Currrow.统筹比额, 0), n_医疗小组id
            From (Select 类别, 计算单位
                   From 收费细目
                   Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                 (Select 收据费目
                   From 收入项目
                   Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
        
          n_Billcount := n_Billcount + Sql%RowCount;
        End If;
      End If;
    End Loop;
  End Loop;

  If n_Do = 0 Then
    --撤销出院后,如果修改出院时间为入院当天则不产生新费用,但以前的费用要冲销
    Begin
      Select Trunc(b.上次计算时间)
      Into d_Datelast
      From 病人变动记录 A, 病人变动记录 B
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.终止原因 = 1 And a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 = 1 And
            Trunc(b.开始时间) = Trunc(a.终止时间) And a.附加床位 = 0 And b.附加床位 = 0;
    Exception
      When Others Then
        Null;
    End;
    If d_Datelast Is Not Null Then
      d_Datefrom := d_Datelast;
      d_Dateto   := Sysdate;
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= d_Datefrom;
    End If;
  End If;

  -----------------------------------------------------------------
  --作废以前计算的错误记录
  -----------------------------------------------------------------
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --填写病人余额
  -----------------------------------------------------------------
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Datefrom);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  -----------------------------------------------------------------
  --填写病人汇总费用
  -----------------------------------------------------------------
  n_Delete := 0;
  For v_Currrow In v_Sumcur(v_Billno, d_Datefrom) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;

  -----------------------------------------------------------------
  --将所有修改的附加标志还原为正常标志
  -----------------------------------------------------------------
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --修改计算时间标志
  -----------------------------------------------------------------
  Update 病人变动记录
  Set 上次计算时间 = Least(d_Dateto, Decode(Sign(Trunc(Sysdate) - Nvl(终止时间, Trunc(Sysdate))), -1, Sysdate, Nvl(终止时间, Sysdate)))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Datefrom;
  Commit; --单个病人提交
End Zl1_Autocptone;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Function Zl_Eprsplit(p_String Varchar2, p_Separator Varchar2, p_Element Integer)
  Return Varchar2 As
  --实现VB的Split功能,返回在p_String中以p_Separator为分隔的第p_Element个元素串
  v_String Varchar2(32767);
Begin
  v_String := p_String || p_Separator;
  For I In 1 .. p_Element - 1 Loop
    v_String := Substr(v_String, Instr(v_String, p_Separator) + 1);
  End Loop;
  Return Substr(v_String, 1, Instr(v_String, p_Separator) - 1);
Exception
  When Others Then
    Return Null;
End Zl_Eprsplit;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表
(
  病人id_In In 病人医嘱记录.病人id%Type,
  主页id_In In 病人医嘱记录.主页id%Type
) Return Varchar2 Is
  v_Return Varchar2(4000);
  v_Temp   Varchar2(200);

  Cursor c_Reportlist Is
    Select * From( Select b.病历id||'' As ID, a.Id As Yzid, Decode(d.检查uid, Null, 0, 1) As Gp, a.医嘱内容 As Mc, c.保存人 As Bgr, c.完成时间 As Bgsj
      From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D
      Where a.病人id = 病人id_In And nvl(a.主页id,0) = 主页id_In And a.Id = b.医嘱id And b.病历id = c.Id And a.诊疗类别 = 'D' And 相关id Is Null And
            c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8)
    union all Select b.检查报告id||'' As ID, a.Id As Yzid, Decode(d.检查uid, Null, 0, 1) As Gp, a.医嘱内容 As Mc, c.最后编辑人 As Bgr, c.最后审核时间 As Bgsj
      From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D
      Where a.病人id = 病人id_In And nvl(a.主页id,0) = 主页id_In And a.Id = b.医嘱id And b.检查报告id = c.Id And a.诊疗类别 = 'D' And 相关id Is Null And
            c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8)
     ) Order By Bgsj Desc;
Begin
  For Row_Cols In c_Reportlist Loop
    Select '<FILE>' || '<ID>' || Row_Cols.Id || '</ID>' || '<YZID>' || Row_Cols.Yzid || '</YZID>' || '<GP>' ||
            Row_Cols.Gp || '</GP>' || '<MC>' || Row_Cols.Mc || '</MC>' || '<BGR>' || Row_Cols.Bgr || '</BGR>' ||
            '<BGSJ>' || Row_Cols.Bgsj || '</BGSJ>' || '</FILE>'
    Into v_Temp
    From Dual;

    v_Return := v_Return || v_Temp;
  End Loop;

  If v_Return <> ' ' Then
    v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
  End If;

  Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取报告提纲
(
  医嘱id_In In 病人医嘱报告.医嘱id%Type--体检一个医嘱对应一份报告
) Return Varchar2 Is
  v_报告提纲 Varchar2(1000);
  v_提纲内容 Varchar2(100);
  
  x_Content xmltype;
  n_NodeNum number(2);
  Xcdom            Xmldom.Domdocument;
  Section_List     Xmldom.Domnodelist;

  Cursor c_报告提纲 Is
    Select a.内容文本
    From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
    Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id And c.医嘱id = 医嘱id_In;
Begin
  Begin
    Select b.报告内容 Into x_Content From 病人医嘱报告 a, 影像报告记录 b Where a.医嘱id = 医嘱id_In And a.检查报告id = b.id; 
    
    Xcdom         := Xmldom.Newdomdocument(x_Content);
    Section_List  := Xmldom.Getelementsbytagname(Xcdom, 'section');
    n_NodeNum     := Xmldom.Getlength(Section_List);
    
    For i in 0..n_NodeNum-1 Loop
      v_提纲内容 := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, i)), 'title');
      
      If Nvl(v_提纲内容,' ') != ' ' Then
        v_报告提纲 := v_报告提纲 || '<split>' || v_提纲内容;
      End If;
    End Loop;
  Exception
    When Others Then
      For Row_Cols In c_报告提纲 Loop
        v_报告提纲 := '<split>' || Row_Cols.内容文本 || v_报告提纲;
      End Loop;
  End;
  
  Return(Substr(v_报告提纲, 8));
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告提纲;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2
) Return Xmltype
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
 Is
  File_Id Varchar2(32);
  Docxml  Xmltype;
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  n_Adviceid Number(18);
  v_Ftppath  Varchar2(200);
  
  n_Count    Number(1);
  --标记变量
  n_i        Number(2);
  n_Len      Number(3);
  n_width    Number(4);
  n_height   Number(4);
  v_id       Varchar2(100);
  v_Ftppath  Varchar2(200);
  v_title    Varchar2(100);
  v_Newline  Varchar2(2);
  v_Text     Varchar2(500);
  v_Name     Varchar2(100);
  
  x_Content       Xmltype;
  Section_Node    Xmldom.Domnode;
  Element_Node    Xmldom.Domnode;
  Xcdom           Xmldom.Domdocument;
  Node_List       Xmldom.Domnodelist;
  Section_List    Xmldom.Domnodelist;

  Function Getorigpic(Pic_Id In 电子病历记录.Id%Type) Return Xmltype Is
    --读取病历图形，以多个 <OrigPic>节点返回，每个节点<=2000长度
    l_Blob   Blob;
    v_Buffer Varchar2(32767);
    n_Amount Number := 2000;
    n_Offset Number := 1;
    Pos_In   Number := 0;
    Origpic  Xmltype;
    Origpics Xmltype;
  Begin
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = Pic_Id;
    While True Loop
      n_Offset := 1 + Pos_In * n_Amount;
      n_Amount := 2000;
      v_Buffer := '';
      Begin
        Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
      Exception
        When No_Data_Found Then
          Exit;
      End;

      If Length(v_Buffer) = 0 Then
        Exit;
      Else
        Select Xmlelement("OrigPic", Xmlattributes(Pos_In As "序号"), v_Buffer) Into Origpic From Dual;
      End If;
      Select Xmlconcat(Origpics, Origpic) Into Origpics From Dual;
      Pos_In := Pos_In + 1;
    End Loop;
    Return Origpics;
  End Getorigpic;
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';

  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    If File_Id Is Null Then
      Exit;
    Else
      --判断是新版报告还是老版报告,有记录则是新版报告
      Select Count(1) Into n_Count From 影像报告记录 a, 病人医嘱报告 b Where a.id= HexToRaw(File_Id) And a.id = b.检查报告id;
      
      If n_Count > 0 Then
        --开始某个文件读取
        Begin
          Select Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                            RawToHex(a.Id) As "文件ID")))
          Into Docxml
          From 影像报告记录 a, 病人医嘱记录 b Where a.id= HexToRaw(File_Id) And a.医嘱id = b.id;
        Exception
          --给定的文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml From Dual;

        --开始读取内容
        Select b.报告内容 Into x_Content From 影像报告记录 b Where b.id||'' = File_Id;
        
        Xcdom         := Xmldom.Newdomdocument(x_Content);
        
        n_i := -1;
        
        Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
        Section_Node := Xmldom.Item(Section_List, 0);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);

        For I In 0 .. n_Len - 1 Loop
          Element_Node      := Xmldom.Item(Node_List, I);
          
          v_Name            := Xmldom.getNodeName(Element_Node);
          v_Newline         := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');
          
          If v_Newline Is Null Then
            v_Newline := '1';
          End If;

          If v_Name = 'section' Then   --提纲
            v_title   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_id      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');
            
            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                                     Xmlelement("Compend", Xmlattributes(v_title As "Name", v_id As "ID")))
            Into Docxml From Dual;
          Elsif v_Name = 'utext' Then  --文本
            v_Text     := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
            
            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            End If;
          Elsif v_Name = 'element' Then --要素
            v_title     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Text      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                          Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') ;
            
            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(v_title As "Name", v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Element", Xmlattributes(v_title As "Name", v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            End If;
          Elsif v_Name = 'image' Then  --图片
            n_width     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
            n_height    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
            v_Name      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');
            
            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(n_width       As "OrigWidth",
                                                                n_height     As "OrigHeight",
                                                                n_width      As "ShowWidth",
                                                                n_height     As "ShowHeight",
                                                                v_Name       As "PicName",
                                                                n_Adviceid   As "AdviceID")))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(n_width       As "OrigWidth",
                                                                n_height     As "OrigHeight",
                                                                n_width      As "ShowWidth",
                                                                n_height     As "ShowHeight",
                                                                v_Name       As "PicName",
                                                                n_Adviceid   As "AdviceID")))
              Into Docxml From Dual;
            End If;
          Elsif v_Name = 'signature' Then --签名
            v_Text     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');
            
            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"),
                                                 Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"),
                                                 Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml From Dual;
            End If;
          End If;
        End Loop;
      Else
        --开始某个病历文件读取
        Begin
          Select Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                            a.Id As "文件ID")))
          Into Docxml
          From 电子病历记录 A, 病人信息 B
          Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;
        Exception
          --给定的病历文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;
        
        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(null, 0) As "NewLine"), '内容文本'))
              Into Docxml
              From Dual;

        For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                   From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                          From 电子病历内容
                          Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
                   Start With 父id Is Null
                   Connect By Prior ID = 父id
                   Order Siblings By 对象序号, 内容行次) Loop
          If Rs.对象类型 = 1 Then
            --提纲
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 2 Then
            --文本
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 3 Then
            --表格
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;

            ---对表格的单元格进行填充
            For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                            From 电子病历内容
                            Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                            Order By 内容行次, ID) Loop
              If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
                If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
                  --兼容历史病历
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                Else
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;

                If Nvl(n_Adviceid, 0) = 0 Then
                  n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                        ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                        Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
                --制作标记子节点集
                v_Mark  := '';
                Makxml  := Null;
                Maksxml := Null;
                For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                                From 电子病历内容
                                Where 父id = Rs_Cell.Id
                                Order By 内容行次) Loop
                  v_Marks := v_Mark || Rs_Mark.内容文本;
                  v_Marks := Replace(v_Marks, '||', '^');
                  For I In 1 .. 100 Loop
                    v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                    If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                      --最后一个标记信息不全，存在下一行中
                      Exit;
                    Else
                      Select Xmlelement("Mark",
                                         Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                    Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                    Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                    Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                    Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                    Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                    Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                    Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                    Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                      Into Makxml
                      From Dual;
                      Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                    End If;
                  End Loop;
                End Loop;
                --向Picture插入标记子节点
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                       Maksxml)
                Into Docxml
                From Dual;
              End If;
            End Loop;
          Elsif Rs.对象类型 = 4 Then
            --要素
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
            --图片
            /*Picxml := Getorigpic(Rs.Id);--由Webservice直接读取BLOB之后直接写文件以提高速度*/
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            End If;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式", Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                Zl_Eprsplit(v_Mark, '|', 12) As "字体色", Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                Zl_Eprsplit(v_Mark, '|', 14) As "线宽", Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          Elsif Rs.对象类型 = 7 Then
            --诊断
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 8 Then
            --签名
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      End If;
    End If;

    For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
               From 影像检查记录 L, 影像设备目录 A1
               Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop

      Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                             Xmlelement("FtpPath", '', Aa.v_Ftppath))
      Into Docxml
      From Dual;
    End Loop;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取提纲内容
(
  医嘱id_In   In 病人医嘱报告.医嘱id%Type,
  报告提纲_In In 电子病历内容.内容文本%Type
) Return Varchar2 Is
  x_Content        xmltype;
  Xcdom            Xmldom.Domdocument;
  Section_List     Xmldom.Domnodelist;
  Section_Node     Xmldom.Domnode;
  Node_List        Xmldom.Domnodelist;
  n_Len            Number;
  Element_Node     Xmldom.Domnode;
  p_Node           Xmldom.Domnode;
  Enum_Node        Xmldom.Domnode;
  e_Node           Xmldom.Domnodelist;
  c_Node           Xmldom.Domnode;
  Enumeration_List Xmldom.Domnodelist;
  Enumeration_Node Xmldom.Domnode;
  Item_List        Xmldom.Domnodelist;
  Item_Node        Xmldom.Domnode;
  Item_Node1       Xmldom.Domnode;
  v_Name           Varchar2(100);
  v_Result         Varchar2(4000);
  n_i              Number;
  n_Num            Number;
  n_j              Number;
  n_Enum           Number;
  v_Val            Varchar2(20);
  v_Content        Varchar2(4000);
  v_Eleid          Varchar2(50);
  v_Multisel       Varchar2(10);
Begin
  v_Result := '';
  
  Begin
    Select b.报告内容 Into x_Content From 病人医嘱报告 a, 影像报告记录 b Where a.医嘱id = 医嘱id_In And a.检查报告id = b.id; 
    Select Deletexml(x_Content, '//image') Into x_Content From Dual;

    Xcdom := Xmldom.Newdomdocument(x_Content);

    For Myrow In (Select Column_Value Name From Table(f_Str2list(报告提纲_In))) Loop
      n_i := -1;
      --循环提纲名称
      Section_List := Xmldom.Getelementsbytagname(Xcdom, 'section');
      n_Len        := Xmldom.Getlength(Section_List);
        
      For I In 0 .. n_Len - 1 Loop
        If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, I)), 'title') = Myrow.Name Then
          n_i := I;
          Exit;
        End If;
      End Loop;
        
      If n_i >= 0 Then
        Section_Node := Xmldom.Item(Section_List, n_i);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);
          
        For I In 0 .. n_Len - 1 Loop
          Element_Node := Xmldom.Item(Node_List, I);
          v_Name       := Xmldom.Getnodename(Element_Node);
            
          If v_Name = 'element' Then
            If Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') Is Not Null Then
              v_Content := Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node));
                
              If Instr(v_Content, 'textstyleno') > 0 Then
                v_Content := '';
              End If;
              --如果有单位
              v_Result := v_Result || v_Content || Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
            Else
              p_Node := Xmldom.Getparentnode(Element_Node);
              If Xmldom.Getnodename(p_Node) <> 'enumvalues' Then
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node));
              End If;
            End If;
          Elsif v_Name = 'utext' Then
            v_Result := v_Result || LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          Elsif v_Name = 'e_list' Or v_Name = 'e_enum' Or v_Name = 'e_etree' Or v_Name = 'e_utree' Then
            Enumeration_List := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumeration');
            n_Num            := Xmldom.Getlength(Enumeration_List);
              
            If v_Name = 'e_enum' And n_Num > 0 Then
              For J In 0 .. n_Num - 1 Loop
                Enumeration_Node := Xmldom.Item(Enumeration_List, J);
                Item_List        := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'item');
                n_j              := Xmldom.Getlength(Item_List);

                For K In 0 .. n_j - 1 Loop
                  Item_Node := Xmldom.Item(Item_List, K);
                  If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'checked') = '1' Then
                    v_Val := Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'val');

                    For Z In 0 .. n_j - 1 Loop
                      Item_Node1 := Xmldom.Item(Item_List, Z);
                      If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'val') = v_Val And
                         Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'issymbol') = '0' Then
                        v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Item_Node1));
                        Exit;
                      End If;
                    End Loop;
                  End If;
                End Loop;
              End Loop;
            Else
              --这里处理枚举有无的情况
              v_Eleid := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid'); --获取元素ID

              Select Extractvalue(b.值域描述, '/root/multisel')
              Into v_Multisel
              From 影像报告元素清单 A, 影像报告值域清单 B
              Where a.值域id = b.id And a.id = Hextoraw(v_Eleid);

              If v_Multisel = 2 And v_Name = 'e_enum' Then
                --为是否类型的枚举
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.getLastChild(Element_Node));
              Else
                Enum_Node := Xmldom.Item(Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumvalues'), 0);
                e_Node := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Enum_Node), 'element');
                n_Enum := Xmldom.Getlength(e_Node);

                For K In 0 .. n_Enum - 1 Loop
                  c_Node   := Xmldom.Item(e_Node, K);
                  v_Result := v_Result || Xmldom.Getattribute(Xmldom.Makeelement(c_Node), 'showtext');
                    
                  If K <> n_Enum - 1 Then
                    v_Result := v_Result || '、';
                  End If;
                End Loop;
              End If;
            End If;
          End If;
        End Loop;
      End If;
    End Loop;

    Xmldom.Freedocument(Xcdom);

    Return translate(v_Result,chr(13)||chr(10),',');
  Exception
    When Others Then
      Begin
        Select b.内容文本 Into v_Result From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
        Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id
        And c.医嘱id = 医嘱id_In And a.内容文本 = 报告提纲_In;
        
        Return v_Result;
      Exception
        When Others Then
         Return '';
      End;
  End;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取提纲内容;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Procedure Zl_影像报告查阅记录_Insert
(
  医嘱id_In 报告查阅记录.医嘱id%Type,
  报告id_In Varchar2
  --功能：当前人员查阅报告时填写记录
) Is
  v_Temp     Varchar2(255);
  v_人员姓名 报告查阅记录.查阅人%Type;
Begin
  --当前操作人员
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  If Length(报告id_In) = 32 Then
    Update 病人医嘱报告 Set 查阅状态 = 1 Where 医嘱id = 医嘱id_In And 检查报告ID = 报告id_In;

    Update 报告查阅记录
    Set 查阅时间 = Sysdate, 查阅次数 = Nvl(查阅次数, 0) + 1, 取消时间 = Null
    Where 医嘱id = 医嘱id_In And 检查报告ID = 报告id_In And 查阅人 = v_人员姓名;

    If Sql%RowCount = 0 Then
      Insert Into 报告查阅记录
        (医嘱id, 检查报告ID, 查阅人, 查阅时间, 查阅次数)
      Values
        (医嘱id_In, 报告id_In, v_人员姓名, Sysdate, 1);
    End If;
  Else
    Update 病人医嘱报告 Set 查阅状态 = 1 Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In;

    Update 报告查阅记录
    Set 查阅时间 = Sysdate, 查阅次数 = Nvl(查阅次数, 0) + 1, 取消时间 = Null
    Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In And 查阅人 = v_人员姓名;

    If Sql%RowCount = 0 Then
      Insert Into 报告查阅记录
        (医嘱id, 病历ID, 查阅人, 查阅时间, 查阅次数)
      Values
        (医嘱id_In, 报告id_In, v_人员姓名, Sysdate, 1);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像报告查阅记录_Insert;
/

--84958:许华峰,2015-07-01,PACS依赖性接口封装
CREATE OR REPLACE Procedure Zl_影像报告查阅记录_Cancel
(
  医嘱id_In   报告查阅记录.医嘱id%Type,
  报告id_In   Varchar2,
  人员姓名_In 人员表.姓名%Type
  --功能：a.人员姓名_in=当前操作员,当前人员取消查阅报告时
  --     b.人员姓名_in=Null,修改报告后,取消所有人员的查阅,并更新查阅状态
) Is
  v_Count Number;
Begin
  If Length(报告id_In) = 32 Then
    If 人员姓名_In Is Null Then
      Update 报告查阅记录 Set 取消时间 = Sysdate Where 医嘱id = 医嘱id_In And 检查报告id = 报告id_In And 取消时间 Is Null;
      Update 病人医嘱报告 Set 查阅状态 = 0 Where 医嘱id = 医嘱id_In And 检查报告id = 报告id_In;
    Else
      --当前操作人员
      Update 报告查阅记录
      Set 取消时间 = Sysdate
      Where 医嘱id = 医嘱id_In And 检查报告id = 报告id_In And 查阅人 = 人员姓名_In And 取消时间 Is Null;

      Select Count(*)
      Into v_Count
      From 报告查阅记录
      Where 医嘱id = 医嘱id_In And 检查报告id = 报告id_In And 取消时间 Is Null;
      If Nvl(v_Count, 0) = 0 Then
        Update 病人医嘱报告 Set 查阅状态 = 0 Where 医嘱id = 医嘱id_In And 检查报告id = 报告id_In;
      End If;
    End If;
  Else
    If 人员姓名_In Is Null Then
      Update 报告查阅记录 Set 取消时间 = Sysdate Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In And 取消时间 Is Null;
      Update 病人医嘱报告 Set 查阅状态 = 0 Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In;
    Else
      --当前操作人员
      Update 报告查阅记录
      Set 取消时间 = Sysdate
      Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In And 查阅人 = 人员姓名_In And 取消时间 Is Null;

      Select Count(*)
      Into v_Count
      From 报告查阅记录
      Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In And 取消时间 Is Null;
      If Nvl(v_Count, 0) = 0 Then
        Update 病人医嘱报告 Set 查阅状态 = 0 Where 医嘱id = 医嘱id_In And 病历ID = 报告id_In;
      End If;
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像报告查阅记录_Cancel;
/

--84257:许华峰,2015-05-18,撤销关联
CREATE OR REPLACE Procedure Zl_影像检查_撤销关联
( 
  医嘱ID_In     影像检查记录.医嘱ID%Type, 
  图像UID_In    影像检查图象.图像UID%Type, 
  新检查UID_In  影像检查记录.检查UID%Type, 
  设备号_IN     影像检查记录.位置一%Type, 
  接收日期_In   影像检查记录.接收日期%Type 
) is 
  v_SeriesUid 影像检查序列.序列UID%Type; 
  v_StudyUid  影像检查记录.检查UID%Type; 
 
  v_Error      Varchar2(255); 
  v_rowcount    Number; 
  Err_Custom Exception; 
  Cursor c_ImageNo is Select 图像号 From 影像临时图象 Where 序列UID=v_SeriesUid Order By 图像号;
  i Number;
  j Number;
begin 
 
  Select Count(*) Into v_rowcount From 影像检查记录 Where 医嘱id = 医嘱id_In; 
  If v_rowcount = 0 Then 
    v_Error := '该检查未正常开始，请取消后重新开始。'; 
    Raise Err_Custom; 
  End If; 
 
  select 检查UID into v_StudyUid from 影像检查记录 where 医嘱ID=医嘱ID_In; 
  select 序列UID into v_SeriesUid from 影像检查图象 where 图像UID=图像UID_In; 
  
  --将检查记录插入临时库中 
  insert into 影像临时记录(影像类别,检查号,姓名,英文名,性别,年龄,出生日期,身高,体重, 
                           病理检查,发放胶片,检查UID,位置一,位置二,位置三,检查设备,报告图象,接收日期) 
      select 影像类别,检查号,姓名,英文名,性别,年龄,出生日期,身高,体重, 
             病理检查,发放胶片,新检查UID_In,设备号_IN,位置二,位置三,检查设备,'',接收日期_In 
      from 影像检查记录 
      where 医嘱ID=医嘱ID_In and not exists( select 1 from  影像临时序列 a,影像临时记录 b 
      where a.检查UID = b.检查uid and a.序列UID=v_SeriesUid) and not exists
      (select 1 from 影像临时记录 where 检查UID =  新检查UID_In); 
 
  --将检查序列插入临时库中 
  insert into 影像临时序列(序列uid, 检查uid, 序列号, 序列描述, 采集时间) 
      select 序列uid, 新检查UID_In, 序列号, 序列描述, 采集时间 
      from 影像检查序列 
      where 序列uid = v_SeriesUid and not exists (select 1 from 影像临时序列 where 序列UID=v_SeriesUid); 
 
  --获取图像号
  i:=1;
  j:=0;
  For r_ImageNo In c_ImageNo Loop
      If i<>r_ImageNo.图像号 Then
        j:=i;
        Exit;
      End If;
      
      i:=i+1;
  End Loop;
  
  If j=0 Then
    j:=i;
  End If;
  
  --将检查图像插入临时库中 
  insert into 影像临时图象(图像uid, 序列uid, 图像号, 图像描述, 采集时间, 图像时间, 层厚, 图像位置病人, 图像方向病人, 参考帧uid, 切片位置, 行数, 列数, 像素距离, 动态图) 
      select 图像uid, 序列uid, j, 图像描述, 采集时间, 图像时间, 层厚, 图像位置病人, 图像方向病人, 参考帧uid, 切片位置, 行数, 列数, 像素距离, 动态图 
      from 影像检查图象 
      where 图像UID=图像UID_In and not exists (select 1 from 影像临时图象 where 图像UID=图像UID_In); 
 
  delete from 影像检查图象 where 图像UID=图像UID_In; 
  delete from 影像检查序列 where 序列UID=v_SeriesUid and not exists(select 1 from 影像检查图象 where 序列UID=v_SeriesUid); 
 
  update 影像检查记录 
  set 检查UID='', 位置一='',位置二='',位置三='',报告图象='', 接收日期='' 
  where 医嘱ID= 医嘱ID_In and not exists(select 1 from 影像检查序列 where 检查UID=v_StudyUid); 
 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
end Zl_影像检查_撤销关联;
/

--86418:刘尔旋,2015-07-13,就诊详情附医嘱不包含治疗
--84843:刘尔旋,2015-05-14,医嘱对应多条病人医嘱报告服务窗接口调整
Create Or Replace Procedure Zl_Third_Getvisitinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:根据挂号单号获取该次就诊详情(医嘱为主要显示)
  --入参:Xml_In:
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --    <JSKLB>结算卡类别</JSKLB>
  --    <MXGL>明细过滤</MXGL> 0-不过滤,明细包含治疗 1-过滤,明细不包含治疗,默认为1
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <GH>
  --     <YYSJ>预约时间</YYSJ> //yyyy-mm-dd hh24:mi:ss
  --     <JZSJ></JZSJ>      //实际就诊时间
  --     <DJH></DJH>        //单据号
  --     <JE></JE>          //金额
  --     <DJLX></DJLX>      //单据类型,1-收费单，4-挂号单
  --     <KDSJ></KDSJ>      //开单时间
  --     <ZFZT></ZFZT>  //支付状态,0-待支付，1-已支付，2-已退费
  --     <SFJSK></SFJSK>    //是否结算卡支付，0-否，1-是
  --  </GH>
  --  <YZLIST>
  --     <YZ>                   //医嘱返回与HIS中显示的内容相同
  --        <YZID><YZID>        //医嘱ID，返回组医嘱ID
  --        <YZLX><YZLX>        //医嘱类型,如处方、检查、检验
  --         <YZMC></YZMC>        //医嘱名称
  --        <ZXKS></ZXKS>       //执行科室
  --        <ZXKSID></ZXKSID>   //执行科室ID
  --        <YZMX>
  --           <MX>
  --              <YZNR></YZNR>        //医嘱内容
  --              <ZXZT></ZXZT>        //医嘱执行状态
  --              <SFFY>是否发药</SFFY> // 0-否 ，1-是
  --              <GG>规格</GG>
  --              <SL>数量</SL>
  --              <DW>计算单位</DW>
  --              <BZDJ>标准单价</BZDJ>
  --              <YSJE>应收金额</YSJE>
  --              <SSJE>实收金额</SSJE>
  --           </MX>
  --           <MX/>
  --        </YZMX>
  --        <BG></BG>                   //是否已出报告，是否签名
  --        <BLID></BLID>              //病历ID，如果<BG>字段为1，该值不为空
  --        <DJLIST>
  --           <DJ>                //费用单据信息
  --              <DJH></DJH>      //费用单据号
  --              <DJLX></DJLX>    //单据类型
  --              <JE></JE>        //单据总金额
  --              <KDSJ></KDSJ>    //开单时间
  --              <ZFZT></ZFZT>    //支付状态,0-待支付，1-已支付，2-已退费
  --              <SFJSK></SFJSK>  //是否结算卡支付，0-否，1-是
  --           </DJ>
  --           <DJ/>
  --        </DJLIST>
  --     </YZ>
  --  </YZLIST>
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);
  v_队列名称 排队叫号队列.队列名称%Type;

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  n_Add_Djlist Number(1); --是否增加了DJLIST的
  n_性质       Number(2);
  n_组医嘱id   Number(18);
  n_独立医嘱   Number(8);
  n_执行科室id Number(18);
  v_执行科室   Varchar2(50);
  n_退款金额   病人预交记录.冲预交%Type;
  n_明细过滤   Number(3);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/MXGL')
  Into v_挂号单, v_卡类别, n_明细过滤
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  If n_明细过滤 Is Null Then
    n_明细过滤 := 1;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  n_性质 := 4;
  --1.获取挂号数据
  Begin
    Select Replace(摘要, '划价:', '') Into v_No From 病人挂号记录 Where NO = v_挂号单;
  Exception
    When Others Then
      v_No := Null;
  End;

  If v_No Is Not Null Then
    Select Count(*) Into n_Count From 门诊费用记录 Where NO = v_No And 记录性质 = 1;
    If n_Count <> 0 Then
      n_性质 := 1;
    End If;
  End If;
  If n_性质 = 4 Then
    v_No := v_挂号单;
  End If;

  n_Count := 0;
  For c_挂号 In (Select a.Id, v_No As NO, n_性质 As 记录性质, a.执行部门id, c.名称 As 执行部门,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, To_Char(a.预约时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi:ss') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志, b.结帐id As 结帐id
               From 病人挂号记录 A,
                    (Select Max(Decode(记录状态, 0, 0, 2, 0, Nvl(结帐id, 0))) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = n_性质 And NO = v_No) B, 部门表 C
               Where a.No = v_挂号单 And a.执行部门id = c.Id(+)) Loop
  
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
  
    Begin
      Select 排队号码, 队列名称
      Into v_排队号码, v_队列名称
      From 排队叫号队列
      Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码, v_队列名称);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where 结帐id = c_挂号.结帐id And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    v_Temp := '<DJH>' || c_挂号.No || '</DJH>';
    v_Temp := v_Temp || '<YYSJ>' || c_挂号.预约时间 || '</YYSJ>';
    v_Temp := v_Temp || '<JZSJ>' || c_挂号.就诊时间 || '</JZSJ>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<JE>' || c_挂号.金额 || '</JE>';
    v_Temp := v_Temp || '<DJLX>' || n_性质 || '</DJLX>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
    v_Temp := '<GH>' || v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;

  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.组建医嘱及费用相关数据
  n_组医嘱id := 0;

  For c_医嘱 In (With 医嘱费用 As
                  (Select 医嘱id, 发送号, 记录性质, NO, Max(Nvl(执行状态, 0)) As 执行状态
                  From (Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(b.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+)
                         Union All
                         Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(c.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱附费 B, 病人医嘱发送 C
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+) And b.医嘱id = c.医嘱id(+) And b.发送号 = c.发送号(+))
                  Group By 医嘱id, 发送号, 记录性质, NO)
                 
                 Select Nvl(a.相关id, a.Id) As 组id, Decode(a.相关id, Null, 0, 1) As 附医嘱, a.Id, a.相关id,
                        Max(Decode(a.诊疗类别, 'E', Decode(q.操作类型, '2', '处方', '4', '处方', '6', '检验', m.名称), m.名称)) As 医嘱类型,
                        a.执行科室id, d.名称 As 执行科室, Decode(a.相关id, Null, a.医嘱内容, Null) As 组医嘱内容,
                        Max(Decode(a.诊疗类别, '5', 1, '6', 1, '7', 1, 0) * Decode(Nvl(e.执行状态, 0), 1, 1, 3, 1, 0)) As 发药状态,
                        Decode(a.相关id, Null, Null, q.名称) As 明细医嘱内容, s.规格, (e.数次 * e.付数) As 数量, e.计算单位 As 单位,
                        Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行') As 执行状态,
                        Max(Decode(p.审核时间, Null, Decode(C1.完成时间, Null, 0, 1), 1)) As 是否已出报告, c.病历id, e.No, e.记录性质 As 单据类型,
                        Max(e.标准单价) As 标准单价, Sum(e.应收金额) As 应收金额, Sum(e.实收金额) As 实收金额,
                        To_Char(e.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1) As 支付状态

                 
                 From 病人医嘱记录 A, 医嘱费用 B, 病人医嘱报告 C, 电子病历记录 C1, 部门表 D, 门诊费用记录 E, 诊疗项目类别 M, 诊疗项目目录 Q, 收费项目目录 S, 检验标本记录 P
                 Where a.Id = b.医嘱id(+) And a.执行科室id = d.Id(+) And c.病历id = C1.Id(+) And a.Id = c.医嘱id(+) And
                       a.Id = p.医嘱id(+) And b.医嘱id = e.医嘱序号(+) And e.收费细目id = s.Id(+) And b.No = e.No(+) And
                       b.记录性质 = e.记录性质(+) And e.记录状态(+) <> 2 And a.挂号单 = v_挂号单 And a.诊疗类别 = m.编码(+) And
                       a.诊疗项目id = q.Id(+) And a.医嘱状态 In (3, 8)
                 Group By a.Id, a.婴儿, a.序号, a.相关id, a.诊疗类别, a.执行科室id, d.名称, a.医嘱内容, q.名称, s.规格, e.数次 * e.付数, e.计算单位,
                          Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行'), C1.完成时间,
                          Decode(c.病历id, Null, 0, 1), c.病历id, e.No, e.记录性质, e.发生时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1),
                          p.审核时间
                 Order By 组id, 附医嘱, Nvl(a.婴儿, 0), a.序号) Loop
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZLIST></YZLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
  
    If n_组医嘱id <> Nvl(c_医嘱.组id, 0) Then
      n_组医嘱id := Nvl(c_医嘱.组id, 0);
    
      If c_医嘱.医嘱类型 = '检验' Then
        --检验医嘱以显示采集科室
        n_执行科室id := c_医嘱.执行科室id;
        v_执行科室   := c_医嘱.执行科室;
      Else
        Begin
          Select b.Id, b.名称
          Into n_执行科室id, v_执行科室
          From 病人医嘱记录 A, 部门表 B
          Where a.相关id = n_组医嘱id And a.执行科室id = b.Id And Rownum <= 1;
        Exception
          When Others Then
            n_执行科室id := c_医嘱.执行科室id;
            v_执行科室   := c_医嘱.执行科室;
        End;
      End If;
    
      v_Temp := '<YZID>' || n_组医嘱id || '</YZID>';
      v_Temp := v_Temp || '<YZLX>' || c_医嘱.医嘱类型 || '</YZLX>';
      v_Temp := v_Temp || '<YZMC>' || c_医嘱.组医嘱内容 || '</YZMC>';
      v_Temp := v_Temp || '<ZXKS>' || v_执行科室 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || n_执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<BG>' || c_医嘱.是否已出报告 || '</BG>';
      If Nvl(c_医嘱.是否已出报告, 0) = 1 And c_医嘱.病历id Is Not Null Then
        v_Temp := v_Temp || '<BLID>' || c_医嘱.病历id || '</BLID>';
      End If;
      v_Temp := '<YZ 医嘱ID="' || n_组医嘱id || '">' || v_Temp || '<YZMX></YZMX><DJLIST></DJLIST></YZ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    
      For v_费用 In (
                   
                   Select a.No, Mod(a.记录性质, 10) As 单据类型, To_Char(a.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间,
                           Max(Decode(Nvl(a.记录状态, 0), 0, 0, 3, 2, 1)) As 支付状态, Sum(a.实收金额) As 单据金额, Max(a.结帐id) As 结算卡支付
                   From 门诊费用记录 A
                   Where (a.No, a.记录性质) In
                         (Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱发送 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)
                          Union All
                          Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱附费 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)) And
                         Nvl(a.记录状态, 0) In (0, 1, 3)
                   Group By a.No, Mod(a.记录性质, 10), To_Char(a.发生时间, 'yyyy-mm-dd hh24:mi:ss')) Loop
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
        Begin
          Select -1 * Sum(结帐金额)
          Into n_退款金额
          From 门诊费用记录 B
          Where b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 = 2;
        Exception
          When Others Then
            n_退款金额 := 0;
        End;
      
        v_Temp := '<DJH>' || v_费用.No || '</DJH>';
        v_Temp := v_Temp || '<DJLX>' || v_费用.单据类型 || '</DJLX>';
        v_Temp := v_Temp || '<JE>' || v_费用.单据金额 || '</JE>';
        v_Temp := v_Temp || '<KDSJ>' || v_费用.开单时间 || '</KDSJ>';
        v_Temp := v_Temp || '<ZFZT>' || v_费用.支付状态 || '</ZFZT>';
        v_Temp := v_Temp || '<YTJE>' || Nvl(n_退款金额, 0) || '</YTJE>';
        v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
        v_Temp := '<DJ>' || v_Temp || '</DJ>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/DJLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End Loop;
    End If;
  
    --只有一条记录的医嘱，在明细中增加该条医嘱，以获取执行状态
    Select Decode(Count(*), 0, 1, 0) Into n_独立医嘱 From 病人医嘱记录 Where 相关id = n_组医嘱id;
    If n_独立医嘱 = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.组医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
    If Nvl(c_医嘱.附医嘱, 0) = 1 Then
      If n_明细过滤 = 0 Or (n_明细过滤 = 1 And c_医嘱.医嘱类型 <> '治疗') Then
        v_Temp := '<YZNR>' || c_医嘱.明细医嘱内容 || '</YZNR>';
        v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
        v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
        v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
        v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
        v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
        v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
        v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
        v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
        v_Temp := '<MX>' || v_Temp || '</MX>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    End If;
  
  End Loop;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitinfo;
/

--84398:刘鹏飞,2015-05-12,门诊与住院病人合并住院次数处理
Create Or Replace Procedure Zl_病人信息_Merge
(
  A病人id_In    病人信息.病人id%Type, --要合并的病人信息
  B病人id_In    病人信息.病人id%Type, --要保留的病人信息
  合并原因_In   病人合并记录.合并原因%Type,
  操作员姓名_In 人员表.姓名%Type,
  强制保留_In   Number := 0
  --标准版
  ----------------------------------------------------------------------------
  --病人信息,病案主页,病案主页从表,病人变动记录,特殊病人
  --门诊病案记录,住院病案记录,床位状况记录
  --医保病人档案,保险模拟结算,保险结算记录,帐户年度信息
  --病人余额,病人未结费用,住院费用记录,门诊费用记录,病人预交记录,病人结帐记录,未发药品记录
  --病人挂号记录,病人过敏药物,病人过敏记录,病人诊断记录,诊断情况
  --病人医嘱记录,病人手麻记录
  --病人社区信息
  
  --后备表：
  --H病人结帐记录,H病人预交记录,H住院费用记录,H门诊费用记录
  --H病人医嘱记录,H病人诊断记录,H病人过敏记录
  --H病人病历记录,H病人手麻记录
  
  --病案系统
  ----------------------------------------------------------------------------
  --病人费用,随诊记录,借阅记录
  --新生儿诊断记录,病人分娩信息
  --诊断符合情况,病案评分结果
  
) As
  --病人相关表
  Cursor c_Patitable Is
    Select a.Table_Name, Max(Decode(b.Column_Name, '病人ID', 1, 0)) As 病人id,
           Max(Decode(b.Column_Name, '主页ID', 1, 0)) As 主页id
    From User_Tables a, User_Tab_Columns b
    Where a.Table_Name = b.Table_Name And b.Column_Name In ('病人ID', '主页ID') And
          a.Table_Name Not In ('病人信息',
                               '病案主页',
                               '病案主页从表',
                               '病人变动记录',
                               '特殊病人',
                               '门诊病案记录',
                               '住院病案记录',
                               '床位状况记录',
                               '医保病人档案',
                               '医保病人关联表',
                               '保险模拟结算',
                               '帐户年度信息',
                               '病人余额',
                               '病人未结费用',
                               '住院费用记录',
                               '门诊费用记录',
                               '病人预交记录',
                               '病人结帐记录',
                               '未发药品记录',
                               '病人挂号记录',
                               '病人过敏药物',
                               '病人过敏记录',
                               '病人诊断记录',
                               '诊断情况',
                               '病人医嘱记录',
                               '病人手麻记录',
                               '病人费用',
                               '随诊记录',
                               '借阅记录',
                               '病人分娩信息',
                               '诊断符合情况',
                               '病案评分结果',
                               '病人担保记录',
                               '病人社区信息',
                               '病人免疫记录',
                               '病人信息从表',
                               '病人医疗卡属性') Having Max(Decode(b.Column_Name, '病人ID', 1, 0)) <> 0
    Group By a.Table_Name;

  --数组定义
  Type Array_Patitable Is Table Of Varchar2(100) Index By Binary_Integer;
  Arronbase Array_Patitable;
  Arronpage Array_Patitable;
  v_Loop    Number;
  n_Have    Number;

  -------------------------------------------------------
  --被合并的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infoa Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 a, 病案主页 b
    Where a.病人id = b.病人id(+) And a.病人id = A病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infoa c_Infoa%Rowtype;

  --要保留的病人(住院号可能每次新产生,多次住院取最近一次)
  Cursor c_Infob Is
    Select a.病人id, a.门诊号, a.住院号, a.就诊卡号, a.卡验证码, a.费别, a.医疗付款方式, a.姓名, a.性别, a.年龄, a.出生日期, a.出生地点, a.身份证号, a.其他证件, a.身份,
           a.职业, a.民族, a.国籍, a.籍贯, a.区域, a.学历, a.婚姻状况, a.家庭地址, a.家庭电话, a.家庭地址邮编, a.监护人, a.联系人姓名, a.联系人关系, a.联系人地址,
           a.联系人电话, a.户口地址, a.户口地址邮编, a.Email, a.Qq, a.合同单位id, a.工作单位, a.单位电话, a.单位邮编, a.单位开户行, a.单位帐号, a.担保人, a.担保额,
           a.担保性质, a.就诊时间, a.就诊状态, a.就诊诊室, a.住院次数, a.当前科室id, a.当前病区id, a.当前床号, a.入院时间, a.出院时间, a.在院, a.Ic卡号, a.健康号,
           a.医保号, a.险类, a.查询密码, a.登记时间, a.停用时间, a.锁定, a.联系人身份证号, b.主页id, b.入院日期, b.出院日期
    From 病人信息 a, 病案主页 b
    Where a.病人id = b.病人id(+) And a.病人id = B病人id_In
    Order By 出院日期 Desc, 主页id Desc;
  r_Infob c_Infob%Rowtype;

  --合并后的信息
  Cursor c_Info(v_病人id 病人信息.病人id%Type) Is
    Select 病人id, 主页id, (Select Nvl(Max(主页id), 0) From 病案主页 Where 病人id = v_病人id) 最大主页id, 住院号, 病人性质, 医疗付款方式, 费别, 再入院,
           入院病区id, 入院科室id, 医疗小组id, 入院日期, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id, 护理等级id, 出院科室id, 出院病床,
           出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师, 责任护士, 住院医师, 病案号, 编目员编号, 编目员姓名,
           编目日期, 状态, 费用和, 年龄, 身高, 体重, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话, 家庭地址邮编, 联系人姓名, 联系人关系, 联系人地址,
           联系人电话, 联系人身份证号, 户口地址, 户口地址邮编, 中医治疗类别, 险类, 社区, 审核标志, 审核人, 审核日期, 是否上传, 数据转出, 登记人, 登记时间, 备注, 病案状态, 病人类型
    From 病案主页
    Where 主页id = (Select Nvl(Max(主页id), 0)
                  From 病案主页
                  Where 病人id = v_病人id And Not Exists (Select 主页id From 病案主页 Where 病人id = v_病人id And 主页id = 0)) And
          病人id = v_病人id;
  r_Info c_Info%Rowtype;

  --合并两个住院病人
  Cursor c_Mergepati Is
    Select a.姓名, a.门诊号, a.住院号 当前住院号, b.病人id, b.主页id, b.住院号, b.病人性质, b.医疗付款方式, b.费别, b.再入院, b.入院病区id, b.入院科室id, b.医疗小组id,
           b.入院日期, b.入院病况, b.入院方式, b.入院属性, b.二级院转入, b.住院目的, b.入院病床, b.是否陪伴, b.当前病况, b.当前病区id, b.护理等级id, b.出院科室id, b.出院病床,
           b.出院日期, b.住院天数, b.出院方式, b.是否确诊, b.确诊日期, b.新发肿瘤, b.血型, b.抢救次数, b.成功次数, b.随诊标志, b.随诊期限, b.尸检标志, b.门诊医师, b.责任护士,
           b.住院医师, b.病案号, b.编目员编号, b.编目员姓名, b.编目日期, b.状态, b.费用和, b.年龄, b.身高, b.体重, b.婚姻状况, b.职业, b.国籍, b.学历, b.单位电话,
           b.单位邮编, b.单位地址, b.区域, b.家庭地址, b.家庭电话, b.家庭地址邮编, b.联系人姓名, b.联系人关系, b.联系人地址, b.联系人电话, b.联系人身份证号, b.户口地址,
           b.户口地址邮编, b.中医治疗类别, b.险类, b.社区, b.审核标志, b.审核人, b.审核日期, b.是否上传, b.数据转出, b.登记人, b.登记时间, b.备注, b.病案状态, b.病人类型
    From 病人信息 a, 病案主页 b
    Where a.病人id = b.病人id And a.病人id In (A病人id_In, B病人id_In)
    Order By b.入院日期 Desc, Nvl(b.出院日期, Sysdate) Desc;

  v_保留id 病人信息.病人id%Type;
  v_合并id 病人信息.病人id%Type;
  v_门诊号 病人信息.门诊号%Type;
  v_住院号 病人信息.住院号%Type;
  --病人未结费用(门诊部份)
  Cursor c_Owe(v_病人id 病人信息.病人id%Type) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, Sum(金额) As 金额
    From 病人未结费用
    Where 主页id Is Null And 病人id = v_病人id
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径;

  --病人余额
  Cursor c_Spare(v_病人id 病人信息.病人id%Type) Is
    Select 性质, 类型, 预交余额, 费用余额 From 病人余额 Where 病人id = v_病人id;

  --医保病人档案
  Cursor c_Insure(v_病人id 病人信息.病人id%Type) Is
    Select * From 保险帐户 Where 病人id = v_病人id Order By 险类;

  --要保留的医保病人档案
  Cursor c_Keepinsure
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 保险帐户 Where 病人id = v_病人id And 险类 = v_险类;
  r_Keepinsure c_Keepinsure%Rowtype;

  Cursor c_Year
  (
    v_病人id 病人信息.病人id%Type,
    v_险类   医保病人档案.险类%Type
  ) Is
    Select * From 帐户年度信息 Where 病人id = v_病人id And 险类 = v_险类;

  v_原信息   病人合并记录.原信息%Type;
  v_Count    Number;
  n_Readonly Number;
  v_Sql      Varchar2(1000);

  n_主页id       病人信息.主页id%Type;
  v_Error        Varchar2(255);
  n_担保额       病人担保记录.担保额%Type;
  v_担保人       病人信息.担保人%Type;
  n_担保性质     病人担保记录.担保性质%Type;
  n_Row          Number;
  n_独立病案     Number;
  n_每次新住院号 Number;
  n_Max主页id    Number;
  n_Cnt主页id    Number;
  n_Cur主页id    Number;
  n_Cnt住院次数  Number;
  n_Cur住院次数  Number;
  n_Max住院次数  Number;
  n_Loop主页id   病人信息.主页id%Type;

  n_Lengthb Number;
  Err_Custom Exception;
Begin
  Begin
    Select 只读 Into n_Readonly From Zlbakspaces Where 当前 = 1;
  Exception
    When Others Then
      Null;
  End;
  If n_Readonly = 1 Then
    n_Readonly := 0;
    For r_Bak In (Select a.表名 Table_Name
                  From Zltools.Zlbaktables a, User_Constraints b
                  Where a.表名 = b.Table_Name And b.r_Constraint_Name = '病人信息_PK' And b.Constraint_Type = 'R') Loop
      v_Sql := 'Select Count(病人Id) From ' || r_Bak.Table_Name || ' Where 病人Id In(:1,:2)';
      Execute Immediate v_Sql
        Into n_Readonly
        Using A病人id_In, B病人id_In;
      If n_Readonly > 0 Then
        v_Error := '病人在只读的当前转储空间存在数据,不能进行合并!';
        Raise Err_Custom;
      End If;
    End Loop;
  End If;

  --程序中已检查：
  --1.选择了同一个病人
  --2.两个住院病人先入院的却在院(包括两个都在院)。
  --3.两个住院病人的住院期间存在交叉的情况
  --4.医保病人存在未结费用

  --先锁定病人不允许进行其他业务
  Zl_病人信息_锁定(A病人id_In, 1);
  Zl_病人信息_锁定(B病人id_In, 1);

  Open c_Infoa;
  Fetch c_Infoa
    Into r_Infoa;
  If c_Infoa%Rowcount = 0 Then
    Close c_Infoa;
    v_Error := '没有发现被合并的病人信息！';
    Raise Err_Custom;
  End If;

  Open c_Infob;
  Fetch c_Infob
    Into r_Infob;
  If c_Infob%Rowcount = 0 Then
    Close c_Infob;
    v_Error := '没有发现要保留的病人信息！';
    Raise Err_Custom;
  End If;

  --读取其它相关病人表到数组
  For r_Patitable In c_Patitable Loop
    If r_Patitable.主页id = 0 Then
      Arronbase(Arronbase.Count + 1) := r_Patitable.Table_Name;
    Else
      Arronpage(Arronpage.Count + 1) := r_Patitable.Table_Name;
    End If;
  End Loop;

  --以先住院或先登记的病人ID作为实际上要保留的病人ID
  If Nvl(强制保留_In, 0) = 1 Then
    v_保留id := B病人id_In;
  Else
    Select 病人id
    Into v_保留id
    From (Select /*+ CHOOSE */
            a.病人id
           From 病人信息 a, 病案主页 b
           Where a.病人id = b.病人id(+) And a.病人id In (A病人id_In, B病人id_In)
           Order By Nvl(b.入院日期, To_Date('3000-01-01', 'YYYY-MM-DD')), Nvl(b.出院日期, To_Date('3000-01-01', 'YYYY-MM-DD')),
                    a.登记时间, a.病人id --住院病人优先
           )
    Where Rownum = 1;
  End If;

  --先确定病案号的模式
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(39), '0')) Into n_独立病案 From Dual;
  --住院号模式
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(145), '0')) Into n_每次新住院号 From Dual;

  --另外一个就是实际最后要删除的病人ID
  If v_保留id = A病人id_In Then
    v_合并id := B病人id_In;
    --问题27445 保留指定病人的门诊号、住院号、医保号
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  Else
    v_合并id := A病人id_In;
    v_门诊号 := Nvl(r_Infob.门诊号, r_Infoa.门诊号);
    v_住院号 := Nvl(r_Infob.住院号, r_Infoa.住院号);
  End If;

  ---记录合并操作,在后面会根据r_PatiTable把合并病人的合并记录更新为保留病人的
  v_原信息 := v_合并id || ',' || r_Infoa.门诊号 || ',' || r_Infoa.住院号 || ',' || r_Infoa.就诊卡号 || ',' || r_Infoa.姓名 || ',' ||
           r_Infoa.性别 || ',' || r_Infoa.年龄 || ',' || To_Char(r_Infoa.出生日期, 'yyyy-mm-dd') || ',' || r_Infoa.身份证号 || ',' ||
           r_Infoa.婚姻状况 || ',' || r_Infoa.职业 || ',' || r_Infoa.家庭地址;
  Insert Into 病人合并记录
    (病人id, 原信息, 合并原因, 操作员姓名, 合并时间)
  Values
    (v_保留id, v_原信息, 合并原因_In, 操作员姓名_In, Sysdate);

  --开始合并
  --84398修改将住院次数计算放在外面，因需要考虑门诊和住院病人合并
  --10.34开始,住院次数不包含留关病人,合并后的住院次数=保留病人住院次数+合并病人正常入院的次数
  Select Nvl(住院次数, 0) Into n_Cur住院次数 From 病人信息 Where 病人id = v_保留id;
  Select Count(*) Into n_Cnt住院次数 From 病案主页 Where 病人id = v_合并id And 主页id <> 0 And 病人性质 = 0;
  n_Max住院次数 := n_Cur住院次数 + n_Cnt住院次数;
  --处理病案主页部份(涉及病人ID,主页ID字段的表)
  If (r_Infoa.主页id Is Not Null And r_Infob.主页id Is Not Null) Or (强制保留_In = 1 And r_Infoa.主页id Is Not Null) Then
    If r_Infoa.主页id = 0 And r_Infob.主页id = 0 Then
      Close c_Infoa;
      Close c_Infob;
      v_Error := '两个预约病人不能进行病人合并操作！';
      Raise Err_Custom;
    Elsif r_Infoa.主页id = 0 Then
      If r_Infob.入院日期 Is Not Null And r_Infob.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    Elsif r_Infob.主页id = 0 Then
      If r_Infoa.入院日期 Is Not Null And r_Infoa.出院日期 Is Null Then
        Close c_Infoa;
        Close c_Infob;
        v_Error := '预约病人和在院病人不能进行病人合并操作！';
        Raise Err_Custom;
      End If;
    End If;
    --求两个病人总共的住院就诊次数
    Select Count(*) Into v_Count From 病案主页 Where 病人id In (A病人id_In, B病人id_In) And 主页id <> 0;
    --因为10.19开始，入院时允许修改主页id，所以最大主页ID可能大于总的住院就诊次数
    Select Max(主页id) Into n_Max主页id From 病案主页 Where 病人id = v_保留id And 主页id <> 0;
    Select Count(*) Into n_Cnt主页id From 病案主页 Where 病人id = v_合并id And 主页id <> 0;
    If n_Max主页id + n_Cnt主页id > v_Count Then
      v_Count := n_Max主页id + n_Cnt主页id;
    End If;
    --求实际要更新的主页截至值,以前用v_Count >= n_Max主页id判断存在一个问题（对于两个病人多次交叉入院，可能导致A,B病人部分就诊次数没有更新）
    Select Nvl(Max(主页id), 0)
    Into n_Loop主页id
    From 病案主页 a, (Select Min(入院日期) 入院日期 From 病案主页 Where 病人id = v_合并id) b
    Where a.病人id = v_保留id And a.入院日期 < b.入院日期;
  
    For r_Merge In c_Mergepati Loop
      If Not (r_Merge.病人id = v_保留id And r_Merge.主页id = v_Count) And v_Count <> 0 Then
        --该病案主页要删除时,不能是已编目了的。
        If r_Merge.编目日期 Is Not Null Then
          Close c_Infoa;
          Close c_Infob;
          If r_Merge.当前住院号 Is Null Then
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ')存在已编目的病案,不允许合并该病人。';
          Else
            v_Error := '病人' || r_Merge.姓名 || '(病人ID=' || r_Merge.病人id || ',住院号=' || r_Merge.当前住院号 ||
                       ')存在已编目的病案,不允许合并该病人。';
          End If;
          Raise Err_Custom;
        End If;
        If v_Count >= Nvl(n_Loop主页id, 0) Then
          If r_Merge.主页id = 0 Then
            n_Cur主页id := 0;
            Update 病案主页
            Set 病人性质 = r_Merge.病人性质, 医疗付款方式 = r_Merge.医疗付款方式, 费别 = r_Merge.费别, 再入院 = r_Merge.再入院,
                入院病区id = r_Merge.入院病区id, 入院科室id = r_Merge.入院科室id, 入院日期 = r_Merge.入院日期, 入院病况 = r_Merge.入院病况,
                入院方式 = r_Merge.入院方式, 二级院转入 = r_Merge.二级院转入, 住院目的 = r_Merge.住院目的, 入院病床 = r_Merge.入院病床,
                是否陪伴 = r_Merge.是否陪伴, 当前病况 = r_Merge.当前病况, 当前病区id = r_Merge.当前病区id, 护理等级id = r_Merge.护理等级id,
                出院科室id = r_Merge.出院科室id, 出院病床 = r_Merge.出院病床, 出院日期 = r_Merge.出院日期, 住院天数 = r_Merge.住院天数,
                出院方式 = r_Merge.出院方式, 是否确诊 = r_Merge.是否确诊, 确诊日期 = r_Merge.确诊日期, 新发肿瘤 = r_Merge.新发肿瘤, 血型 = r_Merge.血型,
                抢救次数 = r_Merge.抢救次数, 成功次数 = r_Merge.成功次数, 随诊标志 = r_Merge.随诊标志, 随诊期限 = r_Merge.随诊期限, 尸检标志 = r_Merge.尸检标志,
                门诊医师 = r_Merge.门诊医师, 责任护士 = r_Merge.责任护士, 住院医师 = r_Merge.住院医师, 编目员编号 = r_Merge.编目员编号,
                编目员姓名 = r_Merge.编目员姓名, 编目日期 = r_Merge.编目日期, 状态 = r_Merge.状态, 费用和 = r_Merge.费用和, 年龄 = r_Merge.年龄,
                婚姻状况 = r_Merge.婚姻状况, 职业 = r_Merge.职业, 国籍 = r_Merge.国籍, 学历 = r_Merge.学历, 单位电话 = r_Merge.单位电话,
                单位邮编 = r_Merge.单位邮编, 单位地址 = r_Merge.单位地址, 区域 = r_Merge.区域, 家庭地址 = r_Merge.家庭地址, 家庭电话 = r_Merge.家庭电话,
                家庭地址邮编 = r_Merge.家庭地址邮编, 户口地址 = r_Merge.户口地址, 户口地址邮编 = r_Merge.户口地址邮编, 联系人姓名 = r_Merge.联系人姓名,
                联系人关系 = r_Merge.联系人关系, 联系人地址 = r_Merge.联系人地址, 联系人电话 = r_Merge.联系人电话, 中医治疗类别 = r_Merge.中医治疗类别,
                登记人 = r_Merge.登记人, 登记时间 = r_Merge.登记时间, 险类 = r_Merge.险类, 审核标志 = r_Merge.审核标志, 是否上传 = r_Merge.是否上传,
                备注 = r_Merge.备注, 数据转出 = r_Merge.数据转出, 病案号 = r_Merge.病案号,
                住院号 = Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)
            Where 病人id = v_保留id And 主页id = n_Cur主页id;
            If Sql%Rowcount = 0 Then
              Insert Into 病案主页
                (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
                 当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志,
                 门诊医师, 责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话,
                 家庭地址邮编, 户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出, 病案号, 住院号)
              Values
                (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id,
                 r_Merge.入院科室id, r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床,
                 r_Merge.是否陪伴, r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期,
                 r_Merge.住院天数, r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数,
                 r_Merge.成功次数, r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师,
                 r_Merge.编目员编号, r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.年龄, r_Merge.婚姻状况,
                 r_Merge.职业, r_Merge.国籍, r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域, r_Merge.家庭地址,
                 r_Merge.家庭电话, r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系, r_Merge.联系人地址,
                 r_Merge.联系人电话, r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志, r_Merge.是否上传,
                 r_Merge.备注, r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号));
            End If;
          Else
            n_Cur主页id := v_Count;
            Insert Into 病案主页
              (病人id, 主页id, 病人性质, 医疗付款方式, 费别, 再入院, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况,
               当前病区id, 护理等级id, 出院科室id, 出院病床, 出院日期, 住院天数, 出院方式, 是否确诊, 确诊日期, 新发肿瘤, 血型, 抢救次数, 成功次数, 随诊标志, 随诊期限, 尸检标志, 门诊医师,
               责任护士, 住院医师, 编目员编号, 编目员姓名, 编目日期, 状态, 费用和, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话, 家庭地址邮编,
               户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 中医治疗类别, 登记人, 登记时间, 险类, 审核标志, 是否上传, 备注, 数据转出, 病案号, 住院号)
            Values
              (v_保留id, n_Cur主页id, r_Merge.病人性质, r_Merge.医疗付款方式, r_Merge.费别, r_Merge.再入院, r_Merge.入院病区id, r_Merge.入院科室id,
               r_Merge.入院日期, r_Merge.入院病况, r_Merge.入院方式, r_Merge.二级院转入, r_Merge.住院目的, r_Merge.入院病床, r_Merge.是否陪伴,
               r_Merge.当前病况, r_Merge.当前病区id, r_Merge.护理等级id, r_Merge.出院科室id, r_Merge.出院病床, r_Merge.出院日期, r_Merge.住院天数,
               r_Merge.出院方式, r_Merge.是否确诊, r_Merge.确诊日期, r_Merge.新发肿瘤, r_Merge.血型, r_Merge.抢救次数, r_Merge.成功次数,
               r_Merge.随诊标志, r_Merge.随诊期限, r_Merge.尸检标志, r_Merge.门诊医师, r_Merge.责任护士, r_Merge.住院医师, r_Merge.编目员编号,
               r_Merge.编目员姓名, r_Merge.编目日期, r_Merge.状态, r_Merge.费用和, r_Merge.年龄, r_Merge.婚姻状况, r_Merge.职业, r_Merge.国籍,
               r_Merge.学历, r_Merge.单位电话, r_Merge.单位邮编, r_Merge.单位地址, r_Merge.区域, r_Merge.家庭地址, r_Merge.家庭电话,
               r_Merge.家庭地址邮编, r_Merge.户口地址, r_Merge.户口地址邮编, r_Merge.联系人姓名, r_Merge.联系人关系, r_Merge.联系人地址, r_Merge.联系人电话,
               r_Merge.中医治疗类别, r_Merge.登记人, r_Merge.登记时间, r_Merge.险类, r_Merge.审核标志, r_Merge.是否上传, r_Merge.备注,
               r_Merge.数据转出, r_Merge.病案号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号));
          End If;
        Else
          Exit;
        End If;
      
        --更新病人相关表的病人指向
        ---------------------------------------------------------------
        --病人变动记录
        Update 病人变动记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病案主页从表
        Update 病案主页从表
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --住院费用记录
        Update 住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H住院费用记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id,
            标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        --门诊费用记录
        --Update 门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
        --Update H门诊费用记录
        --Set 病人id = v_保留id,
        --    标识号 = Nvl(Decode(门诊标志, 1, v_门诊号, Decode(n_每次新住院号, 1, r_Merge.住院号, v_住院号)), 标识号)
        --Where 病人id = r_Merge.病人id;
      
        --病人预交记录
        Update 病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人预交记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人未结费用
        Update 病人未结费用
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --未发药品记录
        Update 未发药品记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --诊断情况
        Update 诊断情况
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险结算记录(病人ID和非住院病人一起在后面处理)
        Update 保险结算记录 Set 主页id = n_Cur主页id Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --保险模拟结算
        Update 保险模拟结算
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人医嘱记录(ZLHIS+)
        Update 病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人医嘱记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人过敏记录(ZLHIS+)
        Update 病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人过敏记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人诊断记录(ZLHIS+)
        Update 病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人诊断记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人手麻记录(ZLHIS+)
        Update 病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
        Update H病人手麻记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病人担保记录(zlhis+)
        Update 病人担保记录
        Set 病人id = v_保留id, 主页id = n_Cur主页id
        Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      
        --病案系统的表
        Begin
          v_Sql := 'Update 病人费用 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 随诊记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 诊断符合情况 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 病案评分结果 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Insert Into 病人分娩信息(病人ID,主页ID,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分) ' ||
                   'Select :1,:2,胎儿次序,分娩方式,出生胎位,分娩情况,出生缺陷,婴儿性别,婴儿体重,Apgar评分 From 病人分娩信息 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Delete From 病人分娩信息 Where 病人ID=:1 And 主页ID=:2';
          Execute Immediate v_Sql
            Using r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        Begin
          v_Sql := 'Update 借阅记录 Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        Exception
          When Others Then
            Null;
        End;
      
        --其它病案主页相关表
        For v_Loop In 1 .. Arronpage.Count Loop
          v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1,主页ID=:2 Where 病人ID=:3 And 主页ID=:4';
          Execute Immediate v_Sql
            Using v_保留id, n_Cur主页id, r_Merge.病人id, r_Merge.主页id;
        End Loop;
      
        --删除已调整后的病案主页
        Delete From 病案主页 Where 病人id = r_Merge.病人id And 主页id = r_Merge.主页id;
      End If;
      If r_Merge.主页id <> 0 Then
        v_Count := v_Count - 1;
      End If;
    End Loop;
  End If;

  --不涉及主页ID部份的更改(无主页ID或主页ID可能为空)
  ---------------------------------------------------------------
  --住院费用记录
  Update 住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H住院费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  --门诊费用记录
  Update 门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;
  Update H门诊费用记录
  Set 病人id = v_保留id, 标识号 = Nvl(Decode(门诊标志, 2, v_住院号, v_门诊号), 标识号)
  Where 病人id = v_合并id;

  --病人预交记录
  Update 病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人预交记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --未发药品记录
  Update 未发药品记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --诊断情况
  Update 诊断情况 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人医嘱记录(ZLHIS+)
  Update 病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人医嘱记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人过敏记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人过敏记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人诊断记录(ZLHIS+):主页ID可能是挂号ID
  Update 病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人诊断记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人手麻记录(ZLHIS+)
  Update 病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;
  Update H病人手麻记录 Set 病人id = v_保留id Where 病人id = v_合并id And 主页id Is Null;

  --病人挂号记录(ZLHIS+)
  Update 病人挂号记录 Set 病人id = v_保留id, 门诊号 = Nvl(v_门诊号, 门诊号) Where 病人id = v_合并id;

  --病人结帐记录
  Update 病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  Update H病人结帐记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --床位状况记录
  Update 床位状况记录 Set 病人id = v_保留id Where 病人id = v_合并id;

  --病人担保记录
  Update 病人担保记录 Set 病人id = v_保留id Where 病人id = v_合并id;
  --特殊病人
  Select Count(*) Into v_Count From 特殊病人 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Update 特殊病人 Set 病人id = v_保留id Where 病人id = v_合并id;
  Else
    Delete From 特殊病人 Where 病人id = v_合并id;
  End If;

  --病人未结费用
  For r_Owe In c_Owe(v_合并id) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Owe.金额, 0)
    Where 主页id Is Null And 病人id = v_保留id And Nvl(病人病区id, 0) = Nvl(r_Owe.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Owe.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Owe.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(r_Owe.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(r_Owe.收入项目id, 0) And
          Nvl(来源途径, 0) = Nvl(r_Owe.来源途径, 0);
    If Sql%Rowcount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (v_保留id, Null, r_Owe.病人病区id, r_Owe.病人科室id, r_Owe.开单部门id, r_Owe.执行部门id, r_Owe.收入项目id, r_Owe.来源途径, r_Owe.金额);
    End If;
  End Loop;
  Delete From 病人未结费用 Where 病人id = v_合并id;
  Delete From 病人未结费用 Where 病人id = v_保留id And Nvl(金额, 0) = 0;

  --病人余额
  For r_Spare In c_Spare(v_合并id) Loop
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Spare.预交余额, 0), 费用余额 = Nvl(费用余额, 0) + Nvl(r_Spare.费用余额, 0)
    Where Nvl(性质, 0) = Nvl(r_Spare.性质, 0) And 病人id = v_保留id And 类型 = Nvl(r_Spare.类型, 2);
    If Sql%Rowcount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (v_保留id, r_Spare.性质, Nvl(r_Spare.类型, 2), r_Spare.预交余额, r_Spare.费用余额);
    End If;
  End Loop;
  Delete From 病人余额 Where 病人id = v_合并id;
  Delete From 病人余额 Where 病人id = v_保留id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 性质 = 1;

  --病人过敏药物
  Insert Into 病人过敏药物
    (病人id, 过敏药物id, 过敏药物)
    Select v_保留id, 过敏药物id, 过敏药物
    From 病人过敏药物
    Where 病人id = v_合并id And 过敏药物id Not In (Select 过敏药物id From 病人过敏药物 Where 病人id = v_保留id);
  Delete From 病人过敏药物 Where 病人id = v_合并id;

  --病人社区信息
  Insert Into 病人社区信息
    (病人id, 社区, 社区号, 标志, 就诊类型, 就诊时间)
    Select v_保留id, 社区, 社区号, 标志, 就诊类型, 就诊时间
    From 病人社区信息
    Where 病人id = v_合并id And 社区 Not In (Select 社区 From 病人社区信息 Where 病人id = v_保留id);
  Delete From 病人社区信息 Where 病人id = v_合并id;

  --病人免疫记录
  Insert Into 病人免疫记录
    (病人id, 接种时间, 接种名称)
    Select v_保留id, a.接种时间, a.接种名称
    From 病人免疫记录 a
    Where a.病人id = v_合并id And Not Exists (Select 1 From 病人免疫记录 Where 病人id = v_保留id And 接种时间 = a.接种时间);
  Delete From 病人免疫记录 Where 病人id = v_合并id;

  --病人信息从表
  Insert Into 病人信息从表
    (病人id, 信息名, 信息值, 就诊id)
    Select v_保留id, a.信息名, a.信息值, a.就诊id
    From 病人信息从表 a
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人信息从表
           Where 病人id = v_保留id And 信息名 = a.信息名 And Nvl(就诊id, 0) = Nvl(a.就诊id, 0));
  Delete From 病人信息从表 Where 病人id = v_合并id;

  --病人医疗卡属性
  Insert Into 病人医疗卡属性
    (病人id, 卡类别id, 卡号, 信息名, 信息值)
    Select v_保留id, a.卡类别id, a.卡号, a.信息名, a.信息值
    From 病人医疗卡属性 a
    Where a.病人id = v_合并id And Not Exists (Select 1
           From 病人医疗卡属性
           Where 病人id = v_保留id And 卡类别id = a.卡类别id And 卡号 = a.卡号 And 信息名 = a.信息名);
  Delete From 病人医疗卡属性 Where 病人id = v_合并id;

  --门诊病案记录
  Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_保留id;
  If v_Count = 0 Then
    Select Count(*) Into v_Count From 门诊病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 门诊病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Delete From 门诊病案记录 Where 病人id = v_合并id;
  End If;

  --住院病案记录
  Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_保留id;

  If v_Count = 0 Then
    Select Count(*) Into v_Count From 住院病案记录 Where 病人id = v_合并id;
    If v_Count > 0 Then
      Update 住院病案记录 Set 病人id = v_保留id Where 病人id = v_合并id;
    End If;
  Else
    Begin
      v_Sql := 'Delete From 借阅记录 Where 病人ID=:1';
      Execute Immediate v_Sql
        Using v_合并id;
    Exception
      When Others Then
        Null;
    End;
  
    Delete From 住院病案记录 Where 病人id = v_合并id;
  End If;

  --医保病人相关处理
  --即使合病或保留的病人当前不是医保帐户,只要曾是医保帐户,险类不同也不能合并
  Select Count(Distinct 险类) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
  If v_Count = 2 Then
    Close c_Infoa;
    Close c_Infob;
    v_Error := '两个病人分别属于不同的保险类别，不允许合并。';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 0;
  --a.合并的病人以前是医保帐户,现在不是
  If v_Count > 0 Then
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
    --a.1保留的病人现在是医保帐户
    --a.2.1保留的病人现在不是医保帐户,以前是,与a.1相同处理
    If v_Count > 0 Then
      Delete From 帐户年度信息 Where 病人id = v_合并id;
    
      Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
      If v_Count <> 2 Then
        --两个病人医保号相同时,不用处理医保病人档案
        For r_Insure In c_Insure(v_合并id) Loop
          --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
          --问题27445 保留指定病人的门诊号、住院号、医保号
          If v_合并id = B病人id_In Then
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          Else
            Update 医保病人关联表
            Set 医保号 =
                 (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
            Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
          End If;
          --合并的病人现在不是医保,即使是用户指定要保留该病人,也不保留它的帐户信息
          Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
        End Loop;
      End If;
      Delete From 医保病人关联表 Where 病人id = v_合并id;
    Else
      --a.2.2保留的病人现在和以前都不是医保帐户
      Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
      Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
      --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
    End If;
  Else
    Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_合并id And 标志 = 1;
    --b.合并的病人现在是医保帐户
    If v_Count > 0 Then
      Select Count(*) Into v_Count From 医保病人关联表 Where 病人id = v_保留id;
      --b.1保留的病人现在也是医保帐户
      --b.2.1保留的病人现在不是医保帐户,以前是,与b.1相同处理
      If v_Count > 0 Then
        For r_Insure In c_Insure(v_合并id) Loop
          --转移帐户年度信息
          For r_Year In c_Year(v_合并id, r_Insure.险类) Loop
            Update 帐户年度信息
            Set 帐户增加累计 = Nvl(帐户增加累计, 0) + Nvl(r_Year.帐户增加累计, 0), 帐户支出累计 = Nvl(帐户支出累计, 0) + Nvl(r_Year.帐户支出累计, 0),
                进入统筹累计 = Nvl(进入统筹累计, 0) + Nvl(r_Year.进入统筹累计, 0), 统筹报销累计 = Nvl(统筹报销累计, 0) + Nvl(r_Year.统筹报销累计, 0),
                住院次数累计 = Nvl(住院次数累计, 0) + Nvl(r_Year.住院次数累计, 0), 大额统筹累计 = Nvl(大额统筹累计, 0) + Nvl(r_Year.大额统筹累计, 0),
                起付线累计 = Nvl(起付线累计, 0) + Nvl(r_Year.起付线累计, 0), 本次起付线 = Nvl(本次起付线, r_Year.本次起付线),
                基本统筹限额 = Nvl(基本统筹限额, r_Year.基本统筹限额), 大额统筹限额 = Nvl(大额统筹限额, r_Year.大额统筹限额),
                封销信息 = Nvl(封销信息, r_Year.封销信息)
            Where 病人id = v_保留id And 险类 = r_Insure.险类 And 年度 = r_Year.年度;
            If Sql%Rowcount = 0 Then
              Insert Into 帐户年度信息
                (病人id, 险类, 年度, 帐户增加累计, 帐户支出累计, 进入统筹累计, 统筹报销累计, 住院次数累计, 本次起付线, 基本统筹限额, 大额统筹限额, 起付线累计, 大额统筹累计, 封销信息)
              Values
                (v_保留id, r_Insure.险类, r_Year.年度, r_Year.帐户增加累计, r_Year.帐户支出累计, r_Year.进入统筹累计, r_Year.统筹报销累计,
                 r_Year.住院次数累计, r_Year.本次起付线, r_Year.基本统筹限额, r_Year.大额统筹限额, r_Year.起付线累计, r_Year.大额统筹累计, r_Year.封销信息);
            End If;
          End Loop;
          Delete From 帐户年度信息 Where 病人id = v_合并id;
        
          Select Count(Distinct 医保号) Into v_Count From 医保病人关联表 Where 病人id In (v_合并id, v_保留id);
          If v_Count <> 2 Then
            --两个病人医保号相同时,不用处理医保病人档案
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 标志 = 0
              Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
              Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
            End If;
            Delete From 医保病人关联表 Where 病人id = v_合并id;
          Else
            --被合并的病人可能关联了多个医保病人,改为关联到保留的病人上
            --问题27445 保留指定病人的门诊号、住院号、医保号
            If v_合并id = B病人id_In Then
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_合并id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            Else
              Update 医保病人关联表
              Set 医保号 =
                   (Select 医保号 From 医保病人关联表 Where 病人id = v_保留id), 标志 = 0
              Where 险类 = r_Insure.险类 And 中心 = r_Insure.中心 And 医保号 = r_Insure.医保号 And 病人id <> v_合并id;
            End If;
            --暂存用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              Open c_Keepinsure(B病人id_In, r_Insure.险类);
              Fetch c_Keepinsure
                Into r_Keepinsure;
            End If;
          
            Delete From 医保病人关联表 Where 病人id = v_合并id;
            Delete From 医保病人档案 Where 险类 = r_Insure.险类 And 医保号 = r_Insure.医保号;
          
            --保留用户指定要保留病人的帐户信息
            If v_合并id = B病人id_In Then
              If c_Keepinsure%Rowcount > 0 Then
                Update 医保病人档案
                Set 卡号 = r_Keepinsure.卡号, 医保号 = r_Keepinsure.医保号, 密码 = r_Keepinsure.密码, 人员身份 = r_Keepinsure.人员身份,
                    单位编码 = r_Keepinsure.单位编码, 顺序号 = r_Keepinsure.顺序号, 退休证号 = r_Keepinsure.退休证号, 帐户余额 = r_Keepinsure.帐户余额,
                    当前状态 = r_Keepinsure.当前状态, 病种id = r_Keepinsure.病种id, 在职 = r_Keepinsure.在职, 年龄段 = r_Keepinsure.年龄段,
                    灰度级 = r_Keepinsure.灰度级, 就诊时间 = r_Keepinsure.就诊时间
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                --保留病人可能关联了多个医保病人,都要更改医保号
                Update 医保病人关联表
                Set 医保号 = r_Keepinsure.医保号, 标志 = 0
                Where (险类, 中心, 医保号) In (Select 险类, 中心, 医保号 From 医保病人关联表 Where 病人id = v_保留id);
                Update 医保病人关联表 Set 标志 = 1 Where 病人id = v_保留id;
              End If;
              Close c_Keepinsure;
            End If;
          End If;
        End Loop;
      Else
        --b.2.2保留的病人现在和以前都不是医保帐户
        Update 帐户年度信息 Set 病人id = v_保留id Where 病人id = v_合并id;
        Update 医保病人关联表 Set 病人id = v_保留id Where 病人id = v_合并id;
        --医保病人档案表不用处理,因为通过医保号关联<医保病人关联表>
      End If;
    Else
      --c.合并的病人以前和现在都不是医保帐户,不作任何处理
      Null;
    End If;
  End If;

  --处理体检子系统的病人合并
  n_Have := 0;
  Begin
    Select 1 Into n_Have From Zlsystems Where Floor(编号 / 100) = 21;
  Exception
    When Others Then
      Null;
  End;
  If n_Have = 1 Then
    v_Sql := 'Begin zl21_病人信息_Merge(:1,:2); End;';
    Execute Immediate v_Sql
      Using v_合并id, v_保留id;
  End If;

  --其它病人,病案主页相关表
  For v_Loop In 1 .. Arronpage.Count Loop
    --Executesql('Update ' || Arronpage(v_Loop) || ' Set 病人ID=' || v_保留id || ' Where 病人ID=' || v_合并id || ' And Nvl(主页ID,0) = 0');
    --"主页=0，主页ID is NULL，主页ID=挂号ID"都有可能，前面部分与主页ID关联都没处理到，因此不加条件
    v_Sql := 'Update ' || Arronpage(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;
  For v_Loop In 1 .. Arronbase.Count Loop
    v_Sql := 'Update ' || Arronbase(v_Loop) || ' Set 病人ID=:1 Where 病人ID=:2';
    Execute Immediate v_Sql
      Using v_保留id, v_合并id;
  End Loop;

  --删除实际不保留的病人信息
  Delete From 病人信息 Where 病人id = v_合并id;

  --根据界面选择保留病人信息
  Update 病人信息
  Set 姓名 = Nvl(r_Infob.姓名, r_Infoa.姓名), 性别 = Nvl(r_Infob.性别, r_Infoa.性别), 年龄 = Nvl(r_Infob.年龄, r_Infoa.年龄), 门诊号 = v_门诊号,
      住院号 = v_住院号, 就诊卡号 = Nvl(r_Infob.就诊卡号, r_Infoa.就诊卡号),
      卡验证码 = Decode(r_Infob.就诊卡号, Null, r_Infoa.卡验证码, r_Infob.卡验证码), 费别 = Nvl(r_Infob.费别, r_Infoa.费别),
      医疗付款方式 = Nvl(r_Infob.医疗付款方式, r_Infoa.医疗付款方式), 出生日期 = Nvl(r_Infob.出生日期, r_Infoa.出生日期),
      出生地点 = Nvl(r_Infob.出生地点, r_Infoa.出生地点), 身份证号 = Nvl(r_Infob.身份证号, r_Infoa.身份证号), 身份 = Nvl(r_Infob.身份, r_Infoa.身份),
      职业 = Nvl(r_Infob.职业, r_Infoa.职业), 民族 = Nvl(r_Infob.民族, r_Infoa.民族), 国籍 = Nvl(r_Infob.国籍, r_Infoa.国籍),
      学历 = Nvl(r_Infob.学历, r_Infoa.学历), 籍贯 = Nvl(r_Infob.籍贯, r_Infoa.籍贯), 区域 = Nvl(r_Infob.区域, r_Infoa.区域),
      婚姻状况 = Nvl(r_Infob.婚姻状况, r_Infoa.婚姻状况), 家庭地址 = Nvl(r_Infob.家庭地址, r_Infoa.家庭地址),
      家庭电话 = Nvl(r_Infob.家庭电话, r_Infoa.家庭电话), 家庭地址邮编 = Nvl(r_Infob.家庭地址邮编, r_Infoa.家庭地址邮编),
      户口地址 = Nvl(r_Infob.户口地址, r_Infoa.户口地址), 户口地址邮编 = Nvl(r_Infob.户口地址邮编, r_Infoa.户口地址邮编),
      联系人姓名 = Nvl(r_Infob.联系人姓名, r_Infoa.联系人姓名), 联系人关系 = Nvl(r_Infob.联系人关系, r_Infoa.联系人关系),
      联系人地址 = Nvl(r_Infob.联系人地址, r_Infoa.联系人地址), 联系人电话 = Nvl(r_Infob.联系人电话, r_Infoa.联系人电话),
      合同单位id = Nvl(r_Infob.合同单位id, r_Infoa.合同单位id), 工作单位 = Nvl(r_Infob.工作单位, r_Infoa.工作单位),
      单位电话 = Nvl(r_Infob.单位电话, r_Infoa.单位电话), 单位邮编 = Nvl(r_Infob.单位邮编, r_Infoa.单位邮编),
      单位开户行 = Nvl(r_Infob.单位开户行, r_Infoa.单位开户行), 单位帐号 = Nvl(r_Infob.单位帐号, r_Infoa.单位帐号),
      就诊时间 = Nvl(r_Infob.就诊时间, r_Infoa.就诊时间), 就诊状态 = Nvl(r_Infob.就诊状态, r_Infoa.就诊状态),
      就诊诊室 = Nvl(r_Infob.就诊诊室, r_Infoa.就诊诊室), 险类 = Nvl(r_Infob.险类, r_Infoa.险类),
      登记时间 = Nvl(r_Infob.登记时间, r_Infoa.登记时间), 住院次数 = Null, 主页id = Null, 当前床号 = Null, 当前科室id = Null, 当前病区id = Null,
      入院时间 = Null, 出院时间 = Null, 在院 = Decode(Nvl(r_Infob.在院, 0), 1, 1, Null)
  Where 病人id = v_保留id;

  Open c_Info(v_保留id);
  Fetch c_Info
    Into r_Info;
  If c_Info%Rowcount > 0 Then
    --最后一次为预约病人,只需要更改住院次数和入院时间
    If r_Info.主页id = 0 Then
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数)
      Where 病人id = v_保留id;
    Else
      Update 病人信息
      Set 主页id = Decode(r_Info.最大主页id, 0, Null, r_Info.最大主页id), 住院次数 = Decode(n_Max住院次数, 0, Null, n_Max住院次数),
          当前床号 = Decode(r_Info.出院日期, Null, r_Info.出院病床, Null),
          当前病区id = Decode(r_Info.出院日期, Null, r_Info.当前病区id, Null),
          当前科室id = Decode(r_Info.出院日期, Null, r_Info.出院科室id, Null), 入院时间 = r_Info.入院日期, 出院时间 = r_Info.出院日期

      Where 病人id = v_保留id;
    End If;
    --处理担保信息
    Select Nvl(主页id, -1) Into n_主页id From 病人信息 Where 病人id = v_保留id;
    --提取当前有效的正常担保记录,确保正常担保与临时担保不并存
    Select Nvl(Sum(担保额), 0), Count(病人id)
    Into n_担保额, n_Row
    From 病人担保记录
    Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 担保性质 = 0 And 删除标志 = 1;
    If n_Row = 0 Then
      --保留最后一条临时担保记录,其余到期
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1 And
            登记时间 <> (Select Max(登记时间)
                     From 病人担保记录
                     Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And
                           删除标志 = 1);
    Else
      --有正常担保就让临时担保失效
      Update 病人担保记录
      Set 到期时间 = Sysdate - 1 / 24 / 60 / 60
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 担保性质 = 1 And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1;
    End If;
  
    --提取当前有效担保额及有效担保记录数
    n_Row    := 0;
    n_担保额 := 0;
    v_担保人 := '';
    For r_提保信息 In (Select 担保人, 担保额
                   From 病人担保记录
                   Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1) Loop
      n_Row     := n_Row + 1;
      n_担保额  := n_担保额 + r_提保信息.担保额;
      v_担保人  := v_担保人 || ',' || r_提保信息.担保人;
      n_Lengthb := Lengthb(v_担保人);
      If n_Lengthb >= 101 Then
        v_Error := '不能合并担保记录，在病人信息保存时超过担保人字段长度！';
        Raise Err_Custom;
      End If;
    End Loop;
    v_担保人 := Substr(v_担保人, 2, 100);
  
    If n_Row = 0 Then
      Update 病人信息 Set 担保人 = Null, 担保额 = Null, 担保性质 = Null Where 病人id = v_保留id;
    Else
      --提取最后一条有效担保人和担保性质
      Select 担保性质
      Into n_担保性质
      From 病人担保记录
      Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And 删除标志 = 1 And
            登记时间 =
            (Select Max(登记时间)
             From 病人担保记录
             Where 病人id = v_保留id And Nvl(主页id, -1) = n_主页id And (到期时间 Is Null Or 到期时间 > Sysdate) And 删除标志 = 1);
    
      Update 病人信息 Set 担保人 = v_担保人, 担保额 = n_担保额, 担保性质 = n_担保性质 Where 病人id = v_保留id;
    End If;
  End If;

  Close c_Info;
  Close c_Infoa;
  Close c_Infob;

  --对病人进行解锁
  Update 病人信息 Set 锁定 = 0 Where 病人id In (A病人id_In, B病人id_In);
Exception
  When Err_Custom Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    End;
  When Others Then
    Begin
      Rollback; --不然会死锁
      Zl_病人信息_锁定(A病人id_In, 0);
      Zl_病人信息_锁定(B病人id_In, 0);
      Zl_Errorcenter(Sqlcode, Sqlerrm);
    End;
End Zl_病人信息_Merge;
/

--84882:刘兴洪,2015-05-19,合约单位支持消费卡结算
--84688:刘兴洪,2015-05-11,病人结帐管理中支持支付宝
Create Or Replace Procedure Zl_病人结帐记录_Delete
(
  No_In           病人结帐记录.No%Type,
  操作员编号_In   病人结帐记录.操作员编号%Type,
  操作员姓名_In   病人结帐记录.操作员姓名%Type,
  误差金额_In     病人预交记录.冲预交%Type := 0, --医保或预交退现金产生的误差
  结帐作废结算_In Varchar2 := Null, --结算方式|结算金额|结算号码||......
  预交退现金_In   Number := 0, --当预交款退现金时，结算方式及金额通过参数结帐作废结算_In传入
  冲销id_In       病人预交记录.结帐id%Type := Null,
  冲销时间_In     Date := Null,
  缴预交id_In     病人预交记录.Id%Type := Null --在作废时将相关的金额充值到预交款时填写
  
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  --该游标用于预交记录相关信息
  Cursor c_Deposit(v_Id 病人预交记录.结帐id%Type) Is
    Select 病人id, 记录性质, 结算方式, 冲预交, 预交类别 From 病人预交记录 Where 结帐id = v_Id;
  r_Depositrow c_Deposit%RowType;

  --该游标用于处理费用相关汇总表
  Cursor c_Money(v_Id 病人预交记录.结帐id%Type) Is
    Select NO, 开单部门id, 病人科室id, 执行部门id, 病人病区id, 病人id, 主页id, 收入项目id, 门诊标志, 结帐金额
    From 住院费用记录
    Where 结帐id = v_Id
    Union All
    Select NO, 开单部门id, 病人科室id, 执行部门id, 0 As 病人病区id, 病人id, 0 As 主页id, 收入项目id, 门诊标志, 结帐金额
    From 门诊费用记录
    Where 结帐id = v_Id;

  r_Moneyrow c_Money%RowType;

  --该游标包含病人的相关信息
  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = n_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_实际票号 病人预交记录.实际票号%Type;
  v_误差no   住院费用记录.No%Type;
  v_误差     结算方式.名称%Type;
  n_病人id   病人信息.病人id%Type;

  n_原id   病人结帐记录.Id%Type;
  n_结帐id 病人结帐记录.Id%Type;
  n_打印id 票据打印内容.Id%Type;

  n_来源     Number; --1-门诊;2-住院;3-门诊和住院
  n_返回值   病人余额.预交余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_预交类别 Number;
  d_Date     Date;
  n_预交id   病人预交记录.Id%Type;
  n_卡结算id 病人结帐记录.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select 名称 Into v_误差 From 结算方式 Where 性质 = 9 And Rownum = 1;

  Begin
    Select ID, 病人id, 实际票号 Into n_原id, n_病人id, v_实际票号 From 病人结帐记录 Where 记录状态 = 1 And NO = No_In;
    --最后一次打印的内容
    Select Max(ID)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 3 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Begin
        v_Err_Msg := '没有发现要作废的结帐单据,可能已经作废！';
        Raise Err_Item;
      End;
  End;

  Open c_Pati(n_病人id);
  Fetch c_Pati
    Into r_Pati; --体检系统调用此过程,团体结帐时没有病人信息

  d_Date := 冲销时间_In;
  If d_Date Is Null Then
    Select Sysdate Into d_Date From Dual;
  End If;
  n_结帐id := 冲销id_In;
  If Nvl(n_结帐id, 0) = 0 Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  End If;

  --病人结帐记录
  Insert Into 病人结帐记录
    (ID, NO, 实际票号, 记录状态, 中途结帐, 病人id, 操作员编号, 操作员姓名, 开始日期, 结束日期, 收费时间, 备注, 原因, 缴款组id, 结帐类型)
    Select n_结帐id, NO, 实际票号, 2, 中途结帐, 病人id, 操作员编号_In, 操作员姓名_In, 开始日期, 结束日期, d_Date, 备注, 原因, n_组id, 结帐类型
    From 病人结帐记录
    Where ID = n_原id;

  Update 病人结帐记录 Set 记录状态 = 3 Where ID = n_原id;

  --作废收回票据(可能以前没有使用票据,无法收回)
  If n_打印id Is Not Null Then
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
      From 票据使用明细
      Where 打印id = n_打印id And 票种 = 3 And 性质 = 1;
  End If;

  --病人预交记录(冲预交及缴款)
  If 结帐作废结算_In Is Null Then
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id, Null,
             结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 合作单位, 2
      From 病人预交记录
      Where 结帐id = n_原id And (记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0 Or 记录性质 Not In (1, 11));
  
    --消费卡处理
    For c_消费卡结算 In (Select a.Id, a.结算卡序号, Nvl(b.名称, '消费卡') As 卡名称
                    From 病人预交记录 A, 卡消费接口目录 B
                    Where a.结算卡序号 = b.编号(+) And a.结帐id = n_原id And Nvl(a.结算卡序号, 0) <> 0) Loop
      Select ID
      Into n_预交id
      From 病人预交记录
      Where 结帐id = n_结帐id And 结算卡序号 = Nvl(c_消费卡结算.结算卡序号, 0);
    
      For c_消费卡 In (Select a.Id, a.接口编号, a.消费卡id, a.序号, a.记录状态, a.结算方式, a.结算金额, a.卡号, a.交易流水号, a.交易时间, a.备注, a.结算标志,
                           b.停用日期, b.回收时间
                    From 病人卡结算记录 A, 消费卡目录 B
                    Where a.消费卡id = b.Id(+) And
                          a.Id In (Select 卡结算id From 病人卡结算对照 Where 预交id = c_消费卡结算.Id)) Loop
      
        If Nvl(c_消费卡.停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经被他人停用，不能再进行结帐作废,请检查！';
          Raise Err_Item;
        End If;
      
        If c_消费卡.回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || c_消费卡.卡号 || '"的' || c_消费卡结算.卡名称 || '已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Select 病人卡结算记录_Id.Nextval Into n_卡结算id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_卡结算id, c_消费卡结算.结算卡序号, c_消费卡.消费卡id, c_消费卡.序号, 2, c_消费卡.结算方式, -1 * c_消费卡.结算金额, c_消费卡.卡号, c_消费卡.交易流水号, d_Date,
           Null, 0);

        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_卡结算id);

        Update 消费卡目录 Set 余额 = 余额 + c_消费卡.结算金额 Where ID = c_消费卡.消费卡id;
        If Sql%NotFound Then
          v_Err_Msg := '卡号为' || c_消费卡.卡号 || '的' || c_消费卡结算.卡名称 || '未找到!';
          Raise Err_Item;
        End If;
      End Loop;
    End Loop;
  
  Else
    --1.先处理冲预交部分
    If 预交退现金_In = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 病人id, 主页id, 科室id,
               Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date, 操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = n_原id And 记录性质 In (1, 11) And Nvl(冲预交, 0) <> 0;
    End If;
  
    --2.再处理结帐结算,包括医保和非医保
    v_结算内容 := 结帐作废结算_In || ' ||'; --以空格分开以|结尾,没有结算号码的
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐作废退款',
         Null, Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, -1 * n_结算金额, n_结帐id, n_组id, 2);
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;
  --确定结帐的费用记录来源
  Begin
    Select Case
             When Nvl(Max(住院), 0) = 1 And Nvl(Max(门诊), 0) = 1 Then
              3
             When Nvl(Max(住院), 0) = 1 Then
              2
             Else
              1
           End
    Into n_来源
    From (Select 1 As 住院, 0 As 门诊
           From 住院费用记录
           Where 结帐id = n_原id And Rownum = 1
           Union All
           Select 0 As 住院, 1 As 门诊 From 门诊费用记录 Where 结帐id = n_原id And Rownum = 1);
  
  Exception
    When Others Then
      n_来源 := 3;
  End;

  If 误差金额_In <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 误差金额_In
    Where NO = No_In And 记录性质 = 12 And 记录状态 = 1 And 结帐id = n_结帐id;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, No_In, v_实际票号, 12, 1, n_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_误差, Null, '结帐作废退款', Null,
         Null, Null, d_Date, 操作员姓名_In, 操作员编号_In, 误差金额_In, n_结帐id, n_组id, 2);
    End If;
  End If;

  If n_来源 = 2 Or n_来源 = 3 Then
    --作废结帐对应的费用记录:不包含原始结帐产生的误差项目
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
       病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id,
       开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要,
       缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 多病人单,
             记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次,
             加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人,
             执行时间, 操作员姓名, 操作员编号, -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id, 医疗小组id
      From 住院费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;

  If n_来源 = 1 Or n_来源 = 3 Then
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
       执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, To_Number('1' || Substr(记录性质, Length(记录性质), 1)), 记录状态, 序号, 从属父号, 价格父号, 记帐单id,
             病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费,
             记帐费用, 收入项目id, 收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号,
             -1 * 结帐金额, n_结帐id, 保险项目否, 保险大类id, 统筹金额, 是否急诊, 保险编码, 费用类型, 摘要, 缴款组id
      From 门诊费用记录
      Where 结帐id = n_原id And Nvl(附加标志, 0) <> 9;
  End If;
  --相关汇总表处理
  For r_Depositrow In c_Deposit(n_结帐id) Loop
    If r_Depositrow.记录性质 In (1, 11) Then
    
      --病人余额(预交)
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Depositrow.冲预交 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Depositrow.病人id And 类型 = Nvl(r_Depositrow.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Depositrow.病人id, 1, Nvl(r_Depositrow.预交类别, 2), -1 * r_Depositrow.冲预交, 0);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
    
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 性质 = 1 And 病人id = r_Depositrow.病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
    Else
      --人员缴款余额,医保不支持作废的结算方式在新的预交结算中已被处理为了退现金,
      --此处用加,表示收回退给病人的现金(结帐时,退款是负,作废时是正)
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Depositrow.冲预交
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Depositrow.结算方式, 1, r_Depositrow.冲预交);
        n_返回值 := -1 * r_Depositrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Depositrow.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  End Loop;

  For r_Moneyrow In c_Money(n_结帐id) Loop
    --病人余额 ,误差项已结帐,所以不需要更新这两个汇总表
    If Nvl(v_误差no, 'sc') <> Nvl(r_Moneyrow.No, 'sc') Then
      If Nvl(r_Moneyrow.门诊标志, 0) = 1 Or Nvl(r_Moneyrow.门诊标志, 0) = 2 Then
        n_预交类别 := r_Moneyrow.门诊标志;
      Elsif Nvl(r_Moneyrow.主页id, 0) = 0 Or Nvl(r_Moneyrow.门诊标志, 0) = 4 Then
        --体检:门诊病人
        n_预交类别 := 1;
      Else
        n_预交类别 := 2;
      End If;
    
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - r_Moneyrow.结帐金额 --注:新的结帐ID产生的是负数金额
      Where 病人id = r_Moneyrow.病人id And 类型 = n_预交类别 And 性质 = 1
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, n_预交类别, 0, -1 * r_Moneyrow.结帐金额);
        n_返回值 := -1 * r_Moneyrow.结帐金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_Moneyrow.结帐金额
      Where 病人id = r_Moneyrow.病人id And Nvl(主页id, 0) = Nvl(r_Moneyrow.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Moneyrow.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Moneyrow.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Moneyrow.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Moneyrow.执行部门id, 0) And
            收入项目id + 0 = r_Moneyrow.收入项目id And 来源途径 + 0 = r_Moneyrow.门诊标志;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Moneyrow.病人id, Decode(r_Moneyrow.主页id, Null, Null, 0, Null, r_Moneyrow.主页id),
           Decode(r_Moneyrow.病人病区id, Null, Null, 0, Null, r_Moneyrow.病人病区id), r_Moneyrow.病人科室id, r_Moneyrow.开单部门id,
           r_Moneyrow.执行部门id, r_Moneyrow.收入项目id, r_Moneyrow.门诊标志, -1 * r_Moneyrow.结帐金额);
      End If;
    End If;
  End Loop;

  If Nvl(缴预交id_In, 0) <> 0 Then
    --作废时将退款金额充值到预交款帐户,这里标明是本次结帐缴存的
    Update 病人预交记录 Set 结帐id = 冲销id_In Where ID = 缴预交id_In And 结帐id Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '未找到对应的预交款记录！';
      Raise Err_Item;
    End If;
  End If;
  Close c_Pati;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结帐记录_Delete;
/

--84688:刘兴洪,2015-05-11,病人结帐管理中支持支付宝
Create Or Replace Procedure Zl_住院收费结算_Update
(
  结帐id_In       住院费用记录.结帐id%Type,
  结帐结算_In     Varchar2, --结帐结算_IN-非医保时:结算方式|结算金额|结算号码||.....医保时:结算方式|结算金额|保险类别,保险密码,保险帐号||.....
  冲预交_In       Varchar2, --冲预交_IN= ID|单据号|金额|记录状态||.....
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  三方帐户结算_In Varchar2 := Null --:结算方式|结算金额|卡类别ID|卡号|交易流水号|交易说明||...
) As
  --功能:处理结帐时和医保正式结算后,相关结算信息的调整
  --     因为虚拟结帐后,生成的医保结算金额总额及分摊可能会与正式结算时有差异,所以提供了校对功能,
  --   操作员在结算校对时,可以调整非医保结算方式的各种结算金额及方式,重新生成结算串,并且可能产生误差金额.

  --病人信息
  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, b.主页id, b.出院病床, b.当前病区id, b.出院科室id, Nvl(b.费别, a.费别) As 费别, c.编码 As 付款方式
    From 病人信息 A, 病案主页 B, 医疗付款方式 C
    Where a.病人id = v_病人id And a.病人id = b.病人id(+) And Nvl(a.主页id, 0) = b.主页id(+) And a.医疗付款方式 = c.名称(+);
  r_Pati c_Pati%RowType;

  --过程变量
  v_结算内容 Varchar2(4000);
  v_当前结算 Varchar2(100);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 Varchar2(100); --保险结算记录时,存入:保险类别,保险密码,保险帐号

  n_卡类别id   病人预交记录.卡类别id%Type;
  v_卡号       病人预交记录.卡号%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  v_交易说明   病人预交记录.交易说明%Type;

  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  v_误差结算   病人预交记录.结算方式%Type;

  v_预交id   病人预交记录.Id%Type;
  v_记录状态 病人预交记录.记录状态%Type;

  v_保险类别 病人预交记录.缴款单位%Type;
  v_保险帐号 病人预交记录.单位开户行%Type;
  v_保险密码 病人预交记录.单位帐号%Type;
  v_付款方式 门诊费用记录.付款方式%Type;
  n_返回值   病人余额.预交余额%Type;
  n_Dele     Number; --0-不删除,1-删除
  v_Error    Varchar2(255);
  Err_Custom Exception;
  n_门诊标志   Number; --1.门诊,2-住院,3-门诊和住院
  n_组id       财务缴款分组.Id%Type;
  n_类别       Number;
  n_门诊冲预交 病人预交记录.冲预交%Type;
  n_住院冲预交 病人预交记录.冲预交%Type;

Begin

  --1.取预交记录中的需要的相关信息
  Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id
  From 病人结帐记录
  Where ID = 结帐id_In;

  Open c_Pati(v_病人id);
  Fetch c_Pati
    Into r_Pati;

  --误差相关信息
  Begin
    Select 名称 Into v_误差结算 From 结算方式 Where 性质 = 9;
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
        Raise Err_Custom;
      End;
  End;

  --2.删除旧的记录,回退汇总数据
  --回退人员缴款余额,病人余额,
  For c_Del In (Select 结算方式, 操作员姓名, 冲预交 From 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) - Nvl(c_Del.冲预交, 0)
    Where 结算方式 = c_Del.结算方式 And 收款员 = v_操作员姓名 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (v_操作员姓名, c_Del.结算方式, 1, -1 * c_Del.冲预交);
    End If;
  End Loop;

  If v_病人id > 0 Then
    For v_预交 In (Select 预交类别, Sum(Nvl(冲预交, 0)) As 预交金额
                 From 病人预交记录
                 Where 结帐id = 结帐id_In And 记录性质 In (1, 11)
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = v_病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (v_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
      End If;
    End Loop;
  End If;

  --取门诊标志
  Select Case
           When 门诊标志 = 1 And 住院标志 = 1 Then
            3
           When 门诊标志 = 1 Then
            1
           Else
            2
         End, 付款方式
  Into n_门诊标志, v_付款方式
  From (Select Nvl(Max(门诊标志), 0) As 门诊标志, Nvl(Max(住院标志), 0) As 住院标志, Max(付款方式) As 付款方式
         From (Select 1 As 门诊标志, 0 As 住院标志, 付款方式
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1
                Union All
                Select 0 As 门诊标志, 1 As 住院标志, '' As 付款方式
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1));

  --回退汇总表.         病人未结费用(因为新误差将立即结帐,所以不处理)
  --只可能产生误差金额的变化. 旧误差只可能存在一行,仅为了变量处理方便而用游标

  --删除结帐缴款,保险结算记录
  Delete 三方结算交易 Where 交易id In (Select ID From 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2);

  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2;

  --第一次冲预交的,清空冲减额
  Update 病人预交记录 Set 冲预交 = Null, 结帐id = Null, 结算性质 = Null Where 结帐id = 结帐id_In And 记录性质 = 1;
  --删除冲余款
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 11;

  --删除误差记录
  If n_门诊标志 = 1 Then
    Delete 门诊费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;
  Else
    Delete 住院费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;
  End If;

  --4.重新生成病人预交记录相关数据
  --4.1.补款结算,保险结算
  If 结帐结算_In Is Not Null Then
    v_结算内容 := 结帐结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      If Instr(v_结算号码, ',') > 0 Then
        --医保结算:保险类别,保险密码,保险帐号
        v_结算号码 := v_结算号码 || ',';
        v_保险类别 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Substr(v_结算号码, Instr(v_结算号码, ',') + 1);
        v_保险密码 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Substr(v_结算号码, Instr(v_结算号码, ',') + 1);
        v_保险帐号 := Substr(v_结算号码, 1, Instr(v_结算号码, ',') - 1);
        v_结算号码 := Null;
      Else
        v_保险类别 := Null;
        v_保险密码 := Null;
        v_保险帐号 := Null;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员编号, 操作员姓名, 冲预交,
           结帐id, 缴款, 找补, 缴款组id, 结算性质)
        Values
          (病人预交记录_Id.Nextval, v_No, Null, 2, 1, v_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐缴款',
           v_保险类别, v_保险密码, v_保险帐号, v_收款时间, v_操作员编号, v_操作员姓名, n_结算金额, 结帐id_In,
           Decode(v_结算内容, 结帐结算_In || '||', 缴款_In, Null), Decode(v_结算内容, 结帐结算_In || '||', 找补_In, Null), n_组id, 2);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方帐户结算_In Is Not Null Then
    --结算方式|结算金额|卡类别ID|卡号|交易流水号|交易说明||...
    v_结算内容 := 三方帐户结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      v_卡号     := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      v_交易流水号 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_交易说明   := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员编号, 操作员姓名, 冲预交,
           结帐id, 缴款, 找补, 缴款组id, 结算性质, 卡类别id, 卡号, 交易流水号, 交易说明)
        Values
          (病人预交记录_Id.Nextval, v_No, Null, 2, 1, v_病人id, r_Pati.主页id, r_Pati.出院科室id, Null, v_结算方式, v_结算号码, '结帐缴款', Null,
           Null, Null, v_收款时间, v_操作员编号, v_操作员姓名, n_结算金额, 结帐id_In, Null, Null, n_组id, 2, n_卡类别id, v_卡号, v_交易流水号, v_交易说明);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.2.预交结算
  If 冲预交_In Is Not Null Then
    v_结算内容   := 冲预交_In || '||';
    n_门诊冲预交 := 0;
    n_住院冲预交 := 0;
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_预交id   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1)); --是记录冲预交的ID
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1); --是记录冲预交的NO号
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_记录状态 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If v_预交id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2 Where ID = v_预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, v_记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_收款时间, v_操作员姓名, v_操作员编号, n_结算金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = v_结算号码 And 记录性质 In (1, 11) And 记录状态 = v_记录状态 And Rownum = 1;
    
      Begin
        Select Nvl(预交类别, 2)
        Into n_类别
        From 病人预交记录
        Where NO = v_结算号码 And 记录性质 In (1, 11) And 记录状态 = v_记录状态 And Rownum = 1;
      Exception
        When Others Then
          n_类别 := 2;
      End;
      If Nvl(n_类别, 0) = 1 Then
        n_门诊冲预交 := n_门诊冲预交 + Nvl(n_结算金额, 0);
      Else
        n_住院冲预交 := n_住院冲预交 + Nvl(n_结算金额, 0);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
    --更新病人余额
    If n_门诊冲预交 <> 0 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_门诊冲预交
      Where 病人id = v_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 1, -1 * n_门诊冲预交, 1);
        n_返回值 := -1 * n_门诊冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    If n_住院冲预交 <> 0 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_住院冲预交
      Where 病人id = v_病人id And 性质 = 1 And 类型 = 2
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 2, -1 * n_住院冲预交, 1);
        n_返回值 := -1 * n_住院冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  
  End If;

  --5.相关汇总表的处理
  --汇总人员缴款余额
  --缴款结算,保险结算
  n_Dele := 0;
  For c_结帐 In (Select 结算方式, 冲预交 From 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 2) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_结帐.冲预交, 0)
    Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = c_结帐.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (v_操作员姓名, c_结帐.结算方式, 1, Nvl(c_结帐.冲预交, 0));
      n_返回值 := Nvl(Nvl(c_结帐.冲预交, 0), 0);
    End If;
  
    If Nvl(n_返回值, 0) = 0 Then
      n_Dele := 1;
    End If;
  
  End Loop;

  If n_Dele = 1 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
  End If;
  --汇总表,只需重汇误差行,因为其它项不会变,未结费用不变(新产生的误差项已结帐),只有一行误差记录,仅为使用变量方便而用游标

  --6.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

  Close c_Pati;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院收费结算_Update;
/

--84882:刘兴洪,2015-05-19,合约单位支持消费卡结算
--84688:刘兴洪,2015-05-11,病人结帐管理中支持支付宝
Create Or Replace Procedure Zl_结帐缴款记录_Insert
(
  No_In         病人结帐记录.No%Type,
  病人id_In     病人预交记录.病人id%Type,
  主页id_In     病人预交记录.主页id%Type,
  科室id_In     病人预交记录.科室id%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  结算号码_In   病人预交记录.结算号码%Type,
  金额_In       病人预交记录.冲预交%Type,
  结帐id_In     病人预交记录.结帐id%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  收费时间_In   病人预交记录.收款时间%Type,
  保险类别_In   保险帐户.险类%Type,
  保险帐号_In   保险帐户.医保号%Type,
  保险密码_In   保险帐户.密码%Type,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  消费卡结算_In Varchar2 := Null,
  退支票额_In   病人预交记录.冲预交%Type := Null
) As
  -----------------------------------------------------------
  --功能：处理一行病人结帐时的缴款记录
  --参数：
  --  NO_IN=结帐单相同的NO
  --  消费卡结算_in:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||.
  --  退支票额_In- 退支票额(结算方式_IN不为空时,有效)
  -----------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_退支票   病人预交记录.结算方式%Type;
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  v_名称     Varchar2(100);
  v_结算方式 病人预交记录.结算方式%Type;

  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_组id     财务缴款分组.Id%Type;
  n_校对标志 病人预交记录.校对标志%Type;

Begin
  n_组id     := Zl_Get组id(操作员姓名_In);
  n_校对标志 := 0;
  If Nvl(卡类别id_In, 0) <> 0 Then
    n_校对标志 := 1;
  End If;

  If Not 结算方式_In Is Null Then
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id,
       缴款, 找补, 缴款组id, 卡类别id, 卡号, 交易流水号, 交易说明, 校对标志, 结算性质)
    Values
      (病人预交记录_Id.Nextval, No_In, Null, 2, 1, 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
       Decode(科室id_In, 0, Null, 科室id_In), Null, 结算方式_In, 结算号码_In, '结帐缴款', Decode(保险类别_In, 0, Null, 保险类别_In), 保险密码_In,
       保险帐号_In, 收费时间_In, 操作员编号_In, 操作员姓名_In, 金额_In, 结帐id_In, 缴款_In, 找补_In, n_组id, 卡类别id_In, 卡号_In, 交易流水号_In, 交易说明_In,
       n_校对标志, 2);
  
    --处理人员缴款余额
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 金额_In
    Where 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And 性质 = 1
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 金额_In);
      n_返回值 := 金额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Begin
        Select b.名称
        Into v_退支票
        From 结算方式应用 A, 结算方式 B
        Where a.应用场合 = '结帐' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum < 2;
      Exception
        When Others Then
          v_退支票 := '无';
      End;
      If v_退支票 = '无' Then
        v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
        Raise Err_Item;
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 校对标志, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 2, No_In, 1, 病人id_In, 主页id_In, Null, v_退支票, 收费时间_In, 操作员编号_In, 操作员姓名_In, 退支票额_In, 结帐id_In,
         n_组id, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 2);
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + 退支票额_In
      Where 收款员 = 操作员姓名_In And 结算方式 = v_退支票 And 性质 = 1
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_退支票, 1, 退支票额_In);
        n_返回值 := 退支票额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = v_退支票 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    
    End If;
  
  End If;

  --4-消费卡批量结算
  If 消费卡结算_In Is Not Null Then
    v_结算内容 := 消费卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = 结帐id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 2, No_In, 1, 病人id_In, 主页id_In, Null, v_结算方式, 收费时间_In, 操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, n_组id,
             n_卡类别id, 0, 2);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, 收费时间_In, Null, 0);
      
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + n_结算金额
        Where 收款员 = 操作员姓名_In And 结算方式 = v_结算方式 And 性质 = 1
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_结算方式, 1, n_结算金额);
          n_返回值 := n_结算金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = v_结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐缴款记录_Insert;
/

--84688:刘兴洪,2015-05-11,病人结帐管理中支持支付宝
Create Or Replace Procedure Zl_三方接口更新_Update
(
  卡类别id_In   病人预交记录.卡类别id%Type,
  消费卡_In     Number,
  卡号_In       病人预交记录.卡号%Type,
  结帐ids_In    Varchar2,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  预交款缴款_In Number := 0,
  退费标志_In   Number := 0,
  校对标志_In   Number := Null
) As
  --功能：用于交易流水号,交易说明等信息
  --参数：
  --        消费卡_IN:1-消费卡结算;0-医疗卡结算
  --        卡类别ID_In:消费卡时为接口编号;医疗卡类别.ID
  --        结帐IDs_In:以逗号分离(如果是预交款缴款,则传入的是预交ID)
  --        预交款缴款_In:1-代表预交款缴款;0-代表消费扣款
  --        退费标志_IN:1-进行退费处理;0-支付处理
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_名称     Varchar2(100);
  n_消费卡id 消费卡目录.Id%Type;
  n_自制卡   卡消费接口目录.自制卡%Type;
  v_结算方式 卡消费接口目录.结算方式%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
Begin

  If Nvl(消费卡_In, 0) = 1 Then
    Begin
      Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
    Exception
      When Others Then
        v_名称 := Null;
    End;
  
    If v_名称 Is Null Then
      v_Err_Msg := '[ZLSOFT]未找到对应的结算卡接口,不能' || Case
                     When 预交款缴款_In = 1 Then
                      '缴预交'
                     Else
                      '刷卡消费'
                   End || '![ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(n_自制卡, 0) = 1 Then
      --消费卡结算.求出消费卡的ID
      Begin
        Select ID
        Into n_消费卡id
        From 消费卡目录 A
        Where a.卡号 = 卡号_In And a.接口编号 = 卡类别id_In And
              序号 = (Select Max(序号) From 消费卡目录 B Where 卡号 = a.卡号 And 接口编号 = a.接口编号);
      Exception
        When Others Then
          n_消费卡id := -1;
      End;
      If n_消费卡id = -1 Then
        v_Err_Msg := '[ZLSOFT]卡号为' || 卡号_In || '的' || v_名称 || '未找到,不能' || Case
                       When 预交款缴款_In = 1 Then
                        '缴预交'
                       Else
                        '刷卡消费'
                     End || '![ZLSOFT]';
        Raise Err_Item;
      End If;
    End If;
    If 退费标志_In = 0 Then
      Begin
        Select Nvl(Max(Nvl(序号, 0)), 0) + 1
        Into n_序号
        From 病人卡结算记录
        Where 接口编号 = 卡类别id_In And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = 卡号_In;
      Exception
        When Others Then
          n_序号 := 1;
      End;
    End If;
    If 预交款缴款_In = 0 Then
      For c_预交 In (Select /*+ rule */
                    ID, 冲预交 As 金额
                   From 病人预交记录
                   Where 结算卡序号 = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                         结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J)) Loop
      
        Update 病人预交记录
        Set 交易流水号 = Decode(Sign(Nvl(n_消费卡id, 0)), 1, n_消费卡id, 交易流水号_In), 交易说明 = 交易说明_In, 校对标志 = 校对标志_In,
            卡号 = Nvl(卡号, 卡号_In)
        Where ID = c_预交.Id;
        If Nvl(退费标志_In, 0) = 0 Then
          --退费在调用该过程之间处理了的
          --处理消费卡结算信息
          Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          Insert Into 病人卡结算记录
            (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
          Values
            (n_Id, 卡类别id_In, n_消费卡id, n_序号, 1, v_结算方式, Nvl(c_预交.金额, 0), 卡号_In, 交易流水号_In, Sysdate, Null, 0);
          --如果消费卡,需同时更改其余额
          If Nvl(n_消费卡id, 0) <> 0 Then
            Update 消费卡目录 Set 余额 = 余额 - Nvl(c_预交.金额, 0) Where ID = n_消费卡id;
          End If;
          Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (c_预交.Id, n_Id);
          n_序号 := n_序号 + 1;
        End If;
      End Loop;
    
    Else
      For c_预交 In (Select /*+ rule */
                    ID, 金额
                   From 病人预交记录
                   Where 结算卡序号 = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                         ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J)) Loop
      
        Update 病人预交记录
        Set 交易流水号 = Decode(Sign(Nvl(n_消费卡id, 0)), 1, n_消费卡id, 交易流水号_In), 交易说明 = 交易说明_In, 校对标志 = 0, 卡号 = Nvl(卡号, 卡号_In)
        Where ID = c_预交.Id;
      
        If Nvl(退费标志_In, 0) = 0 Then
          --退费在调用该过程之间处理了的
          --处理消费卡结算信息
          Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          Insert Into 病人卡结算记录
            (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
          Values
            (n_Id, 卡类别id_In, n_消费卡id, n_序号, 1, v_结算方式, Nvl(c_预交.金额, 0), 卡号_In, 交易流水号_In, Sysdate, Null, 0);
          --如果消费卡,需同时更改其余额
          If Nvl(n_消费卡id, 0) <> 0 Then
            Update 消费卡目录 Set 余额 = 余额 - Nvl(c_预交.金额, 0) Where ID = n_消费卡id;
          End If;
          Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (c_预交.Id, n_Id);
          n_序号 := n_序号 + 1;
        End If;
      End Loop;
    End If;
  
  Else
    Begin
      Select 名称 Into v_名称 From 医疗卡类别 Where ID = 卡类别id_In;
    Exception
      When Others Then
        v_名称 := Null;
    End;
    If v_名称 Is Null Then
      v_Err_Msg := '[ZLSOFT]未找到对应的医疗卡接口,不能缴预交![ZLSOFT]';
      Raise Err_Item;
    End If;
    If 预交款缴款_In = 0 Then
      Update 病人预交记录
      Set 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In, 校对标志 = 校对标志_In, 卡号 = Nvl(卡号, 卡号_In)
      Where 卡类别id = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
            结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J) And
            Mod(记录性质, 10) <> 1;
    Else
      Update 病人预交记录
      Set 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In, 校对标志 = 校对标志_In, 卡号 = Nvl(卡号, 卡号_In)
      Where 卡类别id = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
            ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
    End If;
  End If;

  If Sql%NotFound Then
    v_Err_Msg := '[ZLSOFT]警告:' || Chr(13) || Chr(10) || '    ' || v_名称 ||
                 '结算成功,但更新HIS数据时出错,请立即与管理联系处理和核查这部分数据(可以采用手工方式正常录入)![ZLSOFT]';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方接口更新_Update;
/

--84688:刘兴洪,2015-05-11,病人结帐管理中支持支付宝
Create Or Replace Procedure Zl_三方结算交易_Insert
(
  卡类别id_In   病人预交记录.卡类别id%Type,
  消费卡_In     Number,
  卡号_In       病人预交记录.卡号%Type,
  结帐ids_In    Varchar2,
  交易信息_In   Varchar2,
  预交款缴款_In Number := 0,
  结算方式_In   病人预交记录.结算方式%Type := Null
) As
  --功能：用于填制扩展的交易信息
  --参数：
  --        消费卡_IN:1-消费卡结算;0-医疗卡结算
  --        卡类别ID_In:消费卡时为接口编号;医疗卡类别.ID;卡类别ID_In:NULL 表示不存三卡类别ID,但允许通过结算方式_In来更新三方结算数据
  --        结帐IDs_In:以逗号分离
  --        交易信息_IN:格式:交易项目|交易内容||...
  --        预交款缴款_In:1-代表预交款缴款;0-代表消费扣款
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_名称     Varchar2(100);
  v_交易信息 Varchar2(4000);
  v_当前交易 Varchar2(4000);
  v_交易项目 三方结算交易.交易项目%Type;
  v_交易内容 三方结算交易.交易内容%Type;
Begin
  If 交易信息_In Is Null Then
    Return;
  End If;

  --1.按结算方式来更新(主要应用于自助机的相关信息)
  If 结算方式_In Is Not Null And 卡类别id_In Is Null Then
    v_交易信息 := 交易信息_In || '||';
    While v_交易信息 Is Not Null Loop
      v_当前交易 := Substr(v_交易信息, 1, Instr(v_交易信息, '||') - 1);
      v_交易项目 := Substr(v_当前交易, 1, Instr(v_当前交易, '|') - 1);
      v_交易内容 := Substr(v_当前交易, Instr(v_当前交易, '|') + 1);
      If v_交易项目 Is Not Null Then
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 卡类别id Is Null And 结算方式 = 结算方式_In And Mod(记录性质, 10) <> 1 And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 卡类别id Is Null And 结算方式 = 结算方式_In And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        End If;
      End If;
      v_交易信息 := Substr(v_交易信息, Instr(v_交易信息, '||') + 2);
    End Loop;
    Return;
  End If;

  --2.按卡类别ID来更新(主要应用于自助机的相关信息)
  v_交易信息 := 交易信息_In || '||';
  While v_交易信息 Is Not Null Loop
    v_当前交易 := Substr(v_交易信息, 1, Instr(v_交易信息, '||') - 1);
    v_交易项目 := Substr(v_当前交易, 1, Instr(v_当前交易, '|') - 1);
    v_交易内容 := Substr(v_当前交易, Instr(v_当前交易, '|') + 1);
    If v_交易项目 Is Not Null Then
      If Nvl(消费卡_In, 0) = 1 Then
        Begin
          Select 名称 Into v_名称 From 卡消费接口目录 Where 编号 = 卡类别id_In;
        Exception
          When Others Then
            v_名称 := Null;
        End;
      
        If v_名称 Is Null Then
          v_Err_Msg := '卡类别参数传入错误,请检查  ！';
          Raise Err_Item;
        End If;
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 结算卡序号 = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 结算卡序号 = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        End If;
      Else
        Begin
          Select 名称 Into v_名称 From 医疗卡类别 Where ID = 卡类别id_In;
        Exception
          When Others Then
            v_名称 := Null;
        End;
        If v_名称 Is Null Then
          v_Err_Msg := '卡类别参数传入错误,请检查  ！';
          Raise Err_Item;
        End If;
        If 预交款缴款_In = 0 Then
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 卡类别id = 卡类别id_In And Mod(记录性质, 10) <> 1 And (卡号 = 卡号_In Or 卡号 Is Null) And
                  结帐id In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        Else
          Insert Into 三方结算交易
            (交易id, 交易项目, 交易内容)
            Select /*+ rule */
             ID, v_交易项目, v_交易内容
            From 病人预交记录
            Where 卡类别id = 卡类别id_In And (卡号 = 卡号_In Or 卡号 Is Null) And
                  ID In (Select Column_Value From Table(Cast(f_Num2list(结帐ids_In) As Zltools.t_Numlist)) J);
        
        End If;
      End If;
    End If;
    v_交易信息 := Substr(v_交易信息, Instr(v_交易信息, '||') + 2);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方结算交易_Insert;
/

--84110:余智勇,2015-05-07,门诊输液管理接收门诊留观病人
CREATE OR REPLACE Procedure Zl_排队记录_Update
(
  病人id_In In 排队记录.病人id%Type,
  科室id_In In 排队记录.科室id%Type,
  顺序号_In In 排队记录.顺序号%Type,
  加权号_In In 排队记录.加权号%Type,
  状态_In   In 排队记录.状态%Type,
  挂号单_In In 排队记录.挂号单%Type,
  主页id_In In 排队记录.主页id%Type
) Is
Begin
  If 主页id_In Is Not Null Then
    --门诊留观
    Update 排队记录
    Set 加权号 = 加权号_In, 状态 = 状态_In, 日期 = Sysdate, 顺序号 = 顺序号_In
    Where 病人id = 病人id_In And 科室id = 科室id_In And 主页id = 主页id_In;
    If Sql%NotFound Then
      Insert Into 排队记录
        (病人id, 科室id, 顺序号, 加权号, 状态, 备注, 日期, 主页id)
      Values
        (病人id_In, 科室id_In, 顺序号_In, 0, 状态_In, '', Sysdate, 主页id_In);
    End If;
  Elsif 挂号单_In Is Not Null Then
    --门诊
    Update 排队记录
    Set 加权号 = 加权号_In, 状态 = 状态_In, 日期 = Sysdate, 顺序号 = 顺序号_In
    Where 病人id = 病人id_In And 科室id = 科室id_In And 挂号单 = 挂号单_In;
    If Sql%NotFound Then
      Insert Into 排队记录
        (病人id, 科室id, 顺序号, 加权号, 状态, 备注, 日期, 挂号单)
      Values
        (病人id_In, 科室id_In, 顺序号_In, 0, 状态_In, '', Sysdate, 挂号单_In);
    End If;
  Else
    Update 排队记录
    Set 加权号 = 加权号_In, 状态 = 状态_In
    Where 病人id = 病人id_In And 科室id = 科室id_In And 顺序号 = 顺序号_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队记录_Update;
/

--84110:余智勇,2015-05-07,门诊输液管理接收门诊留观病人
CREATE OR REPLACE Procedure Zl_门诊穿刺台_Liquid
(
  科室id_In In 排队记录.科室id%Type,
  病人id_In In 排队记录.病人id%Type
) Is

  --功能：“接单”为病人的排队记录分配等待穿刺的一个穿刺台

  n_Sn  门诊穿刺台.序号%Type;
  v_Tmp 病人医嘱记录.姓名%Type;
  d_Tmp Date;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);
Begin

  -- 清除24小时过期的门诊穿刺台
  Update 门诊穿刺台
  Set 待穿病人id = Null
  Where ID In
        (Select a.Id
         From 门诊穿刺台 A, 排队记录 B
         Where a.科室id = b.科室id And a.待穿病人id = b.病人id And a.有效 = 1 And a.科室id = 科室id_In And b.日期 < Sysdate - 1);

  -- 清除24小时过期，并且状态不为“1-待配液；5-待穿刺”的门诊穿刺台
  Update 门诊穿刺台
  Set 待穿病人id = Null
  Where ID In (Select a.Id
               From 门诊穿刺台 A, 排队记录 B
               Where a.科室id = b.科室id And a.待穿病人id = b.病人id And a.有效 = 1 And a.科室id = 科室id_In And Not b.状态 In (1, 5) And
                     b.日期 < Sysdate - 1);
  Commit;

  -- 为病人“排队记录”分配穿刺台
  Begin
    -- 锁定排队记录（并发控制）
    Select 日期
    Into d_Tmp
    From 排队记录
    Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 1
    For Update Nowait;
  
    -- 查找科室相同，其他穿刺台未分配给排队记录
    Begin
      Select 序号
      Into n_Sn
      From 门诊穿刺台
      Where 科室id = 科室id_In And
            Not 序号 In (Select 穿刺台 From 排队记录 Where 状态 = 1 And 科室id = 科室id_In And 穿刺台 > 0) And
            (待穿病人id Is Null Or 待穿病人id = 0) And 有效 = 1 And Rownum < 2;
    Exception
      When Others Then
        n_Sn := Null;
    End;
  
    If n_Sn Is Not Null Then
      -- 找到后更新
      Update 排队记录 Set 穿刺台 = n_Sn, 日期 = Sysdate Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 1;
      Commit;
    Else
      -- 未找到，就平均分配一个穿刺台给病人的排队记录
      Begin
        Select 穿刺台
        Into n_Sn
        From (Select a.穿刺台, Count(1) 数量
               From 排队记录 A, 门诊穿刺台 B
               Where a.科室id = b.科室id And a.穿刺台 = b.序号 And a.科室id = 科室id_In And a.日期 Between Sysdate - 1 And Sysdate And
                     a.状态 = 1 And b.有效 = 1
               Group By 穿刺台
               Order By 数量, 穿刺台) A
        Where Rownum < 2;
      Exception
        When Others Then
          n_Sn := Null;
      End;
    
      If n_Sn Is Not Null Then
        -- 找到后更新
        Update 排队记录 Set 穿刺台 = n_Sn, 日期 = Sysdate Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 1;
        Commit;
      Else
        -- 未找到，分配一个最小号的穿刺台
        Begin
          Select Min(序号) Into n_Sn From 门诊穿刺台 Where 科室id = 科室id_In And 有效 = 1;
        Exception
          When Others Then
            n_Sn := Null;
        End;
        If n_Sn Is Not Null Then
          Update 排队记录
          Set 穿刺台 = n_Sn, 日期 = Sysdate
          Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 1;
          Commit;
        Else
          Rollback;
          v_Err_Msg := '当前科室未设置穿刺台或有效的穿刺台！';
          Raise Err_Item;
        End If;
      End If;
    
    End If;
  
  Exception
    When Err_Item Then
      Raise Err_Item;
    When Others Then
      Begin
        Select 姓名 Into v_Tmp From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Tmp := '未知';
      End;
      v_Err_Msg := '[' || v_Tmp || ']不在待配液队列中！';
      Raise Err_Item;
  End;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊穿刺台_Liquid;
/

--84110:余智勇,2015-05-07,门诊输液管理接收门诊留观病人
CREATE OR REPLACE Procedure Zl_门诊穿刺台_Puncture
(
  科室id_In In 排队记录.科室id%Type,
  病人id_In In 排队记录.病人id%Type
) Is

  n_Sn      门诊穿刺台.序号%Type;
  n_Pati_Id 门诊穿刺台.待穿病人id%Type;
  n_Punc_No 排队记录.穿刺台%Type;
  d_Tmp     Date;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  --功能：
  --  1. 清除当前病人排队记录的穿刺台，表明已完成穿刺
  --  2. 重新分配另一个待穿病人ID（按排队记录的日期先后分配）

  Begin
    Select 日期, 穿刺台
    Into d_Tmp, n_Punc_No
    From 排队记录
    Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 5;
    --For Update Nowait;
  Exception
    When Others Then
      v_Err_Msg := '当前病人已其他人“穿刺”操作！';
      Raise Err_Item;
  End;

  -- 步骤1
  Update 排队记录 Set 穿刺台 = Null Where 科室id = 科室id_In And 病人id = 病人id_In And 状态 = 5;
  --Commit;

  --步骤2
  Begin
    Select 病人id
    Into n_Pati_Id
    From (Select 病人id
           From 排队记录
           Where 科室id = 科室id_In And 穿刺台 = n_Punc_No And 日期 Between d_Tmp + 1 / 24 / 60 / 60 And
                 To_Date(To_Char(Sysdate, 'yyyy-MM-dd') || ' 23:59:59', 'yyyy-MM-dd HH24:MI:SS') And 状态 = 5
           Order By 日期)
    Where Rownum < 2;
  Exception
    When Others Then
      n_Pati_Id := Null;
  End;

  If n_Pati_Id Is Not Null Then
    Update 门诊穿刺台 Set 待穿病人id = n_Pati_Id Where 科室id = 科室id_In And 序号 = n_Punc_No And 有效 = 1;
  Else
    --未找到，就按日期向小时期找
    Begin
      Select 病人id
      Into n_Pati_Id
      From (Select 病人id
             From 排队记录
             Where 科室id = 科室id_In And 穿刺台 = n_Punc_No And 日期 Between d_Tmp - 1 And d_Tmp And 状态 = 5
             Order By 日期 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        n_Pati_Id := Null;
    End;
  
    If n_Pati_Id Is Not Null Then
      Update 门诊穿刺台 Set 待穿病人id = n_Pati_Id Where 科室id = 科室id_In And 序号 = n_Punc_No And 有效 = 1;
    End If;
  
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊穿刺台_Puncture;
/

--84110:余智勇,2015-05-07,门诊输液管理接收门诊留观病人
CREATE OR REPLACE Procedure Zl_排队记录_Setcalltag
(
  病人id_In In 排队记录.病人id%Type,
  科室id_In In 排队记录.科室id%Type,
  挂号单_In In 排队记录.挂号单%Type,
  主页id_in in 排队记录.主页ID%Type
) Is

Begin

  Update 排队记录 Set 呼叫标志 = 0 Where 科室id = 科室id_In And 呼叫标志 = 1;

  If 主页id_In Is Not Null Then
    Update 排队记录 Set 呼叫标志 = 1 Where 病人id = 病人id_In And 科室id = 科室id_In And 主页id = 主页id_In;
  Elsif 挂号单_In Is Not Null Then
    Update 排队记录 Set 呼叫标志 = 1 Where 病人id = 病人id_In And 科室id = 科室id_In And 挂号单 = 挂号单_In;
  Else
    Update 排队记录 Set 呼叫标志 = 1 Where 病人id = 病人id_In And 科室id = 科室id_In;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队记录_Setcalltag;
/

--84110:余智勇,2015-05-07,门诊输液管理接收门诊留观病人
CREATE OR REPLACE Procedure Zl_排队记录_Startend
(
  操作_In   In Number,
  科室id_In In 排队记录.科室id%Type,
  病人id_In In 排队记录.病人id%Type,
  挂号单_In In 排队记录.挂号单%Type,
  主页id_In In 排队记录.主页id%Type,
  操作员_In In 排队记录.开始操作员%Type
) Is
Begin

  --功能：修改排队记录的开始或结束信息
  --参数：
  --  操作_In：1-开始 2-结束 

  If 操作_In = 1 Then
    If 主页id_In Is Not Null Then
      Update 排队记录
      Set 开始时间 = Sysdate, 开始操作员 = 操作员_In
      Where 科室id = 科室id_In And 病人id = 病人id_In And 主页id = 主页id_In;
    Else
      Update 排队记录
      Set 开始时间 = Sysdate, 开始操作员 = 操作员_In
      Where 科室id = 科室id_In And 病人id = 病人id_In And 挂号单 = 挂号单_In;
    End If;
  Else
    If 主页id_In Is Not Null Then
      Update 排队记录
      Set 结束时间 = Sysdate, 结束操作员 = 操作员_In
      Where 科室id = 科室id_In And 病人id = 病人id_In And 主页id = 主页id_In;
    Else
      Update 排队记录
      Set 结束时间 = Sysdate, 结束操作员 = 操作员_In
      Where 科室id = 科室id_In And 病人id = 病人id_In And 挂号单 = 挂号单_In;
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_排队记录_Startend;
/

--85224:余智勇,2015-05-28,门诊输液操作日志包含门诊留观病人
CREATE OR REPLACE Procedure Zl_门诊输液操作日志_Add
(
  Id_In     In 门诊输液操作日志.Id%Type,
  科室id_In In 门诊输液操作日志.科室id%Type,
  病人id_In In 门诊输液操作日志.病人id%Type,
  挂号单_In In 门诊输液操作日志.挂号单%Type,
  主页id_In In 门诊输液操作日志.主页id%Type,
  类别_In   In 门诊输液操作日志.类别%Type,
  内容_In   In 门诊输液操作日志.内容%Type,
  操作员_In In 门诊输液操作日志.操作员%Type
) Is
Begin
  Insert Into 门诊输液操作日志
    (ID, 科室id, 病人id, 挂号单, 主页id, 类别, 内容, 操作员, 时间)
  Values
    (Id_In, 科室id_In, 病人id_In, 挂号单_In, 主页id_In, 类别_In, 内容_In, 操作员_In, Sysdate);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊输液操作日志_Add;
/

--82076:刘尔旋,2015-07-01,门诊转住院三方结算修改
--84935:刘尔旋,2015-05-18,门诊转住院单据退费报错问题
--84787:刘尔旋,2015-07-15,消费卡转住院前检查
--84649:刘尔旋,2015-05-11,历史费用记录门诊转住院问题
Create Or Replace Procedure Zl_门诊费用转住院_Insert
(
  结算序号_In   病人预交记录.结算序号%Type,
  No_In         住院费用记录.No%Type,
  住院号_In     住院费用记录.标识号%Type, --医保入院补充登记时才传入
  主页id_In     住院费用记录.主页id%Type, --医保入院补充登记时才传入
  入院时间_In   住院费用记录.发生时间%Type,
  入院科室id_In 病人预交记录.科室id%Type,
  退费时间_In   住院费用记录.登记时间%Type, --多张单据退费时,每张单据的退费时间相同,都是系统当前时间
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  入院病区id_In 住院费用记录.病人病区id%Type := Null,
  单据_In       Number := 1,
  结帐id_In     住院费用记录.结帐id%Type := Null
) As
  --单据_In:1-门诊收费单;2-记帐单
  v_Billno   住院费用记录.No%Type;
  n_实收合计 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;

  n_病区id     住院费用记录.病人病区id%Type;
  v_床号       住院费用记录.床号%Type;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  n_开单部门id     部门表.Id%Type;
  n_操作员编号     门诊费用记录.操作员编号%Type;
  v_操作员姓名     门诊费用记录.操作员姓名%Type;
  v_开单人         人员表.姓名%Type;
  n_病人id         病人信息.病人id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_立即销帐       Number(2);
  v_Nos            Varchar2(3000);
  n_结帐id         门诊费用记录.结帐id%Type;
  v_Err_Msg        Varchar2(255);
  n_组id           财务缴款分组.Id%Type;
  n_部分退费       Number(2);
  n_消费卡         Number(2);
  Err_Item Exception;
  n_Count Number(18);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  If Nvl(主页id_In, 0) <> 0 Then
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 病人id
        Into n_病人id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And Rownum = 1;
      Exception
        When Others Then
          n_病人id := 0;
      End;
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  If Nvl(结算序号_In, 0) >= 0 Then
    Begin
      Select 1 Into n_部分退费 From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 2 And NO = No_In And Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
    If n_部分退费 = 1 Then
      Begin
        Select 1
        Into n_消费卡
        From 病人预交记录 A, 结算方式 B
        Where a.记录性质 = 3 And a.No = No_In And a.结算方式 = b.名称 And b.性质 = 8 And Rownum < 2;
      Exception
        When Others Then
          n_消费卡 := 0;
      End;
      If n_消费卡 = 1 Then
        v_Err_Msg := '单据' || No_In || '是使用消费卡结算并且存在部分退费,不能转为住院费用.';
        Raise Err_Item;
      End If;
    End If;
  End If;
  -- n_门诊转住院先审核 := Zl_To_Number(Zl_Getsysparameter('门诊转住院先审核', 1143));
  n_立即销帐 := Zl_To_Number(zl_GetSysParameter('费用转出立即退费', 1131));
  For r_Nos In (Select Distinct a.No
                From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
    v_Nos := v_Nos || ',' || r_Nos.No;
  End Loop;
  v_Nos := Substr(v_Nos, 2);
  If Nvl(n_立即销帐, 0) = 1 Then
    If Mod(单据_In, 10) = 1 Then
      --转收费单
      --No_In;操作员编号_In,操作员姓名_In,退费时间_In,门诊退费_In(0-门诊转住院立即销帐;1-门诊退费模式),入院科室id_In,主页id_In
      If 结算序号_In < 0 Then
        Zl_门诊转住院_收费转出(结算序号_In, Null, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id);
      Else
        For r_No In (Select Distinct a.No
                     From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                     Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
          Zl_门诊转住院_收费转出(Null, r_No.No, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id);
        End Loop;
      End If;
    Else
      --转记帐单
      --No_In;操作员编号_In,操作员姓名_In,退费时间_In
      Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
    End If;
  End If;
  --规则
  -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
  -- 2.主页id_In<>0 :
  If Nvl(入院病区id_In, 0) <> 0 Then
    n_病区id := 入院病区id_In;
  Elsif Nvl(主页id_In, 0) <> 0 Then
    Begin
      Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
      Into n_病区id, v_床号
      From 病人信息 A, 病案主页 B
      Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
    Exception
      When Others Then
        n_病区id := Null;
    End;
  End If;

  If Nvl(n_病区id, 0) = 0 Then
    --以入院科室为准
    n_病区id := Nvl(入院科室id_In, 0);
  End If;

  --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
  --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
  Select 病人id, 开单部门id, 开单人
  Into n_病人id, n_开单部门id, v_开单人
  From 门诊费用记录
  Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;

  --5.产生记帐单
  --需要检查是否已经转出
  Select Count(*)
  Into n_Count
  From 门诊费用记录 A
  Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
   (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
  If n_Count >= 1 Then
    v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
    Raise Err_Item;
  End If;
  If Mod(单据_In, 10) = 1 Then
    --收费按照结算序号查出包含NO号进行处理
    n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    For r_Nos In (Select Distinct c.No
                  From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B, 门诊费用记录 C
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id And c.No = a.No And
                        Mod(c.记录性质, 10) = 1 And c.记录状态 In (1, 3)) Loop
      v_Billno := Nextno(14);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
                              保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价,
                              Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                              Max(执行人) As 执行人, 划价人, Max(记帐单id) As 记帐单id, Max(是否急诊) As 是否急诊, 发生时间, Min(实际票号) As 实际票号,
                              Max(执行状态) As 执行状态
                       From 门诊费用记录
                       Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And
                             Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Nos.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '',
             r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1, 1);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = r_Nos.No And 单据 In (8, 9, 24, 25) And
              费用id In
              (Select ID
               From 门诊费用记录
               Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In
              (Select ID
               From 门诊费用记录
               Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
    End Loop;
  Else
    --记账按照单据NO进行处理
    v_Billno     := Nextno(14);
    n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
  
    Insert Into 住院费用记录
      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
       收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
       记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
      Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
             Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
             发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
             执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
  
    If Nvl(n_立即销帐, 0) = 1 Then
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
    End If;
  
    For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                            费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                            Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人,
                            Max(记帐单id) As 记帐单id, 发生时间, 实际票号, Max(执行状态) As 执行状态
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                     Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间, 实际票号
                     Having Sum(数次) <> 0) Loop
      Select 操作员编号, 操作员姓名
      Into n_操作员编号, v_操作员姓名
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
         开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态)
      Values
        (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
         住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
         r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
         r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
         r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1, r_Clinic.开单部门id,
         r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号, v_操作员姓名, r_Clinic.记帐单id,
         '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态);
      If Nvl(n_立即销帐, 0) = 1 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
           r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, 1);
      End If;
    End Loop;
  
    --8-工本费，9-误差费
    --病人余额
    Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
    Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
      n_返回值 := n_实收合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --病人未结费用
    For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                  From 住院费用记录
                  Where NO = v_Billno And 记录性质 = 2
                  Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
      Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
      End If;
    End Loop;
  
    --6.药品相关数据处理
    For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                  From 住院费用记录 A, 材料特性 B
                  Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
      Update 药品收发记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
      Where NO = No_In And 单据 In (8, 9, 24, 25) And
            费用id In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
      If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
        --更新备货材料
        Update 药品收发记录
        Set 费用id = r_Fee.Id
        Where 单据 = 21 And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
      End If;
      --更新费用审核记录
      Update 费用审核记录
      Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
      Where 费用id In (Select ID
                     From 门诊费用记录
                     Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
      If Sql%NotFound Then
        --未找到数据时，要强制进行对应.
        Insert Into 费用审核记录
          (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
          Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
          From 门诊费用记录
          Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
      End If;
    End Loop;
    Update 未发药品记录
    Set 主页id = 主页id_In, NO = v_Billno
    Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊费用转住院_Insert;
/

--82076:刘尔旋,2015-07-01,门诊转住院三方结算修改
--84935:刘尔旋,2015-05-21,转住院退费处理历史数据
--84787:刘尔旋,2015-05-15,门诊转住院费用历史数据处理问题
--84732:刘尔旋,2015-05-12,门诊转住院生成预交保存三方结算信息
--84649:刘尔旋,2015-05-11,历史费用记录门诊转住院问题
Create Or Replace Procedure Zl_门诊转住院_收费转出
(
  结算序号_In   病人预交记录.结算序号%Type,
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  --门诊退费_In:0-门诊转住院立即销帐;1-门诊退费模式
  -- 门诊退费_In为1时:入院科室id_In和主页ID_IN可以不传入
  n_Count      Number(5);
  n_原结帐id   住院费用记录.结帐id%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  n_组id       财务缴款分组.Id%Type;
  n_病人id     病人信息.病人id%Type;
  v_预交no     病人预交记录.No%Type;
  n_预交金额   病人预交记录.冲预交%Type;
  n_打印id     票据使用明细.打印id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_返回值     病人余额.费用余额%Type;
  n_部分退费   Number(5);
  n_退费条数   Number(5);
  v_结算方式   结算方式.名称%Type;
  v_Nos        Varchar2(3000);
  n_退现       Number(5);
  v_结帐ids    Varchar2(3000);
  v_原结帐ids  Varchar2(3000);
  n_Tempid     病人预交记录.Id%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  n_预交id     病人预交记录.Id%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  If No_In Is Null Then
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A, (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 结算序号_In) B
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = b.结帐id) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
  
    For r_结帐ids In (Select Distinct a.结帐id
                    From 门诊费用记录 A
                    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                          a.记录状态 <> 0) Loop
      v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
    End Loop;
    v_结帐ids := Substr(v_结帐ids, 2);
    Select Count(a.No), Sum(a.实收金额)
    Into n_Count, n_实收金额
    From 门诊费用记录 A
    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '本次结算不是收费或因并发原因他人操作了该结算,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where 结帐id = Abs(结算序号_In) And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    Begin
      Select 1
      Into n_部分退费
      From 门诊费用记录 A
      Where Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
  
    Begin
      Select 0
      Into n_部分退费
      From 门诊费用记录 A
      Where 记录性质 = 11 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select Count(Avg(1))
      Into n_退费条数
      From 病人预交记录 A
      Where a.记录性质 = 3 And a.记录状态 <> 0 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))
      Group By a.结算方式;
    Exception
      When Others Then
        n_退费条数 := 0;
    End;
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
             a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志, a.收入项目id,
             a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.执行人, -1, a.执行时间,
             操作员编号_In, 操作员姓名_In, a.发生时间, 退费时间_In, n_结帐id, -1 * a.结帐金额, a.保险项目否, a.保险大类id, a.统筹金额, a.摘要,
             Decode(Nvl(a.附加标志, 0), 9, 1, 0), a.保险编码, a.费用类型, n_组id, 1
      From 门诊费用记录 A
      Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    --1.2作废预交记录
    --作废冲预交部分
    If n_部分退费 = 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交,
                              卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                             Nvl(冲预交, 0) <> 0
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号,
                                卡号, 交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
          From Dual;
      End Loop;
    
      For v_预交 In (Select 病人id, Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录 A
                   Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                         a.结帐id <> n_结帐id
                   Group By 病人id, Nvl(预交类别, 2)
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), n_预交金额, 1);
          n_返回值 := n_预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      If n_退费条数 = 0 And Nvl(门诊退费_In, 0) = 0 Then
        --只使用了预交，原样退回预交
        For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, Max(结算方式) As 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间,
                                -1 * Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                         From 病人预交记录 A
                         Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                               Nvl(冲预交, 0) <> 0
                         Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                                  交易流水号, 交易说明, 合作单位, 结算性质) Loop
          Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
            Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                   r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                   操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                   r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
            From Dual;
          Select -1 * 冲预交 Into n_预交金额 From 病人预交记录 Where ID = n_Tempid;
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_预交金额, 0)
          Where 病人id = r_Prepay.病人id And 类型 = 1 And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_预交金额, 1);
            n_返回值 := n_预交金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Prepay.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
        Exception
          When Others Then
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
        End;
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null,
                 Null, Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null,
                 -1 * n_原结帐id, 3
          From 病人预交记录 A
          Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                Nvl(冲预交, 0) <> 0
          Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
      End If;
    End If;
  
    --作废门诊缴费及医保部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 Not In (7, 8);
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 校对标志)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质, 1
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 = 7;
  
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));
  
    --2.票据收回
    --可能以前没有打印,无收回
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                        a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
    
      Select Nvl(Max(ID), 0)
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = r_Nos.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
      If n_打印id > 0 Then
        --多张单据循环调用时只能收回一次
        Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        End If;
      End If;
    End Loop;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                         a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                         b.性质 In (1, 2, 3, 4, 7, 8)
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        If c_预交.性质 = 7 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = c_预交.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, c_预交.结算方式, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
               c_预交.合作单位, n_结帐id, -1 * n_结帐id, 1, 3);
          End If;
        Else
          If c_预交.性质 In (3, 4, 8) Then
            v_结算方式 := c_预交.结算方式;
          Else
            If 结算方式_In Is Null Then
              Begin
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
              Exception
                When Others Then
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
              End;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
        
          If c_预交.性质 = 8 Then
            Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id);
          End If;
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - c_预交.冲预交
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
            n_返回值 := c_预交.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
          End If;
          --部分退费情况，退原预交记录
          If c_预交.性质 <> 8 Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
                 c_预交.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select a.Id
                     From 门诊费用记录 A
                     Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                           a.记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      For r_Nos In (Select Distinct NO
                    From 门诊费用记录
                    Where Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And
                          结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) = 1 And 记录状态 = 1;
      End Loop;
      For r_Clinic In (Select Min(a.记录性质) As 记录性质, a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别,
                              a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, Sum(a.数次) As 数次,
                              a.加班标志, a.附加标志, a.收入项目id, a.收据费目, a.标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额,
                              Sum(a.统筹金额) As 统筹金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, Max(a.记帐单id) As 记帐单id,
                              Max(a.是否急诊) As 是否急诊, a.发生时间, Min(a.实际票号) As 实际票号
                       From 门诊费用记录 A
                       Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (2, 3) And Nvl(a.附加标志, 0) Not In (8, 9)
                       Group By a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别, a.收费类别, a.收费细目id,
                                a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, a.加班标志, a.附加标志, a.收入项目id, a.收据费目,
                                a.标准单价, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.发生时间
                       Having Sum(a.数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Clinic.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
           1, r_Clinic.病人id, '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, -1, 1);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
    
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                          a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                          b.性质 In (1, 2, 3, 4, 7, 8)
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If r_Pay.性质 = 7 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = r_Pay.结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, r_Pay.结算方式, Null,
               退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
               r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 1, 3);
          End If;
        Else
          If n_部分退费 = 0 Or n_退费条数 = 1 Then
            v_结算方式 := r_Pay.结算方式;
          Else
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If r_Pay.性质 = 8 Then
            Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id);
          End If;
          If r_Pay.性质 Not In (3, 4, 7, 8) Then
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If r_Pay.性质 In (3, 4, 8) Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
            End If;
          End If;
        
          If r_Pay.性质 <> 8 Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                 r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0;
    Update 病人预交记录
    Set 结算方式 = Null, 卡类别id = Null, 交易流水号 = Null, 交易说明 = Null
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 校对标志 = 1;
  Else
    Select Count(NO), Sum(实收金额) Into n_Count, n_实收金额 From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '单据' || No_In || '不是收费单据或因并发原因他人操作了该单据,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;
  
    Begin
      Select 1 Into n_部分退费 From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 2 And NO = No_In And Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
  
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
             收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额, -1 * 实收金额, 开单部门id,
             开单人, 执行部门id, 划价人, 执行人, -1, 执行时间, 操作员编号_In, 操作员姓名_In, 发生时间, 退费时间_In, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, 统筹金额,
             摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id, 1
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --1.2作废预交记录
    --作废冲预交部分
    For r_结账id In (Select Distinct 结帐id From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 <> 0) Loop
      v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
    End Loop;
    v_原结帐ids := Substr(v_原结帐ids, 2);
    If n_部分退费 = 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交,
                              卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号,
                                卡号, 交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, 1, r_Prepay.结算性质
          From Dual;
      End Loop;
    
      For v_预交 In (Select 病人id, Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录 A, Table(f_Str2list(v_原结帐ids)) B
                   Where 记录性质 In (1, 11) And a.结帐id = b.Column_Value And a.结帐id <> n_结帐id
                   Group By 病人id, Nvl(预交类别, 2)
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), n_预交金额, 1);
          n_返回值 := n_预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      Begin
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
      Exception
        When Others Then
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
      End;
      Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null, Null,
               Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null, -1 * n_原结帐id, 3
        From 病人预交记录 A
        Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))
        Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
    End If;
  
    --作废门诊缴费及医保部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
      From 病人预交记录 A, 结算方式 B
      Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And a.结算方式 = b.名称 And b.性质 Not In (7, 8);
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 校对标志)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质, 1
      From 病人预交记录 A, 结算方式 B
      Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And a.结算方式 = b.名称 And b.性质 = 7;
  
    Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id;
  
    --2.票据收回
    --可能以前没有打印,无收回
    Select Nvl(Max(ID), 0)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
    If n_打印id > 0 Then
      --多张单据循环调用时只能收回一次
      Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      End If;
    End If;
  
    Begin
      Select Count(Avg(1))
      Into n_退费条数
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (2, 3) And NO = No_In
      Group By 结算方式;
    Exception
      When Others Then
        n_退费条数 := 0;
    End;
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And a.No = No_In And a.结算方式 = b.名称 And
                         b.性质 In (1, 2, 3, 4, 7, 8)
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        If c_预交.性质 = 7 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = c_预交.结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, c_预交.结算方式, Null,
               退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号,
               c_预交.交易说明, c_预交.合作单位, n_结帐id, n_结帐id, 1, 3);
          End If;
        Else
          If c_预交.性质 In (3, 4, 8) Then
            v_结算方式 := c_预交.结算方式;
          Else
            If 结算方式_In Is Null Then
              Begin
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
              Exception
                When Others Then
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
              End;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
        
          If c_预交.性质 = 8 Then
            If n_部分退费 = 0 Then
              Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, n_结帐id);
            Else
              v_Err_Msg := '单据' || No_In || '是使用消费卡结算并且存在部分退费,不能转为住院费用.';
              Raise Err_Item;
            End If;
          End If;
        
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - c_预交.冲预交
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
            n_返回值 := c_预交.冲预交;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
          End If;
        
          --部分退费情况，退原预交记录
          If c_预交.性质 <> 8 Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, c_预交.卡类别id, c_预交.结算卡序号, c_预交.卡号, c_预交.交易流水号, c_预交.交易说明,
                 c_预交.合作单位, n_结帐id, n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select ID From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      For r_Clinic In (Select 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                              发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, 划价人, Max(记帐单id) As 记帐单id, 发生时间,
                              实际票号
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间, 实际票号
                       Having Sum(数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
        Values
          (病人费用记录_Id.Nextval, 1, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1, r_Clinic.病人id,
           '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id,
           r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数,
           -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, 1);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
    
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And a.No = No_In And a.结算方式 = b.名称 And
                          (b.性质 In (1, 2, 3, 4, 7, 8))
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If r_Pay.性质 = 7 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = r_Pay.结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, r_Pay.结算方式, Null,
               退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
               r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 1, 3);
          End If;
        Else
          If n_部分退费 = 0 Or n_退费条数 = 1 Then
            v_结算方式 := r_Pay.结算方式;
          Else
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
          If r_Pay.性质 = 8 Then
            If n_部分退费 = 0 Then
              Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, 退费时间_In, n_结帐id);
            Else
              v_Err_Msg := '单据' || No_In || '是使用消费卡结算并且存在部分退费,不能转为住院费用.';
              Raise Err_Item;
            End If;
          End If;
          If r_Pay.性质 Not In (3, 4, 7, 8) Then
          
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If r_Pay.性质 In (3, 4, 8) Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
            End If;
          End If;
        
          If r_Pay.性质 <> 8 Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And NO = No_In And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, No_In, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null,
                 退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号,
                 r_Pay.交易流水号, r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    Delete From 病人预交记录 Where NO = No_In And 摘要 = '预交临时记录';
    Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0;
    Update 病人预交记录
    Set 结算方式 = Null, 卡类别id = Null, 交易流水号 = Null, 交易说明 = Null
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 校对标志 = 1;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_收费转出;
/

--85591:刘尔旋,2015-06-10,服务窗获取医疗卡类别时不再自动绑卡
--84431:刘尔旋,2015-05-05,绑卡过程支持非身份证方式
Create Or Replace Procedure Zl_Third_Findcards
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:获取医疗卡类别 
  --入参:Xml_In: 
  --  <IN>
  --      <ZJH>证件号<ZJH>     //卡号
  --      <ZJLX>证件类型<ZJLX>  //医疗卡类别.名称
  --  </IN>
  --出参:Xml_Out 
  -- <OUTPUT>
  --    <LIST>
  --        <JZK>
  --            <LB>卡类别</LB>
  --            <KH>卡号</KH>
  --        </JZK>
  --        <JZK>
  --            ...
  --        </JZK>
  --    </LIST>
  --    如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  -- </OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_证件号   Varchar2(50);
  v_证件类型 医疗卡类别.名称%Type;
  n_存在     Number(3);
  v_操作员   人员表.姓名%Type;
  n_病人id   病人信息.病人id%Type;
  n_卡类别id 医疗卡类别.Id%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT><LIST></LIST></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/ZJH'), Extractvalue(Value(A), 'IN/ZJLX')
  Into v_证件号, v_证件类型
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_证件类型 Like '%身份证%' Then
    For c_Item In (Select Distinct b.名称, a.卡号
                   From 病人医疗卡信息 A, 医疗卡类别 B
                   Where a.卡类别id = b.Id And Nvl(b.是否启用, 0) = 1 And
                         a.病人id In
                         (Select 病人id
                          From 病人信息
                          Where 身份证号 = v_证件号
                          Union All
                          Select a.病人id
                          From 病人医疗卡信息 A
                          Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And
                                a.卡号 = v_证件号) And
                         (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                          (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) Loop
      v_Temp := '<LB>' || c_Item.名称 || '</LB>';
      v_Temp := v_Temp || '<KH>' || c_Item.卡号 || '</KH>';
      v_Temp := '<JZK>' || v_Temp || '</JZK>';
      Select Appendchildxml(x_Templet, '/OUTPUT/LIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  Else
    For c_Item In (Select Distinct b.名称, a.卡号
                   From 病人医疗卡信息 A, 医疗卡类别 B
                   Where a.卡类别id = b.Id And Nvl(b.是否启用, 0) = 1 And
                         a.病人id In
                         (Select 病人id
                          From 病人医疗卡信息
                          Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And 卡号 = v_证件号) And
                         (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                          (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) Loop
      v_Temp := '<LB>' || c_Item.名称 || '</LB>';
      v_Temp := v_Temp || '<KH>' || c_Item.卡号 || '</KH>';
      v_Temp := '<JZK>' || v_Temp || '</JZK>';
      Select Appendchildxml(x_Templet, '/OUTPUT/LIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;
  --绑定证件
  If v_证件类型 Like '%身份证%' Then
    Select Max(a.病人id)
    Into n_病人id
    From (Select 病人id
           From 病人信息
           Where 身份证号 = v_证件号
           Union All
           Select a.病人id
           From 病人医疗卡信息 A
           Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And a.卡号 = v_证件号 And
                 (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                  (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) A;
  Else
    Select Max(a.病人id)
    Into n_病人id
    From (Select a.病人id
           From 病人医疗卡信息 A
           Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And a.卡号 = v_证件号 And
                 (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                  (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) A;
  End If;

  --自定义查询  
  Zl_Third_Custom_Findcards(Xml_In, x_Templet);

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Findcards;
/

--84458:许华峰,2015-05-05,新版报告文档编辑器取消检查
CREATE OR REPLACE Procedure Zl_影像检查_Cancel
( 
  医嘱id_In     影像检查记录.医嘱id%Type, 
  发送号_In     影像检查记录.发送号%Type, 
  单独执行_In   Number := 0, 
  执行部门id_In 部门表.Id%Type := 0 
  --参数： 
  --      医嘱ID_IN=单独执行的医嘱ID。 
  --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行 
) Is 
  Cursor c_Advice Is 
    Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In; 
  r_Advice c_Advice%RowType; 
 
  n_报告id Number; 
  v_Count  Number; 
  v_Delete Boolean; 
Begin 
  n_报告id := 0; 
 
  --取主医嘱ID 
  Open c_Advice; 
  Fetch c_Advice 
    Into r_Advice; 
  Close c_Advice; 
 
  --如果是成套执行医嘱，则取消检查的时候，删除报告，删除影像检查记录 
  --如果是单独执行医嘱，则只有在取消最后一条医嘱的时候，才删除报告，删除影像检查记录 
  v_Delete := False; 
 
  If Nvl(单独执行_In, 0) = 0 Then 
    v_Delete := True; 
  Else 
    Select Count(*) 
    Into v_Count 
    From 病人医嘱发送 
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id) And 执行状态 = 1 Or 执行状态 = 3; 
    If v_Count = 1 Then 
      Select Count(*) Into v_Count From 病人医嘱发送 Where 医嘱id = 医嘱id_In; 
      If v_Count = 1 Then 
        v_Delete := True; 
      End If; 
    End If; 
  End If; 
 
  --删除报告信息和影像信息 
  If v_Delete = True Then 
    Begin 
      Select 病历id Into n_报告id From 病人医嘱报告 Where 医嘱id = r_Advice.组id; 
    Exception 
      When Others Then 
        Null; 
    End; 
 
    Delete From 影像危急值记录 Where 医嘱id = 医嘱id_In; 
 
    Delete 电子病历记录 Where ID = n_报告id; 
 
    Delete From 影像检查记录 Where 医嘱id = r_Advice.组id;
    
    Delete From 影像报告记录 Where 医嘱id = r_Advice.组id;
  End If; 
 
  --调用统一的医嘱执行Cancel过程 
  Zl_病人医嘱执行_Cancel(医嘱id_In, 发送号_In, Null, 单独执行_In, 执行部门id_In); 
 
  --先处理医嘱执行Cancel之后，再设置病人医嘱发送表的状态,PACS中有些字段定义不一样，要特殊处理 
  --取消医嘱执行 
  If Nvl(单独执行_In, 0) = 0 Then 
    Update 病人医嘱发送 
    Set 首次时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null 
    Where 发送号 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id); 
  Else 
    Update 病人医嘱发送 
    Set 首次时间 = Null, 末次时间 = Null, 执行间 = Null, 执行状态 = 0, 执行过程 = 0, 结果阳性 = Null 
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
  End If; 
 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_影像检查_Cancel;
/

--85053:刘尔旋,2015-05-21,获取合作单位科室问题
--84885:刘尔旋,2015-05-20,支付宝问题集中修改
--84449:刘尔旋,2015-05-04,获取可挂号科室计划时间范围的问题
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室

  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Temp      Varchar(5000); --临时XML
  x_Templet   Xmltype; --模板XML
  n_查询天数  Number(5);
  n_Add_Lists Number(3);
  v_合作单位  合作单位安排控制.合作单位%Type;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW')
  Into n_查询天数, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  If v_合作单位 Is Null Then
    For r_Dept In (Select Distinct a.科室id, b.名称
                   From 挂号安排 A, 部门表 B
                   Where a.停用日期 Is Null And a.科室id = b.Id) Loop
    
      If Nvl(n_Add_Lists, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
        n_Add_Lists := 1;
      End If;
      v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
      Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  Else
    For r_Dept In (Select Distinct 科室id, 名称
                   From (Select b.科室id, d.名称
                          From (Select a.Id
                                 From 挂号安排 A
                                 Where a.停用日期 Is Null And Not Exists
                                  (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                 Union All
                                 Select a.Id
                                 From 挂号安排 A, 合作单位安排控制 B
                                 Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                               挂号安排计划 C, 部门表 D
                          Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + n_查询天数) Or
                                (c.生效时间 Between Sysdate And Sysdate + n_查询天数) Or
                                (c.失效时间 Between Sysdate And Sysdate + n_查询天数)) And Not Exists
                           (Select 1 From 合作单位计划控制 Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id
                          Union All
                          Select b.科室id, d.名称
                          From (Select a.Id
                                 From 挂号安排 A
                                 Where a.停用日期 Is Null And Not Exists
                                  (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                 Union All
                                 Select a.Id
                                 From 挂号安排 A, 合作单位安排控制 B
                                 Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B, 部门表 D
                          Where a.Id = b.Id And Not Exists
                           (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id)) Loop
      If Nvl(n_Add_Lists, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
        n_Add_Lists := 1;
      End If;
      v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
      Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Getdeptlist;
/

--84447:刘兴洪,2015-05-04,增加支付宝充值及报警接口
Create Or Replace Procedure Zl_Third_Deposit_Recharge
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <ZYID>主页ID</ZYID>
  --        <SFMZ>是否门诊</SFMZ> //1-是门诊,0-住院
  --        <JSLIST>
  --            <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</JSKH>
  --              <JYLSH>交易流水号</JYLSH>
  --              <JYSM>交易说明</JYSM>
  --              <JSFS>支付方式</JSFS> //充值方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>交易金额</JSJE> //充值金额
  --              <ZY>摘要</ZY> 
  --              <SFXFK>是否消费卡</SFXFK> 
  --              <JSHM>结算号码(可以不传)</JSHM> 
  --              <JKDW>缴款单位(可以不传)</JKDW> 
  --              <DWKFH>单位开户行(可以不传)</DWKFH> 
  --              <DWZH>单位帐号(可以不传)</DWZH> 
  --              <HZDW>合作单位(可以不传)</HZDW> 
  --              <EXPENDLIST>  //扩展交易信息
  --                   <EXPEND>
  --                        <JYMC>交易名称</JYMC>
  --                        <JYLR>交易内容</JYLR>
  --                   </EXPEND>
  --              </EXPENDLIST >
  --            </JS>
  --         </JSLIST>
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  v_结算方式   Varchar2(2000);
  v_Nos        Varchar2(4000);
  v_No         病人预交记录.No%Type;
  v_操作员编码 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;

  n_卡类别id   医疗卡类别.Id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  n_主页id     病人预交记录.主页id%Type;
  n_科室id     病人预交记录.科室id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_结算卡序号 病人预交记录.结算卡序号%Type;
  n_预交类别   病人预交记录.预交类别%Type;
  n_消费卡     Number(2);
  n_门诊预存   Number(2);

  d_登记时间 Date;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_Count Number(18);

  Function Zl_结算方式_Get
  (
    卡类别_In   Varchar2,
    消费卡_In   Number,
    卡类别id_In Out 病人预交记录.卡类别id%Type
  ) Return Varchar2 As
    v_名称 Varchar2(200);
  
  Begin
  
    v_结算方式 := Null;
    v_Err_Msg  := Null;
  
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If Nvl(消费卡_In, 0) = 1 Then
    
      If n_卡类别id = 0 Then
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 名称 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
        End;
      
      Else
      
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 编号 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '未找到指定的结算支付信息!';
        End;
      
      End If;
    
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在消费卡管理中设置结算方式';
        Raise Err_Item;
      End If;
      卡类别id_In := n_卡类别id;
    
      Return v_结算方式;
    
    End If;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    卡类别id_In := n_卡类别id;
    Return v_结算方式;
  End Zl_结算方式_Get;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID')),
         To_Number(Extractvalue(Value(A), 'IN/SFMZ'))
  Into n_病人id, n_主页id, n_门诊预存
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_门诊预存, 0) = 0 Then
    n_预交类别 := 2;
  Else
    n_预交类别 := 1;
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许充值!';
    Raise Err_Item;
  
  End If;

  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity;
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;

  n_科室id     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_操作员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  v_Err_Msg := Null;

  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;

  If Nvl(n_主页id, 0) = 0 Then
    n_主页id := Null;
  End If;

  If Nvl(n_科室id, 0) = 0 Then
    n_科室id := Null;
  End If;

  d_登记时间 := Sysdate;

  --2.确定支付方式
  n_Count := 0;
  v_Nos   := Null;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                        Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                        Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                        Extractvalue(b.Column_Value, '/JS/JSHM') As 结算号码,
                        Extractvalue(b.Column_Value, '/JS/JKDW') As 缴款单位,
                        Extractvalue(b.Column_Value, '/JS/DWKFH') As 单位开户行,
                        Extractvalue(b.Column_Value, '/JS/DWZH') As 单位帐号,
                        Extractvalue(b.Column_Value, '/JS/HZDW') As 合作单位,
                        Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
  
    v_No := Nextno(11);
    If v_Nos Is Null Then
      v_Nos := v_No;
    Else
      v_Nos := v_Nos || ',' || v_No;
    End If;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Nvl(c_结算方式.结算金额, 0) = 0 Then
      v_Err_Msg := '传入的充值金额为零,没必要进行充值处理,请检查充值金额是否传入错误!';
      Raise Err_Item;
    End If;
  
    n_结算卡序号 := Null;
    n_卡类别id   := Null;
    n_消费卡     := Nvl(c_结算方式.是否消费卡, 0);
  
    If c_结算方式.结算卡类别 Is Not Null Then
      --三方卡结算
      v_结算方式 := Zl_结算方式_Get(c_结算方式.结算卡类别, n_消费卡, n_卡类别id);
      If Nvl(n_消费卡, 0) = 1 Then
        n_结算卡序号 := n_卡类别id;
        n_卡类别id   := Null;
      End If;
    
    Else
      v_结算方式 := c_结算方式.结算方式;
      If v_结算方式 Is Null Then
        v_Err_Msg := '未确定本次充值的支付方式,请检查支付方式是否传入错误!';
        Raise Err_Item;
      End If;
    End If;
    Zl_病人预交记录_Insert(n_预交id, v_No, Null, n_病人id, n_主页id, n_科室id, c_结算方式.结算金额, v_结算方式, c_结算方式.结算号码, c_结算方式.缴款单位,
                     c_结算方式.单位开户行, c_结算方式.单位帐号, c_结算方式.摘要, v_操作员编码, v_操作员姓名, Null, n_预交类别, n_卡类别id, n_结算卡序号, c_结算方式.结算卡号,
                     c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.合作单位, d_登记时间, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(c_结算方式.Expend, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, n_消费卡, c_结算方式.结算卡号, n_预交id, c_扩展.Jymc || '|' || c_扩展.Jylr, 1);
    End Loop;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前充值的支付方式!';
    Raise Err_Item;
  End If;

  v_Temp := '<YJDH>' || v_Nos || '</YJDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := v_Err_Msg;
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Deposit_Recharge;
/

--84447:刘兴洪,2015-05-04,增加支付宝充值及报警接口
Create Or Replace Procedure Zl_Third_Getalarmline
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <ZYID>主页ID</ZYID> //主页ID不传入或为零表示取门诊
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  n_类型   Number(2);
  v_方案   Varchar2(100);
  n_病人id 病人信息.病人id%Type;
  n_病区id 病人信息.当前病区id%Type;
  n_主页id 病案主页.主页id%Type;

  n_报警值    记帐报警线.报警值%Type;
  n_报警方法  记帐报警线.报警方法%Type;
  v_报警标志1 记帐报警线.报警标志1%Type;
  v_报警标志2 记帐报警线.报警标志2%Type;
  v_报警标志3 记帐报警线.报警标志3%Type;

  n_预交余额   病人余额.预交余额%Type;
  n_费用余额   病人余额.预交余额%Type;
  n_担保额     病人信息.担保额%Type;
  n_Temp       病人余额.预交余额%Type;
  n_险类       病案主页.险类%Type;
  n_医保结算额 保险模拟结算.金额%Type;
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

Begin

  v_Err_Msg := Null;

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID'))
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_主页id, 0) = 0 Then
    n_类型 := 1;
  Else
    n_类型 := 2;
  End If;

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份!';
    Raise Err_Item;
  
  End If;
  n_病区id := 0;
  If Nvl(n_主页id, 0) <> 0 Then
    Begin
      Select Nvl(Nvl(b.当前病区id, a.当前病区id), 0), Decode(担保额, Null, 担保额, Zl_Patientsurety(a.病人id, a.主页id)), b.险类
      Into n_病区id, n_担保额, n_险类
      From 病人信息 A, 病案主页 B
      Where a.病人id = b.病人id And a.病人id = n_病人id And b.主页id = n_主页id And Rownum < 2;
    Exception
      When Others Then
        n_病区id  := Null;
        v_Err_Msg := '未找到病案主页,请检查主页ID是否传入正确!';
      
    End;
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
    If Nvl(n_险类, 0) <> 0 Then
      --医保包含医保模拟计算
      Select Nvl(Sum(金额), 0) Into n_医保结算额 From 保险模拟结算 Where 病人id = n_病人id And 主页id = n_主页id;
    End If;
  Else
    Select Decode(担保额, Null, 担保额, Zl_Patientsurety(病人id, 主页id))
    Into n_担保额
    From 病人信息
    Where 病人id = n_病人id;
  End If;

  v_方案 := Zl_Patiwarnscheme(n_病人id, n_主页id);
  Begin
    Select 报警值, Nvl(报警方法, 1), 报警标志1, 报警标志2, 报警标志3
    Into n_报警值, n_报警方法, v_报警标志1, v_报警标志2, v_报警标志3
    From 记帐报警线
    Where 适用病人 = v_方案 And Nvl(病区id, 0) = Decode(n_类型, 1, 0, n_病区id) And Rownum < 2;
  Exception
    When Others Then
      n_报警值 := 0;
  End;
  Begin
    Select 预交余额, 费用余额
    Into n_预交余额, n_费用余额
    From 病人余额
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类型;
  Exception
    When Others Then
      n_预交余额 := 0;
      n_费用余额 := 0;
  End;
  n_Temp := Nvl(n_预交余额, 0) - Nvl(n_费用余额, 0) + Nvl(n_医保结算额, 0);

  v_Temp := '<YJYE>' || Nvl(n_预交余额, 0) || '</YJYE>';
  v_Temp := v_Temp || '<WJFY>' || Nvl(n_费用余额, 0) || '</WJFY>';
  v_Temp := v_Temp || '<BXMLJE>' || Nvl(n_医保结算额, 0) || '</BXMLJE>';
  v_Temp := v_Temp || '<SYK>' || Nvl(n_Temp, 0) || '</SYK>';
  v_Temp := v_Temp || '<DBE>' || Nvl(n_担保额, 0) || '</DBE>';
  v_Temp := v_Temp || '<BJJE>' || Nvl(n_报警值, 0) || '</BJJE>';

  v_Temp := '<OUTPUT>' || v_Temp || '</OUTPUT>';

  x_Templet := Xmltype(v_Temp);
  Xml_Out   := x_Templet;

Exception
  When Err_Item Then
    v_Temp := v_Err_Msg;
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getalarmline;
/

--85053:刘尔旋,2015-05-21,已建档病人返回病人ID与门诊号
--84885:刘尔旋,2015-05-20,支付宝问题集中修改
--84942:刘尔旋,2015-05-18,调整服务窗建档过程入参格式
--84162:刘尔旋,2015-04-24,建档过程错误返回问题
Create Or Replace Procedure Zl_Third_Buildpatient
(
  Patiinfo_In  In Xmltype,
  Patiinfo_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------
  --参数说明:
  -- 入参 Patiinfo_In:
  --<IN>
  --  <ZJH></ZJH>                 //证件号，目前仅支持身份证号
  --  <ZJLX></ZJLX>                       //证件类型(目前仅支持身份证,为空时默认为身份证)
  --  <XM></XM>                       //姓名
  --  <SJH></SJH>                      //手机号
  --</IN>

  --出参 Patiinfo_Out：
  --<OUTPUT>
  --       <BRID></BRID>                //病人ID
  --       <MZH></MZH>                  //门诊号
  --     <ERROR></ERROR>         //如果有错误返回该节点
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Pati_Id      病人信息.病人id%Type;
  n_Card_Type_Id 医疗卡类别.Id%Type;
  n_Count        Number(5);
  n_Sum          Number(5);
  v_校验位       Varchar2(50);

  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_手机号       病人信息.家庭电话%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  v_操作员       人员表.姓名%Type;
  v_医疗付款方式 病人信息.医疗付款方式%Type;
  n_门诊号       病人信息.门诊号%Type;
  v_证件类型     医疗卡类别.名称%Type;
  v_证件号       病人医疗卡信息.卡号%Type;

  v_Pattern Varchar2(500);
  v_Temp    Varchar2(32767); --临时XML
  v_Err_Msg Varchar2(2000);
  n_存在    Number(2);

  d_出生日期  病人信息.出生日期%Type;
  d_Curr_Time Date;

  Err_Item Exception;
Begin
  Patiinfo_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Sysdate Into d_Curr_Time From Dual;

  --新建病人：姓名、身份证号、手机号（存在家庭电话中）、出生日期、性别、年龄(后面三项可从身份证中获取)。
  Select Extractvalue(Value(I), 'IN/XM'), Extractvalue(Value(I), 'IN/ZJH'), Extractvalue(Value(I), 'IN/SJH'),
         Extractvalue(Value(I), 'IN/ZJLX')
  Into v_姓名, v_证件号, v_手机号, v_证件类型
  From Table(Xmlsequence(Extract(Patiinfo_In, 'IN'))) I;

  Begin
    If v_证件类型 Is Null Then
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 Like '%身份证%') And Rownum < 2;
    Else
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 = v_证件类型) And Rownum < 2;
    End If;
    n_存在 := 1;
  Exception
    When Others Then
      n_存在 := 0;
  End;

  If Nvl(n_存在, 0) = 1 Then
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    Select 门诊号 Into n_门诊号 From 病人信息 Where 病人id = n_Pati_Id;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  Else
    If v_姓名 Is Null Then
      v_Err_Msg := '传人姓名为空!';
      Raise Err_Item;
    End If;
    If v_证件类型 Like '%身份证%' Or v_证件类型 Is Null Then
      v_身份证号 := v_证件号;
    Else
      v_Err_Msg := '目前不支持身份证以外的方式建档！';
      Raise Err_Item;
    End If;
  
    If v_身份证号 Is Null Then
      v_Err_Msg := '传人身份证号为空!';
      Raise Err_Item;
    Else
      --身份证合法验证
      v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
    
      --地区检验
      If Instr(v_Pattern, Substr(v_身份证号, 1, 2)) = 0 Then
        v_Err_Msg := '身份证前两位地区码不正确!';
        Raise Err_Item;
      End If;
      --身份证长度检查
      If Length(v_身份证号) = 15 Then
        --检查身份证号:15位身份证号要求全部为数字
        v_Pattern := '^\d{15}$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符，请检查!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 15, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
        v_Pattern  := '^[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(v_身份证号, 7, 6), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
        End If;
      Elsif Length(v_身份证号) = 18 Then
        -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
        v_Pattern := '^\d{17}[0-9Xx]$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 17, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
        v_Pattern  := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(v_身份证号, 7, 8), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
          --计算校验位
          n_Sum     := (To_Number(Substr(v_身份证号, 1, 1)) + To_Number(Substr(v_身份证号, 11, 1))) * 7 +
                       (To_Number(Substr(v_身份证号, 2, 1)) + To_Number(Substr(v_身份证号, 12, 1))) * 9 +
                       (To_Number(Substr(v_身份证号, 3, 1)) + To_Number(Substr(v_身份证号, 13, 1))) * 10 +
                       (To_Number(Substr(v_身份证号, 4, 1)) + To_Number(Substr(v_身份证号, 14, 1))) * 5 +
                       (To_Number(Substr(v_身份证号, 5, 1)) + To_Number(Substr(v_身份证号, 15, 1))) * 8 +
                       (To_Number(Substr(v_身份证号, 6, 1)) + To_Number(Substr(v_身份证号, 16, 1))) * 4 +
                       (To_Number(Substr(v_身份证号, 7, 1)) + To_Number(Substr(v_身份证号, 17, 1))) * 2 +
                       To_Number(Substr(v_身份证号, 8, 1)) * 1 + To_Number(Substr(v_身份证号, 9, 1)) * 6 +
                       To_Number(Substr(v_身份证号, 10, 1)) * 3;
          n_Count   := Mod(n_Sum, 11);
          v_Pattern := '10X98765432';
          v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
          If v_校验位 <> Upper(Substr(v_身份证号, 18, 1)) Then
            v_Err_Msg := '身份证号码不正确，请检查。';
            Raise Err_Item;
          End If;
        End If;
      Else
        v_Err_Msg := '身份证长度不对,请检查。';
        Raise Err_Item;
      End If;
    
      If Nvl(v_年龄, '_') = '_' Then
        v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
      End If;
    End If;
  
    Select 名称 Into v_医疗付款方式 From 医疗付款方式 Where 缺省标志 = 1;
    Select 病人信息_Id.Nextval Into n_Pati_Id From Dual;
    n_门诊号 := Nextno(3);
    Insert Into 病人信息
      (病人id, 姓名, 身份证号, 家庭电话, 出生日期, 性别, 年龄, 登记时间, 门诊号, 医疗付款方式)
      Select n_Pati_Id, v_姓名, v_身份证号, v_手机号, d_出生日期, v_性别, v_年龄, d_Curr_Time, n_门诊号, v_医疗付款方式
      From Dual;
  
    --病人信息保存完后，完成医疗卡绑定（二代身份证卡类别的绑定）
    Begin
      If v_证件类型 Is Null Then
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 Like '%身份证%' And Rownum < 2;
      Else
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 = v_证件类型 And Rownum < 2;
      End If;
    Exception
      When No_Data_Found Then
        v_Err_Msg := '身份证卡类别不存在！';
        Raise Err_Item;
    End;
    Select b.姓名 Into v_操作员 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
  
    Zl_医疗卡变动_Insert(11, n_Pati_Id, n_Card_Type_Id, Null, v_身份证号, '创建虚拟卡', Null, v_操作员, d_Curr_Time);
  
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  End If;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatient;
/

--85658:刘尔旋,2015-06-12,挂号状态新增不就诊状态
--85238:刘尔旋,2015-05-28,获取挂号历史记录新增出参医生姓名
--84162:刘尔旋,2015-04-24,获取挂号记录状态添加失效号
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //卡号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS')
  Into n_病人id, n_记录数
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_记录数 := Nvl(n_记录数, 0);

  For r_Reg In (Select a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                       Decode(a.记录性质, 2, '预约中', Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                       Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1
                Order By a.登记时间 Desc) Loop
    If n_记录数 <> 0 Then
      Begin
        Select Decode(记录状态, 0, 0, 1)
        Into n_是否付款
        From 门诊费用记录
        Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
      Exception
        When Others Then
          n_是否付款 := r_Reg.是否付款;
      End;
      If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
        v_状态 := '已失效';
      Else
        v_状态 := r_Reg.状态;
      End If;
      v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' || r_Reg.科室id ||
                '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' || '<YYSJ>' ||
                To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 || '</ZXZT>' || '<DDFK>' ||
                n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' || r_Reg.医生姓名 || '</YSXM>' ||
                '</GH>';
      Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      n_记录数 := n_记录数 - 1;
    End If;
  End Loop;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Reghistory;
/

--84162:刘尔旋,2015-04-28,服务窗支持预约接收
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_Count    Number(18);
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;
  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH'))
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.收费类别, b.收入项目id,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And
                       b.收费细目id Not In (Select 收费细目id From 收费特定项目 Where 特定项目 = '病历费') And Nvl(b.费用状态, 0) = 0 And
                       b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, 0, Null, Null, Null, Null, c_费用.开单部门id, c_费用.执行部门id);
      n_结帐金额 := n_结帐金额 + c_费用.实收金额;
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        n_预交支付 := c_结算方式.结算金额;
      Else
        If Nvl(n_普通支付, 0) = 0 Then
          n_普通支付 := c_结算方式.结算金额;
          v_结算方式 := c_结算方式.结算方式;
          If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
            Begin
              n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_结算卡序号 := 0;
            End;
            If n_结算卡序号 = 0 Then
              Begin
                Select 编号
                Into n_结算卡序号
                From 卡消费接口目录
                Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的消费卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            End If;
          Else
            Begin
              n_卡类别id := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_卡类别id := 0;
            End;
            If n_卡类别id = 0 Then
              Begin
                Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的医疗卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
          End If;
          v_结算卡号   := c_结算方式.结算卡号;
          v_交易流水号 := c_结算方式.交易流水号;
          v_交易说明   := c_结算方式.交易说明;
          v_摘要       := c_结算方式.摘要;
        Else
          v_Err_Msg := '挂号结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --预约接收
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
  
    Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别, v_结算方式,
                     n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号, v_结算卡号,
                     v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1);
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := v_Err_Msg;
    -- Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    -- Xml_Out := x_Templet;
    Raise_Application_Error(-20101, v_Temp);
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/

--86000:刘尔旋,2015-06-25,新增预约接收模式
--84162:刘尔旋,2015-04-28,服务窗支持预约接收
Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select *
    From (Select a.Id, a.病人id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                        a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And
                 Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, Max(病人id) As 病人id, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, 预交类别, NO)
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), ID, NO, 预交类别;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date     Date;
  d_预约时间 门诊费用记录.发生时间%Type;
  d_发生时间 Date;
  d_排队时间 Date;
  n_时段     Number := 0;
  n_存在     Number := 0;
  v_排队序号 排队叫号队列.排队序号%Type;
  n_结算模式 病人信息.结算模式%Type;
  n_票种     票据使用明细.票种%Type;
  v_付款方式 病人挂号记录.医疗付款方式%Type;
  n_接收模式 Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter(64, 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      v_Err_Msg := '当前预约挂号单已被其它人接收';
      Raise Err_Item;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), 现金支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (r_Deposit.病人id, Nvl(r_Deposit.预交类别, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

--84188:马政,2015-04-22,卫材外购核查可用数量不对处理
Create Or Replace Procedure Zl_材料外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  零售差价_In   In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  注册证号_In   In 药品收发记录.注册证号%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  高值材料_In   In Varchar2 := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  内部条码_In   In 药品收发记录.内部条码%Type := Null,
  费用id_In     In 药品收发记录.费用id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  财务审核_In   In Number := 0,
  批准文号_In   In 药品收发记录.批准文号%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No         应付记录.No%Type; --应付记录的NO 
  v_商品名     收费项目目录.名称%Type; --通用名称 
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID 
  n_应付id     应付记录.Id%Type; --应付记录的ID 
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID 
  n_入出系数   药品收发记录.入出系数%Type; --入出系数 
  n_批次       药品收发记录.批次%Type := Null; --批次 
  n_库房分批   Integer; --是否分批核算    1:分批；0：不分批 
  n_在用分批   Integer; --是否在用分批       1:分批；0：不分批 
  v_可用数量   药品库存.可用数量%Type;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  --取该材料的名称 
  v_产地 := '';
  Select 名称, 规格, 计算单位 Into v_商品名, v_规格, v_单位 From 收费项目目录 Where ID = 材料id_In;

  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  --财务审核直接用传过来的批次
  If 财务审核_In = 0 Then
    If 费用id_In > 0 And 批次_In > 0 Then
      n_批次 := 批次_In;
    Else
      If n_在用分批 = 0 Then
        If n_库房分批 = 1 Then
          Begin
            Select Distinct 0
            Into n_库房分批
            From 部门性质说明
            Where ((工作性质 Like '发料部门') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
          Exception
            When Others Then
              n_库房分批 := 1;
          End;
        
          If n_库房分批 = 1 Then
            n_批次 := v_Lngid;
          End If;
        End If;
      Else
        n_批次 := v_Lngid;
      End If;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 30 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额,
     扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 发药方式, 配药人, 配药日期, 注册证号, 用法, 商品条码, 内部条码, 费用id, 批准文号)
  Values
    (v_Lngid, 1, 15, No_In, 序号_In, 库房id_In, 供药单位id_In, n_入出类别id, n_入出系数, 材料id_In, Decode(退货_In, -1, 批次_In, n_批次), 产地_In,
     批号_In, 生产日期_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In, 扣率_In, 零售价_In,
     退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, Decode(退货_In, -1, 1, 0), 核查人_In, 核查日期_In, 注册证号_In, 零售差价_In,
     商品条码_In, 内部条码_In, 费用id_In, 批准文号_In);

  --高值材料信息 
  If Length(高值材料_In) > 0 Then
    Insert Into 收发记录补充信息
      (收发id, 科室, 病人姓名, 住院号, 床号)
    Values
      (v_Lngid, Substr(高值材料_In, 1, Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 1) + 1, Instr(高值材料_In, ',', 1, 2) - Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 2) + 1, Instr(高值材料_In, ',', 1, 3) - Instr(高值材料_In, ',', 1, 2) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 3) + 1, Length(高值材料_In)));
  End If;

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
  
    Select 应付记录_Id.Nextval Into n_应付id From Dual;
  
    --如果是第一笔明细,则产生应付记录的NO 
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量,
       采购价, 采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码)
    Values
      (n_应付id, 0, 1, 材料id_In, 序号_In, 供药单位id_In, v_No, 5, v_Lngid, No_In, 退货_In * 零售金额_In, 随货单号_In, 发票号_In, 发票日期_In,
       退货_In * Decode(发票号_In, Null, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 库房id_In, 发票代码_In);
  End If;

  --退货时下可用数量 
  If 退货_In = -1 And Nvl(费用id_In, 0) <> 2 Then
    --检查库存 
    Begin
      Select Nvl(可用数量, 0)
      Into v_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
    Exception
      When Others Then
        v_可用数量 := 0;
    End;
  
    If v_可用数量 - 实际数量_In < 0 Then
      v_Err_Msg := '[ZLSOFT]第' || 序号_In || '行的可用数量不够,请检查[ZLSOFT]';
      Raise Err_Item;
    End If;
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - 实际数量_In
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Insert;
/

--86000:刘尔旋,2015-06-25,新增预约接收模式
--84885:刘尔旋,2015-05-28,支付宝问题集中修改
--84162:刘尔旋,2015-04-28,服务窗支持预约接收
Create Or Replace Procedure Zl_病人挂号汇总_Update
(
  医生姓名_In   挂号安排.医生姓名%Type,
  医生id_In     挂号安排.医生id%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  预约标志_In   Number := 0, --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约 
  号码_In       挂号安排.号码%Type := Null,
  三方调用_In   Number := 0 --是否接口调用
) As
  --发生时间_In:预约时,为预约时间;否则为登记时间 
  v_Date    Date;
  n_预约数  病人挂号汇总.已约数%Type;
  n_时段    Number := 0;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_接收模式 Number := 0;
Begin
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = 号码_In And Rownum <= 1
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = 号码_In And d.生效时间 > Sysdate And Rownum <= 1);
  Exception
    When Others Then
      n_时段 := 0;
  End;
  n_接收模式 := Nvl(zl_GetSysParameter(64, 1111), 0);
  --分时段的号别，只能当天接收
  If n_时段 = 1 And Nvl(预约标志_In, 0) = 2 And 三方调用_In = 0 And n_接收模式 = 0 Then
    If Trunc(发生时间_In) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能当天接收！';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(预约标志_In, 0) <> 2 Or 三方调用_In = 1 Then
    v_Date := Trunc(发生时间_In);
  Else
    If n_接收模式 = 0 Then
      v_Date := Trunc(Sysdate);
    Else
      v_Date := Trunc(发生时间_In);
    End If;
  End If;

  n_预约数 := 0;
  If Nvl(预约标志_In, 0) <> 1 Then
    --非预约挂号;或预约接收 
    If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
      --1.减去预约日期的预约数; 
      --2-加上当前预约日期的挂号数; 
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1
      Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
            (号码 = 号码_In Or 号码 Is Null)
      Returning 已约数 Into n_预约数;
    
      If n_预约数 < 0 Then
        Update 病人挂号汇总
        Set 已约数 = 0
        Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
              (号码 = 号码_In Or 号码 Is Null)
        Returning 已约数 Into n_预约数;
      End If;
      n_预约数 := 1;
    Elsif Nvl(预约标志_In, 0) = 3 Then
      n_预约数 := 1;
    End If;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
    Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
          Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
      Values
        (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
         Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
    End If;
  Else
    --预约挂号 
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) + 1
    Where 日期 = Trunc(v_Date) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(v_Date), 执行部门id_In, 收费细目id_In, 医生姓名_In, Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号汇总_Update;
/

--84162:刘尔旋,2015-04-28,服务窗支持挂号接收
--84183:刘尔旋,2015-04-21,服务窗预约挂号缴费
Create Or Replace Procedure Zl_Third_Waitingpay
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取待付款收费单(即付款单据)
  --入参:Xml_In: 
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --</IN>
  --出参:Xml_Out 
  --<OUTPUT>
  --        <FYLIST> 如果为空表示未找到数据
  --            <FY>
  --                <NO>单据号</NO>                           
  --                <KDSJ>开单时间</SJ>                           
  --                <KDKS>开单科室</KDKS>                     
  --                <YS></YS>                           //医生
  --                <SFGH></SFGH>                       //是否挂号单,0-收费单,1-挂号单
  --                <FMLIST>
  --                    <FM>
  --                        <MC></MC>                           //费目名称
  --                        <MXLIST>
  --                            <MX>
  --                                <XMMC></XMMC>           //项目名称
  --                                <GG></GG>                   //规格
  --                                <DW></DW>               //单位
  --                                <SL></SL>                   //数量
  --                                <DJ></DJ>                   //单价
  --                                <YSJE></YSJE>               //应收金额
  --                                <SSJE></SSJE>               //实收金额
  --                            </MX>
  --                        </MXLIST>
  --                    </FM>
  --                </FMLIST>
  --            </FY>
  --        </FYLIST>
  --        <ERROR><MSG></MSG></ERROR>                  //如果有错误返回
  --</OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_挂号单     Varchar2(10);
  n_预约挂号单 Number(3);
  n_Count      Number(18);

  v_Temp Varchar2(32767); --临时XML 
  v_No   Varchar2(50);
  v_费目 Varchar2(50);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH') Into v_挂号单 From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;

  --1.检查是否有挂号单
  Select Count(*) Into n_Count From 病人挂号记录 A Where NO = v_挂号单;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  If Nvl(n_Count, 0) > 1 Then
    v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
    Raise Err_Item;
  End If;

  Begin
    Select 1 Into n_预约挂号单 From 病人挂号记录 Where NO = v_挂号单 And 记录性质 = 2;
  Exception
    When Others Then
      n_预约挂号单 := 0;
  End;
  --2.费用汇总
  v_No   := '-_';
  v_费目 := '-_';
  If n_预约挂号单 = 0 Then
    --正常挂号
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No In (Select Replace(摘要, '划价:', '')
                                From 病人挂号记录
                                Where NO = v_挂号单 And Instr(摘要, '划价:') > 0) And Mod(b.记录性质, 10) = 1 And
                       Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And
                       b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位
                 Union All
                 
                 Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 病人医嘱记录 A1, 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where A1.挂号单 = v_挂号单 And Mod(b.记录性质, 10) = 1 And A1.Id = b.医嘱序号 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And
                       b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位
                 Order By 顺序号, NO, 收据费目, 序号) Loop
      If v_No <> c_费用.No Then
        v_Temp := '<NO>' || c_费用.No || '</NO>';
        v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
        v_Temp := v_Temp || '<KDKS>' || c_费用.开单科室 || '</KDKS>';
        v_Temp := v_Temp || '<YS>' || c_费用.开单人 || '</YS>';
        v_Temp := v_Temp || '<SFGH>' || n_预约挂号单 || '</SFGH>';
        v_Temp := '<FYLIST NO="' || c_费用.No || '"><FY>' || v_Temp || '<FMLIST></FMLIST></FY></FYLIST>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        v_No   := c_费用.No;
        v_费目 := '-_';
      End If;
    
      If v_费目 <> c_费用.收据费目 Then
      
        v_费目 := c_费用.收据费目;
      
        v_Temp := '<MC>' || v_费目 || '</MC>';
        v_Temp := '<FM SJFM="' || v_费目 || '">' || v_Temp || '<MXLIST></MXLIST></FM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    
      v_Temp := '<XMMC>' || c_费用.名称 || '</XMMC>';
      v_Temp := v_Temp || '<GG>' || c_费用.规格 || '</GG>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_费用.计算单位 || '</DW>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DJ>' || c_费用.单价 || '</DJ>';
      v_Temp := v_Temp || '<YSJE>' || c_费用.实收金额 || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || c_费用.实收金额 || '</SSJE>';
    
      v_Temp := '<MX>' || v_Temp || '</MX>';
    
      Select Appendchildxml(x_Templet,
                             '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST/FM[@SJFM="' || v_费目 || '"]/MXLIST',
                             Xmltype(v_Temp))
      
      Into x_Templet
      From Dual;
    End Loop;
  Else
    --预约挂号
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_挂号单 And b.记录性质 = 4 And
                       b.收费细目id Not In (Select 收费细目id From 收费特定项目 Where 特定项目 = '病历费') And Nvl(b.费用状态, 0) = 0 And
                       b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位) Loop
      If v_No <> c_费用.No Then
        v_Temp := '<NO>' || c_费用.No || '</NO>';
        v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
        v_Temp := v_Temp || '<KDKS>' || c_费用.开单科室 || '</KDKS>';
        v_Temp := v_Temp || '<YS>' || c_费用.开单人 || '</YS>';
        v_Temp := v_Temp || '<SFGH>' || n_预约挂号单 || '</SFGH>';
        v_Temp := '<FYLIST NO="' || c_费用.No || '"><FY>' || v_Temp || '<FMLIST></FMLIST></FY></FYLIST>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        v_No   := c_费用.No;
        v_费目 := '-_';
      End If;
    
      If v_费目 <> c_费用.收据费目 Then
      
        v_费目 := c_费用.收据费目;
      
        v_Temp := '<MC>' || v_费目 || '</MC>';
        v_Temp := '<FM SJFM="' || v_费目 || '">' || v_Temp || '<MXLIST></MXLIST></FM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    
      v_Temp := '<XMMC>' || c_费用.名称 || '</XMMC>';
      v_Temp := v_Temp || '<GG>' || c_费用.规格 || '</GG>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_费用.计算单位 || '</DW>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DJ>' || c_费用.单价 || '</DJ>';
      v_Temp := v_Temp || '<YSJE>' || c_费用.实收金额 || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || c_费用.实收金额 || '</SSJE>';
    
      v_Temp := '<MX>' || v_Temp || '</MX>';
    
      Select Appendchildxml(x_Templet,
                             '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST/FM[@SJFM="' || v_费目 || '"]/MXLIST',
                             Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Waitingpay;
/

--84136:刘鹏飞,2015-04-21,入住病区时检查入住的病区和变动记录待入住的病区是否一致
Create Or Replace Procedure Zl_病人变动记录_Inunit
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  床号_In       Varchar2,
  病区id_In     病案主页.当前病区id%Type,
  护理等级id_In 病案主页.护理等级id%Type,
  当前病况_In   病案主页.当前病况%Type,
  是否陪伴_In   病案主页.是否陪伴%Type,
  责任护士_In   病案主页.责任护士%Type,
  入病区时间_In 病人变动记录.开始时间%Type,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  主床位_In     病案主页.出院病床%Type
) As
  -----------------------------------------------------------
  --说明：完成病人入病区处理
  --参数：
  --       床号_IN:为空表示家庭病床,否则为"床号1,床号2,...床号n",多个床号时,表示包房。
  -----------------------------------------------------------
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In)) a, 病人变动记录 b
    
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 入病区时间_In;
  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  Cursor c_Futureinfo Is
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 0 And 开始时间 > 入病区时间_In;

  r_Futureinfo   c_Futureinfo %Rowtype;
  b_Isdel        Boolean;
  r_Endinfo      c_Endinfo%Rowtype;
  r_Oldinfo      c_Oldinfo%Rowtype;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;
  v_床号     Varchar2(255);
  v_当前床号 床位状况记录.床号%Type;
  v_等级id   床位状况记录.等级id%Type;
  v_病区id   病案主页.当前病区id%Type;
  v_科室id   病案主页.出院科室id%Type;
  v_终止人员 病人变动记录.终止人员%Type;
  v_Count    Number;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  Open c_Oldinfo; --必须先打开

  --入病区
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 2;

  If v_Count = 0 Then
    v_Error := '病人当前不处于转病区状态,可能已经撤转病区，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Begin
    Select 病区id, 操作员姓名
    Into v_病区id, v_终止人员
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;
  Exception
    When Others Then
      v_病区id := 0;
  End;
  --v_病区id=0说明病人可能是转科状态
  If v_病区id = 0 Then
    v_Error := '病人当前不处于转病区状态，而是处于转科状态，操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;
  If v_病区id <> 病区id_In Then
    v_Error := '当前该病人即将入住的病区和变动记录中实际要入住病区不符,操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的，请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  --产生新变动
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%Rowcount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院病床 = Decode(床号_In, Null, Null, 主床位_In), 当前病区id = 病区id_In,
      护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 当前病况 = 当前病况_In, 责任护士 = 责任护士_In, 是否陪伴 = 是否陪伴_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --更新病人信息
  Update 病人信息
  Set 当前病区id = 病区id_In, 当前床号 = Decode(床号_In, Null, Null, 主床位_In)
  Where 病人id = 病人id_In;

  --更新在院病人
  v_科室id := 0;
  Begin
    Update 在院病人 Set 病区id = Nvl(病区id_In, 0) Where 病人id = 病人id_In;
    If Sql%Rowcount = 0 Then
      Select 出院科室id Into v_科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    End If;
  Exception
    When Others Then
      v_科室id := 0;
  End;
  If v_科室id > 0 Then
    Insert Into 在院病人 (病人id, 科室id, 病区id) Values (病人id_In, v_科室id, Nvl(病区id_In, 0));
  End If;

  --退除病人当前床位
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --记录上一步的终止操作人员
  If r_Oldinfo.终止时间 Is Not Null Then
    v_变动终止时间 := r_Oldinfo.终止时间;
    v_变动终止原因 := r_Oldinfo.终止原因;
    v_变动终止人员 := r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员, 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
    --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    Update 病人变动记录
    Set 终止时间 = 入病区时间_In, 终止原因 = 15, 终止人员 = v_终止人员
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Not Null And 终止时间 Is Null;
  End If;

  Delete From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始原因 = 15 And 开始时间 Is Null And 终止时间 Is Null;

  --新的床位记录
  If 床号_In Is Null Then
    --仅家庭病床
    Insert Into 病人变动记录
      (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名, 终止时间, 终止原因, 终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, 0, 病区id_In, r_Oldinfo.科室id, r_Oldinfo.医疗小组id,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), Null, Null, 责任护士_In, r_Oldinfo.经治医师, r_Oldinfo.主治医师, r_Oldinfo.主任医师,
       当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    --如果修改了床位，则必须修改停止到将来的变动数
    If c_Oldinfo%Rowcount <> 1 Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
    End If;
    --如果有停到将来的情况，将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)
    Update 病人变动记录
    Set 床位等级id = Null, 床号 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Else
    v_床号  := 床号_In || ',';
    v_Count := 0;
    While v_床号 Is Not Null Loop
      v_Count := v_Count + 1;
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
    End Loop;
    --如果修改了床位，则必须修改停止到将来的变动数
    b_Isdel := False;
    If c_Oldinfo%Rowcount <> v_Count Then
      --删除所有将来的附加床位的变动
      Delete From 病人变动记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 附加床位 = 1 And 开始时间 > 入病区时间_In;
      b_Isdel := True;
    End If;
  
    v_Count := 0;
    v_床号  := 床号_In || ',';
  
    While v_床号 Is Not Null Loop
      v_当前床号 := Substr(v_床号, 1, Instr(v_床号, ',') - 1);
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      Insert Into 病人变动记录
        (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
         操作员姓名, 终止时间, 终止原因, 终止人员)
      Values
        (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 入病区时间_In, 15, Decode(主床位_In, v_当前床号, 0, 1), 病区id_In, r_Oldinfo.科室id,
         r_Oldinfo.医疗小组id, Decode(护理等级id_In, 0, Null, 护理等级id_In), v_等级id, v_当前床号, 责任护士_In, r_Oldinfo.经治医师,
         r_Oldinfo.主治医师, r_Oldinfo.主任医师, 当前病况_In, 操作员编号_In, 操作员姓名_In, v_变动终止时间, v_变动终止原因, v_变动终止人员);
    
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 病区id_In And 床号 = v_当前床号 And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || v_当前床号 || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, r_Oldinfo.科室id, 科室id)
      Where 病区id = 病区id_In And 床号 = v_当前床号;
    
      If b_Isdel = True Then
        --如果有停到将来的情况且有床位数变动,将将来的变动信息同步更新(附加床位和主床位记录不相同的字段。)和插入附加床位数据。
        If 主床位_In = v_当前床号 Then
          --如果是主床位则修改将来的主记录信息，如果不是主床位，就新插入数据
          Update 病人变动记录
          Set 床位等级id = v_等级id, 床号 = v_当前床号
          Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In And 附加床位 = 0;
        Else
          Open c_Futureinfo; --必须先打开
          Fetch c_Futureinfo
            Into r_Futureinfo;
          --循环停到将来的数据，进行附加床位插入
          While c_Futureinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 科室id, 医疗小组id, 床位等级id, 床号, 经治医师, 主治医师, 主任医师, 操作员编号, 操作员姓名, 终止时间, 终止原因,
               终止人员)
            Values
              (病人变动记录_Id.Nextval, r_Futureinfo.病人id, r_Futureinfo.主页id, r_Futureinfo.开始时间, r_Futureinfo.开始原因, 1,
               r_Futureinfo.科室id, r_Futureinfo.医疗小组id, v_等级id, v_当前床号, r_Futureinfo.经治医师, r_Futureinfo.主治医师,
               r_Futureinfo.主任医师, r_Futureinfo.操作员编号, r_Futureinfo.操作员姓名, r_Futureinfo.终止时间, r_Futureinfo.终止原因,
               r_Futureinfo.终止人员);
            Fetch c_Futureinfo
              Into r_Futureinfo;
          End Loop;
          Close c_Futureinfo;
        End If;
      End If;
    
      v_床号  := Substr(v_床号, Instr(v_床号, ',') + 1);
      v_Count := v_Count + 1;
    End Loop;
  End If;
  --如果有停到将来的情况，将将来的变动信息同步更新（附加床位的记录和主记录相同的字段）
  Update 病人变动记录
  Set 病区id = 病区id_In, 责任护士 = 责任护士_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 病情 = 当前病况_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 入病区时间_In;
  Close c_Oldinfo;
  Close c_Endinfo;
  --对有效的医嘱(未停止、作废的长嘱，未发送的临嘱)，为原病区执行的，将执行科室自动更换为新的病区
  Update 病人医嘱记录
  Set 执行科室id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行科室id = r_Oldinfo.病区id And 医嘱状态 Not In (4, 8, 9);
  --对未审核的记帐划价单，为原病区执行的，将执行科室自动更换为新的病区
  Update 住院费用记录
  Set 执行部门id = 病区id_In
  Where 病人id = 病人id_In And 主页id = 主页id_In And 执行部门id = r_Oldinfo.病区id And 记录状态 = 0;
  --已发送且未执行且未记帐审核或未收费的医嘱发送记录，如果执行科室是原病区的，应更新为当前病区
  Update 病人医嘱发送 a
  Set a.执行部门id = 病区id_In
  Where a.执行部门id = r_Oldinfo.病区id And a.执行状态 = 0 And Exists
   (Select 1
         From 住院费用记录 b
         Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 0 And 病人id = 病人id_In And 主页id = 主页id_In);

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;

  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Inunit;
/

--83258:刘尔旋,2015-04-17,挂号锁号重复问题
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <RQ>2013-11-21 09:00</RQ>     //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码         挂号安排.号码%Type;
  d_日期         Date;
  n_操作类型     Number(3);
  n_序号控制     Number(3);
  n_存在         Number(3);
  n_分时段       Number(3);
  n_限号数       挂号安排限制.限号数%Type;
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  n_号序         挂号序号状态.序号%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  n_状态         挂号序号状态.状态%Type;
  v_合作单位     合作单位安排控制.合作单位%Type;
  n_合约模式     Number(3);
  n_启用合作单位 Number(3);
  v_Temp         Varchar2(32767); --临时XML
  v_Optemp       Varchar2(300);
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_Optemp := Zl_Identity(1);
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_Optemp From Dual;
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_操作员姓名 From Dual;
  If n_操作类型 = 0 Then
    --解锁
    Begin
      Select 1
      Into n_Exists
      From 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码 And
            Rownum < 2;
    Exception
      When Others Then
        n_Exists := 0;
    End;
    If n_Exists = 1 Then
      Delete 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码;
      v_Temp := '<HX>' || n_号序 || '</HX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      v_Temp := '<ERROR><MSG>没有发现需要解锁的序号</MSG></ERROR>';
      Raise Err_Item;
    End If;
  End If;

  If n_操作类型 = 1 Then
    --锁号
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    Begin
      Select 序号控制, ID
      Into n_序号控制, n_计划id
      From (Select 序号控制, ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_日期 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If n_序号控制 = 1 Then
      If Nvl(n_计划id, 0) <> 0 Then
        Begin
          Select 1 Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位计划控制
          Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号计划时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '<ERROR><MSG>传入时间' || d_日期 || '的序号已被使用</MSG></ERROR>';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号计划时段
                       Where 计划id = n_计划id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
              
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 序号 = 0 And 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位计划控制 A
                         Where 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      Else
        Begin
          Select 1 Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位安排控制
          Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号安排时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '<ERROR><MSG>传入时间' || d_日期 || '的序号已被使用</MSG></ERROR>';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号安排时段
                       Where 安排id = n_安排id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 序号 = 0 And 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位安排控制 A
                         Where 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '<ERROR><MSG>传入号别' || v_号码 || '的所有序号已被用完</MSG></ERROR>';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Lockno;
/

--85657:刘尔旋,2015-06-12,服务窗挂号更新年龄
--84162:刘尔旋,2015-04-28,服务窗支持预约接收
--83258:刘尔旋,2015-04-17,挂号保存三方结算交易信息
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号目前仅支持一个，结构与收费一致，以后可扩展
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码       挂号安排.号码%Type;
  d_发生时间   Date;
  d_原始时间   Date;
  d_登记时间   Date;
  v_金额       Varchar2(200);
  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  n_分时段     Number(3);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名
  
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Extractvalue(b.Column_Value, '/JS/JSKLB'), Extractvalue(b.Column_Value, '/JS/JSKH'),
         Extractvalue(b.Column_Value, '/JS/JSFS'), Extractvalue(b.Column_Value, '/JS/JYLSH'),
         Extractvalue(b.Column_Value, '/JS/JYSM')
  Into v_卡类别名称, v_结算卡号, v_结算方式, v_流水号, v_说明
  From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;
  Begin
    Select b.结算方式, b.Id Into v_结算方式, n_卡类别id From 医疗卡类别 B Where b.名称 = v_卡类别名称 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现该结算卡的相关信息';
      Raise Err_Item;
  End;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;
  Select Decode(To_Char(d_发生时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  Begin
    Select ID
    Into n_计划id
    From (Select ID
           From 挂号安排计划
           Where 号码 = v_号码 And d_发生时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                 Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
           Order By 生效时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
  End;
  If Nvl(n_计划id, 0) <> 0 Then
    --从计划读取信息
    Select a.项目id, b.科室id, a.医生姓名, a.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                   Null), Nvl(a.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = n_计划id And b.Id = a.安排id;
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号计划时段
      Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号计划时段
            Where 计划id = n_计划id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  Else
    --从安排读取信息
    Select b.项目id, b.科室id, b.医生姓名, b.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                   Null), Nvl(b.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排 B
    Where b.Id = n_安排id;
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号安排时段
            Where 安排id = n_安排id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  End If;

  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费细目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Rownum < 2;

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;

  If Trunc(d_发生时间) <> Trunc(Sysdate) Then
    Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null, v_流水号,
                     v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
  Else
    Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null, v_流水号,
                     v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
  End If;

  For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                        Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
    Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
  End Loop;

  v_Temp := '<GHDH>' || v_No || '</GHDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/

--84093:曾超,2015-04-24,83939问题关联修改Execute 
CREATE OR REPLACE Procedure Zl_检验标本记录_报告审核
(
  Id_In     检验标本记录.Id%Type,
  审核人_In 检验标本记录.审核人%Type := Null,
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null
) Is

  --未审核的费用行(不包含药品)
  Cursor C_Verify(V_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = V_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where V_医嘱id In (ID, 相关id)))
    Union All
    Select Distinct 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = V_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where V_医嘱id In (ID, 相关id)))
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor C_Samplequest(V_微生物 In Number) Is
    Select Distinct 医嘱id,病人来源
    From (Select a.医嘱id,b.病人来源
           From 检验项目分布 a ,检验标本记录 b
           Where 0 = V_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null and a.标本id = b.id
           Union
           Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 1 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select B.Id As 医嘱id,a.病人来源 From 检验标本记录 A, 病人医嘱记录 B Where A.Id = Id_In And A.医嘱id = B.相关id);

  Cursor C_Stuff
  (
    V_No     Varchar2,
    V_主页id Number
  ) Is
    Select NO, 单据, 库房id
    From 未发药品记录
    Where NO = V_No And 单据 In (24, 25, 26) And 库房id Is Not Null And Not Exists
     (Select 1 From Dual Where Zl_Getsysparameter(Decode(V_主页id, Null, 92, 63)) = '1') And Exists
     (Select A.序号
           From 住院费用记录 A, 材料特性 B
           Where A.记录性质 = 2 And A.记录状态 = 1 And A.No = V_No And A.收费细目id = B.材料id And B.跟踪在用 = 1
           Union All
           Select A.序号
           From 门诊费用记录 A, 材料特性 B
           Where A.记录性质 = 2 And A.记录状态 = 1 And A.No = V_No And A.收费细目id = B.材料id And B.跟踪在用 = 1)
    Order By 库房id;

  V_执行 Number(1);
  V_No   病人医嘱发送.No%Type;
  V_性质 病人医嘱发送.记录性质%Type;
  V_序号 Varchar2(1000);

  V_Count      Number(18);

  V_微生物标本 Number(1) := 0;
  V_主页id     Number(18);
  V_婴儿       Number(1);
  V_年龄       Varchar2(10);
  V_仪器       Number(18);
  V_Intloop    Number;
  Err_Custom Exception;
  V_Error Varchar2(100);
Begin
  Select Nvl(婴儿, 0), 年龄 Into V_婴儿, V_年龄 From 检验标本记录 Where ID = Id_In;

  --执行后自动审核对应的记帐划价单(不包含药品)
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(81), '0')) Into V_执行 From Dual;

  V_微生物标本 := 0;
  Begin
    Select 1 Into V_微生物标本 From 检验标本记录 Where 微生物标本 = 1 And ID = Id_In;
  Exception
    When Others Then
      V_微生物标本 := 0;
  End;

  --1.置本标本的状态及审核人和时间
  Update 检验标本记录
  Set 审核人 = Decode(审核人_In, Null, 人员姓名_In, 审核人_In), 审核时间 = Sysdate, 样本状态 = 2
  Where ID = Id_In;

  --记录审核过程
  Insert Into 检验操作记录
    (ID, 标本id, 操作类型, 操作员, 操作时间)
  Values
    (检验操作记录_Id.Nextval, Id_In, 0, Decode(审核人_In, Null, 人员姓名_In, 审核人_In), Sysdate);

  --2.检查当前标本相关的申请的相关标本是否完成审核
  For R_Samplequest In C_Samplequest(V_微生物标本) Loop

    V_Count := 0;

    If V_微生物标本 = 0 Then
      Begin
        Select Nvl(Count(1), 0)
        Into V_Count
        From 检验标本记录
        Where 样本状态 < 2 And ID In (Select 标本id From 检验项目分布 Where 医嘱id = R_Samplequest.医嘱id);
      Exception
        When Others Then
          V_Count := 0;
      End;
    End If;

    --r_SampleQuest.医嘱id申请已经完成,处理后续环节
    If V_Count = 0 Then


        --1.置申请单的执行状态
        Update 病人医嘱发送
        Set 执行状态 = 1,完成人 = 人员姓名_In,完成时间 = Sysdate 
        Where 医嘱id In (Select ID From 病人医嘱记录 Where R_Samplequest.医嘱id In (ID, 相关id));

    if R_Samplequest.病人来源 = 2 then
      --2.费用执行处理
      Update 住院费用记录
      Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
      Where 收费类别 Not In ('5', '6', '7') And
            (医嘱序号, 记录性质, NO) In
            (Select 医嘱id, 记录性质, NO
             From 病人医嘱附费
             Where 医嘱id = R_Samplequest.医嘱id
             Union All
             Select 医嘱id, 记录性质, NO
             From 病人医嘱发送
             Where 医嘱id In (Select ID From 病人医嘱记录 Where R_Samplequest.医嘱id In (ID, 相关id)));
     else
       Update 门诊费用记录
      Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
      Where 收费类别 Not In ('5', '6', '7') And
            (医嘱序号, 记录性质, NO) In
            (Select 医嘱id, 记录性质, NO
             From 病人医嘱附费
             Where 医嘱id = R_Samplequest.医嘱id
             Union All
             Select 医嘱id, 记录性质, NO
             From 病人医嘱发送
             Where 医嘱id In (Select ID From 病人医嘱记录 Where R_Samplequest.医嘱id In (ID, 相关id)));
     end if;

      --3.自动审核记帐
      If V_执行 = 1 Then
        For R_Verify In C_Verify(R_Samplequest.医嘱id) Loop
          If R_Verify.No || ',' || R_Verify.记录性质 <> V_No || ',' || V_性质 Then
            If V_序号 Is Not Null Then
              If V_性质 = 1 Then
                Zl_门诊记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In, Substr(V_序号, 2));
              Elsif V_性质 = 2 Then
                Zl_住院记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In, Substr(V_序号, 2));
              End If;
            End If;
            V_序号 := Null;
          End If;
          V_No   := R_Verify.No;
          V_性质 := R_Verify.记录性质;
          V_序号 := V_序号 || ',' || R_Verify.序号;
        End Loop;
        If V_序号 Is Not Null Then
          If V_性质 = 1 Then
            Zl_门诊记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In, Substr(V_序号, 2));
          Elsif V_性质 = 2 Then
            Zl_住院记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In, Substr(V_序号, 2));
          End If;
	  V_序号 := Null;
        End If;
      End If;

      --审核试剂消耗单
      V_Intloop := 1;
      Select 仪器id Into V_仪器 From 检验标本记录 Where ID = Id_In;
      For R_检验试剂 In (Select C.材料id, C.数量
                     From 病人医嘱记录 A, 检验报告项目 B, 检验试剂关系 C
                     Where A.相关id = R_Samplequest.医嘱id And A.诊疗项目id = B.诊疗项目id And B.报告项目id = C.项目id And C.仪器id = V_仪器) Loop
        Zl_检验试剂记录_Insert(R_Samplequest.医嘱id, V_Intloop, R_检验试剂.材料id, R_检验试剂.数量);
        V_Intloop := V_Intloop + 1;
      End Loop;
      Select Count(*) Into V_Intloop From 检验试剂记录 Where 医嘱id = R_Samplequest.医嘱id And NO Is Null;
      If V_Intloop > 1 Then
        V_No := Nextno(14);
        Update 检验试剂记录 Set NO = V_No Where 医嘱id = R_Samplequest.医嘱id;
      End If;
      If V_No Is Not Null Then

        Zl_检验试剂记录_Bill(R_Samplequest.医嘱id, V_No);

        V_主页id := Null;
        Select 主页id Into V_主页id From 病人医嘱记录 A Where ID = R_Samplequest.医嘱id;

        If V_主页id Is Null Then
          Zl_门诊记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In);
        Else
          Zl_住院记帐记录_Verify(V_No, 人员编号_In, 人员姓名_In);
        End If;

        --如果记帐没有自动发料,则自动发料,否则不处理
        For R_Stuff In C_Stuff(V_No, V_主页id) Loop
          Zl_材料收发记录_处方发料(R_Stuff.库房id, 25, V_No, 人员姓名_In, 人员姓名_In, 人员姓名_In, 1, Sysdate);
        End Loop;
      End If;
    End If;
  End Loop;
  begin 
  Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
       Using 9, 0 || ',' || Id_In;
   Exception
     When Others Then
       Null;
   End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检验标本记录_报告审核;
/

--84018:张德婷,2015-04-16,配合支付宝进行调整
Create Or Replace Procedure Zl_药品收发记录_部门退药
(
  Billid_In     In 药品收发记录.Id%Type,
  People_In     In 药品收发记录.审核人%Type,
  Date_In       In 药品收发记录.审核日期%Type,
  批号_In       In 药品库存.上次批号%Type := Null,
  效期_In       In 药品库存.效期%Type := Null,
  产地_In       In 药品库存.上次产地%Type := Null,
  退药数量_In   In 药品收发记录.实际数量%Type := Null,
  退药库房_In   In 药品收发记录.库房id%Type := Null,
  退药人_In     In 药品收发记录.领用人%Type := Null,
  Intdigit_In   In Number := 2,
  门诊_In       In Number := 2,
  汇总发药号_In In 药品收发记录.汇总发药号%Type := Null
) Is
  --只读变量
  Int记录状态   药品收发记录.记录状态%Type;
  Int执行状态   住院费用记录.执行状态%Type;
  Bln部分退药   Number;
  Lng入出类别id Number(18);
  Strno         药品收发记录.No%Type;
  Int单据       药品收发记录.单据%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Dbl实际数量   药品收发记录.实际数量%Type;
  Dbl实际金额   药品收发记录.零售金额%Type;
  Dbl实际成本   药品收发记录.成本金额%Type;
  Dbl实际差价   药品收发记录.差价%Type;
  Lng费用id     药品收发记录.费用id%Type;
  n_零售价      药品收发记录.零售价%Type;
  n_是否变价    Number;
  n_时价分批    Number;

  --20020731 Modified by zyb
  --处理退药时，分批核算性质改变后的处理
  Lng新批次 药品收发记录.批次%Type;
  Lng分批   药品规格.药房分批%Type;
  Lng批次   药品收发记录.批次%Type; --原批次

  Str批号        药品收发记录.批号%Type; --原批号
  Date效期       药品收发记录.效期%Type; --原效期
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次采购价   药品库存.上次采购价%Type;
  v_上次产地     药品库存.上次产地%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_批准文号     药品库存.批准文号%Type;

  n_记录性质   住院费用记录.记录性质%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  n_付数       药品收发记录.付数%Type;
  n_原始数量   药品收发记录.实际数量%Type;
  v_冲销记录id 药品收发记录.Id%Type;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  v_配药确认 药房配药控制.配药确认%Type;
  v_配药     药房配药控制.配药%Type;
  v_排队状态 Number(1);
  v_执行时间 药品收发记录.审核日期%Type;
Begin
  If 退药数量_In Is Not Null Then
    If 退药数量_In = 0 Then
      Return;
    End If;
  End If;

  --获取该收发记录的单据、药品ID、库房ID
  Select a.单据, a.No, a.库房id, a.药品id, a.费用id, a.入出类别id, a.记录状态, Nvl(a.批次, 0), a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号,
         a.成本价, a.付数, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.零售价, Nvl(b.是否变价, 0) 是否变价
  Into Int单据, Strno, Lng库房id, Lng药品id, Lng费用id, Lng入出类别id, Int记录状态, Lng批次, Str批号, Date效期, n_上次供应商id, v_上次产地, d_上次生产日期,
       v_批准文号, n_上次采购价, n_付数, n_原始数量, n_零售价, n_是否变价
  From 药品收发记录 A, 收费项目目录 B
  Where a.药品id = b.Id And a.Id = Billid_In;

  Begin
    Select Nvl(配药确认, 0), Nvl(配药, 0)
    Into v_配药确认, v_配药
    From 药房配药控制
    Where 药房id = Lng库房id And Rownum = 1;
  
  Exception
    When Others Then
      v_配药确认 := 0;
      v_配药     := 0;
      Null;
  End;

  If v_配药确认 = 0 And v_配药 = 0 Then
    v_排队状态 := 2;
  Elsif v_配药确认 = 1 Then
    v_排队状态 := 0;
  Elsif v_配药 = 1 Then
    v_排队状态 := 1;
  End If;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into Dbl实际数量, Dbl实际金额, Dbl实际成本, Dbl实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = Strno And 单据 = Int单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = Billid_In);

  --如果允许退药数为零，表示已退药
  If Dbl实际数量 = 0 Then
    v_Error := '该单据已被其他操作员退药，请刷新后再试！';
    Raise Err_Custom;
  End If;
  If Nvl(退药数量_In, 0) > Dbl实际数量 Then
    v_Error := '该单据已被其他操作员部分退药，请刷新后再试！';
    Raise Err_Custom;
  End If;

  --获取该药品当前是否分批的信息
  Select Nvl(药房分批, 0) Into Lng分批 From 药品规格 Where 药品id = Lng药品id;
  --如果是部分退药，则重新计算零售金额及差价
  Bln部分退药 := 0;
  If Not (退药数量_In Is Null Or Nvl(退药数量_In, 0) = Dbl实际数量) Then
    Bln部分退药 := 1;
  End If;
  If Bln部分退药 = 1 Then
    Dbl实际金额 := Round(Dbl实际金额 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际成本 := Round(Dbl实际成本 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际差价 := Round(Dbl实际差价 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际数量 := 退药数量_In;
  End If;

  If n_原始数量 = 退药数量_In Then
    Dbl实际数量 := 退药数量_In / n_付数;
  Else
    n_付数 := 1;
  End If;

  --lng分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If Lng分批 = 0 And Lng批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    Lng分批 := 2;
  Elsif Lng分批 <> 0 And Lng批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    Lng分批 := 3;
  Else
    If Lng批次 = 0 Then
      Lng分批 := 0;
    Else
      Lng分批 := 1;
    End If;
  End If;
  --判断是否时价分批
  If (Lng分批 = 1 Or Lng分批 = 3) And n_是否变价 = 1 Then
    n_时价分批 := 1;
  Else
    n_时价分批 := 0;
  End If;

  --记录状态的含义有所变化
  --冲销的记录状态        :iif(int记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(int记录状态=1,0,1)+2
  --等待发药的记录状态    :iif(int记录状态=1,0,1)+3

  --产生冲销记录
  Select 药品收发记录_Id.Nextval Into v_冲销记录id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 外观, 领用人, 供药单位id, 生产日期, 批准文号, 汇总发药号, 发药方式, 注册证号)
    Select v_冲销记录id, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 1, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地,
           批号, 效期, n_付数, -dbl实际数量, -dbl实际数量, 成本价, -dbl实际成本, 扣率, 零售价, -dbl实际金额, -dbl实际差价, 摘要, People_In, Date_In, 配药人,
           People_In, Date_In, 费用id, 单量, 频次, 用法, 发药窗口, 退药库房_In, 退药人_In, 供药单位id, 生产日期, 批准文号, 汇总发药号_In, 发药方式, 注册证号
    From 药品收发记录
    Where ID = Billid_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发药
  Select 药品收发记录_Id.Nextval Into Lng新批次 From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号)
    Select Lng新批次, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 3, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(Lng分批, 1, 批次, 3, Lng新批次, 0), Decode(Lng分批, 3, 产地_In, 1, 产地, 产地), Decode(Lng分批, 3, 批号_In, 1, 批号, Null),
           Decode(Lng分批, 3, 效期_In, 1, 效期, Null), n_付数, Dbl实际数量, Dbl实际数量, 成本价, Dbl实际成本, 扣率, 零售价, Dbl实际金额, Dbl实际差价, 摘要,
           填制人, 填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号
    From 药品收发记录
    Where ID = Billid_In;

  --更新费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into Int执行状态
  From 药品收发记录
  Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Not Null;
  
  If 门诊_In=1 Then
      Select 记录性质, 收费类别 Into n_记录性质, v_收费类别 From 门诊费用记录 Where ID = Lng费用id;
  End If;
  
  If Int执行状态 = 0 Then
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null Where ID = Lng费用id;
    End If;
  Else
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态 Where ID = Lng费用id;
    End If;
  End If;

  --插入未发药品记录
  Begin
    If 门诊_In = 1 Then
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, Null, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份,
                      b.产品合格证
               From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    
      --修改处方类型
      Zl_Prescription_Type_Update(Strno, n_记录性质, Lng药品id, v_收费类别);
    Else
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                      c.身份, b.产品合格证
               From 住院费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 2 Where ID = Billid_In;

  --修改药品库存(反冲库存)
  If Lng分批 <> 3 Then
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + Dbl实际数量 * n_付数, 实际金额 = Nvl(实际金额, 0) + Dbl实际金额, 实际差价 = Nvl(实际差价, 0) + Dbl实际差价
    Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lng批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 零售价, 上次批号, 效期, 上次供应商id, 上次采购价, 上次产地, 上次生产日期, 批准文号, 平均成本价)
      Values
        (Lng库房id, Lng药品id, Decode(Lng分批, 2, 0, Lng批次), 1, Dbl实际数量 * n_付数, Dbl实际金额, Dbl实际差价,
         Decode(n_时价分批, 1, n_零售价, Null), Decode(Lng分批, 1, Str批号, Null), Decode(Lng分批, 1, Date效期, Null), n_上次供应商id,
         n_上次采购价, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 效期, 性质, 实际数量, 实际金额, 实际差价, 零售价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 平均成本价)
    Values
      (Lng库房id, Lng药品id, Lng新批次, 效期_In, 1, Dbl实际数量 * n_付数, Dbl实际金额, Dbl实际差价, Decode(n_时价分批, 1, n_零售价, Null), 批号_In,
       产地_In, n_上次供应商id, n_上次采购价, d_上次生产日期, v_批准文号, n_上次采购价);
  End If;

  Delete 药品库存
  Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --处理调价修正
  Zl_药品收发记录_调价修正(v_冲销记录id);
  
  Begin
    --移动支付宝项目在发药后动态调用生成推送信息的过程
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 7, Billid_In || ',' ||退药数量_In || ',' || 门诊_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_部门退药;
/

--84053:许华峰,2015-04-16,服务窗消息推送
CREATE OR REPLACE Procedure ZL_排队叫号队列_呼叫
(
  队列名称_IN 排队叫号队列.队列名称%Type,
  排队状态_IN 排队叫号队列.排队状态%Type,
  呼叫医生_IN 排队叫号队列.呼叫医生%Type,
  站点_IN     排队语音呼叫.站点%Type,
  业务类型_IN 排队叫号队列.业务类型%Type,
  业务ID_IN   排队叫号队列.业务ID%Type := Null
) Is
  --排队状态_IN = 1时，是直呼
  --排队状态_IN 0-正常排队，1呼叫，2弃号 ，3-暂停，4-完成就诊，6回诊,7顺呼
  --如果 队列名称_IN 为空，则通过 业务类型_IN+业务ID_IN 确定队列名称
  --顺呼的时候 队列名称_IN 不能为空；
  v队列ID         排队叫号队列.ID%Type;
  v队列名称     排队叫号队列.队列名称%Type;
  v最大回诊序号 排队叫号队列.回诊序号%Type;
Begin
     --呼叫
     If 排队状态_IN = 1 Or 排队状态_In = 7 Then
           If 队列名称_IN Is Null Then
              Begin
                   Select 队列名称 Into v队列名称 From 排队叫号队列 Where 业务类型 = 业务类型_IN And 业务ID = 业务ID_IN;
              Exception
                When Others Then
                  Null;
              End;
           Else
               v队列名称 := 队列名称_IN;
           End if;
           --先把前一个被呼叫的检查置为弃号
           Update  排队叫号队列 Set 排队状态 = 7 Where 队列名称 = v队列名称 And 呼叫医生 = 呼叫医生_IN And 排队状态 = 1;

            --直呼
            Begin
            Select id Into v队列ID From 排队叫号队列 Where 业务类型 = 业务类型_IN And 业务ID = 业务ID_IN ;
            Exception
              When Others Then
                Null;
            End;
            
           If v队列ID Is Not Null Then
             Update  排队叫号队列 Set 排队状态 = 1,呼叫医生 = 呼叫医生_IN,呼叫时间 =Sysdate Where id =v队列ID;
             
             --插入 排队语音呼叫
             If 排队状态_IN = 1 Then
                ZL_排队语音呼叫_INSERT(v队列ID,站点_IN,0);
             Else
                --(如果顺乎时，需要用候诊的方式进行呼叫，则将以下语句修改为 “ZL_排队语音呼叫_INSERT(v队列ID,站点_IN,1);”)  
                ZL_排队语音呼叫_INSERT(v队列ID,站点_IN,0);
             End If;
           End if;
           
           Begin
             Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
               Using 13, 业务类型_IN || ',' || 业务ID_IN;
           Exception
             When Others Then
               Null;
           End;
     elsif 排队状态_IN = 6 then
          select Nvl(Max(回诊序号), 0) + 1 into v最大回诊序号 from 排队叫号队列;
          Update  排队叫号队列 Set 排队状态 = 0, 回诊序号=v最大回诊序号, 排队时间=sysdate Where 业务类型 = 业务类型_IN And 业务ID = 业务ID_IN;
     else
     --恢复、弃号、暂停、完成就诊
           Update  排队叫号队列 Set 排队状态 = 排队状态_IN,呼叫医生 = 呼叫医生_IN Where 业务类型 = 业务类型_IN And 业务ID = 业务ID_IN;

     End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_排队叫号队列_呼叫;
/

--84458:许华峰,2015-05-05,新版报告文档编辑器检查状态更新
CREATE OR REPLACE Procedure Zl_影像检查_状态更新
(
  医嘱id_In   影像检查记录.医嘱id%Type,
  发送号_In   影像检查记录.发送号%Type,
  报告Id_In   影像报告记录.ID%Type,
  执行过程_In 病人医嘱发送.执行过程%Type,
  删除报告_In Number := 0, --1删除报告，无报告完成
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  执行部门id_In 门诊费用记录.执行部门id%Type := Null,
  完成时间_In  病人医嘱发送.完成时间%Type :=Null
) 
Is
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_部门ID   部门表.id%Type;
  v_完成人   人员表.姓名%Type;
  v_完成时间 date;
Begin
  --取得报告完成人和时间
  if 执行过程_In=6  Then
    v_完成人:=操作员姓名_In;
    v_完成时间:=完成时间_In;
  end if;

  --取当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null  Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
    v_部门ID   := 执行部门id_In;
  Else
    v_Temp     := Zl_Identity;
    v_部门ID   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  end if;

  If 删除报告_In <> 0 Then
    Delete 影像报告记录 Where 医嘱ID = 医嘱id_In;
    Zl_影像报告标记_Clear(医嘱id_In);
  End If;

  Update 病人医嘱发送
  Set 执行状态 = Decode(执行过程_In, 6, 1, 3), 执行过程 = 执行过程_In ,完成人=v_完成人,完成时间=v_完成时间,采样时间=sysdate
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;

    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In || ',' || 报告Id_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;

    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用
    zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In,0,v_人员编号,v_人员姓名, v_部门ID);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_状态更新;
/

--84046:许华峰,2015-04-16,服务窗消息推送
CREATE OR REPLACE Procedure Zl_影像检查_State
(   
  医嘱id_In   影像检查记录.医嘱id%Type,   
  发送号_In   影像检查记录.发送号%Type,   
  执行过程_In 病人医嘱发送.执行过程%Type,   
  删除报告_In Number := 0, --1删除报告，无报告完成     
  操作员编号_In 人员表.编号%Type := Null,  
  操作员姓名_In 人员表.姓名%Type := Null,  
  执行部门id_In 门诊费用记录.执行部门id%Type := Null, 
  完成时间_In  病人医嘱发送.完成时间%Type :=Null
) Is   
    
  v_Temp     Varchar2(255);   
  v_人员编号 人员表.编号%Type;   
  v_人员姓名 人员表.姓名%Type;   
  v_部门ID   部门表.id%Type;  
  n_报告id   Number; 
  v_完成人   人员表.姓名%Type;   
  v_完成时间 date; 
   
Begin   
     
  --取得报告完成人和时间 
  if 执行过程_In=6  Then 
    v_完成人:=操作员姓名_In; 
    v_完成时间:=完成时间_In; 
  end if; 
 
  --取当前操作人员   
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null  Then   
    v_人员编号 := 操作员编号_In;   
    v_人员姓名 := 操作员姓名_In;   
    v_部门ID   := 执行部门id_In;   
  Else     
    v_Temp     := Zl_Identity;   
    v_部门ID   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);   
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);   
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);   
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);   
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);   
  end if;  
                  
  n_报告id   := 0;   
   
  If 删除报告_In <> 0 Then   
    Begin   
      Select 病历id Into n_报告id From 病人医嘱报告 Where 医嘱id = 医嘱id_In;   
    Exception   
      When Others Then   
        Null;   
    End;   
    Delete 电子病历记录 Where ID = n_报告id;   
    Zl_影像报告标记_Clear(医嘱id_In);   
  End If;   
   
  Update 病人医嘱发送   
  Set 执行状态 = Decode(执行过程_In, 6, 1, 3), 执行过程 = 执行过程_In ,完成人=v_完成人,完成时间=v_完成时间,采样时间=sysdate 
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));   
       
  If 执行过程_In = 5 Then   
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;  
     
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then   
    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;   
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用
    zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In,0,v_人员编号,v_人员姓名, v_部门ID);       
  End If;     
Exception   
  When Others Then   
    zl_ErrorCenter(SQLCode, SQLErrM);   
End Zl_影像检查_State;
/

--84041:刘硕,2015-04-16,消息推送
Create Or Replace Procedure Zl_门诊医嘱发送_Insert
(
  医嘱id_In     病人医嘱发送.医嘱id%Type,
  发送号_In     病人医嘱发送.发送号%Type,
  记录性质_In   病人医嘱发送.记录性质%Type,
  No_In         病人医嘱发送.No%Type,
  记录序号_In   病人医嘱发送.记录序号%Type,
  发送数次_In   病人医嘱发送.发送数次%Type,
  首次时间_In   病人医嘱发送.首次时间%Type,
  末次时间_In   病人医嘱发送.末次时间%Type,
  发送时间_In   病人医嘱发送.发送时间%Type,
  执行状态_In   病人医嘱发送.执行状态%Type,
  执行部门id_In 病人医嘱发送.执行部门id%Type,
  计费状态_In   病人医嘱发送.计费状态%Type,
  First_In      Number := 0,
  样本条码_In   病人医嘱发送.样本条码%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：填写病人医嘱发送记录 
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
           a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In
    Group By Nvl(a.相关id, a.Id), a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
             a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志;
  r_Advice c_Advice%RowType;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  --其它临时变量 
  v_Temp     Varchar2(255);
  v_Count    Number;
  v_病人性质 病案主页.病人性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_入院方式 入院方式.名称%Type;
  d_开始时间 病人医嘱记录.开始执行时间%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  If 首次时间_In Is Null Then
    Select 开始执行时间 Into d_开始时间 From 病人医嘱记录 Where ID = 医嘱id_In;
  End If;

  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 Then
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
  
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理:临嘱发送后自动停止 
    --------------------------------------------------------------------------------------- 
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
        --可能没有 
        停嘱时间 = 发送时间_In,
        --要作为发送时间显示 
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作 
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --1-留观;2-住院; 
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录 
      
        --删除超过挂号有效天数的预约登记 
        Begin
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0;
        Exception
          When Others Then
            v_Count := 0;
        End;
        If Nvl(v_Count, 0) > 0 Then
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0);
          v_Count := 0;
        End If;
      
        If v_Count = 0 Then
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null;
        End If;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间);
        End If;
        If v_Count = 0 Then
          If r_Advice.操作类型 = '1' Then
            --留观医嘱,将病人在"开始时间"留观到临床执行科室 
            Begin
              v_病人性质 := 2;
              Select Decode(服务对象, 1, 1, 2)
              Into v_病人性质
              From 部门性质说明
              Where 工作性质 = '临床' And 部门id = 执行部门id_In;
            Exception
              When Others Then
                Null;
            End;
          Elsif r_Advice.操作类型 = '2' Then
            --住院医嘱,将病人在"开始时间"登记到临床执行科室 
            v_病人性质 := 0;
          End If;
        
          Open c_Pati(r_Advice.病人id);
          Fetch c_Pati
            Into r_Pati;
        
          v_入院方式 := Null;
          If r_Advice.紧急标志 = 1 Then
            v_入院方式 := '急诊';
          Else
            Select Decode(急诊, 1, '急诊', Null)
            Into v_入院方式
            From 病人挂号记录
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1;
          End If;
        
          If v_病人性质 = 1 Then
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          Else
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          End If;
          Close c_Pati;
        End If;
      End If;
    End If;
  
    Close c_Advice;
  End If;

  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null));

  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 3, 发送号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱发送_Insert;
/

--85591:刘尔旋,2015-06-11,服务窗不自动绑卡
--84431:刘尔旋,2015-05-05,绑卡过程支持非身份证方式
--83951:刘尔旋,2015-04-28,服务窗挂号支持费别打折
Create Or Replace Procedure Zl_Third_Getpati_Unique
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人的唯一标识(病人ID) 
  --入参:Xml_In: 
  --   <IN> 
  --     <ZJH>证件号</ZJH>     //卡号
  --     <ZJLX>证件类型</ZJLX>  //医疗卡类别.名称
  --     <XM>姓名</XM> 
  --     <KH>卡号</KH> 
  --     <KLB>卡类别</KLB> 
  --    </IN> 
  --出参:Xml_Out 
  -- <OUTPUT> 
  --   <BRID>病人ID</BRID> 
  --   <MZH>门诊号</MZH>
  --   <ERROR><MSG>错误信息</MSG></ERROR> 
  --  </OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_证件号   Varchar2(50);
  v_证件类型 医疗卡类别.名称%Type;
  v_姓名     Varchar2(100);
  v_验证姓名 Varchar2(100);
  v_卡号     Varchar2(100);
  v_卡类别   Varchar2(100);
  n_存在     Number(3);
  n_卡类别id 病人医疗卡信息.卡类别id%Type;
  v_操作员   人员表.姓名%Type;

  n_病人id 病人信息.病人id%Type;
  n_门诊号 病人信息.门诊号%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZJH'), Extractvalue(Value(A), 'IN/ZJLX'), Extractvalue(Value(A), 'IN/XM'),
         Extractvalue(Value(A), 'IN/KH'), Extractvalue(Value(A), 'IN/KLB')
  Into v_证件号, v_证件类型, v_姓名, v_卡号, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --先从用户自定义过程获取病人ID
  n_病人id := Zl_Third_Custom_Getpati(v_卡类别, v_卡号);

  If Nvl(n_病人id, 0) = 0 Then
    If Nvl(v_卡类别, '-') <> '-' And Nvl(v_卡号, '-') <> '-' Then
      Select Max(a.病人id)
      Into n_病人id
      From 病人医疗卡信息 A
      Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_卡类别 And Nvl(是否启用, 0) = 1) And 卡号 = v_卡号 And
            (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
             (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
    End If;
  
    If Nvl(n_病人id, 0) = 0 And Not v_证件号 Is Null Then
      If v_证件类型 Like '%身份证%' Then
        Begin
          Select 病人id Into n_病人id From 病人信息 Where 身份证号 = v_证件号;
        Exception
          When Others Then
            n_病人id := Null;
        End;
      End If;
      If Nvl(n_病人id, 0) = 0 Then
        Select Max(病人id)
        Into n_病人id
        From 病人医疗卡信息 A
        Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And 卡号 = v_证件号 And
              (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
               (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
      End If;
    End If;
  End If;

  If Nvl(n_病人id, 0) <> 0 Then
    v_Temp := '<BRID>' || n_病人id || '</BRID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Select 门诊号, 姓名 Into n_门诊号, v_验证姓名 From 病人信息 Where 病人id = n_病人id;
    If v_姓名 <> v_验证姓名 Then
      v_Err_Msg := '传入的病人姓名与已有的病人姓名不符,请检查!';
      Raise Err_Item;
    End If;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_病人id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpati_Unique;
/

--83951:刘尔旋,2015-04-28,服务窗挂号费别打折
Create Or Replace Procedure Zl_Third_Salereginfo
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:调用用户自定义函数获取指定的费别
  --入参:Xml_In:
  --  <IN>
  --       <XMID>123</XMID>   //要计算的收费项目的ID
  --       <BRID>421<BRID>   //病人ID
  --  </IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <JE>计算后的金额</JE>
  --  <FB>计算后的费别</FB>
  -- </OUTPUT>
  --    如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet  Xmltype; --模板XML
  v_Err_Msg  Varchar2(200);
  v_Temp     Varchar2(500);
  n_项目id   挂号安排.项目id%Type;
  n_病人id   病人信息.病人id%Type;
  v_费别     病人信息.费别%Type;
  n_实收金额 门诊费用记录.实收金额%Type := 0;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID')
  Into n_病人id, n_项目id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_费别 := Zl_Custom_Getpatifeetype(1, n_病人id);

  For r_Fb In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                     Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
               Union All
               Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                     Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
               Order By 性质, 项目编码, 收入编码) Loop
    v_Temp     := Zl_Actualmoney(v_费别, r_Fb.项目id, r_Fb.收入项目id, r_Fb.单价);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
    n_实收金额 := n_实收金额 + Zl_To_Number(v_Temp);
  End Loop;
  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<FB>' || v_费别 || '</FB>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    v_Temp := '<ERROR><MSG>' || SQLErrM || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
End Zl_Third_Salereginfo;
/

--83951:刘尔旋,2015-04-28,服务窗挂号支持费别打折
Create Or Replace Function Zl_Custom_Getpatifeetype
(
  操作类型_In Number,
  病人id_In   病人信息.病人id%Type := Null,
  身份证号_In 病人信息.身份证号%Type := Null
) Return Varchar2 Is
  --------------------------------------------------------------------------------------------------
  --功能:用户自定义获取指定病人费别函数
  --入参:
  --     操作类型_In:0-绑定身份;1-挂号操作
  --     病人id_In:病人ID
  --     身份证号_In:身份证号
  --返回:费别
  --------------------------------------------------------------------------------------------------
  v_费别    病人信息.费别%Type;
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  Return v_费别;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Custom_Getpatifeetype;
/

--84018:张德婷,2015-04-15,支付宝配合修改
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No,b.记录性质
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间)
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In
      Where ID = v_Modifybillout.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.数量, 0), 0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id,
             v_Modifybillout.成本价, v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期,
             v_Modifybillout.批准文号, v_Modifybillout.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id, v_Modifybillout.成本价,
             v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期, v_Modifybillout.批准文号,
             v_Modifybillout.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间


      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型
      Where ID = v_Modifybillin.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.数量, 0), 0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id,
             v_Modifybillin.成本价, v_Modifybillin.批号, v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期,
             v_Modifybillin.批准文号, v_Modifybillin.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id, v_Modifybillin.成本价, v_Modifybillin.批号,
             v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期, v_Modifybillin.批准文号, v_Modifybillin.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间


      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  Begin
    --移动支付宝项目在发药后动态调用生成推送信息的过程
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 6, No_In || ',' ||Partid_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_病人预交记录_Delete
(
  Id_In         病人预交记录.Id%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  帐户退费_In   Number := 1,
  冲预交id_In   病人预交记录.Id%Type := Null
) As
  Cursor c_Moneyinfo Is
    Select ID, NO, 金额, 结算方式, 病人id, 预交类别
    From 病人预交记录
    Where ID = Id_In And 记录性质 = 1 And 记录状态 = 1;
  r_Moneyrow c_Moneyinfo%RowType;

  v_打印id   票据打印内容.Id%Type;
  v_性质     结算方式.性质%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;
  n_预交id   病人预交记录.Id%Type;
  v_Date     Date;
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;
  v_Msg  Varchar2(500);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;

  Open c_Moneyinfo;
  Fetch c_Moneyinfo
    Into r_Moneyrow;

  --首先判断要退款的记录是否存在
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Raise Err_Custom;
  Else
    Select Sysdate Into v_Date From Dual;
    If 冲预交id_In Is Not Null Then
      n_预交id := 冲预交id_In;
    Else
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
  
    --预交退款
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持个人帐户退费,正常处理
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要_In, -1 * 金额, 结算方式, 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, 缴款单位,
               单位开户行, 单位帐号, n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    Else
      --不支持时,处理成现金,记录性质为2的摘要填标志,为3的更新新输入的摘要
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, Nvl(摘要_In, '个人帐户退款'), -1 * 金额,
               Decode(结算方式, v_个人帐户, v_现金, 结算方式), 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, Decode(结算方式, v_个人帐户, Null, 缴款单位),
               Decode(结算方式, v_个人帐户, Null, 单位开户行), Decode(结算方式, v_个人帐户, Null, 单位帐号), n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明,
               合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    End If;
  
    Update 病人预交记录 Set 记录状态 = 3, 摘要 = 摘要_In Where ID = Id_In;
  
    --处理相关汇总表
    --人员缴款余额(注意包括处理个人帐户的结算方式)
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持退个人帐户时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    Else
      --不支持时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式)
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式), 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式) And
              Nvl(余额, 0) = 0;
      End If;
    End If;
  
    --病人(预交)余额(不管是退现金还是个人帐户都应该减少)
    --判断要退款的性质
    Select b.性质 Into v_性质 From 病人预交记录 A, 结算方式 B Where a.结算方式 = b.名称(+) And a.Id = Id_In;
    If Nvl(v_性质, 1) <> 5 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 病人id = r_Moneyrow.病人id And Nvl(类型, 2) = Nvl(r_Moneyrow.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, Nvl(r_Moneyrow.预交类别, 2), -r_Moneyrow.金额, 0);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --作废收回票据(可能以前没有使用票据,无法收回)
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = r_Moneyrow.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 2 And 性质 = 1;
    End If;
  
    Close c_Moneyinfo;
  End If;
  --消息推送;
  Select Id_In || ',' || 帐户退费_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 12, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20999, '[ZLSOFT]没有发现要退款的预交记录,该记录可能已经退除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Delete;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_病人预交记录_Insert
(
  Id_In         病人预交记录.ID%Type,
  单据号_In     病人预交记录.NO%Type,
  票据号_In     票据使用明细.号码%Type,
  病人id_In     病人预交记录.病人id%Type,
  主页id_In     病人预交记录.主页id%Type,
  科室id_In     病人预交记录.科室id%Type,
  金额_In       病人预交记录.金额%Type,
  结算方式_In   病人预交记录.结算方式%Type,
  结算号码_In   病人预交记录.结算号码%Type,
  缴款单位_In   病人预交记录.缴款单位%Type,
  单位开户行_In 病人预交记录.单位开户行%Type,
  单位帐号_In   病人预交记录.单位帐号%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  领用id_In     票据使用明细.领用id%Type,
  预交类别_In   病人预交记录.预交类别%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  结算卡序号_In 病人预交记录.结算卡序号%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  合作单位_In   病人预交记录.合作单位%Type := Null,
  收款时间_In   病人预交记录.收款时间%Type := Null,
  操作类型_In   Integer := 0
) As
  ----------------------------------------------
  --操作类型_In:0-正常缴预交;1-存为划价单
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  v_性质   结算方式.性质%Type;
  v_打印id 票据打印内容.ID%Type;
  v_担保   病人信息.担保性质%Type;
  v_Date   Date;
  n_返回值 病人余额.预交余额%Type;
  n_组id   财务缴款分组.ID%Type;
Begin
  v_Date := 收款时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  n_组id := Zl_Get组id(操作员姓名_In);

  --插入预交缴款记录
  Insert Into 病人预交记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位,
     单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号,
     交易说明, 合作单位)
  Values
    (Id_In, 单据号_In, 票据号_In, 1, Decode(操作类型_In, 1, 0, 1), 病人id_In, Decode(主页id_In, 0, Null, 主页id_In),
     Decode(科室id_In, 0, Null, 科室id_In), 金额_In, 结算方式_In, 结算号码_In, v_Date, 缴款单位_In, 单位开户行_In,
     单位帐号_In, 操作员编号_In, 操作员姓名_In, 摘要_In, n_组id, 预交类别_In, 卡类别id_In, 结算卡序号_In, 卡号_In,
     交易流水号_In, 交易说明_In, 合作单位_In);

  If 操作类型_In = 1 Then
    --暂不处理汇总表
    Return;
  End If;

  --处理票据
  If 票据号_In Is Not Null Then
    Select 票据打印内容_Id.Nextval Into v_打印id From Dual;

    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, 单据号_In);

    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 1, 领用id_In, v_打印id, v_Date, 操作员姓名_In);

    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
    Where ID = Nvl(领用id_In, 0);
  End If;

  --相关汇总表处理

  --病人余额(预交余额现收)
  Begin
    Select 性质 Into v_性质 From 结算方式 Where 名称 = 结算方式_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(v_性质, 1) <> 5 Then
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) + 金额_In
    Where 性质 = 1 And 病人id = 病人id_In And Nvl(类型, 0) = Nvl(预交类别_In, 0) Returning 预交余额 Into n_返回值;
    If Sql%Rowcount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (病人id_In, 1, Nvl(预交类别_In, 0), 金额_In, 0);
      n_返回值 := 金额_In;
    End If;
    If Nvl(金额_In, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  End If;

  --人员缴款余额(现收)
  Update 人员缴款余额
  Set 余额 = Nvl(余额, 0) + 金额_In
  Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = 结算方式_In Returning 余额 Into n_返回值;

  If Sql%Rowcount = 0 Then
    Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, 结算方式_In, 1, 金额_In);
    n_返回值 := 金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = 结算方式_In And Nvl(余额, 0) = 0;
  End If;
  --对临时担保的处理
  Select Nvl(担保性质, 0) Into v_担保 From 病人信息 Where 病人id = 病人id_In;
  If v_担保 = 1 And Nvl(金额_In, 0) > 0 Then
    Update 病人信息
    Set 担保额 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, Nvl(担保额, 0) - Nvl(金额_In, 0), Null),
        担保人 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保人, Null),
        担保性质 = Decode(Sign(Nvl(担保额, 0) - Nvl(金额_In, 0)), 1, 担保性质, Null)
    Where 病人id = 病人id_In;
  End If;
  If 操作类型_In = 0 Then
    --消息推送;
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 11, Id_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人预交记录_Insert;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_病人医嘱附费_Insert
(
  医嘱id_In   病人医嘱附费.医嘱id%Type,
  发送号_In   病人医嘱附费.发送号%Type,
  记录性质_In 病人医嘱附费.记录性质%Type,
  No_In       病人医嘱附费.No%Type
) Is
  v_Msg Varchar2(500);
Begin
  Insert Into 病人医嘱附费 (医嘱id, 发送号, 记录性质, NO) Values (医嘱id_In, 发送号_In, 记录性质_In, No_In);
  --消息推送
  Select No_In || ',' || 记录性质_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 10, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱附费_Insert;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_门诊收费结算_完成退费
(
  病人id_In       门诊费用记录.病人id%Type,
  退费结算序号_In 病人预交记录.结算序号%Type,
  冲销ids_In      Varchar2,
  操作员姓名_In   病人预交记录.操作员姓名%Type := Null,
  操作标志_In     Integer := 0
) As
  --功能:完成退费处理
  --NOs_In:可以为多张;No1,No2...Non
  --操作标志_IN:0-更新缴款余额;1-不更新缴款余额(异常单据作废)
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_Count      Number;
  n_返回值     病人预交记录.冲预交%Type;
  v_Msg        Varchar2(500);
Begin
  v_操作员姓名 := 操作员姓名_In;

  If 冲销ids_In Is Null Then
    Select Count(*)
    Into n_Count
    From 病人预交记录 A
    Where 结算序号 = 退费结算序号_In And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
      Raise Err_Item;
    End If;
    For v_结帐 In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 退费结算序号_In) Loop
      If 操作标志_In = 1 Then
      
        Update 病人预交记录 A
        Set 校对标志 = 2
        Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
              (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
               (Select 1 From 结算方式 B Where a.结算方式 = b.名称 And b.性质 In (3, 4))));
        Return;
      End If;
      Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
      For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数
                   From 门诊费用记录 A, 门诊费用记录 B
                   Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                         b.结帐id = v_结帐.结帐id
                   Group By a.No, Nvl(a.价格父号, a.序号)) Loop
        Update 门诊费用记录 A
        Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 0
        Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
      End Loop;
    
      --处理预交记录
    
      If Nvl(操作标志_In, 0) = 0 Then
      
        --处理病人预交余额
        For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 预交类别
                     Having Sum(Nvl(冲预交, 0)) <> 0) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
          Returning 预交余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
            n_返回值 := Nvl(v_预交.预交金额, 0);
          End If;
          If n_返回值 = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      
        --更新人员缴款余额
        For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                     From 病人预交记录 A
                     Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 结算方式) Loop
        
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
          Returning Nvl(余额, 0) Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
            n_返回值 := Nvl(v_缴款.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete 人员缴款余额
            Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End Loop;
      End If;
    
    End Loop;
    Return;
  End If;

  --按单据号更新
  Select /*+ rule */
   Count(a.Id)
  Into n_Count
  From 病人预交记录 A, Table(f_Num2list(冲销ids_In)) J
  Where a.结帐id = j.Column_Value And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
  If n_Count <> 0 Then
    v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
    Raise Err_Item;
  End If;

  --更新执行状态:在未完成时,都是9
  For v_结帐 In (Select /*+ rule */
                j.Column_Value As 结帐id
               From Table(f_Num2list(冲销ids_In)) J) Loop
  
    If Nvl(操作标志_In, 0) = 1 Then
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
            (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
             (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4))));
    
    End If;
  
    Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
  
    For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数


                 From 门诊费用记录 A, 门诊费用记录 B
                 Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                       b.结帐id = v_结帐.结帐id
                 Group By a.No, Nvl(a.价格父号, a.序号)) Loop
      Update 门诊费用记录 A
      Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 0
      Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
    End Loop;
  
    --处理预交记录
  
    If Nvl(操作标志_In, 0) = 0 Then
    
      --处理病人预交余额
      For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := Nvl(v_预交.预交金额, 0);
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    
      --更新人员缴款余额
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning Nvl(余额, 0) Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 人员缴款余额
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  End Loop;
  --消息推送
  Select 病人id_In || ',' || 冲销ids_In || ',' || 操作标志_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_完成退费;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  v_Msg      Varchar2(5000);
  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10)
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                2
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --如果存在医保,肯定先退,所以校对标志应该2,减少重复更新
                2
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id := 冲销id_In;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id := n_重结id;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In,
         交易说明_In, Null, 3);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号,
                   交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                                 预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 2, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  结帐id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  退支票额_In     病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成结算_In     Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.." 
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_退支票   病人预交记录.结算方式%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;
  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Open c_Feedata;
    Begin
      Fetch c_Feedata
        Into r_Feedata;
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      End If;
    Exception
      When Others Then
        n_Count := 1;
    End;
    Close c_Feedata;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                         Union All
                         Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                               预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
      n_返回值 := -1 * 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;
  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 2, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
    --医保相关表的处理 
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4,结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--85234:刘尔旋,2015-05-29,预约收款退号后挂号汇总错误的问题
--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_病人挂号记录_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.记录状态 = v_状态 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = 单据号_In And
          Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 2 And b.记录性质 = 4 And b.记录状态 = 2 And
          Nvl(b.冲预交, 0) <> 0 And
          Nvl(a.附加标志, 0) =
          Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(a.附加标志, 0), 1, -1, Nvl(a.附加标志, 0)), Nvl(a.附加标志, 0));

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  
    --更新挂号序号状态
    Delete 挂号序号状态
    Where 状态 = 2 And
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, Trunc(发生时间)
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In) Or
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, 发生时间
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  
    --Update 病人挂号记录 set 摘要=nvl(摘要_IN,摘要) where NO=单据号_IN;
    --删除门诊费用记录
    Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) <> 2 Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Delete 挂号序号状态
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    Else
      Update 挂号序号状态
      Set 状态 = 4
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) <> 2 Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  --门诊费用记录
  --冲销记录
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
     数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
     结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
           收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
           操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
           Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
           Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));

  --原始记录
  If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
    Update 门诊费用记录
    Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  Else
    Update 门诊费用记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
          Rownum = 1;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 非原样退结算_In Is Not Null Then
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                Nvl(附加标志, 0) =
                Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
        
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
        Begin
          Select 冲预交
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
      
        --a.允许的结算方式
      
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        If n_退费金额 = 0 Then
          --b.不允许的退现金
          If n_退款金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
              Exception
                When Others Then
                  v_退指定结算方式 := '现金';
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退款金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --a.允许的结算方式原样退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        --b.不允许的退现金
        Begin
          Select Sum(冲预交)
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
        If n_退费金额 <> 0 Then
          If v_退指定结算方式 Is Null Then
            --退给现金
            Begin
              Select 结算方式
              Into v_退指定结算方式
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
            
            Exception
              When Others Then
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
            End;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * n_退费金额)
          Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                     操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录 A
              Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
          End If;
        End If;
      End If;
    Else
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                Nvl(附加标志, 0) =
                Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
      End If;
      If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
        --首次全退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
      Else
        --二次退费,或者本次单退一部分
        --二次退费时,记录状态=3 ,首次部分退,记录状态为1
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                 -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And 冲预交 = n_退款金额 And
                Rownum < 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And Rownum < 2;
        End If;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
          If Sql%RowCount = 0 Then
            --部分退费,并且全部使用预交款缴费时才存在此种情况
            n_预交金额 := n_退款金额;
          End If;
        End If;
      
      End If;
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If Nvl(退费类型_In, 0) <> 2 Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  Open c_Registinfo(3);
  Fetch c_Registinfo
    Into r_Registrow;

  If c_Registinfo%RowCount = 0 Then
    --只收病历费时无号别,不处理
    Close c_Registinfo;
  Else
  
    --需要确定是否预约挂号
    --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
    --2.如果是正常挂号,则只减已挂数
  
    Begin
      Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
    Exception
      When Others Then
        n_预约挂号 := 0;
    End;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号, -1 * n_预约挂号);
    End If;
  
    Close c_Registinfo;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) <> 2 Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Delete;
/

--85819:刘尔旋,2015-06-16,门诊挂不当班号别
--58163:刘尔旋,2015-06-15,不当班医生挂号
--84142:刘尔旋,2015-04-21,分时段的预留号挂号之后显示不正确的问题
--84087:李南春,2015-04-20,自助挂号在完成挂号时更新病人费别
--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In       门诊费用记录.病人id%Type,
  门诊号_In       门诊费用记录.标识号%Type,
  姓名_In         门诊费用记录.姓名%Type,
  性别_In         门诊费用记录.性别%Type,
  年龄_In         门诊费用记录.年龄%Type,
  付款方式_In     门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In         门诊费用记录.费别%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  序号_In         门诊费用记录.序号%Type,
  价格父号_In     门诊费用记录.价格父号%Type,
  从属父号_In     门诊费用记录.从属父号%Type,
  收费类别_In     门诊费用记录.收费类别%Type,
  收费细目id_In   门诊费用记录.收费细目id%Type,
  数次_In         门诊费用记录.数次%Type,
  标准单价_In     门诊费用记录.标准单价%Type,
  收入项目id_In   门诊费用记录.收入项目id%Type,
  收据费目_In     门诊费用记录.收据费目%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In     门诊费用记录.应收金额%Type,
  实收金额_In     门诊费用记录.实收金额%Type,
  病人科室id_In   门诊费用记录.病人科室id%Type,
  开单部门id_In   门诊费用记录.开单部门id%Type,
  执行部门id_In   门诊费用记录.执行部门id%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  医生姓名_In     挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病历费_In       Number, --该条记录是否病历工本费
  急诊_In         Number,
  号别_In         挂号安排.号码%Type,
  诊室_In         门诊费用记录.发药窗口%Type,
  结帐id_In       门诊费用记录.结帐id%Type,
  领用id_In       票据使用明细.领用id%Type,
  预交支付_In     病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In     病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In     病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In   门诊费用记录.保险大类id%Type,
  保险项目否_In   门诊费用记录.保险项目否%Type,
  统筹金额_In     门诊费用记录.统筹金额%Type,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In     Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In     Number := 0, --挂号是否使用收费票据
  保险编码_In     门诊费用记录.保险编码%Type,
  复诊_In         病人挂号记录.复诊%Type := 0,
  号序_In         挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In         病人挂号记录.社区%Type := Null,
  预约接收_In     Number := 0,
  预约方式_In     预约方式.名称%Type := Null,
  生成队列_In     Number := 0,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  操作类型_In     Number := 0,
  险类_In         病人挂号记录.险类%Type := Null,
  结算模式_In     Number := 0,
  记帐费用_In     Number := 0,
  退号重用_In     Number := 1,
  修正病人费别_In Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);
  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;
  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存在相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  If Nvl(n_计划id, 0) = 0 Then
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
  Else
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), 现金支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
      
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         Null, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) > Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--83951:刘尔旋,2015-04-15,服务窗退号重用问题
--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  n_退号重用       Number(3);
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;
Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Custom;
  End If;
  v_操作员编号 := Zl_操作员(1, v_Temp);
  v_操作员姓名 := Zl_操作员(2, v_Temp);

  n_组id := Zl_Get组id(v_操作员姓名);

  d_退号时间 := 退号时间_In;
  If d_退号时间 Is Null Then
    d_退号时间 := Sysdate;
  End If;

  --首先判断要退号/取消预约的记录是否存在
  Begin
    Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0), Decode(记录状态, 0, 1, 0)
    Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
    From 病人挂号记录
    Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
  Exception
    When Others Then
      n_预约挂号 := -1;
  End;

  If n_预约挂号 = -1 Then
    v_Error := '单据可能已经被退号或单据输入错误!';
    Raise Err_Custom;
  End If;

  Begin
    Select 1
    Into n_启用分时段
    From 挂号安排 A, 挂号安排时段 B
    Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --预约检查是否添加合作单位控制
  --如果设置了合作单位控制 则
  Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
  --更新挂号序号状态
  n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
  If n_退号重用 = 0 Then
    Update 挂号序号状态
    Set 状态 = 4
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  Else
    Delete 挂号序号状态
    Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
  End If;
  If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
    If Nvl(n_无效单据, 0) = 0 Then
      --N天内不能取消预约号
      n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
      If n_Count <> 0 Then
        If Trunc(Sysdate - n_Count) < d_登记时间 Then
          v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_状态 := Case n_无效单据
              When 1 Then
               0
              Else
               1
            End;
    --减少已约数
    Open c_Registinfo(n_状态, 2, n_无效单据);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
    End If;
  
    If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
      Update 合作单位挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
            序号 = Nvl(n_号序, 0);
      If Sql%RowCount = 0 Then
        Insert Into 合作单位挂号汇总
          (日期, 号码, 已约数, 合作单位, 序号, 已接数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
      End If;
    End If;
    Close c_Registinfo;
  
    If Nvl(n_无效单据, 0) = 0 Then
      --删除门诊费用记录
      Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
      --如果预约生成队列时需要清除队列
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If Nvl(n_挂号生成队列, 0) = 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
        If Nvl(n_预约生成队列, 0) = 1 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    End If;
  Else
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  
    --更新挂号序号状态
  
    --病人就诊状态
    Select 病人id Into n_病人id From 门诊费用记录 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
  
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
    End If;
  
    --门诊费用记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
             Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
  
    Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    Select 结帐id
    Into n_原结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
  
    Select Count(Distinct 结算方式) Into n_Count From 病人预交记录 Where 结帐id = n_原结帐id;
    If n_Count > 1 Then
      v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
      Raise Err_Custom;
    End If;
    n_预交id := 预交id_In;
    If Nvl(预交id_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明, 合作单位,
       结算序号, 卡类别id, 结算性质)
      Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
             交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
      From 病人预交记录
      Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
  
    Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
  
    --退卡收回票据(可能上次挂号使用票据,不能收回)
    Begin
      --从最后一次的打印内容中取
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If n_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
        From 票据使用明细
        Where 打印id = n_打印id And 性质 = 1;
    End If;
  
    --相关汇总表的处理
  
    --病人挂号汇总
    Open c_Registinfo(1, 1);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
        Into n_预约挂号, n_执行状态
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
      --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
      If n_执行状态 > 0 Then
        If n_执行状态 = 1 Then
          v_Error := '该病人已经完成就诊,不能再退号!';
        Else
          v_Error := '该病人正在就诊, 不能退号!';
        End If;
        Raise Err_Custom;
      End If;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
        End If;
      End If;
      Close c_Registinfo;
    End If;
  
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Delete From 就诊登记记录
    Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
  End If;

  If Nvl(n_无效单据, 0) = 0 Then
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
    If Sql%NotFound Then
      v_Error := '未找到挂号单据,请检查!';
      Raise Err_Custom;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
      Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
             发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 = 3;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/

--85720:刘尔旋,2015-06-15,三方挂号病人费别处理优化
--85683:刘尔旋,2015-06-12,合作单位限数量预约的问题
--85657:刘尔旋,2015-06-12,服务窗挂号更新年龄
--85355:刘尔旋,2015-06-04,根据挂号计划生成挂号记录
--84162:刘尔旋,2015-04-23,挂号重号的问题
--83939:刘尔旋,2015-04-28,服务窗消息推送
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In     Integer,
  病人id_In       门诊费用记录.病人id%Type,
  号码_In         挂号安排.号码%Type,
  号序_In         挂号序号状态.序号%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  合作单位_In     挂号合作单位.名称%Type,
  挂号金额合计_In 门诊费用记录.实收金额%Type,
  领用id_In       票据使用明细.领用id%Type,
  收费票据_In     Number := 0, --挂号是否使用收费票据
  交易流水号_In   病人预交记录.交易流水号%Type,
  交易说明_In     病人预交记录.交易说明%Type,
  预约方式_In     预约方式.名称%Type := Null,
  预交id_In       病人预交记录.Id%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  加入序号状态_In Number := 0,
  是否自助设备_In Number := 0,
  结帐id_In       门诊费用记录.结帐id%Type := Null,
  锁定类型_In     Number := 0,
  保险结算_In     Varchar2 := Null,
  冲预交_In       Number := Null,
  支付卡号_In     病人预交记录.卡号%Type := Null,
  退号重用_In     Number := 1,
  费别_In         门诊费用记录.费别%Type := Null,
  机器名_In       挂号序号状态.机器名%Type := Null,
  更新年龄_In     Number := 0
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  d_时段开始时间       Date;
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队标记           排队叫号队列.排队标记%Type;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(n_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = n_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

Begin
  If 费别_In Is Null Then
    Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
  Else
    v_费别 := 费别_In;
  End If;
  If v_费别 Is Null Then
    n_屏蔽费别 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;
  Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  If 更新年龄_In = 1 Then
    Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
    If v_年龄 Is Not Null Then
      Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
    End If;
  End If;
  --获取当前机器名称
  If 机器名_In Is Not Null Then
    v_机器名 := 机器名_In;
  Else
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  n_实收金额合计 := 0;
  Select Count(*) + 1
  Into n_挂号序号
  From 病人挂号记录
  Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  --Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Item;
  End If;

  If 登记时间_In Is Null Then
    d_登记时间 := Sysdate;
  Else
    d_登记时间 := 登记时间_In;
  End If;
  If Trunc(Sysdate) > Trunc(发生时间_In) Then
    v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
    Raise Err_Item;
  End If;
  n_同科限约一个号 := Nvl(zl_GetSysParameter('病人同科限约一个号', 1111), 0);
  n_病人预约科室数 := Nvl(zl_GetSysParameter('病人预约科室数', 1111), 0);
  n_开单部门id     := To_Number(Zl_操作员(0, v_Temp));
  v_操作员编号     := Zl_操作员(1, v_Temp);
  v_操作员姓名     := Zl_操作员(2, v_Temp);
  n_组id           := Zl_Get组id(v_操作员姓名);

  If 操作方式_In <> 1 Then
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
            Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
      Order By 生效时间 Desc;
    Exception
      When Others Then
        Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Select Count(0)
      Into n_合作单位限制
      From 合作单位计划控制
      Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
    Else
      Select Count(0)
      Into n_合作单位限制
      From 合作单位安排控制
      Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
    End If;
  End If;

  If 操作方式_In <> 2 Then
    v_诊室 := Zl_诊室(号码_In);
  End If;
  If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
    --检查结算方式是否完备
    Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
    If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
      Select Count(1)
      Into n_Count
      From 医疗卡类别
      Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
    End If;
    If n_Count = 0 Then
      v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
      Raise Err_Item;
    End If;
  End If;

  --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
  Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
  If n_Count <> 0 Then
    v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
    Raise Err_Item;
  End If;

  Open c_Pati(病人id_In);
  n_Count := 0;
  Begin
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '病人未找到，不能继续。';
    Raise Err_Item;
  End If;

  Open c_安排(号码_In, 发生时间_In);
  Begin
    Fetch c_安排
      Into r_安排;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
    Raise Err_Item;
  End If;

  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', '周日')
  Into v_星期
  From Dual;
  Begin
    Select 1 Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --对参数控制进行检查
  --仅在预约不扣款时进行检查
  If 操作方式_In = 2 Then
    If Nvl(n_同科限约一个号, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Count(1) As 已约, a.执行部门id As 科室id, Nvl(k.名称, '') As 科室
                        From 病人挂号记录 A, 病人信息 B, 部门表 K
                        Where a.病人id = b.病人id And a.病人id = 病人id_In And a.执行部门id = k.Id(+) And a.记录性质 = 2 And 记录状态 = 1 And
                              a.预约时间 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60
                        Group By a.执行部门id, k.名称) Loop
        If Nvl(n_同科限约一个号, 0) <> 0 And c_Chkitem.科室id = r_安排.科室id Then
        
          v_Err_Msg := '该病人已经在科室[' || c_Chkitem.科室 || ']进行了预约,不能再预约！';
          Raise Err_Item;
        
          If Nvl(n_病人预约科室数, 0) > 0 And c_Chkitem.科室id <> r_安排.科室id Then
            n_已约科室 := n_已约科室 + 1;
          End If;
        End If;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Err_Msg := '同一病人在最多同时预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  d_Date         := Null;
  d_时段开始时间 := Null;

  If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
  
    Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
    Into n_已挂数, n_其中已接收, n_已约数
    From 挂号安排 A, 病人挂号汇总 B
    Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
          Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
          Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
  
    If n_启用分时段 = 1 Then
      If Nvl(r_安排.序号控制, 0) = 1 Then
        If Nvl(是否自助设备_In, 0) = 0 Then
          Select Count(*), Max(开始时间)
          Into n_Count, d_时段开始时间
          From 挂号安排时段
          Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
          v_Temp := '挂号';
          If 操作方式_In > 1 Then
            v_Temp := '预约挂号';
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
            Raise Err_Item;
          End If;
        End If;
        --过点的,不能选择挂号
        If Trunc(Sysdate) = Trunc(发生时间_In) Then
          --挂当天的号
          v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
          For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                       To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                       From 挂号安排时段
                       Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
            If Sysdate > v_时段.结束时间 Then
              v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End Loop;
        End If;
      Elsif 操作方式_In > 1 Then
        --未启用序号的,需要检查预约的情况
      
        n_Count := 0;
        For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                     From 挂号安排时段
                     Where 安排id = r_安排.Id And 星期 = v_星期 And
                           (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                           '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                    '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
          n_预约时段序号 := v_时段.序号;
          d_时段开始时间 := v_时段.开始时间;
        
          Select Count(*), Max(序号)
          Into n_Count, n_预约总数
          From 挂号序号状态
          Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
        
          If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                         To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
            Raise Err_Item;
          End If;
          n_Count := 1;
        End Loop;
      
        If n_Count = 0 Then
          v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                       '),不能进行预约挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作方式_In = 1 And 锁定类型_In <> 2 Then
    --挂号规则:
    --  已挂数不能大于限号数
    If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
      v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
      Raise Err_Item;
    End If;
  End If;

  If 操作方式_In > 1 Then
    --预约的相关检查
    --规则:
    --   1.已限约不能超过限约数
    --   2.检查是否启用时段的
    If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
      v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
      Raise Err_Item;
    End If;
  End If;
  If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
  
    If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
      v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
      Raise Err_Item;
    End If; --Nvl(r_安排.序号控制, 0) =0
  
    n_序号 := Case
              When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
               Nvl(号序_In, 0)
              Else
               0
            End;
    --合作单位限数量模式
    Begin
      If Nvl(n_计划id, 0) <> 0 Then
        Select 0
        Into n_序号
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      Else
        Select 0
        Into n_序号
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      End If;
      n_合作单位限数量模式 := 1;
    Exception
      When Others Then
        n_合作单位限数量模式 := 0;
    End;
    --开放序号检查
    For c_合作单位 In (Select c.序号, 数量
                   From 挂号安排 A, 合作单位安排控制 C
                   Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                         c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                    (Select 1
                          From 挂号安排计划 D
                          Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                   Union All
                   Select c.序号, 数量
                   From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                        (Select Max(a.生效时间) As 生效, 安排id
                          From 挂号安排计划 A, 挂号安排 B
                          Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                          Group By 安排id) E
                   Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                         Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                         Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                         发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
    
      If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
        n_是否开放 := 1;
        Exit;
      Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
        Begin
          Select Nvl(已约数, 0)
          Into n_预约数量
          From 合作单位挂号汇总
          Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
        Exception
          When Others Then
            n_预约数量 := 0;
        End;
        If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
          v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
          Raise Err_Item;
        End If;
        n_是否开放 := 1;
        Exit;
      End If;
    
    End Loop;
  
    If Nvl(n_是否开放, 0) = 0 Then
      v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
      Raise Err_Item;
    End If;
  End If;

  --检查限号数和限约数
  n_行号         := 1;
  n_原项目id     := 0;
  n_原收入项目id := 0;
  n_实收金额合计 := 0;
  If 锁定类型_In <> 1 Then
    If 操作方式_In <> 2 Then
      If Nvl(结帐id_In, 0) = 0 Then
        --这里应该程序传入
        Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
      Else
        n_结帐id := 结帐id_In;
      End If;
    Else
      n_结帐id := Null;
    End If;
  End If;
  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = r_安排.项目id And
                       Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_价格父号 := Null;
    If n_原项目id = c_Item.项目id Then
      If n_原收入项目id <> c_Item.收入项目id Then
        n_价格父号 := n_行号;
      End If;
      n_原收入项目id := c_Item.收入项目id;
    End If;
    n_原项目id := c_Item.项目id;
    n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
    n_实收金额 := n_应收金额;
    If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
      --打折:
      v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    End If;
    n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
  
    --锁定单据不产生费用
    If 锁定类型_In <> 1 Then
      --产生病人挂号费用(可能单独是或包括病历费用)
      Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
      --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      Insert Into 门诊费用记录
        (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
         收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
         操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
      Values
        (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
         Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
         r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
         n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
         Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
         摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
    End If;
    n_行号 := n_行号 + 1;
  
  End Loop;

  If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
    v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
    Raise Err_Item;
  End If;

  If n_启用分时段 = 1 Then
    d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
  Else
    d_Date := Trunc(发生时间_In);
  End If;

  --更新挂号序号状态
  If 锁定类型_In <> 2 Then
    n_号序 := 号序_In;
  End If;
  Begin
    Select 1
    Into n_Count
    From 挂号序号状态
    Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 1 Then
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
      n_号序 := Null;
    End If;
    If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
      v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
      Raise Err_Item;
    End If;
  End If;
  n_Count := 0;
  If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
    If 退号重用_In = 1 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
    End If;
  End If;
  If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
  
    If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
      --规则:预约时段序号||预约数
      If Nvl(n_预约总数, 0) = 0 Then
        v_Temp := Nvl(r_安排.限约数, 0);
        v_Temp := LTrim(RTrim(v_Temp));
        v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
        v_Temp := n_预约时段序号 || v_Temp;
        n_号序 := To_Number(v_Temp);
      Else
        n_号序 := n_预约总数 + 1;
      End If;
    End If;
  End If;

  If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
      n_序号锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_序号锁定   := 0;
    End;
    If n_序号锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
      Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
          Values
            (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
        
          If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
            Update 合作单位挂号汇总
            Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
            Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
            If Sql%NotFound Then
              Insert Into 合作单位挂号汇总
                (号码, 日期, 序号, 合作单位, 已约数, 已接数)
              Values
                (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --锁定单据不产生任何 费用
  If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
    --挂号,预约挂号已经扣款部分
    n_预交id := 预交id_In;
    If Nvl(n_预交id, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    n_结算合计 := 0;
    If 保险结算_In Is Not Null Then
      --各个保险结算
      v_结算内容 := 保险结算_In || '||';
      n_结算合计 := 0;
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
          Values
            (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额,
             n_结帐id, n_组id, n_结帐id, 4);
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        End If;
        n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    If Nvl(冲预交_In, 0) <> 0 Then
      --处理总预交
      n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
      n_预交金额 := 冲预交_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_结算金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 <= n_结算金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      End If;
    End If;
    --剩余款项,用指定结算方支付
    n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
    If Nvl(n_结算金额, 0) < 0 Then
      v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
      Raise Err_Item;
    End If;
    If Nvl(n_结算金额, 0) <> 0 Then
      If 结算方式_In Is Null Then
        v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(预交id_In, 0) <> 0 Then
        --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
        Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
        n_预交id := Nvl(预交id_In, 0);
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, n_结算金额, d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id, 合作单位_In || '缴款', n_组id,
         交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
    End If;
  
    --更新人员缴款数据
  
    For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                 Group By 结算方式) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
      Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
        n_返回值 := Nvl(v_缴款.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    
    End Loop;
  
  End If;

  --处理挂号记录
  If 锁定类型_In = 2 Then
    Begin
      Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    Exception
      When Others Then
        Null;
    End;
  Else
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  End If;

  Update 病人挂号记录
  Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
      操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1), 接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
      接收时间 = Case 锁定类型_In
                When 1 Then
                 Null
                Else
                 Case 操作方式_In
                   When 2 Then
                    Null
                   Else
                    d_登记时间
                 End
              End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位)
  Where ID = n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
       r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
       Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
       Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In, v_付款方式);
  End If;
  --锁定单据不能产生队列
  If 锁定类型_In <> 1 Then
    n_预约生成队列 := 0;
    If 操作方式_In > 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
    --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
    If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
      If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
        --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站      
        If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
          --产生队列
          --.按”执行部门” 的方式生成队列
          v_队列名称 := r_安排.科室id;
          v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          v_排队标记 := Substr(v_排队号码, 1, 1);
          v_排队号码 := Substr(v_排队号码, 2);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)  
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
          --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, v_排队标记, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                           d_排队时间, 预约方式_In, n_启用分时段, v_排队序号);
        End If;
      End If;
    End If;
  
    If Nvl(操作方式_In, 0) = 1 Then
      --处理票据使用情况
      If 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --病人本次就诊(以发生时间为准)
      If Nvl(r_Pati.病人id, 0) <> 0 Then
        Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
      End If;
    End If;
  End If;
  --病人挂号汇总
  --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
  If 锁定类型_In <> 2 Then
    --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
    n_预约 := Case
              When Nvl(操作方式_In, 0) = 1 Then
               0
              When Nvl(操作方式_In, 0) = 2 Then
               1
              When Nvl(操作方式_In, 0) = 3 Then
               3
              Else
               0
            End;
    Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--85171:刘尔旋,2015-05-26,批量换号没有删除原号码序号状态的问题
--84885:刘尔旋,2015-05-18,支付宝问题集中修改
--83685:刘尔旋,2015-04-13,换号后挂号汇总错误的问题
Create Or Replace Procedure Zl_病人挂号记录_批量换号
(
  Nos_In        In Varchar2 := Null,
  新号别_In     In 病人挂号记录.号别%Type := Null,
  新医生姓名_In In 挂号安排.医生姓名%Type := Null,
  新医生id_In   In 挂号安排.医生id%Type := Null,
  新科室id_In   In 挂号安排.科室id%Type := Null,
  原医生姓名_In In 挂号安排.医生姓名%Type := Null,
  原医生id_In   In 挂号安排.医生id%Type := Null,
  原号别_In     In 病人挂号记录.号别%Type := Null,
  操作员姓名_In In 挂号序号状态.操作员姓名%Type := Null
  --功能: 完成病人批量换号功能,在挂号项目相同,限号数相同,限约数相同,科室相同的情况下。
  --参数说明:  Nos_In :需要跟换排班的病人挂号记录单据集:格式: M000001|M000002|..........
) As
  --获取对应挂号记录的门诊费用记录信息
  Cursor c_Bill(c_No 病人挂号记录.No%Type) Is
    Select ID, 序号, NO, 发生时间, 执行部门id, 收费细目id, 计算单位
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (0, 1) And NO = c_No
    Order By 序号;
  --获取相应排班的分诊诊室
  Cursor c_平均分诊(c_指定分诊号表id 挂号安排.Id%Type) Is
    Select 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = c_指定分诊号表id;

  --变量定义
  r_平均分诊         挂号安排诊室%RowType;
  r_Bill             c_Bill%RowType;
  v_Nos              Varchar(2000);
  v_No               病人挂号记录.No%Type;
  n_病人id           病人挂号记录.病人id%Type;
  n_原序号           病人挂号记录.号序%Type;
  d_原就诊日期       病人挂号记录.预约时间%Type;
  n_是否已被挂出     Number(1);
  n_记录性质         Number(1);
  n_预约             Number(1);
  n_挂号状态         Number(1); --0-正常挂号:1-预约挂号;2-预约挂号接收
  v_新就诊诊室       病人信息.就诊诊室%Type;
  n_分诊方式         Number(1); --0-不分诊:1-指定分诊:2-动态分诊:3-平均分诊
  n_指定分诊号表id   Number(10);
  n_分诊诊室数量     Number(3);
  n_是否找到分诊诊室 Number(1); --0:未找到:1-找到但分配标识未更改:2-修改第一条数据标识
  n_Index            Number(1); --当前记录集的索引值
  v_现队列名称       排队叫号队列.队列名称%Type;
  n_挂号生成队列     Number;
  n_预约生成队列     Number;
  v_排队号码         排队叫号队列.排队号码%Type;
  n_业务id           病人挂号记录.Id%Type;
  v_Temp             Varchar2(500);
  v_操作员编号       就诊变动记录.操作员编号%Type;
  v_操作员姓名       就诊变动记录.操作员姓名%Type;
  n_医生id           人员表.Id%Type;
  v_Error            Varchar2(255);
  Err_Custom Exception;
Begin
  --检查是否存在该挂号记录
  If Nos_In Is Not Null Then
    v_Nos := Nos_In || '|';
    While v_Nos Is Not Null Loop
      --初始化变量
      n_病人id           := 0;
      n_原序号           := 0;
      d_原就诊日期       := Null;
      n_是否已被挂出     := 0;
      n_记录性质         := 0;
      n_预约             := 0;
      n_挂号状态         := 0;
      v_新就诊诊室       := '';
      n_分诊方式         := 0;
      n_指定分诊号表id   := 0;
      v_现队列名称       := '';
      v_排队号码         := '';
      n_业务id           := 0;
      n_分诊诊室数量     := 0;
      n_挂号生成队列     := 0;
      n_预约生成队列     := 0;
      n_是否找到分诊诊室 := 0;
      n_Index            := 0;
    
      v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
      v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
      --检查是否存在该挂号记录
      Begin
        Select a.Id, a.病人id, a.号序, Nvl(b.日期, Nvl(a.预约时间, a.发生时间)), a.记录性质, Nvl(a.预约, 0)
        Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约
        From 病人挂号记录 A, 挂号序号状态 B
        Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1 And a.号别 = b.号码(+) And Trunc(Nvl(预约时间, 发生时间)) = Trunc(b.日期(+)) And
              a.号序 = b.序号(+);
      Exception
        When Others Then
          Null;
      End;
      If n_病人id = 0 Then
        v_Error := '没有找到病人的挂号信息';
        Raise Err_Custom;
      End If;
      --判断当前挂号状态
      n_挂号状态 := 0; --正常挂号
      If n_记录性质 = 1 And n_预约 = 1 Then
        n_挂号状态 := 2; --预约接收
      End If;
      If n_记录性质 = 2 And n_预约 = 1 Then
        n_挂号状态 := 1; --预约
      End If;
    
      --检查换号的新号别是否已被挂出
      Begin
        Select a.状态
        Into n_是否已被挂出
        From 挂号序号状态 A
        Where a.日期 = d_原就诊日期 And a.号码 = 新号别_In And a.序号 = n_原序号;
      Exception
        When Others Then
          n_是否已被挂出 := 0;
      End;
      If n_是否已被挂出 > 0 Then
        v_Error := '要换的号别已被挂出';
        Raise Err_Custom;
      End If;
      --预约接收的情况下进行分诊诊室的获取
      If n_挂号状态 = 2 Then
        --获取新号别诊室
        --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
        --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
        --获取分诊方式
        Begin
          Select ID, Nvl(分诊方式, 0) Into n_指定分诊号表id, n_分诊方式 From 挂号安排 Where 号码 = 新号别_In;
        Exception
          When Others Then
            n_分诊方式       := 0;
            n_指定分诊号表id := 0;
        End;
      
        Begin
          If n_分诊方式 = 0 Then
            --不分诊
            v_新就诊诊室 := '';
          End If;
          If n_分诊方式 = 1 Then
            --指定分诊
            Select 门诊诊室 Into v_新就诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
          End If;
          If n_分诊方式 = 2 Then
            --动态分诊
            Select 门诊诊室
            Into v_新就诊诊室
            From (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_指定分诊号表id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                号别 = 新号别_In And 诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num)
            Where Rownum = 1;
          End If;
          If n_分诊方式 = 3 Then
            --平均分诊
            --获取当前安排下的诊室数量
            Select Count(1) Into n_分诊诊室数量 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
          
            Open c_平均分诊(n_指定分诊号表id);
            Loop
              Fetch c_平均分诊
                Into r_平均分诊;
              Exit When c_平均分诊%NotFound;
              n_Index := n_Index + 1;
              --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
              If n_是否找到分诊诊室 = 1 Then
                Update 挂号安排诊室
                Set 当前分配 = 1
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                Exit;
              End If;
            
              If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                v_新就诊诊室 := r_平均分诊.门诊诊室;
                Update 挂号安排诊室
                Set 当前分配 = 0
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                n_是否找到分诊诊室 := 1;
              End If;
            
              If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                n_是否找到分诊诊室 := 2;
                Exit;
              End If;
              If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                --游标已经到了最后,所以需从第一条数据开始修改标识
                If n_Index >= n_分诊诊室数量 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
              End If;
            End Loop;
            Close c_平均分诊;
            --重置索引值
            n_Index := 0;
            --第一次分诊
            If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                n_Index := n_Index + 1;
              
                If n_是否找到分诊诊室 = 1 Then
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End If;
              
                Update 挂号安排诊室
                Set 当前分配 = 0
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                v_新就诊诊室 := r_平均分诊.门诊诊室;
              
                n_是否找到分诊诊室 := 1;
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
              
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              
              End Loop;
              Close c_平均分诊;
            End If;
          
            If n_是否找到分诊诊室 = 2 Then
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                Update 挂号安排诊室
                Set 当前分配 = 1
                Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                Exit;
              End Loop;
              Close c_平均分诊;
            End If;
          End If;
        Exception
          When Others Then
            v_新就诊诊室 := '';
        End;
      End If;
    
      --更新病人信息的就诊诊室和状态
      Update 病人信息 Set 就诊诊室 = v_新就诊诊室, 就诊状态 = 1 Where 病人id = n_病人id And 就诊状态 In (1, 2);
    
      --打开游标
      Open c_Bill(v_No);
      Loop
        Fetch c_Bill
          Into r_Bill;
        Exit When c_Bill%NotFound;
        If r_Bill.序号 = 1 Then
          --需要确定是否预约挂号 
          --1.如果是预约挂号产生的挂号记录,则需要减已约数
          --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
          --3.如果是正常挂号,则只减已挂数      
          --恢复以前的挂号汇总
          Update 病人挂号汇总
          Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
              已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
          Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And
                Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And (号码 = r_Bill.计算单位 Or 号码 Is Null);
          If Sql%RowCount = 0 Then
            Insert Into 病人挂号汇总
              (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
            Values
              (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
               r_Bill.计算单位, 0, 0, 0);
          End If;
        
          ----然后再更新挂号汇总
          Update 病人挂号汇总
          Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
              已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
          Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
               
                (号码 = 新号别_In Or 号码 Is Null);
          If Sql%RowCount = 0 Then
            Insert Into 病人挂号汇总
              (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
            Values
              (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
               Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
          End If;
        End If;
      
        ---更新挂号记录 
        If n_挂号状态 = 1 Then
          --预约
          Update 门诊费用记录
          Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
              --病人病区id = 科室id_In, 
              执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
          Where ID = r_Bill.Id;
        Else
          --挂号或接收
          Update 门诊费用记录
          Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
              --病人病区id = 科室id_In, 
              执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
          Where ID = r_Bill.Id;
        End If;
      
        --更新病人挂号记录 
        If r_Bill.序号 = 1 Then
          v_Temp := Zl_Identity(1);
          Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
          Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
          Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
          Begin
            Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
          Exception
            When Others Then
              n_医生id := Null;
          End;
          Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                           n_原序号, Null);
          --修改队列信息
          Update 排队叫号队列
          Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
          Where 业务id = n_业务id And 业务类型 = 0;
        
          Update 病人挂号记录
          Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号
          Where NO = r_Bill.No;
          --修改挂号序号状态
          If n_原序号 Is Not Null Then
            --1.恢复以前挂号序号状态
            Delete 挂号序号状态 Where 日期 = d_原就诊日期 And 序号 = n_原序号 And 号码 = 原号别_In;
            --2.新增换号后挂号序号状态 
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 操作员姓名, 状态, 预约, 登记时间)
            Values
              (新号别_In, d_原就诊日期, n_原序号, 操作员姓名_In, Decode(n_挂号状态, 1, 2, 1), Decode(n_挂号状态, 0, 0, 1), Sysdate);
          End If;
        End If;
      End Loop;
      Close c_Bill;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_批量换号;
/

--83685:刘尔旋,2015-04-13,换号后挂号汇总错误的问题
Create Or Replace Procedure Zl_病人挂号记录_换号
(
  No_In       病人挂号记录.No%Type,
  号别_In     病人挂号记录.号别%Type,
  诊室_In     病人挂号记录.诊室%Type,
  科室id_In   病人挂号记录.执行部门id%Type,
  原医生_In   病人挂号记录.执行人%Type,
  原医生id_In 病人挂号汇总.医生id%Type,
  新医生_In   病人挂号记录.执行人%Type,
  新医生id_In 病人挂号汇总.医生id%Type
  --功能：完成病人换号功能，在挂号项目ID相同的情况下。
) As
  Cursor c_Bill Is
    Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别,
           收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In
    Order By 序号;

  v_病人id       门诊费用记录.Id%Type;
  v_现队列名称   排队叫号队列.队列名称%Type;
  v_挂号生成队列 Varchar2(2);
  v_预约挂号     Number(2);
  n_业务id       病人挂号记录.Id%Type;
  v_排队号码     排队叫号队列.排队号码%Type;
  v_号别         病人挂号记录.号别%Type;
  n_号序         病人挂号记录.号序%Type;
  v_排队序号     排队叫号队列.排队序号%Type;
  v_Temp         Varchar2(500);
  v_操作员编号   就诊变动记录.操作员编号%Type;
  v_操作员姓名   就诊变动记录.操作员姓名%Type;
  n_医生id       人员表.Id%Type;
  v_Error        Varchar2(255);
  Err_Custom Exception;
Begin
  v_病人id := 0;
  Begin
    Select 病人id Into v_病人id From 病人挂号记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  Exception
    When Others Then
      Null;
  End;
  If v_病人id = 0 Then
    v_Error := '没有找到病人的挂号信息。';
    Raise Err_Custom;
  Elsif v_病人id Is Null Then
    v_Error := '没有找到病人信息。';
    Raise Err_Custom;
  End If;

  ---先更新病人信息的就诊诊室和状态
  Update 病人信息 Set 就诊诊室 = 诊室_In, 就诊状态 = 1 Where 病人id = v_病人id And 就诊状态 In (1, 2);

  For r_Bill In c_Bill Loop
    If r_Bill.序号 = 1 Then
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1) Into v_预约挂号 From 病人挂号记录 Where NO = r_Bill.No And Rownum = 1;
      Exception
        When Others Then
          v_预约挂号 := 0;
      End;
    
      --恢复以前的挂号汇总
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - v_预约挂号, 已约数 = Nvl(已约数, 0) - v_预约挂号
      Where 日期 = Trunc(r_Bill.登记时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
            (号码 = r_Bill.计算单位 Or 号码 Is Null);
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
        Values
          (Trunc(r_Bill.登记时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生_In, Decode(原医生id_In, 0, Null, 原医生id_In), r_Bill.计算单位,
           -1, -1 * v_预约挂号, -1 * v_预约挂号);
      End If;
    
      ----然后再更新挂号汇总
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + v_预约挂号, 已约数 = Nvl(已约数, 0) + v_预约挂号
      Where 日期 = Trunc(r_Bill.登记时间) And Nvl(科室id, 0) = 科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
            (号码 = 号别_In Or 号码 Is Null);
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
        Values
          (Trunc(r_Bill.登记时间), 科室id_In, r_Bill.收费细目id, 新医生_In, Decode(新医生id_In, 0, Null, 新医生id_In), 号别_In, 1, v_预约挂号,
           v_预约挂号);
      End If;
    End If;
  
    ---更新挂号记录
    Update 门诊费用记录
    Set 执行部门id = 科室id_In, 病人科室id = 科室id_In, 计算单位 = 号别_In, 发药窗口 = 诊室_In,
        --病人病区id = 科室id_In,
        执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null
    Where ID = r_Bill.Id;
  
    --更新病人挂号记录
    If r_Bill.序号 = 1 Then
      v_Temp := Zl_Identity(1);
      Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
      Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
      Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
      Begin
        Select ID Into n_医生id From 人员表 Where 姓名 = 新医生_In And Rownum < 2;
      Exception
        When Others Then
          n_医生id := Null;
      End;
      Zl_就诊变动记录_Insert(r_Bill.No, 2, '分诊换号', v_操作员姓名, v_操作员编号, 号别_In, 科室id_In, Null, n_医生id, 新医生_In, 诊室_In, n_号序, Null);
      v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If v_挂号生成队列 <> 0 Then
        v_现队列名称 := 科室id_In;
        Select ID, 号别, Nvl(号序, 0)
        Into n_业务id, v_号别, n_号序
        From 病人挂号记录
        Where NO = r_Bill.No And Rownum = 1;
        --Zlgetnextqueue(执行部门id_In Number,业务id_In     Number := Null)
        v_排队号码 := Zlgetnextqueue(科室id_In, n_业务id, v_号别 || '|' || n_号序);
        v_排队序号 := Zlgetsequencenum(0, n_业务id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In
        Zl_排队叫号队列_Update(v_现队列名称, 0, n_业务id, 科室id_In, r_Bill.姓名, 诊室_In, 新医生_In, v_排队号码, v_排队序号);
      End If;
      Update 病人挂号记录
      Set 执行部门id = 科室id_In, 号别 = 号别_In, 诊室 = 诊室_In, 执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null
      Where NO = r_Bill.No;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_换号;
/

--86580:张德婷,2015-07-16,修正配置中心瓶签号错误
--83383:张德婷,2015-04-13,修正输液单重复问题
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In And b.病人id = n_病人id
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;
  Function Zl_Getpivaworkbatch
  (
    执行时间_In   In Date,
    配置中心id_In In 输液配药记录.部门id%Type
  ) Return Number As
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 配置中心id_In
      Order By 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 配置中心id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch     := 0;
      v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
      v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
    
      If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
        v_Batch := v_配药批次.批次;
        n_打包  := v_配药批次.打包;
        Exit When v_Batch > 0;
      End If;
    End Loop;
  
    If v_Batch = 0 Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源病区', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  
  v_医嘱ids  := 医嘱id_In;
  v_当前病人 := '';
  v_New相关id:=0;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B
    Where a.收费细目id = b.药品id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
    
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人病区id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
    
    If v_医嘱记录.是否tpn = 2 Then
      v_Continue := 1;  
    end if;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change      := True;
            d_Old执行时间 := v_执行时间;
            
            Select /*+ rule*/
             Count(a.要求时间)
            Into n_Cur
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60;
            
            Select Count(a.要求时间)
            Into n_Sum
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
            Select Count(Distinct a.摆药单号)
            Into n_摆药单
            From 输液配药记录 A
            Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                  a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
          
            If n_Cur <> n_Sum Or  n_摆药单 > 1 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
              
              For v_输液记录 In (Select ID, 执行时间
                             From 输液配药记录
                             Where 医嘱id In
                                   (Select ID
                                    From 病人医嘱记录
                                    Where 病人id =
                                          (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                                   执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60 And 操作状态 < 2) Loop
                v_批次 := Zl_Getpivaworkbatch(v_输液记录.执行时间, 部门id_In);
                Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液记录.Id;
                v_批次 := 0;
              End Loop;
            End If;
          End If;
        
          If b_Change = True Then
            b_Change := True;
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            End If;
          
            If b_Change = True Then
              For v_单个医嘱记录 In c_单个医嘱记录 Loop
                --检查输液单是否调整到打包状态
                Select Count(ID)
                Into n_Sum
                From 输液配药记录
                Where 医嘱id = v_单个医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And
                      打包时间 Is Not Null;
                If n_Sum <> 0 Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              
                Select Count(医嘱id)
                Into n_Cur
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
                Select Count(医嘱id)
                Into n_Sum
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
                If n_Sum <> n_Cur Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              End Loop;
            End If;
          End If;
        
          If v_保持上次批次 = 1 Or b_Change = True Then
            --取上次的批次
            Begin
              Select Distinct 配药批次
              Into v_批次
              From 输液配药记录 A
              Where 医嘱id = v_医嘱记录.相关id And
                    发送号 = (Select Distinct Max(发送号)
                           From 输液配药记录
                           Where 医嘱id = v_医嘱记录.相关id And 发送号 <> v_医嘱记录.发送号) And
                    To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_执行时间, 'hh24:mi:ss');
            Exception
              When Others Then
                v_批次 := 0;
            End;
          End If;
        
          If v_批次 = 0 Then
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, 部门id_In);
          
            --同病人同批次总输液量控制，超过则分配到下个批次
            If v_输液总量 > 0 And Not v_大输液剂型 Is Null And v_批次 < v_Maxbatch Then
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Curdose
                From (Select Distinct c.Id, c.单量
                       From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id And
                             e.药名id = f.药名id And b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And
                             f.药品剂型 = g.Column_Value And a.相关id = v_相关id And b.发送号 = v_发送号);
              Exception
                When Others Then
                  v_Curdose := 0;
              End;
            
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Sumdose
                From (Select Distinct a.Id, a.单量
                       From 药品收发记录 A, 病人医嘱记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where c.Id = d.记录id And a.Id = d.收发id And c.医嘱id = b.Id And a.药品id + 0 = e.药品id And
                             e.药名id = f.药名id And b.病人id + 0 = v_医嘱记录.病人id And f.药品剂型 = g.Column_Value And
                             c.执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And c.配药批次 = v_批次);
              Exception
                When Others Then
                  v_Sumdose := 0;
              End;
            
              If v_Sumdose > 0 And v_Sumdose + v_Curdose > v_输液总量 Then
                v_批次 := v_批次 + 1;
              End If;
            End If;
          End If;
        
          if v_Old相关id<>v_医嘱记录.相关id then
            Select Count(医嘱id)
            Into n_发送次数
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 <= v_执行时间
            Order By 执行时间;
          else
            n_发送次数:=n_发送次数+1;
          end if;
        
          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 启用 = 1 And 配置中心id = 部门id_In And 批次 = v_批次;
          End If;
        
          If Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0 Then
            n_是否打包     := 1;
            d_手工打包时间 := Sysdate;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
           --如果是TPN：如果指定了要打包或配置，则不管其他条件如何都设置为打包或配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, Decode(v_批次, 0, Null, v_批次), v_Maxno, n_调整批次, n_是否打包,
             d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          --产生配药记录对应的药品记录
          For v_收发记录 In c_收发记录 Loop
            If v_收发记录.是否不予配置 = 1 Then
              v_Nodosage := 1;
            End If;
          
            n_Count := n_Count + 1;
          
            Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
          
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
               成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
               产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
              Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                     效期, 付数, 填写数量 / v_Count, 实际数量 / v_Count, 成本价, 成本金额 / v_Count, 扣率, 零售价, 零售金额 / v_Count, 差价 / v_Count,
                     '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                     领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间



        From 药品收发记录
              Where ID = v_收发记录.收发id;
          
            Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, v_收发记录.数量 / v_Count);
          End Loop;
        
        End Loop;
      
        For v_收发记录 In c_收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录 Set 是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--83815:张德婷,2015-04-13,支付宝支付后返回提示信息
CREATE OR REPLACE Procedure Zl_MSG_PointOut
(
  病人id_In  in    number,
  NO_In  in   药品收发记录.NO%Type,
  msg_Out out      varchar2
) As
Begin
  msg_Out:=' ';
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_MSG_PointOut;
/


--83930:刘硕,2015-04-17,抗生素过程修正
CREATE OR REPLACE Procedure Zl_病人抗生素记录_Update
(
  功能_In           Number,
  病人id_In         病人抗生素记录.病人id%Type,
  主页id_In         病人抗生素记录.主页id%Type,
  药名id_In         病人抗生素记录.药名id%Type,
  药品名称_In       病人抗生素记录.药品名称%Type,
  用药目的_In       病人抗生素记录.用药目的%Type,
  使用阶段_In       病人抗生素记录.使用阶段%Type:= Null,
  使用天数_In       病人抗生素记录.使用天数%Type:= Null,
  记录人_In         病人抗生素记录.记录人%Type:= Null,
  记录时间_In       病人抗生素记录.记录时间%Type:= Null,
  一类切口预防用_In 病人抗生素记录.一类切口预防用%Type := Null,
  Ddd数_In          病人抗生素记录.Ddd数%Type := Null,
  联合用药_In       病人抗生素记录.联合用药%Type := Null
) Is
  --功能：首页整理中抗生素的使用记录
  --参数：功能_In 0-新增,1-修改   2-删除
Begin
  If 功能_In = 1 Then
    If 药名id_In Is Null Or 药名id_In = 0 Then
      Update 病人抗生素记录
      Set 用药目的 = 用药目的_In, 使用阶段 = 使用阶段_In, 使用天数 = 使用天数_In, 记录人 = 记录人_In, 记录时间 = 记录时间_In, 一类切口预防用 = 一类切口预防用_In,
          Ddd数 = Ddd数_In, 联合用药 = 联合用药_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 药品名称 = 药品名称_In And NVL(用药目的,'空') = NVL(用药目的_In,'空');
    Else
      Update 病人抗生素记录
      Set 用药目的 = 用药目的_In, 使用阶段 = 使用阶段_In, 使用天数 = 使用天数_In, 记录人 = 记录人_In, 记录时间 = 记录时间_In, 药品名称 = 药品名称_In,
          一类切口预防用 = 一类切口预防用_In, Ddd数 = Ddd数_In, 联合用药 = 联合用药_In
      Where 病人id = 病人id_In And 主页id = 主页id_In And 药名id = 药名id_In And NVL(用药目的,'空') = NVL(用药目的_In,'空');
    End If;
  Elsif 功能_In = 0 Then
    Insert Into 病人抗生素记录
      (病人id, 主页id, 药名id, 药品名称, 用药目的, 使用阶段, 使用天数, 记录人, 记录时间, 一类切口预防用, Ddd数, 联合用药)
    Values
      (病人id_In, 主页id_In, 药名id_In, 药品名称_In, 用药目的_In, 使用阶段_In, 使用天数_In, 记录人_In, 记录时间_In, 一类切口预防用_In, Ddd数_In, 联合用药_In);
  Elsif 功能_In = 2 Then
    If 药名id_In Is Null Or 药名id_In = 0 Then
      Delete From 病人抗生素记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 药品名称 = 药品名称_In And NVL(用药目的,'空') = NVL(用药目的_In,'空');
    Else
      Delete From 病人抗生素记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 药名id = 药名id_In And NVL(用药目的,'空') = NVL(用药目的_In,'空');
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人抗生素记录_Update;
/



--------------------------------------------------------------------------------------------------
--部件变化
--------------------------------------------------------------------------------------------------
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 1,'zlSvgProcess.dll','', Null ,'1','ZL9PACSWORK','[Appsoft]\Public','用于处理svg图像','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLSVGPROCESS.DLL');
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 1,'zlPacsRichPages.ocx','', Null ,'1','ZL9PACSWORK','[Appsoft]\Public','新Pacs报告编辑器核心处理控件','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLPACSRICHPAGES.OCX');
Insert Into zlFilesUpgrade (文件类型,文件名,版本号,修改日期,所属系统,业务部件,安装路径,文件说明,强制覆盖,自动注册,加入日期,序号) select 1,'zlPacsVBCommon.dll','', Null ,'1','ZL9PACSWORK','[Appsoft]\Public','新版PACS报告编辑器和vb层PACS程序交互的部件','0','1',sysdate,序号 from Dual a,(Select max(to_number(序号))+1 序号 from zlfilesupgrade) b where not exists (select 1 from zlfilesupgrade where upper(文件名)='ZLPACSVBCOMMON.DLL');


---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.34.30' Where 编号=&n_System;
--部件版本号
Commit;
