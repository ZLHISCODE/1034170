--[连续升级]1
--[管理工具版本号]10.34.30
--本脚本支持从ZLHIS+ v10.34.30 升级到 v10.34.40
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--99999:刘鹏飞,2015-09-28,缺外键
Create Index 检验普通结果_IX_项目id On 检验普通结果(检验项目ID) Pctfree 5 Tablespace zl9Indexcis nologging;
--88738:胡俊勇,2015-09-28,字段长度不一致
alter table 门诊费用记录 modify 结论 VARCHAR2(1000);

--88901:许华峰,2015-09-24,报告中所有图像都存到FTP中
Alter Table 影像报告原型清单 Add 设备号 Varchar2(3);
Alter Table 影像报告记录 Add 设备号 Varchar2(3);

--84458:涂建华,2015-09-21,新版报告编辑器唯一键结构变动对应调整
Alter Table 报告查阅记录 Add Constraint 报告查阅记录_FK_病历ID Foreign Key (医嘱ID,病历ID,检查报告ID) References 病人医嘱报告(医嘱ID,病历ID,检查报告ID) On Delete Cascade;
Alter Table 影像报告驳回 Add Constraint 影像报告驳回_FK_医嘱ID Foreign Key (医嘱ID,病历ID,检查报告ID) References 病人医嘱报告(医嘱ID,病历ID,检查报告ID) On Delete Cascade;

--88158:余伟节,2015-09-20,河北CA
alter table 人员证书记录 add 时间戳证书 varchar2(3000);

alter table 人员证书记录 add 签章信息 clob;

--84534:涂建华,2015-09-14,优化检查列表查询性能
Create Index 病人医嘱发送_IX_发送执行 On 病人医嘱发送(发送时间,执行部门id) Pctfree 5 Tablespace zl9Indexcis nologging;
Alter Index 病人医嘱发送_IX_发送执行 noparallel;

--87988:马政,2015-09-01,结存管理中加入删除和取消功能
alter table 药品结存记录 add 取消人 varchar2(20);

alter table 药品结存记录 add 取消日期 date;

--87687:刘尔旋,2015-08-24,自定义可预约天数
Alter Table 挂号安排 Add 预约天数 Number(5);

--87051:马政,2015-08-11,材料储备限额设置较慢
Create Index 材料储备限额_IX_材料ID On 材料储备限额(材料ID) Tablespace zl9Indexhis;

--86358:冉俊明,2015-08-10,退费申请模式调整
Alter Table 病人退费申请 Add 审核原因 Varchar2(100);

Alter Table 病人退费申请 Add 状态 Number(2);

Alter Table 病人退费申请 Drop Constraint 病人退费申请_Pk Cascade Drop Index;

Alter Table 病人退费申请 Add Constraint 病人退费申请_Pk Primary Key (NO, 记录性质, 申请时间) Using Index Pctfree 10 Tablespace Zl9indexhis;

--86321:冉俊明,2015-07-27,医保多单据收费分单据结算
Create Table 医保结算明细
(
 结帐id Number(18), 
 NO Varchar2(8), 
 结算方式 Varchar2(20), 
 金额 Number(16, 5), 
 备注 Varchar2(200),
 待转出 Number(3)
) Tablespace zl9Expense;

Alter Table 医保结算明细 Add Constraint 医保结算明细_PK Primary Key(结帐id, NO, 结算方式) Using Index Tablespace zl9Indexhis;

Create Index 医保结算明细_Ix_待转出 On 医保结算明细(待转出) Tablespace Zl9indexhis;




-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 37, '是否显示功能标题', '1', '1',
           '（1.显示 0.不显示）'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '是否显示功能标题' And 模块 = 1802 And 系统 = &n_System);

Insert Into zlParameters
    (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
    Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 37, '是否显示功能标题', '1', '1',
           '（1.显示 0.不显示）'
    From Dual
    Where Not Exists (Select 1 From zlParameters Where 参数名 = '是否显示功能标题' And 模块 = 1803 And 系统 = &n_System);

--88923,李南春,2015-09-24,医疗卡管理过程的执行权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl_病人医疗卡属性_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '发卡' And Upper(对象) = Upper('Zl_病人医疗卡属性_Update'));     
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl_病人免疫记录_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '发卡' And Upper(对象) = Upper('Zl_病人免疫记录_Update'));      
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl_病人免疫记录_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '发卡' And Upper(对象) = Upper('Zl_病人免疫记录_Delete'));
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl_病人过敏药物_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '发卡' And Upper(对象) = Upper('Zl_病人过敏药物_Update'));
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl_病人过敏药物_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '发卡' And Upper(对象) = Upper('Zl_病人过敏药物_Delete'));
 
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl_病人医疗卡属性_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And Upper(对象) = Upper('Zl_病人医疗卡属性_Update'));     
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl_病人免疫记录_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And Upper(对象) = Upper('Zl_病人免疫记录_Update'));      
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl_病人免疫记录_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And Upper(对象) = Upper('Zl_病人免疫记录_Delete'));
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl_病人过敏药物_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And Upper(对象) = Upper('Zl_病人过敏药物_Update'));
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl_病人过敏药物_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And Upper(对象) = Upper('Zl_病人过敏药物_Delete'));

--88936,涂建华,2015-09-24,调整影像系统导航台相关菜单
Update zlMenus Set 标题='病历词句设置', 短标题='病历词句' Where 标题='老版词句设置' And 系统=100 And 模块=1073;
Update zlMenus Set 标题='病历单据设置', 短标题='病历单据' Where 标题='老版单据设置' And 系统=100 And 模块=1076;

--78421:马政,2015-09-09,主界面默认查询天数
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1300, 1, 0, 0, 0, 15, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1300 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1301, 1, 0, 0, 0, 7, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1301 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1302, 1, 0, 0, 0, 8, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1302 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1303, 1, 0, 0, 0, 5, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1303 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1304, 1, 0, 0, 0, 9, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1304 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1305, 1, 0, 0, 0, 7, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1305 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1306, 1, 0, 0, 0, 6, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1306 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1307, 1, 0, 0, 0, 10, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1307 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 0, 9, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1330 And 系统 = &n_System);
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1331, 1, 0, 0, 0, 2, '查询天数', '7', '7', '查询单据的有效天数'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '查询天数' And 模块 = 1331 And 系统 = &n_System);

--86855:马政,2015-09-08,药品全院计划不管站点调整
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 0, 10, '全院计划不管站点', '0', '0',
         '当启用该参数后且实行了站点管理药品计划管理中也能做全院计划，如果没有启用该参数实行站点管理那么就不能做全院计划,0-不可做,1-可做'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数号 = 10 And 系统 = &n_System And 模块 = 1330);

--87689:刘尔旋,2015-08-28,挂号必须输入联系电话
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 66,'输入联系电话', '0', '0', '不要求建病案的号别,是否允许输入该项'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1111 And 参数名 = '输入联系电话');

--87515:刘硕,2015-08-27,转科或转病区时首页不能修改重要的医护人员
Declare
  n_Count Number(1);
Begin
  --数据备份
  Select Count(1) Into n_Count From User_Tables Where Table_Name = Upper('病人变动记录_87515BAK');
  If n_Count <> 0 Then
    Execute Immediate 'drop table 病人变动记录_87515BAK';
  End If;
  Execute Immediate 'create table 病人变动记录_87515BAK as select * from 病人变动记录  where 开始时间 is null and 终止时间 is not null';
  --查询有问题的数据
  For Rs In (Select Id, 病人id, 主页id, 开始原因, 终止人员, 终止时间, 终止原因
             From 病人变动记录
             Where 开始时间 Is Null And 终止时间 Is Not Null) Loop
    Update 病人变动记录 Set 终止原因 = Null, 终止时间 = Null, 终止人员 = Null Where Id = Rs.Id;
  End Loop;
End;
/
--87400:李南春,2015-08-26,自助充值增加住院预交功能
Update zlParameters Set  参数号=13  Where 系统 = &n_System And 模块 = 1804 And 参数名 = '热敏打印部件';
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1804, 0, 1, 0, 0, 17,'自助充值类型', Null, '0', '控制自助机支持的充预交类型:0-门诊预交,1-住院预交,2-门诊住院预交'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1804 And 参数名 = '自助充值类型');
Update zlParameters Set  参数号=17  Where 系统 = &n_System And 模块 = 1804 And 参数名 = '自助充值类型';

--62982:李南春,2015-08-25,收费执行单
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 102,'收费执行单打印方式', Null, '0', '0-不打印,1-自动打印,2-选择是否打印'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1121 And 参数名 = '收费执行单打印方式');

--78751:李南春,2015-08-24,增加预交票据打印格式
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1101, 0, 0, 0, 0, 41,'预交发票格式', Null, '', '预交发票使用的缺省格式:使用类别1,格式1|使用类别2,格式2,其中的格式值为:0-使用本地缺省格式,其它值-票据格式序号'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1101 And 参数名 = '预交发票格式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1101, 1, 0, 0, 0, 42,'预交发票打印方式', Null, '', '格式:预交类别1,打印方式1|预交类别2,打印方式2...|预交类别n,打印方式n'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1101 And 参数名 = '预交发票打印方式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1103, 0, 0, 0, 0, 20,'预交发票格式', Null, '', '预交发票使用的缺省格式:使用类别1,格式1|使用类别2,格式2,其中的格式值为:0-使用本地缺省格式,其它值-票据格式序号'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1103 And 参数名 = '预交发票格式');

--87489:冉俊明,2015-08-19,退费项目缺省选择方式。
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 1, 0, 0, 0, 103, '退费缺省选择方式', -null, '0',
         '通过输入单据号或发票号查找单据退费时费用项目的缺省选择方式:0-缺省按单据号或发票号选择费用项目,1-缺省选择所有单据的费用项目。'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '退费缺省选择方式' And Nvl(模块, 0) = 1121 And Nvl(系统, 0) = &n_System);

--87385:梁唐彬,2015-08-11,领药部门增加参数控制
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1254, 0, 0, 0,  0, 73, '住院领药部门', '0', '0',
         '住院医嘱发送时，根据医院管理要求，决定部门发药时的领药部门,0-给药执行科室;1-病人病区。'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '住院领药部门' And Nvl(模块, 0) = 1254 And Nvl(系统, 0) = &n_System);

--86358:冉俊明,2015-08-10,退费申请模式调整
Update 病人退费申请 Set 状态 = Decode(审核人, Null, 0, Decode(Nvl(状态, 0), 0, 1, 状态));

--86549:马政,2015-07-16,药品报表调整
Declare
  n_门诊id Number(18);
  n_住院id Number(18);
Begin
  --门诊中西药房管理系统
  Begin
    Select ID
    Into n_门诊id
    From zlMenus
    Where 系统 = &n_System And 组别 = '缺省' And 标题 = '门诊中西药房管理系统' And 模块 Is Null;
  Exception
    When Others Then
      n_门诊id := 0;
  End;
  If n_门诊id > 0 Then
    Insert Into zlMenus
      (组别, ID, 上级id, 标题, 短标题, 快键, 图标, 说明, 系统, 模块)
      Select '缺省', Zlmenus_Id.Nextval, n_门诊id, '药品入出汇总表', '药品入出汇总表', Null, 105, '按药品入出经济业务汇总各个药品库房不同剂型药品的库存变化数据。',
             &n_System, 1311
      From Dual
      Where Not Exists (Select 1
             From zlMenus
             Where 组别 = '缺省' And 上级id = n_门诊id And 标题 = '药品入出汇总表' And Nvl(系统, 0) = &n_System);
  
    Insert Into zlMenus
      (组别, ID, 上级id, 标题, 短标题, 快键, 图标, 说明, 系统, 模块)
      Select '缺省', Zlmenus_Id.Nextval, n_门诊id, '药品收发存汇总表', '药品收发存汇总表', Null, 105, '按材质、剂型分类汇总药品的收发调价以及库存金额和差价。',
             &n_System, 1310
      From Dual
      Where Not Exists (Select 1
             From zlMenus
             Where 组别 = '缺省' And 上级id = n_门诊id And 标题 = '药品收发存汇总表' And Nvl(系统, 0) = &n_System);
  End If;
  --住院药房管理系统
  Begin
    Select ID
    Into n_住院id
    From zlMenus
    Where 系统 = &n_System And 组别 = '缺省' And 标题 = '住院药房管理系统' And 模块 Is Null;
  Exception
    When Others Then
      n_住院id := 0;
  End;
  If n_住院id > 0 Then
    Insert Into zlMenus
      (组别, ID, 上级id, 标题, 短标题, 快键, 图标, 说明, 系统, 模块)
      Select '缺省', Zlmenus_Id.Nextval, n_住院id, '药品入出汇总表', '药品入出汇总表', Null, 105, '按药品入出经济业务汇总各个药品库房不同剂型药品的库存变化数据。',
             &n_System, 1311
      From Dual
      Where Not Exists (Select 1
             From zlMenus
             Where 组别 = '缺省' And 上级id = n_住院id And 标题 = '药品入出汇总表' And Nvl(系统, 0) = &n_System);
  
    Insert Into zlMenus
      (组别, ID, 上级id, 标题, 短标题, 快键, 图标, 说明, 系统, 模块)
      Select '缺省', Zlmenus_Id.Nextval, n_住院id, '药品收发存汇总表', '药品收发存汇总表', Null, 105, '按材质、剂型分类汇总药品的收发调价以及库存金额和差价。',
             &n_System, 1310
      From Dual
      Where Not Exists (Select 1
             From zlMenus
             Where 组别 = '缺省' And 上级id = n_住院id And 标题 = '药品收发存汇总表' And Nvl(系统, 0) = &n_System);
  End If;
End;
/

--75453:胡俊勇,2015-07-30,启用血库管理系统参数
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 236, '启用血库管理系统', '1', '1',
         '是否启用了血库系统，1启用，0未启用'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 Is Null And 参数号 = 236);

--86321:冉俊明,2015-07-27,医保多单据收费分单据结算
Insert Into zlBakTables (系统, 组号, 表名, 序号, 直接转出, 停用触发器) Values (&n_System, 1, '医保结算明细', 12, 1, -null);


--80594:马政,2014-12-17,调价产生药品收发记录的NO方式改进
Insert Into 号码控制表 (项目序号, 项目名称, 自动补缺, 编号规则) Values (147, '药品收发记录调价NO', 0, 0);



-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--88911:冉俊明,2015-09-24,添加挂号模块"费别适用科室"表的查询权限
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, '费别适用科室', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1111 And 功能 = '基本' And Upper(对象) = Upper('费别适用科室'));

--88158:余伟节,2015-09-20,河北CA
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,2285,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1341,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1342,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1002,'数字证书注册',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select 'zl_lob_append','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1252,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1208,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All  
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1255,'护理记录签名',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
  Select 'zl_lob_append','EXECUTE' From Dual Union All
  Select 'zl_lob_Read','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;


--87868:张险华,2015-09-08，智能病历增加终末质控接收模块
Insert Into zlPrograms
  (序号, 标题, 说明, 系统, 部件)
  Select 2226 序号, '终末质控接收' 标题, '用于终末质控前进行接收工作及工作量统计' As 说明, &n_System 系统, 'zl9EmrInterface' 部件
  From Dual
  Where Not Exists (Select 1 From zlPrograms Where 序号 = 2226 And 标题='终末质控接收');

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2226,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '基本',0,'基本信息',1 From Dual Union All
Select '系统报表',1,'对系统自带报表的访问',1 From Dual) A
Where Not Exists (Select 1 From zlProgFuncs Where 序号 = 2226 And 功能='基本');

Insert Into zlMenus(组别, ID, 上级id, 标题, 说明, 系统, 模块, 短标题, 图标)
Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
Select 组别,ID From zlMenus Where 标题 = '质控系统管理' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
(Select 标题, 说明, 系统, 模块, 短标题, 图标 From zlMenus Where 1=0 Union ALL
Select '终末质控接收','用于终末质控前进行接收工作及工作量统计',&n_System,2226,'终末质控接收',137 From Dual) B
Where Not Exists (Select 1 From zlMenus Where 模块 = 2226 And 标题='终末质控接收');

--86743:张险华,2015-07-21,增加复制他人病历权限
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
Select &n_System, 1070, a.*
From (Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0 Union All
       Select '复制他人病历', 23, '具有该权限允许复制他人病历内容', 0 From Dual
       Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1070 And 功能 = '复制他人病历')) A;

Insert Into zlProgRelas(系统,序号,组号,功能,关系,主项,主项关系)
Select &n_System,1070,2,A.* From (
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0 Union All
Select '内容复制',2,1,0 From Dual Union All
Select '复制他人病历',2,0,0 From Dual Union All
Select 功能,关系,主项,主项关系 From zlProgRelas Where 1 = 0) A Where Not Exists (Select 1 From zlProgRelas Where 系统 = &n_System And 序号 = 1070 And 功能 = '复制他人病历');

--85950:冉俊明,2015-07-28,补打或重打票据或按病人补打票据时，费用信息写卡
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明)
  Select &n_System, 1137, '门诊信息写卡', 21, '允许对门诊记帐的相关信息进行写卡操作(主要针对医疗卡具有写卡属性).'
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1137 And 功能 = '门诊信息写卡');

--86321:冉俊明,2015-07-27,医保多单据收费分单据结算
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, '医保结算明细', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('医保结算明细'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '基本', User, 'Zl_医保结算明细_Insert', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '基本' And Upper(对象) = Upper('Zl_医保结算明细_Insert'));






-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------
--62982:李南春,2015-08-25,收费执行单
--报表：ZL1_BILL_1121_6/收费执行单
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1121_6','收费执行单','打印指引单',']b"tV~:`g%>\u"ot[2NJ',Null,15,1,0,&n_System,Null,Null,Sysdate,Sysdate,To_Date('2015-04-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2015-04-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,&n_System,1121,'收费执行单');
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'收费执行单',11904,8312,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'收费明细','姓名,202|性别,202|年龄,202|序号,131|项目,202|数量,202|执行科室,202|时间,135|说明,202',User||'.门诊费用记录,'||User||'.部门表,'||User||'.收费项目目录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select A.姓名,A.性别,A.年龄,A.序号,C.名称 as 项目,A.付数 * A.数次|| A.计算单位 as 数量,B.名称 as 执行科室,A.登记时间 as 时间,B.位置 as 说明' From Dual Union All
  Select 2,'From 门诊费用记录 A,部门表 B,收费项目目录 C' From Dual Union All
  Select 3,'where  A.执行部门id=B.id and A.收费细目id=C.id  ' From Dual Union All
  Select 4,'AND A.记录性质=1 and A.记录状态=1 ' From Dual Union All
  Select 5,'AND A.no IN([0])' From Dual Union All
  Select 6,'Order By A.序号' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',3,'''A0000001''',0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,'任意表1',11,'姓名:[收费明细.姓名]',Null,855,2040,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',12,'[单位名称]',Null,2118,660,7575,360,0,1,0,'宋体',18,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'任意表1',12,'收费执行单',Null,4668,1230,2475,495,0,0,1,'宋体',24,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签4',2,Null,0,'任意表1',12,'性别:[收费明细.性别]',Null,5005,2040,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,'任意表1',23,'打印时间：[yyyy-MM-dd HH:mm]',Null,8435,7450,2520,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,'任意表1',13,'年龄:[收费明细.年龄]',Null,9155,2040,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'发送医嘱明细',Null,855,2325,10100,4980,450,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[收费明细.项目]','4^450^项目',0,0,3180,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[收费明细.数量]','4^450^数量',0,0,1005,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[收费明细.执行科室]','4^450^执行科室',0,0,1365,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[收费明细.时间]','4^450^时间',0,0,1635,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[收费明细.说明]','4^450^说明',0,0,2865,0,255,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1121_6/收费执行单
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1121,'收费执行单','打印指引单');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1121,'收费执行单',User,'部门表','SELECT' From Dual Union All
  Select &n_System,1121,'收费执行单',User,'门诊费用记录','SELECT' From Dual Union All
  Select &n_System,1121,'收费执行单',User,'收费项目目录','SELECT' From Dual;




-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--86711:马政,2015-07-24,配合血库系统改进
Create Or Replace Procedure Zl_收费细目_Insert
(
  特殊项目_In In Number := 0, ---增加了特殊项目的说明
  Id_In       In 收费项目目录.Id%Type,
  类别_In     In 收费项目目录.类别%Type,
  编码_In     In 收费项目目录.编码%Type,
  标识主码_In In 收费项目目录.标识主码%Type,
  标识子码_In In 收费项目目录.标识子码%Type,
  备选码_In   In 收费项目目录.备选码%Type,
  名称_In     In 收费项目目录.名称%Type,
  --修改了上级ID为分类ID
  分类id_In       In 收费项目目录.分类id%Type := Null,
  规格_In         In 收费项目目录.规格%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  计算单位_In     In 收费项目目录.计算单位%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  是否变价_In     In 收费项目目录.是否变价%Type := 0,
  加班加价_In     In 收费项目目录.加班加价%Type := 0,
  执行科室_In     In 收费项目目录.执行科室%Type := 0,
  服务对象_In     In 收费项目目录.服务对象%Type := 0,
  补充摘要_In     In 收费项目目录.补充摘要%Type := 0,
  最高限价_In     In 收费项目目录.最高限价%Type := Null,
  最低限价_In     In 收费项目目录.最低限价%Type := Null,
  别名列表_In     In Varchar2 := Null,
  录入限量_In     In 收费项目目录.录入限量%Type := Null,
  限量范围_In     In Number := 0,
  费用确认_In     In 收费项目目录.费用确认%Type := 0,
  费用确认范围_In Number := 0,
  计算方式_In     In 收费项目目录.计算方式%Type := 0,
  站点_In         In 收费项目目录.站点%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  项目特性_In     In 收费项目目录.项目特性%Type := Null
) Is
  Intpos  Pls_Integer;
  Strtemp Varchar2(4000);
  v_名称  收费项目目录.名称%Type;
  v_性质  收费项目别名.性质%Type;
  v_码类  收费项目别名.码类%Type;
  v_简码  收费项目别名.简码%Type;
Begin

  ----特殊项目_IN    代表以下信息
  ---挂号项目:1为挂号项目 2为急诊挂号项目
  ---护理项目:3为护理项目中的一般项目 4为护理项目中的护理等级  5为护理项目中的基本护理等级
  ---其他一般项目或床位项目
  If 特殊项目_In = 1 Or 特殊项目_In = 2 Then
    ---为挂号项目
    Insert Into 收费项目目录
      (ID, 类别, 分类id, 编码, 标识主码, 标识子码, 备选码, 名称, 项目特性, 规格, 计算单位, 说明, 费用类型, 屏蔽费别, 是否变价, 加班加价, 执行科室, 服务对象, 补充摘要, 建档时间, 撤档时间,
       最高限价, 最低限价, 录入限量, 费用确认, 计算方式, 病案费目, 站点)
    Values
      (Id_In, 类别_In, 分类id_In, 编码_In, 标识主码_In, 标识子码_In, 备选码_In, 名称_In, Decode(特殊项目_In, 2, 1, 0), 规格_In, 计算单位_In, 说明_In,
       费用类型_In, 0, 0, 0, 执行科室_In, 服务对象_In, 0, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), 最高限价_In, 最低限价_In, 录入限量_In,
       费用确认_In, 计算方式_In, 病案费目_In, 站点_In);
  Else
    If 特殊项目_In = 3 Or 特殊项目_In = 4 Or 特殊项目_In = 5 Then
      ---为护理项目
      Insert Into 收费项目目录
        (ID, 类别, 分类id, 编码, 标识主码, 标识子码, 备选码, 名称, 项目特性, 规格, 计算单位, 说明, 费用类型, 屏蔽费别, 是否变价, 加班加价, 执行科室, 服务对象, 补充摘要, 建档时间,
         撤档时间, 最高限价, 最低限价, 录入限量, 费用确认, 计算方式, 病案费目, 站点)
      Values
        (Id_In, 类别_In, 分类id_In, 编码_In, 标识主码_In, 标识子码_In, 备选码_In, 名称_In, 特殊项目_In - 3, 规格_In, 计算单位_In, 说明_In, 费用类型_In, 0,
         0, 0, 执行科室_In, 服务对象_In, 0, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), 最高限价_In, 最低限价_In, 录入限量_In, 费用确认_In,
         计算方式_In, 病案费目_In, 站点_In);
    Else
      ---为一般项目或床位等级项目等等
      Insert Into 收费项目目录
        (ID, 类别, 分类id, 编码, 标识主码, 标识子码, 备选码, 名称, 项目特性, 规格, 计算单位, 说明, 费用类型, 屏蔽费别, 是否变价, 加班加价, 执行科室, 服务对象, 补充摘要, 建档时间,
         撤档时间, 最高限价, 最低限价, 录入限量, 费用确认, 计算方式, 病案费目, 站点)
      Values
        (Id_In, 类别_In, 分类id_In, 编码_In, 标识主码_In, 标识子码_In, 备选码_In, 名称_In, 项目特性_In, 规格_In, 计算单位_In, 说明_In, 费用类型_In,
         屏蔽费别_In, 是否变价_In, 加班加价_In, 执行科室_In, 服务对象_In, 补充摘要_In, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), 最高限价_In,
         最低限价_In, 录入限量_In, 费用确认_In, 计算方式_In, 病案费目_In, 站点_In);
    End If;
  End If;
  --接着插入别名
  Strtemp := 别名列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, '''');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到性质
      v_性质  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到别名
      Intpos  := Instr(Strtemp, '''');
      v_名称  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到码类
      Intpos  := Instr(Strtemp, '''');
      v_码类  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到简码
      Intpos  := Instr(Strtemp, '''');
      v_简码  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 收费项目别名 (收费细目id, 性质, 名称, 简码, 码类) Values (Id_In, v_性质, v_名称, v_简码, v_码类);
    End If;
  End Loop;

  --录入限量按指定范围批量更新
  If 限量范围_In = 1 Then
    --本级
    If 分类id_In Is Null Then
      Update 收费项目目录 Set 录入限量 = 录入限量_In Where 分类id Is Null;
    Else
      Update 收费项目目录 Set 录入限量 = 录入限量_In Where 分类id = 分类id_In;
    End If;
  Elsif 限量范围_In = 2 Then
    --本分类
    If 分类id_In Is Null Then
      Update 收费项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id);
    Else
      Update 收费项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id);
    End If;
  Elsif 限量范围_In = 3 Then
    --本类别
    Update 收费项目目录 Set 录入限量 = 录入限量_In Where 类别 = 类别_In;
  Elsif 限量范围_In = 4 Then
    --所有
    Update 收费项目目录 Set 录入限量 = 录入限量_In Where 类别 Not In ('4', '5', '6', '7');
  End If;

  --费用确认应用范围
  If 费用确认范围_In = 1 Then
    --本分类
    If 分类id_In Is Null Then
      Update 收费项目目录
      Set 费用确认 = 费用确认_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id);
    Else
      Update 收费项目目录
      Set 费用确认 = 费用确认_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id);
    End If;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Insert;
/

--86711:马政,2015-07-24,配合血库系统改进
Create Or Replace Procedure Zl_收费细目_Update
(
  特殊项目_In In Number := 0, ---增加了特殊项目的说明
  Id_In       In 收费项目目录.Id%Type,
  类别_In     In 收费项目目录.类别%Type,
  编码_In     In 收费项目目录.编码%Type,
  标识主码_In In 收费项目目录.标识主码%Type,
  标识子码_In In 收费项目目录.标识子码%Type,
  备选码_In   In 收费项目目录.备选码%Type,
  名称_In     In 收费项目目录.名称%Type,
  --修改了上级ID为分类ID
  分类id_In       In 收费项目目录.分类id%Type := Null,
  规格_In         In 收费项目目录.规格%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  计算单位_In     In 收费项目目录.计算单位%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  是否变价_In     In 收费项目目录.是否变价%Type := 0,
  加班加价_In     In 收费项目目录.加班加价%Type := 0,
  服务对象_In     In 收费项目目录.服务对象%Type := Null,
  补充摘要_In     In 收费项目目录.补充摘要%Type := 0,
  最高限价_In     In 收费项目目录.最高限价%Type := 0,
  最低限价_In     In 收费项目目录.最低限价%Type := 0,
  别名列表_In     In Varchar2 := Null,
  录入限量_In     In 收费项目目录.录入限量%Type := Null,
  限量范围_In     In Number := 0,
  费用确认_In     In 收费项目目录.费用确认%Type := 0,
  费用确认范围_In Number := 0,
  计算方式_In     In 收费项目目录.计算方式%Type := 0,
  站点_In         In 收费项目目录.站点%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  项目特性_In     In 收费项目目录.项目特性%Type := Null
) Is
  Intpos  Pls_Integer;
  Strtemp Varchar2(4000);
  v_名称  收费项目目录.名称%Type;
  v_性质  收费项目别名.性质%Type;
  v_码类  收费项目别名.码类%Type;
  v_简码  收费项目别名.简码%Type;

  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  ----特殊项目_IN    代表以下信息
  ---挂号项目:1为挂号项目 2为急诊挂号项目
  ---护理项目:3为护理项目中的一般项目 4为护理项目中的护理等级  5为护理项目中的基本护理等级
  ---其他一般项目或床位项目

  If 特殊项目_In = 1 Or 特殊项目_In = 2 Then
    ---为挂号项目
    Update 收费项目目录
    Set 类别 = 类别_In, 分类id = 分类id_In, 编码 = 编码_In, 标识主码 = 标识主码_In, 标识子码 = 标识子码_In, 备选码 = 备选码_In, 名称 = 名称_In, 计算单位 = 计算单位_In,
        说明 = 说明_In, 费用类型 = 费用类型_In, 屏蔽费别 = 0, 是否变价 = 0, 加班加价 = 0, 服务对象 = 服务对象_In, 补充摘要 = 0, 最高限价 = 最高限价_In,
        最低限价 = 最低限价_In, 项目特性 = Decode(特殊项目_In, 2, 1, 0), 录入限量 = 录入限量_In, 费用确认 = 费用确认_In, 计算方式 = 计算方式_In, 病案费目 = 病案费目_In,
        站点 = 站点_In
    Where ID = Id_In;
  Else
    If 特殊项目_In = 3 Or 特殊项目_In = 4 Or 特殊项目_In = 5 Then
      ---为护理项目
      ---将如果当前是基本护理那么在数据中将其它为基本护理的置为护理等级
      If 特殊项目_In - 3 = 2 Then
        Update 收费项目目录 Set 项目特性 = 1 Where 类别 = 'H' And 项目特性 = 2;
      End If;
      ---更新收护理收费项目
      Update 收费项目目录
      Set 类别 = 类别_In, 分类id = 分类id_In, 编码 = 编码_In, 标识主码 = 标识主码_In, 标识子码 = 标识子码_In, 备选码 = 备选码_In, 名称 = 名称_In,
          计算单位 = 计算单位_In, 说明 = 说明_In, 费用类型 = 费用类型_In, 屏蔽费别 = 0, 是否变价 = 0, 加班加价 = 0, 服务对象 = 服务对象_In, 补充摘要 = 0,
          最高限价 = 最高限价_In, 最低限价 = 最低限价_In, 项目特性 = 特殊项目_In - 3, 录入限量 = 录入限量_In, 费用确认 = 费用确认_In, 计算方式 = 计算方式_In,
          病案费目 = 病案费目_In, 站点 = 站点_In
      Where ID = Id_In;
    Else
      ---为一般项目或床位等级项目等等
      Update 收费项目目录
      Set 类别 = 类别_In, 分类id = 分类id_In, 编码 = 编码_In, 标识主码 = 标识主码_In, 标识子码 = 标识子码_In, 备选码 = 备选码_In, 名称 = 名称_In,
          项目特性 = Decode(类别_In, 'K', 项目特性_In, 项目特性), 规格 = 规格_In, 计算单位 = 计算单位_In, 说明 = 说明_In, 费用类型 = 费用类型_In,
          屏蔽费别 = 屏蔽费别_In, 是否变价 = 是否变价_In, 加班加价 = 加班加价_In, 服务对象 = 服务对象_In, 补充摘要 = 补充摘要_In, 最高限价 = 最高限价_In, 最低限价 = 最低限价_In,
          录入限量 = 录入限量_In, 费用确认 = 费用确认_In, 计算方式 = 计算方式_In, 病案费目 = 病案费目_In, 站点 = 站点_In
      Where ID = Id_In;
    End If;
  End If;
  --修改别名表
  Delete From 收费项目别名 Where 收费细目id = Id_In;

  --接着插入别名
  Strtemp := 别名列表_In;

  While Strtemp Is Not Null Loop
    Intpos := Instr(Strtemp, '''');
  
    If Intpos = 0 Then
      Strtemp := '';
    Else
      --得到性质
      v_性质  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到别名
      Intpos  := Instr(Strtemp, '''');
      v_名称  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到码类
      Intpos  := Instr(Strtemp, '''');
      v_码类  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
      --得到简码
      Intpos  := Instr(Strtemp, '''');
      v_简码  := Substr(Strtemp, 1, Intpos - 1);
      Strtemp := Substr(Strtemp, Intpos + 1);
    
      Insert Into 收费项目别名 (收费细目id, 性质, 名称, 简码, 码类) Values (Id_In, v_性质, v_名称, v_简码, v_码类);
    End If;
  End Loop;

  --录入限量按指定范围批量更新
  If 限量范围_In = 1 Then
    --本级
    If 分类id_In Is Null Then
      Update 收费项目目录 Set 录入限量 = 录入限量_In Where 分类id Is Null;
    Else
      Update 收费项目目录 Set 录入限量 = 录入限量_In Where 分类id = 分类id_In;
    End If;
  Elsif 限量范围_In = 2 Then
    --本分类
    If 分类id_In Is Null Then
      Update 收费项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id);
    Else
      Update 收费项目目录
      Set 录入限量 = 录入限量_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id);
    End If;
  Elsif 限量范围_In = 3 Then
    --本类别
    Update 收费项目目录 Set 录入限量 = 录入限量_In Where 类别 = 类别_In;
  Elsif 限量范围_In = 4 Then
    --所有
    Update 收费项目目录 Set 录入限量 = 录入限量_In Where 类别 Not In ('4', '5', '6', '7');
  End If;

  --费用确认应用范围
  If 费用确认范围_In = 1 Then
    --本分类
    If 分类id_In Is Null Then
      Update 收费项目目录
      Set 费用确认 = 费用确认_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id);
    Else
      Update 收费项目目录
      Set 费用确认 = 费用确认_In
      Where 分类id In (Select ID From 诊疗分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id);
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Update;
/

--88901:许华峰,2015-09-24,报告中所有图像都存到FTP中
CREATE OR REPLACE Package b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
  );
  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
  Val           Out t_Refcur,
  种类_In      影像报告原型清单.种类%Type,
  Stop_Flag    Number,
  Condition_In Varchar2
  );
  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
  Id_In           影像报告原型清单.ID%Type,
  种类_In         影像报告原型清单.种类%Type,
  编码_In         影像报告原型清单.编码%Type,
  名称_In         影像报告原型清单.名称%Type,
  设备号_In       影像设备目录.设备号%Type,
  说明_In         影像报告原型清单.说明%Type,
  可否重置页面_In 影像报告原型清单.可否重置页面%Type,
  可否重置格式_In 影像报告原型清单.可否重置格式%Type,
  是否禁用_In     影像报告原型清单.是否禁用%Type,
  创建人_In       影像报告原型清单.创建人%Type,
  内容_In         影像报告原型清单.内容%Type,
  控制选项_In     影像报告原型清单.控制选项%Type,
  专用插件_In     影像报告原型清单.专用插件%Type,
  Copy_Id_In      影像报告原型清单.ID%Type,
  Only_Head_In    Varchar2,
  分组_In         影像报告原型清单.分组%Type
  );
  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In       影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_Id_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
  );
  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
  );
  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
  Val           Out t_Refcur,
  Id_In 影像报告原型清单.Id%Type
  );
  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
  Val           Out t_Refcur,
  Id_In 影像报告原型清单.Id%Type
  );
  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
  );

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
  );
  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind;
  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
  );
  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
  编码_In 影像报告预备提纲.编码%Type,
  名称_In 影像报告预备提纲.名称%Type,
  说明_In 影像报告预备提纲.说明%Type
  );
  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline;
  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
  );
  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
  片段ID_In 影像报告原型片段.片段ID%Type
  );
  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
  );
  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  );
  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
    Val           Out t_Refcur,    
  原型ID_In 影像报告原型片段.原型ID%Type,
    片段ID_In 影像报告原型片段.片段ID%Type
  );
  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    Id_In     影像报告原型清单.Id%Type,
  内容_In   影像报告原型清单.内容%Type,
  修改人_In 影像报告原型清单.修改人%Type
  );
  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
  );
  --21.获取已经设置了关联的原型片段类别的信息

  Procedure p_Get_Antetype_Fragments_Info(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  );
  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
  Val           Out t_Refcur,
  原型id_In Varchar2
  );
  --23.获取能复制的原型名称

  Procedure p_Get_Copy_Antetype(
  Val           Out t_Refcur,
  种类_In 影像报告原型清单.种类%Type
  );
  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
  Val           Out t_Refcur,
  种类_In 影像报告原型清单.种类%Type
  );
  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型id_In 影像报告原型清单.Id%Type
  );
  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
  );
  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
  Val           Out t_Refcur,
  编码_In 影像报告种类.编码%Type
  );
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
  );
  --29.获取关于原型导出的重复信息

  Procedure p_Get_Antetypelist_Same_Info(
  Val           Out t_Refcur,
  Tablename_In Varchar2,
    Id_In        影像报告原型清单.Id%Type,
    编码_In      Varchar2,
    名称_In      Varchar2
  );
  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
  Val           Out t_Refcur,  
  Id_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
  );
  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
  );

  ----32.获取元素或者提纲的名称集合
  --Procedure p_Get_Antetype_Ele_Section(
  --原型ID_In  影像报告原型清单.Id%Type,
  --Val     Out t_Refcur);

  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
  Val           Out t_Refcur,
  原型id_In 影像报告动作.原型id%Type
  );

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
  Val           Out t_Refcur,
  名称_In 影像字典清单.名称%Type
  );
  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
  );
  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
  Val           Out t_Refcur,
  学科_In Varchar2
  );

  --37.获取词句信息
  Procedure p_Get_Fragment_Filter(
  Val           Out t_Refcur,
  原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
  );
  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  );
  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
  );
  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
  Val           Out t_Refcur,
  Table_Name_In Varchar2
  );
  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
  );
  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
  );
  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
  Val           Out t_Refcur,
  原型ID_In       影像报告事件.原型ID%Type,
  Include_Base_In Number
  );
  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
  序号_In 影像报告动作.序号%Type
  );
  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
  );
  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
  );
  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型清单.Id%Type,
  Type_In   Varchar2
  );
  --50.删除文档处理
  Procedure p_Del_Doc_Process(
    Id_In        影像报告动作.ID%Type,
  Del_Event_In Number
  );

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
  Val           Out t_Refcur,
  Id_In    影像报告值域清单.Id%Type,
  Code_In  Varchar2,
  Title_In Varchar2,
  Flag_In  Varchar2
  );
  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
  );
  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
  Val           Out t_Refcur,
  ID_In Varchar2
  );
  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
  );
  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
  );
  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
  );
  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
  );
  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
  Val           Out t_Refcur,
  ID_In 影像报告插件.ID%type
  );
  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
  Val           Out t_Refcur,
  ID_In   影像报告插件.ID%Type,
    编码_In 影像报告插件.编码%Type,
    名称_In 影像报告插件.名称%Type
  );
  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
  Val           Out t_Refcur,
  ID_In 影像报告插件.ID%Type
  );
  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
  Val           Out t_Refcur,
  类别_In Varchar2,
    条件_In Varchar2
  );
  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
  );
  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
  应用场合_In   影像报告原型应用.应用场合%Type,
  报告原型ID_In 影像报告原型应用.报告原型ID%Type
  );
  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
  );
  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
  Val           Out t_Refcur,
  报告原型ID_In 影像报告原型应用.报告原型ID%Type
  );
  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
  );
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
  Val           Out t_Refcur,
  ID_In 影像报告原型清单.ID%Type
  );
  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
  Val           Out t_Refcur,
  编码_In 影像报告原型清单.编码%Type,
    名称_In 影像报告原型清单.名称%Type,
    ID_In  影像报告原型清单.ID%Type
  );
  --69  获取影像存储设备
  Procedure p_GetStorageDevice(
    Val           Out t_Refcur);

End b_PACS_RptAntetype;
/

CREATE OR REPLACE Package Body b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select 编码, a.名称, a.编码 || '-' || a.名称 As 标题
        From 影像报告种类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelistkind;

  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
  Val           Out t_Refcur,
  种类_In      影像报告原型清单.种类%Type,
    Stop_Flag    Number,
    Condition_In Varchar2
  ) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And a.分组 Is Not Null
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.
               种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelis_By_Kind;

  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In       影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    创建人_In       影像报告原型清单.创建人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
  ) As
    x_Str Xmltype;
  Begin
    Begin
      If Copy_ID_In Is Null or Copy_ID_In = 0 Then
        x_Str := 内容_In;
      Else
        Select Decode(Only_Head_In,
                      1,
                      Deletexml(a.内容, '/zlxml/document/node()'),
                      a.内容)
          Into x_Str
          From 影像报告原型清单 A
         Where a.id = Copy_ID_In;
      End If;
    Exception
      When Others Then
        x_Str := 内容_In;
    End;
  
    Insert Into 影像报告原型清单
      (ID,
       种类,
       编码,
       名称,
       设备号,
       说明,
       可否重置页面,
       可否重置格式,
       是否禁用,
       创建人,
       创建时间,
       内容,
       控制选项,
       专用插件,
       分组)
    Values
      (ID_In,
       种类_In,
       编码_In,
       名称_In,
       设备号_In,
       说明_In,
       可否重置页面_In,
       可否重置格式_In,
       是否禁用_In,
       创建人_In,
       sysdate,
       x_Str,
       控制选项_In,
       专用插件_In,
       分组_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetypelist;

  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In       影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
  ) As
    x_Str     Xmltype;
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告原型清单 A
     Where (a.编码 = 编码_In Or a.名称 = 名称_In)
       And ID <> ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在相同的文档编码或者名称，请重新填写！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Copy_ID_In Is Null or Copy_ID_In = 0 Then
      x_Str := 内容_In;
    Else
      Select Decode(Only_Head_In,
                    1,
                    Deletexml(a.内容, '/zlxml/document/node()'),
                    a.内容)
        Into x_Str
        From 影像报告原型清单 A
       Where a.id = Copy_ID_In;
    End If;
  
    Update 影像报告原型清单
       Set 种类         = 种类_In,
           编码         = 编码_In,
           名称         = 名称_In,
           设备号       = 设备号_In,
           说明         = 说明_In,
           可否重置页面 = 可否重置页面_In,
           可否重置格式 = 可否重置格式_In,
           是否禁用     = NVL(是否禁用_In, 是否禁用),
           修改人       = 修改人_In,
           修改时间     = sysdate,
           内容         = x_Str,
           控制选项     = 控制选项_In,
           专用插件     = 专用插件_In,
           分组         = 分组_In
     Where ID = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist;

  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
  ) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(ID) Into n_Num From 影像报告记录 A Where a.原型id = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该原型已经被文档使用，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(原型ID)
      Into n_Num
      From 影像报告原型片段
     Where 影像报告原型片段.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该文档下存在词句关联，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(ID)
      Into n_Num
      From 影像报告范文清单
     Where 影像报告范文清单.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在以此原型建立的范文信息，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告原型清单 C Where c.Id = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetypelist;

  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
  Val           Out t_Refcur,
  ID_In 影像报告原型清单.Id%Type
  ) As
  Begin
    Open Val For
      Select rawtohex(a.ID) ID,
             a.种类,
             a.编码,
             a.名称,
             a.设备号,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
             Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
             Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
             Nvl(a.控制选项.GetClobVal(), '<NULL/>') as 控制选项,
             a.是否禁用,
             Nvl(a.专用插件.GetClobVal(), '<NULL/>') as 专用插件,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             a.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_By_Id;

  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
  Val           Out t_Refcur,
  ID_In 影像报告原型清单.Id%Type
  ) As
  Begin
    Open Val For
      Select Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Content;

  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
  ) As
  Begin
    Update 影像报告原型清单
       Set 是否禁用 = Decode(是否禁用, 1, 0, 0, 1)
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Stop_Antetypelist;

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
  ) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告种类 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 编码_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告种类
      (编码, 名称, 说明)
    Values
      (编码_In, 名称_In, 说明_In);
  
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Kind;

  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind As
  Begin
    Delete From 影像报告种类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Kind;

  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID, 编码, 名称, 说明, 最后编辑时间
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Pre_Outline;

  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
    编码_In 影像报告预备提纲.编码%Type,
    名称_In 影像报告预备提纲.名称%Type,
    说明_In 影像报告预备提纲.说明%Type
  ) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告预备提纲 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 名称_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告预备提纲
      (ID, 编码, 名称, 说明, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, sysdate);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Pre_Outline;

  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline As
  Begin
    Delete From 影像报告预备提纲;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Pre_Outline;

  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select '类别' As 类别,
             b.编码 As ID,
             Null As 种类,
             b.名称 As 种类名称,
             b.编码 As 编码,
             b.名称 As 名称,
             b.说明 As 说明,
             Null As 可否重置页面,
             Null As 可否重置格式,
             Null As 是否禁用,
             Null As 创建人,
             Null As 创建时间,
             Null As 修改人,
             Null As 修改时间,
             Null As 内容
        From 影像报告种类 B
      Union All
      Select '原型' 类别,
             RawToHex(a.Id) ID,
             a.种类,
             b.名称 种类名称,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             a.是否禁用,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             Null As 内容
        From 影像报告原型清单 A, 影像报告种类 B
       Where a.种类 = b.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Output_Antetypelist;

  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
  片段ID_In 影像报告原型片段.片段ID%Type) As
  Begin
    Insert Into 影像报告原型片段
      (原型ID, 片段ID)
    Values
      (原型ID_In, 片段ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetype_Fragments;

  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
  ) As
  Begin
    Delete From 影像报告原型片段 Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetype_Fragments;

  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments;

  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type,
  片段ID_In 影像报告原型片段.片段ID%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In
         And a.片段ID = 片段ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_f_Byaidfid;

  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    ID_In     影像报告原型清单.Id%Type,
  内容_In   影像报告原型清单.内容%Type,
  修改人_In 影像报告原型清单.修改人%Type
  ) As
  Begin
    Update 影像报告原型清单
       Set 内容 = 内容_In, 修改人 = 修改人_In, 修改时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist_Content;

  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             编码 || '-' || 名称 As 名称,
             分组,
             a.种类,
             a.是否禁用,
             a.说明,
             Decode(a.是否禁用, 1, 2, 1) Imageindex,
             Nvl(a.内容.GetClobVal(), '<ZLXML/>') As 内容
        From 影像报告原型清单 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Antetype_Lists;

  --21.获取已经设置了关联的原型片段类别的信息
  Procedure p_Get_Antetype_Fragments_Info(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             a.名称,
             a.编码 || '-' || a.名称 标题,
             a.说明
        From 影像报告片段清单 A
       Where a.Id In (Select b.片段id
                        From 影像报告原型片段 B
                       Where b.原型id = 原型ID_In)
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments_Info;

  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
  Val           Out t_Refcur,
  原型ID_In Varchar2
  ) As
    v_Sql  Varchar2(4000);
    v_Aids Varchar2(4000);
    v_Msg  Varchar2(4000);
    Err Exception;
  Begin
    For Myrow In (Select RawtoHex(a.片段id) ID
                    From 影像报告原型片段 A
                   Where a.原型id = 原型ID_In) Loop
      If v_Aids Is Null Then
        v_Aids := '''' || Myrow.Id || '''';
      Else
        v_Aids := v_Aids || ',''' || Myrow.Id || '''';
      End If;
    End Loop;
  
    If v_Aids Is Null Then
      If Substr(原型ID_In, 0, 1) <> '''' Then
        v_Aids := '''' || 原型ID_In || '''';
      Else
        v_Aids := 原型ID_In;
      End If;
    End If;
  
    v_Sql := 'Select Distinct  RawtoHex(a.id) ID,  RawtoHex(a.上级ID) 上级ID , a.编码, a.编码 || ''-'' || a.名称 标题,Decode(a.节点类型, 0, 0, 1) 节点类型
      From 影像报告片段清单 A
      Start With a.Id In (' || v_Aids || ')
      Connect By Prior a.Id = a.上级ID
      Order By a.编码';
  
    Open Val For v_Sql;
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Selected_Fragments;

  --23.获取能复制的原型名称
  Procedure p_Get_Copy_Antetype(
  Val           Out t_Refcur,
  种类_In 影像报告原型清单.种类%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID, a.编码 || '-' || a.名称 标题
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Copy_Antetype;

  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
  Val           Out t_Refcur,
  种类_In 影像报告原型清单.种类%Type
  ) As
  Begin
    Open Val For
      Select Distinct a.分组 As 分组
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
         and a.分组 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Category;

  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型ID_In 影像报告原型清单.Id%Type
  ) As
    x_Content Xmltype;
    x_Result  Xmltype;
    Cursor c_Antetype Is
      Select Extractvalue(c.Column_Value, '/section/@iid') Iid,
             Extractvalue(c.Column_Value, '/section/@title') Title,
             c.Column_Value As Content
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.内容, '/zlxml//section'))) C
       Where a.Id = 原型ID_In;
    n_i               Number;
    n_j               Number;
    n_Count           Number;
    x_Subdocuments    Xmltype;
    x_Docparameters   Xmltype;
    x_Antetypecontent Xmltype;
    v_Textstyleno     Varchar2(10);
    v_Parastyleno     Varchar2(10);
    x_Acontent        Xmltype;
  Begin
    For Mysample In (Select b.id, b.内容
                       From 影像报告范文清单 B
                      Where b.原型id = 原型ID_In) Loop
      x_Content := Mysample.内容;
      n_i       := 1;
      If x_Content Is Null Then
        Select a.内容
          Into x_Result
          From 影像报告原型清单 A
         Where a.Id = 原型ID_In;
      Else
        Begin
          Select Extractvalue(c.Column_Value, '/section/@textstyleno') Textstyleno,
                 Extractvalue(c.Column_Value, '/section/@parastyleno') Parastyleno
            Into v_Textstyleno, v_Parastyleno
            From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C
           Where Rownum = 1;
        Exception
          When Others Then
            v_Textstyleno := '1';
            v_Parastyleno := '1';
        End;
      
        For Myantetype In c_Antetype Loop
          For I In 1 .. 1 Loop
            If n_i <> 1 Or n_Count <> 0 Or n_Count Is Null Then
              Select Count(*)
                Into n_Count
                From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C;
            End If;
            If n_Count < n_i Then
              Select Updatexml(Myantetype.Content,
                               '//section/@textstyleno',
                               v_Textstyleno)
                Into x_Acontent
                From Dual;
              Select Updatexml(x_Acontent,
                               '//section/@parastyleno',
                               v_Parastyleno)
                Into x_Acontent
                From Dual;
              Select Appendchildxml(x_Content,
                                    '/zlxml/document',
                                    x_Acontent)
                Into x_Content
                From Dual;
              Exit;
            End If;
            n_j := 1;
            For Mysample In (Select Extractvalue(c.Column_Value,
                                                 '/section/@iid') Iid,
                                    Extractvalue(c.Column_Value,
                                                 '/section/@title') Title
                               From Table(Xmlsequence(Extract(x_Content,
                                                              '/zlxml//section'))) C) Loop
              If n_i = n_j Then
                If Myantetype.Iid <> Mysample.Iid Then
                  Select Updatexml(Myantetype.Content,
                                   '//section/@textstyleno',
                                   v_Textstyleno)
                    Into x_Acontent
                    From Dual;
                  Select Updatexml(x_Acontent,
                                   '//section/@parastyleno',
                                   v_Parastyleno)
                    Into x_Acontent
                    From Dual;
                  Select Deletexml(x_Content,
                                   '//section[@iid="' || Myantetype.Iid || '"]')
                    Into x_Content
                    From Dual;
                  Select Insertxmlbefore(x_Content,
                                         '//section[@iid="' || Mysample.Iid || '"]',
                                         x_Acontent)
                    Into x_Content
                    From Dual;
                  n_j := n_j + 1;
                  Exit;
                Else
                  n_j := n_j + 1;
                  Exit;
                End If;
              End If;
              n_j := n_j + 1;
            End Loop;
            n_i := n_i + 1;
          End Loop;
        End Loop;
        x_Result := x_Content;
        For Mysample2 In (Select Iid
                            From (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From Table(Xmlsequence(Extract(x_Content,
                                                                   '/zlxml//section'))) C) C
                           Where c.Iid Not In
                                 (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From 影像报告原型清单 A,
                                         Table(Xmlsequence(Extract(a.内容,
                                                                   '/zlxml//section'))) C
                                   Where a.Id = 原型ID_In)) Loop
          Select Deletexml(x_Result,
                           '//section[@iid="' || Mysample2.Iid || '"]')
            Into x_Result
            From Dual;
        End Loop;
      End If;
    
      Update 影像报告范文清单 X
         Set x.内容 = x_Result
       Where x.Id = Mysample.Id;
    End Loop;
  
    Select a.内容
      Into x_Antetypecontent
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
    Select Extract(x_Antetypecontent, 'zlxml/subdocuments')
      Into x_Subdocuments
      From Dual;
    Select Extract(x_Antetypecontent, 'zlxml/docparameters')
      Into x_Docparameters
      From Dual;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/subdocuments', x_Subdocuments)
     Where 原型ID = 原型ID_In;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/docparameters', x_Docparameters)
     Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Synchronous_Sample;

  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select ID,
             编码,
             标题,
             Parentid,
             种类,
             是否禁用,
             说明,
             Imageindex,
             名称
        From (Select a.编码 As ID,
                     a.编码 As 编码,
                     a.名称 As 标题,
                     '' As Parentid,
                     '-1' As 种类,
                     0 As 是否禁用,
                     a.说明 As 说明,
                     4 As Imageindex,
                     a.名称 名称
                From 影像报告种类 A
              Union
              Select Distinct a.种类 || '-' || a.分组 As ID,
                              (Select Min(编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              Max(a.分组) As 名称,
                              a.种类 As Parentid,
                              '0' As 种类,
                              0 As 是否禁用,
                              '' As 说明,
                              4 As Imageindex,
                              a.分组
                From 影像报告原型清单 A
               Where a.分组 Is Not Null
               Group By a.种类, a.分组
              Union
              Select RawTohex(ID),
                     a.编码,
                     编码 || '-' || 名称 As 标题,
                     Decode(a.分组, Null, a.种类, a.种类 || '-' || a.分组) Parentid,
                     a.种类 As 种类,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 1, 0, 2),
                     a.名称
                From 影像报告原型清单 A) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Out_Antetypelist;

  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
  Val           Out t_Refcur,
  编码_In 影像报告种类.编码%Type
  ) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明
        From 影像报告种类 A
       Where a.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Kind_By_Code;
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID,
             a.种类,
             a.原型id,
             a.编号,
             a.名称,
             a.说明,
             a.元素iid,
             a.扩展标记
        From 影像报告事件 A
       Where a.种类 <> 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event;

  --29.获取关于原型导出的重复信息
  Procedure p_Get_Antetypelist_Same_Info(
  Val           Out t_Refcur,
  Tablename_In Varchar2,
  ID_In        影像报告原型清单.Id%Type,
  编码_In      Varchar2,
  名称_In      Varchar2
  ) As
    n_Num    Number;
    v_Result Varchar2(100);
    v_Sql    Varchar2(4000);
  Begin
    If ID_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where id=' ||
               ID_In;
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        v_Result := 'ID重复';
      End If;
    End If;
    If 编码_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 编码=''' ||
               编码_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',编码重复';
        Else
          v_Result := '编码重复';
        End If;
      End If;
    End If;
    If 名称_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 名称=''' ||
               名称_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',名称重复';
        Else
          v_Result := '名称重复';
        End If;
      End If;
    End If;
    Open Val For
      Select v_Result Result From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Same_Info;

  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
  Val           Out t_Refcur,
  ID_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
  ) As
    v_Same_Antetype Varchar2(50);
    n_Same_Id       Number;
    n_Same_Title    Number;
    n_Same_Seqnum   Number;
    n_Maxnum        Number;
  Begin
    Select Count(*)
      Into n_Same_Title
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.名称 = 名称_In;
    Select Count(*)
      Into n_Same_Seqnum
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.编号 = 编号_In;
    Begin
      Select a.Id
        Into v_Same_Antetype
        From 影像报告事件 A
       Where a.原型ID = 原型ID_In
         And a.元素IID = 元素IID_In;
    Exception
      When Others Then
        v_Same_Antetype := '';
    End;
  
    Select Count(*) Into n_Same_Id From 影像报告事件 A Where a.Id = ID_In;
    Select Max(a.编号) Into n_Maxnum From 影像报告事件 A;
  
    Open Val For
      Select v_Same_Antetype As Sameaid,
             n_Same_Id       As Sameid,
             n_Same_Title    As Sametitle,
             n_Same_Seqnum   As Sameseqnum,
             n_Maxnum        As Maxnum
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Event_Same_Info;

  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select Distinct 动作类型
        From (Select Extractvalue(c.Column_Value, '/step/kind') As 动作类型
                From 影像报告动作 A,
                     Table(Xmlsequence(Extract(a.内容, '/root/step'))) C) B
       Where b.动作类型 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Process_Kind;


  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
  Val           Out t_Refcur,
  原型ID_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容.GetClobVal(), '<NULL/>')) As 内容, --Nvl(p.内容,'<NULL/>') As 内容,
             RawtoHex(p.事件ID) 事件ID,
             0 Is_Event
        From 影像报告动作 P
       Where p.原型ID = 原型ID_In
      Union All
      Select RawtoHex(e.id) ID,
             e.名称,
             e.种类,
             e.编号,
             e.说明,
             Null,
             To_CLOB('<Null/>') As 内容, --(Null,'<NULL/>') As 内容,
             Null,
             1
        From 影像报告事件 E
       Where e.Id In (Select RawtoHex(事件ID) 事件ID
                        From 影像报告动作
                       Where 原型ID = 原型ID_In)
       Order By Is_Event, 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process_Of_Antetype;

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
  Val           Out t_Refcur,
  名称_In 影像字典清单.名称%Type
  ) As
  Begin
    Open Val For
      Select a.编号, a.名称, Rawtohex(a.字典id) As 字典ID
        From 影像字典内容 A
       Where a.字典id In (Select id From 影像字典清单 b Where b.名称 = 名称_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Dictitems_By_Title;

  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, a.编码, a.名称
        From 影像报告预备提纲 a
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Phr_Onlines;

  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
  Val           Out t_Refcur,
  学科_In Varchar2
  ) As
  Begin
    If 学科_In <> '' Then
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Where (a.学科 In
               (Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(学科_In, ','))
                 Intersect
                 Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(a.学科, ','))) And
               a.节点类型 <> 0)
            Or a.节点类型 = 0
            Or a.学科 Is Null
         Order By a.编码, a.上级id;
    Else
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               Nvl(a.组成.GetClobVal(), '<NULL/>') As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Order By a.上级id, a.节点类型, a.编码, a.名称;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment;

  --37. 获取词句信息
  Procedure p_Get_Fragment_Filter(
  Val           Out t_Refcur,
  原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
  ) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(b.Id) ID,
               Rawtohex(b.上级id) 上级id,
               b.编码,
               b.名称,
               b.说明,
               b.节点类型,
               Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
               b.学科,
               b.标签,
               b.是否私有,
               b.作者,
               b.最后编辑时间
          From 影像报告原型片段 A, 影像报告片段清单 B
         Where a.片段id = b.id
           And a.原型id = 原型id_In;
    Else
      Open Val For
        Select /*+ rule*/
         Rawtohex(b.Id) ID,
         Rawtohex(b.上级id) 上级id,
         b.编码,
         b.名称,
         b.说明,
         b.节点类型,
         Nvl(b.组成.GetClobVal(), '<NULL/>') As 组成,
         b.学科,
         b.标签,
         b.是否私有,
         b.作者,
         b.最后编辑时间
          From 影像报告片段清单 B
         Where b.上级id = 原型id_In
           And (b.是否私有 = 0 Or (b.是否私有 = 1 And b.作者 = 作者_In))
           And (b.学科 Is Null Or
               (b.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(b.学科, 学科_In) > 0));
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_Filter;

  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型片段.原型ID%Type
  ) As
  Begin
    Open Val For
      Select Distinct b.标签
        From 影像报告片段清单 B
       Start With b.上级id In (Select a.片段id
                               From 影像报告原型片段 A
                              Where a.原型id = 原型ID_In)
      Connect By Prior b.Id = b.上级id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Label_By_Aid;

  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) ID,
             Rawtohex(a.上级id) 上级id,
             a.编码,
             a.名称,
             a.说明,
             a.节点类型
        From 影像报告片段清单 A
       Where a.节点类型 = 0
       Start With 上级id Is Null
      Connect By Prior id = 上级id
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment_Class;

  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
  Val           Out t_Refcur,
  Table_Name_In Varchar2
  ) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Data_Last_Edit_Time;

  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
  ) As
    n_Seq_Num  影像报告事件.编号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = 原型ID_In
       And 种类 = 种类_In
       And 名称 = 名称_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上已存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (编号_In Is Null Or 编号_In = 0) Then
      Select Nvl(Max(编号), 0) + 1 Into n_Seq_Num From 影像报告事件;
    Else
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where 原型ID = 原型ID_In
         And 种类 = 种类_In
         And 编号 = 编号_In;
      If n_Is_Exist > 0 Then
        v_Err_Msg := '[ZLSOFT]原型上已存在相同编号的事件[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_Seq_Num := 编号_In;
    End If;
  
    Insert Into 影像报告事件
      (ID, 种类, 原型ID, 编号, 名称, 说明, 元素IID, 扩展标记)
    Values
      (ID_In,
       种类_In,
       原型ID_In,
       n_Seq_Num,
       名称_In,
       说明_In,
       元素IID_In,
       扩展标记_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Event;

  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
  ) As
    r_Aid      影像报告事件.原型ID%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告事件 Where ID = Id_In;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = r_Aid
       And 种类 = 种类_In
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 影像报告事件
       Set 种类     = 种类_In,
           名称     = 名称_In,
           说明     = 说明_In,
           元素IID  = 元素IID_In,
           扩展标记 = 扩展标记_In
     Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Event;

  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
  ) As
    n_Kind     影像报告事件.种类%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 种类 Into n_Kind From 影像报告事件 Where ID = Id_In;
  
    If n_Kind = 1 Then
      v_Err_Msg := '[ZLSOFT]不允许删除固定事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(*) Into n_Is_Exist From 影像报告动作 Where 事件ID = Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]事件已经被使用,不能被删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告事件 Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Doc_Event;

  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
  ) As
  Begin
    Delete From 影像报告事件
     Where 种类 <> 1
       And ID Not In
           (Select 事件ID From 影像报告动作 Where 事件ID Is Not Null);
    Count_Out := Sql%RowCount;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Unused_Doc_Events;

  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
  Val           Out t_Refcur,
  原型ID_In       影像报告事件.原型ID%Type,
  Include_Base_In Number
  ) As
  Begin
    If Include_Base_In = 1 Then
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where (t.种类 = 1 Or t.原型id = 原型ID_In)
           And t.Id = p.事件ID(+)
         Order By t.编号;
    Else
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where t.原型id = 原型ID_In
           And t.种类 <> 1
           And t.Id = p.事件ID(+)
         Order By t.编号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event_Of_Antetype;

  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
  序号_In 影像报告动作.序号%Type) As
  Begin
    Update 影像报告动作 Set 序号 = 序号_In Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process_Seqnum;

  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
  ) As
    n_Seq_Num  影像报告动作.序号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = 原型ID_In
       And 名称 = 名称_In;
    If (序号_In Is Null Or 序号_In = 0) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 序号_In;
    End If;
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
    Insert Into 影像报告动作
      (ID, 原型ID, 事件ID, 动作类型, 名称, 说明, 可否手工执行, 序号, 内容)
    Values
      (Id_In,
       原型ID_In,
       事件ID_In,
       动作类型_In,
       名称_In,
       说明_In,
       可否手工执行_In,
       n_Seq_Num,
       内容_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Process;

  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
  ) As
    r_Aid          影像报告事件.原型ID%Type;
    r_Old_Event_Id 影像报告动作.事件ID%Type;
    n_Seq_Num      影像报告事件.编号%Type;
    n_Is_Exist     Number(1) := 0;
    v_Err_Msg      Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告动作 Where ID = Id_In;
    If (事件ID_In Is Not Null) Then
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where (原型ID Is Null Or 原型ID = r_Aid)
         And ID = 事件ID_In;
    
      If n_Is_Exist = 0 Then
        v_Err_Msg := '[ZLSOFT]关联的事件不存在[ZLSOFT]';
        Raise Err_Item;
      End If;
    
    End If;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = r_Aid
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (r_Old_Event_Id <> 事件ID_In Or
       (事件ID_In Is Null And r_Old_Event_Id Is Not Null)) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 0;
    End If;
  
    If n_Seq_Num > 0 Then
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In,
             序号         = n_Seq_Num
       Where ID = Id_In;
    Else
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In
       Where ID = Id_In;
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process;

  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
  Val           Out t_Refcur,
  原型ID_In 影像报告原型清单.Id%Type,
  Type_In   Varchar2
  ) As
    c_Content Clob;
  Begin
    /*Select To_Clob(a.内容)*/
    Select a.内容.getclobval()
      Into c_Content
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
  
    If Type_In = '1' Then
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/*/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '/zlxml/document//element[@sid and @title]|/zlxml/document//e_list[@sid and @title]|/zlxml/document//e_enum[@sid and @title]|/zlxml/document//e_etree[@sid and @title]|/zlxml/document//e_utree[@sid and @title]'))) C) A
         Where a.Name Is Not Null;
    Else
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/section/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '//section'))) C) A
         Where a.Name Is Not Null;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Ele_Section;

  --50.删除文档处理
  Procedure p_Del_Doc_Process(Id_In        影像报告动作.ID%Type,
                              Del_Event_In Number) As
    r_Event_Id   影像报告动作.事件ID%Type := Null;
    n_Event_Kind 影像报告事件.种类%Type;
    n_Is_Exist   Number(1) := 0;
  Begin
    If Del_Event_In = 1 Then
      Select Max(e.Id), Max(e.种类)
        Into r_Event_Id, n_Event_Kind
        From 影像报告动作 P, 影像报告事件 E
       Where p.Id = Id_In
         And p.事件id = e.Id;
    End If;
  
    Delete From 影像报告动作 Where ID = Id_In;
  
    If Del_Event_In = 1 Then
      If (r_Event_Id Is Not Null And n_Event_Kind <> 1) Then
        Select Count(*)
          Into n_Is_Exist
          From 影像报告动作
         Where 事件id = r_Event_Id;
        If n_Is_Exist = 0 Then
          Delete From 影像报告事件
           Where ID = r_Event_Id
             And 种类 <> 1;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Process;

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
  Val           Out t_Refcur,
  Id_In    影像报告值域清单.Id%Type,
  Code_In  Varchar2,
  Title_In Varchar2,
  Flag_In  Varchar2
  ) As
    v_Result  Varchar2(50);
    v_Id      Varchar2(50);
    v_Code_Id Varchar2(50);
    n_Num     Number;
  Begin
    If Flag_In = 1 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.Id = Id_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.编码 = Code_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素分类 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 2 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 3 Then
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告值域清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    Open Val For
      Select v_Result As Result, v_Id As ID, v_Code_Id As Codesameid
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Ele_Same_Info;

  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             Decode(显示样式, '1', '嵌入式', '弹出式') 显示样式II,
             Decode(种类, '1', '专用插件', '共享插件') 种类II,
             类名,
             库名,
             是否禁用,
             Decode(是否禁用, '1', '停用', '启用') IsEnable
        From 影像报告插件;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocPluginList;

  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
    Val           Out t_Refcur,
	ID_In Varchar2
	) As
    CURSOR C_EVENT Is
      Select t.专用插件.getclobval() 专用插件 From 影像报告原型清单 t;
    anum Int := 0;
    sult Varchar2(6666);
  Begin
    For temp In C_EVENT Loop
      If instr(temp.专用插件, ID_In) > 0 Then
        anum := anum + 1;
      End If;
    End Loop;
    Open Val For
      Select anum From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExit_DocPluginByID;

  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Insert Into 影像报告插件
      (ID, 编码, 名称, 说明, 显示样式, 种类, 类名, 库名, 是否禁用)
    Values
      (ID_In,
       编码_In,
       名称_In,
       说明_In,
       显示样式_In,
       种类_In,
       类名_In,
       库名_In,
       是否禁用_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddDocPlugin;

  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Update 影像报告插件
       Set 编码     = 编码_In,
           名称     = 名称_In,
           说明     = 说明_In,
           显示样式 = 显示样式_In,
           种类     = 种类_In,
           类名     = 类名_In,
           库名     = 库名_In,
           是否禁用 = 是否禁用_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDocPlugin;

  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Delete From 影像报告插件 Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDocPlugin;

  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Update 影像报告插件 a
       Set 是否禁用 = Decode(a.是否禁用, 1, 0, 1)
     Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsEnableDocPlugin;

  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocPluginByID;

  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
	编码_In 影像报告插件.编码%Type,
	名称_In 影像报告插件.名称%Type
	) As
  Begin
    Open Val For
      Select Count(id)
        From 影像报告插件 a
       Where (a.编码 = 编码_In Or a.名称 = 名称_In)
         and a.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExitDocPlugin;

  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In
         And 种类 = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocSpecPluginByID;

  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
	条件_In Varchar2
	) As
  Begin
    Open Val For
      Select to_char(a.id) ID,
             a.编码,
             a.名称,
             (Select b.名称 From 诊疗项目类别 b Where b.编码 = a.类别) 类别
        From 诊疗项目目录 a
       Where (a.id In (Select t.诊疗项目id From 影像检查项目 t) And a.类别 = 类别_In)
         And (a.编码 Like 条件_In || '%' Or a.名称 Like 条件_In || '%');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisList;

  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.编码, t.名称, t.简码 From 诊疗项目类别 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisClass;

  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
    应用场合_In   影像报告原型应用.应用场合%Type,
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Insert Into 影像报告原型应用
      (诊疗项目ID, 应用场合, 报告原型ID)
    Values
      (诊疗项目ID_In, 应用场合_In, 报告原型ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMedicalAntetype;

  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告原型应用 Where 报告原型ID = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMedicalAntetype;

  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Open Val For
      Select id,
             x.编码,
             x.名称,
             x.类别,
             Sum(x.门诊) 门诊,
             Sum(x.住院) 住院,
             Sum(x.外诊) 外诊,
             Sum(x.体检) 体检
        From (Select id,
                     编码,
                     名称,
                     类别,
                     Decode(应用场合, '1', 1, 0) as 门诊,
                     Decode(应用场合, '2', 1, 0) as 住院,
                     Decode(应用场合, '3', 1, 0) as 外诊,
                     Decode(应用场合, '4', 1, 0) as 体检
                From (Select to_Char(a.诊疗项目id) ID,
                             (Select b.编码
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 编码,
                             (Select b.名称
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 名称,
                             (Select c.名称
                                From 诊疗项目类别 c
                               Where c.编码 = (Select b.类别
                                               From 诊疗项目目录 b
                                              Where b.id = a.诊疗项目id)) As 类别,
                             a.应用场合
                        From 影像报告原型应用 a
                       Where a.报告原型id = 报告原型ID_In)) x
       Group By x.id, x.编码, x.名称, x.类别;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMedicalByAID;

  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告动作 t Where t.原型id = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     a.名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAntetypeTreeByID;

  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
	名称_In 影像报告原型清单.名称%Type,
	ID_In  影像报告原型清单.ID%Type
	) As
  begin
    Open Val For
      Select Count(*) AS num
        From 影像报告原型清单 t
       where (t.编码 = 编码_In
          or t.名称 = 名称_In) and t.id<>ID_In;
  End p_IsExitAntetype;

  --69  获取影像存储设备
  Procedure p_GetStorageDevice(
	Val           Out t_Refcur
	) Is 
  Begin 
	Open Val For
		Select 设备号||' - '||设备名 As 存储设备, 设备号, IP地址, FTP目录, FTP用户名, FTP密码, 共享目录用户名, 共享目录密码, 共享目录  
		From 影像设备目录 Where 类型 = 1;
	Exception
	  When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStorageDevice;

End b_PACS_RptAntetype;
/

--88387:马政,2015-09-23,高值卫材数量处理
Create Or Replace Procedure Zl_材料收发记录_部门退料
(
  收发id_In   In 药品收发记录.Id%Type,
  审核人_In   In 药品收发记录.审核人%Type,
  审核日期_In In 药品收发记录.审核日期%Type,
  批号_In     In 药品库存.上次批号%Type := Null,
  效期_In     In 药品库存.效期%Type := Null,
  产地_In     In 药品库存.上次产地%Type := Null,
  退料数量_In In 药品收发记录.实际数量%Type := Null,
  自动销帐_In Integer := 0,
  退料人_In   In 药品收发记录.领用人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  v_No      药品收发记录.No%Type;

  n_记录状态   药品收发记录.记录状态%Type;
  n_执行状态   住院费用记录.执行状态%Type;
  n_部分退料   Number;
  n_入出类别id Number(18);
  n_单据       药品收发记录.单据%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_药品id     药品收发记录.药品id%Type;
  n_实际数量   药品收发记录.实际数量%Type;
  n_实际金额   药品收发记录.零售金额%Type;
  n_实际成本   药品收发记录.成本金额%Type;
  n_实际差价   药品收发记录.差价%Type;
  n_费用id     药品收发记录.费用id%Type;
  n_零售价     药品收发记录.零售价%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  --处理退料时，分批核算性质改变后的处理
  n_新批次       药品收发记录.批次%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批         材料特性.在用分批%Type;
  n_小数         Number(2);
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_成本价       药品收发记录.成本价%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_产地         药品收发记录.产地%Type;
  v_费用no       住院费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     人员表.姓名%Type;
  n_主页id       住院费用记录.主页id%Type;
  n_序号         住院费用记录.序号%Type;
  v_病人来源     病人医嘱记录.病人来源%Type;

  v_备货id     药品收发记录.Id%Type;
  v_入库no     药品收发记录.No%Type;
  v_入库序号   Number(5) := 0;
  v_执行时间   药品收发记录.审核日期%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  n_冲销记录id 药品收发记录.Id%Type;
  n_移库       Number(1) := 0;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_小数 From Dual;

  If 退料数量_In Is Not Null Then
    If 退料数量_In = 0 Then
      Return;
    End If;
  End If;

  --1、判断当前数据是否是备货卫材
  Begin
    Select 汇总发药号
    Into v_备货id
    From 药品收发记录
    Where 单据 = 21 And 审核日期 Is Not Null And
          汇总发药号 =
          (Select Max(a.Id)
           From 药品收发记录 A, 药品收发记录 B
           Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And b.Id = 收发id_In And (Mod(a.记录状态, 3) = 1 Or a.记录状态 = 1)) And
          Rownum = 1;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  --获取该收发记录的单据、药品ID、库房ID
  Select 单据, NO, 库房id, 药品id, 费用id, 入出类别id, 记录状态, Nvl(批次, 0), 生产日期, 灭菌效期, 批准文号, 供药单位id, 成本价, 产地, 零售价
  Into n_单据, v_No, n_库房id, n_药品id, n_费用id, n_入出类别id, n_记录状态, n_批次, d_上次生产日期, d_灭菌效期, v_批准文号, n_上次供应商id, n_成本价, v_产地,
       n_零售价
  From 药品收发记录
  Where ID = 收发id_In;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into n_实际数量, n_实际金额, n_实际成本, n_实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = v_No And 单据 = n_单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = 收发id_In);

  --如果允许退药数为零，表示已退药
  If n_实际数量 = 0 Then
    v_Err_Msg := '该单据已被其他操作员退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  If Nvl(退料数量_In, 0) > n_实际数量 Then
    v_Err_Msg := '该单据已被其他操作员部分退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  --获取该材料当前是否分批的信息
  Select Nvl(在用分批, 0) Into n_分批 From 材料特性 Where 材料id = n_药品id;

  --如果是部分退料，则重新计算零售金额及差价
  n_部分退料 := 0;
  If Not (退料数量_In Is Null Or Nvl(退料数量_In, 0) = n_实际数量) Then
    n_部分退料 := 1;
  End If;

  If n_部分退料 = 1 Then
    n_实际金额 := Round(n_实际金额 * 退料数量_In / n_实际数量, n_小数);
    n_实际成本 := Round(n_实际成本 * 退料数量_In / n_实际数量, n_小数);
    n_实际差价 := Round(n_实际差价 * 退料数量_In / n_实际数量, n_小数);
    n_实际数量 := 退料数量_In;
  End If;

  --n_分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If n_分批 = 0 And n_批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    n_分批 := 2;
  Elsif n_分批 <> 0 And n_批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    n_分批 := 3;
  Else
    If n_批次 = 0 Then
      n_分批 := 0;
    Else
      n_分批 := 1;
    End If;
  End If;
  If 产地_In Is Not Null Then
    v_产地 := 产地_In;
  End If;
  --记录状态的含义有所变化
  --冲销的记录状态        :iif(n_记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(n_记录状态=1,0,1)+2
  --等待发料的记录状态    :iif(n_记录状态=1,0,1)+3
  Select 药品收发记录_Id.Nextval Into n_冲销记录id From Dual;
  --产生冲销记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 领用人, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_冲销记录id, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 1, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号,
           效期, 灭菌效期, 1, -n_实际数量, -n_实际数量, 成本价, -n_实际成本, 扣率, 零售价, -n_实际金额, -n_实际差价, 摘要, 审核人_In, 审核日期_In, 配药人, 审核人_In,
           审核日期_In, 费用id, 单量, 频次, 用法, 发药窗口, 退料人_In, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发料
  Select 药品收发记录_Id.Nextval Into n_新批次 From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_新批次, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 3, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(n_分批, 1, 批次, 3, n_新批次, Null), Decode(n_分批, 3, 产地_In, 1, 产地, Null), Decode(n_分批, 3, 批号_In, 1, 批号, Null),
           Decode(n_分批, 3, 效期_In, 1, 效期, Null), 灭菌效期, 1, n_实际数量, n_实际数量, 成本价, n_实际成本, 扣率, 零售价, n_实际金额, n_实际差价, 摘要, 填制人,
           填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --更新病人费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into n_执行状态
  From 药品收发记录
  Where 单据 = n_单据 And NO = v_No And 费用id = n_费用id And 审核人 Is Not Null;

  If n_执行状态 = 0 Then
    Update 住院费用记录 Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And Mod(记录性质, 10) = 1 And
          记录状态 <> 2 And 执行部门id = n_库房id;
  Else
    Update 住院费用记录 Set 执行状态 = n_执行状态 Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And Mod(记录性质, 10) = 1 And
          记录状态 <> 2 And 执行部门id = n_库房id;
  End If;

  --插入未发药品记录
  Begin
    Insert Into 未发药品记录
      (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
      Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
      From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费, b.对方部门id,
                    b.库房id, b.发药窗口, b.填制日期, c.身份
             From 住院费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)
             Union All
             Select b.单据, b.No, a.病人id, Null As 主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费,
                    b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
             From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
      Where b.名称(+) = a.身份;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 2 Where ID = 收发id_In;

  --修改药品库存(反冲库存)
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = n_药品id;

  If n_分批 <> 3 Then
  
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_实际金额, 实际差价 = Nvl(实际差价, 0) + n_实际差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null)
    Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(批次, 0) = n_批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
      Values
        (n_库房id, n_药品id, Decode(n_分批, 2, Null, n_批次), 1, n_实际数量, n_实际金额, n_实际差价, Decode(n_分批, 1, 效期_In, Null), d_灭菌效期,
         n_上次供应商id, n_成本价, Decode(n_分批, 1, 批号_In, Null), d_上次生产日期, v_产地, v_批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_成本价);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
    Values
      (n_库房id, n_药品id, n_新批次, 1, n_实际数量, n_实际金额, n_实际差价, 效期_In, d_灭菌效期, n_上次供应商id, n_成本价, 批号_In, d_上次生产日期, v_产地, v_批准文号,
       Decode(n_实价卫材, 1, Decode(Nvl(n_新批次, 0), 0, Null, n_零售价), Null), n_成本价);
  End If;

  Delete 药品库存
  Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  If 自动销帐_In = 1 And n_单据 <> 24 Then
    Begin
      Select 主页id, NO, 序号 Into n_主页id, v_费用no, n_序号 From 住院费用记录 Where ID = n_费用id;
    Exception
      When Others Then
        Begin
          Select Null, NO, 序号 Into n_主页id, v_费用no, n_序号 From 门诊费用记录 Where ID = n_费用id;
        Exception
          When Others Then
            n_主页id := Null;
        End;
    End;
    If n_主页id Is Null Then
      Zl_门诊记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    Else
      Zl_住院记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    End If;
  End If;

  --备货卫材处理
  If v_备货id > 0 Then
    --2、自动冲销已审核的其他出库单据
    Begin
      Select 1
      Into n_移库
      From 药品收发记录
      Where 单据 = 15 And 审核日期 Is Null And
            费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
    Exception
      When Others Then
        n_移库 := 0;
    End;
    If n_移库 <> 0 Then
      For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
      
        Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In, 1);
      End Loop;
    
      --3、产生新的其他出库单据
      If v_入库no Is Null Then
        v_入库no := Nextno(74, n_库房id);
      End If;
      v_入库序号 := v_入库序号 + 1;
    
      For v_入库 In (Select 入出类别id, 库房id, 药品id, 批次, 填写数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 产地, 批号, 效期, 灭菌效期, 摘要, 单量, 发药窗口
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
      
        Zl_材料其他出库_Insert(v_入库.入出类别id, v_入库no, v_入库序号, v_入库.库房id, v_入库.药品id, v_入库.批次, v_入库.填写数量, v_入库.成本价, v_入库.成本金额,
                         v_入库.零售价, v_入库.零售金额, v_入库.差价, 审核人_In, 审核日期_In, v_入库.产地, v_入库.批号, v_入库.效期, v_入库.灭菌效期, v_入库.摘要,
                         v_入库.单量, v_入库.发药窗口);
      
        Update 药品收发记录
        Set 费用id = n_费用id, 汇总发药号 = n_新批次
        Where 单据 = 21 And NO = v_入库no And 序号 = v_入库序号;
      End Loop;
    
      --4、删除未审核的外购入库单据（已审核则不管）
      Delete 药品收发记录
      Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
    End If;
  End If;
  --处理调价修正单据
  Zl_材料收发记录_调价修正(n_冲销记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_部门退料;
/


--88158:余伟节,2015-09-20,河北CA
Create Or Replace Procedure Zl_人员证书记录_Insert
(
  人员id_In     人员证书记录.人员id%Type,
  Certdn_In     人员证书记录.Certdn%Type,
  Certsn_In     人员证书记录.Certsn%Type,
  Signcert_In   人员证书记录.Signcert%Type,
  Enccert_In    人员证书记录.Enccert%Type,
  时间戳证书_In 人员证书记录.时间戳证书%Type := Null
) Is
  v_姓名  人员表.姓名%Type;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    Select a.姓名 Into v_姓名 From 人员表 A, 人员证书记录 B Where a.Id = b.人员id And b.Certsn = Certsn_In;
  Exception
    When Others Then
      Null;
  End;
  If v_姓名 Is Not Null Then
    v_Error := '该数字证书已经注册给"' || v_姓名 || '"，不能重复注册。';
    Raise Err_Custom;
  End If;

  Update 人员证书记录 Set 是否停用 = 1 Where 人员id = 人员id_In And Nvl(是否停用, 0) = 0;

  Insert Into 人员证书记录
    (ID, 人员id, Certdn, Certsn, Signcert, Enccert, 时间戳证书, 注册时间)
  Values
    (人员证书记录_Id.Nextval, 人员id_In, Certdn_In, Certsn_In, Signcert_In, Enccert_In, 时间戳证书_In, Sysdate);
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_人员证书记录_Insert;
/

--88158:余伟节,2015-09-20,河北CA
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  End If;
  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--88158:余伟节,2015-09-20,河北CA
CREATE OR REPLACE Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形)；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录,
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
Begin
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    Return Null;
End Zl_Lob_Read;
/

--88888:刘鹏飞,2015-09-19,数据转移指定历史库
Create Or Replace Procedure Zl1_Datamoveout1
(
  Demoded_In        In Number,
  Optmode_In        In Number := 0,
  Curtime_In        In Number := 1,
  Totaltime_In      In Number := 1,
  Speedmode_In      In Number := 0,
  Disabletrigger_In In Number := 0,
  Disablejob_In     In Number := 0,
  Parallel_In       In Number := 0,
  Sysowner_In       In Varchar2 := Null,
  Peissysowner_In   In Varchar2 := Null,
  Opersysowner_In   In Varchar2 := Null
) As
  --功能：标记并转出n天前的数据到历史表空间
  --参数:Demoded_in:          标记转出多少天以前的数据,当参数Optmode_In为0或1时才有效
  --     Optmode_in:           0-标记并执行转出,1-只进行标记，2-只执行转出(将已标记的)
  --     Curtime_in,Totaltime_in，连续多次转出时的当前次数和总次数，如果都为1表示一次性转出
  --                首次时会检查在线表与历史表的结构一致性、在线表的子表是否转出，并且禁用他表外键，禁用转出表引用非转出表的外键索引
  --                最后一次执行后，需在界面程序中手工恢复禁用的外键和索引
  --     Speedmode_in:        0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快删除操作）
  --                          历史库的约束和索引禁用在应用程序时进行（因为需要用到历史库的连接）
  --     Disabletrigger_in:   1=转出期间禁用当前所有者的触发器，0-不禁用
  --     Disablejob_in:       1=转出期间禁用当前所有者的自动作业，0-不禁用
  --     parallel_in:         重建标记查询所需索引时的并行度，缺省为不并行执行
  --     SysOwner_In:         标准系统指定转出历史表空间所有者
  --     PeisSysOwner_In:     体检系统指定转出历史表空间所有者
  --     OperSysOwner_In:     手麻系统指定转出历史表空间所有者
  --说明：1.标记要转出的数据，可以多次标记，然后分批执行转出
  --      2.转出时，根据zlBakTables中定义的分组和顺序转出数据，分组提交事务;
  --      3.为了避免查询范围太大导致性能问题，及Undo表空间增长太大，建议每次不要转出太多的数据(界面程序调用时自动拆分为每次调用转一个月);
  d_End          Date;
  n_System       Number(5);
  v_Systems      Varchar2(100);
  n_Peissystem   Number(5);
  n_Opersystem   Number(5);
  n_Reset        Number(1) := 0;
  v_Sql          Varchar2(4000);
  v_Owner        Varchar2(20);
  v_Pre组号      Number(2);
  v_当前批次     Number(8);
  v_序列         Number(8);
  n_重建索引间隔 Zldatamove.重建索引间隔%Type;
  n_重建索引范围 Zldatamove.重建索引范围%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(4000);

  --功能：转移数据（插入后删除，按组提交事务）
  Procedure Movedata
  (
    v_Table    In Varchar2,
    v_当前批次 In Varchar2,
    v_Owner    In Varchar2
  ) As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    v_Sql := 'Insert Into /*+ append */ ' || v_Owner || '.' || v_Table || '(' || v_Colstr || ') Select ' || v_Colstr ||
             ' From ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
  
    v_Sql := 'Delete ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
  End Movedata;

  --检查历史表等
  Function Checkvalid
  (
    v_Systems     In Varchar2,
    n_Sharesystem In Number,
    n_Optmode     In Number
  ) Return Varchar2 Is
    n_只读    Number(3);
    n_状态    Number(1);
    v_Err_Msg Varchar2(4000);
    v_Tmp1    Varchar2(4000);
    v_Tmp2    Varchar2(4000);
    v_Tmp3    Varchar2(4000);
  Begin
    Select Count(1)
    Into n_只读
    From Zlbakspaces
    Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And 当前 = 1 And 只读 = 1;
  
    If n_只读 > 0 Then
      v_Err_Msg := '[ZLSOFT]存在只读状态的当前历史数据空间,操作不能继续![ZLSOFT]';
      Return(v_Err_Msg);
    End If;
  
    --并发检查，避免人工转出期间，自动作业又调用本过程    
    Select Nvl(状态, 0) Into n_状态 From Zldatamove Where 系统 = n_Sharesystem And 组号 = 1;
    If n_状态 = 1 Then
      v_Err_Msg := '[ZLSOFT]其他用户正在进行转出操作，如果不是这种情况，请手工更新"zlDataMove.状态"的值为空![ZLSOFT]';
      Return(v_Err_Msg);
    End If;
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    If n_Optmode <> 2 Then
      --检查在线表与后备表的字段是否一致,以避免数据转移了一部分时才报错。
      For r In (Select 表名 From Zlbaktables Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems)))) Loop
        v_Tmp1 := '';
        v_Tmp2 := '';
        v_Tmp3 := '';
        For c In (Select *
                  From (Select a.Column_Name, a.Data_Type, a.Data_Precision, b.Column_Name As Bcolumn_Name,
                                b.Data_Type As Bdata_Type, b.Data_Precision As Bdata_Precision
                         From (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From User_Tab_Columns a
                                Where Table_Name = r.表名) a,
                              (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From All_Tab_Columns
                                Where Table_Name = r.表名 And
                                      Owner In
                                      (Select 所有者
                                       From Zlbakspaces
                                       Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And 当前 = 1)) b
                         Where a.Column_Name = b.Column_Name(+))
                  Where Bcolumn_Name Is Null Or Data_Type <> Bdata_Type Or Data_Precision > Bdata_Precision) Loop
        
          If c.Bcolumn_Name Is Null Then
            v_Tmp1 := v_Tmp1 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || ')';
          Elsif c.Data_Type <> c.Bdata_Type Then
            If c.Data_Type = 'DATE' Then
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || ',H表的为' || c.Bdata_Type;
            Else
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),H表的为' ||
                        c.Bdata_Type;
            End If;
          Else
            v_Tmp3 := v_Tmp3 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),H表的为' ||
                      c.Bdata_Precision;
          End If;
        End Loop;
      
        If v_Tmp1 Is Not Null Then
          v_Err_Msg := v_Err_Msg || Chr(10) || ',缺字段：' || r.表名 || ' ' || v_Tmp1;
        End If;
        If v_Tmp2 Is Not Null Then
          v_Err_Msg := v_Err_Msg || Chr(10) || ',类型不同：' || r.表名 || ' ' || v_Tmp2;
        End If;
        If v_Tmp3 Is Not Null Then
          v_Err_Msg := v_Err_Msg || Chr(10) || ',长度较小：' || r.表名 || ' ' || v_Tmp3;
        End If;
      
        If Length(v_Err_Msg) > 3000 Then
          v_Err_Msg := '[ZLSOFT]请到【管理工具】中执行【历史库修正】' || Substr(v_Err_Msg, 1, 3000) || '......[ZLSOFT]';
          Return(v_Err_Msg);
        End If;
      End Loop;
    
      If v_Err_Msg Is Not Null Then
        v_Err_Msg := '[ZLSOFT]请到【管理工具】中执行【历史库修正】:' || Substr(v_Err_Msg, 1, 3000) || '[ZLSOFT]';
        --重建H表视图的脚本生成语句示例：
        --Select 'Create or replace view  ZLHIS.H' || 表名 || ' as Select * From ZLBAK1.' || 表名 || ';' From Zlbaktables Where 系统 In(Select Column_Value From Table(f_num2list(v_Systems)))
        Return(v_Err_Msg);
      End If;
    
      --可能由于历史升级脚本的遗漏，有些不再使用的外键或子表没有删除，为了避免转移到中途时才报错，先检查一遍
      For p In (Select Constraint_Name
                From (Select Constraint_Name,
                              Row_Number() Over(Partition By Constraint_Name Order By Decode(Constraint_Type, 'P', 0, 1)) Rn
                       From User_Constraints a, Zlbaktables b
                       Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
                             a.Constraint_Type In ('P', 'U'))
                Where Rn = 1) Loop
        For r In (Select a.Table_Name, a.Constraint_Name, a.Delete_Rule
                  From User_Constraints a
                  Where a.r_Constraint_Name = p.Constraint_Name And Not Exists
                   (Select 1
                         From Zlbaktables b
                         Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))))
                  Order By a.r_Constraint_Name) Loop
          v_Err_Msg := v_Err_Msg || Chr(10) || r.Table_Name || '(' || r.Constraint_Name || ',' || r.Delete_Rule || '->' ||
                       p.Constraint_Name || ')';
          If Length(v_Err_Msg) > 2000 Then
            v_Err_Msg := '[ZLSOFT]子表未转出:' || Substr(v_Err_Msg, 1, 2000) || '......[ZLSOFT]';
            Return(v_Err_Msg);
          End If;
        End Loop;
      End Loop;
    
      If v_Err_Msg Is Not Null Then
        v_Err_Msg := '[ZLSOFT]子表未转出:' || Substr(v_Err_Msg, 1, 2000) || '[ZLSOFT]';
        Return(v_Err_Msg);
      End If;
    End If;
    Return('');
  End Checkvalid;
Begin
  If Optmode_In <> 2 Then
    Select Trunc(Sysdate) - Demoded_In Into d_End From Dual;
  End If;
  v_Owner := Zl_Owner;
  Select 编号 Into n_System From Zlsystems Where Upper(所有者) = v_Owner And 编号 Like '1%';

  Select Nvl(Min(编号), 0) Into n_Peissystem From Zlsystems Where Upper(所有者) = v_Owner And 编号 Like '21%';
  Select Nvl(Min(编号), 0) Into n_Opersystem From Zlsystems Where Upper(所有者) = v_Owner And 编号 Like '24%';

  --1.安全性检查
  -----------------------------------------------------------------------------------
  If Curtime_In = 1 Then
    v_Systems := n_System;
    If n_Peissystem > 0 Then
      v_Systems := v_Systems || ',' || n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      v_Systems := v_Systems || ',' || n_Opersystem;
    End If;
  
    v_Err_Msg := Checkvalid(v_Systems, n_System, Optmode_In);
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
  
    --一批中的首次调用时禁用触发器和作业
    If Disabletrigger_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 1, 0);
      If n_Peissystem > 0 Then
        Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Peissystem, Speedmode_In, 1, 0;
      End If;
      If n_Opersystem > 0 Then
        Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Opersystem, Speedmode_In, 1, 0;
      End If;
    End If;
    If Disablejob_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 2, 0);
      If n_Peissystem > 0 Then
        Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Peissystem, Speedmode_In, 2, 0;
      End If;
      If n_Opersystem > 0 Then
        Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Opersystem, Speedmode_In, 2, 0;
      End If;
    End If;
  
    Update Zldatamove Set 状态 = 1 Where 系统 = n_System And 组号 = 1;
    Commit;
  End If;

  --2.标记要转出的数据
  -----------------------------------------------------------------------------------
  If Optmode_In <> 2 Then
    --上次标记转出出错后继续进行标记转出
    Select Nvl(Max(批次), 0) Into v_当前批次 From Zldatamovelog Where 系统 = n_System And 待转出 = 2;
  
    If v_当前批次 = 0 Then
      Select Nvl(Max(批次), 0) + 1, Decode(Curtime_In, 1, Nvl(Max(序列), 0) + 1, Max(序列))
      Into v_当前批次, v_序列
      From Zldatamovelog
      Where 系统 = n_System;
    
      Insert Into Zldatamovelog
        (系统, 批次, 序列, 截止时间, 标记开始时间, 待转出, 当前进度)
      Values
        (n_System, v_当前批次, v_序列, d_End, Sysdate, 2, '正在标记待转出数据');
      Commit;
    Else
      Update Zldatamovelog
      Set 标记开始时间 = Sysdate, 当前进度 = '正在标记待转出数据'
      Where 系统 = n_System And 批次 = v_当前批次;
      Commit;
    End If;
  
    Zl1_Datamove_Tag(d_End, v_当前批次, n_System);
    If n_Peissystem > 0 Then
      Execute Immediate 'Begin Zl21_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      Execute Immediate 'Begin Zl24_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Opersystem;
    End If;
  
    Update Zldatamovelog
    Set 标记结束时间 = Sysdate, 当前进度 = '标记待转出数据完成', 待转出 = 1
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

  --3.转移数据处理
  -----------------------------------------------------------------------------------
  If Optmode_In = 1 Then
    If Curtime_In = Totaltime_In Then
      Update Zldatamove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
    End If;
    Commit;
  Else
    --从最小的批次开始执行转出
    If Optmode_In = 2 Then
      Select Nvl(Min(批次), 0), Max(截止时间)
      Into v_当前批次, d_End
      From Zldatamovelog
      Where 系统 = n_System And 待转出 = 1;
    
      If v_当前批次 = 0 Then
        Update Zldatamove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
        Return;
      End If;
    End If;
  
    --禁用约束和索引
    If Curtime_In = 1 Then
      Update Zldatamovelog Set 当前进度 = '正在禁用约束和索引' Where 系统 = n_System And 批次 = v_当前批次;
      --要先禁用约束，否则主键或唯一键的索引被禁用后，会导致查询或插入操作报错，而禁用主键或唯一键则会删除对应的索引
      n_Reset := 1;
      Zl1_Datamove_Reb(n_System, Speedmode_In, 3, 0);
      If n_Peissystem > 0 Then
        Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Peissystem, Speedmode_In, 3, 0;
      End If;
      If n_Opersystem > 0 Then
        Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Opersystem, Speedmode_In, 3, 0;
      End If;
    
      Zl1_Datamove_Reb(n_System, Speedmode_In, 4, 0);
      If n_Peissystem > 0 Then
        Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Peissystem, Speedmode_In, 4, 0;
      End If;
      If n_Opersystem > 0 Then
        Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3, :4); End;'
          Using n_Opersystem, Speedmode_In, 4, 0;
      End If;
    
    End If;
  
    --数据转出处理
    -----------------------------------------------------------------------------------
    --不更新汇总表：病人费用汇总，药品收发汇总，药品库存，人员缴款余额等，虽然只是更新的期初数，
    --但是，由于并非这个时间以前的数据都转出了（部分未符合转出条件的数据未转出），更新后，如果按时间查询，会发现在线中这些日期的数据非常小，容易引起误解
    --即使出于某些特殊原因需要更新汇总表，也可以通过汇总表处理的过程进行重新汇总，所以，不必在转出过程中逐条更新。
  
    --"标记结束时间=转出开始时间"时不记录
    If Optmode_In = 2 Then
      Update Zldatamovelog Set 转出开始时间 = Sysdate Where 系统 = n_System And 批次 = v_当前批次;
    End If;
  
    For r In (Select 表名, 组号 From Zlbaktables Where 系统 = n_System And 直接转出 = 1 Order By 组号, 序号) Loop
      --一组相关业务表在一个事务中
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit; --先提交上一组的
      End If;
    
      Movedata(r.表名, v_当前批次, Sysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    v_Pre组号 := -1;
    For r In (Select 表名, 组号 From Zlbaktables Where 系统 = n_Peissystem And 直接转出 = 1 Order By 组号, 序号) Loop
      --一组相关业务表在一个事务中
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出体检第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit; --先提交上一组的         
      End If;
    
      Movedata(r.表名, v_当前批次, Peissysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    v_Pre组号 := -1;
    For r In (Select 表名, 组号 From Zlbaktables Where 系统 = n_Opersystem And 直接转出 = 1 Order By 组号, 序号) Loop
      --一组相关业务表在一个事务中
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出手麻第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit; --先提交上一组的         
      End If;
    
      Movedata(r.表名, v_当前批次, Opersysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
    Commit;
  
    Update 病案主页 Set 待转出 = Null, 数据转出 = 1 Where 待转出 = v_当前批次;
  
    Update Zldatamove Set 上次日期 = d_End Where 系统 = n_System And 组号 = 1;
    Update Zlbakinfo Set 最后转储日期 = Sysdate Where 系统 = n_System;
    Update Zldatamovelog
    Set 转出结束时间 = Sysdate, 待转出 = Null, 当前进度 = '转出数据完成,正在重建待转出索引'
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  
    If Curtime_In = Totaltime_In Then
      Update Zldatamove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
      Commit;
    End If;
  
    --4.索引重建（以提高下次标记转出查询的速度）
    -----------------------------------------------------------------------------------
    --每次转完后都要重建"待转出"索引，否则影响下一次查询待转出数据的SQL性能
    Zl1_Datamove_Reb(n_System, Speedmode_In, 5);
    If n_Peissystem > 0 Then
      Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3); End;'
        Using n_Peissystem, Speedmode_In, 5;
    End If;
    If n_Opersystem > 0 Then
      Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3); End;'
        Using n_Opersystem, Speedmode_In, 5;
    End If;
  
    --收缩标记转出查询所需的索引被删除后的空闲空间，下次标记转出时减少范围扫描的数据块
    --如果每次转完后进行，则耗时较多，所以，可根据查询的耗时来动态决定间隔次数(界面缺省为24次转出后重建一次)
    Select Nvl(重建索引间隔, 0), Nvl(重建索引范围, 0) Into n_重建索引间隔, n_重建索引范围 From Zldatamove;
  
    If Mod(Curtime_In, n_重建索引间隔) = 0 And n_重建索引间隔 <> 0 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
    
      If n_Peissystem > 0 Then
        Execute Immediate 'Begin Zl21_Datamove_Reb(:1, :2, :3, :4, :5); End;'
          Using n_Peissystem, Speedmode_In, 6, Parallel_In, n_重建索引范围;
      End If;
      If n_Opersystem > 0 Then
        Execute Immediate 'Begin Zl24_Datamove_Reb(:1, :2, :3, :4, :5); End;'
          Using n_Opersystem, Speedmode_In, 6, Parallel_In, n_重建索引范围;
      End If;
    End If;
  
    Update Zldatamovelog Set 重建结束时间 = Sysdate, 当前进度 = '完成' Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    --可能部分数据插入成功，删除操作由于主键或唯一的索引被禁用而失败
    Rollback;
    Update Zldatamove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
  
    v_Err_Msg := Substr(Sqlerrm, 1, 60);
    If Curtime_In = 1 And n_Reset = 0 Then
      Update Zldatamovelog
      Set 当前进度 = '转出标记操作出错：' || v_Err_Msg
      Where 系统 = n_System And 批次 = v_当前批次;
    Else
      Update Zldatamovelog Set 当前进度 = '转出操作出错：' || v_Err_Msg Where 系统 = n_System And 批次 = v_当前批次;
    End If;
    Commit;
  
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl1_Datamoveout1;
/

--88439:刘尔旋,2015-09-17,支付宝服务窗结帐接口
Create Or Replace Procedure Zl_Third_Getsettlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取HIS结帐数据
  --入参:Xml_In:
  --<IN>
  -- <BRID></BRID>       //病人ID 
  -- <ZYID></ZYID>         //主页ID
  -- <JSLX></JSLX>       //结算类型。1-门诊,2-住院。固定传2
  -- <JSKLB></JSKLB>       //结算卡类别
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<JBXX>              //基本信息
  --   <XM></XM>           //姓名
  --   <XB></XB>           //性别
  --   <NL></NL>         //年龄
  --   <ZYH></ ZYH>        //住院号
  --   <ZYKS></ ZYKS>          //住院科室  
  --   <KSID></KSID>         //科室ID
  --   <ZZYS></ ZZYS>          //主治医生  
  --   <RYSJ></ RYSJ>          //入院时间
  --   <CYSJ></ CYSJ >         //出院时间 
  --   <JZSJ></JZSJ>         //结帐时间(未结帐为空)
  --   <DJH></DJH>         //单据号(未结帐为空)
  --   <JSZFY></JSZFY>         //结算总费用
  --</JBXX>
  --<YJKLIST>              //冲抵预缴款集合
  --   <ITEM>
  --     <DJH><DJH>        //预交款单据号
  --     <JSFS></JSFS>     //结算方式（为名称，返回什么就取什么）
  --     <JE></JE>           //预缴款金额
  --     <JYLSH></JYLSH>       //交易流水号（便于冲销使用）
  --     <SFJSK></SFJSK>       //是否结算卡，1-是，0-否。如果是由传入的卡类别缴费，返回1，否则返回0
  --   </ITEM>
  --</YJKLIST >
  --<TBQK>               //退补情况
  --   <TBLX></TBLX>         //退补类型(1:个人补款，2:医院退款)
  --   <TBJE></TBJE>         //退补金额
  --</TBQK>
  -- <ERROR><MSG></MSG></ERROR>    //出现错误时返回具体原因，error节点为空表示成功
  --</OUTPUT>  

  --------------------------------------------------------------------------------------------------
  n_病人id     病人信息.病人id%Type;
  n_主页id     病案主页.主页id%Type;
  n_结算类型   Number(3);
  v_结算卡类别 Varchar2(200);
  n_卡类别id   医疗卡类别.Id%Type;
  n_是否结清   Number(3); -- 1-未结清,0-结清
  n_结帐金额   住院费用记录.结帐金额%Type;
  v_Temp       Varchar2(32767); --临时XML
  v_Subtemp    Varchar2(32767);
  v_结帐ids    Varchar2(5000);
  n_退补金额   病人预交记录.冲预交%Type;
  n_病人余额   病人预交记录.金额%Type;
  n_结帐id     病人预交记录.结帐id%Type;
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/ZYID'), Extractvalue(Value(A), 'IN/JSLX'),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_主页id, n_结算类型, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --默认住院结帐
  n_结算类型 := Nvl(n_结算类型, 2);
  Begin
    Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
  Exception
    When Others Then
      v_Err_Msg := '无法确认传入的结算卡,请检查!';
      Raise Err_Item;
  End;
  If n_结算类型 = 2 Then
    Begin
      Select Distinct 1
      Into n_是否结清
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1 Having
       Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0;
    Exception
      When Others Then
        n_是否结清 := 0;
    End;
    If n_是否结清 = 0 Then
      --结清,读取结帐数据
      For r_结帐 In (Select 姓名, 性别, 年龄, 住院号, 住院科室, 科室id, 主治医生, To_Char(入院时间, 'yyyy-mm-dd') As 入院时间,
                          To_Char(出院时间, 'yyyy-mm-dd') As 出院时间, To_Char(结帐时间, 'yyyy-mm-dd') As 结帐时间, 单据号, 结算总费用, 结帐id
                   From (Select c.姓名, c.性别, c.年龄, c.住院号, e.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生, c.入院日期 As 入院时间,
                                 c.出院日期 As 出院时间, a.收费时间 As 结帐时间, a.No As 单据号, Sum(d.冲预交) As 结算总费用, a.Id As 结帐id
                          From 病人结帐记录 A, 病人信息 B, 病案主页 C, 病人预交记录 D, 部门表 E
                          Where a.记录状态 = 1 And a.病人id = c.病人id And a.病人id = b.病人id And b.主页id = c.主页id And a.病人id = n_病人id And
                                d.结帐id = a.Id And c.入院科室id = e.Id(+) And Exists
                           (Select 1 From 病人预交记录 Where 结帐id = a.Id And 结算方式 = v_结算卡类别)
                          Group By c.姓名, c.性别, c.年龄, c.住院号, c.入院科室id, c.住院医师, c.入院日期, c.出院日期, a.收费时间, a.No, a.Id
                          Order By 结帐时间 Desc)
                   Where Rownum < 2) Loop
        v_Temp := '<XM>' || r_结帐.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_结帐.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_结帐.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_结帐.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_结帐.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_结帐.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_结帐.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_结帐.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_结帐.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || r_结帐.结帐时间 || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || r_结帐.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSZFY>' || r_结帐.结算总费用 || '</JSZFY>';
        v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_结帐id := r_结帐.结帐id;
      End Loop;
      If n_结帐id Is Null Then
        v_Err_Msg := '该病人没有结帐数据!';
        Raise Err_Item;
      End If;
      v_Temp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(冲预交) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 结帐id = n_结帐id And Mod(记录性质, 10) = 1
                   Group By NO, 结算方式, 交易流水号
                   Order By 单据号 Desc) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSL>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSL>';
        End If;
        v_Temp    := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp := v_Subtemp || v_Temp;
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      Select Nvl(Sum(冲预交), 0)
      Into n_退补金额
      From 病人预交记录
      Where 结帐id = n_结帐id And Mod(记录性质, 10) = 2 And Nvl(校对标志, 0) = 0;
      If n_退补金额 < 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(n_退补金额) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      --未结清，读取未结数据
      For r_Info In (Select c.姓名, c.性别, c.年龄, c.住院号, d.名称 As 住院科室, c.入院科室id As 科室id, c.住院医师 As 主治医生,
                            To_Char(c.入院日期, 'yyyy-mm-dd') As 入院时间, To_Char(c.出院日期, 'yyyy-mm-dd') As 出院时间
                     From 病案主页 C, 部门表 D
                     Where c.病人id = n_病人id And c.入院科室id = d.Id(+) And c.主页id = n_主页id And Rownum < 2) Loop
        v_Temp := '<XM>' || r_Info.姓名 || '</XM>';
        v_Temp := v_Temp || '<XB>' || r_Info.性别 || '</XB>';
        v_Temp := v_Temp || '<NL>' || r_Info.年龄 || '</NL>';
        v_Temp := v_Temp || '<ZYH>' || r_Info.住院号 || '</ZYH>';
        v_Temp := v_Temp || '<ZYKS>' || r_Info.住院科室 || '</ZYKS>';
        v_Temp := v_Temp || '<KSID>' || r_Info.科室id || '</KSID>';
        v_Temp := v_Temp || '<ZZYS>' || r_Info.主治医生 || '</ZZYS>';
        v_Temp := v_Temp || '<RYSJ>' || r_Info.入院时间 || '</RYSJ>';
        v_Temp := v_Temp || '<CYSJ>' || r_Info.出院时间 || '</CYSJ>';
        v_Temp := v_Temp || '<JZSJ>' || '' || '</JZSJ>';
        v_Temp := v_Temp || '<DJH>' || '' || '</DJH>';
      End Loop;
      Begin
        Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
        Into n_结帐金额
        From 住院费用记录
        Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
      Exception
        When Others Then
          n_结帐金额 := 0;
      End;
      v_Temp := v_Temp || '<JSZFY>' || n_结帐金额 || '</JSZFY>';
      v_Temp := '<JBXX>' || v_Temp || '</JBXX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      v_Subtemp := '';
      For r_预交 In (Select NO As 单据号, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号, Max(卡类别id) As 卡类别id
                   From 病人预交记录
                   Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                   Group By NO, 结算方式, 交易流水号
                   Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
        v_Temp := '<DJH>' || r_预交.单据号 || '</DJH>';
        v_Temp := v_Temp || '<JSFS>' || r_预交.结算方式 || '</JSFS>';
        v_Temp := v_Temp || '<JE>' || r_预交.金额 || '</JE>';
        v_Temp := v_Temp || '<JYLSH>' || r_预交.交易流水号 || '</JYLSH>';
        If n_卡类别id = r_预交.卡类别id Then
          v_Temp := v_Temp || '<SFJSK>' || 1 || '</SFJSK>';
        Else
          v_Temp := v_Temp || '<SFJSK>' || 0 || '</SFJSK>';
        End If;
        v_Temp     := '<ITEM>' || v_Temp || '</ITEM>';
        v_Subtemp  := v_Subtemp || v_Temp;
        n_病人余额 := Nvl(n_病人余额, 0) + Nvl(r_预交.金额, 0);
      End Loop;
      v_Subtemp := '<YJKLIST>' || v_Subtemp || '</YJKLIST>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Subtemp)) Into x_Templet From Dual;
      If n_病人余额 - n_结帐金额 > 0 Then
        v_Temp := '<TBLX>' || 2 || '</TBLX>';
      Else
        v_Temp := '<TBLX>' || 1 || '</TBLX>';
      End If;
      v_Temp := v_Temp || '<TBJE>' || Abs(n_病人余额 - n_结帐金额) || '</TBJE>';
      v_Temp := '<TBQK>' || v_Temp || '</TBQK>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    End If;
  End If;
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getsettlement;
/


--88439:刘尔旋,2015-09-17,支付宝服务窗结帐接口
Create Or Replace Procedure Zl_Third_Settlement
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  --------------------------------------------------------------------------------------------------
  --功能:三方接口结帐
  --入参:Xml_In:
  --<IN>
  --        <BRID>病人ID</BRID>         //病人ID
  --        <ZYID>主页ID</ZYID>         //主页ID
  --        <JSLX>2</JSLX>         //结算类型,1-门诊,2-住院.目前固定传2
  --        <JE></JE>         //本次结算总金额
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>结算金额</JSJE> //结算金额(正金额：个人补款，负金额：医院退款)<SFCYJ>为1时为冲预交金额
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //是否冲预交，0-结算，1-冲预交.允冲预交时,只填JSJE节点
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC>交易名称</JYMC> //交易名称   退款时,传入冲预交的流水号
  --                        <JYLR>交易内容</JYLR> //交易内容   退款时,传入冲预交的金额
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out
  --  <OUT>
  --    DD如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUT>
  --------------------------------------------------------------------------------------------------
  n_主页id     病案主页.主页id%Type;
  n_病人id     病案主页.病人id%Type;
  n_结帐总额   病人预交记录.冲预交%Type;
  n_待结帐金额 病人预交记录.冲预交%Type;
  n_结算类型   Number(3);
  v_操作员编码 病人结帐记录.操作员编号%Type;
  v_操作员姓名 病人结帐记录.操作员姓名%Type;
  n_结帐id     病人结帐记录.Id%Type;
  n_冲预交金额 病人预交记录.冲预交%Type;
  d_结帐时间   Date;
  n_预交充值   病人预交记录.金额%Type;
  d_开始日期   Date;
  n_存在       Number(3);
  n_预交id     病人预交记录.Id%Type;
  n_科室id     病案主页.入院科室id%Type;
  d_结束日期   Date;
  n_结算卡序号 卡消费接口目录.编号%Type;
  n_时间类型   Number(3);
  v_Ids        Varchar2(20000);
  v_消费卡结算 Varchar2(5000);
  v_No         病人结帐记录.No%Type;
  v_预交no     病人预交记录.No%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  v_Temp       Varchar2(500);
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
  n_Count Number(18);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZYID'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/JSLX'))
  Into n_主页id, n_病人id, n_结帐总额, n_结算类型
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_结算类型 := Nvl(n_结算类型, 2);

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  End If;

  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许结算!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  If n_结算类型 = 2 Then
    Begin
      Select Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0))
      Into n_待结帐金额
      From 住院费用记录
      Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1;
    Exception
      When Others Then
        n_待结帐金额 := 0;
    End;
  
    If n_待结帐金额 <> n_结帐总额 Then
      v_Err_Msg := '传入的结帐金额与实际结帐金额不符,不允许结算!';
      Raise Err_Item;
    End If;
    Begin
      Select 入院科室id Into n_科室id From 病案主页 Where 病人id = n_病人id And 主页id = n_主页id;
    Exception
      When Others Then
        n_科室id := Null;
    End;
  
    Select 病人结帐记录_Id.Nextval, Sysdate, Nextno(15) Into n_结帐id, d_结帐时间, v_No From Dual;
  
    n_时间类型 := zl_GetSysParameter('结帐费用时间', 1137);
    If n_时间类型 = 0 Then
      --按登记时间
      Select Trunc(Min(登记时间)), Trunc(Max(登记时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    Else
      --按发生时间  
      Select Trunc(Min(发生时间)), Trunc(Max(发生时间))
      Into d_开始日期, d_结束日期
      From (Select NO, 序号, 登记时间, 发生时间
             From 住院费用记录
             Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
             Group By NO, 序号, 登记时间, 发生时间, Mod(记录性质, 10)
             Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0);
    End If;
  
    Zl_病人结帐记录_Insert(n_结帐id, v_No, n_病人id, d_结帐时间, d_开始日期, d_结束日期, 0, 0, n_主页id, Null, 2, Null, 2);
  
    For r_费用 In (Select Min(ID) As ID, Mod(记录性质, 10) As 记录性质, NO, 序号, 记录状态, 执行状态,
                        Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) As 金额, Sum(Nvl(结帐金额, 0)) As 结帐金额
                 From 住院费用记录
                 Where 病人id = n_病人id And 记录状态 <> 0 And 主页id = n_主页id And 记帐费用 = 1
                 Group By Mod(记录性质, 10), NO, 序号, 记录状态, 执行状态
                 Having Sum(Nvl(实收金额, 0)) - Sum(Nvl(结帐金额, 0)) <> 0
                 Order By NO, 序号) Loop
      If Nvl(r_费用.结帐金额, 0) = 0 Then
        Begin
          Select 1 Into n_存在 From 住院费用记录 Where ID = r_费用.Id And 结帐id Is Null;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          v_Ids := v_Ids || ',' || r_费用.Id;
        Else
          Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
        End If;
      Else
        Zl_结帐费用记录_Insert(0, r_费用.No, r_费用.记录性质, r_费用.记录状态, r_费用.执行状态, r_费用.序号, r_费用.金额, n_结帐id);
      End If;
    End Loop;
  
    If v_Ids Is Not Null Then
      v_Ids := Substr(v_Ids, 2);
      Zl_结帐费用记录_Batch(v_Ids, n_病人id, n_结帐id);
    End If;
  
    n_Count := 0;
    For r_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(r_结算方式.是否冲预交, 0) = 0 Then
        --付款
        If n_Count = 1 Then
          v_Err_Msg := '结帐结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
        If Nvl(r_结算方式.是否消费卡, 0) = 1 Then
          Begin
            n_结算卡序号 := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_结算卡序号 := 0;
          End;
          If n_结算卡序号 = 0 Then
            Begin
              Select 编号
              Into n_结算卡序号
              From 卡消费接口目录
              Where 名称 = r_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的消费卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
          End If;
        Else
          Begin
            n_卡类别id := To_Number(r_结算方式.结算卡类别);
          Exception
            When Others Then
              n_卡类别id := 0;
          End;
          If n_卡类别id = 0 Then
            Begin
              Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = r_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
            Exception
              When Others Then
                v_Err_Msg := '未找到对应的医疗卡!';
                Raise Err_Item;
            End;
          End If;
          If v_结算方式 Is Null Then
            Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
          End If;
        End If;
      
        If n_卡类别id Is Not Null Then
          --三方卡,生成住院预交款
          v_结算卡号 := r_结算方式.结算卡号;
          If r_结算方式.结算金额 > 0 Then
            Select 病人预交记录_Id.Nextval, Nextno(11) Into n_预交id, v_预交no From Dual;
            Zl_病人预交记录_Insert(n_预交id, v_预交no, Null, n_病人id, n_主页id, n_科室id, r_结算方式.结算金额, v_结算方式, '', '', '', '', '',
                             v_操作员编码, v_操作员姓名, Null, 2, n_卡类别id, Null, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, Null,
                             d_结帐时间, 0);
            n_预交充值 := Nvl(n_预交充值, 0) + r_结算方式.结算金额;
          Else
          
            Zl_结帐缴款记录_Insert(v_No, n_病人id, n_主页id, n_科室id, v_结算方式, Null, r_结算方式.结算金额, n_结帐id, v_操作员编码, v_操作员姓名, d_结帐时间,
                             Null, Null, Null, Null, Null, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明);
          
          End If;
        Else
          If n_结算卡序号 Is Not Null Then
            --消费卡
            v_结算卡号   := r_结算方式.结算卡号;
            v_消费卡结算 := n_结算卡序号 || '|' || r_结算方式.结算卡号 || '|0|' || r_结算方式.结算金额 || '||';
            Zl_结帐缴款记录_Insert(v_No, n_病人id, n_主页id, n_科室id, v_结算方式, Null, r_结算方式.结算金额, n_结帐id, v_操作员编码, v_操作员姓名, d_结帐时间,
                             Null, Null, Null, Null, Null, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明, v_消费卡结算);
          Else
            --其他结算
            Zl_结帐缴款记录_Insert(v_No, n_病人id, n_主页id, n_科室id, v_结算方式, Null, r_结算方式.结算金额, n_结帐id, v_操作员编码, v_操作员姓名, d_结帐时间,
                             Null, Null, Null, Null, Null, n_卡类别id, r_结算方式.结算卡号, r_结算方式.交易流水号, r_结算方式.交易说明);
          End If;
        End If;
      
        n_Count := 1;
      End If;
    End Loop;
  
    For r_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(r_结算方式.是否冲预交, 0) = 1 Then
        --冲预交,目前默认全冲
        n_冲预交金额 := r_结算方式.结算金额 + Nvl(n_预交充值, 0);
        For r_预交 In (Select Min(ID) As ID, NO, 结算方式, Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) As 金额, 交易流水号
                     From 病人预交记录
                     Where 病人id = n_病人id And Mod(记录性质, 10) = 1 And Nvl(预交类别, 2) = 2 And (主页id = n_主页id Or 主页id Is Null)
                     Group By NO, 结算方式, 交易流水号
                     Having Sum(Nvl(金额, 0)) - Sum(Nvl(冲预交, 0)) <> 0) Loop
          Zl_结帐预交记录_Insert(r_预交.Id, r_预交.No, 1, r_预交.金额, n_结帐id, n_病人id);
          n_冲预交金额 := n_冲预交金额 - Nvl(r_预交.金额, 0);
        End Loop;
        If n_冲预交金额 <> 0 Then
          v_Err_Msg := '传入的预交冲销金额与实际不符,请检查!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_预交id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 1);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Settlement;
/



--84498:刘尔旋,2015-09-16,轧帐只轧票据
Create Or Replace Procedure Zl_收费员轧帐记录_Insert
(
  Id_In         In 人员收缴记录.Id%Type,
  No_In         In 人员收缴记录.No%Type,
  收款员_In     In 人员收缴记录.收款员%Type,
  收款部门id_In In 人员收缴记录.收款部门id%Type,
  冲预交款_In   In 人员收缴记录.冲预交款%Type,
  借入合计_In   In 人员收缴记录.借入合计%Type,
  借出合计_In   In 人员收缴记录.借出合计%Type,
  摘要_In       In 人员收缴记录.摘要%Type,
  开始时间_In   In 人员收缴记录.开始时间%Type,
  终止时间_In   In 人员收缴记录.终止时间%Type,
  登记人_In     In 人员收缴记录.登记人%Type,
  登记时间_In   In 人员收缴记录.登记时间%Type,
  收缴标志_In   In 人员收缴记录.收缴标志%Type,
  收费对照_In   In Varchar2,
  操作类别_In   In Integer := 0,
  暂存金_In     In 人员暂存记录.金额%Type := 0,
  类别_In       In 人员收缴记录.类别%Type := 0
) Is
  --------------------------------------------------------------------------------------------
  --功能:收费员轧帐记录写入
  --参数:记录性质_IN:
  --     收费对照_IN:性质1,记录ID1|性质2,记录ID2|...|性质n,记录IDn
  --     操作类别_In:0-保存轧帐记录和对照;1-只保存对照
  --------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;

  n_组id     人员收缴记录.缴款组id%Type;
  n_Count    Number(18);
  n_暂存id   人员暂存记录.Id%Type;
  v_暂存单号 人员暂存记录.No%Type;
  v_现金     结算方式.名称%Type;

Begin
  --并发检查,是否当前时间范围内已经有轧帐记录
  If 操作类别_In = 0 Then
    Select Count(1)
    Into n_Count
    From 人员收缴记录
    Where 收款员 = 收款员_In And 开始时间 > 开始时间_In And 作废时间 Is Null And Nvl(类别, 0) = Nvl(类别_In, 0) And Rownum < 2 And 记录性质 = 1;
    If n_Count <> 0 Then
      v_Err_Msg := '收费员:"' || 收款员_In || '"在当前轧帐范围内已经被他人进行轧帐,不能再进行轧帐！';
      Raise Err_Item;
    End If;
  End If;

  --检查是否已存在轧帐明细
  For c_检查 In (Select /*+ rule*/
                a.性质, a.记录id, m.收款员
               From 人员收缴对照 A, Table(f_Str2list2(收费对照_In, '|', ',')) B, 人员收缴记录 M
               Where a.性质 = b.C1 And a.记录id = b.C2 And a.收缴id = m.Id And m.作废时间 Is Null And Rownum < 2) Loop
    --1-收费(含挂号),2-结帐,3-预交,4-借款;5-消费卡充值;6--消费卡面值;7-暂存金(本次增加)；８－收款或轧帐作废对照（本次增加）
    If c_检查.性质 = 1 Then
      Select Decode(记录性质, 1, '收费', 4, '挂号', '') || '单据为:' || NO || '的' || Decode(记录性质, 1, '收费', 4, '挂号', '') ||
              '记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 门诊费用记录
      Where 结帐id = c_检查.记录id And Rownum < 2;
    End If;
  
    If c_检查.性质 = 2 Then
      Select '结帐单据为:' || NO || '的结帐记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 病人结帐记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 3 Then
      Select '预交单据为:' || NO || '的预交记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 病人预交记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 4 And 收款员_In = c_检查.收款员 Then
      Select '收费员在' || To_Char(借出时间, 'yyyy-mm-dd hh24:mi:ss') || '的' || Decode(借款人, Null, '借出款', '借入款') ||
              '已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 人员借款记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
  
    If c_检查.性质 = 5 Then
      Select '收费员在' || To_Char(充值时间, 'yyyy-mm-dd hh24:mi:ss') || '的消费卡充值记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 消费卡充值记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 6 Then
      Select '收费员在发卡号为:' || 卡号 || '的且发卡时间为:' || To_Char(发卡时间, 'yyyy-mm-dd hh24:mi:ss') || '发卡记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 消费卡目录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 7 Then
      Select '暂存单号为:' || NO || '的暂存记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 人员暂存记录
      Where ID = c_检查.记录id And Rownum < 2;
    End If;
    If c_检查.性质 = 9 Then
      Select '单号为:' || NO || '的补充结算记录已经被轧帐，不能再进行轧帐处理'
      Into v_Err_Msg
      From 费用补充记录
      Where 结算id = c_检查.记录id And Rownum < 2;
    End If;
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
  End Loop;

  If 操作类别_In = 0 Then
    n_组id := Zl_Get组id(收款员_In);
    Insert Into 人员收缴记录
      (ID, 记录性质, NO, 收款员, 收款部门id, 冲预交款, 借入合计, 借出合计, 摘要, 开始时间, 终止时间, 缴款组id, 登记人, 登记时间, 收缴标志, 类别)
    Values
      (Id_In, 1, No_In, 收款员_In, 收款部门id_In, 冲预交款_In, 借入合计_In, 借出合计_In, 摘要_In, 开始时间_In, 终止时间_In, n_组id, 登记人_In, 登记时间_In,
       收缴标志_In, 类别_In);
  
    Update 人员缴款余额 Set 上次轧帐时间 = 终止时间_In Where 收款员 = 收款员_In;
  End If;
  --插入收费对照
  Insert Into 人员收缴对照
    (收缴id, 性质, 记录id)
    Select Id_In, C1, C2 From Table(f_Str2list2(收费对照_In, '|', ','));
  If 暂存金_In <> 0 Then
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Select 人员暂存记录_Id.Nextval Into n_暂存id From Dual;
    v_暂存单号 := Nextno(141);
    Insert Into 人员暂存记录
      (ID, 收缴id, 记录性质, NO, 结算方式, 金额, 收款员, 登记人, 登记时间)
    Values
      (n_暂存id, Id_In, 2, v_暂存单号, v_现金, -1 * 暂存金_In, 收款员_In, 登记人_In, 登记时间_In);
  
    Insert Into 人员收缴对照 (收缴id, 性质, 记录id) Values (Id_In, 7, n_暂存id);
    Select 人员暂存记录_Id.Nextval Into n_暂存id From Dual;
    v_暂存单号 := Nextno(141);
    Insert Into 人员暂存记录
      (ID, 收缴id, 记录性质, NO, 结算方式, 金额, 收款员, 登记人, 登记时间)
    Values
      (n_暂存id, Id_In, 2, v_暂存单号, v_现金, 暂存金_In, 收款员_In, 登记人_In, 登记时间_In + 1 / 24 / 60 / 60);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费员轧帐记录_Insert;
/

--88643:冉俊明,2015-09-16,门诊退费费用查询SQL性能优化。
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7'))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_总金额
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额, 1);
        n_返回值 := n_总金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(Zl_Getsysparameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4')
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--88643:冉俊明,2015-09-16,门诊退费费用查询SQL性能优化。
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。 
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。 
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生 
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额) 
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式) 
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录 
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了 
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中 
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用 
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id   := Zl_Get组id(操作员姓名_In);
  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数 
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称 
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行) 
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能) 
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录 
          n_费用状态 := 0;
          --该笔项目第几次退费 
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9 
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数) 
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9 
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --------------------------------------------------------------------------------- 
  --处理病人预交记录 

  --原单据的结帐ID 
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完 
    --冲预交部分记录 
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额 
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理) 
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对. 
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上 
      --需要处理误差金额
    Else
      --a.原样退回 
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了 
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差) 
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录 
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    ------------------------------------------------- 
    --部分退费直接退为指定结算方式 
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * (n_总金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志, 1, 2, 0), n_结算序号, 3
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交 
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --检查是否已经处理完 
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If Nvl(校对标志_In, 0) = 0 Then
        --更新病人预交余额 
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
          n_返回值 := n_总金额 + Nvl(误差_In, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  --------------------------------------------------------------------------------- 
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款) 
  --如果是需要校对的,暂不处理人员缴款余额 
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(Zl_Getsysparameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理 
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null And
                     (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费 
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费 
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--88508:冉俊明,2015-09-14,病人余额表中出现类型为3的记录问题。
Create Or Replace Procedure Zl_划价收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  三方卡结算_In Varchar2 := Null,
  登记时间_In   门诊费用记录.登记时间%Type := Null,
  结算序号_In   病人预交记录.结算序号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  简单收费_In   Number := 0
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n
  --        病人来源_IN:1-门诊;2-住院
  --        收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --        保险结算_IN:格式="结算方式|结算金额||....."
  --        三方卡结算_In:格式=卡类别Id|是否消费卡|结算金额|卡号|备注||...
  --        交易流水号_In和交易说明_In:收费结算_IN时有效.
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容

  --=================================
  --备注：该过程目前只有简单收费使用！
  --=================================

  Cursor c_Price Is
    Select ID, 医嘱序号
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  t_医嘱id     t_Numlist;
  l_医嘱id     t_Numlist;
  v_部门名称   部门表.名称%Type;
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, Nvl(a.预交类别, 2) As 预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, Nvl(预交类别, 2) As 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(预交类别, 2) = 1 And Nvl(金额, 0) <> Nvl(冲预交, 0) And
                 病人id = v_病人id Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, Nvl(预交类别, 2))
    Order By ID, 预交类别 Desc, NO;

  --预交与结算相关变量
  v_预交金额 病人预交记录.冲预交%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;

  v_标识号   门诊费用记录.标识号%Type;
  v_付款方式 医疗付款方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;

  --临时变量
  n_Count      Number;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_组id     财务缴款分组.Id%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  n_消费卡   Number;
  v_卡号     病人预交记录.卡号%Type;
  v_卡名称   Varchar2(100);
  n_自制卡   Number;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_金额     病人预交记录.金额%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    v_Err_Msg := '不能读取划价单内容,该单据可能已经删除或已经收费！';
    Raise Err_Item;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号) Into v_标识号 From 病人信息 Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id, t_医嘱id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 标识号 = v_标识号, 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
          性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      v_Err_Msg := '由于并发操作,该单据可能已经删除或已经收费！';
      Raise Err_Item;
    End If;
  
    --更新医属的计价数据
    Select Column_Value Bulk Collect Into l_医嘱id From Table(t_医嘱id) Where Column_Value Is Not Null;
    If l_医嘱id.Count <> 0 Then
      Forall I In 1 .. l_医嘱id.Count
        Update 病人医嘱发送 A
        Set 计费状态 = 3
        Where NO = No_In And 医嘱id = l_医嘱id(I) And 记录性质 = 1 And 计费状态 = 1;
    End If;
  
  End Loop;
  Close c_Price;
  ------------------------------------------------------------------------------------------------------------------------

  --预交款相关结算
  --收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 交易流水号,
           交易说明, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, v_Date,
           操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 结算序号_In, 交易流水号_In, 交易说明_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, v_Date, 操作员编号_In,
           操作员姓名_In, n_结算金额, 结帐id_In, n_组id, 结算序号_In, 3);
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := v_当前结算;
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 卡类别id, 结算卡序号, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id,
           结算序号, 卡号, 结算性质)
        Values
          (n_预交id, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, Decode(n_消费卡, 1, Null, n_卡类别id),
           Decode(n_消费卡, 0, Null, n_卡类别id), v_结算方式, v_结算号码, v_Date, 操作员编号_In, 操作员姓名_In, n_结算金额, 结帐id_In, Null, Null,
           n_组id, 结算序号_In, v_卡号, 3);
      
        --卡结算对照
        If n_消费卡 = 1 Then
          n_消费卡id := Null;
          If n_自制卡 = 1 Then
            Select ID
            Into n_消费卡id
            From 消费卡目录
            Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                  序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
          End If;
          Zl_病人卡结算记录_Insert(n_卡类别id, n_消费卡id, v_结算方式, n_结算金额, v_卡号, Null, Null, v_结算摘要, 结帐id_In, n_预交id);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人病人ID,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
  
    v_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(病人id_In) Loop
    
      n_金额 := Case
                When r_Deposit.金额 - v_预交金额 < 0 Then
                 r_Deposit.金额
                Else
                 v_预交金额
              End;
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 校对标志, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_Date,
               操作员姓名_In, 操作员编号_In, n_金额, 结帐id_In, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号_In, 校对标志, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 类型, 性质) Values (病人id_In, -n_金额, Nvl(r_Deposit.预交类别, 2), 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < v_预交金额 Then
        v_预交金额 := v_预交金额 - r_Deposit.金额;
      Else
        v_预交金额 := 0;
      End If;
      If v_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If v_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
  End If;

  --相关汇总表的处理

  --汇总"人员缴款余额"
  --收费结算
  n_返回值 := 0;
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 三方卡结算_In Is Not Null Then
    v_结算内容 := 三方卡结算_In || '||';
    While v_结算内容 Is Not Null Loop
      --卡类别Id|是否消费卡|结算金额|卡号|备注||...
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') + 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算摘要 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    
      If n_消费卡 = 1 Then
        Select 结算方式, 名称, Nvl(自制卡, 0)
        Into v_结算方式, v_卡名称, n_自制卡
        From 卡消费接口目录
        Where 编号 = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在消费卡中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      Else
        Select 结算方式, 名称 Into v_结算方式, v_卡名称 From 医疗卡类别 Where ID = n_卡类别id;
        If v_结算方式 Is Null Then
          v_Err_Msg := v_卡名称 || '未设置结算方式对照,请在医疗卡管理中进行设置,结算失败！';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(n_结算金额, 0)
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning Nvl(余额, 0) + n_返回值 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, Nvl(n_结算金额, 0));
          n_返回值 := Nvl(n_返回值, 0) + Nvl(n_结算金额, 0);
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
  End If;

  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And b.No = No_In And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    If Nvl(简单收费_In, 0) <> 0 Then
      Update 门诊费用记录
      Set 发药窗口 = 发药窗口_In
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 收费类别 = 'Z';
    Else
      For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
        Update 门诊费用记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
      
        Update 药品收发记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              费用id + 0 In (Select ID
                           From 门诊费用记录
                           Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      
        Update 未发药品记录
        Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
        Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
              Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                               From 门诊费用记录
                               Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
      End Loop;
    End If;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Nvl(性别_In, 性别), 年龄 = Nvl(年龄_In, 年龄), 姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(Zl_Getsysparameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_划价收费记录_Insert;
/

--87992:张德婷,2015-09-11,配置中心销账前先判断输液单状态
CREATE OR REPLACE Procedure Zl_输液配药记录_销帐审核
(
  配药id_In   In Varchar2, --ID串:ID1,审核标志1,ID2,审核标志2....
  操作人员_In In 输液配药记录.操作人员%Type,
  操作时间_In In 输液配药记录.操作时间%Type
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_Usercode   Varchar2(100);
  v_发药id     药品收发记录.Id%Type;
  n_Count      Number(1);
  d_审核时间   药品收发记录.审核日期%Type;
  v_No         药品收发记录.No%Type;
  v_上次no     药品收发记录.No%Type;
  n_审核标志   Number(1);
  n_操作状态   Number(2);
  v_收发ids    Varchar2(4000);
  v_退药待发id 药品收发记录.Id%Type;
  v_原始id     药品收发记录.Id%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  Cursor c_销帐记录 Is
    Select Distinct a.费用id, b.操作时间
    From 药品收发记录 A, 输液配药记录 B, 输液配药内容 C
    Where a.Id = c.收发id And b.Id = c.记录id And b.Id = v_Tansid And b.操作状态 = 9;

  v_销帐记录 c_销帐记录%RowType;

  Cursor c_退药记录 Is
    Select Distinct a.Id As 退药id, c.收发id, c.数量
    From 药品收发记录 A, 药品收发记录 B, 输液配药内容 C
    Where c.记录id = v_Tansid And b.Id = c.收发id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And
          a.药品id + 0 = b.药品id And a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  v_退药记录 c_退药记录%RowType;

  Cursor c_费用销帐 Is
    Select a.No, a.序号 || ':' || c.数量 || ':' || c.记录id As 费用序号
    From 住院费用记录 A, 药品收发记录 B, 输液配药内容 C
    Where a.Id = b.费用id And b.Id = c.收发id And c.记录id = v_Tansid;

  v_费用销帐 c_费用销帐%RowType;

Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid   := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
    n_审核标志 := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp      := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

    v_收发ids := Null;

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态<>9 then
        v_Error := '该数据已被操作，不能进行销帐审核！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    If n_审核标志 = 1 Then
      n_操作状态 := 10;
    Elsif n_审核标志 = 2 Then
      n_操作状态 := 11;
    End If;

    --查找输液单对应的收发NO
    Begin
      Select NO
      Into v_No
      From 药品收发记录
      Where ID In (Select 收发id From 输液配药内容 Where 记录id In (Select ID From 输液配药记录 Where ID = v_Tansid)) And Rownum < 2;
    Exception
      When Others Then
        v_No := '';
    End;

    --收发NO相同的配药ID，审核时间以此设置为延长1秒
    If v_No = v_上次no Then
      d_审核时间 := d_审核时间 + 1 / 24 / 60 / 60;
    Else
      d_审核时间 := 操作时间_In;
      v_上次no   := v_No;
    End If;

    --销帐记录处理
    For v_销帐记录 In c_销帐记录 Loop
      Zl_病人费用销帐_Audit(v_销帐记录.费用id, v_销帐记录.操作时间, 操作人员_In, d_审核时间, n_审核标志);
    End Loop;

    Select Count(*) Into n_Count From 输液配药状态 Where 配药id = v_Tansid And 操作时间 = 操作时间_In;

    If n_Count <> 1 Then
      Insert Into 输液配药状态
        (配药id, 操作类型, 操作人员, 操作时间)
      Values
        (v_Tansid, n_操作状态, 操作人员_In, 操作时间_In);
    End If;
    Update 输液配药记录 Set 操作人员 = 操作人员_In, 操作时间 = 操作时间_In, 操作状态 = n_操作状态 Where ID = v_Tansid;

    --退药处理
    If n_审核标志 = 1 Then
      For v_退药记录 In c_退药记录 Loop
        Zl_药品收发记录_部门退药(v_退药记录.退药id, 操作人员_In, 操作时间_In, Null, Null, Null, v_退药记录.数量, Null, 操作人员_In);

        --取退药待发id
        Select a.Id
        Into v_发药id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 1 And a.审核日期 Is Null;

        --输液配药内容中的收发ID更新为退药待发的收发ID
        Update 输液配药内容 Set 收发id = v_发药id Where 记录id = v_Tansid And 收发id = v_退药记录.收发id;

        If v_收发ids Is Null Then
          v_收发ids := v_发药id;
        Else
          v_收发ids := v_收发ids || ',' || v_发药id;
        End If;

        --取原始id
        Select a.Id
        Into v_发药id
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_退药记录.退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Mod(a.记录状态, 3) = 0 And a.审核日期 Is Not Null;

        v_收发ids := v_收发ids || ',' || v_发药id;
      End Loop;

      --费用销帐
      For v_费用销帐 In c_费用销帐 Loop
        Zl_住院记帐记录_Delete(v_费用销帐.No, v_费用销帐.费用序号, v_Usercode, Zl_Username, 2, 1, 1, d_审核时间);
      End Loop;

      --因为费用销账会删除新产生的待发记录，所以用原始记录替换输液配药内容中的收发ID
      v_收发ids := v_收发ids || ',';
      While v_收发ids Is Not Null Loop
        v_退药待发id := Substr(v_收发ids, 1, Instr(v_收发ids, ',') - 1);
        v_收发ids    := Substr(v_收发ids, Instr(v_收发ids, ',') + 1);
        v_原始id     := Substr(v_收发ids, 1, Instr(v_收发ids, ',') - 1);
        v_收发ids    := Substr(v_收发ids, Instr(v_收发ids, ',') + 1);

        --输液配药内容中的收发ID更新为原始ID
        Update 输液配药内容 Set 收发id = v_原始id Where 记录id = v_Tansid And 收发id = v_退药待发id;
      End Loop;
    End If;
  End Loop;
Exception
   When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_销帐审核;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Findcards
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:获取医疗卡类别 
  --入参:Xml_In: 
  --  <IN>
  --      <ZJH>证件号<ZJH>     //卡号
  --      <ZJLX>证件类型<ZJLX>  //医疗卡类别.名称
  --  </IN>
  --出参:Xml_Out 
  -- <OUTPUT>
  --    <LIST>
  --        <JZK>
  --            <LB>卡类别</LB>
  --            <KH>卡号</KH>
  --        </JZK>
  --        <JZK>
  --            ...
  --        </JZK>
  --    </LIST>
  --    如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  -- </OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_证件号   Varchar2(50);
  v_证件类型 医疗卡类别.名称%Type;
  n_存在     Number(3);
  v_操作员   人员表.姓名%Type;
  n_病人id   病人信息.病人id%Type;
  n_卡类别id 医疗卡类别.Id%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT><LIST></LIST></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/ZJH'), Extractvalue(Value(A), 'IN/ZJLX')
  Into v_证件号, v_证件类型
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_证件类型 Like '%身份证%' Then
    For c_Item In (Select Distinct b.名称, a.卡号
                   From 病人医疗卡信息 A, 医疗卡类别 B
                   Where a.卡类别id = b.Id And Nvl(b.是否启用, 0) = 1 And
                         a.病人id In
                         (Select 病人id
                          From 病人信息
                          Where 身份证号 = v_证件号
                          Union All
                          Select a.病人id
                          From 病人医疗卡信息 A
                          Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And
                                a.卡号 = v_证件号) And
                         (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                          (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) Loop
      v_Temp := '<LB>' || c_Item.名称 || '</LB>';
      v_Temp := v_Temp || '<KH>' || c_Item.卡号 || '</KH>';
      v_Temp := '<JZK>' || v_Temp || '</JZK>';
      Select Appendchildxml(x_Templet, '/OUTPUT/LIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  Else
    For c_Item In (Select Distinct b.名称, a.卡号
                   From 病人医疗卡信息 A, 医疗卡类别 B
                   Where a.卡类别id = b.Id And Nvl(b.是否启用, 0) = 1 And
                         a.病人id In
                         (Select 病人id
                          From 病人医疗卡信息
                          Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And 卡号 = v_证件号) And
                         (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                          (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) Loop
      v_Temp := '<LB>' || c_Item.名称 || '</LB>';
      v_Temp := v_Temp || '<KH>' || c_Item.卡号 || '</KH>';
      v_Temp := '<JZK>' || v_Temp || '</JZK>';
      Select Appendchildxml(x_Templet, '/OUTPUT/LIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;
  --绑定证件
  If v_证件类型 Like '%身份证%' Then
    Select Max(a.病人id)
    Into n_病人id
    From (Select 病人id
           From 病人信息
           Where 身份证号 = v_证件号
           Union All
           Select a.病人id
           From 病人医疗卡信息 A
           Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And a.卡号 = v_证件号 And
                 (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                  (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) A;
  Else
    Select Max(a.病人id)
    Into n_病人id
    From (Select a.病人id
           From 病人医疗卡信息 A
           Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And a.卡号 = v_证件号 And
                 (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
                  (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)))) A;
  End If;

  --自定义查询  
  Zl_Third_Custom_Findcards(Xml_In, x_Templet);

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Findcards;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Getmoney
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:计算项目的实收金额
  --入参:Xml_In: 
  --  <IN> 
  --    <FB>费别</FB>                      //费别名称,可以不传
  --    <XMID>收费项目ID</XMID>        //收费项目的ID
  --    <CXFY>1</CXFY>                     //是否计算从项费用,-0不计算,1-计算，默认计算
  --  </IN> 
  --出参:Xml_Out 
  --  <OUTPUT> 
  --    <JE>5</JE>                   //返回根据费别计算好的金额
  --                                     //如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 

  v_费别       费别.名称%Type;
  n_收费项目id 收费项目目录.Id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_标准单价   收费价目.现价%Type;
  v_收费类别   收费项目目录.类别%Type;
  v_收据费目   收入项目.收据费目%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_金额       Varchar2(200);
  n_从项费用   Number(3);
  n_不计算     Number(3);
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 
  v_Err_Msg    Varchar2(200);
  n_Exists     Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/CXFY')
  Into v_费别, n_收费项目id, n_从项费用
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_不计算 := 0;
  If v_费别 Is Null Then
    n_不计算 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;

  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费项目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Rownum < 2;

  If Nvl(n_屏蔽费别, 0) = 0 And n_不计算 = 0 Then
    v_金额     := Zl_Actualmoney(v_费别, n_收费项目id, n_收入项目id, n_标准单价);
    v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
    n_实收金额 := Zl_To_Number(v_金额);
  Else
    n_实收金额 := n_标准单价;
  End If;

  If Nvl(n_从项费用, 1) = 1 Then
    For r_Subfee In (Select b.现价, a.从项数次, b.收入项目id, c.屏蔽费别, a.从项id As 收费细目id
                     From 收费从属项目 A, 收费价目 B, 收费项目目录 C
                     Where a.主项id = n_收费项目id And c.Id = a.从项id And a.从项id = b.Id And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      If Nvl(r_Subfee.屏蔽费别, 0) = 0 And n_不计算 = 0 Then
        v_金额     := Zl_Actualmoney(v_费别, r_Subfee.收费细目id, r_Subfee.收入项目id, r_Subfee.现价);
        v_金额     := Substr(v_金额, Instr(v_金额, ':') + 1);
        n_实收金额 := n_实收金额 + Zl_To_Number(v_金额) * r_Subfee.从项数次;
      Else
        n_实收金额 := n_实收金额 + r_Subfee.现价 * r_Subfee.从项数次;
      End If;
    End Loop;
  End If;

  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getmoney;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Getpati_Unique
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取病人的唯一标识(病人ID) 
  --入参:Xml_In: 
  --   <IN> 
  --     <ZJH>证件号</ZJH>     //卡号
  --     <ZJLX>证件类型</ZJLX>  //医疗卡类别.名称
  --     <XM>姓名</XM> 
  --     <KH>卡号</KH> 
  --     <KLB>卡类别</KLB> 
  --    </IN> 
  --出参:Xml_Out 
  -- <OUTPUT> 
  --   <BRID>病人ID</BRID> 
  --   <MZH>门诊号</MZH>
  --   <ERROR><MSG>错误信息</MSG></ERROR> 
  --  </OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet Xmltype; --模板XML 

  v_证件号   Varchar2(50);
  v_证件类型 医疗卡类别.名称%Type;
  v_姓名     Varchar2(100);
  v_验证姓名 Varchar2(100);
  v_卡号     Varchar2(100);
  v_卡类别   Varchar2(100);
  n_存在     Number(3);
  n_卡类别id 病人医疗卡信息.卡类别id%Type;
  v_操作员   人员表.姓名%Type;

  n_病人id 病人信息.病人id%Type;
  n_门诊号 病人信息.门诊号%Type;

  v_Temp Varchar2(32767); --临时XML 
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/ZJH'), Extractvalue(Value(A), 'IN/ZJLX'), Extractvalue(Value(A), 'IN/XM'),
         Extractvalue(Value(A), 'IN/KH'), Extractvalue(Value(A), 'IN/KLB')
  Into v_证件号, v_证件类型, v_姓名, v_卡号, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --先从用户自定义过程获取病人ID
  n_病人id := Zl_Third_Custom_Getpati(v_卡类别, v_卡号);

  If Nvl(n_病人id, 0) = 0 Then
    If Nvl(v_卡类别, '-') <> '-' And Nvl(v_卡号, '-') <> '-' Then
      Select Max(a.病人id)
      Into n_病人id
      From 病人医疗卡信息 A
      Where a.卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_卡类别 And Nvl(是否启用, 0) = 1) And 卡号 = v_卡号 And
            (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
             (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
    End If;
  
    If Nvl(n_病人id, 0) = 0 And Not v_证件号 Is Null Then
      If v_证件类型 Like '%身份证%' Then
        Begin
          Select 病人id Into n_病人id From 病人信息 Where 身份证号 = v_证件号;
        Exception
          When Others Then
            n_病人id := Null;
        End;
      End If;
      If Nvl(n_病人id, 0) = 0 Then
        Select Max(病人id)
        Into n_病人id
        From 病人医疗卡信息 A
        Where 卡类别id = (Select Max(ID) From 医疗卡类别 Where 名称 = v_证件类型 And Nvl(是否启用, 0) = 1) And 卡号 = v_证件号 And
              (a.状态 = 0 Or Nvl(a.状态, 0) = 1 And Exists
               (Select 1 From 医疗卡挂失方式 Where a.挂失方式 = 名称 And a.挂失时间 + 有效天数 < Trunc(Sysdate)));
      End If;
    End If;
  End If;

  If Nvl(n_病人id, 0) <> 0 Then
    v_Temp := '<BRID>' || n_病人id || '</BRID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Select 门诊号, 姓名 Into n_门诊号, v_验证姓名 From 病人信息 Where 病人id = n_病人id;
    If v_姓名 <> v_验证姓名 Then
      v_Err_Msg := '传入的病人姓名与已有的病人姓名不符,请检查!';
      Raise Err_Item;
    End If;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_病人id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpati_Unique;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Getvisitdetails
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:根据挂号单号获取该次就诊详情
  --入参:Xml_In: 
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --    <JSKLB>结算卡类别</JSKLB>
  --</IN>
  --出参:Xml_Out 
  --<OUTPUT>
  --    <DJLIST>  //如果为空表示为找到数据
  --        <DJ>
  --            <NO>单据号</NO>
  --            <DJLX>单据类型</DJLX> //1-收费单;4-挂号单
  --            <KDSJ>开单时间</KDSJ>
  --            <ZFZT>支付状态</ZFZT>    //0未支付1已支付
  --            <SFJSK>是否结算卡支付</SFJSK> //即该单据是否存在入参<JSKLB>来进行支付的,是返回1,否则返回0
  --            <LX>类型</LX> //挂号单固定为挂号,其他按收费类别汇总
  --            <ZXKS>执行科室</ZXKS>
  --            <ZXKSID>执行科室ID</ZXKSID>
  --            <MXLIST> 
  --                     <MX>
  --                                <JZSJ>就诊时间</JZSJ>    //挂号有效:yyyy-mm-dd hh24:mi:ss
  --                                <BW>部位</BW>               //检查,检验时有效
  --                                <XM>项目名称</XM>     //挂号无效:其他项目有效
  --                                <ZXZT>执行状态</ZXZT> //挂号:未接诊;已接诊;完成就诊;收费:未执行;已执行;部分执行
  --                                <BG>报告状态</BG>// 1-已出报告;0未出报告,检查,检验时有效 
  --                                <BLID>病历ID</BLID>  //如果<BG>字段为1，该值不为空,检查,检验时有效
  --                                <GG>规格</GG>                       //药品有效
  --                                <SL>数量</SL> //非挂号有效
  --                                <DW>单位</DW> //非挂号有效
  --                                <DJ>单价</DJ> //非挂号有效
  --                                <JE>金额</JE>  
  --                     </MX>
  --             </MXLIST>
  --             <DL> //队列
  --                        <XH>序号</XH>
  --                        <QMRS>前面人数</QMRS>  //(由Oracle函数zl_GetSequenceBeforPerons获取)
  --             </DL>
  --        </DJ>
  --    </DJLIST>
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回
  --</OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML 
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  v_Tmp        Varchar2(4000);
  n_Add_Djlist Number(1); --是否增加了DJLIST的;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB')
  Into v_挂号单, v_卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  --1.获取挂号数据
  n_Count := 0;
  For c_挂号 In (Select a.Id, a.No, a.记录性质, a.执行部门id, c.名称 As 执行部门, To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间,
                      a.预约时间, a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志
               From 病人挂号记录 A,
                    (Select NO, Max(Nvl(结帐id, 0)) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = 4 And NO = v_挂号单
                      Group By NO) B, 部门表 C
               Where a.No = v_挂号单 And a.No = b.No And a.执行部门id = c.Id(+)) Loop
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
    Begin
      Select 排队号码 Into v_排队号码 From 排队叫号队列 Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where NO = v_挂号单 And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
    v_Temp := '<NO>' || c_挂号.No || '</NO>';
    v_Temp := v_Temp || '<DJLX>' || 4 || '</DJLX>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    v_Temp := v_Temp || '<LX>挂号</LX>';
    v_Temp := v_Temp || '<ZXKS>' || c_挂号.执行部门 || '</ZXKS>';
    v_Temp := v_Temp || '<ZXKSID>' || c_挂号.执行部门id || '</ZXKSID>';
    v_Temp := v_Temp || '<MXLIST><MX><JZSJ>' || c_挂号.就诊时间 || '</JZSJ><JE>' || c_挂号.金额 || '</JE></MX></MXLIST>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
  
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<DJLIST></DJLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.分类汇总收费单
  v_No := '-_';

  For c_费用 In (Select j.医嘱id, j.相关id As 组号, j.No, j.序号, j.收费类别, i.名称 As 收费类别名, j.执行部门id, q.名称 As 执行部门, j.收费细目id, m.名称,
                      m.规格, Max(j.计算单位) As 计算单位, Decode(Max(j.执行状态), 0, '未执行', 1, '完全执行', 2, '部分执行', '') As 执行状态,
                      Max(j.付款状态) As 付款状态, To_Char(Max(j.登记时间), 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Max(j.单价) As 单价,
                      Sum(j.数量) As 数量, Sum(j.实收金额) As 实收金额
               From (Select a.相关id, a.Id As 医嘱id, b.No, b.收费类别, Max(Decode(b.记录状态, 0, 0, 1)) As 付款状态, b.结帐id, b.执行部门id,
                             Max(Decode(b.记录状态, 2, 0, b.执行状态)) As 执行状态,
                             Max(Decode(b.记录状态, 2, Null + Sysdate, b.登记时间)) As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                             b.计算单位, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量, Sum(b.实收金额) As 实收金额




                      From 门诊费用记录 B, 病人医嘱记录 A
                      Where Mod(b.记录性质, 10) = 1 And a.Id = b.医嘱序号 And Nvl(b.费用状态, 0) = 0 And a.挂号单 = v_挂号单
                      Group By a.相关id, a.Id, b.No, b.收费类别, b.结帐id, b.执行部门id, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位) J,
                    收费项目目录 M, 部门表 Q, 收费项目类别 I
               Where j.收费细目id = m.Id And j.执行部门id = q.Id(+) And j.收费类别 = i.编码(+)
               Group By j.医嘱id, j.相关id, j.No, j.序号, j.收费类别, i.名称, j.执行部门id, q.名称, j.收费细目id, m.名称, m.规格
               Order By 登记时间 Desc, NO Desc, 收费类别, 序号) Loop
    If c_费用.No <> v_No Then
      n_Temp := 0;
      --单据不同,则产生的结构不同
      If Nvl(c_费用.付款状态, 0) = 1 Then
        --是否结算卡支付的
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = c_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
      End If;
      v_Tmp := Null;
      Begin
        Select Wm_Concat(名称)
        Into v_Tmp
        From (Select Distinct b.名称
               From 门诊费用记录 A, 收费项目类别 B
               Where a.收费类别 = b.编码 And a.No = c_费用.No And a.记录性质 = 1 And a.记录状态 In (1, 3));
      Exception
        When Others Then
          Null;
      End;
    
      If Nvl(n_Add_Djlist, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<DJLIST></DJLIST>')) Into x_Templet From Dual;
        n_Add_Djlist := 1;
      End If;
    
      v_No   := c_费用.No;
      v_Temp := '<NO>' || c_费用.No || '</NO>';
      v_Temp := v_Temp || '<DJLX>' || 1 || '</DJLX>';
      v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
      v_Temp := v_Temp || '<ZFZT>' || c_费用.付款状态 || '</ZFZT>';
      v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    
      v_Temp := v_Temp || '<LX>' || Nvl(Replace(v_Tmp, ',', '/'), '') || '</LX>';
      v_Temp := v_Temp || '<ZXKS>' || c_费用.执行部门 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || c_费用.执行部门id || '</ZXKSID>';
      v_Temp := v_Temp || '<MXLIST></MXLIST>' || Nvl(v_队列, '') || '';
      v_Temp := '<DJ NO="' || c_费用.No || '">' || v_Temp || '</DJ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End If;
  
    v_Temp := '<XM>' || Nvl(c_费用.名称, '') || '</XM>';
    If c_费用.收费类别 = 'D' Then
      --检查获取部位
      Begin
        Select Wm_Concat(标本部位) Into v_Tmp From 病人医嘱记录 Where 相关id = c_费用.医嘱id;
      Exception
        When Others Then
          v_Tmp := Null;
      End;
      v_Temp := v_Temp || '<BW>' || Nvl(v_Tmp, '') || '</BW>';
    Elsif c_费用.收费类别 = 'C' Then
      --检验
      Begin
        Select Max(Decode(b.审核时间, Null, 0, 1))
        Into n_Temp
        From 病人医嘱记录 A, 检验标本记录 B
        Where a.Id = c_费用.医嘱id And a.Id = b.医嘱id(+) And Exists
         (Select 1 From 病人医嘱记录 Where 相关id = c_费用.医嘱id And 诊疗类别 = 'C');
      Exception
        When Others Then
          n_Temp := 0;
      End;
      v_Temp := v_Temp || '<BG>' || n_Temp || '</BG>';
      If n_Temp = 1 Then
        --取病历ID
        Begin
          Select 病历id
          Into n_Temp
          From 病人医嘱报告
          Where 医嘱id = c_费用.医嘱id And Nvl(病历id, 0) <> 0 And Rownum < 2;
        Exception
          When Others Then
            n_Temp := Null;
        End;
        v_Temp := v_Temp || '<BLID>' || Nvl(n_Temp, '') || '</BLID>';
      End If;
    End If;
  
    v_Temp := v_Temp || '<GG>' || Nvl(c_费用.规格, '') || '</GG>';
    v_Temp := v_Temp || '<SL>' || Nvl(c_费用.数量, 0) || '</SL>';
    v_Temp := v_Temp || '<DW>' || Nvl(c_费用.计算单位, '') || '</DW>';
    v_Temp := v_Temp || '<DJ>' || Nvl(c_费用.单价, 0) || '</DJ>';
    v_Temp := v_Temp || '<JE>' || Nvl(c_费用.实收金额, 0) || '</JE>';
    v_Temp := '<MX>' || v_Temp || '</MX>';
    Select Appendchildxml(x_Templet, '/OUTPUT/DJLIST/DJ[@NO="' || v_No || '"]/MXLIST', Xmltype(v_Temp))
    Into x_Templet
    From Dual;
  
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitdetails;
/

--88874:刘尔旋,2015-09-29,错误信息处理
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <RQ>2013-11-21 09:00</RQ>     //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- 错误信息  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码         挂号安排.号码%Type;
  d_日期         Date;
  n_操作类型     Number(3);
  n_序号控制     Number(3);
  n_存在         Number(3);
  n_分时段       Number(3);
  n_限号数       挂号安排限制.限号数%Type;
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  n_号序         挂号序号状态.序号%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  n_状态         挂号序号状态.状态%Type;
  v_合作单位     合作单位安排控制.合作单位%Type;
  n_合约模式     Number(3);
  n_启用合作单位 Number(3);
  v_Temp         Varchar2(32767); --临时XML
  v_Optemp       Varchar2(300);
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_Optemp := Zl_Identity(1);
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_Optemp From Dual;
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_操作员姓名 From Dual;
  If n_操作类型 = 0 Then
    --解锁
    Begin
      Select 1
      Into n_Exists
      From 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码 And
            Rownum < 2;
    Exception
      When Others Then
        n_Exists := 0;
    End;
    If n_Exists = 1 Then
      Delete 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码;
      v_Temp := '<HX>' || n_号序 || '</HX>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Else
      v_Temp := '没有发现需要解锁的序号';
      Raise Err_Item;
    End If;
  End If;

  If n_操作类型 = 1 Then
    --锁号
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    Begin
      Select 序号控制, ID
      Into n_序号控制, n_计划id
      From (Select 序号控制, ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_日期 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If n_序号控制 = 1 Then
      If Nvl(n_计划id, 0) <> 0 Then
        Begin
          Select 1 Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位计划控制
          Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号计划时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '传入时间' || d_日期 || '的序号已被使用';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号计划时段
                       Where 计划id = n_计划id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
              
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 序号 = 0 And 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位计划控制 A
                         Where 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位计划控制
                             Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      Else
        Begin
          Select 1 Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
        Exception
          When Others Then
            n_分时段 := 0;
        End;
        Begin
          Select 1
          Into n_启用合作单位
          From 合作单位安排控制
          Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
        Exception
          When Others Then
            n_启用合作单位 := 0;
        End;
        Begin
          Select 1, a.状态, a.操作员姓名, a.机器名
          Into n_存在, n_状态, v_验证姓名, v_验证机器名
          From 挂号序号状态 A, 挂号安排时段 B
          Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
                To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
        If n_存在 = 1 Then
          If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
            Null;
          Else
            --传入时间的序号已经被使用
            v_Temp := '传入时间' || d_日期 || '的序号已被使用';
            Raise Err_Item;
          End If;
        Else
          If n_分时段 = 1 Then
            Begin
              Select 序号
              Into n_号序
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                Select Max(序号) + 1
                Into n_号序
                From (Select Distinct 序号
                       From 挂号安排时段
                       Where 安排id = n_安排id And 星期 = v_星期
                       Union
                       Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
            End;
            Begin
              Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
            Exception
              When Others Then
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                Values
                  (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
            End;
            v_Temp := '<HX>' || n_号序 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            Else
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 序号 = 0 And 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
              If n_合约模式 = 0 Then
                Begin
                  Select 序号
                  Into n_号序
                  From (Select 序号
                         From 合作单位安排控制 A
                         Where 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                               (Not Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                (Select 1
                                 From 挂号序号状态
                                 Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                       机器名 = v_机器名))
                         Order By 序号)
                  Where Rownum < 2;
                Exception
                  When Others Then
                    n_号序 := 0;
                End;
                If n_号序 = 0 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Else
                n_号序 := 1;
                Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                             From 挂号序号状态
                             Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                             
                             Union
                             Select 序号, Null, Null, Null
                             From 合作单位安排控制
                             Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                             Order By 序号) Loop
                  Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                  If r_序号.序号 = n_号序 Then
                    n_号序 := n_号序 + 1;
                  End If;
                End Loop;
                If n_号序 > n_限号数 Then
                  v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                  Raise Err_Item;
                Else
                  Begin
                    Select 1
                    Into n_存在
                    From 挂号序号状态
                    Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                  Exception
                    When Others Then
                      Insert Into 挂号序号状态
                        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                      Values
                        (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                  End;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Lockno;
/

--88474:刘尔旋,2015-09-18,获取单据信息包含退费申请状态
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Paymentinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取指定单据交易信息 
  --入参:Xml_In: 
  --<IN>
  --    <DJ>单据号,性质|....</DJ> //可以传入多个单据
  --    <JSKLB>结算卡类别</JSKLB>
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<DJ>  //如果为空表示没有找到数据
  --    <DJH>单据号</DJH>
  --    <JLXZ>记录性质</JLXZ>   
  --    <YSJE>应收金额</YSJE>
  --    <SSJE>实收金额</SSJE>
  --    <FYMC>收据费目</FYMC> //(多个用逗号分离 )
  --    <JSKZF>结算卡支付</JSKZF> //:0-不是结算卡支付;1-结算卡支付(入参中:JSKLB判断,存在该类别支付的,返回1,否则返回0)
  --    <FKSJ>付款时间</FKSJ>
  --    <JYLSH>交易流水号</JYLSH> //(非结算卡支付的，不返回)
  --    <YXTK>是否允许退款</YXTK>            //0不允许1允许
  --    <YBJS>医保是否结算</YBJS>   //1-已结算;0-未结算
  --    <KP>是否开票</KP>  1是0否
  --    <SQZT>退费申请状态</SQZT>                  //退费申请状态,0-未申请,1-申请中,2-审核通过,3-审核未通过
  --    <JZTFSM>禁止退款说明</JZTFSM>
  --</DJ>
  --<ERROR><MSG></MSG></ERROR>          //错误情况返回
  --</OUTPUT>
  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet      Xmltype; --模板XML 
  v_No           Varchar2(4000);
  v_结算卡类别   Varchar2(100);
  n_结算卡类别id 医疗卡类别.Id%Type;

  n_Temp       Number(18);
  v_Temp       Varchar2(32767); --临时XML 
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_医保结算   Number(2);
  n_允许退款   Number(2);
  n_退费状态   病人退费申请.状态%Type;
  v_审核原因   病人退费申请.审核原因%Type;
  v_说明       Varchar2(100);
  n_补结算     Number(18);
  n_已开医嘱   Number(2);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/DJ'), Extractvalue(Value(A), 'IN/JSKLB')
  Into v_No, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_No Is Null Then
    v_Err_Msg := '不能找到指定的收费单据(当前单据为空)';
    Raise Err_Item;
  End If;
  If v_结算卡类别 Is Not Null Then
    v_Err_Msg := Null;
    Begin
      n_结算卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_结算卡类别id := 0;
    End;
    If Nvl(n_结算卡类别id, 0) = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_结算卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := v_结算卡类别 || '不存在!';
      End;
    Else
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_结算卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_结算卡类别id;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  For c_收费单 In (Select /*+ rule*/
                 记录性质, NO, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Max(收款时间) As 收款时间, Max(结帐id) As 结帐id, Max(是否退款) As 是否退款,
                 Max(是否打印) As 是否打印, Max(记录状态) As 记录状态, f_List2str(Cast(Collect(收据费目) As t_Strlist)) As 收据费目,
                 Max(挂号单) As 挂号单
                
                From (Select 记录性质, NO, 收据费目, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额,
                              To_Char(Max(登记时间), 'yyyy-mm-dd hh24:mi:ss') As 收款时间, Max(结帐id) As 结帐id,
                              Max(Decode(Nvl(a.执行状态, 0), 1, 0, 1)) As 是否退款, Max(Decode(a.实际票号, Null, 0, 1)) 是否打印,
                              Max(a.记录状态) As 记录状态, Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', ''))) As 挂号单
                       From 门诊费用记录 A, Table(f_Str2list2(v_No, '|', ',')) B
                       Where a.No = b.C1 And a.记录性质 = b.C2 And 记录状态 In (1, 3)
                       Group By 记录性质, NO, 收据费目
                       Order By 记录性质, NO, 收据费目)
                Group By 记录性质, NO) Loop
    n_Temp := 0;
    If n_结算卡类别id <> 0 Then
      Begin
        Select 交易流水号, 1
        Into v_交易流水号, n_Temp
        From 病人预交记录
        Where 卡类别id = n_结算卡类别id And 结帐id = Nvl(c_收费单.结帐id, 0);
      Exception
        When Others Then
          n_Temp := 0;
      End;
    
    End If;
    Begin
      Select Count(*) Into n_补结算 From 费用补充记录 Where 收费结帐id = Nvl(c_收费单.结帐id, 0) And Rownum < 2;
    Exception
      When Others Then
        n_补结算 := 0;
    End;
  
    Select Decode(Nvl(Count(*), 0), 0, 0, 1)
    Into n_医保结算
    From 保险结算记录
    Where 性质 = 1 And 记录id = Nvl(c_收费单.结帐id, 0);
  
    n_允许退款 := Nvl(c_收费单.是否退款, 0);
    n_已开医嘱 := 0;
  
    If c_收费单.挂号单 Is Not Null Then
      Begin
        Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = c_收费单.挂号单;
      Exception
        When Others Then
          n_已开医嘱 := 0;
      End;
      If Nvl(n_已开医嘱, 0) = 1 Then
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_已开医嘱, 0) = 1 Then
      v_说明 := '挂号单已开医嘱';
    Elsif Nvl(n_允许退款, 0) = 0 Then
      v_说明 := '单据已经执行';
    End If;
    If Nvl(n_医保结算, 0) = 1 Then
      v_说明     := '单据已经医保结算';
      n_允许退款 := 0;
    End If;
    If Nvl(n_补结算, 0) <> 0 Then
      v_说明     := '单据已经补充结算';
      n_允许退款 := 0;
      n_医保结算 := 1;
    
    End If;
  
    If Nvl(n_允许退款, 0) = 1 Then
      --检查是否有可退数量
      Select Decode(Nvl(Count(*), 0), 0, 0, 1)
      Into n_允许退款
      From (Select 序号, Sum(Nvl(付数, 0) * 数次) As 数量
             From 门诊费用记录 A
             Where NO = c_收费单.No And Mod(记录性质, 10) = c_收费单.记录性质 And 价格父号 Is Null Having Sum(Nvl(付数, 0) * 数次) <> 0
             Group By 序号);
      If Nvl(c_收费单.记录状态, 0) = 3 And n_允许退款 = 0 Then
        v_说明     := '单据已全退';
        n_允许退款 := 0;
      Elsif Nvl(c_收费单.记录状态, 0) = 3 Then
        v_说明     := '单据已部分退费';
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_允许退款, 0) = 1 And Nvl(c_收费单.是否打印, 0) = 1 Then
      v_说明     := '单据已开发票';
      n_允许退款 := 0;
    End If;
  
    Begin
      Select 状态, 审核原因
      Into n_退费状态, v_审核原因
      From 病人退费申请
      Where NO = c_收费单.No And Mod(记录性质, 10) = Mod(c_收费单.记录性质, 10);
    Exception
      When Others Then
        n_退费状态 := -1;
        v_审核原因 := '';
    End;
    n_退费状态 := n_退费状态 + 1;
    If n_退费状态 = 3 Then
      v_说明     := v_审核原因;
      n_允许退款 := 0;
    End If;
  
    v_Temp := '<DJH>' || c_收费单.No || '</DJH>';
    v_Temp := v_Temp || '<JLXZ>' || c_收费单.记录性质 || '</JLXZ>';
    v_Temp := v_Temp || '<YSJE>' || c_收费单.应收金额 || '</YSJE>';
    v_Temp := v_Temp || '<SSJE>' || c_收费单.实收金额 || '</SSJE>';
    v_Temp := v_Temp || '<FYMC>' || c_收费单.收据费目 || '</FYMC>';
    v_Temp := v_Temp || '<FKSJ>' || c_收费单.收款时间 || '</FKSJ>';
    v_Temp := v_Temp || '<JSKZF>' || n_Temp || '</JSKZF>';
    v_Temp := v_Temp || '<JYLSH>' || Nvl(v_交易流水号, '') || '</JYLSH>';
    v_Temp := v_Temp || '<YXTK>' || Nvl(n_允许退款, 0) || '</YXTK>';
    v_Temp := v_Temp || '<YBJS>' || n_医保结算 || '</YBJS>';
    v_Temp := v_Temp || '<KP>' || Nvl(c_收费单.是否打印, 0) || '</KP>';
    v_Temp := v_Temp || '<SQZT>' || n_退费状态 || '</SQZT>';
    v_Temp := v_Temp || '<JZTFSM>' || v_说明 || '</JZTFSM>';
  
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
  
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Paymentinfo;
/

--88366:刘尔旋,2015-09-10,获取优惠金额
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
CREATE OR REPLACE Procedure Zl_Third_Salereginfo
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:调用用户自定义函数获取指定的费别
  --入参:Xml_In:
  --  <IN>
  --       <XMID>123</XMID>   //要计算的收费项目的ID
  --       <BRID>421<BRID>   //病人ID
  --  </IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <YHJE>优惠金额</YHJE>
  --  <JE>计算后的金额</JE>
  --  <FB>计算后的费别</FB>
  -- </OUTPUT>
  --    如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet  Xmltype; --模板XML
  v_Err_Msg  Varchar2(200);
  v_Temp     Varchar2(500);
  n_项目id   挂号安排.项目id%Type;
  n_病人id   病人信息.病人id%Type;
  v_费别     病人信息.费别%Type;
  n_实收金额 门诊费用记录.实收金额%Type := 0;
  n_应收金额 门诊费用记录.应收金额%TYPE := 0;
  n_优惠金额 门诊费用记录.实收金额%TYPE := 0;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID')
  Into n_病人id, n_项目id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_费别 := Zl_Custom_Getpatifeetype(1, n_病人id);

  For r_Fb In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                     Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
               Union All
               Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
               From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
               Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                     Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
               Order By 性质, 项目编码, 收入编码) Loop
    v_Temp     := Zl_Actualmoney(v_费别, r_Fb.项目id, r_Fb.收入项目id, r_Fb.单价);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
    n_实收金额 := n_实收金额 + Zl_To_Number(v_Temp);
    n_应收金额 := n_应收金额 +  r_Fb.单价;
  End Loop;
    n_优惠金额:=n_应收金额-n_实收金额;
  v_Temp := '<YHJE>' || n_优惠金额 || '</YHJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JE>' || n_实收金额 || '</JE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<FB>' || v_费别 || '</FB>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Salereginfo;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Waitingpay
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取待付款收费单(即付款单据)
  --入参:Xml_In: 
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --</IN>
  --出参:Xml_Out 
  --<OUTPUT>
  --        <FYLIST> 如果为空表示未找到数据
  --            <FY>
  --                <NO>单据号</NO>                           
  --                <KDSJ>开单时间</SJ>                           
  --                <KDKS>开单科室</KDKS>                     
  --                <YS></YS>                           //医生
  --                <SFGH></SFGH>                       //是否挂号单,0-收费单,1-挂号单
  --                <FMLIST>
  --                    <FM>
  --                        <MC></MC>                           //费目名称
  --                        <MXLIST>
  --                            <MX>
  --                                <XMMC></XMMC>           //项目名称
  --                                <GG></GG>                   //规格
  --                                <DW></DW>               //单位
  --                                <SL></SL>                   //数量
  --                                <DJ></DJ>                   //单价
  --                                <YSJE></YSJE>               //应收金额
  --                                <SSJE></SSJE>               //实收金额
  --                            </MX>
  --                        </MXLIST>
  --                    </FM>
  --                </FMLIST>
  --            </FY>
  --        </FYLIST>
  --        <ERROR><MSG></MSG></ERROR>                  //如果有错误返回
  --</OUTPUT>

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_挂号单     Varchar2(10);
  n_预约挂号单 Number(3);
  n_Count      Number(18);

  v_Temp Varchar2(32767); --临时XML 
  v_No   Varchar2(50);
  v_费目 Varchar2(50);

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH') Into v_挂号单 From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;

  --1.检查是否有挂号单
  Select Count(*) Into n_Count From 病人挂号记录 A Where NO = v_挂号单;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  If Nvl(n_Count, 0) > 1 Then
    v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
    Raise Err_Item;
  End If;

  Begin
    Select 1 Into n_预约挂号单 From 病人挂号记录 Where NO = v_挂号单 And 记录性质 = 2;
  Exception
    When Others Then
      n_预约挂号单 := 0;
  End;
  --2.费用汇总
  v_No   := '-_';
  v_费目 := '-_';
  If n_预约挂号单 = 0 Then
    --正常挂号
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No In (Select Replace(摘要, '划价:', '')
                                From 病人挂号记录
                                Where NO = v_挂号单 And Instr(摘要, '划价:') > 0) And Mod(b.记录性质, 10) = 1 And
                       Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And
                       b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位
                 Union All
                 
                 Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 病人医嘱记录 A1, 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where A1.挂号单 = v_挂号单 And Mod(b.记录性质, 10) = 1 And A1.Id = b.医嘱序号 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And
                       b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位
                 Order By 顺序号, NO, 收据费目, 序号) Loop
      If v_No <> c_费用.No Then
        v_Temp := '<NO>' || c_费用.No || '</NO>';
        v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
        v_Temp := v_Temp || '<KDKS>' || c_费用.开单科室 || '</KDKS>';
        v_Temp := v_Temp || '<YS>' || c_费用.开单人 || '</YS>';
        v_Temp := v_Temp || '<SFGH>' || n_预约挂号单 || '</SFGH>';
        v_Temp := '<FYLIST NO="' || c_费用.No || '"><FY>' || v_Temp || '<FMLIST></FMLIST></FY></FYLIST>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        v_No   := c_费用.No;
        v_费目 := '-_';
      End If;
    
      If v_费目 <> c_费用.收据费目 Then
      
        v_费目 := c_费用.收据费目;
      
        v_Temp := '<MC>' || v_费目 || '</MC>';
        v_Temp := '<FM SJFM="' || v_费目 || '">' || v_Temp || '<MXLIST></MXLIST></FM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    
      v_Temp := '<XMMC>' || c_费用.名称 || '</XMMC>';
      v_Temp := v_Temp || '<GG>' || c_费用.规格 || '</GG>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_费用.计算单位 || '</DW>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DJ>' || c_费用.单价 || '</DJ>';
      v_Temp := v_Temp || '<YSJE>' || c_费用.实收金额 || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || c_费用.实收金额 || '</SSJE>';
    
      v_Temp := '<MX>' || v_Temp || '</MX>';
    
      Select Appendchildxml(x_Templet,
                             '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST/FM[@SJFM="' || v_费目 || '"]/MXLIST',
                             Xmltype(v_Temp))
      
      Into x_Templet
      From Dual;
    End Loop;
  Else
    --预约挂号
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_挂号单 And b.记录性质 = 4 And
                       b.收费细目id Not In (Select 收费细目id From 收费特定项目 Where 特定项目 = '病历费') And Nvl(b.费用状态, 0) = 0 And
                       b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.开单部门id, b.开单人, b.登记时间, Nvl(b.价格父号, b.序号), b.收费细目id, b.计算单位) Loop
      If v_No <> c_费用.No Then
        v_Temp := '<NO>' || c_费用.No || '</NO>';
        v_Temp := v_Temp || '<KDSJ>' || c_费用.登记时间 || '</KDSJ>';
        v_Temp := v_Temp || '<KDKS>' || c_费用.开单科室 || '</KDKS>';
        v_Temp := v_Temp || '<YS>' || c_费用.开单人 || '</YS>';
        v_Temp := v_Temp || '<SFGH>' || n_预约挂号单 || '</SFGH>';
        v_Temp := '<FYLIST NO="' || c_费用.No || '"><FY>' || v_Temp || '<FMLIST></FMLIST></FY></FYLIST>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        v_No   := c_费用.No;
        v_费目 := '-_';
      End If;
    
      If v_费目 <> c_费用.收据费目 Then
      
        v_费目 := c_费用.收据费目;
      
        v_Temp := '<MC>' || v_费目 || '</MC>';
        v_Temp := '<FM SJFM="' || v_费目 || '">' || v_Temp || '<MXLIST></MXLIST></FM>';
        Select Appendchildxml(x_Templet, '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    
      v_Temp := '<XMMC>' || c_费用.名称 || '</XMMC>';
      v_Temp := v_Temp || '<GG>' || c_费用.规格 || '</GG>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_费用.计算单位 || '</DW>';
      v_Temp := v_Temp || '<SL>' || c_费用.数量 || '</SL>';
      v_Temp := v_Temp || '<DJ>' || c_费用.单价 || '</DJ>';
      v_Temp := v_Temp || '<YSJE>' || c_费用.实收金额 || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || c_费用.实收金额 || '</SSJE>';
    
      v_Temp := '<MX>' || v_Temp || '</MX>';
    
      Select Appendchildxml(x_Templet,
                             '/OUTPUT/FYLIST[@NO="' || v_No || '"]/FY/FMLIST/FM[@SJFM="' || v_费目 || '"]/MXLIST',
                             Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Waitingpay;
/

--88653:刘尔旋,2015-09-17,预约接收后病人科室问题
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_Count    Number(18);
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;
  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH'))
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室ID, b.开单人, b.收费类别, b.收入项目id,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And
                       b.收费细目id Not In (Select 收费细目id From 收费特定项目 Where 特定项目 = '病历费') And Nvl(b.费用状态, 0) = 0 And
                       b.记录状态 = 0 And b.收费细目id = m.Id And b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室ID, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, 0, Null, Null, Null, Null, c_费用.病人科室ID, c_费用.执行部门id);
      n_结帐金额 := n_结帐金额 + c_费用.实收金额;
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        n_预交支付 := c_结算方式.结算金额;
      Else
        If Nvl(n_普通支付, 0) = 0 Then
          n_普通支付 := c_结算方式.结算金额;
          v_结算方式 := c_结算方式.结算方式;
          If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
            Begin
              n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_结算卡序号 := 0;
            End;
            If n_结算卡序号 = 0 Then
              Begin
                Select 编号
                Into n_结算卡序号
                From 卡消费接口目录
                Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的消费卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            End If;
          Else
            Begin
              n_卡类别id := To_Number(c_结算方式.结算卡类别);
            Exception
              When Others Then
                n_卡类别id := 0;
            End;
            If n_卡类别id = 0 Then
              Begin
                Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
              Exception
                When Others Then
                  v_Err_Msg := '未找到对应的医疗卡!';
                  Raise Err_Item;
              End;
            End If;
            If v_结算方式 Is Null Then
              Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
          End If;
          v_结算卡号   := c_结算方式.结算卡号;
          v_交易流水号 := c_结算方式.交易流水号;
          v_交易说明   := c_结算方式.交易说明;
          v_摘要       := c_结算方式.摘要;
        Else
          v_Err_Msg := '挂号结算暂不支持多种结算方式!';
          Raise Err_Item;
        End If;
      End If;
    End Loop;
  
    --预约接收
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
  
    Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别, v_结算方式,
                     n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号, v_结算卡号,
                     v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1);
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Getalarmline
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <ZYID>主页ID</ZYID> //主页ID不传入或为零表示取门诊
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  n_类型   Number(2);
  v_方案   Varchar2(100);
  n_病人id 病人信息.病人id%Type;
  n_病区id 病人信息.当前病区id%Type;
  n_主页id 病案主页.主页id%Type;

  n_报警值    记帐报警线.报警值%Type;
  n_报警方法  记帐报警线.报警方法%Type;
  v_报警标志1 记帐报警线.报警标志1%Type;
  v_报警标志2 记帐报警线.报警标志2%Type;
  v_报警标志3 记帐报警线.报警标志3%Type;

  n_预交余额   病人余额.预交余额%Type;
  n_费用余额   病人余额.预交余额%Type;
  n_担保额     病人信息.担保额%Type;
  n_Temp       病人余额.预交余额%Type;
  n_险类       病案主页.险类%Type;
  n_医保结算额 保险模拟结算.金额%Type;
  v_Temp       Varchar2(32767); --临时XML 
  x_Templet    Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

Begin

  v_Err_Msg := Null;

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID'))
  Into n_病人id, n_主页id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_主页id, 0) = 0 Then
    n_类型 := 1;
  Else
    n_类型 := 2;
  End If;

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份!';
    Raise Err_Item;
  
  End If;
  n_病区id := 0;
  If Nvl(n_主页id, 0) <> 0 Then
    Begin
      Select Nvl(Nvl(b.当前病区id, a.当前病区id), 0), Decode(担保额, Null, 担保额, Zl_Patientsurety(a.病人id, a.主页id)), b.险类
      Into n_病区id, n_担保额, n_险类
      From 病人信息 A, 病案主页 B
      Where a.病人id = b.病人id And a.病人id = n_病人id And b.主页id = n_主页id And Rownum < 2;
    Exception
      When Others Then
        n_病区id  := Null;
        v_Err_Msg := '未找到病案主页,请检查主页ID是否传入正确!';
      
    End;
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
    If Nvl(n_险类, 0) <> 0 Then
      --医保包含医保模拟计算
      Select Nvl(Sum(金额), 0) Into n_医保结算额 From 保险模拟结算 Where 病人id = n_病人id And 主页id = n_主页id;
    End If;
  Else
    Select Decode(担保额, Null, 担保额, Zl_Patientsurety(病人id, 主页id))
    Into n_担保额
    From 病人信息
    Where 病人id = n_病人id;
  End If;

  v_方案 := Zl_Patiwarnscheme(n_病人id, n_主页id);
  Begin
    Select 报警值, Nvl(报警方法, 1), 报警标志1, 报警标志2, 报警标志3
    Into n_报警值, n_报警方法, v_报警标志1, v_报警标志2, v_报警标志3
    From 记帐报警线
    Where 适用病人 = v_方案 And Nvl(病区id, 0) = Decode(n_类型, 1, 0, n_病区id) And Rownum < 2;
  Exception
    When Others Then
      n_报警值 := 0;
  End;
  Begin
    Select 预交余额, 费用余额
    Into n_预交余额, n_费用余额
    From 病人余额
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类型;
  Exception
    When Others Then
      n_预交余额 := 0;
      n_费用余额 := 0;
  End;
  n_Temp := Nvl(n_预交余额, 0) - Nvl(n_费用余额, 0) + Nvl(n_医保结算额, 0);

  v_Temp := '<YJYE>' || Nvl(n_预交余额, 0) || '</YJYE>';
  v_Temp := v_Temp || '<WJFY>' || Nvl(n_费用余额, 0) || '</WJFY>';
  v_Temp := v_Temp || '<BXMLJE>' || Nvl(n_医保结算额, 0) || '</BXMLJE>';
  v_Temp := v_Temp || '<SYK>' || Nvl(n_Temp, 0) || '</SYK>';
  v_Temp := v_Temp || '<DBE>' || Nvl(n_担保额, 0) || '</DBE>';
  v_Temp := v_Temp || '<BJJE>' || Nvl(n_报警值, 0) || '</BJJE>';

  v_Temp := '<OUTPUT>' || v_Temp || '</OUTPUT>';

  x_Templet := Xmltype(v_Temp);
  Xml_Out   := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getalarmline;
/

--88838:刘尔旋,2015-09-10,服务窗预交款充值科室问题
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Deposit_Recharge
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:预交款充值 
  --入参:Xml_In: 
  --    <IN>
  --        <BRID>病人ID</BRID>
  --        <ZYID>主页ID</ZYID>
  --        <SFMZ>是否门诊</SFMZ> //1-是门诊,0-住院
  --        <JSLIST>
  --            <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</JSKH>
  --              <JYLSH>交易流水号</JYLSH>
  --              <JYSM>交易说明</JYSM>
  --              <JSFS>支付方式</JSFS> //充值方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>交易金额</JSJE> //充值金额
  --              <ZY>摘要</ZY> 
  --              <SFXFK>是否消费卡</SFXFK> 
  --              <JSHM>结算号码(可以不传)</JSHM> 
  --              <JKDW>缴款单位(可以不传)</JKDW> 
  --              <DWKFH>单位开户行(可以不传)</DWKFH> 
  --              <DWZH>单位帐号(可以不传)</DWZH> 
  --              <HZDW>合作单位(可以不传)</HZDW> 
  --              <EXPENDLIST>  //扩展交易信息
  --                   <EXPEND>
  --                        <JYMC>交易名称</JYMC>
  --                        <JYLR>交易内容</JYLR>
  --                   </EXPEND>
  --              </EXPENDLIST >
  --            </JS>
  --         </JSLIST>
  --    </IN>
  --出参:Xml_Out 
  --  <OUTPUT> 
  --     <YJDH>预交单号(多个逗号分隔)</YJDH>
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUTPUT> 
  -------------------------------------------------------------------------------------------------- 
  v_结算方式   Varchar2(2000);
  v_Nos        Varchar2(4000);
  v_No         病人预交记录.No%Type;
  v_操作员编码 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;

  n_卡类别id   医疗卡类别.Id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  n_主页id     病人预交记录.主页id%Type;
  n_科室id     病人预交记录.科室id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_结算卡序号 病人预交记录.结算卡序号%Type;
  n_预交类别   病人预交记录.预交类别%Type;
  n_消费卡     Number(2);
  n_门诊预存   Number(2);

  d_登记时间 Date;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_Count Number(18);

  Function Zl_结算方式_Get
  (
    卡类别_In   Varchar2,
    消费卡_In   Number,
    卡类别id_In Out 病人预交记录.卡类别id%Type
  ) Return Varchar2 As
    v_名称 Varchar2(200);
  
  Begin
  
    v_结算方式 := Null;
    v_Err_Msg  := Null;
  
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If Nvl(消费卡_In, 0) = 1 Then
    
      If n_卡类别id = 0 Then
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 名称 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
        End;
      
      Else
      
        Begin
          Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
          Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
          From 卡消费接口目录
          Where 编号 = 卡类别_In;
        Exception
          When Others Then
            v_Err_Msg := '未找到指定的结算支付信息!';
        End;
      
      End If;
    
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在消费卡管理中设置结算方式';
        Raise Err_Item;
      End If;
      卡类别id_In := n_卡类别id;
    
      Return v_结算方式;
    
    End If;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    卡类别id_In := n_卡类别id;
    Return v_结算方式;
  End Zl_结算方式_Get;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), To_Number(Extractvalue(Value(A), 'IN/ZYID')),
         To_Number(Extractvalue(Value(A), 'IN/SFMZ'))
  Into n_病人id, n_主页id, n_门诊预存
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_门诊预存, 0) = 0 Then
    n_预交类别 := 2;
  Else
    n_预交类别 := 1;
  End If;
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许充值!';
    Raise Err_Item;
  
  End If;

  --操作员信息:部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity;
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;

  Select Nvl(a.当前科室id, b.出院科室id)
  Into n_科室id
  From 病人信息 A, 病案主页 B
  Where b.病人id(+) = a.病人id And a.主页id = b.主页id(+) And a.病人id = n_病人id;

  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_操作员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  v_Err_Msg := Null;

  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;

  If Nvl(n_主页id, 0) = 0 Then
    n_主页id := Null;
  End If;

  If Nvl(n_科室id, 0) = 0 Then
    n_科室id := Null;
  End If;

  d_登记时间 := Sysdate;

  --2.确定支付方式
  n_Count := 0;
  v_Nos   := Null;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                        Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                        Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                        Extractvalue(b.Column_Value, '/JS/JSHM') As 结算号码,
                        Extractvalue(b.Column_Value, '/JS/JKDW') As 缴款单位,
                        Extractvalue(b.Column_Value, '/JS/DWKFH') As 单位开户行,
                        Extractvalue(b.Column_Value, '/JS/DWZH') As 单位帐号,
                        Extractvalue(b.Column_Value, '/JS/HZDW') As 合作单位,
                        Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
  
    v_No := Nextno(11);
    If v_Nos Is Null Then
      v_Nos := v_No;
    Else
      v_Nos := v_Nos || ',' || v_No;
    End If;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Nvl(c_结算方式.结算金额, 0) = 0 Then
      v_Err_Msg := '传入的充值金额为零,没必要进行充值处理,请检查充值金额是否传入错误!';
      Raise Err_Item;
    End If;
  
    n_结算卡序号 := Null;
    n_卡类别id   := Null;
    n_消费卡     := Nvl(c_结算方式.是否消费卡, 0);
  
    If c_结算方式.结算卡类别 Is Not Null Then
      --三方卡结算
      v_结算方式 := Zl_结算方式_Get(c_结算方式.结算卡类别, n_消费卡, n_卡类别id);
      If Nvl(n_消费卡, 0) = 1 Then
        n_结算卡序号 := n_卡类别id;
        n_卡类别id   := Null;
      End If;
    
    Else
      v_结算方式 := c_结算方式.结算方式;
      If v_结算方式 Is Null Then
        v_Err_Msg := '未确定本次充值的支付方式,请检查支付方式是否传入错误!';
        Raise Err_Item;
      End If;
    End If;
    Zl_病人预交记录_Insert(n_预交id, v_No, Null, n_病人id, n_主页id, n_科室id, c_结算方式.结算金额, v_结算方式, c_结算方式.结算号码, c_结算方式.缴款单位,
                     c_结算方式.单位开户行, c_结算方式.单位帐号, c_结算方式.摘要, v_操作员编码, v_操作员姓名, Null, n_预交类别, n_卡类别id, n_结算卡序号, c_结算方式.结算卡号,
                     c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.合作单位, d_登记时间, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(c_结算方式.Expend, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, n_消费卡, c_结算方式.结算卡号, n_预交id, c_扩展.Jymc || '|' || c_扩展.Jylr, 1);
    End Loop;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前充值的支付方式!';
    Raise Err_Item;
  End If;

  v_Temp := '<YJDH>' || v_Nos || '</YJDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Deposit_Recharge;
/


--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Function Zl_Third_Custom_Getpati
(
  卡类别_In Varchar2,
  卡号_In   Varchar2
) Return Number As
  --------------------------------------------------------------------------------------------------
  --功能:获取病人ID(用户自定义）
  --入参:
  --  卡类别_In : 卡类别名称
  --  卡号_In   : 卡号
  --返回:病人ID
  --------------------------------------------------------------------------------------------------
  v_Temp    Varchar2(32767);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Return 0;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --   <HL>号类</HL>      //号类，可传多个，用逗号分隔，格式:普通,专家,...
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  v_号类         Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/HL')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位, v_号类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;
  If Nvl(n_科室id, 0) = 0 Then
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      n_安排存在 := 0;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  Else
    While (n_Daycount < n_查询天数) Loop
      If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
        d_开始时间 := Sysdate - n_Daycount;
      Else
        d_开始时间 := d_原始时间;
      End If;
      v_上班时间 := Null;
      n_总已挂数 := 0;
      n_已挂数   := 0;
      n_剩余数   := 0;
      n_限号数   := 0;
      n_已约数   := 0;
      n_限约数   := 0;
      n_安排存在 := 0;
      For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                          a.安排id, a.计划id, a.号码, a.号类
                   
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                       d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                        Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       Ap.科室id = n_科室id And
                                       d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二',
                                                           '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_开始时间 + n_Daycount Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                         b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                   
                   ) Loop
        If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
          v_上班时间 := v_上班时间 || '+' || r_排班.排班;
          n_总已挂数 := n_总已挂数 + r_排班.已挂数;
          n_已挂数   := r_排班.已挂数;
          n_限号数   := r_排班.限号数;
          n_已约数   := r_排班.已约数;
          n_限约数   := r_排班.限约数;
          n_安排id   := Nvl(r_排班.安排id, 0);
          n_计划id   := Nvl(r_排班.计划id, 0);
          v_号码     := r_排班.号码;
          n_安排存在 := 1;
        
          If v_上班时间 Is Not Null Then
            If v_合作单位 Is Not Null Then
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位计划控制
                  Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_合约存在
                  From 合作单位安排控制
                  Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约存在 := 0;
                End;
              End If;
            End If;
          
            If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
              If n_计划id <> 0 Then
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              Else
                Begin
                  Select Sum(数量)
                  Into n_合作单位数量
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null);
                Exception
                  When Others Then
                    n_合作单位数量 := 0;
                End;
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                      Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              Else
                n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
              End If;
            Else
              --合约单位
              If n_计划id <> 0 Then
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位计划控制
                  Where 计划id = n_计划id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              Else
                Begin
                  Select 1
                  Into n_禁用
                  From 合作单位安排控制
                  Where 安排id = n_安排id And
                        限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                      '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
                Exception
                  When Others Then
                    n_禁用 := 0;
                End;
              End If;
              If Nvl(n_禁用, 0) = 0 Then
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
              
              End If;
            End If;
          End If;
          n_合作单位数量 := 0;
          n_合约存在     := 0;
          n_禁用         := 0;
        End If;
      End Loop;
      v_上班时间 := Substr(v_上班时间, 2);
      If n_安排存在 = 1 Then
        v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                  '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                  '</PB>';
      End If;
      n_Daycount := n_Daycount + 1;
    End Loop;
  End If;
  v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Docarrange;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
Create Or Replace Procedure Zl_Third_Custom_Findcards
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取医疗卡类别(用户自定义）
  --入参:Xml_In:
  --  <IN>
  --       <SFZ>身份证号</SFZ >不传入时,表示查询全部启用的医疗卡类别ID
  --  </IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --    <LIST>
  --        <JZK>
  --            <LB>卡类别</LB>
  --            <KH>卡号</KH>
  --        </JZK>
  --        <JZK>
  --            ...
  --        </JZK>
  --    </LIST>
  --    如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  v_Temp    Varchar2(32767);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  Null;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Custom_Findcards;
/

--87874:冉俊明,2015-09-02,多单据按单据结算时，保存的保险结算明细信息不正确。
Create Or Replace Procedure Zl_医保核对表_Insert
(
  结帐id_In   In 保险结算明细.结帐id%Type,
  结算方式_In In Varchar2,
  标志_In     In Number := 1,
  清除数据_In Number := 0
) As
  --说明：
  --      结算方式_In：格式：结算方式1|金额1||结算方式2|金额2||...
  --      清除数据_In：1-删除该结帐ID已存在的医保结算方式明细,再插入新的记录
  --                  0-存在该结帐ID的结算方式则进行累加,不存在则直接插入
  v_保险结算 Varchar2(2000);
  v_当前结算 Varchar2(200);
  v_结算方式 Varchar2(50);
  v_结算金额 Number(16, 5);

  v_现金     Number(16, 5);
  v_医保费用 Number(16, 5);
  v_总费用   Number(16, 5);
  v_住院标志 Number(1);
Begin
  v_医保费用 := 0;
  v_住院标志 := 0;
  Begin
    Select 1 Into v_住院标志 From 病人结帐记录 Where ID = 结帐id_In;
  Exception
    When Others Then
      Null;
  End;
  If v_住院标志 = 0 Then
    Select Sum(Nvl(结帐金额, 0)) Into v_总费用 From 门诊费用记录 Where 结帐id = 结帐id_In;
  Else
    Select Sum(Nvl(结帐金额, 0)) Into v_总费用 From 住院费用记录 Where 结帐id = 结帐id_In;
  End If;

  --删除该结帐ID已存在的医保结算方式明细
  If 清除数据_In = 1 Then
    Delete 医保核对表 Where 结帐id = 结帐id_In;
  End If;
  --将正式结算接口返回的各项医保结算方式插入医保核对表
  v_保险结算 := 结算方式_In || '||';
  While v_保险结算 Is Not Null Loop
    v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    Update 保险结算明细
    Set 金额 = Nvl(金额, 0) + Nvl(v_结算金额, 0), 标志 = 标志_In
    Where 结帐id = 结帐id_In And 结算方式 = v_结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 保险结算明细 (结帐id, 结算方式, 金额, 标志) Values (结帐id_In, v_结算方式, v_结算金额, 标志_In);
    End If;
    v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
  End Loop;

  Select Nvl(Sum(金额), 0) Into v_医保费用 From 保险结算明细 Where 结帐id = 结帐id_In And 结算方式 <> '现金';

  --插入现金支付金额
  v_现金 := v_总费用 - v_医保费用;
  Update 保险结算明细 Set 金额 = v_现金, 标志 = 标志_In Where 结帐id = 结帐id_In And 结算方式 = '现金';
  If Sql%RowCount = 0 Then
    Insert Into 保险结算明细 (结帐id, 结算方式, 金额, 标志) Values (结帐id_In, '现金', v_现金, 标志_In);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医保核对表_Insert;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--88016:刘尔旋,2015-09-01,服务窗查看报告限制
Create Or Replace Function Zl_Third_Custom_Rptlimit
(
  病人id_In 病人信息.病人id%Type,
  医嘱id_In 病人医嘱记录.Id%Type
) Return Varchar2 As

  ----------------------------------------------------
  --功能:设置不允许查看的报告
  --入参:病人ID
  --     医嘱ID，如果是一组医嘱，则传入组医嘱ID（即相关ID）
  --通过医嘱ID，判断组医嘱中是否有不允许查看报告的项目
  --返回值:<JZBG></JZBG>    //禁止显示报告。0-允许，1-禁止
  --       <JZTS></JZTS>    //禁止提示文字。对于禁止查看的报告，可返回用于提示病人的文字信息
  ----------------------------------------------------
  v_Tmp     Varchar2(100);
  v_Temp    Varchar2(32767);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  v_Tmp := '<JZBG>0</JZBG><JZTS></JZTS>';
  Return(v_Tmp);
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Custom_Rptlimit;
/

--87988:马政,2015-09-01,结存管理中加入删除和取消功能
Create Or Replace Procedure Zl_药品结存记录_Delete
(
  结存id_In In 药品结存记录.ID%Type
) Is
  v_Tmp Number(1);

  Err_Msg Varchar2(255);
  Err_Nofind Exception;
Begin
  Begin
    Select 1 Into v_Tmp From 药品结存记录 Where ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员删除！';
      Raise Err_Nofind;
  End;

  Begin
    Select 1 Into v_Tmp From 药品结存记录 Where 审核人 Is Null And ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员审核，不能删除！';
      Raise Err_Nofind;
  End;

  --删除结存误差记录
  Delete 药品结存误差 Where 结存id = 结存id_In;

  --结存人为空，删除结存记录
  Delete 药品结存记录 Where ID = 结存id_In;
Exception
  When Err_Nofind Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Delete;
/

--87988:马政,2015-09-01,结存管理中加入删除和取消功能
Create Or Replace Procedure Zl_药品结存记录_Cancel
(
  结存id_In In 药品结存记录.Id%Type,
  取消人_In In 药品结存记录.取消人%Type := Null
) Is
  v_Tmp Number(1);

  Err_Msg Varchar2(255);
  Err_Nofind Exception;

Begin
  Begin
    Select 1 Into v_Tmp From 药品结存记录 Where 取消人 Is Null And ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员取消！';
      Raise Err_Nofind;
  End;

  --结存人不为空，取消结存记录
  Update 药品结存记录 Set 取消人 = Nvl(取消人_In, Zl_Username), 取消日期 = Sysdate Where ID = 结存id_In;

Exception
  When Err_Nofind Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Cancel;
/

--87988:马政,2015-09-01,结存管理中加入删除和取消功能
Create Or Replace Procedure Zl_药品结存记录_Insert
(
  库房id_In In 药品结存记录.库房id%Type := Null,
  填制人_In In 药品结存记录.填制人%Type := Null,
  转结_In   In Number := 1
) Is
  v_Lngid      药品结存记录.Id%Type;
  d_开始日期   药品结存记录.期初日期%Type;
  d_结束日期   药品结存记录.期末日期%Type;
  n_结存时点   Number(2);
  n_上次结存id 药品结存记录.Id%Type;
  v_上次期间   药品结存记录.期间%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
  n_未审核记录 Number(1) := 0;
Begin
  If 转结_In = 0 Then
    --初始结存，期初日期 = 期末日期= 当前系统日期
    d_开始日期 := Sysdate;
    d_结束日期 := d_开始日期;
  Else
    --检查是否存在未审核的结存记录，如果存在则不能结存
    Select Count(ID) Into n_未审核记录 From 药品结存记录 Where 库房id = 库房id_In And 审核日期 Is Null;
  
    If n_未审核记录 > 0 Then
      v_Error := '上次结存未审核，不能再次结存';
      Raise Err_Custom;
    End If;
  
    --取结存时点，默认每月最后一日结存
    n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);
  
    If n_结存时点 <> -1 Then
      --自动结存
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Trunc(Max(期末日期)) + 1, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In And 取消人 Is Null;
    
      --自动结存
      If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(d_开始日期 - 1)), 'dd')) Then
        --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
        d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
      Else
        d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
      End If;
      --检查日期，在结存时点后才能进行结存
      If Sysdate - d_结束日期 < 0 Then
        v_Error := '本月结存时点未到，不能提前结存！';
        Raise Err_Custom;
      End If;
    
      --检查期间
      If v_上次期间 = To_Char(Trunc(d_结束日期), 'yyyymm') Then
        v_Error := '本月已经结存，不能再次结存！';
        Raise Err_Custom;
      End If;
    Else
      --手工结存
      --取上次结存ID,上期期末日期作为本期的期初日期,上次期间
      Select Max(ID), Max(期末日期) + 1 / 24 / 60 / 60, Max(期间)
      Into n_上次结存id, d_开始日期, v_上次期间
      From 药品结存记录
      Where 库房id = 库房id_In And 取消人 Is Null;
    
      d_结束日期 := Sysdate;
    End If;
  End If;

  Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;

  --产生药品结存主表
  Insert Into 药品结存记录
    (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 审核人, 审核日期, 上次结存id, 期间, 性质)
  Values
    (v_Lngid, 库房id_In, d_开始日期, d_结束日期, Nvl(填制人_In, Zl_Username), Sysdate,
     Decode(d_开始日期, Null, Nvl(填制人_In, Zl_Username), Null), Decode(d_开始日期, Null, Sysdate, Null), n_上次结存id,
     To_Char(Trunc(d_结束日期), 'yyyymm'), Decode(转结_In, 0, 0, 1));

  If 转结_In = 0 Then
    --初始结存，以当前库存为准期末 = 期初=当前库存数据
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select a.库房id, a.药品id, Nvl(a.批次, 0) 批次, Nvl(a.实际数量, 0) As 期初数量, Nvl(a.实际金额, 0) As 期初金额,
                    Nvl(a.实际差价, 0) As 期初差价, Nvl(a.实际数量, 0) As 期末数量, Nvl(实际金额, 0) As 期末金额, Nvl(实际差价, 0) As 期末差价
             From 药品库存 A, 药品规格 B
             Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期初数量,
                    -1 * a.入出系数 * a.零售金额 As 期初金额, -1 * a.入出系数 * a.差价 As 期初差价, -1 * a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量,
                    -1 * a.入出系数 * a.零售金额 As 期末金额, -1 * a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 > d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  Else
    --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
    Insert Into 药品结存明细
      (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
      Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
      From (Select 库房id, 药品id, Nvl(批次, 0) As 批次, 期末数量 As 期初数量, 期末金额 As 期初金额, 期末差价 As 期初差价, 期末数量, 期末金额, 期末差价
             From 药品结存明细
             Where 结存id = n_上次结存id
             Union All
             Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                    a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
             From 药品收发记录 A, 药品规格 B
             Where a.药品id = b.药品id And a.库房id + 0 = 库房id_In And a.审核日期 Between d_开始日期 And d_结束日期)
      Group By 库房id, 药品id, 批次
      Order By 库房id, 药品id, 批次;
  
    --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
    Insert Into 药品结存误差
      (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
      Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
      From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
             From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                           Nvl(a.期末差价, 0) As 实际差价
                    From 药品结存明细 A, 药品规格 B
                    Where a.药品id = b.药品id And a.结存id = v_Lngid
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量, -1 * Nvl(a.实际金额, 0) As 实际金额,
                           -1 * Nvl(a.实际差价, 0) As 实际差价
                    From 药品库存 A, 药品规格 B
                    Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = 库房id_In
                    Union All
                    Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                           a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                    From 药品收发记录 A, 药品规格 B
                    Where a.药品id = b.药品id And a.库房id = 库房id_In And a.审核日期 > d_结束日期) A
             Group By 库房id, 药品id, 批次) A
      Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Insert;
/

--87988:马政,2015-09-01,结存管理中加入删除和取消功能
Create Or Replace Procedure Zl1_Autocloseaccount Is
  v_Lngid    药品结存记录.Id%Type;
  d_开始日期 药品结存记录.期初日期%Type;
  d_结束日期 药品结存记录.期末日期%Type;
  n_结存时点 Number(2);
  v_Error    Varchar2(255);
  Err_Custom Exception;
  d_计算日期     药品结存记录.期末日期%Type;
  n_结存id       药品结存记录.Id%Type;
  n_未审核结存id 药品结存记录.Id%Type;

  Cursor c_Stock Is
    Select Distinct b.Id
    From 部门性质说明 A, 部门表 B
    Where a.部门id = b.Id And a.工作性质 In ('西药库', '成药库', '中药库', '西药房', '成药房', '中药房', '制剂室') And
          To_Char(b.撤档时间, 'yyyy-MM-dd') = '3000-01-01'
    Order By b.Id;
  r_Stock c_Stock%RowType;
Begin
  --取结存时点，默认每月最后一日结存
  n_结存时点 := Nvl(Zl_Getsysparameter(221), 0);

  --只有自动结存才走此过程，手工结存不在走此过程
  If n_结存时点 <> -1 Then
    --计算本次结存的结束日期；因为自动结存是对前一天数据进行结存，所以需要按当前日期提前一天来计算或判断，
    If n_结存时点 = 0 Or n_结存时点 > To_Number(To_Char(Trunc(Last_Day(Sysdate - 1)), 'dd')) Then
      --指定按每月最后一天结存；或者结存时点大于了本月最大天数，也按本月最后一天结存
      d_结束日期 := Trunc(Last_Day(Sysdate - 1)) + 1 - 1 / 24 / 60 / 60;
    Else
      d_结束日期 := Trunc(Sysdate - 1, 'MONTH') + n_结存时点 - 1 / 24 / 60 / 60;
    End If;
  
    --检查日期，在结存时点后才能进行自动结存
    If Sysdate - d_结束日期 > 0 Then
      For r_Stock In c_Stock Loop
        --判断期间内是否有结存(不算转结)
        Select Nvl(Max(ID), 0)
        Into n_结存id
        From 药品结存记录
        Where 库房id = r_Stock.Id And 性质 = 1 And 期间 = To_Char(Trunc(d_结束日期), 'yyyymm') And 取消人 Is Null;
      
        If n_结存id > 0 Then
          --如果当前期间已经结存过了，就不再结存，一个期间只结存一次
          Null;
        Else
          --取库房最大的结存ID和本次结存的开始日期
          Select Nvl(Max(ID), 0), Max(期末日期) + 1 / 24 / 60 / 60
          Into n_结存id, d_开始日期
          From 药品结存记录
          Where 库房id = r_Stock.Id And 取消人 Is Null;
        
          If n_结存id > 0 Then
            --检查是否存在未审核的结存，如果存在则自动审核(通常情况都是在期间内手工审核)
            Select Nvl(Max(ID), 0)
            Into n_未审核结存id
            From 药品结存记录
            Where 库房id = r_Stock.Id And 审核日期 Is Null;
          
            If n_未审核结存id > 0 Then
              Zl_药品结存记录_Verify(n_未审核结存id, Zl_Username);
            End If;
          
            --产生新的结存记录
            Select 药品结存记录_Id.Nextval Into v_Lngid From Dual;
          
            Insert Into 药品结存记录
              (ID, 库房id, 期初日期, 期末日期, 填制人, 填制日期, 上次结存id, 期间, 性质)
            Values
              (v_Lngid, r_Stock.Id, d_开始日期, d_结束日期, Zl_Username, Sysdate, n_结存id, To_Char(Trunc(d_结束日期), 'yyyymm'), 1);
          
            --产生药品结存明细表，本期期末=本期期初(上期期末)+期间发生
            Insert Into 药品结存明细
              (结存id, 库房id, 药品id, 批次, 期初数量, 期初金额, 期初差价, 期末数量, 期末金额, 期末差价)
              Select v_Lngid, 库房id, 药品id, 批次, Sum(期初数量), Sum(期初金额), Sum(期初差价), Sum(期末数量), Sum(期末金额), Sum(期末差价)
              From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.期末数量 As 期初数量, a.期末金额 As 期初金额, a.期末差价 As 期初差价, a.期末数量,
                            a.期末金额, a.期末差价
                     From 药品结存明细 A, 药品规格 B
                     Where a.药品id = b.药品id And a.结存id = n_结存id
                     Union All
                     Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, 0 As 期初数量, 0 As 期初金额, 0 As 期初差价,
                            a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 期末数量, a.入出系数 * a.零售金额 As 期末金额, a.入出系数 * a.差价 As 期末差价
                     From 药品收发记录 A, 药品规格 B
                     Where a.药品id = b.药品id And a.库房id + 0 = r_Stock.Id And a.审核日期 Between d_开始日期 And d_结束日期)
              Group By 库房id, 药品id, 批次
              Order By 库房id, 药品id, 批次;
          
            --计算误差：本期期末-库存记录(减去本期期末时间后发生的数据)
            Insert Into 药品结存误差
              (ID, 结存id, 库房id, 药品id, 批次, 数量差, 金额差, 差价差)
              Select 药品结存误差_Id.Nextval, v_Lngid, a.库房id, a.药品id, a.批次, a.实际数量 As 数量差, a.实际金额 As 金额差, a.实际差价 As 差价差
              From (Select 库房id, 药品id, 批次, Sum(实际数量) As 实际数量, Sum(实际金额) As 实际金额, Sum(实际差价) As 实际差价
                     From (Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.期末数量, 0) As 实际数量, Nvl(a.期末金额, 0) As 实际金额,
                                   Nvl(a.期末差价, 0) As 实际差价
                            From 药品结存明细 A, 药品规格 B
                            Where a.药品id = b.药品id And a.结存id = v_Lngid
                            Union All
                            Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, -1 * Nvl(a.实际数量, 0) As 实际数量,
                                   -1 * Nvl(a.实际金额, 0) As 实际金额, -1 * Nvl(实际差价, 0) As 实际差价
                            From 药品库存 A, 药品规格 B
                            Where a.药品id = b.药品id And a.性质 = 1 And a.库房id = r_Stock.Id
                            Union All
                            Select a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, a.入出系数 * a.实际数量 * Nvl(a.付数, 1) As 实际数量,
                                   a.入出系数 * a.零售金额 As 实际金额, a.入出系数 * a.差价 As 实际差价
                            From 药品收发记录 A, 药品规格 B
                            Where a.药品id = b.药品id And a.库房id = r_Stock.Id And a.审核日期 > d_结束日期) A
                     Group By 库房id, 药品id, 批次) A
              Where a.实际数量 <> 0 Or a.实际金额 <> 0 Or a.实际差价 <> 0;
          End If;
        End If;
        --按库房提交
        Commit;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Autocloseaccount;
/

--87737:刘鹏飞,2015-08-31,检查打印数据是否连续跨一页以上
Create Or Replace Procedure Zl_病人护理打印_Update
(
  文件id_In   In 病人护理打印.文件id%Type,
  发生时间_In In 病人护理打印.发生时间%Type,
  行数_In     In 病人护理打印.行数%Type,
  删除_In     Number := 0
) Is
  n_Actives   Number;
  n_Rows      Number; --0-新增,>0表示修改
  n_Lastrows  Number; --小于当前时间的记录行
  n_Startpage Number; --开始页
  n_Startrow  Number; --开始行
  n_Endpage   Number; --结束页
  n_Endrow    Number; --结束行
  n_Count     Number; --发生时间之后的数据条数
  n_Pagerows  Number; --每页有效数据行
  n_Del       Number;
  n_Firstdata Number; --是否是录入的第一条数据
  n_记录id    病人护理数据.Id%Type;
  n_记录oldid 病人护理打印.记录id%Type;
  n_格式id    病人护理文件.格式id%Type;
  d_发生时间  病人护理打印.发生时间%Type;
  v_Username  人员表.姓名%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(1000);
  v_Print   Varchar2(800);
Begin
  n_Del      := 删除_In;
  v_Username := Zl_Username;
  Select 格式id Into n_格式id From 病人护理文件 Where Id = 文件id_In;

  If 行数_In = 0 Then
    v_Err_Msg := '有效数据行不能等于零，请记录本次错误的操作过程！';
    Raise Err_Item;
  End If;

  Begin
    Select 记录id, 行数, 开始页号, 开始行号, 结束页号, 结束行号
    Into n_记录oldid, n_Rows, n_Startpage, n_Startrow, n_Endpage, n_Endrow
    From 病人护理打印
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_Rows := 0;
  End;

  --提取该护理文件格式每页有效数据行（不加错误处理）
  Select To_Number(内容文本)
  Into n_Pagerows
  From 病历文件结构
  Where 对象属性 = '有效数据行' And 父id = (Select Id From 病历文件结构 Where 文件id = n_格式id And 对象序号 = 1 And 父id Is Null);

  --修改数据时,也可能删除
  If n_Del = 0 Then
    Begin
      Select Count(*) Into n_Count From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
      If n_Count = 0 Then
        n_Del := 1;
      End If;
      If n_Count > 1 Then
        v_Err_Msg := '在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】已经存在相应的数据，您不能再次录入或修改数据的时间为此发生时间！';
        Raise Err_Item;
      End If;
    End;
  End If;

  n_Firstdata := 0;
  If n_Del = 1 Then
    Delete 病人护理打印 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
    n_Rows := n_Rows * -1;
  Else
    Select Id Into n_记录id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  
    If n_Rows = 0 Then
      --根据现有打印数据及将要插入的数据，计算出开始页号，行号，结束页号，行号
      Select Min(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      If d_发生时间 Is Null Then
        Select Max(发生时间) Into d_发生时间 From 病人护理打印 Where 文件id = 文件id_In And 发生时间 < 发生时间_In;
        If d_发生时间 Is Null Then
          n_Startpage := 1;
          n_Startrow  := 1;
          n_Firstdata := 1;
        Else
          Select 结束页号, 结束行号
          Into n_Startpage, n_Startrow
          From 病人护理打印
          Where 文件id = 文件id_In And 发生时间 = d_发生时间;
          n_Startrow := n_Startrow + 1;
        End If;
      Else
        Select 开始页号, 开始行号
        Into n_Startpage, n_Startrow
        From 病人护理打印
        Where 文件id = 文件id_In And 发生时间 = d_发生时间;
      End If;
    
      --校正页号,行号
      If n_Startrow > n_Pagerows Then
        n_Startpage := n_Startpage + 1;
        n_Startrow  := n_Startrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Startpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Startpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Startpage - 1;
        End If;
      End If;
      n_Endpage := n_Startpage;
      n_Endrow  := n_Startrow + 行数_In - 1;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      
        --翻页时，自动依据当前页的设置产生新页的活动项目设置
        Begin
          Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Endpage And Rownum < 2;
        Exception
          When Others Then
            n_Actives := 0;
        End;
      
        If n_Actives = 0 Then
          Insert Into 病人护理活动项目
            (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
            Select 文件id, n_Endpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
            From 病人护理活动项目
            Where 文件id = 文件id_In And 页号 = n_Endpage - 1;
        End If;
      End If;
      --不允许录入跨两页的数据
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      Insert Into 病人护理打印
        (记录id, 文件id, 发生时间, 行数, 开始页号, 开始行号, 结束页号, 结束行号)
      Values
        (n_记录id, 文件id_In, 发生时间_In, 行数_In, n_Startpage, n_Startrow, n_Endpage, n_Endrow);
      --新插入的数据的行数就是差值
      n_Rows := 行数_In;
    Else
      --计算与原行数的差值
      n_Rows := 行数_In - n_Rows;
      --校正页号,行号
      n_Endrow := n_Endrow + n_Rows;
      If n_Endrow <= 0 Then
        n_Endrow  := n_Pagerows + n_Endrow;
        n_Endpage := n_Endpage - 1;
      End If;
      If n_Endrow > n_Pagerows Then
        --不考虑输入的数据超过一页的情况
        n_Endpage := n_Endpage + 1;
        n_Endrow  := n_Endrow - n_Pagerows;
      End If;
    
      --不允许录入跨两页的数据
      If n_Endrow > n_Pagerows Or n_Endpage - n_Startpage > 1 Then
        v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据存在错误，录入的数据不能连续跨一页以上！';
        Raise Err_Item;
      End If;
    
      --更新打印数据（当前数据的打印人与打印时间更新为NULL，其后数据不动）
      Update 病人护理打印
      Set 文件id = 文件id_In, 记录id = n_记录id, 发生时间 = 发生时间_In, 行数 = 行数_In, 开始页号 = n_Startpage, 开始行号 = n_Startrow,
          结束页号 = n_Endpage, 结束行号 = n_Endrow, 行差 = Decode(打印人, Null, 0, n_Rows),
          --只有打印过的数据才记录行差
          打印人 = Null, 打印时间 = Null
      Where 记录id = n_记录oldid;
    End If;
  End If;
  --无行差，退出
  If n_Rows = 0 Then
    Return;
  End If;

  --之后是否存在数据？
  Begin
    Select 1 Into n_Count From 病人护理打印 Where 文件id = 文件id_In And 发生时间 > 发生时间_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If n_Count = 1 Then
    --更新之后数据的打印相关数据（除打印人与打印时间）
    If n_Rows > 0 Then
      Update 病人护理打印
      Set 开始页号 = 开始页号 + Decode(Sign(开始行号 + n_Rows - n_Pagerows), 1, 1, 0),
          结束页号 = 结束页号 + Decode(Sign(结束行号 + n_Rows - n_Pagerows), 1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(开始行号 + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Rows, n_Pagerows), 0, n_Pagerows, Mod(结束行号 + n_Rows, n_Pagerows)), 打印人 = Null,
          打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
    Else
      --新的行号小于1则页号-1
      --新的行号+每页的有效行后再进行判断
      Update 病人护理打印
      Set 开始页号 = 开始页号 - Decode(Sign(开始行号 + n_Rows - 1), -1, 1, 0),
          结束页号 = 结束页号 - Decode(Sign(结束行号 + n_Rows - 1), -1, 1, 0),
          开始行号 = Decode(Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows),
                         0,
                         n_Pagerows,
                         Mod(开始行号 + n_Pagerows + n_Rows, n_Pagerows)),
          结束行号 = Decode(Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows),
                         0,
                         n_Pagerows,
                         Mod(结束行号 + n_Pagerows + n_Rows, n_Pagerows)), 打印人 = Null, 打印时间 = Null
      Where 文件id = 文件id_In And 发生时间 > 发生时间_In;
      --程序应该是先删除了数据才更新的，所以不会存在页号为零的，页号为零的肯定已经删除了。
      --DELETE 病人护理打印 WHERE 开始页号=0;
    End If;
    --检查更新之后的打印数据是否存在连续跨一页以上，如果存在则禁止。
    v_Print := '';
    For r_Print In (Select 发生时间, 开始页号
                    From 病人护理打印
                    Where 文件id = 文件id_In And 发生时间 > 发生时间_In And 结束页号 - 开始页号 > 1
                    Order By 发生时间) Loop
      If Lengthb(v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                 To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】') < 800 Then
        v_Print := v_Print || Chr(13) || Chr(10) || '页号【' || r_Print.开始页号 || '】    发生时间【' ||
                   To_Char(r_Print.发生时间, 'YYYY-MM-DD hh24:mi:ss') || '】';
      End If;
    End Loop;
    If v_Print Is Not Null Then
      v_Err_Msg := '您在发生时间【' || To_Char(发生时间_In, 'YYYY-MM-DD hh24:mi:ss') || '】录入的数据影响了后续数据位置，导致以下数据连续跨了一页以上：';
      v_Err_Msg := v_Err_Msg || v_Print || Chr(13) || Chr(10) || '目前产品暂不支持对跨一页以上的数据进行展示和打印，操作终止！';
      Raise Err_Item;
    End If;
  End If;
  --进行关联文件的页号修正
  Zl_病人护理打印_Batchretrypage(文件id_In, n_Firstdata || ';' || n_Firstdata);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人护理打印_Update;
/
--87650:刘尔旋,2015-08-31,挂号零费用产生预交记录
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In     Integer,
  病人id_In       门诊费用记录.病人id%Type,
  号码_In         挂号安排.号码%Type,
  号序_In         挂号序号状态.序号%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  合作单位_In     挂号合作单位.名称%Type,
  挂号金额合计_In 门诊费用记录.实收金额%Type,
  领用id_In       票据使用明细.领用id%Type,
  收费票据_In     Number := 0, --挂号是否使用收费票据
  交易流水号_In   病人预交记录.交易流水号%Type,
  交易说明_In     病人预交记录.交易说明%Type,
  预约方式_In     预约方式.名称%Type := Null,
  预交id_In       病人预交记录.Id%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  加入序号状态_In Number := 0,
  是否自助设备_In Number := 0,
  结帐id_In       门诊费用记录.结帐id%Type := Null,
  锁定类型_In     Number := 0,
  保险结算_In     Varchar2 := Null,
  冲预交_In       Number := Null,
  支付卡号_In     病人预交记录.卡号%Type := Null,
  退号重用_In     Number := 1,
  费别_In         门诊费用记录.费别%Type := Null,
  机器名_In       挂号序号状态.机器名%Type := Null,
  更新年龄_In     Number := 0
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_同科限约一个号 Number(18);
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  d_时段开始时间       Date;
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队标记           排队叫号队列.排队标记%Type;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(n_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = n_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

Begin
  If 费别_In Is Null Then
    Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
  Else
    v_费别 := 费别_In;
  End If;
  If v_费别 Is Null Then
    n_屏蔽费别 := 1;
    Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
  End If;
  Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  If 更新年龄_In = 1 Then
    Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
    If v_年龄 Is Not Null Then
      Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
    End If;
  End If;
  --获取当前机器名称
  If 机器名_In Is Not Null Then
    v_机器名 := 机器名_In;
  Else
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  n_实收金额合计 := 0;
  Select Count(*) + 1
  Into n_挂号序号
  From 病人挂号记录
  Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  --Begin
  --部门ID,部门名称;人员ID,人员编号,人员姓名
  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
    Raise Err_Item;
  End If;

  If 登记时间_In Is Null Then
    d_登记时间 := Sysdate;
  Else
    d_登记时间 := 登记时间_In;
  End If;
  If Trunc(Sysdate) > Trunc(发生时间_In) Then
    v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
    Raise Err_Item;
  End If;
  n_同科限约一个号 := Nvl(zl_GetSysParameter('病人同科限约一个号', 1111), 0);
  n_病人预约科室数 := Nvl(zl_GetSysParameter('病人预约科室数', 1111), 0);
  n_开单部门id     := To_Number(Zl_操作员(0, v_Temp));
  v_操作员编号     := Zl_操作员(1, v_Temp);
  v_操作员姓名     := Zl_操作员(2, v_Temp);
  n_组id           := Zl_Get组id(v_操作员姓名);

  If 操作方式_In <> 1 Then
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
            Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
      Order By 生效时间 Desc;
    Exception
      When Others Then
        Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Select Count(0)
      Into n_合作单位限制
      From 合作单位计划控制
      Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
    Else
      Select Count(0)
      Into n_合作单位限制
      From 合作单位安排控制
      Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
    End If;
  End If;

  If 操作方式_In <> 2 Then
    v_诊室 := Zl_诊室(号码_In);
  End If;
  If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
    --检查结算方式是否完备
    Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
    If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
      Select Count(1)
      Into n_Count
      From 医疗卡类别
      Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
    End If;
    If n_Count = 0 Then
      v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
      Raise Err_Item;
    End If;
  End If;

  --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
  Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
  If n_Count <> 0 Then
    v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
    Raise Err_Item;
  End If;

  Open c_Pati(病人id_In);
  n_Count := 0;
  Begin
    Fetch c_Pati
      Into r_Pati;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '病人未找到，不能继续。';
    Raise Err_Item;
  End If;

  Open c_安排(号码_In, 发生时间_In);
  Begin
    Fetch c_安排
      Into r_安排;
  Exception
    When Others Then
      n_Count := -1;
  End;
  If n_Count = -1 Then
    v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
    Raise Err_Item;
  End If;

  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', '周日')
  Into v_星期
  From Dual;
  Begin
    Select 1 Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum <= 1;
  Exception
    When Others Then
      n_启用分时段 := 0;
  End;

  --对参数控制进行检查
  --仅在预约不扣款时进行检查
  If 操作方式_In = 2 Then
    If Nvl(n_同科限约一个号, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Count(1) As 已约, a.执行部门id As 科室id, Nvl(k.名称, '') As 科室
                        From 病人挂号记录 A, 病人信息 B, 部门表 K
                        Where a.病人id = b.病人id And a.病人id = 病人id_In And a.执行部门id = k.Id(+) And a.记录性质 = 2 And 记录状态 = 1 And
                              a.预约时间 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60
                        Group By a.执行部门id, k.名称) Loop
        If Nvl(n_同科限约一个号, 0) <> 0 And c_Chkitem.科室id = r_安排.科室id Then
        
          v_Err_Msg := '该病人已经在科室[' || c_Chkitem.科室 || ']进行了预约,不能再预约！';
          Raise Err_Item;
        
          If Nvl(n_病人预约科室数, 0) > 0 And c_Chkitem.科室id <> r_安排.科室id Then
            n_已约科室 := n_已约科室 + 1;
          End If;
        End If;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Err_Msg := '同一病人在最多同时预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  d_Date         := Null;
  d_时段开始时间 := Null;

  If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
  
    Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
    Into n_已挂数, n_其中已接收, n_已约数
    From 挂号安排 A, 病人挂号汇总 B
    Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
          Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
          Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
  
    If n_启用分时段 = 1 Then
      If Nvl(r_安排.序号控制, 0) = 1 Then
        If Nvl(是否自助设备_In, 0) = 0 Then
          Select Count(*), Max(开始时间)
          Into n_Count, d_时段开始时间
          From 挂号安排时段
          Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
          v_Temp := '挂号';
          If 操作方式_In > 1 Then
            v_Temp := '预约挂号';
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
            Raise Err_Item;
          End If;
        End If;
        --过点的,不能选择挂号
        If Trunc(Sysdate) = Trunc(发生时间_In) Then
          --挂当天的号
          v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
          For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                       To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                       From 挂号安排时段
                       Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
            If Sysdate > v_时段.结束时间 Then
              v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End Loop;
        End If;
      Elsif 操作方式_In > 1 Then
        --未启用序号的,需要检查预约的情况
      
        n_Count := 0;
        For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                     From 挂号安排时段
                     Where 安排id = r_安排.Id And 星期 = v_星期 And
                           (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                           '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                           '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                           Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                    '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                    '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
          n_预约时段序号 := v_时段.序号;
          d_时段开始时间 := v_时段.开始时间;
        
          Select Count(*), Max(序号)
          Into n_Count, n_预约总数
          From 挂号序号状态
          Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
        
          If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                         To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
            Raise Err_Item;
          End If;
          n_Count := 1;
        End Loop;
      
        If n_Count = 0 Then
          v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                       '),不能进行预约挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作方式_In = 1 And 锁定类型_In <> 2 Then
    --挂号规则:
    --  已挂数不能大于限号数
    If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
      v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
      Raise Err_Item;
    End If;
  End If;

  If 操作方式_In > 1 Then
    --预约的相关检查
    --规则:
    --   1.已限约不能超过限约数
    --   2.检查是否启用时段的
    If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
      v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
      Raise Err_Item;
    End If;
  End If;
  If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
  
    If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
      v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
      Raise Err_Item;
    End If; --Nvl(r_安排.序号控制, 0) =0
  
    n_序号 := Case
              When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
               Nvl(号序_In, 0)
              Else
               0
            End;
    --合作单位限数量模式
    Begin
      If Nvl(n_计划id, 0) <> 0 Then
        Select 0
        Into n_序号
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      Else
        Select 0
        Into n_序号
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
              限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                            '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
      End If;
      n_合作单位限数量模式 := 1;
    Exception
      When Others Then
        n_合作单位限数量模式 := 0;
    End;
    --开放序号检查
    For c_合作单位 In (Select c.序号, 数量
                   From 挂号安排 A, 合作单位安排控制 C
                   Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                         c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                    (Select 1
                          From 挂号安排计划 D
                          Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                   Union All
                   Select c.序号, 数量
                   From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                        (Select Max(a.生效时间) As 生效, 安排id
                          From 挂号安排计划 A, 挂号安排 B
                          Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                          Group By 安排id) E
                   Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                         Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                         Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                         发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                         Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
    
      If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
        n_是否开放 := 1;
        Exit;
      Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
        Begin
          Select Nvl(已约数, 0)
          Into n_预约数量
          From 合作单位挂号汇总
          Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
        Exception
          When Others Then
            n_预约数量 := 0;
        End;
        If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
          v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
          Raise Err_Item;
        End If;
        n_是否开放 := 1;
        Exit;
      End If;
    
    End Loop;
  
    If Nvl(n_是否开放, 0) = 0 Then
      v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
      Raise Err_Item;
    End If;
  End If;

  --检查限号数和限约数
  n_行号         := 1;
  n_原项目id     := 0;
  n_原收入项目id := 0;
  n_实收金额合计 := 0;
  If 锁定类型_In <> 1 Then
    If 操作方式_In <> 2 Then
      If Nvl(结帐id_In, 0) = 0 Then
        --这里应该程序传入
        Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
      Else
        n_结帐id := 结帐id_In;
      End If;
    Else
      n_结帐id := Null;
    End If;
  End If;
  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = r_安排.项目id And
                       Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_价格父号 := Null;
    If n_原项目id = c_Item.项目id Then
      If n_原收入项目id <> c_Item.收入项目id Then
        n_价格父号 := n_行号;
      End If;
      n_原收入项目id := c_Item.收入项目id;
    End If;
    n_原项目id := c_Item.项目id;
    n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
    n_实收金额 := n_应收金额;
    If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
      --打折:
      v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    End If;
    n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
  
    --锁定单据不产生费用
    If 锁定类型_In <> 1 Then
      --产生病人挂号费用(可能单独是或包括病历费用)
      Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
      --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      Insert Into 门诊费用记录
        (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
         收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
         操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
      Values
        (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
         Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别, r_Pati.年龄,
         r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
         n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
         Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
         摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
    End If;
    n_行号 := n_行号 + 1;
  
  End Loop;

  If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
    v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
    Raise Err_Item;
  End If;

  If n_启用分时段 = 1 Then
    d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
  Else
    d_Date := Trunc(发生时间_In);
  End If;

  --更新挂号序号状态
  If 锁定类型_In <> 2 Then
    n_号序 := 号序_In;
  End If;
  Begin
    Select 1
    Into n_Count
    From 挂号序号状态
    Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 1 Then
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
      n_号序 := Null;
    End If;
    If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
      v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
      Raise Err_Item;
    End If;
  End If;
  n_Count := 0;
  If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
    If 退号重用_In = 1 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_号序
      From 挂号序号状态
      Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
    End If;
  End If;
  If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
  
    If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
      --规则:预约时段序号||预约数
      If Nvl(n_预约总数, 0) = 0 Then
        v_Temp := Nvl(r_安排.限约数, 0);
        v_Temp := LTrim(RTrim(v_Temp));
        v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
        v_Temp := n_预约时段序号 || v_Temp;
        n_号序 := To_Number(v_Temp);
      Else
        n_号序 := n_预约总数 + 1;
      End If;
    End If;
  End If;

  If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
      n_序号锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_序号锁定   := 0;
    End;
    If n_序号锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
      Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
          Values
            (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
        
          If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
            Update 合作单位挂号汇总
            Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
            Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
            If Sql%NotFound Then
              Insert Into 合作单位挂号汇总
                (号码, 日期, 序号, 合作单位, 已约数, 已接数)
              Values
                (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --锁定单据不产生任何 费用
  If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
    --挂号,预约挂号已经扣款部分
    n_预交id := 预交id_In;
    If Nvl(n_预交id, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
    n_结算合计 := 0;
    If 保险结算_In Is Not Null Then
      --各个保险结算
      v_结算内容 := 保险结算_In || '||';
      n_结算合计 := 0;
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
          Values
            (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额,
             n_结帐id, n_组id, n_结帐id, 4);
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
        End If;
        n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    If Nvl(冲预交_In, 0) <> 0 Then
      --处理总预交
      n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
      n_预交金额 := 冲预交_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_结算金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 <= n_结算金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      End If;
    End If;
    --剩余款项,用指定结算方支付
    n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
    If Nvl(n_结算金额, 0) < 0 Then
      v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
      Raise Err_Item;
    End If;
    If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
      If 结算方式_In Is Null Then
        v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(预交id_In, 0) <> 0 Then
        --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
        Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
        n_预交id := Nvl(预交id_In, 0);
      End If;
    
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id, 合作单位_In || '缴款', n_组id,
         交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
    End If;
  
    --更新人员缴款数据
  
    For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                 Group By 结算方式) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
      Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
        n_返回值 := Nvl(v_缴款.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    
    End Loop;
  
  End If;

  --处理挂号记录
  If 锁定类型_In = 2 Then
    Begin
      Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    Exception
      When Others Then
        Null;
    End;
  Else
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  End If;

  Update 病人挂号记录
  Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
      操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1), 接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
      接收时间 = Case 锁定类型_In
                When 1 Then
                 Null
                Else
                 Case 操作方式_In
                   When 2 Then
                    Null
                   Else
                    d_登记时间
                 End
              End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位)
  Where ID = n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
       r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
       Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
       Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In, v_付款方式);
  End If;
  --锁定单据不能产生队列
  If 锁定类型_In <> 1 Then
    n_预约生成队列 := 0;
    If 操作方式_In > 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
    --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
    If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
      If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
        --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站      
        If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
          --产生队列
          --.按”执行部门” 的方式生成队列
          v_队列名称 := r_安排.科室id;
          v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          v_排队标记 := Substr(v_排队号码, 1, 1);
          v_排队号码 := Substr(v_排队号码, 2);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)  
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
          --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, v_排队标记, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                           d_排队时间, 预约方式_In, n_启用分时段, v_排队序号);
        End If;
      End If;
    End If;
  
    If Nvl(操作方式_In, 0) = 1 Then
      --处理票据使用情况
      If 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
      --病人本次就诊(以发生时间为准)
      If Nvl(r_Pati.病人id, 0) <> 0 Then
        Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
      End If;
    End If;
  End If;
  --病人挂号汇总
  --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
  If 锁定类型_In <> 2 Then
    --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
    n_预约 := Case
              When Nvl(操作方式_In, 0) = 1 Then
               0
              When Nvl(操作方式_In, 0) = 2 Then
               1
              When Nvl(操作方式_In, 0) = 3 Then
               3
              Else
               0
            End;
    Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--87650:刘尔旋,2015-08-31,免费挂号产生预交记录
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In       门诊费用记录.病人id%Type,
  门诊号_In       门诊费用记录.标识号%Type,
  姓名_In         门诊费用记录.姓名%Type,
  性别_In         门诊费用记录.性别%Type,
  年龄_In         门诊费用记录.年龄%Type,
  付款方式_In     门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In         门诊费用记录.费别%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  序号_In         门诊费用记录.序号%Type,
  价格父号_In     门诊费用记录.价格父号%Type,
  从属父号_In     门诊费用记录.从属父号%Type,
  收费类别_In     门诊费用记录.收费类别%Type,
  收费细目id_In   门诊费用记录.收费细目id%Type,
  数次_In         门诊费用记录.数次%Type,
  标准单价_In     门诊费用记录.标准单价%Type,
  收入项目id_In   门诊费用记录.收入项目id%Type,
  收据费目_In     门诊费用记录.收据费目%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In     门诊费用记录.应收金额%Type,
  实收金额_In     门诊费用记录.实收金额%Type,
  病人科室id_In   门诊费用记录.病人科室id%Type,
  开单部门id_In   门诊费用记录.开单部门id%Type,
  执行部门id_In   门诊费用记录.执行部门id%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  医生姓名_In     挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病历费_In       Number, --该条记录是否病历工本费
  急诊_In         Number,
  号别_In         挂号安排.号码%Type,
  诊室_In         门诊费用记录.发药窗口%Type,
  结帐id_In       门诊费用记录.结帐id%Type,
  领用id_In       票据使用明细.领用id%Type,
  预交支付_In     病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In     病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In     病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In   门诊费用记录.保险大类id%Type,
  保险项目否_In   门诊费用记录.保险项目否%Type,
  统筹金额_In     门诊费用记录.统筹金额%Type,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In     Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In     Number := 0, --挂号是否使用收费票据
  保险编码_In     门诊费用记录.保险编码%Type,
  复诊_In         病人挂号记录.复诊%Type := 0,
  号序_In         挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In         病人挂号记录.社区%Type := Null,
  预约接收_In     Number := 0,
  预约方式_In     预约方式.名称%Type := Null,
  生成队列_In     Number := 0,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  操作类型_In     Number := 0,
  险类_In         病人挂号记录.险类%Type := Null,
  结算模式_In     Number := 0,
  记帐费用_In     Number := 0,
  退号重用_In     Number := 1,
  修正病人费别_In Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO, 预交类别)
    Order By ID, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);
  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;
  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存在相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  If Nvl(n_计划id, 0) = 0 Then
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
  Else
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(r_Deposit.预交类别, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
      
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         Null, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Exists (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) > Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

--87502:张德婷,2015-08-28,修正在发送小于已存在输液配药记录的执行时间的输液单的时导致瓶签重复的问题
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In And b.病人id = n_病人id
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;
  Function Zl_Getpivaworkbatch
  (
    执行时间_In   In Date,
    配置中心id_In In 输液配药记录.部门id%Type
  ) Return Number As
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 配置中心id_In
      Order By 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 配置中心id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch     := 0;
      v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
      v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
    
      If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
        v_Batch := v_配药批次.批次;
        n_打包  := v_配药批次.打包;
        Exit When v_Batch > 0;
      End If;
    End Loop;
  
    If v_Batch = 0 Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源病区', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  
  v_医嘱ids  := 医嘱id_In;
  v_当前病人 := '';
  v_New相关id:=0;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B
    Where a.收费细目id = b.药品id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
    
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人病区id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
    
    If v_医嘱记录.是否tpn = 2 Then
      v_Continue := 1;  
    end if;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change      := True;
            d_Old执行时间 := v_执行时间;
            
            Select /*+ rule*/
             Count(a.要求时间)
            Into n_Cur
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60;
            
            Select Count(a.要求时间)
            Into n_Sum
            From 医嘱执行时间 A
            Where a.医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                  a.要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
            Select Count(Distinct a.摆药单号)
            Into n_摆药单
            From 输液配药记录 A
            Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                  a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
          
            If n_Cur <> n_Sum Or  n_摆药单 > 1 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
              
              For v_输液记录 In (Select ID, 执行时间
                             From 输液配药记录
                             Where 医嘱id In
                                   (Select ID
                                    From 病人医嘱记录
                                    Where 病人id =
                                          (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                                   执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60 And 操作状态 < 2) Loop
                v_批次 := Zl_Getpivaworkbatch(v_输液记录.执行时间, 部门id_In);
                Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液记录.Id;
                v_批次 := 0;
              End Loop;
            End If;
          End If;
        
          If b_Change = True Then
            b_Change := True;
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID
                             From 病人医嘱记录
                             Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            End If;
          
            If b_Change = True Then
              For v_单个医嘱记录 In c_单个医嘱记录 Loop
                --检查输液单是否调整到打包状态
                Select Count(ID)
                Into n_Sum
                From 输液配药记录
                Where 医嘱id = v_单个医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And
                      打包时间 Is Not Null;
                If n_Sum <> 0 Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              
                Select Count(医嘱id)
                Into n_Cur
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
                Select Count(医嘱id)
                Into n_Sum
                From 医嘱执行时间
                Where 医嘱id = v_单个医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
                If n_Sum <> n_Cur Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_单个医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                  Exit;
                End If;
              End Loop;
            End If;
          End If;
        
          If v_保持上次批次 = 1 Or b_Change = True Then
            --取上次的批次
            Begin
              Select Distinct 配药批次
              Into v_批次
              From 输液配药记录 A
              Where 医嘱id = v_医嘱记录.相关id And
                    发送号 = (Select Distinct Max(发送号)
                           From 输液配药记录
                           Where 医嘱id = v_医嘱记录.相关id And 发送号 <> v_医嘱记录.发送号) And
                    To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_执行时间, 'hh24:mi:ss');
            Exception
              When Others Then
                v_批次 := 0;
            End;
          End If;
        
          If v_批次 = 0 Then
            v_批次 := Zl_Getpivaworkbatch(v_执行时间, 部门id_In);
          
            --同病人同批次总输液量控制，超过则分配到下个批次
            If v_输液总量 > 0 And Not v_大输液剂型 Is Null And v_批次 < v_Maxbatch Then
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Curdose
                From (Select Distinct c.Id, c.单量
                       From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id And
                             e.药名id = f.药名id And b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And
                             f.药品剂型 = g.Column_Value And a.相关id = v_相关id And b.发送号 = v_发送号);
              Exception
                When Others Then
                  v_Curdose := 0;
              End;
            
              Begin
                Select /*+rule */
                 Sum(单量) As 单量
                Into v_Sumdose
                From (Select Distinct a.Id, a.单量
                       From 药品收发记录 A, 病人医嘱记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                       Where c.Id = d.记录id And a.Id = d.收发id And c.医嘱id = b.Id And a.药品id + 0 = e.药品id And
                             e.药名id = f.药名id And b.病人id + 0 = v_医嘱记录.病人id And f.药品剂型 = g.Column_Value And
                             c.执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And c.配药批次 = v_批次);
              Exception
                When Others Then
                  v_Sumdose := 0;
              End;
            
              If v_Sumdose > 0 And v_Sumdose + v_Curdose > v_输液总量 Then
                v_批次 := v_批次 + 1;
              End If;
            End If;
          End If;
        
          if v_Old相关id<>v_医嘱记录.相关id then
            Select Count(医嘱id)
            Into n_发送次数
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id 
            Order By 执行时间;
          else
            n_发送次数:=n_发送次数+1;
          end if;
        
          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 启用 = 1 And 配置中心id = 部门id_In And 批次 = v_批次;
          End If;
        
          If Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0 Then
            n_是否打包     := 1;
            d_手工打包时间 := Sysdate;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
           --如果是TPN：如果指定了要打包或配置，则不管其他条件如何都设置为打包或配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
          
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, Decode(v_批次, 0, Null, v_批次), v_Maxno, n_调整批次, n_是否打包,
             d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          --产生配药记录对应的药品记录
          For v_收发记录 In c_收发记录 Loop
            If v_收发记录.是否不予配置 = 1 Then
              v_Nodosage := 1;
            End If;
          
            n_Count := n_Count + 1;
          
            Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
          
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
               成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
               产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
              Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                     效期, 付数, 填写数量 / v_Count, 实际数量 / v_Count, 成本价, 成本金额 / v_Count, 扣率, 零售价, 零售金额 / v_Count, 差价 / v_Count,
                     '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                     领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间

        From 药品收发记录
              Where ID = v_收发记录.收发id;
          
            Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, v_收发记录.数量 / v_Count);
          End Loop;
        
        End Loop;
      
        For v_收发记录 In c_收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录 Set 是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--87515:刘硕,2015-08-27,转科或转病区时首页不能修改重要的医护人员
Create Or Replace Procedure Zl_病案主页_首页整理
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  年龄_In         病案主页.年龄%Type,
  国籍_In         病案主页.国籍%Type,
  区域_In         病案主页.区域%Type,
  职业_In         病案主页.职业%Type,
  身高_In         病案主页.身高%Type,
  体重_In         病案主页.体重%Type,
  血型_In         病案主页.血型%Type,
  婚姻状况_In     病案主页.婚姻状况%Type,
  医疗付款方式_In 病案主页.医疗付款方式%Type,
  家庭地址_In     病案主页.家庭地址%Type,
  家庭电话_In     病案主页.家庭电话%Type,
  家庭邮编_In     病案主页.家庭地址邮编%Type,
  户口地址_In     病案主页.户口地址%Type,
  户口邮编_In     病案主页.户口地址邮编%Type,
  单位地址_In     病案主页.单位地址%Type,
  单位电话_In     病案主页.单位电话%Type,
  单位邮编_In     病案主页.单位邮编%Type,
  联系人姓名_In   病案主页.联系人姓名%Type,
  联系人关系_In   病案主页.联系人关系%Type,
  联系人电话_In   病案主页.联系人电话%Type,
  联系人地址_In   病案主页.联系人地址%Type,
  入院病况_In     病案主页.入院病况%Type,
  入院方式_In     病案主页.入院方式%Type,
  出院方式_In     病案主页.出院方式%Type,
  再入院_In       病案主页.再入院%Type,
  是否确诊_In     病案主页.是否确诊%Type,
  确诊日期_In     病案主页.确诊日期%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  随诊标志_In     病案主页.随诊标志%Type,
  随诊期限_In     病案主页.随诊期限%Type,
  新发肿瘤_In     病案主页.新发肿瘤%Type,
  中医治疗类别_In 病案主页.中医治疗类别%Type,
  抢救次数_In     病案主页.抢救次数%Type,
  成功次数_In     病案主页.成功次数%Type,
  门诊医师_In     病案主页.门诊医师%Type,
  住院医师_In     病案主页.住院医师%Type,
  主治医师_In     病案主页.住院医师%Type,
  主任医师_In     病案主页.住院医师%Type,
  责任护士_In     病案主页.责任护士%Type,
  操作员编号_In   病案主页.编目员编号%Type := Null,
  操作员姓名_In   病案主页.编目员姓名%Type := Null
) As
  --功能：用于住院医护工作站对病人进行首页整理 
  v_住院医师 病案主页.住院医师%Type;
  v_主治医师 病案主页.住院医师%Type;
  v_主任医师 病案主页.住院医师%Type;
  v_责任护士 病案主页.责任护士%Type;
  v_病人性质 病案主页.病人性质%Type;
  v_原因     病人变动记录.开始原因%Type;
  v_出院科室 病案主页.出院科室id%Type;
  v_Curdate  Date;
  v_Count    Number;
  v_Change   Varchar2(500);
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 c
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate)) a, 病人变动记录 b
    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= v_Curdate;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo  c_Oldinfo%Rowtype;
  r_Endinfo  c_Endinfo%Rowtype;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

Begin
  --取更改前的内容(用NoneData和新的比较) 
  Select 病人性质, Nvl(住院医师, 'NoneData'), Nvl(出院科室id, 入院科室id), Nvl(责任护士, 'NoneData')
  Into v_病人性质, v_住院医师, v_出院科室, v_责任护士
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主治医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
  
  Exception
    When Others Then
      v_主治医师 := 'NoneData';
    
  End;

  Begin
    Select Nvl(信息值, 'NoneData')
    Into v_主任医师
    From 病案主页从表
    Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
  
  Exception
    When Others Then
      v_主任医师 := 'NoneData';
    
  End;

  Update 病案主页
  Set 婚姻状况 = 婚姻状况_In, 年龄 = 年龄_In, 职业 = 职业_In, 国籍 = 国籍_In, 区域 = 区域_In, 医疗付款方式 = 医疗付款方式_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
      家庭地址邮编 = 家庭邮编_In, 单位地址 = 单位地址_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
      联系人电话 = 联系人电话_In, 联系人地址 = 联系人地址_In, 再入院 = 再入院_In, 入院病况 = 入院病况_In, 是否确诊 = 是否确诊_In, 确诊日期 = 确诊日期_In, 抢救次数 = 抢救次数_In,
      成功次数 = 成功次数_In, 尸检标志 = 尸检标志_In, 随诊标志 = 随诊标志_In, 随诊期限 = 随诊期限_In, 血型 = 血型_In, 门诊医师 = 门诊医师_In, 住院医师 = 住院医师_In,
      新发肿瘤 = 新发肿瘤_In, 中医治疗类别 = 中医治疗类别_In, 身高 = 身高_In, 体重 = 体重_In, 出院方式 = 出院方式_In, 入院方式 = 入院方式_In, 责任护士 = 责任护士_In,
      户口地址 = 户口地址_In, 户口地址邮编 = 户口邮编_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Or v_主治医师 <> Nvl(主治医师_In, 'NoneData') Or v_主任医师 <> Nvl(主任医师_In, 'NoneData') Or
     v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
    Select Count(*)
    Into v_Count
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
    If v_Count > 0 Then
      Select f_List2str(Cast(Collect(a.信息) As t_Strlist))
      Into v_Change
      From (Select 姓名 信息
             From 人员表
             Where 0 = 1
             Union All
             Select '住院医师(原:' || v_住院医师 || ')' 信息
             From Dual
             Where v_住院医师 <> Nvl(住院医师_In, 'NoneData')
             Union All
             Select '主治医师(原:' || v_主治医师 || ')'
             From Dual
             Where v_主治医师 <> Nvl(主治医师_In, 'NoneData')
             Union All
             Select '主任医师(原:' || v_主任医师 || ')'
             From Dual
             Where v_主任医师 <> Nvl(主任医师_In, 'NoneData')
             Union All
             Select '责任护士(原:' || v_责任护士 || ')'
             From Dual
             Where v_责任护士 <> Nvl(责任护士_In, 'NoneData')) a;
    
      v_Error := '该病人正在转科或转病区，不能进行如下变动：' || v_Change || '！';
      Raise Err_Custom;
    End If;
    Select Sysdate Into v_Curdate From Dual;
    Open c_Oldinfo;
    Fetch c_Oldinfo
      Into r_Oldinfo;
    Open c_Endinfo;
    Fetch c_Endinfo
      Into r_Endinfo;
    If c_Endinfo%Rowcount = 0 Then
      --出院病人不进行变动处理 
      Close c_Endinfo;
    Else
      --如果终止时间<>NULL ，就记录下终止时间和终止原因。 
      If r_Oldinfo.终止时间 Is Not Null Then
        v_终止时间 := r_Oldinfo.终止时间;
        v_终止原因 := r_Oldinfo.终止原因;
        v_终止人员 := r_Oldinfo.终止人员;
      End If;
      --如果是待入住的病人，则不产生变动，直接修改已有变动 
      If r_Oldinfo.开始原因 = 1 And r_Oldinfo.终止时间 Is Null Then
        Update 病人变动记录
        Set 经治医师 = 住院医师_In, 主治医师 = 主治医师_In, 责任护士 = 责任护士_In, 主任医师 = 主任医师_In
        Where Id = r_Oldinfo.Id;
      Else
        If v_住院医师 <> Nvl(住院医师_In, 'NoneData') Then
          v_原因 := 7;
          If v_终止时间 Is Null Then
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
          Else
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
            --更新将来的记录如果有停止到将来的则删除上次计算时间 
            Update 病人变动记录
            Set 经治医师 = 住院医师_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
          End If;
        
          --产生病历书写时机 
          Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '交班', r_Oldinfo.科室id, 住院医师_In, v_Curdate, v_Curdate);
        
          While c_Oldinfo%Found Loop
            --注意:有附加床位时有多条记录 
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
               r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, 住院医师_In,
               r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
          
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End Loop;
        
          --如果存在停止到将来的变动就更新终止原因 
          If v_终止时间 Is Not Null Then
            v_终止原因 := v_原因;
            v_终止时间 := v_Curdate;
            v_终止人员 := 操作员姓名_In;
          End If;
        
          Close c_Oldinfo;
          Open c_Oldinfo; --重新打开,以便取最新信息 
          Fetch c_Oldinfo
            Into r_Oldinfo;
        End If;
      
        If v_主治医师 <> Nvl(主治医师_In, 'NoneData') Then
          Update 病案主页从表
          Set 信息值 = 主治医师_In
          Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主治医师';
        
          If Sql%Rowcount = 0 Then
            Insert Into 病案主页从表
              (病人id, 主页id, 信息名, 信息值)
            Values
              (病人id_In, 主页id_In, '主治医师', 主治医师_In);
          
          End If;
        
          v_原因 := 11;
          If v_终止时间 Is Null Then
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
          
          Else
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
            --更新将来的记录如果有停止到将来的则删除上次计算时间 
            Update 病人变动记录
            Set 主治医师 = 主治医师_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
          End If;
        
          While c_Oldinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
               r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
               主治医师_In, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
          
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End Loop;
        
          --如果存在停止到将来的变动就更新终止原因 
          If v_终止时间 Is Not Null Then
            v_终止原因 := v_原因;
            v_终止时间 := v_Curdate;
            v_终止人员 := 操作员姓名_In;
          End If;
        
          Close c_Oldinfo;
          Open c_Oldinfo;
          Fetch c_Oldinfo
            Into r_Oldinfo;
        End If;
      
        If v_责任护士 <> Nvl(责任护士_In, 'NoneData') Then
          v_原因 := 8;
          If v_终止时间 Is Null Then
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
          Else
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
            --更新将来的记录，如果有停止到将来的则删除上次计算时间 
            Update 病人变动记录
            Set 责任护士 = 责任护士_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
          End If;
          While c_Oldinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
               r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, 责任护士_In, r_Oldinfo.经治医师,
               r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End Loop;
          --如果存在停止到将来的变动就更新终止原因 
          If v_终止时间 Is Not Null Then
            v_终止原因 := v_原因;
            v_终止时间 := v_Curdate;
            v_终止人员 := 操作员姓名_In;
          End If;
          Close c_Oldinfo;
          Open c_Oldinfo;
          Fetch c_Oldinfo
            Into r_Oldinfo;
        End If;
      
        If v_主任医师 <> Nvl(主任医师_In, 'NoneData') Then
          Update 病案主页从表
          Set 信息值 = 主任医师_In
          Where 病人id = 病人id_In And 主页id = 主页id_In And 信息名 = '主任医师';
        
          If Sql%Rowcount = 0 Then
            Insert Into 病案主页从表
              (病人id, 主页id, 信息名, 信息值)
            Values
              (病人id_In, 主页id_In, '主任医师', 主任医师_In);
          
          End If;
        
          v_原因 := 12;
          If v_终止时间 Is Null Then
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
          
          Else
            Update 病人变动记录
            Set 终止时间 = v_Curdate, 终止原因 = v_原因, 终止人员 = 操作员姓名_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因 = v_终止原因;
            --更新将来的记录如果有停止到将来的则删除上次计算时间 
            Update 病人变动记录
            Set 主任医师 = 主任医师_In, 上次计算时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > v_Curdate;
          End If;
        
          While c_Oldinfo%Found Loop
            Insert Into 病人变动记录
              (Id, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情,
               操作员编号, 操作员姓名, 终止时间, 终止原因, 终止人员)
            Values
              (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, v_Curdate, v_原因, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
               r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
               r_Oldinfo.主治医师, 主任医师_In, r_Oldinfo.病情, 操作员编号_In, 操作员姓名_In, v_终止时间, v_终止原因, v_终止人员);
          
            Fetch c_Oldinfo
              Into r_Oldinfo;
          End Loop;
        
          Close c_Oldinfo;
          Open c_Oldinfo;
          Fetch c_Oldinfo
            Into r_Oldinfo;
        End If;
      
        Close c_Oldinfo;
        Close c_Endinfo;
        Select Count(*)
        Into v_Count
        From 病人变动记录
        Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
      
        If v_Count > 1 Then
          v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
          Raise Err_Custom;
        End If;
      
      End If;
    
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病案主页_首页整理;
/
--84958:许华峰,2015-08-27,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表
(
  病人id_In In 病人医嘱记录.病人id%Type,
  主页id_In In 病人医嘱记录.主页id%Type
) Return Varchar2 Is
  v_Return Varchar2(4000);
  v_Temp   Varchar2(200);

  Cursor c_Reportlist Is
    Select * From( Select b.病历id||'' As ID, a.Id As Yzid, Decode(d.检查uid, Null, 0, 1) As Gp, a.医嘱内容 As Mc, c.保存人 As Bgr, to_char(c.完成时间,'YYYY-MM-DD HH24:MI:SS') As Bgsj
      From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D
      Where a.病人id = 病人id_In And nvl(a.主页id,0) = 主页id_In And a.Id = b.医嘱id And b.病历id = c.Id And a.诊疗类别 = 'D' And 相关id Is Null And
            c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8)
    union all Select b.检查报告id||'' As ID, a.Id As Yzid, Decode(d.检查uid, Null, 0, 1) As Gp, a.医嘱内容 As Mc, c.最后编辑人 As Bgr, to_char(c.最后审核时间,'YYYY-MM-DD HH24:MI:SS') As Bgsj
      From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D
      Where a.病人id = 病人id_In And nvl(a.主页id,0) = 主页id_In And a.Id = b.医嘱id And b.检查报告id = c.Id And a.诊疗类别 = 'D' And 相关id Is Null And
            c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8)
     ) Order By Bgsj Desc;
Begin
  For Row_Cols In c_Reportlist Loop
    Select '<FILE>' || '<ID>' || Row_Cols.Id || '</ID>' || '<YZID>' || Row_Cols.Yzid || '</YZID>' || '<GP>' ||
            Row_Cols.Gp || '</GP>' || '<MC>' || Row_Cols.Mc || '</MC>' || '<BGR>' || Row_Cols.Bgr || '</BGR>' ||
            '<BGSJ>' || Row_Cols.Bgsj || '</BGSJ>' || '</FILE>'
    Into v_Temp
    From Dual;

    v_Return := v_Return || v_Temp;
  End Loop;

  If v_Return <> ' ' Then
    v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
  End If;

  Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表;
/

--84958:许华峰,2015-08-27,PACS依赖性接口封装
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2
) Return Xmltype
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
 Is
  File_Id Varchar2(32);
  Docxml  Xmltype;
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  n_Adviceid Number(18);
  v_Ftppath  Varchar2(200);

  n_Count    Number(1);
  --标记变量
  n_i        Number(2);
  n_Len      Number(3);
  n_width    Number(4);
  n_height   Number(4);
  v_id       Varchar2(100);
  v_Ftppath  Varchar2(200);
  v_title    Varchar2(100);
  v_Newline  Varchar2(2);
  v_Text     Varchar2(500);
  v_Name     Varchar2(100);

  x_Content       Xmltype;
  Section_Node    Xmldom.Domnode;
  Element_Node    Xmldom.Domnode;
  Xcdom           Xmldom.Domdocument;
  Node_List       Xmldom.Domnodelist;
  Section_List    Xmldom.Domnodelist;

  Function Getorigpic(Pic_Id In 电子病历记录.Id%Type) Return Xmltype Is
    --读取病历图形，以多个 <OrigPic>节点返回，每个节点<=2000长度
    l_Blob   Blob;
    v_Buffer Varchar2(32767);
    n_Amount Number := 2000;
    n_Offset Number := 1;
    Pos_In   Number := 0;
    Origpic  Xmltype;
    Origpics Xmltype;
  Begin
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = Pic_Id;
    While True Loop
      n_Offset := 1 + Pos_In * n_Amount;
      n_Amount := 2000;
      v_Buffer := '';
      Begin
        Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
      Exception
        When No_Data_Found Then
          Exit;
      End;

      If Length(v_Buffer) = 0 Then
        Exit;
      Else
        Select Xmlelement("OrigPic", Xmlattributes(Pos_In As "序号"), v_Buffer) Into Origpic From Dual;
      End If;
      Select Xmlconcat(Origpics, Origpic) Into Origpics From Dual;
      Pos_In := Pos_In + 1;
    End Loop;
    Return Origpics;
  End Getorigpic;
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';

  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    If File_Id Is Null Then
      Exit;
    Else
      --判断是新版报告还是老版报告,有记录则是新版报告
      Select Count(1) Into n_Count From 影像报告记录 a, 病人医嘱报告 b Where a.id= HexToRaw(File_Id) And a.id = b.检查报告id;

      If n_Count > 0 Then
        --开始某个文件读取
        Begin
          Select a.医嘱id,Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                            RawToHex(a.Id) As "文件ID")))
          Into n_Adviceid,Docxml
          From 影像报告记录 a, 病人医嘱记录 b Where a.id= HexToRaw(File_Id) And a.医嘱id = b.id;
        Exception
          --给定的文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml From Dual;

        --开始读取内容
        Select b.报告内容 Into x_Content From 影像报告记录 b Where b.id||'' = File_Id;

        Xcdom         := Xmldom.Newdomdocument(x_Content);

        n_i := -1;

        Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
        Section_Node := Xmldom.Item(Section_List, 0);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);

        For I In 0 .. n_Len - 1 Loop
          Element_Node      := Xmldom.Item(Node_List, I);

          v_Name            := Xmldom.getNodeName(Element_Node);
          v_Newline         := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');

          If v_Newline Is Null Then
            v_Newline := '1';
          End If;

          If v_Name = 'section' Then   --提纲
            v_title   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_id      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');

            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                                     Xmlelement("Compend", Xmlattributes(v_title As "Name", v_id As "ID")))
            Into Docxml From Dual;
          Elsif v_Name = 'utext' Then  --文本
            v_Text     := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');

            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            End If;
          Elsif v_Name = 'element' Then --要素
            v_title     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
            v_Text      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                          Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') ;

            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(v_title As "Name", v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Element", Xmlattributes(v_title As "Name", v_Newline As "NewLine"), v_Text))
              Into Docxml From Dual;
            End If;
          Elsif v_Name = 'image' Then  --图片
            n_width     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
            n_height    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
            v_Name      := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');

            If nvl(v_Name, ' ') <> ' ' Then
              If nvl(v_id, ' ') = ' ' Then
                Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_width       As "OrigWidth",
                                                                  n_height     As "OrigHeight",
                                                                  n_width      As "ShowWidth",
                                                                  n_height     As "ShowHeight",
                                                                  v_Name       As "PicName",
                                                                  n_Adviceid   As "AdviceID")))
                Into Docxml From Dual;
              Else
                Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(n_width       As "OrigWidth",
                                                                  n_height     As "OrigHeight",
                                                                  n_width      As "ShowWidth",
                                                                  n_height     As "ShowHeight",
                                                                  v_Name       As "PicName",
                                                                  n_Adviceid   As "AdviceID")))
                Into Docxml From Dual;
              End If;
            End If;
          Elsif v_Name = 'signature' Then --签名
            v_Text     := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');

            If nvl(v_id, ' ') = ' ' Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"),
                                                 Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml From Dual;
            Else
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_id || '"]',
                                     Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"),
                                                 Zl_Eprsplit(v_Text, ';', 1)))
              Into Docxml From Dual;
            End If;
          End If;
        End Loop;
      Else
        --开始某个病历文件读取
        Begin
          Select Appendchildxml(Docxml, '/ZlEPR',
                                 Xmlelement("Document",
                                             Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                            a.Id As "文件ID")))
          Into Docxml
          From 电子病历记录 A, 病人信息 B
          Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;

          Select 医嘱ID Into n_Adviceid From 病人医嘱报告 Where 病历ID = File_Id;
        Exception
          --给定的病历文件ID无效
          When Others Then
            Return Null;
        End;
        Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                               Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
        Into Docxml
        From Dual;

        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(null, 0) As "NewLine"), '内容文本'))
              Into Docxml
              From Dual;

        For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                   From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                          From 电子病历内容
                          Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
                   Start With 父id Is Null
                   Connect By Prior ID = 父id
                   Order Siblings By 对象序号, 内容行次) Loop
          If Rs.对象类型 = 1 Then
            --提纲
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 2 Then
            --文本
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 3 Then
            --表格
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Table",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;

            ---对表格的单元格进行填充
            For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                            From 电子病历内容
                            Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                            Order By 内容行次, ID) Loop
              If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
                If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
                  --兼容历史病历
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                Else
                  Select Appendchildxml(Docxml,
                                         '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                         Xmlelement("Cell",
                                                     Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                     Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                    Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                    Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                    Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                     Rs_Cell.内容文本))
                  Into Docxml
                  From Dual;
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;

                If Nvl(n_Adviceid, 0) = 0 Then
                  n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
                End If;
              Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
                --单元格图
                /*Picxml := Getorigpic(Rs_Cell.Id); --由Webservice直接读取BLOB之后直接写文件以提高速度*/
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                        ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                        Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                       Xmlelement("Picture",
                                                   Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                                  Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                                  Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                                  Rs_Cell.Id As "ID"), Rs_Cell.Id))
                Into Docxml
                From Dual;
                --制作标记子节点集
                v_Mark  := '';
                Makxml  := Null;
                Maksxml := Null;
                For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                                From 电子病历内容
                                Where 父id = Rs_Cell.Id
                                Order By 内容行次) Loop
                  v_Marks := v_Mark || Rs_Mark.内容文本;
                  v_Marks := Replace(v_Marks, '||', '^');
                  For I In 1 .. 100 Loop
                    v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                    If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                      --最后一个标记信息不全，存在下一行中
                      Exit;
                    Else
                      Select Xmlelement("Mark",
                                         Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                    Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                    Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                    Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                    Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                    Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                    Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                    Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                    Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                      Into Makxml
                      From Dual;
                      Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                    End If;
                  End Loop;
                End Loop;
                --向Picture插入标记子节点
                Select Appendchildxml(Docxml,
                                       '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                       Maksxml)
                Into Docxml
                From Dual;
              End If;
            End Loop;
          Elsif Rs.对象类型 = 4 Then
            --要素
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
            --图片
            /*Picxml := Getorigpic(Rs.Id);--由Webservice直接读取BLOB之后直接写文件以提高速度*/
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Picture",
                                                 Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                                Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                                Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
              Into Docxml
              From Dual;
            End If;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                                Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                                Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                                Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式", Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                Zl_Eprsplit(v_Mark, '|', 12) As "字体色", Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                Zl_Eprsplit(v_Mark, '|', 14) As "线宽", Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          Elsif Rs.对象类型 = 7 Then
            --诊断
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs.对象类型 = 8 Then
            --签名
            If Rs.父id Is Null Then
              Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                     Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                                 Zl_Eprsplit(Rs.内容文本, ';', 1)))
              Into Docxml
              From Dual;
            End If;
          End If;
        End Loop;
      End If;

      For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
               From 影像检查记录 L, 影像设备目录 A1
               Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop

        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                               Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
        Into Docxml
        From Dual;
      End Loop;
    End If;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86797:刘尔旋,2015-08-24,获取号源特殊预约处理
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD/>      //时间段
  --                  <SL/>      //数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  c_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;

  Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  n_合约剩余数量 := 0;
  If Nvl(n_科室id, 0) <> 0 Then
    --按科室过滤号别
    For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.科室id = n_科室id And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
      If r_No.计划id <> 0 Then
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排计划 Jh, 挂号计划时段 Sd
        Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      Else
        Select Sign(Count(Rownum))
        Into n_分时段
        From 挂号安排 Ap, 挂号安排时段 Sd
        Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
              Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                             '周六', Null) And Rownum < 2;
      End If;
      If n_分时段 = 0 Then
        v_Temp := '';
        If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
          If r_No.计划id <> 0 Then
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          Else
            Select Nvl(Sum(数量), 0)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null);
            Select Count(1)
            Into n_合约模式
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                  限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                '7', '周六', Null) And 序号 = 0;
          End If;
          If n_合约模式 = 0 Then
            If r_No.计划id <> 0 Then
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位计划控制
                     Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录 A
              Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                    Exists (Select 1
                     From 合作单位安排控制
                     Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                           限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                         '周四', '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
            End If;
          Else
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
          End If;
          If n_合约总数量 = 0 Then
            n_合约剩余数量 := 0;
          Else
            n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
            If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
              n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
            End If;
          End If;
        End If;
      Else
        v_Temp := '<SPANLIST>';
        If r_No.计划id <> 0 Then
          Select Max(结束时间)
          Into d_加号时间
          From 挂号计划时段
          Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Jh.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排计划 Jh, 挂号计划时段 Sd
                     Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
              Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
            End If;
          
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排计划 Jh, 挂号计划时段 Sd
                                  Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                           Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                           Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                           Order By Jh.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位计划控制
                  Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        Else
          Select Max(结束时间)
          Into d_加号时间
          From 挂号安排时段
          Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                 '周四', '6', '周五', '7', '周六', Null);
          If r_No.序号控制 = 1 Then
            If Trunc(d_日期) = Trunc(Sysdate) Then
              n_特殊预约 := 0;
            Else
              Select Nvl(Max(Ap.是否预约), 0)
              Into n_特殊预约
              From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                            To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                     'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                     From 挂号安排 Ap, 挂号安排时段 Sd
                     Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                           Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                          '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
              Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
            End If;
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                  Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Order By 序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              If r_Time.剩余数 = 0 Then
                n_单个剩余 := 0;
              Else
                n_单个剩余 := r_Time.限制数量;
              End If;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                    Null;
                  Else
                    Begin
                      Select 1
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                    Exception
                      When Others Then
                        n_是否预留 := 0;
                    End;
                    If n_是否预留 = 0 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + 1;
                    End If;
                  End If;
                End If;
              End If;
            End Loop;
          Else
            n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
            For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                  Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                  Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                  Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                           From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                         To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                  'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                  From 挂号安排 Ap, 挂号安排时段 Sd
                                  Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                        Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                       '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                           Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                 Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                           Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                           Order By Ap.序号) Loop
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              n_单个剩余 := r_Time.剩余数;
              If v_合作单位 Is Null Or n_合约模式 = 1 Then
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                If n_Exists = 0 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                  Else
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                    n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                  End If;
                End If;
              Else
                Begin
                  Select 1
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
                Begin
                  Select 0
                  Into n_非合约
                  From 合作单位安排控制
                  Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                Exception
                  When Others Then
                    n_非合约 := 1;
                End;
                If n_Exists = 1 Or n_非合约 = 1 Then
                  If n_最大可用数量 < n_单个剩余 Then
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  Else
                    v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                    n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                  End If;
                End If;
              End If;
            End Loop;
          End If;
        End If;
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 0
            Into n_非合约
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        Else
          Begin
            Select 0
            Into n_非合约
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_非合约 := 1;
          End;
        End If;
      End If;
      If v_合作单位 Is Null Or n_非合约 = 1 Then
        If r_No.限号数 = 0 Then
          v_剩余数量 := '';
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          Else
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
          End If;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          Select Count(1)
          Into n_预留数量
          From 挂号序号状态
          Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
          If Trunc(d_日期) = Trunc(Sysdate) Then
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
            Else
              v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
            End If;
            n_已挂数 := r_No.已挂数;
            If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
              n_缓冲序号 := 1;
              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' || '<SL>' ||
                            To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
            Else
              n_缓冲序号 := 0;
            End If;
          Else
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
              If v_剩余数量 Is Null Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              End If;
            Else
              v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              If v_剩余数量 Is Null Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
            End If;
            n_已挂数 := r_No.已挂数;
          End If;
        End If;
      Else
        If Nvl(r_No.计划id, 0) <> 0 Then
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位计划控制
          Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        Else
          If v_合作单位 Is Not Null Then
            Begin
              Select 1
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Exception
              When Others Then
                n_合约模式 := 0;
            End;
          Else
            n_合约模式 := 0;
          End If;
          Select Sum(数量)
          Into n_合约总数量
          From 合作单位安排控制
          Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
        End If;
        If n_合约模式 = 0 Then
          v_剩余数量   := n_合约剩余数量;
          n_已挂数     := r_No.已挂数;
          n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
        Else
          n_已挂数 := r_No.已挂数;
          Begin
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
          Exception
            When Others Then
              n_合约已挂数 := 0;
          End;
          If Nvl(n_合约总数量, 0) = 0 Then
            v_剩余数量 := '0';
          Else
            v_剩余数量 := n_合约总数量 - n_合约已挂数;
          End If;
        End If;
      End If;
      Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_Timetemp || '-';
      Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
      v_时间段 := v_时间段 || v_Timetemp;
      If v_Temp Is Not Null Then
        v_Temp := v_Temp || '</SPANLIST>';
      End If;
      If v_合作单位 Is Not Null Then
        If Nvl(r_No.计划id, 0) <> 0 Then
          Begin
            Select 1
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        Else
          Begin
            Select 1
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Exception
            When Others Then
              n_禁用 := 0;
          End;
        End If;
      End If;
      If Nvl(n_禁用, 0) = 0 Then
        --从项金额计算
        n_合计金额 := r_No.价格;
        For r_Subfee In (Select 现价, 从项数次
                         From 收费从属项目 A, 收费价目 B
                         Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                               Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
          n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
        End Loop;
        If Trunc(Sysdate) = Trunc(d_日期) Then
          Begin
            Select 1
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Exception
            When Others Then
              n_Exists := 0;
          End;
        Else
          n_Exists := 1;
        End If;
        If n_Exists = 1 Then
          If v_剩余数量 > 0 Then
            c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                         r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                         '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                         r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                         r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                         '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                         r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                         '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                         '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    If Nvl(n_医生id, 0) <> 0 Then
      --按医生ID过滤号别
      For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                   From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                 Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                          
                          From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                        Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                                '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                 From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                 Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                       d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                  (Select Rownum
                                        From 挂号安排计划 Jh
                                        Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                 Union All
                                 Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                        Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                        Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                                '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                 From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                 Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                       d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                       Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                       Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                  (Select Rownum
                                        From 挂号安排停用状态 Ty
                                        Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                       (Jh.生效时间, Jh.安排id) =
                                       (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                        From 挂号安排计划 Sxjh
                                        Where Sxjh.审核时间 Is Not Null And
                                              d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                              Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                        Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                          Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                        病人挂号汇总 Hz, 收费价目 B
                   Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select Max(结束时间)
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位计划控制
                    Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          Else
            Select Max(结束时间)
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
          
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Order By 序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Begin
                        Select 1
                        Into n_是否预留
                        From 挂号序号状态
                        Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      Exception
                        When Others Then
                          n_是否预留 := 0;
                      End;
                      If n_是否预留 = 0 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                   Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 0 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Begin
                    Select 1
                    Into n_Exists
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If n_Exists = 1 Or n_非合约 = 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    Else
                      v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位计划控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Begin
                Select 1
                Into n_合约模式
                From 合作单位安排控制
                Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
              Exception
                When Others Then
                  n_合约模式 := 0;
              End;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Begin
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Exception
              When Others Then
                n_合约已挂数 := 0;
            End;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 1
              Into n_禁用
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          Else
            Begin
              Select 1
              Into n_禁用
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
            Exception
              When Others Then
                n_禁用 := 0;
            End;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Begin
              Select 1
              Into n_Exists
              From (Select 时间段
                     From 时间段
                     Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                           ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                           Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                   '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
              Where 时间段 = r_No.排班;
            Exception
              When Others Then
                n_Exists := 0;
            End;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                           '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                           r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                           '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
        n_合约剩余数量 := 0;
        n_合约总数量   := 0;
        n_时段数量     := 0;
        n_禁用         := 0;
        n_非合约       := 0;
      End Loop;
      v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                   '</HBLIST>' || '</GROUP>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
    Else
      If Nvl(v_医生姓名, '_') <> '_' Then
        --按医生姓名过滤号别
        For r_No In (Select a.*, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收, b.现价 As 价格
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数



                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5',
                                                  Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Ap.医生姓名 = v_医生姓名 And Ap.停用日期 Is Null And
                                         d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5',
                                                  Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Ap.医生姓名 = v_医生姓名 And
                                         d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                             '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And
                                                d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) > d_日期 And b.执行日期 <= d_日期) Loop
          If r_No.计划id <> 0 Then
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排计划 Jh, 挂号计划时段 Sd
            Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          Else
            Select Sign(Count(Rownum))
            Into n_分时段
            From 挂号安排 Ap, 挂号安排时段 Sd
            Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                  Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                 '7', '周六', Null) And Rownum < 2;
          End If;
          If n_分时段 = 0 Then
            v_Temp := '';
            If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
              If r_No.计划id <> 0 Then
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              Else
                Select Nvl(Sum(数量), 0)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
                Select Count(1)
                Into n_合约模式
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null) And 序号 = 0;
              End If;
              If n_合约模式 = 0 Then
                If r_No.计划id <> 0 Then
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位计划控制
                         Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                Else
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录 A
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                        Exists
                   (Select 1
                         From 合作单位安排控制
                         Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                               限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                             '6', '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
                End If;
              Else
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
              End If;
              If n_合约总数量 = 0 Then
                n_合约剩余数量 := 0;
              Else
                n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                  n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
                End If;
              End If;
            End If;
          Else
            v_Temp := '<SPANLIST>';
            If r_No.计划id <> 0 Then
              Select Max(结束时间)
              Into d_加号时间
              From 挂号计划时段
              Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Jh.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排计划 Jh, 挂号计划时段 Sd
                         Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                  Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                        Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                            To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 ||
                                            '</SL>' || '</SPAN>';
                          n_合约剩余数量 := n_合约剩余数量 + 1;
                        End If;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排计划 Jh, 挂号计划时段 Sd
                                      Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                               Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1
                               Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                               Order By Jh.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位计划控制
                      Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位计划控制
                      Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            Else
              Select Max(结束时间)
              Into d_加号时间
              From 挂号安排时段
              Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null);
            
              If r_No.序号控制 = 1 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_特殊预约 := 0;
                Else
                  Select Nvl(Max(Ap.是否预约), 0)
                  Into n_特殊预约
                  From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                         From 挂号安排 Ap, 挂号安排时段 Sd
                         Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                               Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                              '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                  Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                        Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
                End If;
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                      Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Order By 序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  If r_Time.剩余数 = 0 Then
                    n_单个剩余 := 0;
                  Else
                    n_单个剩余 := r_Time.限制数量;
                  End If;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                        '</SPAN>';
                          n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                        End If;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                        Null;
                      Else
                        Begin
                          Select 1
                          Into n_是否预留
                          From 挂号序号状态
                          Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                        Exception
                          When Others Then
                            n_是否预留 := 0;
                        End;
                        If n_是否预留 = 0 Then
                          v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                            To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 ||
                                            '</SL>' || '</SPAN>';
                          n_合约剩余数量 := n_合约剩余数量 + 1;
                        End If;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
                For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                      Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                      Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                               From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                             To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                      'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                      From 挂号安排 Ap, 挂号安排时段 Sd
                                      Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                            Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                           '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                               Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+) And
                                     Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1
                               Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                               Order By Ap.序号) Loop
                  If v_合作单位 Is Not Null Then
                    Begin
                      Select 1
                      Into n_合约模式
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合约模式 := 0;
                    End;
                  Else
                    n_合约模式 := 0;
                  End If;
                  n_单个剩余 := r_Time.剩余数;
                  If v_合作单位 Is Null Or n_合约模式 = 1 Then
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    If n_Exists = 0 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                      Else
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                      '</SPAN>';
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  Else
                    Begin
                      Select 1
                      Into n_Exists
                      From 合作单位安排控制
                      Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_Exists := 0;
                    End;
                    Begin
                      Select 0
                      Into n_非合约
                      From 合作单位安排控制
                      Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_非合约 := 1;
                    End;
                    If n_Exists = 1 Or n_非合约 = 1 Then
                      If n_最大可用数量 < n_单个剩余 Then
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 ||
                                          '</SL>' || '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      Else
                        v_Temp         := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                          To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                          '</SPAN>';
                        n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 0
                Into n_非合约
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            Else
              Begin
                Select 0
                Into n_非合约
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_非合约 := 1;
              End;
            End If;
          End If;
          If v_合作单位 Is Null Or n_非合约 = 1 Then
            If r_No.限号数 = 0 Then
              v_剩余数量 := '';
            Else
              If Nvl(r_No.计划id, 0) <> 0 Then
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位计划控制
                Where 计划id = r_No.计划id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              Else
                Select Sum(数量)
                Into n_合约总数量
                From 合作单位安排控制
                Where 安排id = r_No.安排id And
                      限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                    '7', '周六', Null);
              End If;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              Select Count(1)
              Into n_预留数量
              From 挂号序号状态
              Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
              If Trunc(d_日期) = Trunc(Sysdate) Then
                If Nvl(n_合约总数量, 0) = 0 Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                Else
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
                n_已挂数 := r_No.已挂数;
                If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                  n_缓冲序号 := 1;
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                                '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
                Else
                  n_缓冲序号 := 0;
                End If;
              Else
                If Nvl(n_合约总数量, 0) = 0 Then
                  v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                  If v_剩余数量 Is Null Then
                    v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                  End If;
                Else
                  v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                  If v_剩余数量 Is Null Then
                    v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                  End If;
                End If;
                n_已挂数 := r_No.已挂数;
              End If;
            End If;
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            Else
              If v_合作单位 Is Not Null Then
                Begin
                  Select 1
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                      '周五', '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Exception
                  When Others Then
                    n_合约模式 := 0;
                End;
              Else
                n_合约模式 := 0;
              End If;
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 合作单位 = v_合作单位;
            End If;
            If n_合约模式 = 0 Then
              v_剩余数量   := n_合约剩余数量;
              n_已挂数     := r_No.已挂数;
              n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
            Else
              n_已挂数 := r_No.已挂数;
              Begin
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              Exception
                When Others Then
                  n_合约已挂数 := 0;
              End;
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := '0';
              Else
                v_剩余数量 := n_合约总数量 - n_合约已挂数;
              End If;
            
            End If;
          End If;
          Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_Timetemp || '-';
          Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
          v_时间段 := v_时间段 || v_Timetemp;
          If v_Temp Is Not Null Then
            v_Temp := v_Temp || '</SPANLIST>';
          End If;
          If v_合作单位 Is Not Null Then
            If Nvl(r_No.计划id, 0) <> 0 Then
              Begin
                Select 1
                Into n_禁用
                From 合作单位计划控制
                Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            Else
              Begin
                Select 1
                Into n_禁用
                From 合作单位安排控制
                Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
              Exception
                When Others Then
                  n_禁用 := 0;
              End;
            End If;
          End If;
          If Nvl(n_禁用, 0) = 0 Then
            --从项金额计算
            n_合计金额 := r_No.价格;
            For r_Subfee In (Select 现价, 从项数次
                             From 收费从属项目 A, 收费价目 B
                             Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                   Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
              n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
            End Loop;
            If Trunc(Sysdate) = Trunc(d_日期) Then
              Begin
                Select 1
                Into n_Exists
                From (Select 时间段
                       From 时间段
                       Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                             Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                     '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
                Where 时间段 = r_No.排班;
              Exception
                When Others Then
                  n_Exists := 0;
              End;
            Else
              n_Exists := 1;
            End If;
            If n_Exists = 1 Then
              If v_剩余数量 > 0 Then
                c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                             r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                             '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                             '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                             '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' ||
                             '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 ||
                             '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
                v_Xmlmain := v_Xmlmain || c_Xmlmain;
              Else
                c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                             r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                             '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' ||
                             '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 ||
                             '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' ||
                             n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                             '</FWMC>' || '</HB>';
                v_Xmlmain := v_Xmlmain || c_Xmlmain;
              End If;
            End If;
          End If;
          n_合约剩余数量 := 0;
          n_合约总数量   := 0;
          n_时段数量     := 0;
          n_禁用         := 0;
          n_非合约       := 0;
        End Loop;
        v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                     '</HBLIST>' || '</GROUP>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/

--87687:刘尔旋,2015-08-24,自定义可预约天数
Create Or Replace Procedure Zl_挂号安排_Insert
(
  Id_In           挂号安排.Id%Type,
  号码_In         挂号安排.号码%Type,
  号类_In         挂号安排.号类%Type,
  科室id_In       挂号安排.科室id%Type,
  项目id_In       挂号安排.项目id%Type,
  医生_In         挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病案必须_In     挂号安排.病案必须%Type,
  周日_In         挂号安排.周日%Type,
  周一_In         挂号安排.周一%Type,
  周二_In         挂号安排.周二%Type,
  周三_In         挂号安排.周三%Type,
  周四_In         挂号安排.周四%Type,
  周五_In         挂号安排.周五%Type,
  周六_In         挂号安排.周六%Type,
  限号控制_In     Varchar2,
  分诊方式_In     挂号安排.分诊方式%Type,
  诊室_In         Varchar2,
  开始时间_In     挂号安排.开始时间%Type,
  终止时间_In     挂号安排.终止时间%Type,
  新增_In         Number,
  序号控制_In     挂号安排.序号控制%Type,
  处理类型_In     Number := 0,
  默认时间间隔_In 挂号安排.默认时段间隔%Type := 0,
  预约天数_In     挂号安排.预约天数%Type := Null
) As
  -----------------------------------------------------------
  --参数：
  --  诊室_IN=以';'号分隔的多个诊室名称
  --  限号控制_IN:|周一,22(限号),13(限约)|周二,20(限号),11(限约)....
  --  处理类型_IN:修改安排时 对时段数据的处理 0--不处理 1--删除时段信息
  --  默认时间间隔_In:为安排设置时段时默认的时间段间隔
  -----------------------------------------------------------
  v_诊室  Varchar2(1000);
  n_Count Number(18);
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_序号       Number(18);
  v_操作员姓名 挂号安排计划.审核人%Type;
  n_限号数     挂号安排限制.限号数%Type;
  n_限约数     挂号安排限制.限约数%Type;
  v_限制项目   挂号安排限制.限制项目%Type;
  v_限制控制   Varchar2(4000);
  v_当前项目   Varchar2(4000);

Begin
  Begin
    If Nvl(医生id_In, 0) <> 0 Then
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生id = 医生id_In And ID + 0 <> Id_In;
    Else
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 挂号安排
      Where 科室id = 科室id_In And 项目id = 项目id_In And 医生姓名 = 医生_In And Nvl(医生id, 0) = 0 And ID + 0 <> Id_In;
    End If;
  Exception
    When Others Then
      n_序号 := 1;
  End;

  If 新增_In = 1 Then
    --新增挂号安排
    Begin
      Select b.姓名 Into v_操作员姓名 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
    Exception
      When Others Then
        Null;
    End;
    Insert Into 挂号安排
      (ID, 号码, 号类, 科室id, 项目id, 医生姓名, 医生id, 序号, 病案必须, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 开始时间, 终止时间, 序号控制, 默认时段间隔, 预约天数)
    Values
      (Id_In, 号码_In, 号类_In, 科室id_In, 项目id_In, 医生_In, Decode(医生id_In, 0, Null, 医生id_In), n_序号, 病案必须_In, 周日_In, 周一_In,
       周二_In, 周三_In, 周四_In, 周五_In, 周六_In, 分诊方式_In, 开始时间_In, 终止时间_In, 序号控制_In, 默认时间间隔_In, 预约天数_In);
    For r_合作单位 In (Select 名称 From 挂号合作单位) Loop
      Insert Into 合作单位安排控制
        (合作单位, 安排id, 限制项目, 序号, 数量)
        Select r_合作单位.名称, Id_In, '周日', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周一', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周二', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周三', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周四', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周五', 0, 0
        From Dual
        Union
        Select r_合作单位.名称, Id_In, '周六', 0, 0 From Dual;
    End Loop;
  
  Else
    --修改指定ID的挂号安排
    --1.先检查是否存在计划,存在计划，不能更改
    Begin
      Select Count(*) Into n_Count From 挂号安排计划 Where 安排id = Id_In;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '[ZLSOFT]该安排已经制定了相关的计划,,不能再修改![ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Nvl(处理类型_In, 0) = 1 Then
      Delete 挂号安排时段 Where 安排id = Id_In;
    Else
      --针对存在时段这种情况需要先处理排班修改后的时段 在后再修改安排
      Delete 挂号安排时段
      Where 安排id = Id_In And 星期 In (Select 星期
                                    From (Select Case 周一
                                                     When 周一_In Then
                                                      Null
                                                     Else
                                                      '周一'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周二
                                                     When 周二_In Then
                                                      Null
                                                     Else
                                                      '周二'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周三
                                                     When 周三_In Then
                                                      Null
                                                     Else
                                                      '周三'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周四
                                                     When 周四_In Then
                                                      Null
                                                     Else
                                                      '周四'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周五
                                                     When 周五_In Then
                                                      Null
                                                     Else
                                                      '周五'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周六
                                                     When 周六_In Then
                                                      Null
                                                     Else
                                                      '周六'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In
                                           Union All
                                           Select Case 周日
                                                     When 周日_In Then
                                                      Null
                                                     Else
                                                      '周日'
                                                   End As 星期
                                           From 挂号安排
                                           Where ID = Id_In) A
                                    Where a.星期 Is Not Null);
    End If;
  
    Update 挂号安排
    Set 号码 = 号码_In, 号类 = 号类_In, 科室id = 科室id_In, 项目id = 项目id_In, 医生姓名 = 医生_In, 医生id = Decode(医生id_In, 0, Null, 医生id_In),
        序号 = n_序号, 病案必须 = 病案必须_In, 周日 = 周日_In, 周一 = 周一_In, 周二 = 周二_In, 周三 = 周三_In, 周四 = 周四_In, 周五 = 周五_In, 周六 = 周六_In,
        开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 分诊方式 = 分诊方式_In, 序号控制 = 序号控制_In,
        默认时段间隔 = Decode(Nvl(默认时间间隔_In, 0), 0, 默认时段间隔, 默认时间间隔_In), 预约天数 = 预约天数_In
    Where ID = Id_In;
  
    Delete 挂号安排限制 Where 安排id = Id_In;
  End If;

  v_限制控制 := 限号控制_In || '|';
  While v_限制控制 Is Not Null Loop
    v_当前项目 := Substr(v_限制控制, 1, Instr(v_限制控制, '|') - 1);
    v_限制项目 := Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1);
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_限号数   := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    n_限约数   := To_Number(Substr(v_当前项目, Instr(v_当前项目, ',') + 1));
    Insert Into 挂号安排限制
      (安排id, 限制项目, 限号数, 限约数)
    Values
      (Id_In, v_限制项目, Decode(n_限号数, 0, Null, n_限号数), n_限约数);
    v_限制控制 := Substr(v_限制控制, Instr(v_限制控制, '|') + 1);
  End Loop;

  If 新增_In = 0 Then
    --挂号安排诊室处理
    Delete From 挂号安排诊室 Where 号表id = Id_In;
  End If;

  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ';';
    While v_诊室 Is Not Null Loop
      Insert Into 挂号安排诊室 (号表id, 门诊诊室) Values (Id_In, Substr(v_诊室, 1, Instr(v_诊室, ';') - 1));
      v_诊室 := Substr(v_诊室, Instr(v_诊室, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Insert;
/

--87640:冉俊明,2015-08-21,票据重打后，重新发出票据的使用原因为正常发出，应为重打发出。
Create Or Replace Procedure Zl_Invoice_Autoallot
(
  操作类型_In   Number,
  模拟计算_In   Number,
  票种_In       票据使用明细.票种%Type,
  领用id_In     票据使用明细.领用id%Type,
  病人id_In     门诊费用记录.病人id%Type,
  Nos_In        Varchar2,
  起始发票号_In 门诊费用记录.实际票号%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  发票号_In     In Out Varchar2,
  发票张数_In   Out Number
) As
  ---------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多;有400张单据,格式为:A00001,A00002.....
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     发票号_In   :可以为多个,当操作类型为3-重打票据时,有效
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --出参:
  --     发票张数_IN :返回本次收费所需要的发票张数
  ---------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  v_Para       Varchar2(1000);
  v_Temp       Varchar2(4000);
  n_启用模式   Number(3);
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  ---------------------------------------------------------
  Type Ty_Rec_Splitno Is Record(
    元素1    票据打印明细.No%Type,
    元素2集  Varchar2(4000),
    元素3集  Varchar2(4000),
    关联序号 Number(18));

  Type Ty_Tb_Splitno Is Table Of Ty_Rec_Splitno;
  c_Split_No   Ty_Tb_Splitno := Ty_Tb_Splitno();
  c_Split_费目 Ty_Tb_Splitno := Ty_Tb_Splitno();

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  --------------------------------------------------------------------------------------------
  --根据相关传入的数据,取对应的数据集

  v_Nos        Varchar2(4000);
  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_当前发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1    门诊费用记录.No%Type;
  n_元素2    门诊费用记录.执行部门id%Type;
  v_元素3    门诊费用记录.收据费目%Type;
  n_元素4    门诊费用记录.收费细目id%Type;
  v_发票信息 Varchar2(4000);
  n_误差项   Number(1);
  n_打印id   票据使用明细.打印id%Type;
  n_使用id   票据使用明细.Id%Type;
  n_返回数   Number(18);
  n_关联序号 Number(18);
  r_单据号   t_Strlist := t_Strlist();
  r_单据序号 t_Strlist := t_Strlist();
  l_使用id   t_Numlist := t_Numlist();
  l_关联序号 t_Numlist := t_Numlist();

  v_打印内容   Varchar2(4000);
  l_元素2      t_Numlist := t_Numlist();
  l_元素3      t_Strlist := t_Strlist();
  v_起始发票号 票据领用记录.开始号码%Type;
  -------------------------------------------------------------------------------------------------------------------
  --Invoice_Split_Notgroup:不进行分组汇总或首页汇总时调用此过程
  Procedure Invoice_Split_Notgroup
  (
    收费nos_In       Varchar2,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号 
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- 本次退费单据_Out-退费回收所涉及的NO号,多个用逗号分离
  
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量 
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select NO, 序号 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J Where m.票号 = j.Column_Value) B
          Where MOD(记录性质,10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
          Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          c_Invoce.Extend;
          c_Invoce(c_Invoce.Count).票号 := v_发票号;
          c_Invoce(c_Invoce.Count).No := c_No(I).No;
          c_Invoce(c_Invoce.Count).序号 := Case
                                           When Instr(c_No(I).序号, ',') > 0 Then
                                            Substr(c_No(I).序号, 2)
                                           Else
                                            c_No(I).序号
                                         End;
          c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        c_Invoce.Extend;
        c_Invoce(c_Invoce.Count).票号 := v_发票号;
        c_Invoce(c_Invoce.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        c_Invoce(c_Invoce.Count).序号 := c_No(I).序号;
        c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;
  --结束:不进行分组汇总或首页汇总时调用此过程
  -------------------------------------------------------------------------------------------------------------------
  --按组汇总
  Procedure Invoice_Split_Group
  (
    收费nos_In       Varchar2,
    回收发票_In      Varchar2,
    本次打印发票_Out Out Varchar2,
    本次发票张数_Out Out Number
  ) As
  Begin
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
  
    c_No.Delete;
    l_元素2.Delete;
  
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --******************************************************************************************************************************
      --退费和重打按发票号处理(开始)  
      --4.收据费目+收费细目
      If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        v_元素3 := '+';
        c_Split_费目.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where MOD(记录性质,10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素3, Count(*) As 个数
                       From c_费用 A
                       Group By 元素3
                       Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
        n_关联序号 := 0;
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where MOD(记录性质,10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                         From c_费用 M
                         Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                         Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                         Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
              n_元素4_Count := 0;
              --分页
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
        n_元素2_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        c_Split_No.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A,
                             (Select NO, 序号
                               From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                               Where m.票号 = j.Column_Value) B
                        Where MOD(记录性质,10) = 1 And a.No = b.No And
                              Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                             
                              Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素1, a.元素2, b.编码, Count(*) As 个数
                       From c_费用 A, 部门表 B
                       Where a.元素2 = b.Id(+)
                       Group By 元素1, b.编码, 元素2
                       Order By 元素1, b.编码, 元素2) Loop
          If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
            c_Split_No.Extend;
            n_元素2_Count := 0;
            v_元素1       := '+';
            n_元素2       := 0;
          End If;
          If (v_元素1 <> c_分页.元素1) Then
            v_元素1 := c_分页.元素1;
            c_Split_No(c_Split_No.Count).元素1 := v_元素1;
          End If;
          If (n_元素2 <> c_分页.元素2) Then
            n_元素2_Count := n_元素2_Count + 1;
            n_元素2 := c_分页.元素2;
            c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
          End If;
        End Loop;
      End If;
    
      --6.(no Or 执行科室)+收费细目
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
      
        For I In 1 .. c_Split_No.Count Loop
          v_元素3 := '+';
          --只有首页汇总的,才有关联序号
          n_关联序号    := n_关联序号 + 1;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where MOD(记录性质,10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                         Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
            If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
          
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_元素4_Count;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --7.(no Or 执行科室)+收据费目+收费细目
      n_关联序号 := 0;
      If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
        c_Split_费目.Delete;
        For I In 1 .. c_Split_No.Count Loop
        
          n_关联序号    := n_关联序号 + 1;
          v_元素3       := '+';
          n_元素3_Count := 0;
          l_元素3.Delete;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where MOD(记录性质,10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          a.元素3, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_No(I).元素1 And
                               Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                         Group By 元素3
                         Order By 元素3) Loop
          
            If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
              If v_元素3 <> '+' Then
                c_Split_费目.Extend;
                c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
                c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
                c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
                For J In 1 .. l_元素3.Count Loop
                  --单据号相同,将序号合并
                  c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
                End Loop;
              End If;
              v_元素3       := '+';
              n_元素3_Count := 0;
              l_元素3.Delete;
            End If;
            If (v_元素3 <> c_分页.元素3) Then
              n_元素3_Count := n_元素3_Count + 1;
              v_元素3       := c_分页.元素3;
              l_元素3.Extend;
              l_元素3(l_元素3.Count) := v_元素3;
            End If;
          End Loop;
        
          If l_元素3.Count <> 0 Then
            c_Split_费目.Extend;
            c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
            c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
            c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
          End If;
        End Loop;
      
        For I In 1 .. c_Split_费目.Count Loop
          c_No.Delete;
          n_元素4_Count := 0;
          For c_分页 In (With c_费用 As
                          (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                          From 门诊费用记录 A,
                               (Select NO, 序号
                                 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J
                                 Where m.票号 = j.Column_Value) B
                          Where MOD(记录性质,10) = 1 And a.No = b.No And
                                Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                               
                                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                          Having Sum(Nvl(a.实收金额, 0)) <> 0)
                         Select /*+ RULE */
                          元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                         From c_费用 A
                         Where a.元素1 = c_Split_费目(I).元素1 And
                               Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                               Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                         Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                         Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
            If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
              --分配单据
              If c_No.Count <> 0 Then
                --分页:计算发票号及相关的
                For J In 1 .. c_No.Count Loop
                  c_Invoce.Extend;
                  c_Invoce(c_Invoce.Count).票号 := v_发票号;
                  c_Invoce(c_Invoce.Count).No := c_No(J).No;
                  c_Invoce(c_Invoce.Count).序号 := Case
                                                   When Instr(c_No(J).序号, ',') > 0 Then
                                                    Substr(c_No(J).序号, 2)
                                                   Else
                                                    c_No(J).序号
                                                 End;
                  c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
                End Loop;
                本次发票张数_Out := 本次发票张数_Out + 1;
                本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
                v_发票号         := Zl_Incstr(v_发票号);
                c_No.Delete;
              End If;
              n_元素4_Count := 0;
            End If;
            n_元素4_Count := n_元素4_Count + 1;
            -------------------------------------------
            --分配单据号及序号
            n_Find := 0;
            For J In 1 .. c_No.Count Loop
              If c_No(J).No = c_分页.单据 Then
                --单据号相同,将序号合并
                c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
                n_Find := 1;
                Exit;
              End If;
            End Loop;
            If n_Find = 0 Then
              c_No.Extend;
              c_No(c_No.Count).No := c_分页.单据;
              c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
            End If;
          End Loop;
        
          --分配单据
          If c_No.Count <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
          End If;
        End Loop;
      End If;
    
      --退费和重打按发票号处理(结束)
      --******************************************************************************************************************************
      If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
        本次打印发票_Out := Substr(本次打印发票_Out, 2);
      End If;
      Return;
    
    End If;
  
    --******************************************************************************************************************************
    --以下是按正常分配单据(开始)
    --4.收据费目+收费细目
    If n_分单据打印 = 0 And n_执行科室 = 0 And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      v_元素3 := '+';
      c_Split_费目.Delete;
    
      For c_分页 In (With c_费用 As
                      (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                             Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                             Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                      Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.实收金额, 0)) <> 0)
                     Select /*+ RULE */
                      a.元素3, Count(*) As 个数
                     From c_费用 A
                     Group By 元素3
                     Order By 元素3) Loop
        If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
          If v_元素3 <> '+' Then
            c_Split_费目.Extend;
            For J In 1 .. l_元素3.Count Loop
              --单据号相同,将序号合并
              c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
            End Loop;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
        End If;
        If (v_元素3 <> c_分页.元素3) Then
          n_元素3_Count := n_元素3_Count + 1;
          v_元素3       := c_分页.元素3;
          l_元素3.Extend;
          l_元素3(l_元素3.Count) := v_元素3;
        End If;
      End Loop;
      If l_元素3.Count <> 0 Then
        c_Split_费目.Extend;
        For J In 1 .. l_元素3.Count Loop
          --单据号相同,将序号合并
          c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
        End Loop;
      End If;
      n_关联序号 := 0;
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_关联序号    := n_关联序号 + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                        Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        m.元素1, 元素2, 元素3, m.元素4, m.单据, m.序号, Count(*) As 个数
                       From c_费用 M
                       Where Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || m.元素3 || ',') > 0
                       Group By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号
                       Order By m.元素1, 元素2, m.元素4, 元素3, m.单据, m.序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分页:计算发票号及相关的
            For J In 1 .. c_No.Count Loop
              c_Invoce.Extend;
              c_Invoce(c_Invoce.Count).票号 := v_发票号;
              c_Invoce(c_Invoce.Count).No := c_No(J).No;
              c_Invoce(c_Invoce.Count).序号 := Case
                                               When Instr(c_No(J).序号, ',') > 0 Then
                                                Substr(c_No(J).序号, 2)
                                               Else
                                                c_No(J).序号
                                             End;
              c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
            End Loop;
            本次发票张数_Out := 本次发票张数_Out + 1;
            本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
            v_发票号         := Zl_Incstr(v_发票号);
            c_No.Delete;
            n_元素4_Count := 0;
            --分页
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    If (n_分单据打印 = 1 Or n_执行科室 > 0) And (n_收据费目 <> 0 Or n_收费细目 <> 0) Then
      n_元素2_Count := 0;
      v_元素1       := '+';
      n_元素2       := 0;
      c_Split_No.Delete;
      For c_分页 In (With c_费用 As
                      (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                             Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                             Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                      From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                      Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                      Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                      Having Sum(Nvl(a.实收金额, 0)) <> 0)
                     Select /*+ RULE */
                      a.元素1, a.元素2, b.编码, Count(*) As 个数
                     From c_费用 A, 部门表 B
                     Where a.元素2 = b.Id(+)
                     Group By 元素1, b.编码, 元素2
                     Order By 元素1, b.编码, 元素2) Loop
        If (v_元素1 <> c_分页.元素1) Or (n_元素2 <> c_分页.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Then
          c_Split_No.Extend;
          n_元素2_Count := 0;
          v_元素1       := '+';
          n_元素2       := 0;
        End If;
        If (v_元素1 <> c_分页.元素1) Then
          v_元素1 := c_分页.元素1;
          c_Split_No(c_Split_No.Count).元素1 := v_元素1;
        End If;
        If (n_元素2 <> c_分页.元素2) Then
          n_元素2_Count := n_元素2_Count + 1;
          n_元素2 := c_分页.元素2;
          c_Split_No(c_Split_No.Count).元素2集 := c_Split_No(c_Split_No.Count).元素2集 || ',' || n_元素2;
        End If;
      End Loop;
    End If;
  
    --3.(no Or 执行科室)+收费细目
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 = 0 And n_收费细目 <> 0 Then
    
      For I In 1 .. c_Split_No.Count Loop
        v_元素3 := '+';
        --只有首页汇总的,才有关联序号
        n_关联序号    := Nvl(n_关联序号, 0) + 1;
        n_元素4_Count := 0;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                        Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, 单据, a.序号
                       Order By 元素1, 元素2, 元素4, 单据, 序号) Loop
          If n_元素4_Count >= n_收费细目 And n_收费细目 <> 0 Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
        
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := n_关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
  
    --7.(no Or 执行科室)+收据费目+收费细目
    n_关联序号 := 0;
    If (n_分单据打印 = 0 Or n_执行科室 > 0) And n_收据费目 <> 0 And n_收费细目 <> 0 Then
      c_Split_费目.Delete;
    
      For I In 1 .. c_Split_No.Count Loop
        
        n_关联序号    := n_关联序号 + 1;
        v_元素3       := '+';
        n_元素3_Count := 0;
        l_元素3.Delete;
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                        Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        a.元素3, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_No(I).元素1 And
                             Instr(',' || c_Split_No(I).元素2集 || ',', ',' || a.元素2 || ',') > 0
                       Group By 元素3
                       Order By 元素3) Loop
          If (v_元素3 <> c_分页.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Then
            If v_元素3 <> '+' Then
              c_Split_费目.Extend;
              c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
              c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
              c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
              For J In 1 .. l_元素3.Count Loop
                --单据号相同,将序号合并
                c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
              End Loop;
            End If;
            v_元素3       := '+';
            n_元素3_Count := 0;
            l_元素3.Delete;
          End If;
          If (v_元素3 <> c_分页.元素3) Then
            n_元素3_Count := n_元素3_Count + 1;
            v_元素3       := c_分页.元素3;
            l_元素3.Extend;
            l_元素3(l_元素3.Count) := v_元素3;
          End If;
        End Loop;
      
        If l_元素3.Count <> 0 Then
          c_Split_费目.Extend;
          c_Split_费目(c_Split_费目.Count).元素1 := c_Split_No(I).元素1;
          c_Split_费目(c_Split_费目.Count).元素2集 := c_Split_No(I).元素2集;
          c_Split_费目(c_Split_费目.Count).关联序号 := n_关联序号;
          For J In 1 .. l_元素3.Count Loop
            --单据号相同,将序号合并
            c_Split_费目(c_Split_费目.Count).元素3集 := c_Split_费目(c_Split_费目.Count).元素3集 || ',' || l_元素3(J);
          End Loop;
        End If;
      End Loop;
    
      For I In 1 .. c_Split_费目.Count Loop
        c_No.Delete;
        n_元素4_Count := 0;
        --收费细目,按条数计数,还是要按执行科室+收据费目
        For c_分页 In (With c_费用 As
                        (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                               Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, 0, a.收费细目id) As 元素4, a.No As 单据,
                               Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
                        From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
                        Where MOD(记录性质,10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
                        Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
                        Having Sum(Nvl(a.实收金额, 0)) <> 0)
                       Select /*+ RULE */
                        元素1, 元素2, 元素3, a.元素4, a.单据, a.序号, Count(*) As 个数
                       From c_费用 A
                       Where a.元素1 = c_Split_费目(I).元素1 And
                             Instr(',' || c_Split_费目(I).元素2集 || ',', ',' || a.元素2 || ',') > 0 And
                             Instr(',' || c_Split_费目(I).元素3集 || ',', ',' || a.元素3 || ',') > 0
                       Group By 元素1, 元素2, 元素4, 元素3, a.单据, a.序号
                       Order By 元素1, 元素2, 元素4, 元素3, 单据, 序号) Loop
          If (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
            --分配单据
            If c_No.Count <> 0 Then
              --分页:计算发票号及相关的
              For J In 1 .. c_No.Count Loop
                c_Invoce.Extend;
                c_Invoce(c_Invoce.Count).票号 := v_发票号;
                c_Invoce(c_Invoce.Count).No := c_No(J).No;
                c_Invoce(c_Invoce.Count).序号 := Case
                                                 When Instr(c_No(J).序号, ',') > 0 Then
                                                  Substr(c_No(J).序号, 2)
                                                 Else
                                                  c_No(J).序号
                                               End;
                c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
              End Loop;
              本次发票张数_Out := 本次发票张数_Out + 1;
              本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
              v_发票号         := Zl_Incstr(v_发票号);
              c_No.Delete;
            End If;
            n_元素4_Count := 0;
          End If;
          n_元素4_Count := n_元素4_Count + 1;
          -------------------------------------------
          --分配单据号及序号
          n_Find := 0;
          For J In 1 .. c_No.Count Loop
            If c_No(J).No = c_分页.单据 Then
              --单据号相同,将序号合并
              c_No(J).序号 := c_No(J).序号 || ',' || c_分页.序号;
              n_Find := 1;
              Exit;
            End If;
          End Loop;
          If n_Find = 0 Then
            c_No.Extend;
            c_No(c_No.Count).No := c_分页.单据;
            c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_分页.序号;
          End If;
        End Loop;
        --分配单据
        If c_No.Count <> 0 Then
          --分页:计算发票号及相关的
          For J In 1 .. c_No.Count Loop
            c_Invoce.Extend;
            c_Invoce(c_Invoce.Count).票号 := v_发票号;
            c_Invoce(c_Invoce.Count).No := c_No(J).No;
            c_Invoce(c_Invoce.Count).序号 := Case
                                             When Instr(c_No(J).序号, ',') > 0 Then
                                              Substr(c_No(J).序号, 2)
                                             Else
                                              c_No(J).序号
                                           End;
            c_Invoce(c_Invoce.Count).关联序号 := c_Split_费目(I).关联序号;
          End Loop;
          本次发票张数_Out := 本次发票张数_Out + 1;
          本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
          v_发票号         := Zl_Incstr(v_发票号);
          c_No.Delete;
        End If;
      End Loop;
    End If;
    --正常分配单据结束
    --******************************************************************************************************************************
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Group;
  -------------------------------------------------------------------------------------------------------------------
Begin

  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  If Instr(v_Para, '||') = 0 Then
    v_Para := v_Para || '||';
  End If;
  v_Temp := Substr(v_Para, 1, Instr(v_Para, '||') - 1);
  If v_Temp Is Null Then
    --无设置值,代表无启用,直接返回
    Return;
  End If;

  --0-根据实际打印分配票号;1-根据预定规则分配票号;2-.根据自定义规则分配票号
  n_启用模式 := Zl_To_Number(v_Temp);
  If Nvl(n_启用模式, 0) = 0 Then
    --0-根据实际打印分配票号:按原来的处理方式分配票据,直接退出
    Return;
  End If;
  v_Temp       := Nvl(zl_GetSysParameter('误差项不使用票据', 1121), '0');
  n_误差项     := Zl_To_Number(v_Temp);
  v_起始发票号 := 起始发票号_In;

  If v_起始发票号 Is Null Then
    --模拟计算时,可以不传入起始发票号
    If Nvl(领用id_In, 0) <> 0 Then
      Open c_Fact;
      Fetch c_Fact
        Into r_Factrow;
    
      If c_Fact%RowCount <> 0 Then
        If Nvl(r_Factrow.当前号码, '-') <> '-' Then
          v_起始发票号 := Zl_Incstr(r_Factrow.当前号码);
        Else
          v_起始发票号 := r_Factrow.开始号码;
        End If;
      End If;
    End If;
    If v_起始发票号 Is Null Then
      v_起始发票号 := 'J0000001';
    End If;
  End If;
  
  v_发票号   := v_起始发票号;
  v_发票信息 := Null;

  --按单据分配票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
    If 发票号_In Is Null Then
      v_Err_Msg := '未传入指定的回收票据,不允许' || Case
                     When 操作类型_In = 1 Then
                      '重打票据。'
                     Else
                      '补打票据。'
                   End;
      Raise Err_Item;
    End If;
  
    --读取当前票据所涉及的所有票据
    v_Nos := Null;
    For c_票据 In (Select Distinct c.No As 单据号
                 From 票据打印明细 A, 票据使用明细 B, 票据打印内容 C, Table(f_Str2list(发票号_In)) J
                 Where a.使用id = b.Id And b.打印id = c.Id And a.票号 = j.Column_Value
                 Order By 单据号) Loop
      v_Nos := Nvl(v_Nos, '') || ',' || c_票据.单据号;
    End Loop;
  
    If v_Nos Is Null Then
      v_Err_Msg := '未找到指定发票(' || 发票号_In || '所对应的收费单据!';
      Raise Err_Item;
    End If;
    v_Nos := Substr(v_Nos, 2);
  Else
    v_Nos := Nos_In;
  End If;

  If n_启用模式 = 2 Then
    --根据自定义规则分配票号,调用:Zl_Custom_Invoice_Autoallot过程
    Zl_Custom_Invoice_Autoallot(操作类型_In, 模拟计算_In, 票种_In, 领用id_In, 病人id_In, v_Nos, 起始发票号_In, 使用人_In, 使用时间_In, 发票号_In,
                                发票张数_In);
    Return;
  End If;

  --参数获取:
  --1.根据预定规则分配票号
  --   NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para := Substr(v_Para, Instr(v_Para, '||') + 2);
  If Instr(v_Para, ';') > 0 Then
    --NO:票据是否按单据进行分别打印,1表示按单据打印;0-不按单据打印
    v_Temp       := Substr(v_Para, 1, Instr(v_Para, ';') - 1);
    n_分单据打印 := Zl_To_Number(v_Temp);
    v_Para       := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_执行科室 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收据费目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --收据费目
    v_Temp     := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
    n_收费细目 := Zl_To_Number(v_Temp);
    v_Para     := Substr(v_Para, Instr(v_Para, ';') + 1);
  End If;

  If Instr(v_Para, ';') > 0 Then
    --执行科室
    v_Temp := Nvl(Substr(v_Para, 1, Instr(v_Para, ';') - 1), '0');
  Else
    v_Temp := Nvl(v_Para, '0');
  End If;
  n_汇总条件 := Zl_To_Number(v_Temp);

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --一、首页汇总或不汇总
  If n_汇总条件 <> 2 Then
    Invoice_Split_Notgroup(Nos_In, 发票号_In, v_发票信息, 发票张数_In);
  Else
    --二、分组汇总
    Invoice_Split_Group(Nos_In, 发票号_In, v_发票信息, 发票张数_In);
  End If;
  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;

  v_开始发票号 := Null;
  v_当前发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无数据,直接返回
    Return;
  End If;

  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    End If;
  End If;
  --实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息)) Order By 发票号) Loop
    --检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(c_Invoce_No.发票号) >= Upper(r_Factrow.开始号码) And Upper(c_Invoce_No.发票号) <= Upper(r_Factrow.终止号码) And
          Length(c_Invoce_No.发票号) = Length(r_Factrow.终止号码)) Then
        v_Err_Msg := '该单据需要打印多张票据,但票据号"' || c_Invoce_No.发票号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Item;
      End If;
    End If;
  
    --处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 1, r_单据号(I));
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where MOD(记录性质,10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO)
          Select n_打印id, 1, Column_Value From Table(f_Str2list(v_Nos));
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where MOD(记录性质,10) = 1 And NO In (Select Column_Value From Table(f_Str2list(v_Nos)));
      End If;
    End If;
  
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1), Decode(Nvl(领用id_In, 0), 0, Null, 领用id_In), n_打印id, 使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    v_当前发票号 := c_Invoce_No.发票号;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
  
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前发票号, 剩余数量 = Nvl(剩余数量, 0) - 发票张数_In
    Where ID = 领用id_In
    Returning 剩余数量 Into n_返回数;
    If n_返回数 < 0 Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Raise Err_Item;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Invoice_Autoallot;
/

--87640:冉俊明,2015-08-21,票据重打后，重新发出票据的使用原因为正常发出，应为重打发出。
Create Or Replace Procedure Zl_Custom_Invoice_Autoallot
(
  操作类型_In   Number,
  模拟计算_In   Number,
  票种_In       票据使用明细.票种%Type,
  领用id_In     票据使用明细.领用id%Type,
  病人id_In     门诊费用记录.病人id%Type,
  Nos_In        Varchar2,
  起始发票号_In 门诊费用记录.实际票号%Type,
  使用人_In     票据使用明细.使用人%Type,
  使用时间_In   票据使用明细.使用时间%Type,
  发票号_In     In Out Varchar2,
  发票张数_In   Out Number
) As
  -------------------------------------------------------------------------------------------------------------
  --功能：根据票据分配规则,自动分配票据明细数据
  --入参：
  --     操作类型_In :1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  --     模拟计算_IN :0-不进行模拟计算;1-进行模拟计算,模拟计算时不保存数据
  --     票种_IN     :1-门诊收费;暂无其他类型票据
  --     病人ID_IN   :病人ID,如果Nos和发票号_In为空时,表示针对该病人的所有未打印的票据进行打印
  --     NOs_IN      :单据号,多个用逗号分离,最多有400张单据,格式为:A00001,A00002.....
  --     退费NOs:退费所涉及的单据
  --     启始发票号_IN:重打票据或发出票据的启始票号;
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示本次需要回收的票据
  --出参:
  --     发票号_In   :可以为多个,用逗号分隔,当操作类型为3-重打票据时和4-退费回收票据有效,表示重打或退费重新发出的票据
  --     发票张数_IN :返回本次收费所需要的发票张数
  -------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_分单据打印 Number(3);
  n_执行科室   Number(3);
  n_收据费目   Number(3);
  n_汇总条件   Number(3);
  n_收费细目   Number(3);

  --------------------------------------------------------
  --定义内部票据处理的数据集
  Type Ty_Rec_Bill Is Record(
    票号     票据打印明细.票号%Type,
    NO       票据打印明细.No%Type,
    序号     票据打印明细.序号%Type,
    关联序号 票据打印明细.关联票号序号%Type,
    修改标志 Number(1));
  Type Ty_Tb_Bill Is Table Of Ty_Rec_Bill;
  c_Invoce Ty_Tb_Bill := Ty_Tb_Bill();
  --------------------------------------------------------
  --按元素1,元素2,元素3,元素4,分别统计各单据的序号
  Type Ty_Rec_No Is Record(
    NO   门诊费用记录.No%Type,
    序号 Varchar2(1000));
  Type Ty_Tb_No Is Table Of Ty_Rec_No;
  c_No Ty_Tb_No := Ty_Tb_No();
  --------------------------------------------------------
  Cursor c_Fact Is
    Select 前缀文本, 剩余数量, 开始号码, 终止号码, 当前号码 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
  r_Factrow c_Fact%RowType;

  v_Nos        Varchar2(4000);
  v_发票号     票据打印明细.票号%Type;
  v_开始发票号 票据打印明细.票号%Type;
  v_当前发票号 票据打印明细.票号%Type;
  v_回收票据号 Varchar2(4000);
  n_Find       Number(3);

  n_元素1_Count Number(3);
  n_元素2_Count Number(3);
  n_元素3_Count Number(3);
  n_元素4_Count Number(3);

  v_元素1    门诊费用记录.No%Type;
  n_元素2    门诊费用记录.执行部门id%Type;
  v_元素3    门诊费用记录.收据费目%Type;
  n_元素4    门诊费用记录.收费细目id%Type;
  v_发票信息 Varchar2(4000);
  n_误差项   Number(1);
  n_打印id   票据使用明细.打印id%Type;
  n_使用id   票据使用明细.Id%Type;
  n_返回数   Number(18);
  n_关联序号 Number(18);
  r_单据号   t_Strlist := t_Strlist();
  r_单据序号 t_Strlist := t_Strlist();
  l_使用id   t_Numlist := t_Numlist();
  l_关联序号 t_Numlist := t_Numlist();

  v_打印内容 Varchar2(4000);
  v_Temp     Varchar2(4000);
  Procedure Invoice_Split_Notgroup
  (
    收费nos_In       Varchar2,
    回收发票_In      Varchar2,
    本次打印发票_Out In Out Varchar2,
    本次发票张数_Out In Out Number,
    Invoce_Out       In Out Ty_Tb_Bill
  ) As
    ----------------------------------------------------------------------------
    --入参:
    --   收费收费NOs_IN:本次需要处理的发票所涉及的单据,多个用逗号分离
    --   回收发票_IN-退费时有效,多个用逗号分离，表示本次需要回收的发票号 
    --出参:
    -- 本次打印发票_Out-本次需要的发票号,多个用逗号分离
    -- 本次发票张数_Out-本次需要的发票数
    -- Invoce_Out:本次返回的发票号与单据的对应关系
    n_Count Number(18);
    n_分页  Number(18);
  
    Cursor Cr_Bill Is
      Select NO As 元素1, 执行部门id As 元素2, 收据费目 As 元素3, NO As 元素4, NO As 单据, 序号, 0 As 个数
      From 门诊费用记录
      Where Rownum <= 1;
    c_Bill Cr_Bill%RowType;
    --------------------------------------------------------------------------------------------
    --根据相关传入的数据,取对应的数据集
    Type Ty_费用明细 Is Ref Cursor;
    c_费用明细 Ty_费用明细; --游标变量 
  
  Begin
    --按单据分配票据
    If 操作类型_In = 3 Or 操作类型_In = 4 Then
      --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A,
               (Select NO, 序号 From 票据打印明细 M, Table(f_Str2list(回收发票_In)) J Where m.票号 = j.Column_Value) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.No And Instr(',' || b.序号 || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 And
                Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    Else
      Open c_费用明细 For
        With c_费用 As
         (Select Decode(n_分单据打印, 0, '-', a.No) As 元素1, Decode(n_执行科室, 0, 0, a.执行部门id) As 元素2,
                 Decode(n_收据费目, 0, '-', a.收据费目) As 元素3, Decode(n_收费细目, 0, '-', a.No) As 元素4, a.No As 单据,
                 Nvl(a.价格父号, a.序号) As 序号, Sum(Nvl(a.实收金额, 0)) As 实收金额
          From 门诊费用记录 A, Table(f_Str2list(收费nos_In)) B
          Where Mod(a.记录性质, 10) = 1 And a.No = b.Column_Value And Decode(n_误差项, 1, Nvl(a.附加标志, 0), 0) <> 9
          Group By a.No, a.执行部门id, a.收据费目, a.收费细目id, Nvl(a.价格父号, a.序号)
          Having Sum(Nvl(a.实收金额, 0)) <> 0)
        Select 元素1, 元素2, 元素3, 元素4, 单据, 序号, Count(*) As 个数
        From c_费用
        Group By 元素1, 元素2, 元素3, 元素4, 单据, 序号
        Order By 元素1, 元素2, 元素3, 元素4, 单据, 序号;
    End If;
  
    v_元素1          := '+';
    n_元素2          := 0;
    v_元素3          := '+';
    n_元素4          := 0;
    n_元素1_Count    := 0;
    n_元素2_Count    := 0;
    n_元素3_Count    := 0;
    n_元素4_Count    := 0;
    本次发票张数_Out := 0;
    If n_汇总条件 <> 0 Then
      n_关联序号 := 1;
    Else
      n_关联序号 := 0;
    End If;
    n_Count := 0;
    c_No.Delete;
    Loop
      Fetch c_费用明细
        Into c_Bill;
      Exit When c_费用明细%NotFound;
      n_Count := 1;
    
      n_分页 := 0;
      If (v_元素1 <> c_Bill.元素1) Or (n_元素2 <> c_Bill.元素2 And n_元素2_Count >= n_执行科室 And n_执行科室 <> 0) Or
         (v_元素3 <> c_Bill.元素3 And n_元素3_Count >= n_收据费目 And n_收据费目 <> 0) Or (n_元素4_Count >= n_收费细目 And n_收费细目 <> 0) Then
      
        If (v_元素1 <> '+' Or n_元素2 <> 0 Or v_元素3 <> '+' Or n_元素4 <> 0) Then
          n_分页 := 1;
        End If;
        n_元素2_Count := 0;
        n_元素3_Count := 0;
        n_元素4_Count := 0;
        n_元素1_Count := 0;
        v_元素1       := '+';
        n_元素2       := 0;
        v_元素3       := '+';
      End If;
    
      If n_分页 = 1 Then
        --分页:计算发票号及相关的
        For I In 1 .. c_No.Count Loop
          Invoce_Out.Extend;
          Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
          Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
          Invoce_Out(Invoce_Out.Count).序号 := Case
                                               When Instr(c_No(I).序号, ',') > 0 Then
                                                Substr(c_No(I).序号, 2)
                                               Else
                                                c_No(I).序号
                                             End;
          Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
        End Loop;
      
        本次发票张数_Out := 本次发票张数_Out + 1;
        本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
        v_发票号         := Zl_Incstr(v_发票号);
        c_No.Delete;
      End If;
      If (v_元素1 <> c_Bill.元素1) Then
        n_元素1_Count := n_元素1_Count + 1;
        v_元素1       := c_Bill.元素1;
      End If;
      If (n_元素2 <> c_Bill.元素2) Then
        n_元素2_Count := n_元素2_Count + 1;
        n_元素2       := c_Bill.元素2;
      End If;
      If (v_元素3 <> c_Bill.元素3) Then
        n_元素3_Count := n_元素3_Count + 1;
        v_元素3       := c_Bill.元素3;
      End If;
      If n_收费细目 <> 0 Then
        n_元素4_Count := n_元素4_Count + 1;
      End If;
    
      -------------------------------------------
      --分配单据号及序号
      n_Find := 0;
      For J In 1 .. c_No.Count Loop
        If c_No(J).No = c_Bill.单据 Then
          --单据号相同,将序号合并
          c_No(J).序号 := c_No(J).序号 || ',' || c_Bill.序号;
          n_Find := 1;
          Exit;
        End If;
      End Loop;
      If n_Find = 0 Then
        c_No.Extend;
        c_No(c_No.Count).No := c_Bill.单据;
        c_No(c_No.Count).序号 := c_No(c_No.Count).序号 || ',' || c_Bill.序号;
      End If;
    End Loop;
  
    --是否有发票数据
    If n_Count >= 1 Then
      --最后一个发票分配
      本次发票张数_Out := 本次发票张数_Out + 1;
      本次打印发票_Out := Nvl(本次打印发票_Out, '') || ',' || v_发票号;
    Else
      本次发票张数_Out := 0;
      本次打印发票_Out := '';
    End If;
    If c_No.Count <> 0 Then
      For I In 1 .. c_No.Count Loop
        Invoce_Out.Extend;
        Invoce_Out(Invoce_Out.Count).票号 := v_发票号;
        Invoce_Out(Invoce_Out.Count).No := c_No(I).No;
        If Instr(c_No(I).序号, ',') > 0 Then
          c_No(I).序号 := Substr(c_No(I).序号, 2);
        End If;
        Invoce_Out(Invoce_Out.Count).序号 := c_No(I).序号;
        Invoce_Out(Invoce_Out.Count).关联序号 := n_关联序号;
      End Loop;
      c_No.Delete;
    End If;
    If Instr(Nvl(本次打印发票_Out, '-'), ',') > 0 Then
      本次打印发票_Out := Substr(本次打印发票_Out, 2);
    End If;
  End Invoice_Split_Notgroup;

Begin
  --处理票据数据
  If 票种_In <> 1 Then
    --暂不支持其他,只支持门诊收费
    Return;
  End If;
  v_发票号 := 起始发票号_In;
  v_Nos    := Nos_In;
  -----------------------------------------------------------------------------------------------------------------------------
  --一、获取发票分配的相关规则
  --**开始
  --1.确定是否分单据分配票号,缺省不按单据分号
  n_分单据打印 := 0;
  --2.确定是否按执行科室分单据号,缺省为按1个执行科室分号
  n_执行科室 := 1;

  --3.确定是否按收据费目分单据号,缺省为按3个收据费目分号
  n_收据费目 := 3;

  --4.确定是否按收费细目分单据号,缺省为不按收费细目分号
  n_收费细目 := 0;

  --5.决定是否首页汇总,缺省为不汇总
  n_汇总条件 := 0;

  v_回收票据号 := 发票号_In;
  发票张数_In  := 0;
  --**结束
  -----------------------------------------------------------------------------------------------------------------------------
  --二、进行发票分配
  Invoice_Split_Notgroup(Nos_In, 发票号_In, v_发票信息, 发票张数_In, c_Invoce);

  -----------------------------------------------------------------------------------------------------------------------------
  --*****************************************************************************************************************************
  --注意:
  --以下代码，不轻意更改,在上面的代码中需要确定两个变量的值:一是v_发票信息;二是c_Invoce集合中的值
  --  v_发票信息:本次所涉及的发票信息,多个用逗号分离,最好按升序排序
  --  c_Invoce:为集合数据，为发票号和单据的对应关系

  发票号_In := v_发票信息;
  If 模拟计算_In = 1 Then
    --模拟计算,只返回票据张数和使用的票据号,直接退出
    Return;
  End If;
  -----------------------------------------------------------------------------------------------------------------------------
  --四、退费时，需要先处理回收发票
  v_开始发票号 := Null;
  v_当前发票号 := Null;
  --1-正常打印票据;2-补打票据;3-重打票据;4-退费收回票据并重新发出票据
  If 操作类型_In = 3 Or 操作类型_In = 4 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id
           From 票据使用明细 A, 票据打印明细 B, Table(f_Str2list(v_回收票据号)) J
           Where a.Id = b.使用id And b.票号 = j.Column_Value And Nvl(b.票种, 0) = 1);
  
    --插入回收记录
    Forall I In 1 .. l_使用id.Count
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 4, 领用id, 打印id, 使用人_In, 使用时间_In
        From 票据使用明细
        Where ID = l_使用id(I);
    Forall I In 1 .. l_使用id.Count
      Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I);
  End If;

  If c_Invoce.Count = 0 Then
    --无发票数据,则直接返回,退费时，表示只收回票据
    Return;
  End If;

  -----------------------------------------------------------------------------------------------------------------------------
  --五、重新处理发出的票据(含退费重新发出的票据处理)
  If 起始发票号_In Is Null Then
    v_Err_Msg := '未传入起始发票号,不能进行票据分配处理';
    Raise Err_Item;
  End If;

  If Nvl(领用id_In, 0) <> 0 Then
    Open c_Fact;
    Fetch c_Fact
      Into r_Factrow;
    If c_Fact%RowCount = 0 Then
      v_Err_Msg := '无效的票据领用批次，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    Elsif Nvl(r_Factrow.剩余数量, 0) < 发票张数_In Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Close c_Fact;
      Raise Err_Item;
    End If;
  End If;

  --1.实际处理票据信息
  If Nvl(n_分单据打印, 0) <> 1 Then
    --不分单据打印时,表示一次打印,打印ID填成一致
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  End If;

  发票张数_In := 0;
  v_打印内容  := '';
  For c_Invoce_No In (Select Column_Value As 发票号 From Table(f_Str2list(v_发票信息)) Order By 发票号) Loop
    --2.检查票据范围是否正确
    If Nvl(领用id_In, 0) <> 0 Then
      If Not (Upper(c_Invoce_No.发票号) >= Upper(r_Factrow.开始号码) And Upper(c_Invoce_No.发票号) <= Upper(r_Factrow.终止号码) And
          Length(c_Invoce_No.发票号) = Length(r_Factrow.终止号码)) Then
        v_Err_Msg := '该单据需要打印多张票据,但票据号"' || c_Invoce_No.发票号 || '"超出票据领用的号码范围！';
        Close c_Fact;
        Raise Err_Item;
      End If;
    End If;
  
    --3.处理票据打印明细
    r_单据号.Delete;
    r_单据序号.Delete;
    l_关联序号.Delete;
  
    Select 票据使用明细_Id.Nextval Into n_使用id From Dual;
  
    n_关联序号 := 0;
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        n_关联序号 := c_Invoce(I).关联序号;
        Exit;
      End If;
    End Loop;
  
    --处理关联票据,以便回收票据
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).关联序号 = n_关联序号 And Nvl(c_Invoce(I).修改标志, 0) = 0 Then
        If n_关联序号 <> 0 Then
          c_Invoce(I).关联序号 := n_使用id;
        End If;
        c_Invoce(I).修改标志 := 1;
      End If;
    End Loop;
  
    For I In 1 .. c_Invoce.Count Loop
      If c_Invoce(I).票号 = c_Invoce_No.发票号 Then
        r_单据号.Extend;
        r_单据号(r_单据号.Count) := c_Invoce(I).No;
        r_单据序号.Extend;
        r_单据序号(r_单据序号.Count) := c_Invoce(I).序号;
        l_关联序号.Extend;
        If Nvl(c_Invoce(I).关联序号, 0) <> 0 Then
          --检查是否存在其他的票据
          n_Find := 0;
          For J In 1 .. c_Invoce.Count Loop
            If c_Invoce(I).关联序号 = c_Invoce(J).关联序号 And c_Invoce(I).票号 <> c_Invoce(J).票号 Then
              n_Find := 1;
              Exit;
            End If;
          End Loop;
        
          If n_Find = 0 Then
            l_关联序号(l_关联序号.Count) := Null;
            c_Invoce(I).关联序号 := 0;
          Else
            l_关联序号(l_关联序号.Count) := c_Invoce(I).关联序号;
          End If;
        Else
          l_关联序号(l_关联序号.Count) := Null;
        End If;
      End If;
    End Loop;
  
    --1.处理门打印内容
    If n_分单据打印 = 1 Then
      --分单据打印,需按单据进行处理
      --票据打印内容
      n_Find := 0;
      v_Temp := '';
      For I In 1 .. r_单据号.Count Loop
        v_Temp := v_Temp || ',' || r_单据号(I);
        If Instr(Nvl(v_打印内容, '-') || ',', ',' || r_单据号(I) || ',') > 0 Then
          --已经找到
          n_Find := 1;
        End If;
      End Loop;
      v_打印内容 := v_打印内容 || Nvl(v_Temp, '+');
    
      If Nvl(n_Find, 0) = 0 Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
        Forall I In 1 .. r_单据号.Count
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 1, r_单据号(I));
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
        Forall I In 1 .. r_单据号.Count
          Update 门诊费用记录 Set 实际票号 = v_开始发票号 Where Mod(记录性质, 10) = 1 And NO = r_单据号(I);
      End If;
    Else
    
      If v_开始发票号 Is Null Then
        --以便更新门诊费用记录中的实际票号
        v_开始发票号 := c_Invoce_No.发票号;
      
        --票据打印内容
        Insert Into 票据打印内容
          (ID, 数据性质, NO)
          Select n_打印id, 1, Column_Value From Table(f_Str2list(v_Nos));
      
        Update 门诊费用记录
        Set 实际票号 = v_开始发票号
        Where Mod(记录性质, 10) = 1 And NO In (Select Column_Value From Table(f_Str2list(v_Nos)));
      End If;
    End If;
    --2.处理票据打印明细
  
    发票张数_In := 发票张数_In + 1;
    --处理票据使用明细
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
    Values
      (n_使用id, 1, c_Invoce_No.发票号, 1, Decode(操作类型_In, 3, 3, 1), Decode(Nvl(领用id_In, 0), 0, Null, 领用id_In), n_打印id, 使用人_In, 使用时间_In);
  
    Forall I In 1 .. r_单据号.Count
      Insert Into 票据打印明细
        (使用id, 票种, 是否回收, NO, 票号, 序号, 关联票号序号)
      Values
        (n_使用id, 1, 0, r_单据号(I), c_Invoce_No.发票号, r_单据序号(I), l_关联序号(I));
  
    v_当前发票号 := c_Invoce_No.发票号;
  End Loop;

  If Nvl(领用id_In, 0) <> 0 Then
    Close c_Fact;
    Update 票据领用记录
    Set 使用时间 = 使用时间_In, 当前号码 = v_当前发票号, 剩余数量 = Nvl(剩余数量, 0) - 发票张数_In
    Where ID = 领用id_In
    Returning 剩余数量 Into n_返回数;
    If n_返回数 < 0 Then
      v_Err_Msg := '当前批次的剩余数量不足' || 发票张数_In || '张，无法完成收费票据分配操作。';
      Raise Err_Item;
    End If;
  End If;
  --*****************************************************************************************************************************
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Custom_Invoice_Autoallot;
/

--87474:许华峰,2015-08-17,报告医生和审核医生修正
CREATE OR REPLACE PROCEDURE ZL_影像报告保存_UPDATE
(
    医嘱id_In   影像检查记录.医嘱id%Type,
    报告人_In   影像检查记录.报告人%Type,
    复核人_In   影像检查记录.复核人%Type
) Is
--报告人传NULL时，填已有报告人
--复核人传NULL时，填NULL表示清空复核人
Begin
  Update 影像检查记录 Set 报告人=Decode(Nvl(报告人,' '), ' ', 报告人_In, 报告人),复核人=复核人_In Where 医嘱ID=医嘱id_In;
Exception
    When Others Then
        zl_ErrorCenter(SQLCode, SQLErrM);
End ZL_影像报告保存_Update;
/

--87485:胡俊勇,2015-08-17,医嘱单打印从指定页清除
Create Or Replace Procedure Zl_病人医嘱打印_Insert
(
  病人id_In 病人医嘱记录.病人id%Type,
  主页id_In 病人医嘱记录.主页id%Type,
  婴儿_In   病人医嘱记录.婴儿%Type,
  期效_In   病人医嘱记录.医嘱期效%Type,
  行数_In   Number
  --功能：将病人没有打印过的医嘱插入 病人医嘱打印
  --参数：行数_In：报表医嘱单一页可以打多少行
  --      行数_In医嘱单报表的行数，通常是28行。
) Is
  n_序号       病人医嘱记录.序号%Type;
  n_医嘱id     病人医嘱记录.Id%Type;
  n_重整标记   Number;
  v_Max_Date   Date;
  d_重整       Date;
  d_Pdate      Date;
  n_换页打     Number;
  n_打重开     Number;
  n_转科       Number;
  n_页号       Number;
  n_行号       Number;
  n_位置       Number;
  n_打印模式   Number;
  n_打给药方式 Number;
Begin

  n_位置       := Zl_To_Number(Nvl(zl_GetSysParameter('转科和出院打印', 1254), 0));
  n_打印模式   := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱单打印模式', 1253), 0));
  n_打给药方式 := Zl_To_Number(Nvl(zl_GetSysParameter('药品用法单独打印一行', 1254), 0));

  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;
  v_Max_Date := d_重整;
  Begin
    Select 医嘱id, 打印时间, 页号, 行号
    Into n_医嘱id, d_Pdate, n_页号, n_行号
    From (Select 医嘱id, 打印时间, 页号, 行号
           From 病人医嘱打印
           Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id Is Not Null
           Order By 页号 Desc, 行号 Desc)
    Where Rownum < 2;
  
    Select Nvl(Max(序号), 0)
    Into n_序号
    From 病人医嘱记录
    Where ID = (Select Nvl(a.相关id, a.Id) From 病人医嘱记录 A Where a.Id = n_医嘱id); 
  
    If 期效_In = 0 Then
      If d_Pdate Is Not Null Then
        If d_Pdate < d_重整 And d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') Then
          n_重整标记 := 1;
          n_序号     := 0;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      n_页号 := 1;
      n_行号 := 0;
      n_序号 := 0;
  End;

  If 期效_In = 0 Then
    n_换页打 := Zl_To_Number(Nvl(zl_GetSysParameter('重整和术后医嘱换页打印', 1254), 0));
    n_打重开 := Zl_To_Number(Nvl(zl_GetSysParameter('转科换页后在首行打印重开医嘱', 1254), 0));
    If n_医嘱id Is Not Null And n_打重开 = 1 Then
      Select Count(1)
      Into n_转科
      From 病人医嘱记录 A, 诊疗项目目录 B
      Where a.诊疗项目id = b.Id(+) And a.Id = n_医嘱id And a.诊疗类别 = 'Z' And b.操作类型 = '3';
    End If;
  End If;

  --插入重整医嘱，只插入一条
  If n_重整标记 = 1 Then
    --生成行号和页号
    If n_行号 = 行数_In Then
      n_行号 := 1;
      n_页号 := n_页号 + 1;
    Else
      n_行号 := n_行号 + 1;
    End If;
    If n_换页打 = 1 Then
      --如果行号为1说明已经是新的一页的第一行,否则换页
      If n_行号 <> 1 Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    Insert Into 病人医嘱打印
      (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
    Values
      (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, Null);
  End If;

  --转科医嘱换页打医嘱重开字样
  If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
    If n_重整标记 = 1 Then
      --前面打了重整就不换页了
      If n_打重开 = 1 Then
        n_页号 := n_页号 + 1;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      End If;
    Else
      If n_打重开 = 1 Then
        --打重开字样
        If n_行号 = 行数_In Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        Else
          n_行号 := n_行号 + 1;
        End If;
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
      Else
        --只是单纯换一页
        n_行号 := 0;
        n_页号 := n_页号 + 1;
      End If;
    End If;
    n_转科 := 0;
  End If;

  --最近次重整后,需要打印的医嘱，考虑换页打印情况转科术后
  ---r_Print.换页 对特殊医嘱标记，4－术后，3－转科
  If v_Max_Date = To_Date('1900-01-01', 'YYYY-MM-DD') Then
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > n_序号 And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or
                                 l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 n_打给药方式 = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
      
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      
        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱，
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  Else
    For r_Print In (Select 医嘱id, 顺序, 打印标记, 特殊医嘱, 换页
                    From (With Printtable As (Select a.Id As 医嘱id, a.序号 As 顺序, 0 As 打印标记, Null As 特殊医嘱,
                                                     Decode(a.诊疗类别, 'Z', Decode(b.操作类型, '3', 3, '4', 4, 0), 0) As 换页,
                                                     a.诊疗项目id
                                              From 病人医嘱记录 A, 诊疗项目目录 B
                                              Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And
                                                    a.诊疗项目id = b.Id(+) And
                                                    (期效_In = 0 And
                                                    (a.医嘱期效 = 0 Or n_位置 In (-1, 0, 2) And a.医嘱期效 = 1 And a.诊疗类别 = 'Z' And
                                                    b.操作类型 In ('5', '3', '11')) Or
                                                    期效_In = 1 And a.医嘱期效 = 1 And Not (n_位置 = 0 And Nvl(a.诊疗类别, 'X') = 'Z' And
                                                     Nvl(b.操作类型, 'X') In ('5', '3', '11'))) And a.医嘱状态 Not In (-1, 2) And
                                                    (n_打印模式 = 1 And a.医嘱状态 = 1 Or a.医嘱状态 <> 1) And Nvl(a.屏蔽打印, 0) = 0 And
                                                    Not Exists
                                               (Select 1 From 病人医嘱记录 Where 诊疗类别 = 'F' And ID = a.前提id) And
                                                    a.序号 > n_序号 And Exists
                                               (Select 1
                                                     From 病人医嘱状态 C
                                                     Where a.Id = c.医嘱id And c.操作时间 >= v_Max_Date) And a.病人来源 = 2)
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And
                                 (l.诊疗类别 Not In ('5', '6', '7', 'E') Or
                                 l.诊疗类别 = 'E' And Nvl(i.操作类型, '0') Not In ('2', '3') Or i.Id Is Null) And l.相关id Is Null
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗类别 In ('5', '6')
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From 病人医嘱记录 L, 诊疗项目目录 I, Printtable P
                           Where l.Id = p.医嘱id And l.诊疗项目id = i.Id And l.诊疗类别 = 'E' And i.操作类型 = '2' And l.相关id Is Null And
                                 n_打给药方式 = 1
                           Union All
                           Select p.医嘱id, p.顺序, p.打印标记, p.特殊医嘱, p.换页
                           From Printtable P
                           Where p.诊疗项目id Is Null
                           Order By 顺序)
                    ) Loop
      ----换页或者打医嘱重开字样
      If n_换页打 = 1 And n_转科 = 1 And 期效_In = 0 Then
        If n_打重开 = 1 Then
          --打重开字样
          If n_行号 = 行数_In Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          Else
            n_行号 := n_行号 + 1;
          End If;
          If n_行号 <> 1 Then
            n_行号 := 1;
            n_页号 := n_页号 + 1;
          End If;
          Insert Into 病人医嘱打印
            (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
          Values
            (-1 * Null, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, 0, 1);
        Else
          --只是单纯换一页
          n_行号 := 0;
          n_页号 := n_页号 + 1;
        End If;
        n_转科 := 0;
      End If;
    
      --生成行号和页号
      If n_行号 = 行数_In Then
        n_行号 := 1;
        n_页号 := n_页号 + 1;
      Else
        n_行号 := n_行号 + 1;
      End If;
    
      If r_Print.换页 = 4 And n_换页打 = 1 Then
        --术后医嘱换页
        --如果行号为1说明已经是新的一页的第一行,否则换页
        If n_行号 <> 1 Then
          n_行号 := 1;
          n_页号 := n_页号 + 1;
        End If;
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      Else
        Insert Into 病人医嘱打印
          (医嘱id, 页号, 行号, 行数, 病人id, 主页id, 婴儿, 期效, 打印标记, 特殊医嘱)
        Values
          (r_Print.医嘱id, n_页号, n_行号, 1, 病人id_In, 主页id_In, 婴儿_In, 期效_In, r_Print.打印标记, r_Print.特殊医嘱);
      
        --启用了转科换页打重开字样，则插入一重开医嘱标记，此处一定换页，因为转科换页前要先打出转科医嘱
        --这里不插入数据，只进行标记，再下一次循时才插入。如果转科医嘱是最后一条是不用打印新开字样的。
        If r_Print.换页 = 3 And 期效_In = 0 Then
          n_转科 := 1;
        End If;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Insert;
/

--87485:胡俊勇,2015-08-17,医嘱单打印从指定页清除
Create Or Replace Procedure Zl_病人医嘱打印_Delete
(
  病人id_In       病人医嘱记录.病人id%Type,
  主页id_In       病人医嘱记录.主页id%Type,
  婴儿_In         病人医嘱记录.婴儿%Type,
  期效_In         病人医嘱记录.医嘱期效%Type,
  起始页号_In     病人医嘱打印.页号%Type := Null,
  医嘱位置_In     Varchar2 := Null,
  清除上次打印_In Number := Null
  --清除打印_In 1 清除上次打印保留数据，2-清除上次打印删除打印数据，其它－按指定规则清除打印。
) Is
  v_位置   Varchar2(10);
  n_Cnt    Number(8);
  d_重整   Date;
  n_医嘱id 病人医嘱记录.Id%Type;
Begin
  --医嘱变化时的自动清除和清除指定位置医嘱，删数据方式
  If 期效_In = 1 Then
    d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
  Else
    Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
    If d_重整 Is Null Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    End If;
  End If;

  If 清除上次打印_In Is Null Then
    If 医嘱位置_In Is Not Null Then
      v_位置 := 医嘱位置_In;
    End If;
    If v_位置 Is Null Then
      --通过页号来找一个合适的位置
      v_位置 := LPad(起始页号_In, 4, '0') || '001';
    End If;
  Else
    Select Nvl(Min(LPad(页号, 4, '0') || LPad(行号, 3, '0')), '0001001')
    Into v_位置
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
          打印时间 = (Select Max(打印时间)
                  From 病人医嘱打印
                  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In);
  End If;

  --处理一组医嘱打印多行的情况，如一并给药含多个药的医嘱
  For X In (Select a.医嘱id, b.序号, b.相关id, b.诊疗类别, c.操作类型
            From 病人医嘱打印 A, 病人医嘱记录 B, 诊疗项目目录 C
            Where a.医嘱id = b.Id(+) And b.诊疗项目id = c.Id(+) And a.病人id = 病人id_In And a.主页id = 主页id_In And
                  Nvl(a.婴儿, 0) = 婴儿_In And a.期效 = 期效_In And LPad(页号, 4, '0') || LPad(行号, 3, '0') = v_位置) Loop
    If x.诊疗类别 = '5' Or x.诊疗类别 = '6' Then
      Select a.Id
      Into n_医嘱id
      From 病人医嘱记录 A
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.医嘱期效 = 期效_In And
            a.序号 = (Select Min(序号) From 病人医嘱记录 Where 相关id = x.相关id);
    Elsif x.诊疗类别 = 'E' And x.操作类型 = '2' Then
      Select a.Id
      Into n_医嘱id
      From 病人医嘱记录 A
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And Nvl(a.婴儿, 0) = 婴儿_In And a.医嘱期效 = 期效_In And
            a.序号 = (Select Min(序号) From 病人医嘱记录 Where 相关id = x.医嘱id);
    End If;
  End Loop;
  
  n_Cnt := To_Number(v_位置);
  If n_医嘱id Is Not Null Then
    If 期效_In = 1 Then
      Select LPad(页号, 4, '0') || LPad(行号, 3, '0')
      Into v_位置
      From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id = n_医嘱id;
      n_Cnt := To_Number(v_位置);
    Else
      --长嘱单考虑重整及特殊医嘱的情况
      Begin
        Select LPad(页号, 4, '0') || LPad(行号, 3, '0')
        Into v_位置
        From 病人医嘱打印
        Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 医嘱id = n_医嘱id And
              (打印时间 > d_重整 Or 打印时间 Is Null);
        --该位置的前的特殊医嘱一并删除
        For X In (Select 医嘱id, 位置
                  From (Select 医嘱id, LPad(页号, 4, '0') || LPad(行号, 3, '0') As 位置
                         From 病人医嘱打印
                         Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
                               LPad(页号, 4, '0') || LPad(行号, 3, '0') < v_位置
                         Order By 页号 Desc, 行号 Desc)) Loop
          If x.医嘱id Is Not Null Then
            Exit;
          Else
            v_位置 := x.位置;
          End If;
        End Loop;
        n_Cnt := To_Number(v_位置);
      Exception
        When Others Then
          --清除最近一次重整后的所有医嘱
          Select To_Number(Nvl(Max(LPad(页号, 4, '0') || LPad(行号, 3, '0')), 0))
          Into n_Cnt
          From 病人医嘱打印
          Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 < d_重整;
          n_Cnt := n_Cnt + 1;
      End;
    End If;
  End If;

  If n_Cnt Is Not Null Then
    Delete From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
          To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= n_Cnt;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--87409:刘尔旋,2015-08-11,接口预约支持不付款
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <JKFS>0</JKFS>  //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号目前仅支持一个，结构与收费一致，以后可扩展
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码       挂号安排.号码%Type;
  d_发生时间   Date;
  d_原始时间   Date;
  d_登记时间   Date;
  v_金额       Varchar2(200);
  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  n_分时段     Number(3);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  n_缴款方式   Number(3);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM'),
         Extractvalue(Value(A), 'IN/JKFS')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名, n_缴款方式
  
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select Extractvalue(b.Column_Value, '/JS/JSKLB'), Extractvalue(b.Column_Value, '/JS/JSKH'),
         Extractvalue(b.Column_Value, '/JS/JSFS'), Extractvalue(b.Column_Value, '/JS/JYLSH'),
         Extractvalue(b.Column_Value, '/JS/JYSM')
  Into v_卡类别名称, v_结算卡号, v_结算方式, v_流水号, v_说明
  From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;
  Begin
    Select b.结算方式, b.Id Into v_结算方式, n_卡类别id From 医疗卡类别 B Where b.名称 = v_卡类别名称 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现该结算卡的相关信息';
      Raise Err_Item;
  End;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;
  Select Decode(To_Char(d_发生时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;
  Begin
    Select ID
    Into n_计划id
    From (Select ID
           From 挂号安排计划
           Where 号码 = v_号码 And d_发生时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                 Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
           Order By 生效时间 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
  End;
  If Nvl(n_计划id, 0) <> 0 Then
    --从计划读取信息
    Select a.项目id, b.科室id, a.医生姓名, a.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                   Null), Nvl(a.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = n_计划id And b.Id = a.安排id;
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号计划时段
      Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号计划时段
            Where 计划id = n_计划id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  Else
    --从安排读取信息
    Select b.项目id, b.科室id, b.医生姓名, b.医生id,
           Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                   Null), Nvl(b.序号控制, 0)
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
    From 挂号安排 B
    Where b.Id = n_安排id;
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
    --合作单位检查
    If v_合作单位 Is Not Null Then
      Begin
        Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
      Exception
        When Others Then
          n_存在 := 0;
      End;
    End If;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的合作单位在此号码上被禁用！';
      Raise Err_Item;
    End If;
    If n_分时段 = 1 And n_序号控制 = 0 Then
      d_发生时间 := d_原始时间;
      Select 序号
      Into n_号序
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
    Else
      Begin
        Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
        Into d_发生时间
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
      Exception
        When Others Then
          If n_分时段 = 1 And n_序号控制 = 1 Then
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                            'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 挂号安排时段
            Where 安排id = n_安排id And 星期 = v_星期;
          Else
            Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
            Into d_发生时间
            From 时间段
            Where 时间段 = v_排班;
          End If;
          If d_发生时间 < d_登记时间 Then
            d_发生时间 := d_登记时间;
          End If;
      End;
    End If;
  End If;

  Select a.类别, b.现价, b.收入项目id, c.收据费目, a.屏蔽费别
  Into v_收费类别, n_标准单价, n_收入项目id, v_收据费目, n_屏蔽费别
  From 收费项目目录 A, 收费价目 B, 收入项目 C
  Where a.Id = n_收费细目id And b.收费细目id = a.Id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
        Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD')) And Rownum < 2;

  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Select 病人预交记录_Id.Nextval Into n_预交id From Dual;

  If Trunc(d_发生时间) <> Trunc(Sysdate) Then
    If Nvl(n_缴款方式, 0) = 0 Then
      Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                       v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
    Else
      Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                       v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
    End If;
  Else
    Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null, v_流水号,
                     v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
  End If;

  For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                        Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
    Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
  End Loop;

  v_Temp := '<GHDH>' || v_No || '</GHDH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/

--86554:余伟节,2015-08-11,入院时间精确到分
Create Or Replace Procedure Zl_入院病案主页_Insert
(
  登记模式_In       Number,
  病人性质_In       病案主页.病人性质%Type,
  病人id_In         病人信息.病人id%Type,
  住院号_In         病人信息.住院号%Type,
  医保号_In         保险帐户.医保号%Type,
  姓名_In           病人信息.姓名%Type,
  性别_In           病人信息.性别%Type,
  年龄_In           病人信息.年龄%Type,
  费别_In           病人信息.费别%Type,
  出生日期_In       病人信息.出生日期%Type,
  国籍_In           病人信息.国籍%Type,
  民族_In           病人信息.民族%Type,
  学历_In           病人信息.学历%Type,
  婚姻状况_In       病人信息.婚姻状况%Type,
  职业_In           病人信息.职业%Type,
  身份_In           病人信息.身份%Type,
  身份证号_In       病人信息.身份证号%Type,
  出生地点_In       病人信息.出生地点%Type,
  家庭地址_In       病人信息.家庭地址%Type,
  家庭地址邮编_In   病人信息.家庭地址邮编%Type,
  家庭电话_In       病人信息.家庭电话%Type,
  户口地址_In       病人信息.户口地址%Type,
  户口地址邮编_In   病人信息.户口地址邮编%Type,
  联系人姓名_In     病人信息.联系人姓名%Type,
  联系人关系_In     病人信息.联系人关系%Type,
  联系人地址_In     病人信息.联系人地址%Type,
  联系人电话_In     病人信息.联系人电话%Type,
  工作单位_In       病人信息.工作单位%Type,
  合同单位id_In     病人信息.合同单位id%Type,
  单位电话_In       病人信息.单位电话%Type,
  单位邮编_In       病人信息.单位邮编%Type,
  单位开户行_In     病人信息.单位开户行%Type,
  单位帐号_In       病人信息.单位帐号%Type,
  担保人_In         病人信息.担保人%Type,
  担保额_In         病人信息.担保额%Type,
  担保性质_In       病人信息.担保性质%Type,
  入院科室id_In     病案主页.入院科室id%Type,
  护理等级id_In     病案主页.护理等级id%Type,
  入院病况_In       病案主页.入院病况%Type,
  入院方式_In       病案主页.入院方式%Type,
  住院目的_In       病案主页.住院目的%Type,
  二级院转入_In     病案主页.二级院转入%Type,
  门诊医师_In       病案主页.门诊医师%Type,
  籍贯_In           病人信息.籍贯%Type,
  区域_In           病案主页.区域%Type,
  入院时间_In       病案主页.入院日期%Type,
  是否陪伴_In       病案主页.是否陪伴%Type,
  床号_In           病案主页.入院病床%Type,
  付款方式_In       病案主页.医疗付款方式%Type,
  疾病id_In         病人诊断记录.疾病id%Type,
  诊断id_In         病人诊断记录.诊断id%Type,
  门诊诊断_In       病人诊断记录.诊断描述%Type,
  中医疾病id_In     病人诊断记录.疾病id%Type,
  中医诊断id_In     病人诊断记录.诊断id%Type,
  中医诊断_In       病人诊断记录.诊断描述%Type,
  险类_In           病案主页.险类%Type,
  操作员编号_In     病案主页.编目员编号%Type,
  操作员姓名_In     病案主页.编目员姓名%Type,
  新病人_In         Number := 1,
  备注_In           病案主页.备注%Type,
  入院病区id_In     病案主页.入院病区id%Type,
  再入院_In         病案主页.再入院%Type,
  入院属性_In       病案主页.入院属性%Type := Null,
  主页id_In         病案主页.主页id%Type := Null,
  住院次数_In       病人信息.住院次数%Type := Null,
  其他证件_In       病人信息.其他证件%Type := Null,
  病人类型_In       病案主页.病人类型%Type := Null,
  联系人身份证号_In 病人信息.联系人身份证号%Type := Null
) As
  -----------------------------------------------------------
  --功能：对入院病人新增一张病案主页，同时可能处理入科。
  --参数：
  --      登记模式_IN=0-正常登记,1-预约登记,2-接收预约(新病人_IN=0)
  --      病人性质_IN=对应"病案主页.病人性质"
  --      床号_IN=Null:不同时入科;'家庭病床':分配家庭病床,填为空;其他:分配具体床位。
  --      新病人_IN=如果是已有档案的病人入院,则该参数为0；缺省为新病人
  --      入院病区ID_IN=只有当使用[病区管理病床]模式(参数号99)时,并且入院同时入科分床时,才有值
  --      住院号_In = 登记门诊留观病人时 住院号_In 为病人门诊号
  -----------------------------------------------------------
  v_主页id   病案主页.主页id%Type;
  v_等级id   床位状况记录.等级id%Type;
  n_住院次数 病人信息.住院次数%Type;

  v_费别  病案主页.费别%Type;
  v_Count Number;
  v_Date  Date;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --判断病人是否锁定
  Select Count(病人id) Into v_Count From 病人信息 Where 病人id = 病人id_In;
  If v_Count <> 0 Then
    Zl_病人信息_锁定检查(病人id_In);
  End If;

  Select Sysdate Into v_Date From Dual;
  Zl_病区标记记录_Clear(病人id_In);
  --病人基本信息
  If 病人性质_In = 1 Then
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 门诊号, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号)
      Values
        (病人id_In, 住院号_In, Null, 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In, 区域_In, 学历_In,
         婚姻状况_In, 职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In,
         联系人地址_In, 联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
         Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 门诊号 = 住院号_In, 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In,
          出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In, 区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In,
          身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In, 家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In,
          户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In,
          合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In,
          单位帐号 = 单位帐号_In, 担保人 = 担保人_In, 担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In,
          其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In
      Where 病人id = 病人id_In;
    End If;
  Else
    If 新病人_In = 1 Then
      Insert Into 病人信息
        (病人id, 住院号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 出生日期, 国籍, 民族, 籍贯, 区域, 学历, 婚姻状况, 职业, 身份, 身份证号, 出生地点, 家庭地址, 家庭地址邮编, 家庭电话,
         户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 工作单位, 合同单位id, 单位电话, 单位邮编, 单位开户行, 单位帐号, 担保人, 担保额, 担保性质, 险类, 登记时间, 其他证件,
         联系人身份证号)
      Values
        (病人id_In, 住院号_In, 姓名_In, 性别_In, 年龄_In, 费别_In, 付款方式_In, 出生日期_In, 国籍_In, 民族_In, 籍贯_In, 区域_In, 学历_In, 婚姻状况_In,
         职业_In, 身份_In, 身份证号_In, 出生地点_In, 家庭地址_In, 家庭地址邮编_In, 家庭电话_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In, 联系人地址_In,
         联系人电话_In, 工作单位_In, Decode(合同单位id_In, 0, Null, 合同单位id_In), 单位电话_In, 单位邮编_In, 单位开户行_In, 单位帐号_In, 担保人_In,
         Decode(担保额_In, 0, Null, 担保额_In), 担保性质_In, 险类_In, v_Date, 其他证件_In, 联系人身份证号_In);
    Else
      --老病人的门诊费别不变,除非是门诊留观病人
      Update 病人信息
      Set 住院号 = Decode(住院号_In, Null, 住院号, 住院号_In), 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In,
          费别 = Decode(病人性质_In, 1, 费别_In, 费别), 医疗付款方式 = 付款方式_In, 出生日期 = 出生日期_In, 国籍 = 国籍_In, 民族 = 民族_In, 籍贯 = 籍贯_In,
          区域 = 区域_In, 学历 = 学历_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 身份 = 身份_In, 身份证号 = 身份证号_In, 出生地点 = 出生地点_In, 家庭地址 = 家庭地址_In,
          家庭地址邮编 = 家庭地址邮编_In, 家庭电话 = 家庭电话_In, 户口地址 = 户口地址_In, 户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In,
          联系人地址 = 联系人地址_In, 联系人电话 = 联系人电话_In, 工作单位 = 工作单位_In, 合同单位id = Decode(合同单位id_In, 0, Null, 合同单位id_In),
          单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In, 单位开户行 = 单位开户行_In, 单位帐号 = 单位帐号_In, 担保人 = 担保人_In,
          担保额 = Decode(担保额_In, 0, Null, 担保额_In), 担保性质 = 担保性质_In, 险类 = 险类_In, 其他证件 = 其他证件_In, 联系人身份证号 = 联系人身份证号_In
      Where 病人id = 病人id_In;
    End If;
  End If;

  --病案信息
  Begin
    If 登记模式_In = 1 Then
      v_主页id := 0; --预约登记记录的主页ID=0
    Else
      If 主页id_In Is Null Then
        Select Nvl(Max(主页id), 0) + 1 Into v_主页id From 病案主页 Where 病人id = 病人id_In And Nvl(主页id, 0) <> 0;
      Else
        v_主页id := 主页id_In;
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  If 登记模式_In <> 1 Then
    Update 病人信息
    Set 主页id = v_主页id, 当前病区id = 入院病区id_In, 当前科室id = 入院科室id_In, 当前床号 = Decode(床号_In, '家庭病床', Null, 床号_In), 入院时间 = 入院时间_In,
        出院时间 = Null, 在院 = 1
    Where 病人id = 病人id_In;
  End If;

  --更新住院次数
  If 登记模式_In <> 1 And 病人性质_In = 0 Then
    If Nvl(住院次数_In, 0) = 0 Then
      Select Nvl(住院次数, 0) + 1 Into n_住院次数 From 病人信息 Where 病人id = 病人id_In;
    Else
      n_住院次数 := 住院次数_In;
    End If;
    Update 病人信息 Set 住院次数 = n_住院次数 Where 病人id = 病人id_In;
  End If;

  Begin
    If 登记模式_In <> 1 Then
      Update 在院病人 Set 病区id = Nvl(入院病区id_In, 0), 科室id = 入院科室id_In Where 病人id = 病人id_In;
      If Sql%RowCount = 0 Then
        Insert Into 在院病人 (病人id, 科室id, 病区id) Values (病人id_In, 入院科室id_In, Nvl(入院病区id_In, 0));
      End If;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --状态：0-正常在院,1-等待入科,2-等待转科
  If 登记模式_In = 2 Then
    --处理病案主页从表
    Delete From 病案主页从表 Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    --接收预约
    Update 病案主页
    Set 主页id = v_主页id, 病人性质 = 病人性质_In, 住院号 = Decode(病人性质_In, 1, Null, 住院号_In),
        --主页ID变更,病人性质可能变更
        费别 = 费别_In, 入院病区id = 入院病区id_In, 入院科室id = 入院科室id_In, 入院日期 = 入院时间_In, 入院病况 = 入院病况_In, 入院方式 = 入院方式_In,
        入院属性 = 入院属性_In, 二级院转入 = 二级院转入_In, 住院目的 = 住院目的_In, 入院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 是否陪伴 = 是否陪伴_In,
        当前病况 = 入院病况_In, 当前病区id = 入院病区id_In, 护理等级id = Decode(护理等级id_In, 0, Null, 护理等级id_In), 出院科室id = 入院科室id_In,
        出院病床 = Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师 = 门诊医师_In, 编目员编号 = 操作员编号_In, 编目员姓名 = 操作员姓名_In, 姓名 = 姓名_In,
        性别 = 性别_In, 年龄 = 年龄_In, 婚姻状况 = 婚姻状况_In, 职业 = 职业_In, 国籍 = 国籍_In, 学历 = 学历_In, 单位电话 = 单位电话_In, 单位邮编 = 单位邮编_In,
        单位地址 = 工作单位_In, 区域 = 区域_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In, 户口地址 = 户口地址_In,
        户口地址邮编 = 户口地址邮编_In, 联系人姓名 = 联系人姓名_In, 联系人关系 = 联系人关系_In, 联系人地址 = 联系人地址_In, 联系人身份证号 = 联系人身份证号_In, 联系人电话 = 联系人电话_In,
        医疗付款方式 = 付款方式_In, 备注 = 备注_In, 险类 = 险类_In, 状态 = Decode(床号_In, Null, 1, 0), 登记人 = 操作员姓名_In, 登记时间 = v_Date,
        再入院 = 再入院_In, 病人类型 = 病人类型_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0;
    Update 病人预交记录
    Set 主页id = 主页id_In
    Where 病人id = 病人id_In And 主页id Is Null And 科室id = 入院科室id_In And 预交类别 = 2 And 冲预交 Is Null And
          Trunc(收款时间) = Trunc(Sysdate);
  Else
    --入院登记或预约登记
    Insert Into 病案主页
      (病人性质, 病人id, 主页id, 住院号, 费别, 入院病区id, 入院科室id, 入院日期, 入院病况, 入院方式, 入院属性, 二级院转入, 住院目的, 入院病床, 是否陪伴, 当前病况, 当前病区id, 护理等级id,
       出院科室id, 出院病床, 门诊医师, 编目员编号, 编目员姓名, 状态, 姓名, 性别, 年龄, 婚姻状况, 职业, 国籍, 学历, 单位电话, 单位邮编, 单位地址, 区域, 家庭地址, 家庭电话, 家庭地址邮编,
       户口地址, 户口地址邮编, 联系人姓名, 联系人关系, 联系人地址, 联系人电话, 联系人身份证号, 医疗付款方式, 险类, 备注, 登记人, 登记时间, 再入院, 病人类型)
    Values
      (病人性质_In, 病人id_In, v_主页id, Decode(病人性质_In, 1, Null, 住院号_In), 费别_In, 入院病区id_In, 入院科室id_In, 入院时间_In, 入院病况_In,
       入院方式_In, 入院属性_In, 二级院转入_In, 住院目的_In, Decode(床号_In, '家庭病床', Null, 床号_In), 是否陪伴_In, 入院病况_In, 入院病区id_In,
       Decode(护理等级id_In, 0, Null, 护理等级id_In), 入院科室id_In, Decode(床号_In, '家庭病床', Null, 床号_In), 门诊医师_In, 操作员编号_In, 操作员姓名_In,
       Decode(床号_In, Null, 1, 0), 姓名_In, 性别_In, 年龄_In, 婚姻状况_In, 职业_In, 国籍_In, 学历_In, 单位电话_In, 单位邮编_In, 工作单位_In, 区域_In,
       家庭地址_In, 家庭电话_In, 家庭地址邮编_In, 户口地址_In, 户口地址邮编_In, 联系人姓名_In, 联系人关系_In, 联系人地址_In, 联系人电话_In, 联系人身份证号_In, 付款方式_In,
       险类_In, 备注_In, 操作员姓名_In, v_Date, 再入院_In, 病人类型_In);
  End If;

  Select 费别 Into v_费别 From 病人信息 Where 病人id = 病人id_In;
  If v_费别 Is Null Then
    Update 病人信息
    Set 费别 =
         (Select 费别 From 病案主页 Where 病人id = 病人id_In And 主页id = v_主页id)
    Where 病人id = 病人id_In;
  End If;

  --医保号
  If 登记模式_In <> 1 Then
    Select Zl_住院日报_Count(入院科室id_In, Trunc(入院时间_In)) Into v_Count From Dual;
    If v_Count > 0 Then
      v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
      Raise Err_Custom;
    End If;
  
    If 医保号_In Is Not Null Then
      Insert Into 病案主页从表 (病人id, 主页id, 信息名, 信息值) Values (病人id_In, v_主页id, '医保号', 医保号_In);
    End If;
  
    --病人变动记录
    --同时入科且非家庭病床时有等级
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select 等级id Into v_等级id From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --如果同时入科,则入院和入科填写到一条入院变动
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 病情, 操作员编号, 操作员姓名)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, v_主页id, 入院时间_In, 1, 0, 入院病区id_In, 入院科室id_In, Decode(护理等级id_In, 0, Null, 护理等级id_In),
       v_等级id, Decode(床号_In, '家庭病床', Null, 床号_In), 入院病况_In, 操作员编号_In, 操作员姓名_In);
  
    --同时入科且非家庭病床时床位被占用
    If 床号_In Is Not Null And 床号_In <> '家庭病床' Then
      Select Count(*) Into v_Count From 床位状况记录 Where 病区id = 入院病区id_In And 床号 = 床号_In And 状态 = '空床';
    
      If v_Count = 0 Then
        v_Error := '操作失败,床位 ' || 床号_In || ' 不是空床！';
        Raise Err_Custom;
      End If;
    
      Update 床位状况记录
      Set 状态 = '占用', 病人id = 病人id_In, 科室id = Decode(共用, 1, 入院科室id_In, 科室id)
      Where 病区id = 入院病区id_In And 床号 = 床号_In;
    End If;
  
    --病人诊断记录
    If 门诊诊断_In Is Not Null Or 疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 1, 1, 疾病id_In, 诊断id_In, 门诊诊断_In, Sysdate, 操作员姓名_In);
    End If;
    If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Then
      Insert Into 病人诊断记录
        (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 记录日期, 记录人)
      Values
        (病人诊断记录_Id.Nextval, 病人id_In, v_主页id, 2, 11, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Sysdate, 操作员姓名_In);
    End If;
    --病人担保记录
    Update 病人担保记录
    Set 到期时间 = Sysdate
    Where 病人id = 病人id_In And 到期时间 Is Not Null And 到期时间 > Sysdate;
  
    --病人费用审批项目
    If 登记模式_In <> 1 Then
      Delete From 病人审批项目 Where 病人id = 病人id_In;
    End If;
  
    If 登记模式_In = 0 And ((门诊诊断_In Is Not Null Or 疾病id_In Is Not Null) Or (中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null)) Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', 入院科室id_In, Null, Sysdate, Sysdate);
    End If;
  
    If 登记模式_In = 0 And 床号_In Is Not Null Then
      If 再入院_In = 0 Then
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      Else
        Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '再次入院', 入院科室id_In, Null, 入院时间_In, 入院时间_In);
      End If;
    End If;
  
    If 床号_In Is Not Null Then
      --添加首份体温单
      Zl_病人体温单_Newfirst(病人id_In, 主页id_In, 入院病区id_In);
    End If;
  
    --并发操作检查
    Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 出院日期 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的病案记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  
    Select Count(*)
    Into v_Count
    From 病人变动记录
    Where 病人id = 病人id_In And 主页id = v_主页id And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
    If v_Count > 1 Then
      v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
      Raise Err_Custom;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_入院病案主页_Insert;
/
--87379:黄捷,2015-08-10,报告中冗余存储诊断意见
CREATE OR REPLACE Function Zlpub_Pacs_取提纲内容byXML
(
  报告内容_In In xmltype,
  报告提纲_In In 影像报告记录.诊断意见%Type
) Return Varchar2 Is
  x_Content        xmltype;
  Xcdom            Xmldom.Domdocument;
  Section_List     Xmldom.Domnodelist;
  Section_Node     Xmldom.Domnode;
  Node_List        Xmldom.Domnodelist;
  n_Len            Number;
  Element_Node     Xmldom.Domnode;
  p_Node           Xmldom.Domnode;
  Enum_Node        Xmldom.Domnode;
  e_Node           Xmldom.Domnodelist;
  c_Node           Xmldom.Domnode;
  Enumeration_List Xmldom.Domnodelist;
  Enumeration_Node Xmldom.Domnode;
  Item_List        Xmldom.Domnodelist;
  Item_Node        Xmldom.Domnode;
  Item_Node1       Xmldom.Domnode;
  v_Name           Varchar2(100);
  v_Result         Varchar2(4000);
  n_i              Number;
  n_Num            Number;
  n_j              Number;
  n_Enum           Number;
  v_Val            Varchar2(20);
  v_Content        Varchar2(4000);
  v_Eleid          Varchar2(50);
  v_Multisel       Varchar2(10);
Begin
  v_Result := '';
    
    x_Content :=报告内容_In;
    Select Deletexml(x_Content, '//image') Into x_Content From Dual;

    Xcdom := Xmldom.Newdomdocument(x_Content);

    For Myrow In (Select Column_Value Name From Table(f_Str2list(报告提纲_In))) Loop
      n_i := -1;
      --循环提纲名称
      Section_List := Xmldom.Getelementsbytagname(Xcdom, 'section');
      n_Len        := Xmldom.Getlength(Section_List);

      For I In 0 .. n_Len - 1 Loop
        If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, I)), 'title') = Myrow.Name Then
          n_i := I;
          Exit;
        End If;
      End Loop;

      If n_i >= 0 Then
        Section_Node := Xmldom.Item(Section_List, n_i);
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
        n_Len        := Xmldom.Getlength(Node_List);

        For I In 0 .. n_Len - 1 Loop
          Element_Node := Xmldom.Item(Node_List, I);
          v_Name       := Xmldom.Getnodename(Element_Node);

          If v_Name = 'element' Then
            If Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') Is Not Null Then
              v_Content := Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node));

              If Instr(v_Content, 'textstyleno') > 0 Then
                v_Content := '';
              End If;
              --如果有单位
              v_Result := v_Result || v_Content || Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
            Else
              p_Node := Xmldom.Getparentnode(Element_Node);
              If Xmldom.Getnodename(p_Node) <> 'enumvalues' Then
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node));
              End If;
            End If;
          Elsif v_Name = 'utext' Then
            v_Result := v_Result || LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          Elsif v_Name = 'e_list' Or v_Name = 'e_enum' Or v_Name = 'e_etree' Or v_Name = 'e_utree' Then
            Enumeration_List := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumeration');
            n_Num            := Xmldom.Getlength(Enumeration_List);

            If v_Name = 'e_enum' And n_Num > 0 Then
              For J In 0 .. n_Num - 1 Loop
                Enumeration_Node := Xmldom.Item(Enumeration_List, J);
                Item_List        := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'item');
                n_j              := Xmldom.Getlength(Item_List);

                For K In 0 .. n_j - 1 Loop
                  Item_Node := Xmldom.Item(Item_List, K);
                  If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'checked') = '1' Then
                    v_Val := Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'val');

                    For Z In 0 .. n_j - 1 Loop
                      Item_Node1 := Xmldom.Item(Item_List, Z);
                      If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'val') = v_Val And
                         Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'issymbol') = '0' Then
                        v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Item_Node1));
                        Exit;
                      End If;
                    End Loop;
                  End If;
                End Loop;
              End Loop;
            Else
              --这里处理枚举有无的情况
              v_Eleid := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid'); --获取元素ID

              Select Extractvalue(b.值域描述, '/root/multisel')
              Into v_Multisel
              From 影像报告元素清单 A, 影像报告值域清单 B
              Where a.值域id = b.id And a.id = Hextoraw(v_Eleid);

              If v_Multisel = 2 And v_Name = 'e_enum' Then
                --为是否类型的枚举
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.getLastChild(Element_Node));
              Else
                Enum_Node := Xmldom.Item(Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumvalues'), 0);
                e_Node := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Enum_Node), 'element');
                n_Enum := Xmldom.Getlength(e_Node);

                For K In 0 .. n_Enum - 1 Loop
                  c_Node   := Xmldom.Item(e_Node, K);
                  v_Result := v_Result || Xmldom.Getattribute(Xmldom.Makeelement(c_Node), 'showtext');

                  If K <> n_Enum - 1 Then
                    v_Result := v_Result || '、';
                  End If;
                End Loop;
              End If;
            End If;
          End If;
        End Loop;
      End If;
    End Loop;

    Xmldom.Freedocument(Xcdom);

    Return translate(v_Result,chr(13)||chr(10),',');
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_取提纲内容byXML;

/

--87379:黄捷,2015-08-10,报告中冗余存储诊断意见
CREATE OR REPLACE Function Zlpub_Pacs_获取提纲内容
(
  医嘱id_In   In 病人医嘱报告.医嘱id%Type,
  报告提纲_In In 电子病历内容.内容文本%Type
) Return Varchar2 Is
 
  v_Result         Varchar2(4000);
  v_SingleResult   Varchar2(4000);
  v_ReportContent  影像报告记录.报告内容%Type;
  
  Cursor Cur_Report_Contents Is 
		Select 报告内容 from 影像报告记录  Where 医嘱ID =医嘱id_In; 
    
Begin
  v_Result := '';
  v_SingleResult :='';
  
  Begin        
    For Row_Report_Contents IN Cur_Report_Contents loop
      v_ReportContent :=Row_Report_Contents.报告内容;
      select Zlpub_Pacs_取提纲内容byXML(v_ReportContent,报告提纲_In) into v_SingleResult from dual;
      if v_Result is null and not v_SingleResult  is null then 
         v_Result :=v_SingleResult;
      elsif not v_SingleResult  is null then 
         v_Result := v_Result || ';' || v_SingleResult;
      end if;
    end loop;   
    return v_Result; 
  Exception
    When Others Then
      Begin
        Select b.内容文本 Into v_Result From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
        Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id
        And c.医嘱id = 医嘱id_In And a.内容文本 = 报告提纲_In;

        Return v_Result;
      Exception
        When Others Then
         Return '';
      End;
  End;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取提纲内容;

/

--86358:冉俊明,2015-08-10,退费申请模式调整
Create Or Replace Procedure Zl_病人退费申请_Apply
(
  操作类型_In Number,
  No_In       病人退费申请.No%Type,
  记录性质_In 病人退费申请.记录性质%Type,
  申请人_In   病人退费申请.申请人%Type,
  申请时间_In 病人退费申请.申请时间%Type,
  申请原因_In 病人退费申请.申请原因%Type := Null
) As
  --功能：退费申请以及取消申请
  --参数：
  --        操作类型_In：0-申请，else-取消申请
  --说明：
  --        取消申请时，"申请人"以及"申请时间"传入申请时的信息
  v_状态  病人退费申请.状态%Type;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 操作类型_In = 0 Then
    --申请
    Begin
      Select 状态
      Into v_状态
      From 病人退费申请
      Where NO = No_In And 记录性质 = 记录性质_In And Nvl(状态, 0) <> 2 And Rownum < 2;
    Exception
      When Others Then
        --没有申请过
        Insert Into 病人退费申请
          (NO, 记录性质, 申请人, 申请时间, 申请原因, 状态)
        Values
          (No_In, 记录性质_In, 申请人_In, 申请时间_In, 申请原因_In, 0);
        Return;
    End;
  
    --已申请或审核通过的不允许再申请
    If Nvl(v_状态, 0) = 0 Or Nvl(v_状态, 0) = 1 Then
      v_Error := '该单据已被申请，不能重复申请。';
      Raise Err_Custom;
    End If;
  
    Insert Into 病人退费申请
      (NO, 记录性质, 申请人, 申请时间, 申请原因, 状态)
    Values
      (No_In, 记录性质_In, 申请人_In, 申请时间_In, 申请原因_In, 0);
  Else
    --取消申请
    Begin
      Select 状态
      Into v_状态
      From 病人退费申请
      Where NO = No_In And 记录性质 = 记录性质_In And 申请时间 = 申请时间_In And Rownum < 2;
    Exception
      When Others Then
        v_Error := '该单据已被取消申请，请刷新后查看...';
        Raise Err_Custom;
    End;
  
    --审核通过或申请被拒绝，不允许取消申请
    If Nvl(v_状态, 0) = 1 Or Nvl(v_状态, 0) = 2 Then
      v_Error := '该单据已被审核通过或拒绝申请，不能取消申请。';
      Raise Err_Custom;
    End If;
  
    Delete 病人退费申请 Where NO = No_In And 记录性质 = 记录性质_In And 申请时间 = 申请时间_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人退费申请_Apply;
/

--86358:冉俊明,2015-08-10,退费申请模式调整
CREATE OR REPLACE Procedure Zl_病人退费申请_Audit
(
  No_In       病人退费申请.No%Type,
  记录性质_In 病人退费申请.记录性质%Type,
  申请时间_In 病人退费申请.申请时间%Type,
  审核人_In   病人退费申请.审核人%Type,
  审核时间_In 病人退费申请.审核时间%Type,
  审核原因_In 病人退费申请.审核原因%Type := Null,
  状态_In     病人退费申请.状态%Type := 1
) As
  --功能：审核单据
  --参数：
  --       状态_In：1-审核通过，2-拒绝申请(审核不通过)，3-取消审核
  --       申请时间_In：单据申请时间
  v_状态  病人退费申请.状态%Type;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    Select 状态
    Into v_状态
    From 病人退费申请
    Where NO = No_In And 记录性质 = 记录性质_In And 申请时间 = 申请时间_In And Rownum < 2;
  Exception
    When Others Then
      v_Error := '该单据已被取消申请，请刷新后查看...';
      Raise Err_Custom;
  End;

  If Nvl(状态_In, 1) = 1 Then
    --审核通过
    If Nvl(v_状态, 0) = 1 Or Nvl(v_状态, 0) = 2 Then
      v_Error := '该单据已被审核通过或拒绝申请，不能再次审核！';
      Raise Err_Custom;
    End If;
  Elsif Nvl(状态_In, 1) = 2 Then
    --拒绝申请
    If Nvl(v_状态, 0) = 2 Then
      v_Error := '该单据已被拒绝申请，不能再次拒绝申请！';
      Raise Err_Custom;
    End If;
  Else
    --取消审核
    If Nvl(v_状态, 0) = 0 Then
      v_Error := '该单据已被取消审核，不能再次取消审核！';
      Raise Err_Custom;
    End If;
  End If;

  If Nvl(状态_In, 1) = 3 Then
    Update 病人退费申请
    Set 审核人 = Null, 审核时间 = Null, 审核原因 = Null, 状态 = 0
    Where NO = No_In And 记录性质 = 记录性质_In And 申请时间 = 申请时间_In;
  Else
    Update 病人退费申请
    Set 审核人 = 审核人_In, 审核时间 = 审核时间_In, 审核原因 = 审核原因_In, 状态 = Nvl(状态_In, 1)
    Where NO = No_In And 记录性质 = 记录性质_In And 申请时间 = 申请时间_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人退费申请_Audit;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--87318:刘尔旋,2015-08-18,新增结算卡类别节点
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  v_结算卡类别 Varchar2(100);
  v_结算方式   医疗卡类别.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--87318:刘尔旋,2015-08-18,新增结算卡类别节点
Create Or Replace Procedure Zl_Third_Charge_Del
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费交易 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_结帐金额   门诊费用记录.结帐金额%Type;
  n_误差额     病人预交记录.冲预交%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  l_挂号单     t_Strlist := t_Strlist();
  v_挂号单     门诊费用记录.No%Type;
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  v_结算卡类别 Varchar2(100);

  n_消费卡id 消费卡目录.Id%Type;
  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);

  d_退费时间 病人预交记录.收款时间%Type;

  v_退费结算 Varchar2(2000);
  v_普通结算 Varchar2(4000);
  n_Temp     Number(18);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Procedure Third_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   2.三方卡退费结算:
    --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
    --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊退费结算_Modify(2, n_病人id, 冲销id_In, v_退费结算, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    
    Xmlexpned_In Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   4-消费卡结算:
    --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||
    --     ②退支票额_In:传入零
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --卡类别ID|卡号|消费卡ID|消费金额||.
    v_退费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 退款金额_In;
    Zl_门诊退费结算_Modify(4, n_病人id, 冲销id_In, v_退费结算, 0, Null, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --人员id,人员编号,人员姓名 
  v_Temp       := Zl_Identity(1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --1.先进行退费

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_冲销id, d_退费时间 From Dual;

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
    Begin
      Select 结算序号, 结帐id, 病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录
      Where 结帐id In (Select 结帐id
                     From 门诊费用记录
                     Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', '')))
      Into v_挂号单
      From 门诊费用记录
      Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
    Exception
      When Others Then
        v_挂号单 := Null;
    End;
    If Not v_挂号单 Is Null Then
      l_挂号单.Extend;
      l_挂号单(l_挂号单.Count) := v_挂号单;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    Zl_门诊收费记录_销帐(c_费用.单据号, v_操作员编码, v_操作员姓名, c_费用.退款序号, d_退费时间, v_摘要, n_冲销id);
    n_Count := n_Count + 1;
  End Loop;
  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.处理退费的结算信息

  n_结帐金额 := 0;

  --检查总金额是否正确 
  Select Sum(结帐金额) Into n_结帐金额 From 门诊费用记录 Where 结帐id = n_冲销id;

  n_误差额 := -1 * Nvl(n_结帐金额, 0) - Nvl(n_退款总额, 0);
  If Abs(n_误差额) > 1.00 Then
    v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
    Raise Err_Item;
  End If;

  --2.确定支付方式
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Third_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                               c_结算方式.Expend);
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Square_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                                c_结算方式.Expend);
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Zl_门诊退费结算_Modify(4, n_病人id, n_冲销id, Null, c_结算方式.退款金额, Null, Null, Null, Null, 0, 0, 0, 0);
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定指付方式，不允缴款!';
        Raise Err_Item;
      End If;
      --结算方式|结算金额|结算号码|结算摘要||..
      v_退费结算 := c_结算方式.结算方式 || '|' || c_结算方式.退款金额 || '| |' || Nvl(c_结算方式.摘要, '  ');
      v_普通结算 := Nvl(v_普通结算, '') || '||' || v_退费结算;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  --     ②退支票额_In:传入零
  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式!';
    Raise Err_Item;
  End If;

  --5.普通结算及完成结
  If v_普通结算 Is Not Null Then
    v_普通结算 := Substr(v_普通结算, 3);
  End If;
  Zl_门诊退费结算_Modify(1, n_病人id, n_冲销id, v_普通结算, 0, Null, Null, Null, Null, 0, 0, n_误差额, 2);

  If l_挂号单.Count <> 0 Then
  
    For I In 0 .. l_挂号单.Count Loop
      x_Templet := Xmltype('<IN></IN>');
      v_Temp    := '<GHDH>' || l_挂号单(I) || '</GHDH>';
      v_Temp    := v_Temp || '<JSKLB>' || 4 || '</JSKLB>';
      v_Temp    := v_Temp || '<GHJE>' || 0 || '</GHJE>';
    
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
    End Loop;
  Else
    Xml_Out := x_Templet;
  End If;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Del;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86797:刘尔旋,2015-08-24,退号检查医嘱
--87650:刘尔旋,2015-08-31,挂号退预约记录
--87409:刘尔旋,2015-08-17,挂号预约不付款模式
--87318:刘尔旋,2015-08-07,服务窗接口新增结算卡类别
Create Or Replace Procedure Zl_Third_Registdelcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号检查
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS')
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
    If Nvl(n_缴款方式, 0) = 0 Then
      --要退的单据不是以该结算卡结算的，则禁止退号
      Begin
        Select 1
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 = v_结算方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_结算方式 || '结算的,无法退号!';
        Raise Err_Item;
      End If;
    Else
      Begin
        Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If n_缴款方式 = 0 Then
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
    If n_实收金额 <> n_挂号金额 Then
      v_Err_Msg := '传入的退款金额与实际挂号金额不符，请检查!';
      Raise Err_Item;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdelcheck;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--87650:刘尔旋,2015-08-31,挂号退预约记录
--86797:刘尔旋,2015-08-24,退号检查医嘱
--86626:刘尔旋,2015-08-17,预约挂号不付款模式
--87409:刘尔旋,2015-08-17,挂号预约不付款模式
--87318:刘尔旋,2015-08-07,服务窗接口新增结算卡类别
Create Or Replace Procedure Zl_Third_Registdel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示取消挂号成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS')
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
  
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
  
    If Nvl(n_缴款方式, 0) = 0 Then
      --要退的单据不是以该结算卡结算的，则禁止退号
      Begin
        Select 1
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 = v_结算方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_结算方式 || '结算的,无法退号!';
        Raise Err_Item;
      End If;
    Else
      Begin
        Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;
  --获取操作员信息
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  Zl_三方机构挂号_Delete(v_No, v_交易流水号, '移动平台退号');

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdel;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--87318:刘尔旋,2015-08-07,服务窗接口新增结算卡类别
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //卡号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --   <JSKLB></JSKLB>     //结算卡类别
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  v_结算卡类别   Varchar2(100);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS'), Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_记录数, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  n_记录数 := Nvl(n_记录数, 0);

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_Reg In (Select a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                         Decode(a.记录性质, 2, '预约中', Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                         Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  Else
    For r_Reg In (Select a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                         Decode(a.记录性质, 2, '预约中', Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                         Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C, 病人预交记录 D
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        c.结帐id = d.结帐id And d.卡类别id = n_卡类别id
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Reghistory;
/

--87310:刘尔旋,2015-08-06,收费获取发药窗口问题
Create Or Replace Function Zl_Getclinicchargepaywins(Nos_In Varchar2)
--功能:获取本次收费的发药窗口
  --返回:执行部门ID|发药窗口;... 
 Return Varchar2 Is
  v_发药窗口 Varchar2(4000);
  v_Paywin   Varchar2(100);
  Function Getnotpaydrugwinds
  (
    病人id_In 门诊费用记录.病人id%Type,
    药房id_In 门诊费用记录.执行部门id%Type
  ) Return Varchar2 Is
    v_Temp Varchar2(100);
  Begin
    For c_发药窗口 In (Select 发药窗口
                   From 未发药品记录
                   Where 单据 = 8 And 发药窗口 Is Not Null And 病人id = 病人id_In And 库房id = 药房id_In
                   Order By 已收费 Desc, 填制日期 Desc) Loop
      v_Temp := c_发药窗口.发药窗口;
      Exit;
    End Loop;
    Return v_Temp;
  End;

  Function Getdefaultpaydrugwinds
  (
    收费类别_In 门诊费用记录.收费类别%Type,
    药房id_In   门诊费用记录.执行部门id%Type
  ) Return Varchar2 Is
    v_西窗   Varchar2(100);
    n_西药房 Number(18);
  
    v_成窗   Varchar2(100);
    n_成药房 Number(18);
    v_中窗   Varchar2(100);
    n_中药房 Number(18);
    v_Temp   Varchar2(1000);
  
    n_药房id    Number(18);
    v_Split_Str Varchar2(4000);
  Begin
    v_Temp := Null;
    If 收费类别_In = '5' Then
      v_西窗   := zl_GetSysParameter(11, 1121);
      n_西药房 := To_Number(zl_GetSysParameter(6, 1121));
      If Instr(v_西窗, ':') > 0 Then
        --旧数据没有存药房ID
        v_Temp := v_西窗;
      Elsif n_西药房 > 0 And Nvl(v_西窗, '-') <> '-' Then
        v_Temp := n_西药房 || ':' || v_西窗;
      
      End If;
    Elsif 收费类别_In = '6' Then
      v_成窗   := zl_GetSysParameter(12, 1121);
      n_成药房 := To_Number(zl_GetSysParameter(8, 1121));
      If Instr(v_成窗, ':') > 0 Then
        v_Temp := v_成窗;
      Elsif n_成药房 > 0 And Nvl(v_成窗, '-') <> '-' Then
        v_Temp := n_成药房 || ':' || v_成窗;
      End If;
    Elsif 收费类别_In = '7' Then
      v_中窗   := zl_GetSysParameter(10, 1121);
      n_中药房 := To_Number(zl_GetSysParameter(7, 1121));
      If Instr(v_中窗, ':') > 0 Then
        v_Temp := v_中窗;
      Elsif n_中药房 > 0 And Nvl(v_中窗, '-') <> '-' Then
        v_Temp := n_中药房 || ':' || v_中窗;
      End If;
    Else
      Return Null;
    End If;
  
    If v_Temp Is Null Then
      Return Null;
    End If;
  
    --发药窗口格式:"药房ID:发药窗口,药房ID:发药窗口"
    v_Split_Str := v_Temp || ',';
    While v_Split_Str Is Not Null Loop
      v_Temp := Substr(v_Split_Str, 1, Instr(v_Split_Str, ',') - 1);
    
      n_药房id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ':') - 1));
      v_Temp   := Substr(v_Temp, Instr(v_Temp, ':') + 1);
    
      If n_药房id = 药房id_In Then
        Return v_Temp;
      End If;
      v_Split_Str := Substr(v_Split_Str, Instr(v_Split_Str, ',') + 1);
    End Loop;
    Return Null;
  End;

Begin

  v_发药窗口 := Null;
  For c_发药窗口 In (Select Distinct 执行部门id, 收费类别, 发药窗口, 病人id
                 From 门诊费用记录 A
                 Where 记录状态 = 0 And a.记录性质 = 1 And a.收费类别 In ('5', '6', '7') And
                       NO In (Select Column_Value From Table(f_Str2list(Nos_In)))) Loop
  
    If Instr(';' || Nvl(v_发药窗口, '-'), ';' || c_发药窗口.执行部门id || '|') = 0 Then
      --a.存在未发药的，先以未发药的为准
      v_Paywin := Getnotpaydrugwinds(c_发药窗口.病人id, c_发药窗口.执行部门id);
      If v_Paywin Is Null Then
        v_Paywin := c_发药窗口.发药窗口;
      End If;
      If v_Paywin Is Null Then
        --b.获取缺省的发药窗口
        v_Paywin := Getdefaultpaydrugwinds(c_发药窗口.收费类别, c_发药窗口.执行部门id);
      End If;
      If v_Paywin Is Null Then
        --b.根据闲忙或平均方式获取发药窗口
        v_Paywin := Zl_Get发药窗口(c_发药窗口.执行部门id);
      End If;
      v_发药窗口 := v_发药窗口 || ';' || c_发药窗口.执行部门id || '|' || v_Paywin;
    End If;
  End Loop;

  Return v_发药窗口;

Exception
  When Others Then
    Return v_发药窗口;
End Zl_Getclinicchargepaywins;
/

--87280:黄捷,2015-08-06,相同原型书写多份报告给出提示
--87379:黄捷,2015-08-10,报告中冗余存储诊断意见
--88799:黄捷,2015-09-24,报告中所有图像都存到FTP中

--影像报告业务(---定义部分---)***************************************************
CREATE OR REPLACE Package b_PACS_RptManage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	);

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In 影像报告记录.报告质量%Type
	);
                                
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	);
                                
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	);

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type 
	);

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	);

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor);

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	);

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	);

 --10、添加文档的操作日志
 Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type);

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	);

  --12、获取签名类型
  Procedure p_Get_SysConfigSignature(
    Val           Out t_Refcur,
	科室ID_In		In 部门表.ID%Type
	);

--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  );


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  );

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  );

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  );

--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In	影像报告驳回.医嘱ID%Type, 
  报告ID_In	影像报告驳回.检查报告ID%Type, 
  驳回理由_In 影像报告驳回.驳回理由%Type, 
  驳回时间_In 影像报告驳回.驳回时间%Type, 
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  );

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  );

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In	影像报告驳回.检查报告ID%Type
  );

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型id_In 影像报告动作.原型id%Type
  );

--20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In  Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In    Varchar2
    );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    );

  --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
    );

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );
  
  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱ID_IN  影像报告记录.医嘱ID%TYPE   
    );
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,  
    科室ID_IN  影像流程参数.科室ID%TYPE
    );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    );

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
    Val           Out t_Refcur,
    医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
    报告ID_IN  影像报告记录.ID%TYPE
    );
  
  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  );

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    );

end b_PACS_RptManage;
/

--影像报告业务(---实现部分---)***************************************************

CREATE OR REPLACE Package Body b_PACS_RptManage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	) Is
  Begin
  
    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 A Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 A
         Set a.锁定人 = 锁定人_In
       Where a.Id = 报告_Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In  影像报告记录.报告质量%Type
	) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatRptQuality;
  
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	) Is
  Begin
     Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatResult;
  
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	) Is
    v_报告发放     影像报告记录.报告发放%Type; 
  Begin
    
    Begin 
		  Select nvl(报告发放,0) Into v_报告发放 From 影像报告记录 where ID=报告Id_In; 
    Exception 
      When Others Then 
        v_报告发放 :=0; 
    End; 
     
    Update 影像报告记录 Set 报告发放 =decode(v_报告发放,0,1,0),报告发放人=decode(v_报告发放,0,当前操作人_In,'') Where ID=报告Id_In; 
     
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_ReportRelease; 

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type
  ) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_设备号    影像报告原型清单.设备号%Type;
    v_报告序号  number;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       number;
    Err_Custom  Exception;
    v_Result    影像报告记录.诊断意见%Type;

    Function Elist_Filter(
    Source_t t_Editlist
    ) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin

      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                   From Table(Cast(Source_t As t_Editlist)) A
                  Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人,
                                            Rs.编辑时间,
                                            Rs.签名,
                                            Rs.审订签名);
      End Loop;
      Return Target_t;
    End;

    Function Build_Editlog(
    Tn_Edit t_Editlist,
    To_Edit t_Editlist,
    v_Did   影像报告记录.Id%Type) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录

      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;

      Function Atitle(原型ID 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型ID Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where ID = 原型ID;
          Return v_原型名称;
        End If;
      End;

    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;

        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4)
          Into n_Class
          From Dual;
        Select Appendchildxml(x_Return,
                              '/root',
                              Xmlelement("operate",
                                         Xmlforest(r_Saveid As "saving_id",
                                                   n_Class As "class",
                                                   To_Char(Cur_Time,
                                                           'yyyy-mm-dd hh24:mi:ss') As
                                                   "cur_time",
                                                   最后编辑人_In As "operator",
                                                   Decode(n_Class,
                                                          4,
                                                          Tns_Edit(Tns_Edit.Count).编辑人,
                                                          '') As "signer",
                                                   '' As Adjunct)))
          Into x_Return
          From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;

        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;

        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                '/root',
                                Xmlelement("operate",
                                           Xmlforest(r_Saveid As "saving_id",
                                                     n_Class As "class",
                                                     To_Char(Cur_Time,
                                                             'yyyy-mm-dd hh24:mi:ss') As
                                                     "cur_time",
                                                     最后编辑人_In As "operator",
                                                     Decode(n_Class,
                                                            4,
                                                            v_Signor,
                                                            6,
                                                            v_Signor,
                                                            '') As "signer",
                                                     v_Adjunct As Adjunct)))
            Into x_Return
            From Dual;
        End If;

      End If;
      Return x_Return;
    End Build_Editlog;

    Function Get_NextRPTNum(
    AntetypeName 影像报告原型清单.名称%Type,
    Order_ID 影像报告记录.医嘱Id%Type
    )
      Return Number Is
        v_序号 Number;
        v_count Number;
        v_num Number;
      Begin

        v_count :=0;
        v_num :=1;
        loop
             select count(*)+v_num into v_序号 from 影像报告记录 where 医嘱ID=Order_ID;
             select count(*) into v_count from 影像报告记录 where 医嘱ID=Order_ID and 文档标题=AntetypeName||'_'||v_序号;

             if v_count =0 then
               exit;
             end if;

             v_num := v_num +1;
         end loop;

         return v_序号;
     End;

  Begin

    Select 名称, 设备号,Sysdate
      Into v_原型名称,v_设备号, Cur_Time
      From 影像报告原型清单
     Where ID = 原型ID_In;

    --------------------1 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_PACS_RptPublic.f_Geteditlist(报告内容_In);

    --------------------2 处理编辑日志--------------------
    select count(*) into v_New from 影像报告记录 where ID=Id_In;

    v_报告id := Id_In;
    select zlpub_pacs_取提纲内容byxml (报告内容_In,'诊断意见') into v_Result from dual;
    If v_New=0 Then
      --新增报告
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);

      --取报告序号
      v_报告序号 := Get_NextRPTNum(v_原型名称,医嘱ID_In);

      Insert Into 影像报告记录
        (ID,
         原型ID,
         文档标题,
         报告内容,
         创建时间,
         创建人,
         报告状态,
         最后编辑时间,
         最后编辑人,
         编辑日志,
         医嘱ID,
         记录人,
         诊断意见,
         设备号)
      Values
        (v_报告id,
         原型ID_In,
         v_原型名称||'_'||v_报告序号,
         报告内容_In,
         Cur_Time,
         最后编辑人_In,
         1,
         Cur_Time,
         最后编辑人_In,
         x_Editlog,
         医嘱ID_In,
         记录人_In,
         v_Result,
         v_设备号);
      Insert Into 病人医嘱报告(医嘱ID,检查报告ID)Values(医嘱ID_In,v_报告id);

    Else
      --提取文件原始编辑记录,必需在更新之前提取
      Select b_PACS_RptPublic.f_Geteditlist(报告内容)
        Into To_Editlist
        From 影像报告记录
       Where ID = v_报告id;

      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志,
                            '/root',
                            Extract(x_Editlog, '/root/*'))
             Into x_Editlog From 影像报告记录 Where ID = v_报告id;

       Update 影像报告记录
                Set 报告内容     = 报告内容_In,
                最后编辑时间 = Cur_Time,
                最后编辑人   = 最后编辑人_In,
                编辑日志     = x_Editlog,
                记录人       =记录人_In,
                诊断意见     =v_Result
                Where ID = v_报告id;
       end if;

  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	) As
  Begin
    Open Val For
      Select  Nvl(a.报告内容.GetClobVal(), '<ZLXML/>') As 报告内容 From 影像报告记录 A Where a.Id = DocID_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor) As
  Begin
    Open Val For
      Select 操作人, 操作时间
        From 影像报告操作记录
       Where 报告ID = 报告ID_In
         And 操作类型=1
         And 操作时间 >= Signdate_In
         And 作废时间 Is Null
       Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 B
       Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
     Where 报告ID = 报告ID_In And 操作类型=1
       And 操作时间 >= Signdate_In;

  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型ID = 原型ID_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;
  
 --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type) As
  n_医嘱ID 影像报告操作记录.医嘱ID%Type;                              
  Begin
    
  Begin
    Select 医嘱ID Into n_医嘱ID From 影像报告记录 Where ID = 报告ID_In;
  Exception
    When Others Then
      null;
  End;
  if n_医嘱ID is not null then 
    Insert Into 影像报告操作记录
      (ID, 报告ID,医嘱ID, 操作人, 操作时间,操作类型)
    Values
      (Id_In, 报告ID_In, n_医嘱ID, 操作人_In, sysdate,操作类型_In);
    if 操作类型_In=1 then 
        update 影像报告记录 set 报告打印=1 where ID=报告ID_In;
    end if;
  end if;
  Exception
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	) As
  Begin    

    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);

    Delete From 病人医嘱报告 Where 检查报告ID =hextoraw(报告_Id_In);

  Exception   
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_删除;


--12、获取签名类型
Procedure p_Get_SysConfigSignature(
  Val           Out t_Refcur,
  科室ID_In		In 部门表.ID%Type
  )Is
Begin
    --返回用户, 模块号,功能
	Open  Val For 
	    select Zl_Fun_Getsignpar(7, 科室ID_In) as 签名类型 from dual;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  )Is
  v_sql Varchar2(1000);
  n_count Number(5);
Begin                
  Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');
  
  If n_Count > 0 Then
     v_sql := 'Truncate Table 影像签名图片';
     Execute Immediate v_sql;   
     
     v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
     Execute Immediate v_sql;  
  Else
     v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;  
     Execute Immediate v_sql;    
  End If; 
    
  v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';
    --返回用户, 模块号,功能
	Open  Val For v_sql Using ID_In;  

Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select ID, CertDN,CertSN,SignCert,EncCert From 人员证书记录 Where ID=证书ID_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  )Is
Begin
  --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
  --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
  if (报告状态_In=1) or (报告状态_In=2) or (报告状态_In=5) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=null,最后审核时间=null Where ID=报告Id_In;
  elsif (报告状态_In=3) or (报告状态_In=4) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=审核人_In,最后审核时间=sysdate Where ID=报告Id_In;
  else
    Update 影像报告记录 Set 报告状态=报告状态_In Where ID=报告Id_In;
  end if;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select 报告状态 From 影像报告记录 Where ID=报告Id_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;



--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In  影像报告驳回.医嘱ID%Type,
  报告ID_In  影像报告驳回.检查报告ID%Type,
  驳回理由_In 影像报告驳回.驳回理由%Type,
  驳回时间_In 影像报告驳回.驳回时间%Type,
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  )Is
Begin
  Insert Into 影像报告驳回(ID, 医嘱ID,检查报告ID,驳回理由,驳回时间,驳回人)
  Values(影像报告驳回_ID.NEXTVAL, 医嘱ID_IN, 报告ID_In, 驳回理由_IN, 驳回时间_IN, 驳回人_IN);

  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人=待处理人_In Where ID=报告ID_In;

  --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  )Is
Begin
  Update 影像报告驳回 Set 是否撤销=1 Where ID=ID_In;
  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人='' Where ID=报告ID_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In  影像报告驳回.检查报告ID%Type
  )Is
Begin
  Open  Val For
    Select A.ID, A.驳回理由, A.驳回时间, A.驳回人, Nvl( A.是否撤销,0) As 驳回状态, B.报告状态
    From 影像报告驳回 A, 影像报告记录 B Where A.检查报告ID=报告Id_In And A.检查报告ID = B.ID Order by 驳回时间;
End;

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型ID_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称 As 动作名称,
			 e.名称 As 事件名称,
			 e.种类 As 事件种类,
			 e.元素IID As 元素IID,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             To_Clob(Nvl(p.内容.GetClobVal(),'<NULL/>')) As 内容, 
             RawtoHex(p.事件ID) 事件ID
        From 影像报告动作 P, 影像报告事件 E
       Where p.事件ID = e.Id(+) And p.原型ID=原型ID_In
       Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In          Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In          Varchar2
  ) As
  Begin

    Open Val For
      Select /*+ rule*/ Rawtohex(a.Id) ID, a.名称, a.作者, a.说明,
             Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 A
      Where a.原型ID = Hextoraw(原型id_In) And
            ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And  b_PACS_RptPublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0)) And
            (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_PACS_RptPublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;

  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    )Is
  begin
       open val for
       select 名称 from 部门表 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_部门名称_By_ID;
    

 --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
  )Is
  begin
       open val for
       Select Rawtohex(ID) ID, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_AllPreOutlines;

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  begin
       open val for
       select 文档标题 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_reportTitle_By_ID;

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  Begin
       Open Val For
         Select 锁定人 From 影像报告记录 Where id =ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_报告锁定人_By_ID;

 --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
	医嘱ID_IN  影像报告记录.医嘱ID%TYPE
    )Is
  Begin
       Open Val For
       Select RawToHex(ID) As REPORTID, RawToHex(原型ID) As ANTETYPEID, 医嘱ID As ORDERID,文档标题 As REPORTNAME,
              创建时间 As REPORTDATE, Decode(Nvl(报告状态,0),1,'编辑中',2,'已诊断',3,'已审核',4,'已终审',5,'诊断驳回','审核驳回') As REPORTSTATE,
              创建人 As CreateUser,最后审核人 As ExamineyUser,Decode(Nvl(结果阳性,0),1,'阳性','') As RESULTPOSITIVE,
              Nvl(报告质量,0) As INNERQUALITY,' ' As REPORTQUALITY, Decode(Nvl(报告打印,0),0,'未打印','已打印') As ReportPrint,
              Decode(Nvl(报告发放,0),0,'未发放','已发放') As REPORTRELEASE ,记录人 as RECDOCTOR From 影像报告记录 Where 医嘱ID =医嘱ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱ID;
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,
	科室ID_IN  影像流程参数.科室ID%TYPE
    )Is
  Begin
       Open val For
       Select 参数名,参数值 From 影像流程参数 Where 科室ID=科室ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    )Is
  Begin
       Open Val For
       Select rawtohex(c.id) As ANTETYPEID , c.名称 As ANTETYPENAME,c.说明 
       From 病人医嘱记录 a,影像报告原型应用 b,影像报告原型清单 c 
       Where a.id=医嘱_IN And a.诊疗项目id=b.诊疗项目ID And b.报告原型ID=c.id And a.病人来源 =b.应用场合;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱ID;

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  )is
  begin
       open val for
       Select  c.文档标题 , b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
               To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
               From 影像报告操作记录 B, 影像报告记录 C
               Where c.Id = 报告_IN And b.报告ID = c.Id And 操作类型=1 Order By b.操作时间;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_ReportPrintLog_By_报告ID;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    )Is
  Begin
       Open val For
       Select rawtohex(ID) As 报告ID, 文档标题 As 报告名称,最后编辑时间 as 报告日期,
              decode(nvl(报告发放,0),0,'未发放','已发放') As 报告发放 
              From 影像报告记录 Where 报告状态 Between 2 And 4 And 医嘱ID =医嘱_IN;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ReportReleaseList;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    )Is
  Begin
       Open val For
       Select count(*) As 驳回数量 From 影像报告驳回 Where 检查报告ID=报告_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RejectedCount;

   --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    )Is
  Begin
       open val for
       select ID as 医嘱ID,主页ID,挂号单 from 病人医嘱记录 where ID=医嘱_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocProcess_IDs;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
       Val           Out t_Refcur,
       医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
       报告ID_IN  影像报告记录.ID%TYPE
  )Is
  Begin
      If 报告ID_IN Is Null Then 
        Open Val For 
        Select 执行科室ID,'创建人' As 创建人 From 影像检查记录 Where 医嘱ID=医嘱ID_IN;
      Else
        Open Val For
        Select 执行科室ID,创建人 From 影像检查记录 A,影像报告记录 b Where a.医嘱ID=B.医嘱ID and b.id=报告ID_IN;
      End if;
       

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocInfo;

  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  )Is
  Begin      
        Open Val For
        Select count(id) as DocCounts From 影像报告记录 Where 医嘱ID=医嘱ID_IN and 原型ID=原型ID_IN;    
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_SameAntetypeDocCounts;

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    )Is
  begin
       open val for
       select 设备号,创建时间 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_DocImageSaveInof_By_ID;

End b_PACS_RptManage;
/



--86408:张德婷,2015-08-04,支付宝只有收费单据才上传
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No,b.记录性质
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And b.执行状态 <> 1 And
          Mod(a.记录状态, 3) = 1 And a.审核人 Is Null
    Order By 药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间)
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In
      Where ID = v_Modifybillout.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.数量, 0), 0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id,
             v_Modifybillout.成本价, v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期,
             v_Modifybillout.批准文号, v_Modifybillout.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id, v_Modifybillout.成本价,
             v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期, v_Modifybillout.批准文号,
             v_Modifybillout.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间




      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In), 5);
      Dbl成本金额  := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型
      Where ID = v_Modifybillin.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.数量, 0), 0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id,
             v_Modifybillin.成本价, v_Modifybillin.批号, v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期,
             v_Modifybillin.批准文号, v_Modifybillin.成本价);
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id, v_Modifybillin.成本价, v_Modifybillin.批号,
             v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期, v_Modifybillin.批准文号, v_Modifybillin.成本价);
        End If;
      End If;
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间




      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  if Bill_In = 8 Then
    Begin
      --移动支付宝项目在发药后动态调用生成推送信息的过程
      Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
        Using 6, No_In || ',' ||Partid_In;
    Exception
      When Others Then
        Null;
    End;
  end if;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--86996:张德婷,2015-08-03,销帐的输液单在配置中心不能进行操作
Create Or Replace Procedure Zl_输液配药记录_取消发送(配药id_In In Varchar2 --ID串:ID1,ID2.... 
                                           ) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_操作人员 输液配药记录.操作人员%Type;
  d_操作时间 输液配药记录.操作时间%Type;
  
  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  Err_Custom Exception;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串 
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
    
    --检查当前输液单的状态是否为已发送状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态!=5 then
        v_Error := '该数据已被操作，不能进行取消发送操作！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Select 操作人员, 操作时间
    Into v_操作人员, d_操作时间
    From (Select 操作人员, 操作时间 From 输液配药状态 Where 配药id = v_Tansid And 操作类型 = 4 Order By 操作时间 Desc)
    Where Rownum = 1;
  
    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = v_操作人员, 操作时间 = d_操作时间 Where ID = v_Tansid;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_取消发送;
/

--86996:张德婷,2015-08-03,输液单被销帐后配置中心不能对其进行操作
Create Or Replace Procedure Zl_输液配药记录_发送
(
  配药id_In   In Varchar2, --ID串:ID1,ID2.... 
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);
  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  Err_Custom Exception;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串 
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
    
     Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>4 then
        v_Error := '该数据已被操作，不能进行发送操作！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
    
    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_Tansid, 5, 操作人员_In, 操作时间_In);
    Update 输液配药记录 Set 操作状态 = 5, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_发送;
/

--86996:张德婷,2015-08-03,输液单销帐后，在配置中心不能进行取消配液操作
CREATE OR REPLACE Procedure Zl_输液配药记录_取消配药(配药id_In In Varchar2 --ID串:ID1,ID2....
                                           ) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_No       Varchar2(20);
  v_Usercode Varchar2(100);
  n_打包     输液配药记录.是否打包%Type := 0;
  v_操作人员 输液配药记录.操作人员%Type;
  d_操作时间 输液配药记录.操作时间%Type;
  
  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  Err_Custom Exception;
  
Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
    
    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态!=4 then
        v_Error := '该数据当前不是配药状态，不能进行取消配药！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
    
    Select 操作人员, 操作时间
    Into v_操作人员, d_操作时间
    From (Select 操作人员, 操作时间 From 输液配药状态 Where 配药id = v_Tansid And 操作类型 = 2 Order By 操作时间 Desc)
    Where Rownum = 1;

    Update 输液配药记录 Set 操作状态 = 2, 操作人员 = v_操作人员, 操作时间 = d_操作时间 Where ID = v_Tansid;

    Select 是否打包 Into n_打包 From 输液配药记录 Where ID = v_Tansid;
    If n_打包 <> 1 Then
      Select Max(NO) Into v_No From 输液配药附费 Where 配药id = v_Tansid;
      if v_No is not null then
        Zl_住院记帐记录_Delete(v_No, 1, v_Usercode, Zl_Username);
      end if;
    Else
      Zl_输液配药记录_取消摆药(v_Tansid);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_取消配药;
/

--86996:张德婷,2015-08-03,销帐之后在配置中心不能在进行其他操作
CREATE OR REPLACE Procedure Zl_输液配药记录_配药
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null
) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_No       Varchar2(20);
  v_Usercode Varchar2(100);
  n_操作状态 输液配药记录.操作状态%Type;
  v_Error    Varchar2(255); 
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id, f.是否肿瘤药
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And e.药名id = f.药名id And Nvl(c.是否打包, 0) <> 1 And c.Id = v_Tansid
    Order By Nvl(是否肿瘤药, 0) Desc;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
    
    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>3 then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_Tansid, 4, 操作人员_In, 操作时间_In);

    
    For r_Bill In c_Bill Loop
      For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                     From 收费项目目录 A, 收费价目 B, 收入项目 D, 收费特定项目 E
                     Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = e.收费细目id And
                           e.特定项目 = Decode(r_Bill.是否肿瘤药, 1, '肿瘤配置费', '普通配置费') And b.执行日期 <= Sysdate And
                           (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
        Select Nextno(14) Into v_No From Dual;
        Insert Into 输液配药附费 (配药id, NO) Values (v_Tansid, v_No);
        
        Zl_住院记帐记录_Insert(v_No, 1, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                         r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                         r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null, r_Bill.库房id, Null,
                         r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null, Sysdate, Sysdate, Null, Null,
                         v_Usercode, 操作人员_In);
      End Loop;
      Exit;
    End Loop;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_配药;
/

--87450:马政,2015-08-28,财务审核修改采购价库存表平均成本价错误
Create Or Replace Procedure Zl_药品外购_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   Number,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  全部冲销_In   In 药品收发记录.实际数量%Type := 0, --用于财务审核
  财务审核_In   In Number := 0, --财务审核标志
  摘要_In       In 药品收发记录.摘要%Type,
  发票代码_In   In 应付记录.发票代码%Type := Null
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isbatch Exception;
  Err_Isnonum Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_应付id       应付记录.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_供药单位id   药品收发记录.供药单位id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     Number;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_冲销数量     Number;
  v_单量         药品收发记录.单量%Type;
  v_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  v_剩余金额差   药品收发记录.零售金额%Type;
  v_冲销金额差   药品收发记录.零售金额%Type;
  v_加成率       药品收发记录.频次%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_计划id       药品收发记录.计划id%Type;

  v_核查人   药品收发记录.配药人%Type;
  v_核查日期 药品收发记录.配药日期%Type;
  v_发药方式 Number;
  v_收发id   药品收发记录.Id%Type;

  v_药库分批         Integer;
  v_药房分批         Integer;
  v_分批属性         Integer;
  v_药库             Integer;
  v_分批             Number;
  v_入库id           Number;
  v_差价修正金额     药品收发记录.零售金额%Type;
  v_差价修正冲销金额 药品收发记录.零售金额%Type;
  v_原成本价         药品收发记录.成本价%Type;
  n_收发id           药品收发记录.Id%Type;

  Intdigit   Number;
  v_发票金额 Number;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  --取核查人
  Select Min(配药人) 配药人, Min(配药日期) 配药日期, Sum(实际数量) 实际数量
  Into v_核查人, v_核查日期, v_冲销数量
  From 药品收发记录
  Where NO = No_In And 单据 = 1 And 序号 = 序号_In
  Group By 配药人, 配药日期;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3), 费用id = 财务审核_In
    Where NO = No_In And 单据 = 1 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 1 And
          Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, Sum(To_Number(Nvl(a.用法, 0))) As 金额差, a.库房id,
         a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.发药方式, a.单量,
         a.生产日期, a.批准文号, a.频次, a.计划id
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_剩余金额差, v_库房id, v_供药单位id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率,
       v_零售价, v_药库分批, v_药房分批, v_发药方式, v_单量, v_生产日期, v_批准文号, v_加成率, n_计划id
  From 药品收发记录 A, 药品规格 B
  Where a.No = No_In And a.药品id = b.药品id And a.单据 = 1 And a.药品id = 药品id_In And a.序号 = 序号_In
  Group By a.库房id, a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批,
           a.发药方式, a.单量, a.生产日期, a.批准文号, a.频次, a.计划id;

  --如果是退库单据，并且是分批药品时，提取原始入库单据的ID
  If Nvl(v_发药方式, 0) = 1 Then
    Begin
      Select ID
      Into v_入库id
      From 药品收发记录
      Where NO = No_In And 单据 = 1 And 药品id = 药品id_In And 序号 = 序号_In And (记录状态 = 1 Or Mod(记录状态, 3) = 0);
    Exception
      When Others Then
        v_入库id := 0;
    End;
  End If;

  --判断该部门是药库还是药房
  Begin
    Select Distinct 0
    Into v_药库
    From 部门性质说明
    Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = v_库房id;
  Exception
    When Others Then
      v_药库 := 1;
  End;

  --根据部门性质,判断分批特性
  If v_药库 = 0 Then
    v_分批属性 := v_药房分批;
  Else
    v_分批属性 := v_药库分批;
  End If;

  --V_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
  v_分批 := 0;
  If v_分批属性 = 1 And v_批次 <> 0 Then
    v_分批 := v_批次;
  End If;

  --全部冲销或者财务审核时，冲销数量等于剩余数量；其他情况冲销数量等于传入的冲销数量
  If 全部冲销_In = 1 Or 财务审核_In = 1 Then
    v_冲销数量 := v_剩余数量;
  Else
    v_冲销数量 := 冲销数量_In;
  End If;

  --冲销数量不能大于剩余数量（主要防止并发）
  If Abs(v_剩余数量) < Abs(v_冲销数量) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  --如果有金额差，则要冲销金额差
  v_冲销金额差 := 0;
  If v_剩余金额差 <> 0 Then
    If 全部冲销_In = 1 Or 财务审核_In = 1 Then
      v_冲销金额差 := v_剩余金额差;
    Else
      v_冲销金额差 := Round(v_冲销数量 / v_剩余数量 * v_剩余金额差, Intdigit);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价,
     摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 发药方式, 单量, 生产日期, 批准文号, 用法, 频次, 费用id, 计划id)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 1, No_In, 序号_In, v_库房id, v_供药单位id, v_入出类别id, 1, 药品id_In, v_批次, v_产地,
     v_批号, v_效期, -v_冲销数量, -v_冲销数量, v_成本价, -v_成本金额, v_扣率, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, v_核查人, v_核查日期,
     填制人_In, 填制日期_In, v_发药方式, v_单量, v_生产日期, v_批准文号, Decode(v_冲销金额差, 0, Null, -v_冲销金额差), v_加成率, 财务审核_In, n_计划id);

  --冲销单据如果计划id不为空则需要处理计划单据的执行数量
  If n_计划id Is Not Null Then
    Update 药品计划内容 Set 执行数量 = Nvl(执行数量, 0) - v_冲销数量 Where 计划id = n_计划id And 药品id = 药品id_In;
  End If;
  --调用库存更新过程
  If 财务审核_In = 0 Then
    Zl_药品库存_Update(v_收发id, 0);
  Else
    --财务审核时，为了保证以前的价格不变则必须保证库存表数据即使为0也不能删掉
    Zl_药品库存_Update(v_收发id, 0, 0, 0, 1);
  End If;

  --对于冲销的单据也应该对应付余额表进行处理
  --只对填了发票号的记录进行处理
  v_发票金额 := Nvl(发票金额_In, 0);
  If Nvl(发票号_In, ' ') <> ' ' Or Nvl(发票金额_In, 0) <> 0 Then
    --对于财务审核的，要将剩余的发票金额全部冲销
    If 全部冲销_In = 1 Then
      Select Sum(b.发票金额)
      Into v_发票金额
      From (Select ID From 药品收发记录 Where 单据 = 1 And NO = No_In And 序号 = 序号_In) A, 应付记录 B
      Where a.Id = b.收发id And b.系统标识 = 1 And b.记录性质 <> -1;
    End If;
  
    Update 应付余额 Set 金额 = Nvl(金额, 0) - Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, -nvl(v_发票金额, 0));
    End If;
  
    Delete From 应付余额 Where 单位id = v_供药单位id And 金额 = 0;
  End If;

  --产生应付记录的冲销记录(先判断应付记录中是否已存在该记录对应的冲销记录,是则更新;否则新增)
  Select 应付记录_Id.Nextval Into v_应付id From Dual;
  Insert Into 应付记录
    (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人, 填制日期,
     审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 库房id, 发票修改时间, 发票代码)
    Select v_应付id, 记录性质, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 单位id, NO, 1, v_收发id, 入库单据号, -v_零售金额, 发票号, 发票日期, -v_发票金额,
           品名, 规格, 产地, 批号, 计量单位, -v_冲销数量, 采购价, -采购价 * v_冲销数量, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In, 摘要, 项目id, 序号, 随货单号, 库房id,
           Sysdate, 发票代码
    From 应付记录
    Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
          记录性质 = 0;

  Update 应付记录
  Set 记录状态 = 3
  Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
        记录性质 = 0;

  --处理调价后冲销（财务审核时不需要处理）
  If 财务审核_In = 0 Then
    Zl_药品收发记录_调价修正(v_收发id);
  End If;

  --如果是退库单据，并且是分批药品，则根据入库收发ID冲销对应的差价调整单据
  If Nvl(v_发药方式, 0) = 1 Then
    --取差价调整单据的剩余差价金额
    Begin
      Select Sum(差价) 差价, 扣率
      Into v_差价修正金额, v_原成本价
      From 药品收发记录
      Where 单据 = 5 And 费用id = v_入库id And 药品id = 药品id_In
      Group By 扣率;
    Exception
      When Others Then
        v_差价修正金额 := 0;
    End;
  
    If v_差价修正金额 <> 0 Then
      --按冲销数量计算冲销差价金额
      v_差价修正冲销金额 := Round(v_冲销数量 / v_剩余数量 * v_差价修正金额, Intdigit);
      Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      --产生冲销记录
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
        Select n_收发id, Decode(记录状态, 1, 2, 记录状态 + 2), 5, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期,
               -v_冲销数量, 零售价, 成本价, -v_差价修正冲销金额, 摘要, 填制人, 填制日期, 填制人_In, 填制日期_In, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id
        From 药品收发记录
        Where 单据 = 5 And 费用id = v_入库id And 药品id = 药品id_In And (记录状态 = 1 Or Mod(记录状态, 3) = 0);
    
      --修改原始单据的记录状态
      Update 药品收发记录
      Set 记录状态 = Decode(记录状态, 1, 3, 记录状态 + 3)
      Where 单据 = 5 And 费用id = v_入库id And 药品id = 药品id_In And (记录状态 = 1 Or Mod(记录状态, 3) = 0);
      --更新库存
      Zl_药品库存_Update(n_收发id);
    
    End If;
  End If;
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品冲销的数量大于了剩余数量，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Strike;
/

--87091:马政,2015-08-03,退药，冲销成本价处理
--87450:马政,2015-08-28,财务审核修改采购价库存表平均成本价错误
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  Delete_In   In Number := 0,
  冲销方式_In In Number := 0,
  发药标志_In In Number := 0,
  财务审核_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:根据明细数据更新库存
  --关键：根据下可用库存参数决定是否处理可用数量
  --业务规则：按照模块分开处理数据，便于后期维护
  --过程适用范围：药品流通业务，涉及到产生药品收发记录明细后再更新库存表并重算库存表平均成本价的业务，该过程
  --只能由其他过程内部调用，不能作为单独过程直接执行
  --参数:
  --     Id_In:药品业务新增、删除、审核、冲销时产生收发记录明细的id
  --     Delete_in: 0--非删除操作业务（新增、审核、冲销） 1--删除操作业务
  --     冲销方式_In: 0--正常冲销方式 1-产生冲销申请单据 2-发送 3-回退 目前只有移库模块有效
  --     发药标志_in: 0--不标记  1--标记  此参数只有药品处方、部门发药模块有效
  --     财务审核_in:0,财务审核单据,1-其他业务
  ----------------------------------------------------------------------------------------
  v_下可用数量 Zlparameters.参数值%Type;
  n_可用数量   药品库存.实际数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_差价       药品库存.实际差价%Type;
  n_时价分批   Number(1);
  n_成本价     药品收发记录.成本价%Type;
  n_零售价     药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;

  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  v_Detail c_Detail%RowType;
Begin
  --取下可用库存参数
  Select Zl_Getsysparameter(96) Into v_下可用数量 From Dual;

  For v_Detail In c_Detail Loop
    n_实际数量 := v_Detail.入出系数 * v_Detail.实际数量 * Nvl(v_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_零售金额 := v_Detail.入出系数 * v_Detail.零售金额;
    n_差价     := v_Detail.入出系数 * v_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), Nvl(平均成本价, 0)
      Into n_库存数量, n_库存平均价
      From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
    Exception
      When Others Then
        n_库存数量   := 0;
        n_库存平均价 := 0;
    End;
  
    --外购入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，退库模式时在填单时要根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --冲销时直接按数量加减库存可用数量
    --用数量判断是入库还是退库
    If v_Detail.单据 = 1 Then
      If v_Detail.审核日期 Is Null Then
        --未审核单据，填单或删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --已审核或已冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            --退库要考虑填单时已经处理了可用数量
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --自制入库：对于自制药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于原料药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 2 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --协定入库：对于协定药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于组成药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 3 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --其他入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，负数入库模式时要根据参数处理可用数量，在审核时则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --用数量判断是入库还是退库
    If v_Detail.单据 = 4 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --差价调整，成本价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 5 Then
      n_可用数量 := 0;
    End If;
  
    --移库：移库有两条单据，一条出库单据，一条入库单据；出库单据需要根据下可用库存参数决定是否下可用库存，如果是冲销则可用库存则相反处理
    --在填单不减可用数量时，在发送时预减可用数量，审核时不处理可用数量
    --申请冲销模式时也要根据参数来处理可用数量
    --填单时出库业务根据参数决定是否下库存，入库业务不下库存；删除时出库业务更加参数要把库存还回去，入库业务不还库存
    If v_Detail.单据 = 6 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          --新增、修改、发送、回退、冲销申请
          If v_Detail.记录状态 = 1 Then
            If 冲销方式_In = 2 Then
              --发送
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Elsif 冲销方式_In = 3 Then
              --回退
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := -1 * n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Else
              --新增
              If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            End If;
          Else
            --申请冲销
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        Else
          --删除
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Elsif v_Detail.配药日期 Is Not Null And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = -1 Then
            --出的那笔
            n_可用数量 := 0;
          Else
            --入的那笔
            n_可用数量 := n_实际数量;
          End If;
        Else
          If 冲销方式_In = 0 Then
            --正常冲销审核
            n_可用数量 := n_实际数量;
          Else
            --申请冲销审核
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --领用：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 7 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --发药业务：在填单时固定处理可用数量，在审核时不处理
    --删除单据时要把填单时预减的加回去
    --不再发药标记的可用数量处理等同于删除，填单操作
    If v_Detail.单据 = 8 Or v_Detail.单据 = 9 Or v_Detail.单据 = 10 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          If 发药标志_In = 0 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := -1 * n_实际数量;
          End If;
        Else
          n_可用数量 := -1 * n_实际数量;
        End If;
      Else
        n_可用数量 := 0;
      End If;
    End If;
  
    --其他出库：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 11 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --冲销和审核
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --盘点：填单时盘盈业务不处理可用数量，盘亏业务固定处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    --用入出系数区分盘盈盘亏业务
    If v_Detail.单据 = 12 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --售价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 13 Then
      n_可用数量 := 0;
    End If;
  
    --药品留存：产生发药单据时，已经下了库存，部门发药时，需要将库存加回去
    If v_Detail.单据 = 27 Then
      n_可用数量 := n_实际数量;
    End If;
  
    If v_Detail.批次 > 0 And v_Detail.是否变价 = 1 Then
      n_时价分批 := 1;
    Else
      n_时价分批 := 0;
    End If;
  
    n_零售价 := v_Detail.零售价;
    --特殊单据需要处理成本价 特殊单据有单据=5 单据=12
    If v_Detail.单据 = 5 Or v_Detail.单据 = 12 Then
      If v_Detail.单据 = 5 Then
        If v_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(v_Detail.零售价, 0) / v_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If v_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := v_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(v_Detail.零售价, 0) - Nvl(v_Detail.成本价, 0)) / v_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = v_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := v_Detail.单量;
      End If;
    Else
      If v_Detail.单据 = 13 Then
        n_成本价 := Nvl(v_Detail.单量, 0) - Nvl(v_Detail.频次, 0);
      Else
        n_成本价 := v_Detail.成本价;
      End If;
    End If;
  
    --根据业务数据更新库存记录
    If v_Detail.审核日期 Is Null Then
      If n_可用数量 <> 0 Then
        --填单，删除时只更新可用数量
        Update 药品库存
        Set 可用数量 = 可用数量 + n_可用数量
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, 0, 0, 0, v_Detail.供药单位id, n_成本价,
             v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号, Decode(n_时价分批, 1, n_零售价, Null),
             v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        End If;
      End If;
    Else
      --审核时更新库存可用数量，实际数量，库存金额，库存差价等数据
      If v_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If v_Detail.摘要 = '外购退库差价误差自动修正' Or v_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, n_差价, v_Detail.批号, v_Detail.效期, v_Detail.产地,
               v_Detail.供药单位id, v_Detail.生产日期, v_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          End If;
        End If;
      Elsif v_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        Update 药品库存
        Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价分批, 1, n_零售价, Null));
        Else
          If n_时价分批 = 1 Then
            Update 药品库存
            Set 零售价 = 实际金额 / 实际数量
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                  Nvl(实际数量, 0) <> 0;
          End If;
        End If;
      Else
        --按入库和出库 状态分解
        --入库业务,出库冲销，不分批多种价格入库冲销需要更新库存表所有信息
        If (v_Detail.入出系数 = 1 And v_Detail.记录状态 = 1) Or (v_Detail.入出系数 = -1 And Mod(v_Detail.记录状态, 3) = 2) Or
           (v_Detail.入出系数 = 1 And Mod(v_Detail.记录状态, 3) = 2) Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = v_Detail.供药单位id,
              上次采购价 = Decode(v_Detail.单据, 1, Decode(v_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(v_Detail.批号, 上次批号), 上次生产日期 = Nvl(v_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(v_Detail.产地, 上次产地),
              灭菌效期 = Nvl(v_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(v_Detail.效期, 效期), 批准文号 = Nvl(v_Detail.批准文号, 批准文号),
              上次扣率 = Decode(v_Detail.单据, 1, v_Detail.扣率, 上次扣率), 商品条码 = Nvl(v_Detail.商品条码, 商品条码),
              内部条码 = Nvl(v_Detail.内部条码, 内部条码)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          --外购入库和其他入库审核时
          If (v_Detail.单据 = 1 And v_Detail.记录状态 = 1 And 财务审核_In = 0) Or (v_Detail.单据 = 4 And v_Detail.记录状态 = 1) Then
            Update 药品库存
            Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null)
            Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          End If;
          --不分批入库需要重算成本价
          --外购退货、财务审核和所有冲销业务不更新平均成本价，保持当前价格
          If (v_Detail.单据 = 1 And v_Detail.发药方式 = 1) Or Mod(v_Detail.记录状态, 3) = 2 Or (v_Detail.单据 = 1 And 财务审核_In = 1) Then
            Null;
          Else
            --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
            n_总数量 := (n_库存数量 + n_实际数量);
            If n_总数量 <> 0 Then
              n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
              Update 药品库存
              Set 平均成本价 = n_总成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          --出库业务只需要更新数量、金额、差价
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        End If;
        --库存表未找到数据则需要产生库存表所有信息
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, v_Detail.供药单位id,
             n_成本价, v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号,
             Decode(n_时价分批, 1, n_零售价, Null), v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        End If;
        If n_时价分批 = 1 And v_Detail.单据 = 12 Then
          Update 药品库存
          Set 零售价 = 实际金额 / 实际数量
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And
                Nvl(实际数量, 0) <> 0;
          If Sql%NotFound Then
            Update 药品库存
            Set 零售价 = n_零售价
            Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          End If;
        End If;
      End If;
    End If;
  
    --删除多余的库存数据
    If 财务审核_In = 0 Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/


--87245:马政,2015-09-01,财务审核冲销后再财务审核修正
--80594:马政,2015-08-03,售价调价产生NO号方式调整
--87091:马政,2015-08-03,退药，冲销成本价处理
Create Or Replace Procedure Zl_药品外购_Verify
(
  Newno_In    In 药品收发记录.No%Type := Null,
  Oldno_In    In 药品收发记录.No%Type := Null,
  审核人_In   In 药品收发记录.审核人%Type := Null,
  审核日期_In In 药品收发记录.审核日期%Type := Sysdate
) Is
  Err_Isverified Exception;
  Err_Isbatch Exception;
  v_Druginf        Varchar2(50); --原不分批现在分批的药品信息
  v_供药单位id     药品收发记录.供药单位id%Type;
  v_发票金额       应付记录.发票金额%Type;
  v_可用数量       药品库存.可用数量%Type;
  v_时价分批       Number(1);
  n_原成本价       药品收发记录.成本价%Type;
  v_Newno          药品收发记录.No%Type;
  n_New序号        Number;
  n_收发id         药品收发记录.Id%Type;
  n_调整额         药品收发记录.零售金额%Type;
  n_入出类别id     药品收发记录.入出类别id%Type;
  n_售价入出类别id 药品收发记录.入出类别id%Type;
  n_入出系数       药品收发记录.入出系数%Type;
  n_平均成本价     药品库存.平均成本价%Type;
  n_冲销成本价     药品收发记录.成本价%Type;
  n_冲销售价       药品收发记录.零售价%Type;
  v_Billno         药品收发记录.No%Type;

  Cursor c_药品收发记录 Is
    Select a.Id, a.零售价, a.实际数量, a.零售金额, a.差价, a.库房id, a.药品id, a.批次, a.供药单位id, a.成本价, a.批号, a.效期, a.产地, a.入出类别id, a.生产日期,
           a.批准文号, Nvl(b.是否变价, 0) As 时价, Nvl(a.发药方式, 0) As 退库, a.灭菌效期, a.扣率, Nvl(a.计划id, 0) As 计划id,
           Nvl(a.费用id, 0) As 费用id, a.序号
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1
    Order By a.药品id;
Begin

  n_New序号 := 1;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;

  Select 类别id Into n_售价入出类别id From 药品单据性质 Where 单据 = 13 And Rownum < 2;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In
  Where NO = Newno_In And 单据 = 1 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = Newno_In And a.单据 = 1 And
          a.记录状态 = 1 And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  --原分批现不分批的药品,在审核时，要处理他
  Update 药品收发记录
  Set 批次 = 0
  Where ID In
        (Select ID
         From 药品收发记录 A, 药品规格 B
         Where b.药品id = a.药品id And a.No = Newno_In And a.单据 = 1 And a.记录状态 = 1 And Nvl(a.批次, 0) > 0 And
               (Nvl(b.药库分批, 0) = 0 Or
               (Nvl(b.药房分批, 0) = 0 And
               a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室')))));

  For v_药品收发记录 In c_药品收发记录 Loop
    --处理采购计划表中的执行数量，多次导入采用累加执行数量
    If v_药品收发记录.计划id > 0 Then
      Update 药品计划内容
      Set 执行数量 = Nvl(执行数量, 0) + v_药品收发记录.实际数量
      Where 计划id = v_药品收发记录.计划id And 药品id = v_药品收发记录.药品id;
    End If;
    --调用库存更新记录更新库存表
    If Oldno_In Is Null Then
      Zl_药品库存_Update(v_药品收发记录.Id, 0);
    Else
      Zl_药品库存_Update(v_药品收发记录.Id, 0, 0, 0, 1);
    End If;
  
    --如果是分批药品退库，取原来的成本价
    If v_药品收发记录.退库 = 1 Then
      Begin
        Select 平均成本价
        Into n_原成本价
        From 药品库存
        Where 性质 = 1 And 库房id = v_药品收发记录.库房id And 药品id = v_药品收发记录.药品id And Nvl(批次, 0) = Nvl(v_药品收发记录.批次, 0);
      Exception
        When Others Then
          n_原成本价 := 0;
      End;
    End If;
  
    If v_药品收发记录.时价 = 1 Then
      Update 药品规格 Set 上次售价 = v_药品收发记录.零售价 Where 药品id = v_药品收发记录.药品id;
    End If;
  
    If v_药品收发记录.退库 = 0 Then
      --更新该药品的成本价
      Update 药品规格
      Set 成本价 = v_药品收发记录.成本价, 上次供应商id = v_药品收发记录.供药单位id, 上次批号 = v_药品收发记录.批号, 上次生产日期 = v_药品收发记录.生产日期, 上次产地 = v_药品收发记录.产地,
          上次批准文号 = v_药品收发记录.批准文号
      Where 药品id = v_药品收发记录.药品id;
    End If;
  
    --如果是分批药品退库，则检查成本价是否变动，如果变动，则产生差价调整记录并修正库存差价
    If Oldno_In Is Null Then
      If v_药品收发记录.退库 = 1 Then
        If n_原成本价 <> 0 And n_原成本价 <> v_药品收发记录.成本价 Then
          If v_Newno Is Null Then
            v_Newno := Nextno(25, v_药品收发记录.库房id);
          End If;
        
          --产生库存差价调整单
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        
          n_调整额 := (v_药品收发记录.零售金额 - v_药品收发记录.差价) - Round(n_原成本价 * v_药品收发记录.实际数量, 2);
        
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
             审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Values
            (n_收发id, 1, 5, v_Newno, n_New序号, v_药品收发记录.库房id, n_入出类别id, v_药品收发记录.供药单位id, n_入出系数, v_药品收发记录.药品id,
             v_药品收发记录.批次, v_药品收发记录.产地, v_药品收发记录.批号, v_药品收发记录.效期, v_药品收发记录.实际数量, v_药品收发记录.零售金额, v_药品收发记录.差价, n_调整额,
             '外购退库差价误差自动修正', Nvl(审核人_In, Zl_Username), 审核日期_In, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.生产日期,
             v_药品收发记录.批准文号, v_药品收发记录.成本价, 0, n_原成本价, v_药品收发记录.灭菌效期, v_药品收发记录.Id);
        
          n_New序号 := n_New序号 + 1;
          --更新库存
          Zl_药品库存_Update(n_收发id);
        End If;
      End If;
    Else
      Select distinct 成本价, 零售价
      Into n_冲销成本价, n_冲销售价
      From 药品收发记录
      Where NO = Oldno_In And 药品id = v_药品收发记录.药品id And Nvl(批次, 0) = Nvl(v_药品收发记录.批次, 0) And 序号 = v_药品收发记录.序号 And 单据 = 1 And
            Mod(记录状态, 3) = 2;
      If n_冲销成本价 <> v_药品收发记录.成本价 Then
        --产生库存差价调整单
        v_Newno := Nextno(25, v_药品收发记录.库房id);
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
      
        n_调整额 := Round((v_药品收发记录.成本价 - n_冲销成本价) * v_药品收发记录.实际数量, 2);
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
        Values
          (n_收发id, 1, 5, v_Newno, n_New序号, v_药品收发记录.库房id, n_入出类别id, v_药品收发记录.供药单位id, n_入出系数, v_药品收发记录.药品id, v_药品收发记录.批次,
           v_药品收发记录.产地, v_药品收发记录.批号, v_药品收发记录.效期, v_药品收发记录.实际数量, v_药品收发记录.零售金额, v_药品收发记录.差价, n_调整额, '财务审核价格变动修正',
           Nvl(审核人_In, Zl_Username), 审核日期_In, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.生产日期, v_药品收发记录.批准文号,
           v_药品收发记录.成本价, 0, n_冲销成本价, v_药品收发记录.灭菌效期, v_药品收发记录.Id);
      
        n_New序号 := n_New序号 + 1;
      
        --更新库存
        Zl_药品库存_Update(n_收发id);
      End If;
    
      --更新售价
      If n_冲销售价 <> v_药品收发记录.零售价 Then
        Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
        Select Nextno(147) Into v_Billno From Dual;
      
        n_调整额 := Round((n_冲销售价 - v_药品收发记录.零售价) * v_药品收发记录.实际数量, 2);
      
        --产生调价修正记录
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
           填制日期, 库房id, 入出系数, 审核人, 审核日期, 费用id)
        Values
          (n_收发id, 1, 13, v_Billno, n_New序号, n_售价入出类别id, v_药品收发记录.药品id, v_药品收发记录.批次, v_药品收发记录.批号, v_药品收发记录.效期,
           v_药品收发记录.产地, 1, v_药品收发记录.实际数量, 0, n_冲销售价, 0, v_药品收发记录.零售价, 0, n_调整额, n_调整额, '财务审核价格变动修正',
           Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.库房id, 1, Nvl(审核人_In, Zl_Username), 审核日期_In, v_药品收发记录.Id);
      
        n_New序号 := n_New序号 + 1;
        --更新药品库存
        Zl_药品库存_Update(n_收发id);
      End If;
    End If;
  End Loop;

  --对应付余额表进行处理
  --此处用一个块，主要是解决没有对应发票号的记录
  Begin
    Update 应付记录
    Set 审核人 = 审核人_In, 审核日期 = 审核日期_In
    Where 入库单据号 = Newno_In And 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1;
  
    Select b.单位id, Sum(发票金额)
    Into v_供药单位id, v_发票金额
    From 药品收发记录 A, 应付记录 B
    Where a.Id = b.收发id And a.No = Newno_In And a.单据 = 1 And b.系统标识 = 1
    Group By b.单位id;
  
    If Nvl(v_供药单位id, 0) <> 0 Then
      Update 应付余额 Set 金额 = Nvl(金额, 0) + Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
    
      If Sql%NotFound Then
        Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, v_发票金额);
      End If;
    End If;
  Exception
    When No_Data_Found Then
      Null;
  End;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Verify;
/

--80594:马政,2015-08-03,财务审核
--87091:马政,2015-08-03,退药，冲销成本价处理
Create Or Replace Procedure Zl_药品收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_审核日期     药品收发记录.审核日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_费用单价精度 Number;
  d_填制日期     药品收发记录.填制日期%Type;
  d_日期         药品收发记录.填制日期%Type;
  n_记录状态     药品收发记录.记录状态%Type;
  n_当前数量     药品库存.实际数量%Type;
  v_Billno       药品收发记录.No%Type;
Begin

  --1、售价调剂处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.记录状态, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出系数,
         Nvl(a.零售价, 0) 原价, b.现价, Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id
  Into v_单据, n_记录状态, v_库房id, v_药品id, v_批次, v_实际数量, v_入出系数, v_原价, v_现价, v_是否变价, v_价格id
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5')) Into n_费用单价精度 From Dual;
  If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
    --发药应该取费用精度，其他业务应该取药品卫材精度中精度
    Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into v_金额精度 From Dual;
  Else
    Select Nvl(精度, 2) Into v_金额精度 From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  End If;
  --定价直接取收费价目中现价
  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    v_执行修正 := 1;
  Else
    --时价药品的现售价，不能从收费价目中取，因为时价调价可能是按库房和批次来调整的
    v_现价 := 0;
  
    If v_批次 > 0 Then
      --时价分批优先从库存表中取，时价不分批则直接在明细表中查调价记录的零售价
      --从库存记录中取现价
      Begin
        Select Nvl(零售价, 0)
        Into v_现价
        From 药品库存
        Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 = 0 Then
      Begin
        --取原始单据的审核时间
        Select a.审核日期, a.填制日期
        Into v_审核日期, d_填制日期
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
        If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
          d_日期 := d_填制日期;
        Else
          d_日期 := v_审核日期;
        End If;
      
        If Months_Between(Sysdate, d_日期) <= 1 Then
          --只处理小于一个月的数据
          --从调价记录中取现零售价
          Select 零售价, 价格id
          Into v_现价, v_价格id
          From (Select 零售价, 价格id
                 From 药品收发记录
                 Where 单据 = 13 And 摘要 = '药品调价' And 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And
                       审核日期 Between d_日期 And Sysdate
                 Order By 审核日期 Desc)
          Where Rownum = 1;
        End If;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 > 0 Then
      v_执行修正 := 1;
    End If;
  End If;

  If v_执行修正 = 1 Then
    --发药类单据售价精度为5，其他流通类单据为7
    If v_单据 = 8 Or v_单据 = 9 Or v_单据 = 10 Then
      v_售价精度 := n_费用单价精度;
    Else
      v_售价精度 := 7;
    End If;
  
    --比较原价和现价，不同则处理
    If v_原价 <> Round(v_现价, v_售价精度) Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Select Nextno(147) Into v_Billno From Dual;
    
      Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 13;
    
      v_修正金额 := Round(v_入出系数 * (Round(v_现价, v_售价精度) - v_原价) * v_实际数量, v_金额精度);
    
      --产生调价修正记录
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
         填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
        Select v_收发id, 1, 13, v_Billno, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, Abs(v_实际数量), 0, v_原价, 0,
               Round(v_现价, v_售价精度), 扣率, v_修正金额, v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新药品库存
      Zl_药品库存_Update(v_收发id);
    End If;
  End If;

  --2、成本价调价，只有冲销业务才修正
  If Mod(n_记录状态, 3) = 2 Then
    Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * Nvl(实际数量, 0) * Nvl(付数, 1) As 实际数量, 入出系数 * 零售金额, 入出系数 * 差价, 成本价
    Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
    From 药品收发记录
    Where ID = 收发id_In;
  
    --取原始单据的审核时间
    Select a.审核日期
    Into v_审核日期
    From 药品收发记录 A, 药品收发记录 B
    Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
          (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
  
    v_执行修正 := 0;
    Begin
      Select 1, 新成本价
      Into v_执行修正, v_现价
      From 成本价调价信息
      Where 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And 执行日期 > v_审核日期 And Rownum = 1
      Order By 执行日期 Desc;
    
    Exception
      When Others Then
        v_执行修正 := 0;
        v_现价     := 0;
      
        --可能出现冲销或者退库很久以前的数据,这个时候价格可能已经发生变化,所以需要修正
        Begin
          Select 平均成本价, Nvl(实际数量, 0) As 实际数量
          Into v_现价, n_当前数量
          From 药品库存
          Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
        
          --无库存不处理，有库存可能有两种情况，1.原始有库存，冲销抵消后还有数量，2、原始无数量，新库存数据来源于冲销单据
          --如果是1情况那么则通过库存表原价格与冲销价格比较即可
          --如果是2情况那么则需要判断当前库存数量与冲销数量*入出系数是否相等，如果相等则说明肯定是原始无库存然后冲销根据产生的
          --这个时候需要粗略判断，只能通过规格来，另加一下价格判断，如价格为负数
          If n_当前数量 = v_实际数量 Then
            --说明是第二种情况产生的库存数据，这个时候可能产生的数据很离谱，则需要简单判断
            Select 成本价 Into v_现价 From 药品规格 Where 药品id = v_药品id;
            If Abs(Abs(v_现价) - Abs(v_原价)) > 1 Then
              v_执行修正 := 1;
            End If;
          Else
            --说明是第一种情况产生的数据，直接用当前库存与冲销单据价格比较即可
            If Round(v_现价, 2) <> Round(v_原价, 2) Then
              v_执行修正 := 1;
            End If;
          End If;
        Exception
          When Others Then
            v_执行修正 := 0;
        End;
    End;
  
    If v_执行修正 = 1 Then
      v_修正金额 := (v_零售金额 - v_差价) - Round(Round(v_现价, 3) * v_实际数量, v_金额精度);
    
      If v_修正金额 <> 0 Then
        Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
        Select b.Id, b.系数
        Into v_入出类别id, v_入出系数
        From 药品单据性质 A, 药品入出类别 B
        Where a.类别id = b.Id And a.单据 = 5 And Rownum < 2;
      
        v_No := Nextno(25, v_库房id);
      
        --产生库存差价调整单
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期,
           审核人, 审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
          Select v_收发id, 1, 5, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价,
                 v_修正金额, '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
          From 药品收发记录
          Where ID = 收发id_In;
      
        --更新库存
        Zl_药品库存_Update(v_收发id);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_调价修正;
/

--86996:张德婷,2015-07-31,销帐申请之后不能进行摆药操作
CREATE OR REPLACE Procedure Zl_输液配药记录_摆药
(
  部门id_In   In 输液配药记录.部门id%Type,
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  摆药单号_In In 输液配药记录.摆药单号%Type,
  操作人员_In In 输液配药状态.操作人员%Type := Null,
  操作时间_In In 输液配药状态.操作时间%Type := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);

  v_收发ids  Varchar2(4000);
  v_Error    Varchar2(255);
  n_是否打包 输液配药记录.是否打包%Type;
  n_操作状态 输液配药记录.操作状态%Type;
  Err_Custom Exception;
  Cursor c_收发记录 Is
    Select /*+ rule*/
     a.Id, Nvl(a.批次, 0) As 批次
    From 药品收发记录 A,
         (Select Distinct 收发id
           From 输液配药内容 A, Table(Cast(f_Num2list(配药id_In) As Zltools.t_Numlist)) B
           Where a.记录id = b.Column_Value) B
    Where a.Id = b.收发id And a.审核人 Is Null;

  v_收发记录 c_收发记录%RowType;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>1 then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Begin
      Select 是否打包 Into n_是否打包 From 输液配药记录 Where ID = v_Tansid For Update Nowait;
    Exception
      When Others Then
        v_Error := '已有其他用户在执行发药，不能重复操作！';
        Raise Err_Custom;
    End;
    Update 输液配药记录 Set 操作状态 = 2, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In, 摆药单号 = 摆药单号_In Where id=v_Tansid;

    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_Tansid, 2, 操作人员_In, 操作时间_In);
    If n_是否打包 <> 0 Then
      Update 输液配药记录 Set 操作状态 =4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where id=v_Tansid;
      Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_Tansid, 4, 操作人员_In, 操作时间_In);
    End If;
  End Loop;

  For v_收发记录 In c_收发记录 Loop
    If v_收发ids Is Null Then
      v_收发ids := v_收发记录.Id || ',' || v_收发记录.批次;
    Else
      If Length(v_收发ids || '|' || v_收发记录.Id || ',' || v_收发记录.批次) > 3950 Then
        Zl_药品收发记录_批量发药(v_收发ids, 部门id_In, 操作人员_In, 操作时间_In, 4, 操作人员_In, 摆药单号_In);
        v_收发ids := v_收发记录.Id || ',' || v_收发记录.批次;
      Else
        v_收发ids := v_收发ids || '|' || v_收发记录.Id || ',' || v_收发记录.批次;
      End If;
    End If;
  End Loop;

  If Not v_收发ids Is Null Then
    Zl_药品收发记录_批量发药(v_收发ids, 部门id_In, 操作人员_In, 操作时间_In, 4, 操作人员_In, 摆药单号_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_摆药;
/

--86996:张德婷,2015-07-31,销帐申请之后，输液单不能进行取消摆药操作
CREATE OR REPLACE Procedure Zl_输液配药记录_取消摆药(配药id_In In Varchar2 --ID串:配药ID1,配药ID2....
                                           ) Is 
  v_Id       Varchar2(20); 
  v_发药id   Varchar2(20); 
  v_退药id   Varchar2(20); 
  v_收发id   Varchar2(20); 
  v_配药id   Varchar2(20); 
  v_Tmp      Varchar2(4000); 
  v_Date     Date; 
  v_操作人员 输液配药记录.操作人员%Type; 
  d_操作时间 输液配药记录.操作时间%Type;  
  n_操作状态 输液配药记录.操作状态%Type; 
  v_Error    Varchar2(255); 
  Err_Custom Exception; 
 
  Cursor c_配药内容 Is 
    Select /*+ rule*/ 
    Distinct c.记录id, a.Id As 退药id, c.收发id 
    From 药品收发记录 A, 药品收发记录 B, 输液配药内容 C, Table(Cast(f_Num2list(配药id_In) As Zltools.t_Numlist)) D 
    Where c.记录id = d.Column_Value And b.Id = c.收发id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And 
          a.药品id + 0 = b.药品id And a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0); 
 
  v_配药内容 c_配药内容%RowType; 
 
  Cursor c_退药记录 Is 
    Select a.Id, a.批号, a.效期, a.产地, b.数量 As 退药数 
    From 药品收发记录 A, 输液配药内容 B 
    Where a.Id = v_退药id And a.审核人 Is Not Null And b.收发id = v_收发id And b.记录id = v_配药id; 
 
  v_退药记录 c_退药记录%RowType; 
 
Begin 
  If 配药id_In Is Null Then 
    v_Tmp := Null; 
  Else 
    v_Tmp := 配药id_In || ','; 
  End If; 
  While v_Tmp Is Not Null Loop 
    --分解单据ID串 
    v_Id  := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1); 
    v_Tmp := Replace(',' || v_Tmp, ',' || v_Id || ','); 
    
     --检查当前输液单的状态是否为待摆药状态
    Begin 
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Id;
      
      if n_操作状态!=2 then
        v_Error := '该数据已被操作，不能进行取消摆药操作！'; 
        Raise Err_Custom;  
      end if;
    Exception 
      When Others Then 
        v_Error := '该数据已被操作！'; 
        Raise Err_Custom; 
    End; 
 
    Select 操作人员, 操作时间 
    Into v_操作人员, d_操作时间 
    From 输液配药状态 
    Where 配药id = v_Id And 操作类型 = 1 And Rownum = 1; 
 
    Update 输液配药记录 Set 操作状态 = 1, 操作人员 = v_操作人员, 操作时间 = d_操作时间 Where ID = v_Id; 
  End Loop; 
 
  Select Sysdate Into v_Date From Dual; 
 
  For v_配药内容 In c_配药内容 Loop 
    v_退药id := v_配药内容.退药id; 
    v_收发id := v_配药内容.收发id; 
    v_配药id := v_配药内容.记录id; 
    For v_退药记录 In c_退药记录 Loop 
      --处理退药 
      Zl_药品收发记录_部门退药(v_退药记录.Id, Zl_Username, v_Date, v_退药记录.批号, v_退药记录.效期, v_退药记录.产地, v_退药记录.退药数, Null, Zl_Username); 
 
      Select Max(a.Id) 
      Into v_发药id 
      From 药品收发记录 A, 药品收发记录 B 
      Where b.Id = v_退药id And a.单据 = b.单据 And a.No = b.No And a.库房id + 0 = b.库房id And a.药品id + 0 = b.药品id And 
            a.序号 = b.序号 And Mod(a.记录状态, 3) = 1 And a.审核日期 Is Null; 
 
      --替换输液配药内容中的收发ID 
      Update 输液配药内容 Set 收发id = v_发药id Where 记录id = v_配药id And 收发id = v_配药内容.收发id; 
    End Loop; 
  End Loop; 
Exception 
   When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_输液配药记录_取消摆药;
/

--80594:马政,2014-12-17,调价产生药品收发记录的NO方式改进
Create Or Replace Procedure Zl_药品收发记录_Adjust
(
  Adjustid    In Number, --调价记录的ID
  Bln定价     In Number := 0, --是否转为定价销售（更新2004-06-08、收费细目中的变价）
  Billinfo_In In Varchar2 := Null, --用于时价药品按批次调价。格式:"批次1,现价1|批次2,现价2|....."
  药品id_In   In Number := 0 --当不为0时表示是成本价调价，不处理售价相关内容
) As
  Classid      Number(18); --入出类别
  v_Billno     药品收发记录.No%Type; --调价单号
  Rundate      Date; --调价生效时间
  Blnrun       Number(1); --调价时刻到了
  Blncurprice  Number(1); --时价药品
  Lng细目id    Number(18); --收费细目ID
  Adjustdate   Date; --调价时间
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_序号       Number(8);
  n_原价id     收费价目.原价id%Type;
  n_收入项目id 收费价目.收入项目id%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_变动原因   收费价目.变动原因%Type;

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, Rownum 序号, Classid 入出类别id, m.Id As 药品id, s.批次, Null 批号, Null 效期, s.上次产地 As 产地, 1 付数,
           s.上次供应商id As 供应商id, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率, '药品调价' 摘要, Zl_Username 填制人,
           Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(m.是否变价, 0) As 时价, s.实际金额 As 库存金额, s.实际差价 As 库存差价
    From 药品库存 S, 收费项目目录 M, 收费价目 A
    Where s.药品id = m.Id And m.Id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And a.执行日期 <= Sysdate;

  v_Data c_Price%RowType;

  Cursor c_时价按批次调价 --时价药品按批次调价
  Is
    Select 1 记录状态, 13 单据, v_Billno NO, n_序号 + Rownum 序号, Classid 入出类别id, m.药品id 药品id, s.批次 批次, Null 批号, Null 效期,
           s.上次产地 As 产地, s.上次供应商id As 供应商id, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '药品调价' 摘要, Zl_Username 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价,
           s.实际金额 As 库存金额, s.实际差价 As 库存差价
    From 药品库存 S, 药品目录 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = b.Id And s.药品id = m.药品id And m.药品id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = Adjustid And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;

  v_时价按批次调价 c_时价按批次调价%RowType;
Begin
  If 药品id_In <> 0 Then
    --成本价调价
    Zl_药品收发记录_成本价调价(药品id_In);
  Else
    n_变动原因 := 0;
    --取调价记录生效日期
    Select 收费细目id, 执行日期, 收入项目id Into Lng细目id, Rundate, n_收入项目id From 收费价目 Where ID = Adjustid;
  
    If Sysdate >= Rundate Then
      Blnrun := 1;
    Else
      Blnrun := 0;
    End If;
  
    If Blnrun = 1 Then
      --取入出类别ID
      Select 类别id Into Classid From 药品单据性质 Where 单据 = 13;
    
      --取序列
      Select Nextno(147) Into v_Billno From Dual;
    
      --取该药品是否是时价药品
      Select Nvl(是否变价, 0) Into Blncurprice From 收费项目目录 Where ID = Lng细目id;
    
      --检查是否存在原价和现价相同的情况，相同时不执行调售价功能，并且删除这条收费价目记录，恢复原来的收费价目
      Begin
        Select 原价id Into n_原价id From 收费价目 Where ID = Adjustid And 原价 = 现价 And 原价id Is Not Null;
      Exception
        When Others Then
          n_原价id := 0;
      End;
    
      If n_原价id > 0 Then
        --如果现价=原价，这种情况下是单独调整收入项目，更新收入项目ID，删除调价记录
        Delete 收费价目 Where ID = Adjustid;
        Update 收费价目
        Set 收入项目id = n_收入项目id, 终止日期 = To_Date('3000-01-01', 'yyyy-mm-dd')
        Where ID = n_原价id;
      Else
        Adjustdate := Sysdate;
      
        Begin
          Select 变动原因 Into n_变动原因 From 收费价目 Where ID = Adjustid And 变动原因 = 1;
        Exception
          When Others Then
            n_变动原因 := 0;
        End;
        If n_变动原因 = 0 Then
          If Billinfo_In = '' Or Billinfo_In Is Null Then
            For v_Data In c_Price Loop
              Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
              If Nvl(v_Data.填写数量, 0) = 0 And (Nvl(v_Data.库存金额, 0) <> 0 Or Nvl(v_Data.库存差价, 0) <> 0) Then
                --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据            
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                   填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量, v_Data.成本价, v_Data.成本金额,
                   v_Data.零售价, v_Data.扣率, v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数, v_Data.价格id,
                   Zl_Username, Adjustdate, v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新库存零售价,只有时价分批药品才能更新零售价字段
                Zl_药品库存_Update(n_收发id);
              Else
                If Blncurprice = 1 Then
                  n_零售价 := v_Data.库存金额 / v_Data.填写数量;
                Else
                  n_零售价 := v_Data.成本价;
                End If;
                n_零售金额 := Round((v_Data.零售价 - n_零售价) * v_Data.填写数量, 2);
              
                --产生调价影响记录
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
                   填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                Values
                  (n_收发id, v_Data.记录状态, v_Data.单据, v_Data.No, v_Data.序号, v_Data.入出类别id, v_Data.药品id, v_Data.批次,
                   v_Data.批号, v_Data.效期, v_Data.产地, v_Data.付数, v_Data.填写数量, v_Data.实际数量, v_Data.成本价, v_Data.成本金额,
                   v_Data.零售价, v_Data.扣率, n_零售金额, n_零售金额, v_Data.摘要, v_Data.填制人, v_Data.填制日期, v_Data.库房id, v_Data.入出系数,
                   v_Data.价格id, Zl_Username, Adjustdate, v_Data.库存金额, v_Data.库存差价, v_Data.供应商id);
              
                --更新药品库存
                Zl_药品库存_Update(n_收发id);
              End If;
            End Loop;
          Else
            n_序号 := 0;
            --时价药品按批次调价
            v_Infotmp := Billinfo_In || '|';
            While v_Infotmp Is Not Null Loop
              --分解单据ID串
              v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
              n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
              n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
              v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
            
              For v_时价按批次调价 In c_时价按批次调价 Loop
                If v_时价按批次调价.填写数量 <> 0 Then
                  n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
                Else
                  n_原价 := v_时价按批次调价.成本价;
                End If;
              
                Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
                If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
                  --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据              
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人,
                     填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人,
                     v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username, Adjustdate,
                     v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存零售价,只有时价分批药品才能更新零售价字段
                  Zl_药品库存_Update(n_收发id);
                Else
                
                  n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
                  n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
                  --产生调价影响记录
                  Insert Into 药品收发记录
                    (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价,
                     摘要, 填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次, 供药单位id)
                  Values
                    (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
                     v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量,
                     v_时价按批次调价.实际数量, n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要,
                     v_时价按批次调价.填制人, v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, Zl_Username,
                     Adjustdate, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价, v_时价按批次调价.供应商id);
                  n_序号 := n_序号 + 1;
                
                  --更新库存
                  Zl_药品库存_Update(n_收发id);
                End If;
              End Loop;
            End Loop;
          End If;
        
          Update 收费价目 Set 变动原因 = 1 Where ID = Adjustid;
        
          --更新药品目录、收费细目中的变价
          If Bln定价 = 1 Then
            Update 收费项目目录 Set 是否变价 = 0 Where ID = Lng细目id;
            Update 收费细目 Set 是否变价 = 0 Where ID = Lng细目id;
          End If;
        End If;
      End If;
    
      If n_变动原因 = 0 Then
        --成本价调价
        Zl_药品收发记录_成本价调价(Lng细目id, Rundate);
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_Adjust;
/

--80594:马政,2014-12-17,调价产生药品收发记录的NO方式改进
Create Or Replace Procedure Zl_材料收发记录_Adjust
(
  调价id_In   In Number, --调价记录的ID 
  定价_In     In Number := 0, --是否转为定价销售（更新材料特性、收费细目中的变价） 
  材料id_In   In Number := 0, --当不为0时表示是成本价调价，不处理售价相关内容 
  Billinfo_In In Varchar2 := Null --用于时价卫材按批次调价。格式:"批次1,现价1|批次2,现价2|....."
) As
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别 
  v_调价单据号 药品收发记录.No%Type; --调价单号 
  d_生效日期   Date; --调价生效时间 
  n_执行调价   Number(1); --调价时刻到了 
  n_实价材料   Number(1); --时价药品 
  n_收费细目id Number(18); --收费细目ID 
  d_审核日期   药品收发记录.审核日期%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_零售价     药品库存.零售价%Type;
  n_序号       Integer(8);
  v_Infotmp    Varchar2(4000);
  v_Fields     Varchar2(4000);
  n_批次       Number(18);
  n_现价       收费价目.现价%Type;
  n_原价       收费价目.原价%Type;
  n_收发id     药品收发记录.Id%Type;
  n_时价分批   Number(1);

  Cursor c_Price --普通调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, Rownum 序号, n_入出类别id 入出类别id, m.材料id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, q.产地, s.上次产地) 产地, 1 付数, s.实际数量 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, a.现价 零售价, 0 扣率,
           Nvl(s.零售价, 0) As 库存零售价, s.实际金额 As 库存金额, s.实际差价 As 库存差价, '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id,
           1 入出系数, a.Id 价格id, s.上次生产日期, s.灭菌效期, s.批准文号, s.上次供应商id
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 Q
    Where s.药品id = m.材料id And m.材料id = q.Id And m.材料id = a.收费细目id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate;

  Cursor c_时价按批次调价 --时价卫材按批次调价
  Is
    Select 1 记录状态, 13 单据, v_调价单据号 NO, n_序号 + Rownum 序号, n_入出类别id 入出类别id, s.药品id 药品id, s.批次 批次, Null 批号, s.效期,
           Decode(s.上次产地, Null, b.产地, s.上次产地) 产地, 1 付数, Nvl(s.实际数量, 0) 填写数量, 0 实际数量, a.原价 成本价, 0 成本金额, n_现价 零售价, 0 扣率,
           '卫材调价' 摘要, User 填制人, Sysdate 填制日期, s.库房id 库房id, 1 入出系数, a.Id 价格id, Nvl(b.是否变价, 0) As 时价, s.实际金额 As 库存金额,
           s.实际差价 As 库存差价
    From 药品库存 S, 材料特性 M, 收费价目 A, 收费项目目录 B
    Where s.药品id = m.材料id And m.材料id = a.收费细目id And a.收费细目id = b.Id And s.性质 = 1 And a.变动原因 = 0 And a.Id = 调价id_In And
          a.执行日期 <= Sysdate And Nvl(s.批次, 0) = n_批次;
Begin

  If 材料id_In <> 0 Then
    --成本价调价 
    Zl_材料收发记录_成本价调价(材料id_In);
    Return;
  End If;

  --取入出类别ID 
  Select 类别id Into n_入出类别id From 药品单据性质 Where 单据 = 13;

  --取序列 
  Select Nextno(147) Into v_调价单据号 From Dual;
  --取调价记录生效日期 
  Select 收费细目id, 执行日期 Into n_收费细目id, d_生效日期 From 收费价目 Where ID = 调价id_In;
  --取该材料是否是时价药品 
  Select Nvl(是否变价, 0) Into n_实价材料 From 收费项目目录 Where ID = n_收费细目id;

  If Sysdate >= d_生效日期 Then
    n_执行调价 := 1;
  Else
    n_执行调价 := 0;
  End If;

  If n_执行调价 = 1 Then
    d_审核日期 := Sysdate;
    --普通调价处理
    If Billinfo_In = '' Or Billinfo_In Is Null Then
      --非时价药品调价 
      For c_调价 In c_Price Loop
        If Nvl(c_调价.填写数量, 0) = 0 And (Nvl(c_调价.库存金额, 0) <> 0 Or Nvl(c_调价.库存差价, 0) <> 0) Then
          --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据 
          --产生调价影响记录 
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
             库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, c_调价.成本价, c_调价.成本金额, c_调价.零售价, c_调价.扣率, c_调价.摘要, c_调价.填制人,
             c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期, c_调价.批准文号, c_调价.上次供应商id,
             c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存 ，只有时价卫材才更新零售价
          Update 药品库存
          Set 零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        Else
          If n_实价材料 = 1 Then
            If c_调价.库存零售价 = 0 Then
              n_零售价 := c_调价.库存金额 / c_调价.填写数量;
            Else
              n_零售价 := c_调价.库存零售价;
            End If;
          Else
            n_零售价 := c_调价.成本价;
          End If;
          n_零售金额 := Round((c_调价.零售价 - n_零售价) * c_调价.填写数量, 2);
        
          --产生调价影响记录 
          Insert Into 药品收发记录
            (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
             填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 生产日期, 灭菌效期, 批准文号, 供药单位id, 单量, 频次)
          Values
            (药品收发记录_Id.Nextval, c_调价.记录状态, c_调价.单据, c_调价.No, c_调价.序号, c_调价.入出类别id, c_调价.药品id, c_调价.批次, c_调价.批号, c_调价.效期,
             c_调价.产地, c_调价.付数, c_调价.填写数量, c_调价.实际数量, c_调价.成本价, c_调价.成本金额, c_调价.零售价, c_调价.扣率, n_零售金额, n_零售金额, c_调价.摘要,
             c_调价.填制人, c_调价.填制日期, c_调价.库房id, c_调价.入出系数, c_调价.价格id, User, d_审核日期, c_调价.上次生产日期, c_调价.灭菌效期, c_调价.批准文号,
             c_调价.上次供应商id, c_调价.库存金额, c_调价.库存差价);
        
          --更新材料库存 
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
              零售价 = Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null)
          Where 库房id = c_调价.库房id And 药品id = c_调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(c_调价.批次, 0);
        
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价)
            Values
              (c_调价.库房id, c_调价.药品id, c_调价.批次, 1, 0, 0, n_零售金额, n_零售金额, c_调价.效期, c_调价. 灭菌效期, c_调价.上次供应商id, c_调价.成本价,
               c_调价.批号, c_调价.上次生产日期, c_调价.产地, c_调价.批准文号,
               Decode(n_实价材料, 1, Decode(Nvl(c_调价.批次, 0), 0, Null, c_调价.零售价), Null));
          End If;
        End If;
      End Loop;
    Else
      --时价分批调价处理
      n_序号 := 0;
      --时价药品按批次调价
      v_Infotmp := Billinfo_In || '|';
      While v_Infotmp Is Not Null Loop
        --分解单据ID串
        v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
        n_批次    := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
        n_现价    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
        v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
      
        For v_时价按批次调价 In c_时价按批次调价 Loop
          If v_时价按批次调价.填写数量 <> 0 Then
            n_原价 := Nvl(v_时价按批次调价.库存金额, 0) / v_时价按批次调价.填写数量;
          Else
            n_原价 := v_时价按批次调价.成本价;
          End If;
        
          Select 药品收发记录_Id.Nextval Into n_收发id From Dual;
          If Nvl(v_时价按批次调价.填写数量, 0) = 0 And (Nvl(v_时价按批次调价.库存金额, 0) <> 0 Or Nvl(v_时价按批次调价.库存差价, 0) <> 0) Then
            --数量=0 金额或差价<>0时只更新库存表中对应的零售价,并产生售价修正数据但是金额差=0，只记录最新售价，金额差和差价差不填数据

          
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 摘要, 填制人, 填制日期,
               库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, v_时价按批次调价.摘要, v_时价按批次调价.填制人, v_时价按批次调价.填制日期,
               v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期, v_时价按批次调价.库存金额, v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            --更新库存零售价,只有时价分批药品才能更新零售价字段    
            Update 药品库存
            Set 零售价 = Decode(v_时价按批次调价.时价, 1, Decode(Nvl(v_时价按批次调价.批次, 0), 0, Null, v_时价按批次调价.零售价), Null)
            Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And Nvl(批次, 0) = Nvl(v_时价按批次调价.批次, 0);
          Else
            n_零售价   := v_时价按批次调价.库存金额 / v_时价按批次调价.填写数量;
            n_零售金额 := Round((n_现价 - n_零售价) * v_时价按批次调价.填写数量, 2);
            --产生调价影响记录
            Insert Into 药品收发记录
              (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要,
               填制人, 填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 单量, 频次)
            Values
              (n_收发id, v_时价按批次调价.记录状态, v_时价按批次调价.单据, v_时价按批次调价.No, v_时价按批次调价.序号, v_时价按批次调价.入出类别id, v_时价按批次调价.药品id,
               v_时价按批次调价.批次, v_时价按批次调价.批号, v_时价按批次调价.效期, v_时价按批次调价.产地, v_时价按批次调价.付数, v_时价按批次调价.填写数量, v_时价按批次调价.实际数量,
               n_原价, v_时价按批次调价.成本金额, v_时价按批次调价.零售价, v_时价按批次调价.扣率, n_零售金额, n_零售金额, v_时价按批次调价.摘要, v_时价按批次调价.填制人,
               v_时价按批次调价.填制日期, v_时价按批次调价.库房id, v_时价按批次调价.入出系数, v_时价按批次调价.价格id, User, d_审核日期, v_时价按批次调价.库存金额,
               v_时价按批次调价.库存差价);
            n_序号 := n_序号 + 1;
            --处理库存
            If v_时价按批次调价.时价 = 1 And Nvl(v_时价按批次调价.批次, 0) > 0 Then
              n_时价分批 := 1;
            Else
              n_时价分批 := 0;
            End If;
          
            If Nvl(v_时价按批次调价.批次, 0) = 0 Then
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And (批次 Is Null Or 批次 = 0);
            Else
              Update 药品库存
              Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_零售金额,
                  零售价 = Decode(n_时价分批, 1, v_时价按批次调价.零售价, 零售价)
              Where 库房id = v_时价按批次调价.库房id And 药品id = v_时价按批次调价.药品id And 性质 = 1 And 批次 = v_时价按批次调价.批次;
            End If;
          
            If Sql%RowCount = 0 Then
              Insert Into 药品库存
                (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
              Values
                (v_时价按批次调价.库房id, v_时价按批次调价.药品id, v_时价按批次调价.批次, 1, 0, 0, n_零售金额, n_零售金额,
                 Decode(n_时价分批, 1, v_时价按批次调价.零售价, Null));
            End If;
          End If;
        End Loop;
      End Loop;
    End If;
  
    Update 药品收发记录 Set 审核人 = User, 审核日期 = Sysdate Where 价格id = 调价id_In;
    Update 收费价目 Set 变动原因 = 1 Where ID = 调价id_In;
  
    --更新药品目录、收费细目中的变价 
    If 定价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 0 Where ID = n_收费细目id;
    End If;
    --成本价调价 
    Zl_材料收发记录_成本价调价(n_收费细目id);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_Adjust;
/

--87171:王振涛,2015-08-11,年龄字段超长
--86817:王振涛,2015-07-28,计费状态变更
Create Or Replace Procedure Zl_检验标本记录_报告审核
(
  Id_In       检验标本记录.Id%Type,
  审核人_In   检验标本记录.审核人%Type := Null,
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null
) Is

  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Union All
    Select Distinct 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_微生物 In Number) Is
    Select Distinct 医嘱id, 病人来源
    From (Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 0 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 1 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select b.Id As 医嘱id, a.病人来源
           From 检验标本记录 A, 病人医嘱记录 B
           Where a.Id = Id_In And a.医嘱id = b.相关id);

  Cursor c_Stuff
  (
    v_No     Varchar2,
    v_主页id Number
  ) Is
    Select NO, 单据, 库房id
    From 未发药品记录
    Where NO = v_No And 单据 In (24, 25, 26) And 库房id Is Not Null And Not Exists
     (Select 1 From Dual Where zl_GetSysParameter(Decode(v_主页id, Null, 92, 63)) = '1') And Exists
     (Select a.序号
           From 住院费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1
           Union All
           Select a.序号
           From 门诊费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id;

  v_执行 Number(1);
  v_No   病人医嘱发送.No%Type;
  v_性质 病人医嘱发送.记录性质%Type;
  v_序号 Varchar2(1000);

  v_Count Number(18);

  v_微生物标本 Number(1) := 0;
  v_主页id     Number(18);
  v_婴儿       Number(1);
  v_年龄       Varchar2(100);
  v_仪器       Number(18);
  v_Intloop    Number;
  Err_Custom Exception;
  v_Error Varchar2(100);
Begin
  Select Nvl(婴儿, 0), 年龄 Into v_婴儿, v_年龄 From 检验标本记录 Where ID = Id_In;

  --执行后自动审核对应的记帐划价单(不包含药品)
  Select Zl_To_Number(Nvl(zl_GetSysParameter(81), '0')) Into v_执行 From Dual;

  v_微生物标本 := 0;
  Begin
    Select 1 Into v_微生物标本 From 检验标本记录 Where 微生物标本 = 1 And ID = Id_In;
  Exception
    When Others Then
      v_微生物标本 := 0;
  End;

  --1.置本标本的状态及审核人和时间
  Update 检验标本记录
  Set 审核人 = Decode(审核人_In, Null, 人员姓名_In, 审核人_In), 审核时间 = Sysdate, 样本状态 = 2
  Where ID = Id_In;

  --记录审核过程
  Insert Into 检验操作记录
    (ID, 标本id, 操作类型, 操作员, 操作时间)
  Values
    (检验操作记录_Id.Nextval, Id_In, 0, Decode(审核人_In, Null, 人员姓名_In, 审核人_In), Sysdate);

  --2.检查当前标本相关的申请的相关标本是否完成审核
  For r_Samplequest In c_Samplequest(v_微生物标本) Loop
  
    v_Count := 0;
  
    If v_微生物标本 = 0 Then
      Begin
        Select Nvl(Count(1), 0)
        Into v_Count
        From 检验标本记录
        Where 样本状态 < 2 And ID In (Select 标本id From 检验项目分布 Where 医嘱id = r_Samplequest.医嘱id);
      Exception
        When Others Then
          v_Count := 0;
      End;
    End If;
  
    --r_SampleQuest.医嘱id申请已经完成,处理后续环节
    If v_Count = 0 Then
    
      --1.置申请单的执行状态
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
      Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id));
    
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      Else
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      End If;
    
      --3.自动审核记帐
      If v_执行 = 1 Then
        For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
          If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
            If v_序号 Is Not Null Then
              If v_性质 = 1 Then
                Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              Elsif v_性质 = 2 Then
                Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
              End If;
            End If;
            v_序号 := Null;
          End If;
          v_No   := r_Verify.No;
          v_性质 := r_Verify.记录性质;
          v_序号 := v_序号 || ',' || r_Verify.序号;
        End Loop;
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
          v_序号 := Null;
        End If;
      End If;
    
      --审核试剂消耗单
      v_Intloop := 1;
      v_No      := Null;
      Select 仪器id Into v_仪器 From 检验标本记录 Where ID = Id_In;
      For r_检验试剂 In (Select c.材料id, c.数量
                     From 病人医嘱记录 A, 检验报告项目 B, 检验试剂关系 C
                     Where a.相关id = r_Samplequest.医嘱id And a.诊疗项目id = b.诊疗项目id And b.报告项目id = c.项目id And c.仪器id = v_仪器) Loop
        Zl_检验试剂记录_Insert(r_Samplequest.医嘱id, v_Intloop, r_检验试剂.材料id, r_检验试剂.数量);
        v_Intloop := v_Intloop + 1;
      End Loop;
      Select Count(*) Into v_Intloop From 检验试剂记录 Where 医嘱id = r_Samplequest.医嘱id And NO Is Null;
      If v_Intloop > 1 Then
        v_No := Nextno(14);
        Update 检验试剂记录 Set NO = v_No Where 医嘱id = r_Samplequest.医嘱id;
      End If;
      If v_No Is Not Null Then
      
        Zl_检验试剂记录_Bill(r_Samplequest.医嘱id, v_No);
      
        v_主页id := Null;
        Select 主页id Into v_主页id From 病人医嘱记录 A Where ID = r_Samplequest.医嘱id;
      
        If v_主页id Is Null Then
          Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In);
        Else
          Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In);
        End If;
      
        --如果记帐没有自动发料,则自动发料,否则不处理
        For r_Stuff In c_Stuff(v_No, v_主页id) Loop
          Zl_材料收发记录_处方发料(r_Stuff.库房id, 25, v_No, 人员姓名_In, 人员姓名_In, 人员姓名_In, 1, Sysdate);
        End Loop;
      End If;
    End If;
  End Loop;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 9, 0 || ',' || Id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_报告审核;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86902:刘尔旋,2015-07-28,医嘱自定义执行科室
--86629:刘尔旋,2015-07-28,就诊详情返回外检项目
Create Or Replace Procedure Zl_Third_Custom_Getdeptinfo
(
  医嘱id_In      In 病人医嘱记录.Id%Type,
  执行科室id_Out Out 病人医嘱记录.执行科室id%Type,
  执行科室_Out   Out Varchar2
) Is
  --------------------------------------
  --功能：返回自定义的执行科室ID或名称
  --入参：
  --医嘱ID_IN:医嘱ID，也可能是组医嘱ID
  --出参:执行科室ID_Out,0为不自定义执行科室
  --     执行科室_Out:执行科室名称
  --------------------------------------
  v_Temp    Varchar2(32767);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  执行科室id_Out := 0;
  执行科室_Out   := '';
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Custom_Getdeptinfo;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_医保结算明细_Insert
(
  结帐id_In   医保结算明细.结帐id%Type,
  No_In       医保结算明细.No%Type,
  结算方式_In Varchar2,
  备注_In     医保结算明细.备注%Type := Null
) As
  --功能:更新和插入"多单据分单据结算"模式时的医保结算明细信息
  --   结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 医保结算明细.结算方式%Type;
  n_结算金额 医保结算明细.金额%Type;
Begin
  --1.检查是否已经存在医保结算明细数据,存在先删除
  Delete From 医保结算明细 Where 结帐id = 结帐id_In And NO = No_In;

  --2.插入新的医保结算明细数据
  If 结算方式_In Is Not Null Then
    v_结算内容 := 结算方式_In || '||';
  End If;

  While v_结算内容 Is Not Null Loop
    v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    Insert Into 医保结算明细
      (结帐id, NO, 结算方式, 金额, 备注)
    Values
      (结帐id_In, No_In, v_结算方式, n_结算金额, 备注_In);
  
    v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医保结算明细_Insert;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_保险结算记录_作废
(
  记录id_In In 保险结算记录.记录id%Type,
  冲销id_In In 保险结算记录.冲销id%Type,
  No_In     In 门诊费用记录.No%Type := Null
) As
  n_序号 Number(18);
Begin
  If No_In Is Not Null Then
    n_序号 := Zl_Getinsurebalancenum(记录id_In, No_In);
    If Nvl(n_序号, 0) <> 0 Then
      Update 保险结算记录 Set 冲销id = 冲销id_In, 冲销时间 = Sysdate Where 记录id = 记录id_In And 序号 = n_序号;
      Return;
    End If;
  End If;

  Update 保险结算记录 Set 冲销id = 冲销id_In, 冲销时间 = Sysdate Where 记录id = 记录id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_保险结算记录_作废;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_病人门诊收费_医保更新
(
  结帐id_In   门诊费用记录.结帐id%Type,
  结算序号_In 病人预交记录.结算序号%Type,
  保险结算_In Varchar2
) As
  --功能:重新更新保险结算,分摊到指定的单据上
  --保险结算_In:为空时,表示只更新预交的标志(以预结算和结算一样时,才会使用此方式)
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     病人预交记录.缴款组id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式   病人预交记录.结算方式%Type;
  n_结算金额   病人预交记录.冲预交%Type;
  n_剩余额     病人预交记录.冲预交%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  d_Date       门诊费用记录.登记时间%Type;
  v_No         门诊费用记录.No%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  v_Dec        Number;
  n_单价小数   Number;
  n_结算序号   病人预交记录.结算序号%Type;
Begin

  If 保险结算_In Is Null Then
    --预结算和结算一致时,才会只更新标志
    If Nvl(结帐id_In, 0) <> 0 Then
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结帐id = 结帐id_In And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4));
      --医保相关表的处理
      Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
    Else
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结算序号 = 结算序号_In And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4));
      --医保相关表的处理
      Update 保险结算明细
      Set 标志 = 2
      Where 结帐id In (Select 结帐id
                     From 病人预交记录 A
                     Where 结算序号 = 结算序号_In And Exists (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)));
    End If;
    Return;
  End If;

  If Nvl(结帐id_In, 0) <> 0 Then
    Select a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
    Into v_No, v_操作员编号, v_操作员姓名, n_病人id, d_Date, n_组id, n_结算序号
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.结帐id = 结帐id_In And Rownum = 1;
  Else
    Select a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
    Into v_No, v_操作员编号, v_操作员姓名, n_病人id, d_Date, n_组id, n_结算序号
    From 病人预交记录 B, 门诊费用记录 A
    Where b.结帐id = a.结帐id And b.结算序号 = 结算序号_In And Rownum = 1;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  If Nvl(结帐id_In, 0) <> 0 Then
    --检查是否有结算方式为空的记录
    Update 病人预交记录 Set 冲预交 = Null Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, Null, Null, d_Date, v_操作员编号, v_操作员姓名, 0, 结帐id_In, n_组id, n_结算序号, 1, 3);
    End If;
    --删除所有医保结算数据(其他结算方式不删除)
    Delete 病人预交记录 A
    Where 结帐id = 结帐id_In And 结算方式 Is Not Null And Exists
     (Select 1 From 结算方式 Where 性质 In (3, 4) And a.结算方式 = 名称);
    Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;
  End If;

  If Nvl(结算序号_In, 0) <> 0 Then
    For v_结算 In (Select Distinct a.结帐id, a.No, a.操作员编号, a.操作员姓名, a.病人id, a.登记时间, a.缴款组id, b.结算序号
                 From 病人预交记录 B, 门诊费用记录 A
                 Where b.结帐id = a.结帐id And b.结算序号 = 结算序号_In) Loop
      --检查是否有结算方式为空的记录
      Update 病人预交记录 Set 冲预交 = Null Where 结帐id = v_结算.结帐id And 结算方式 Is Null;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_结算.No, 1, n_病人id, Null, Null, v_结算.登记时间, v_结算.操作员编号, v_结算.操作员姓名, 0, v_结算.结帐id,
           v_结算.缴款组id, n_结算序号, 1, 3);
      End If;
      --删除所有医保结算数据(其他结算方式不删除)
      Delete 病人预交记录 A
      Where 结帐id = v_结算.结帐id And 结算方式 Is Not Null And Exists
       (Select 1 From 结算方式 Where 性质 In (3, 4) And a.结算方式 = 名称);
      Update 保险结算明细 Set 标志 = 2 Where 结帐id = v_结算.结帐id;
    End Loop;
  End If;

  --各个保险结算
  v_结算内容 := 保险结算_In || '||';
  While v_结算内容 Is Not Null Loop
    v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(结帐id_In, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, '保险结算', v_结算方式, d_Date, v_操作员编号, v_操作员姓名, n_结算金额, 结帐id_In, n_组id,
           n_结算序号, 2, 3);
      Else
      
        n_剩余额 := Nvl(n_结算金额, 0);
        For v_收费 In (Select b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, Max(b.登记时间) As 登记时间,
                            Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                     From 门诊费用记录 B,
                          (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                            From 病人预交记录
                            Where 结算序号 = 结算序号_In
                            Group By 结帐id) A
                     Where b.结帐id = a.结帐id
                     Group By b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名
                     Having Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) <> 0
                     Order By 结帐id, NO) Loop
          If Nvl(v_收费.结帐金额, 0) >= Nvl(n_剩余额, 0) Then
            n_结算金额 := Nvl(n_剩余额, 0);
            n_剩余额   := 0;
          Else
            n_结算金额 := Nvl(v_收费.结帐金额, 0);
            n_剩余额   := Nvl(n_剩余额, 0) - Nvl(v_收费.结帐金额, 0);
          End If;
          n_结帐id     := v_收费.结帐id;
          n_病人id     := v_收费.病人id;
          v_操作员编号 := v_收费.操作员编号;
          v_操作员姓名 := v_收费.操作员姓名;
          d_Date       := v_收费.登记时间;
          v_No         := v_收费.No;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, v_收费.No, 1, v_收费.病人id, '保险结算', v_结算方式, v_收费.登记时间, v_收费.操作员编号, v_收费.操作员姓名, n_结算金额,
             v_收费.结帐id, n_组id, n_结算序号, 2, 3);
          If Nvl(n_剩余额, 0) = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
    End If;
  
    If Nvl(n_剩余额, 0) <> 0 And Nvl(n_结帐id, 0) <> 0 Then
      --返回的金额为零了,所以将剩下部分放在最后一张单据中
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) + n_剩余额 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, '保险结算', v_结算方式, d_Date, v_操作员编号, v_操作员姓名, n_剩余额, n_结帐id, n_组id,
           n_结算序号, 2, 3);
      End If;
    End If;
    v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
  End Loop;

  --更新结算方式=NULL 的冲预交
  If Nvl(结帐id_In, 0) <> 0 Then
    For v_收费 In (Select Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                 From 门诊费用记录 B,
                      (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                        From 病人预交记录
                        Where 结帐id = 结帐id_In
                        Group By 结帐id) A
                 Where b.结帐id = a.结帐id Having Sum(Nvl(b.结帐金额, 0)) - Nvl(Max(a.冲预交), 0) <> 0) Loop
    
      Update 病人预交记录 Set 冲预交 = Nvl(v_收费.结帐金额, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, 1, n_病人id, Null, Null, d_Date, v_操作员编号, v_操作员姓名, Nvl(v_收费.结帐金额, 0), n_结帐id,
           n_组id, n_结算序号, 1, 3);
      End If;
    End Loop;
  
  Else
    For v_收费 In (Select b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, b.登记时间,
                        Nvl(Sum(Nvl(b.结帐金额, 0)), 0) - Nvl(Max(a.冲预交), 0) As 结帐金额
                 From 门诊费用记录 B,
                      (Select 结帐id, Nvl(Sum(冲预交), 0) As 冲预交
                        From 病人预交记录
                        Where 结算序号 = 结算序号_In
                        Group By 结帐id) A
                 Where b.结帐id = a.结帐id
                 Group By b.No, b.结帐id, b.病人id, b.操作员编号, b.操作员姓名, b.登记时间
                 Having Sum(Nvl(b.结帐金额, 0)) - Nvl(Max(a.冲预交), 0) <> 0
                 Order By 结帐id, NO) Loop
      Update 病人预交记录
      Set 冲预交 = Nvl(v_收费.结帐金额, 0)
      Where 结帐id = Nvl(v_收费.结帐id, 0) And 结算方式 Is Null;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_收费.No, 1, v_收费.病人id, Null, Null, v_收费.登记时间, v_收费.操作员编号, v_收费.操作员姓名,
           Nvl(v_收费.结帐金额, 0), v_收费.结帐id, n_组id, n_结算序号, 1, 3);
      End If;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人门诊收费_医保更新;
/

--88643:冉俊明,2015-09-16,门诊退费费用查询SQL性能优化。
--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据 
  --参数： 
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。 
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。 
  --                           1:部份退费不处理票据,通过重打调用单独处理。 
  --该游标为要退费单据的所有原始记录 

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差 
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量 
  --不要管费用的执行状态,因为先于此步处理 
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@ 
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录 
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@ 

  --该光标用于处理人员缴款余额中退的不同结算方式的金额 

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量 
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。 
  n_组id     财务缴款分组.Id%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();

  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查) 
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查) 
  --执行状态在原始记录上判断 
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And Mod(a.记录性质, 10) = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  --------------------------------------------------------------------------------- 
  --公用变量 
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行) 
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收 
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量) 
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@ 
            --非药品部分(以具体医嘱执行为准进行检查) 
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血) 
            --: 2.不存在医嘱的,则以剩余数量为准 
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And a.No = No_In And
                             a.序号 = r_Bill.序号 And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And Mod(j.记录性质, 10) = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And Mod(j.记录性质, 10) = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             Mod(a.记录性质, 10) = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@ 
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况： 
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量 
            --2.并发操作,此时已发药或发料 
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          If n_准退数量 < 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --是否部分退费 
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --该笔项目第几次退费 
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数) 
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录 
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录 
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        
          --          Update 门诊费用记录 Set 记录状态 = 3 Where ID = r_Bill.Id;
        
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的 
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费 
    End If;
  End Loop;
  --标记原费用记录 
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  --------------------------------------------------------------------------------- 
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收) 
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印) 
      Begin
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回 
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次 
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的 
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  --------------------------------------------------------------------------------- 
  --卫生材料 
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@ 
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@ 
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存 
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容 
  For r_Stock In c_Stock Loop
    --处理药品库存 
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@ 
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录 
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录 
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@ 
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@ 
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;
  --医嘱处理 
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null And
                     (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null)) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      --更新计费状态为1:已计费 
      Update 病人医嘱发送 A Set 计费状态 = 1 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1;
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1 And NO = No_In;
    Else
      --更新计费状态为2:部分退费 
      Update 病人医嘱发送 A Set 计费状态 = 2 Where NO = No_In And 医嘱id = c_医嘱.医嘱序号 And Mod(记录性质, 10) = 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_Retu_Exes
(
  v_No   In Varchar2,
  n_Type In Number
) As
  --------------------------------------------
  --参数:v_No,单据号码
  --     n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐
  --------------------------------------------
  n_Allow  Number(1); --是否能够单据返回
  n_Patiid Number(18);
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  n_System  Number(5);
  n_只读    Number(2);

  v_Table  Varchar2(100);
  v_Field  Varchar2(100);
  v_Sql    Varchar2(4000);
  v_Fields Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定ID的病人预交记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Prepay(n_Settle_Id H病人预交记录.结帐id%Type) As
  Begin
    For r_Rec In (Select * From H病人预交记录 Where 结帐id = n_Settle_Id) Loop
      v_Table  := '病人卡结算对照';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where 预交id = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '三方结算交易';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where 交易ID = :1';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      v_Table  := '病人卡结算记录';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where ID In(Select 卡结算id From H病人卡结算对照 Where 预交id = :1)';
      Execute Immediate v_Sql
        Using r_Rec.Id;
    
      Delete H病人卡结算记录 Where ID In (Select Distinct 卡结算id From H病人卡结算对照 Where 预交id = r_Rec.Id);
      Delete From H病人卡结算对照 Where 预交id = r_Rec.Id;
      Delete From H三方结算交易 Where 交易id = r_Rec.Id;
    
    End Loop;
  
    v_Table  := '病人预交记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    Delete H病人预交记录 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Prepay;

  --------------------------------------------
  --返回指定ID的病人费用记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Fee(n_Settle_Id H住院费用记录.结帐id%Type) As
  Begin
    --返回病人费用记录
    v_Table  := '住院费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '门诊费用记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '费用补充记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 结算id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    v_Table  := '医保结算明细';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where 结帐id = :1';
    Execute Immediate v_Sql
      Using n_Settle_Id;
  
    --删除已返回的费用记录
    Delete H门诊费用记录 Where 结帐id = n_Settle_Id;
    Delete H住院费用记录 Where 结帐id = n_Settle_Id;
    Delete H费用补充记录 Where 结算id = n_Settle_Id;
    Delete H医保结算明细 Where 结帐id = n_Settle_Id;
  End Zl_Retu_Fee;

  --------------------------------------------
  --返回指定ID的药品收发记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Medilist(n_Rec_Id H药品收发记录.Id%Type) As
  Begin
    --按外键引用顺序返回药品收发相关表的数据     
    v_Table  := '药品收发记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where ID = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    v_Table  := '输液配药记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where ID In(Select 记录ID From H输液配药内容 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    For P In (Select ID From H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id)) Loop
      For R In (Select Column_Value From Table(f_Str2list('输液配药附费,输液配药状态'))) Loop
        v_Table := r.Column_Value;
        v_Field := 'ID';
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                    ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.Id;
      End Loop;
    End Loop;
  
    Delete H输液配药记录 Where ID In (Select 记录id From H输液配药内容 Where 收发id = n_Rec_Id);
  
    v_Table  := '药品签名记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                ' Where ID In(Select 签名ID From H药品签名明细 Where 收发ID =:1)';
    Execute Immediate v_Sql
      Using n_Rec_Id;
    Delete H药品签名记录 Where ID In (Select 签名id From H药品签名明细 Where 收发id = n_Rec_Id);
  
    For R In (Select Column_Value From Table(f_Str2list('收发记录补充信息,输液配药内容,药品签名明细,药品留存计划'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '药品留存计划' Then
        v_Field := '留存ID';
      Else
        v_Field := '收发ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --删除已返回的药品收发记录
    Delete H药品收发记录 Where ID = n_Rec_Id;
  End Zl_Retu_Medilist;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --刘兴宏:主要是对基于视图的视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  --判断是否能按照单据返回
  Select Decode(Sum(Nvl(p.金额, 0)) - Sum(Nvl(p.冲预交, 0)), Null, 1, 0, 1, 0)
  Into n_Allow
  From H病人预交记录 P,
       (Select 结帐id
         From H门诊费用记录
         Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
               4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
         Union
         Select 结帐id
         From H住院费用记录
         Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
               4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
         Union
         Select 结帐id
         From H病人预交记录
         Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
         Union
         Select ID From H病人结帐记录 Where NO = v_No And 7 = n_Type) L
  Where p.结帐id = l.结帐id And p.记录性质 In (1, 11);
  If n_Allow = 1 Then
    Select Decode(Sum(Nvl(e.实收金额, 0)) - Sum(Nvl(e.结帐金额, 0)), Null, 1, 0, 1, 0)
    Into n_Allow
    From (Select e.实收金额, e.结帐金额
           From H门诊费用记录 E,
                (Select 结帐id
                  From H门诊费用记录
                  Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                        4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                  Union
                  Select 结帐id
                  From H病人预交记录
                  Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                  Union
                  Select ID From H病人结帐记录 Where NO = v_No And 7 = n_Type) L
           Where e.结帐id = l.结帐id
           Union All
           Select e.实收金额, e.结帐金额
           From H住院费用记录 E,
                (Select 结帐id
                  From H住院费用记录
                  Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                        4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                  Union
                  Select 结帐id
                  From H病人预交记录
                  Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                  Union
                  Select ID From H病人结帐记录 Where NO = v_No And 7 = n_Type) L
           Where e.结帐id = l.结帐id) E;
  End If;

  --按照单据或病人获取结帐游标返回
  If n_Allow = 1 Then
    For r_Settle In (Select 结帐id
                     From H门诊费用记录
                     Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                           4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                     Union
                     Select 结帐id
                     From H住院费用记录
                     Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                           4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5)
                     Union
                     Select 结帐id
                     From H病人预交记录
                     Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11)
                     Union All
                     Select ID From H病人结帐记录 Where NO = v_No And 7 = n_Type) Loop
    
      v_Table  := '病人结帐记录';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where id = :1';
      Execute Immediate v_Sql
        Using r_Settle.结帐id;
    
      Zl_Retu_Prepay(r_Settle.结帐id);
      For r_Rxlist In (Select m.Id
                       From H药品收发记录 M,
                            (Select ID, NO, 序号, 记录性质
                              From H门诊费用记录
                              Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                       Where m.No = e.No And m.费用id = e.Id And
                             (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                       Union All
                       Select m.Id
                       From H药品收发记录 M,
                            (Select ID, NO, 序号, 记录性质
                              From H住院费用记录
                              Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                       Where m.No = e.No And m.费用id = e.Id And
                             (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))) Loop
        Zl_Retu_Medilist(r_Rxlist.Id);
      End Loop;
      Zl_Retu_Fee(r_Settle.结帐id);
    
      Delete H病人结帐记录 Where ID = r_Settle.结帐id;
    End Loop;
  Else
    Begin
      --n_Type,单据类型:1-收费,2-记帐,3-自动记帐,4-挂号,5-就诊卡,6-预交,7-结帐
      If n_Type = 7 Then
        Select Distinct 病人id Into n_Patiid From H病人结帐记录 Where NO = v_No;
      Elsif n_Type = 6 Then
        Select Distinct 病人id Into n_Patiid From H病人预交记录 Where NO = v_No And 6 = n_Type And 记录性质 In (1, 11);
      Elsif n_Type = 5 Or n_Type = 3 Then
        Select Distinct 病人id
        Into n_Patiid
        From H住院费用记录
        Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
              4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
      Elsif n_Type = 4 Or n_Type = 1 Then
        If n_Type = 1 Then
          Select Distinct 病人id
          Into n_Patiid
          From (Select Distinct 病人id
                 From H门诊费用记录
                 Where NO = v_No And 记录性质 = 1
                 Union All
                 Select Distinct 病人id From H费用补充记录 Where NO = v_No And 记录性质 = 1)
          Where Rownum < 2;
        
        Else
          Select Distinct 病人id
          Into n_Patiid
          From H门诊费用记录
          Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
        End If;
      Else
        Begin
          Select Distinct 病人id
          Into n_Patiid
          From H住院费用记录
          Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
        Exception
          When Others Then
            n_Patiid := -1;
        End;
        If Nvl(n_Patiid, 0) <= 0 Then
          Select Distinct 病人id
          Into n_Patiid
          From H门诊费用记录
          Where NO = v_No And (1 = n_Type And 记录性质 = 1 Or 2 = n_Type And 记录性质 = 2 Or 3 = n_Type And 记录性质 = 3 Or
                4 = n_Type And 记录性质 = 4 Or 5 = n_Type And 记录性质 = 5);
        End If;
      End If;
    Exception
      When Others Then
        n_Patiid := Null;
    End Zl_Patiid;
  
    For r_Settle In (Select Distinct 结帐id
                     From H门诊费用记录
                     Where 病人id = n_Patiid
                     Union
                     Select Distinct 结帐id
                     From H住院费用记录
                     Where 病人id = n_Patiid
                     Union
                     Select Distinct 结算id From H费用补充记录 Where 病人id = n_Patiid) Loop
    
      v_Table  := '病人结帐记录';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || v_Fields || ' From H' || v_Table ||
                  ' Where id = :1';
      Execute Immediate v_Sql
        Using r_Settle.结帐id;
    
      Zl_Retu_Prepay(r_Settle.结帐id);
      For r_Rxlist In (Select m.Id
                       From H药品收发记录 M,
                            (Select ID, NO, 序号, 记录性质
                              From H门诊费用记录
                              Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                       Where m.No = e.No And m.费用id = e.Id And
                             (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                       Union All
                       Select m.Id
                       From H药品收发记录 M,
                            (Select ID, NO, 序号, 记录性质
                              From H住院费用记录
                              Where 结帐id = r_Settle.结帐id And 收费类别 In ('4', '5', '6', '7') And 记录性质 In (1, 2)) E
                       Where m.No = e.No And m.费用id = e.Id And
                             (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 <> 1 And m.单据 In (9, 10, 25, 26))
                       
                       ) Loop
        Zl_Retu_Medilist(r_Rxlist.Id);
      End Loop;
    
      Zl_Retu_Fee(r_Settle.结帐id);
      Delete H病人结帐记录 Where ID = r_Settle.结帐id;
    
    End Loop;
  End If;

  Begin
    Execute Immediate 'Update zlBakInfo Set 最后转储日期=Sysdate Where 系统=' || n_System;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Exes;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
--84458:涂建华,2015-07-21,新版pacs报告编辑器数据转出处理
--87787:张永康,2015-08-25,德阳转出测试性能优化及BUG修正
CREATE OR REPLACE Procedure Zl1_Datamove_Reb
( 
  System_In    In Number, 
  Speedmode_In In Number, 
  Func_In      In Number, 
  Enable_In    In Number := 0, 
  Parallel_In  In Number := 0, 
  Rebscope_In  In Number := 0 
) As 
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间 
  --参数： 
  --System_In:    应用系统编号,100=标准版 
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作） 
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引 
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效 
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部) 
 
  v_Sql Varchar2(1000); 
  n_Do  Number(1); 
  n_parallel Number(1);
  v_Tbs Varchar2(100); 
 
  --转出标记中的SQL查询所需的索引
  v_Indexeswithtag Varchar2(4000) := '门诊费用记录_IX_结帐ID,住院费用记录_IX_结帐ID,费用补充记录_IX_结算ID,费用补充记录_IX_登记时间,病人预交记录_IX_主页ID,病人预交记录_IX_结帐ID,病人预交记录_IX_收款时间,门诊费用记录_IX_登记时间,门诊费用记录_IX_医嘱序号,住院费用记录_IX_登记时间,病人结帐记录_IX_收费时间,病人结帐记录_IX_病人id' || 
                                     ',药品收发记录_IX_费用ID,收发记录补充信息_IX_收发ID,输液配药内容_IX_收发ID,药品留存计划_IX_留存ID,药品签名明细_IX_收发ID' || 
                                     ',人员借款记录_IX_借出时间,人员收缴记录_IX_登记时间,人员暂存记录_IX_收缴ID,人员暂存记录_IX_登记时间,票据领用记录_IX_登记时间,票据使用明细_IX_领用ID,票据打印明细_IX_使用ID' || 
                                     ',病人挂号记录_IX_登记时间,病人医嘱发送_IX_发送时间,病人医嘱记录_IX_挂号单,病人医嘱记录_IX_主页ID,病人医嘱记录_IX_相关ID' || 
                                     ',病案主页_IX_出院日期,住院费用记录_IX_病人ID,病人过敏记录_IX_病人ID,病人诊断记录_IX_病人ID,病人手麻记录_IX_主页ID' || 
                                     ',病人护理记录_IX_主页ID,病人护理内容_IX_记录id,病人护理文件_IX_主页ID,病人护理数据_IX_文件ID,病人护理明细_IX_记录ID,病人护理打印_IX_文件ID' || 
                                     ',电子病历记录_IX_病人ID,病人医嘱报告_IX_病历ID,影像报告驳回_IX_医嘱ID,报告查阅记录_IX_病历ID,病人诊断记录_IX_病历ID' || 
                                     ',病人临床路径_IX_病人ID,病人合并路径_IX_首要路径记录ID,病人路径执行_IX_路径记录ID,病人出径记录_IX_路径记录ID,病人诊断医嘱_IX_医嘱ID' || 
                                     ',影像报告记录_IX_医嘱ID,影像报告操作记录_IX_医嘱ID,影像申请单图像_IX_医嘱ID,影像收藏内容_IX_医嘱ID,检验标本记录_IX_医嘱ID,检验项目分布_IX_标本ID,检验分析记录_IX_标本ID' || 
                                     ',检验操作记录_IX_标本ID,检验图像结果_IX_标本ID,检验拒收记录_IX_医嘱ID,检验普通结果_IX_检验标本ID'; 
 
  --转出标记中的SQL查询所需的索引(主键及唯一键对应的索引) 
  v_Constraintswithtag Varchar2(4000) := '病人预交记录_UQ_NO,病人结帐记录_UQ_NO,病人结帐记录_PK,门诊费用记录_UQ_NO,住院费用记录_UQ_NO,医保结算明细_PK' || 
                                         ',病人卡结算对照_PK,费用补充记录_PK,病人卡结算记录_PK,三方结算交易_PK,输液配药记录_PK,药品签名记录_PK,票据打印内容_PK,病人挂号记录_PK,病人挂号汇总_UQ_日期,病人转诊记录_UQ_NO' || 
                                         ',病人护理活动项目_UQ_页号,病人护理要素内容_UQ_页号,产程要素内容_PK,电子病历记录_PK,电子病历附件_PK,电子病历格式_PK,电子病历内容_UQ_对象序号,电子病历图形_PK,疾病申报记录_PK' || 
                                         ',病人合并路径评估_PK,病人路径评估_PK,病人路径变异_PK,病人路径指标_UQ_评估指标,病人路径医嘱_PK' || 
                                         ',病人医嘱记录_PK,病人医嘱报告_PK,病人医嘱计价_UQ_收费细目ID,病人医嘱附费_PK,病人医嘱附件_PK,病人医嘱执行_PK,医嘱执行时间_PK,医嘱执行打印_PK,病人医嘱打印_UQ_医嘱ID,输血申请记录_PK,输血检验结果_PK' || 
                                         ',病人诊断记录_PK,病人医嘱状态_PK,医嘱签名记录_PK,病人医嘱发送_PK,诊疗单据打印_PK,医嘱执行计价_PK,执行打印记录_PK' || 
                                         ',影像检查记录_PK,影像检查序列_UQ_序列号,影像检查图象_UQ_图像号,影像危急值记录_UQ_医嘱ID' || 
                                         ',检验申请项目_PK,检验质控记录_PK,检验签名记录_PK,检验试剂记录_PK,检验质控报告_PK,检验药敏结果_PK,人员收缴记录_PK,人员收缴明细_PK,人员收缴票据_PK,人员收缴对照_PK'; 
 
  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除 
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能 
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。 
  Procedure Setconstraintstatus As 
  Begin 
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键 
    If Enable_In = 0 Then 
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name 
                From User_Constraints A, User_Constraints C, zlBakTables B 
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And 
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED' 
                Order By a.Table_Name) Loop 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name; 
        Execute Immediate v_Sql; 
      End Loop; 
 
      If Speedmode_In = 1 Then 
        --禁用主键或唯一键索引(必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录) 
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引) 
        For R In (Select a.Table_Name, a.Constraint_Name 
                  From User_Constraints A, zlBakTables T, User_Tables B 
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And 
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And 
                        a.Constraint_Name Not In 
                        (Select Upper(Column_Value) As Constraint_Name From Table(f_Str2list(v_Constraintswithtag))) 
                  Order By Constraint_Name) Loop 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name || 
                   ' Cascade Drop Index'; 
          Execute Immediate v_Sql; 
        End Loop; 
      End If; 
    Else 
      --启用时，先启用主键和唯一键，再启用引用转出表主键的他表外键 
      If Speedmode_In = 1 Then 
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式 
        For R In (Select d.Table_Name, d.Constraint_Name, LTrim(Max(Sys_Connect_By_Path(d.Column_Name, ',')), ',') Colstr 
                  From User_Cons_Columns D, 
                       (Select a.Table_Name, a.Constraint_Name 
                         From User_Constraints A, zlBakTables T 
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And 
                               a.Constraint_Type In ('P', 'U')) A 
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name 
                  Start With d.Position = 1 
                  Connect By Prior d.Position + 1 = d.Position And Prior d.Constraint_Name = d.Constraint_Name 
                  Group By d.Table_Name, d.Constraint_Name 
                  Order By Constraint_Name) Loop 
          Update Zldatamovelog 
          Set 当前进度 = '正在恢复约束:' || r.Constraint_Name 
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2; 
 
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create 
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr || 
                   ') Tablespace ' || v_Tbs || ' Nologging'; 
          Begin 
            Execute Immediate v_Sql; 
          Exception 
            When Others Then 
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错 
          End; 
 
          --会自动建立约束与索引的关联 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name; 
          Execute Immediate v_Sql; 
        End Loop; 
      End If; 
 
      --启用引用转出表主键的他表外键 
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name 
                From User_Constraints A, User_Constraints C, zlBakTables B 
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And 
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED' 
                Order By a.Table_Name) Loop 
        --为了加快速度，采用novalidate，不验证已有数据 
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name; 
        Execute Immediate v_Sql; 
      End Loop; 
    End If; 
  End Setconstraintstatus; 
 
  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID) 
  --说明：禁用索引是为了提高删除数据的性能 
  Procedure Setindexstatus As 
  Begin 
    If Speedmode_In = 1 Then 
      --保留转出标记中的SQL查询所需的索引 
      For R In (Select /*+ rule*/ 
                 a.Index_Name 
                From User_Indexes A, zlBakTables T 
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And 
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And 
                      a.Index_Name Not In 
                      (Select Upper(Column_Value) As Index_Name From Table(f_Str2list(v_Indexeswithtag))) And 
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists 
                 (Select 1 
                       From User_Constraints C 
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U')) 
                Order By Index_Name) Loop 
 
        If Enable_In = 0 Then 
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable'; 
          Execute Immediate v_Sql; 
        Else 
          Update Zldatamovelog 
          Set 当前进度 = '正在重建索引:' || r.Index_Name 
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging'; 
          Begin 
            Execute Immediate v_Sql; 
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
 
          Exception 
            When Others Then 
              If SQLErrM Like 'ORA-00054%' Then 
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online'); 
                Execute Immediate v_Sql; 
              End If; 
          End; 
        End If; 
      End Loop; 
    Else 
      For R In (Select a.Index_Name 
                From (Select d.Table_Name, d.Index_Name, LTrim(Max(Sys_Connect_By_Path(d.Column_Name, ',')), ',') Colstr 
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C 
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And 
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And 
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name 
                       Start With d.Column_Position = 1 
                       Connect By Prior d.Column_Position + 1 = d.Column_Position And Prior d.Index_Name = d.Index_Name 
                       Group By d.Table_Name, d.Index_Name) A, 
                     (Select e.Table_Name, LTrim(Max(Sys_Connect_By_Path(e.Column_Name, ',')), ',') Colstr 
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C 
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And 
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And 
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And 
                             Not Exists 
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In) 
                       Start With Nvl(e.Position, 1) = 1 
                       Connect By Prior Nvl(e.Position, 1) + 1 = Nvl(e.Position, 1) And 
                                  Prior e.Constraint_Name = e.Constraint_Name 
                       Group By e.Table_Name, e.Constraint_Name) B 
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr 
                Order By Index_Name) Loop 
 
        If Enable_In = 0 Then 
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用 
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '人员收缴记录_IX_缴款组ID') Then 
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable'; 
            Execute Immediate v_Sql; 
          End If; 
        Else 
          Update Zldatamovelog 
          Set 当前进度 = '正在重建索引:' || r.Index_Name 
          Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging'; 
          Execute Immediate v_Sql; 
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        End If; 
      End Loop; 
    End If; 
  End Setindexstatus; 
 
  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复 
  Procedure Settriggerstatus As 
  Begin 
    For R In (Select Distinct a.Table_Name, t.停用触发器 
              From User_Triggers A, zlBakTables T 
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And 
                    t.系统 = System_In) Loop 
      If Enable_In = 0 Then 
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS'; 
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name; 
      Elsif Nvl(r.停用触发器, 0) = 1 Then 
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS'; 
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name; 
      End If; 
      Execute Immediate v_Sql; 
    End Loop; 
    Commit; 
  End Settriggerstatus; 
 
  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用 
  Procedure Setjobstatus As 
    v_Jobs Varchar2(4000); 
  Begin 
    --停用 
    If Enable_In = 0 Then 
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop 
        Dbms_Job.Broken(r.Job, True); 
        v_Jobs := v_Jobs || ',' || r.Job; 
      End Loop; 
 
      If v_Jobs Is Not Null Then 
        v_Jobs := Substr(v_Jobs, 2); 
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1; 
      End If; 
    Else 
      --启用 
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1; 
      If v_Jobs Is Not Null Then 
        For R In (Select Job 
                  From User_Jobs 
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop 
          Dbms_Job.Broken(r.Job, False); 
        End Loop; 
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1; 
      End If; 
    End If; 
    --作业设置后必须提交事务才生效 
    Commit; 
  End Setjobstatus; 
Begin 
  If Parallel_In < 2 Then 
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL'; 
  Else 
    If Func_In In (6, 7) Or Func_In In (3, 4) And Enable_In = 1 Then 
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度） 
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度 
      --恢复在线库的约束和索引时，不管是不是在线模式，都加上并行，否则太慢
      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In; 
      n_parallel:=1;
    End If;  
  End If; 
 
  If Func_In = 1 Then 
    --1.设置触发器 
    Settriggerstatus; 
  Elsif Func_In = 2 Then 
    --2.设置自动作业 
    Setjobstatus; 
  Elsif Func_In = 3 Then 
    --3.设置约束状态 
    Setconstraintstatus; 
  Elsif Func_In = 4 Then 
    --4.设置索引状态 
    Setindexstatus; 
  Elsif Func_In = 5 Then 
    --5.重建"待转出"索引 
    For R In (Select b.Index_Name 
              From zlBakTables A, User_Indexes B 
              Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And b.Index_Name = b.Table_Name || '_IX_待转出' 
              Union All 
              Select '病案主页_IX_待转出' From Dual Where System_In = 100) Loop 
      Update Zldatamovelog 
      Set 当前进度 = '正在重建索引:' || r.Index_Name 
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
      --耗时太短，无须并行DDL 
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
      --在线重建索引太慢，所以，即使在线转出模式也不用在线重建
      v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';       
      Begin 
        Execute Immediate v_Sql; 
      Exception 
        When Others Then 
          If SQLErrM Like 'ORA-00054%' Then 
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online'); 
            Execute Immediate v_Sql; 
          End If; 
      End; 
    End Loop; 
 
  Elsif Func_In = 6 Then 
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间） 
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时 
    For R In (Select b.Index_Name, a.组号 
              From User_Indexes B, zlBakTables A 
              Where a.系统 = System_In And a.表名 = b.Table_Name And 
                    b.Index_Name In 
                    (Select Upper(Column_Value) 
                     From Table(f_Str2list(v_Indexeswithtag)) 
                     Union 
                     Select Upper(Column_Value) From Table(f_Str2list(v_Constraintswithtag))) 
              Order By Index_Name) Loop 
      n_Do := 0; 
      If Rebscope_In = 0 Then 
        If r.组号 < 5 Then 
          n_Do := 1; --仅经济核算类 
        End If; 
      Elsif Rebscope_In = 1 Then 
        If r.组号 < 5 Or r.组号 = 8 Then 
          n_Do := 1; --仅经济核算类、医嘱类 
        End If; 
      Else 
        n_Do := 1; 
      End If; 
 
      If n_Do = 1 Then 
        Update Zldatamovelog 
        Set 当前进度 = '正在重建索引:' || r.Index_Name 
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space'; 
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍 
        If Speedmode_In = 1 Then 
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging'; 
        Else 
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging'; 
        End If; 
        Begin 
          Execute Immediate v_Sql; 
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
 
        Exception 
          When Others Then 
            If SQLErrM Like 'ORA-00054%' Then 
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online'); 
              Execute Immediate v_Sql; 
            End If; 
        End; 
      End If; 
    End Loop; 
 
    --重组表的数据
  Elsif Func_In = 7 Then 
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组 
    For R In (Select a.表名 As Table_Name 
              From zlBakTables A 
              Where a.直接转出 = 1 And (组号 < Decode(Rebscope_In, 0, 5, 100)) 
              Order By 组号, 序号) Loop 
 
      Update Zldatamovelog 
      Set 当前进度 = '正在重组表:' || r.Table_Name 
      Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩 
      --在前面设置了会话级的强制并行 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging'; 
      Execute Immediate v_Sql; 
 
      --单独移动Lob对象 
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' || 
                 l.Tablespace_Name || ') Nologging'; 
        Execute Immediate v_Sql; 
      End Loop; 
 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel'; 
      Execute Immediate v_Sql; 
 
      --move后，表相关的索引会全部失效，需要全部重建 
      For S In (Select Index_Name 
                From User_Indexes 
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE'
                Order By Index_Name) Loop 
        Update Zldatamovelog 
        Set 当前进度 = '正在恢复失效索引:' || s.Index_Name 
        Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
 
        --在前面设置了会话级的强制并行 
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging'; 
        Execute Immediate v_Sql; 
      End Loop; 
    End Loop; 
  End If; 
 
  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢) 
  --------------------------------------------------------------------------------------------------- 
  If n_parallel=1 Then 
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL'; 
 
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop 
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel'; 
      Execute Immediate v_Sql; 
    End Loop; 
  End If; 
 
  Update Zldatamovelog 
  Set 当前进度 = '重建完成' 
  Where 系统 = System_In And 批次 = (Select Max(批次) From Zldatamovelog Where 系统 = System_In); 
  Commit; 
  --本过程不进行错误处理，错误由调用过程处理 
End Zl1_Datamove_Reb;
/


--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
--84458:涂建华,2015-07-21,新版pacs报告编辑器数据转出处理
--87787:张永康,2015-08-25,德阳转出测试性能优化及BUG修正
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End    In Date,
  n_批次   In Number,
  n_System In Number
) As
  --功能：标记待转出的数据 
  --说明：为避免Undo表空间膨胀过大，分段提交 
Begin
  --1.经济核算（费用,药品,收款和票据等）  
  --新加子查询注意性能优化，把能够将数据过滤到最小的条件放到最后，Exists类条件放前面
  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录(排除之后退号和退费的,一张单据中只要其中一行退了) 
         From 门诊费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
		 And a.待转出 Is Null And a.记录性质 In (1, 4) And a.登记时间 < d_End
         Union All
         Select Distinct a.结算id --2.医保补结算 
         From 费用补充记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 费用补充记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 In (1, 2) And b.登记时间 >= d_End))
		 And a.待转出 Is Null And a.记录性质 = 1 And a.登记时间 < d_End
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了) 
         From 住院费用记录 A
         Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                (Select 1
                 From 住院费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And b.记录状态 = 2 And b.登记时间 >= d_End))
		And a.待转出 Is Null And a.记帐费用 = 0 And a.记录性质 = 5 And a.登记时间 < d_End
         Union All --4.门诊(记帐单)和住院的结帐结算记录 
         Select 结帐id
         From (With Settle As (Select Distinct a.Id As 结帐id, a.病人id --3.门诊(记帐单)和住院的结帐结算记录(排除之后结帐作废的) 
                               From 病人结帐记录 A
                               Where (a.记录状态 In (1, 2) Or a.记录状态 = 3 And Not Exists
                                      (Select 1 From 病人结帐记录 B Where a.No = b.No And b.记录状态 = 2 And b.收费时间 >= d_End))
				      And a.待转出 Is Null And a.收费时间 < d_End)
                Select 结帐id
                From Settle
                Minus
                --以下结帐ID要整体排除,避免部分费用明细被转出后影响后续的计算是否冲完 
                --1.一张预交款被多笔结帐冲完（结帐ID不同）
                --2.费用单据的结帐ID相关的可能还有其他NO的其他结帐ID(结帐作废后分多次结帐结清，可能部分在转出时间之后)
                --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除 
                Select Distinct d.Id
                From 病人结帐记录 D,
                     (Select Distinct c.病人id --多次住院可以一起结，以及门诊记帐和住院记帐可以一起结且冲同一笔预交，所以这里不加主页ID 
                       From 住院费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 住院费用记录 D,
                                   (Select s.结帐id From Settle S, 病人结帐记录 E --没有结清且该病人之后没有再结过就成了呆帐，这种就不排除 
                                     Where s.病人id = e.病人id And (e.收费时间 > d_End Or Exists (Select 1 From 在院病人 F Where s.病人id = f.病人id))) S 
                              Where d.结帐id = s.结帐id) D
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号 --结帐后作废后，再对包含记帐单销帐的结帐ID为空的记录,一起汇总计算是否结清,这种结帐ID为空的数据转出在后面单独转出 
                       Group By c.No, Mod(c.记录性质, 10), c.病人id --一张单据中的一行可部分结帐，以单据为对象来判断，避免一张单据的其中一部分被转出 
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1 --排除转出时间之后再次结帐的(作废后再次结帐)，避免原始单据转走后，后续结帐时无法正确判断 
                                                                                   From 住院费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id  And s.待转出 Is Null And s.收费时间 >= d_End)
                       Union All
                       Select Distinct c.病人id
                       From 门诊费用记录 C,
                            (Select Distinct d.No, d.序号, Mod(d.记录性质, 10) As 记录性质
                              From 门诊费用记录 D, Settle S
                              Where d.结帐id = s.结帐id) D --因为是门诊病人，所以，只要没有结清,该病人的都不转出 
                       Where c.No = d.No And Mod(c.记录性质, 10) = d.记录性质 And c.序号 = d.序号
                       Group By c.No, Mod(c.记录性质, 10), c.病人id
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) Or Exists (Select 1
                                                                                   From 门诊费用记录 E, 病人结帐记录 S
                                                                                   Where e.No = c.No And Mod(e.记录性质, 10) = Mod(c.记录性质, 10) And
                                                                                         e.记录性质 In (12, 13, 15) And e.结帐id = s.Id And s.待转出 Is Null And s.收费时间 >= d_End)) N
                Where d.病人id = n.病人id)
         );

  --排除预交款未冲完的
  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除 
  --由于可能存在数据异常(住院费用结帐冲预交类别为1的门诊预交)，所以没有加预交类别条件限定 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In (Select Distinct d.结帐id
                 From 病人预交记录 D,
                      --连接D表是为了查冲同一预交单据的其他结帐ID（退预交款，冲预交作废的，再次冲同一预交单据） 
                      --该预交或冲预交单据涉及的所有结帐ID的都不转出，避免部分冲预交的结帐ID被排除后，原始预交单被转走，或者其他结帐ID将费用单据的一部分(原始结帐、结帐作废、再次结一部分、再次结全部)转走 
                      (Select Distinct l.No
                        From 病人预交记录 L, 病人预交记录 P --可能本次结帐冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID 
                        Where l.记录性质 = p.记录性质 And l.No = p.No And p.记录性质 In (1, 11) And p.待转出 = n_批次
                        Group By l.No, l.病人id
                        Having Nvl(Sum(l.金额), 0) <> Nvl(Sum(l.冲预交), 0) And (Exists (Select 1
                                                                                  From 病人预交记录 E --没有冲完且之后没有再冲过或结算过就成了呆帐（以及存在用负的结帐补款来表示冲预交当成冲完的清况），这种就不排除
                                                                                  Where l.病人id = e.病人id And e.待转出 Is Null And e.收款时间 > d_End)
                                                                                  Or Exists (Select 1 From 在院病人 E Where l.病人id =e.病人id)
                                                                                  Or Exists (Select 1 From 病人未结费用 E Where l.病人id =e.病人id))  
                        Or Nvl(Sum(l.金额), 0) = Nvl(Sum(l.冲预交), 0) And Exists (Select 1
                                                                                  From 病人预交记录 E --排除转出时间之后的其他结帐ID冲的,10.34.20后，冲预交全部单独增加了一条记录，收费时间就是冲预交时间(以前是在原始交预交款的记录上填冲预交字段，不能直接查到冲预交款的时间)
                                                                                  Where e.No = l.No And e.记录性质 = 11 And e.待转出 Is Null And e.收款时间 >= d_End)) N
                 Where d.No = n.No And d.记录性质 In (1, 11));

  --预交款没有使用就直接退了的记录(结帐ID为空) 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --冲预交款作废的记录（记录性质为2），没有结帐ID 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 2 And NO In (Select a.No From 病人预交记录 A Where a.待转出 = n_批次 And a.记录性质 = 3);

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐) 
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  --1.挂号打折后实收金额为0的(没有对应的预交记录),即使之后有退号费用也不管，因为金额为零不影响计算),而卡费即使为零也有预交记录 
  --结帐ID为空的是异常数据（德阳医院仅有3笔此类数据）
  --根据挂号记录再找门诊费用，比直接按时间查门诊费用要快 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where NO In (Select NO From 病人挂号记录 Where 待转出 Is Null And 登记时间 < d_End) And 记录性质 = 4 And (实收金额 = 0 Or 结帐id Is Null);

  --2.直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --3.没有结帐的门诊记帐单
  --已冲销的或打折后实收金额为零的，且本次挂号没有其他记帐单的强制转出 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 记录性质 = 2 And
        NO In
        (Select NO
         From (Select b.挂号单, a.No, a.序号, Sum(a.实收金额)
                From 门诊费用记录 A, 病人医嘱记录 B
                Where a.医嘱序号 = b.Id And a.记录性质 = 2 And b.病人来源 <> 4 And a.待转出 Is Null And a.结帐id Is Null And a.登记时间 < d_End
                Group By a.No, a.序号, b.挂号单
                Having Sum(a.实收金额) = 0 And Not Exists (Select 1
                                                      From 门诊费用记录 C, 病人医嘱记录 D
                                                      Where b.挂号单 = d.挂号单 And d.Id = c.医嘱序号 And d.病人来源 <> 4 And c.记录性质 = 2 And
                                                            c.待转出 Is Null
                                                      Group By c.No, c.序号
                                                      Having Sum(a.实收金额) > 0)));

  --4.没有结帐id的数据
  --1)结帐作废后，记帐单销帐的记录（结帐ID为空，记录状态为2，记录状态为3的有结帐ID的在最前面已转出） 
  --2)未结帐的零费用(已冲销的记帐单) 
  --3)未结帐的门诊记帐费用(赖账)，该病人没有预交记录或冲预交记录，并且该时间之后无门诊费用发生
  --4)未结帐的划价记录
  --5)未收费（也没有冲预交）的零费用
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 门诊费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 门诊费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0) Or
         (Not Exists (Select 1 From 病人预交记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 记录性质 In (1, 11)) And Not Exists
          (Select 1 From 门诊费用记录 B Where a.病人id = b.病人id And b.待转出 Is Null And 登记时间 > d_End))) And 记录性质 = 2 Or 记录状态 = 0 Or
        记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And 结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --5.有结帐id的零费用
  --按费别打折后结帐金额为零的收费记录,或者一张单据相同结帐ID的结帐金额之和为0(冲销后为零)
  --即使在转出时间之后发药的，也强制转出（为了减少逻辑复杂性，提高查询性能）
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (结帐金额 = 0 Or Exists
         (Select 1 From 门诊费用记录 C Where a.结帐id = c.结帐id Group By c.结帐id, c.No Having Sum(c.结帐金额) = 0)) And Not Exists
   (Select 1 From 病人预交记录 B Where a.结帐id = b.结帐id And b.待转出 Is Null) And 记录性质 = 1 And 结帐id Is Not Null And 待转出 Is Null And
        登记时间 < d_End;

  Update /*+ rule*/ 医保结算明细
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);

  --从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的 
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --1.转出结帐作废后，记帐单销帐的记录（记帐状态为2且没有结帐ID且(记录状态为3的有结帐ID的)在最前面已转出） 
  --2.未结帐的零费用(已冲销的记帐单) 
  --3.没有结帐ID的划价记录处理为转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 Or 记录状态 = 0) And 结帐id Is Null And 待转出 Is Null And 登记时间 < d_End;

  --由于存在赖帐病人离院未结的情况，对于很久以前的这些数据，如果预交已冲完，则处理为要转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.待转出 Is Null And b.预交类别 = 2 And b.记录性质 In (1, 11)
                                Having Nvl(Sum(b.金额), 0) - Nvl(Sum(b.冲预交), 0) <> 0));

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists
   (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_End) And 待转出 Is Null And 剩余数量 = 0 And 登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据 
  --不转出的条件：挂号费用未转出的，转出时间之后存在医嘱，医嘱对应的费用未转出的 
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出 
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1
                From 门诊费用记录 A
                Where r.No = a.No And a.登记时间 < d_End And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.待转出 Is Null And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_End) And Not Exists
          (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And r.待转出 Is Null And
               r.登记时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配 
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

  --通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用 
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人当时并未出院(一次住院多次结帐)。 
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低） 
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
        数据转出 Is Null And 出院日期 < d_End And
        (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据 
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据 
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据 
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id
                                       From 病案主页
                                       Where 待转出 = n_批次);

  --自登记类病人(无挂号单号) 
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID 
  --为提升性能，不从医嘱发送记录的发送时间查询，不采用精确的时间，因为直接登记的检验医嘱，一般开嘱时间与发送时间相差不大
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = N_批次
  Where ID In (Select C.病历id
             From 病人医嘱记录 B, 病人医嘱报告 C
             Where C.医嘱id = B.Id And Nvl(B.主页id, 0) = 0 And B.挂号单 Is Null And B.相关id Is Null And B.待转出 Is Null And
                   B.开嘱时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径 
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/


--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  v_Msg      Varchar2(5000);
  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10)
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                2
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id := 冲销id_In;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id := n_重结id;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In,
         交易说明_In, Null, 3);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号,
                   交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                                 预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 冲销id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Procedure Zl_门诊收费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  结帐id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  退支票额_In     病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成结算_In     Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-普通收费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --     ②退支票额_In:如果涉及退支票,则传入本次的退支票额,非正常收费时,传入零
  --   1.三方卡结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②退支票额_In:传入零
  --     ③卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   2-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.." 
  --     ②退支票额_In:传入零
  --   3-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."  消费卡ID:为零时,根据卡号自动定位
  --     ②冲预交_In: 传入零
  --     ②退支票额_In:传入零
  -- 冲预交_In: 存在冲预交时,传入
  -- 误差金额_In:存在误差费时,传入
  -- 完成结算_In:1-完成收费;0-未完成收费
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_退支票   病人预交记录.结算方式%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();

  Cursor c_Feedata Is
    Select Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名, Sum(结帐金额) As 结算金额,
           Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 结帐id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 结帐id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

Begin
  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0))
  Into n_Count, n_Havenull
  From 病人预交记录
  Where 结帐id = 结帐id_In;
  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Open c_Feedata;
    Begin
      Fetch c_Feedata
        Into r_Feedata;
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), 6);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 结帐id_In, r_Feedata.缴款组id, -1 * 结帐id_In, 1, 3);
      End If;
    Exception
      When Others Then
        n_Count := 1;
    End;
    Close c_Feedata;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的收费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  If 操作类型_In = 0 And Nvl(退支票额_In, 0) <> 0 Then
    Begin
      Select b.名称
      Into v_退支票
      From 结算方式应用 A, 结算方式 B
      Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
    Exception
      When Others Then
        v_退支票 := '无';
    End;
    If v_退支票 = '无' Then
      v_Err_Msg := '在结算场合中,不存在结算性质为应付款的结算方式,请在[结算方式]中设置！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = 结帐id_In And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 误差金额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    End If;
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Item;
    End If;
  
    --病人余额检查
    Begin
      Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
      Into n_预交金额
      From 病人余额
      Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
    Exception
      When Others Then
        n_预交金额 := 0;
    End;
    If n_预交金额 < 冲预交_In Then
      v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                   LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
  
    For c_冲预交 In (Select *
                  From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                         From 病人预交记录 A,
                              (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                From 病人预交记录 A
                                Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                Group By NO
                                Having Sum(Nvl(a.金额, 0)) <> 0) B
                         Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                         Union All
                         Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                         From 病人预交记录
                         Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                               预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                         Group By 记录状态, NO)
                  Order By ID, NO) Loop
    
      If c_冲预交.金额 - n_预交金额 < 0 Then
        n_冲预交 := c_冲预交.金额;
      Else
        n_冲预交 := n_预交金额;
      End If;
    
      If c_冲预交.Id <> 0 Then
        --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = -1 * 结帐id_In, 结算性质 = 3
        Where ID = c_冲预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, 结帐id_In, r_Balancedata.缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * 结帐id_In, 3
        From 病人预交记录
        Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_冲预交
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      --检查是否已经处理完
      If c_冲预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_冲预交.金额;
      Else
        n_预交金额 := 0;
      End If;
      If n_预交金额 = 0 Then
        Exit;
      End If;
    
    End Loop;
    --检查金额是否足够
    If Abs(n_预交金额) > 0 Then
      v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || '，支付失败！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
      n_返回值 := -1 * 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;
  If 操作类型_In = 0 Then
  
    If Nvl(退支票额_In, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_退支票, r_Balancedata.收款时间, r_Balancedata.操作员编号,
         r_Balancedata.操作员姓名, 退支票额_In, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号_In,
         交易流水号_In, 交易说明_In, Null, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - 退支票额_In Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(n_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If 操作类型_In = 1 Then
    --三方卡结算交易
  
    v_当前结算 := 结算方式_In;
  
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
         2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3);
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --2.医保结算(调用此过程,采取平均分摊的方式分摊结算情况):这种情况医保结处后,必须全退
  If 操作类型_In = 2 Then
    --2.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 结帐id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1)
    
     Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 结帐id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 结帐id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 结帐id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --3-消费卡批量结算
  If 操作类型_In = 3 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = 卡类别id_In;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_消费卡id, 0) = 0 Then
        --未传入消费卡ID时,以卡号为准进行查找(卡号的合法性,在程序中有判断)
        Begin
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = n_卡类别id And 卡号 = v_卡号 And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = v_卡号);
        Exception
          When Others Then
            n_消费卡id := 0;
        End;
        If Nvl(n_消费卡id, 0) = 0 Then
          v_Err_Msg := '未找到卡号为:' || v_卡号 || '的' || v_名称 || '.,本次刷卡消费失败!';
          Raise Err_Item;
        End If;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Then
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质)
          Values
            (n_预交id, 3, Null, 1, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata. 收款时间, r_Balancedata. 操作员编号,
             r_Balancedata. 操作员姓名, n_结算金额, r_Balancedata. 结帐id, r_Balancedata. 缴款组id, r_Balancedata. 结算序号, n_卡类别id, 2, 3);
        End If;
      
        --插入卡结算记录
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata. 收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = r_Balancedata. 结帐id And 结算方式 Is Null And Nvl(校对标志, 0) = 1
        Returning Nvl(冲预交, 0) Into n_返回值;
      
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成结算_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 结帐id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = 结帐id_In;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 结帐id_In;

  --4.更新人员缴款数据
  For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结帐id = 结帐id_In And Mod(a.记录性质, 10) <> 1
               Group By 结算方式, 操作员姓名) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
    Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
    End If;
  End Loop;
  --收费后产生导引
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4,结帐id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Modify;
/

--86321:冉俊明,2015-07-24,医保多单据一次收费分单据退费
Create Or Replace Function Zl_Getinsurebalancenum
(
  记录id_In In 保险结算记录.记录id%Type,
  No_In     In 门诊费用记录.No%Type
) Return Number Is
  -------------------------------------------------------------------------------------------
  --功能:针对门诊收费按多单据一次结算分单据退费模式增加此过程，
  --     用于获取单据对应保险结算记录的序号
  --入参:
  --      记录id_In - 收费结帐ID
  --      NO_In - 单据号
  --返回:
  --      单据对应的保险结算记录的序号
  --说明:
  --      因为无法知道渠道人员是否会在"保险结算记录"中增加"NO"列，
  --      也有可能增加列的列名不是"NO"，而是其它的，如"单据号"等。
  --      所以，增加此函数由渠道人员自己定义，只要得到"序号"，就能确定单据与保险结算记录的对应关系。
  --调用过程：
  --      Zl_保险结算记录_作废
  -------------------------------------------------------------------------------------------
  v_Sql  Varchar2(4000);
  n_序号 Number(18);
Begin
  If No_In Is Null Then
    Return Null;
  End If;

  v_Sql := 'Select Max(序号) From 保险结算记录 Where 记录ID = :1 And NO = :2 And Rownum < 2';
  Execute Immediate v_Sql
    Into n_序号
    Using 记录id_In, No_In;
  Return n_序号;
End Zl_Getinsurebalancenum;
/

--86257:刘尔旋,2015-07-24,门诊转住院分单据转出
Create Or Replace Procedure Zl_门诊费用转住院_Insert
(
  No_In         住院费用记录.No%Type,
  住院号_In     住院费用记录.标识号%Type, --医保入院补充登记时才传入
  主页id_In     住院费用记录.主页id%Type, --医保入院补充登记时才传入
  入院时间_In   住院费用记录.发生时间%Type,
  入院科室id_In 病人预交记录.科室id%Type,
  退费时间_In   住院费用记录.登记时间%Type, --多张单据退费时,每张单据的退费时间相同,都是系统当前时间
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  入院病区id_In 住院费用记录.病人病区id%Type := Null,
  单据_In       Number := 1,
  结帐id_In     住院费用记录.结帐id%Type := Null,
  原结帐id_In   住院费用记录.结帐id%Type := Null
) As
  --单据_In:1-门诊收费单;2-记帐单
  v_Billno   住院费用记录.No%Type;
  n_实收合计 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;

  n_病区id     住院费用记录.病人病区id%Type;
  v_床号       住院费用记录.床号%Type;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  n_开单部门id     部门表.Id%Type;
  n_操作员编号     门诊费用记录.操作员编号%Type;
  v_操作员姓名     门诊费用记录.操作员姓名%Type;
  v_开单人         人员表.姓名%Type;
  n_病人id         病人信息.病人id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_立即销帐       Number(2);
  v_Nos            Varchar2(3000);
  n_结帐id         门诊费用记录.结帐id%Type;
  v_Err_Msg        Varchar2(255);
  n_组id           财务缴款分组.Id%Type;
  Err_Item Exception;
  n_Count Number(18);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  If Nvl(主页id_In, 0) <> 0 Then
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 病人id
        Into n_病人id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And Rownum = 1;
      Exception
        When Others Then
          n_病人id := 0;
      End;
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  -- n_门诊转住院先审核 := Zl_To_Number(Zl_Getsysparameter('门诊转住院先审核', 1143));
  n_立即销帐 := Zl_To_Number(zl_GetSysParameter('费用转出立即退费', 1131));

  If 原结帐id_In Is Null Then
    If Nvl(n_立即销帐, 0) = 1 Then
      If Mod(单据_In, 10) = 1 Then
        --转收费单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In,门诊退费_In(0-门诊转住院立即销帐;1-门诊退费模式),入院科室id_In,主页id_In
        Zl_门诊转住院_收费转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id);
      Else
        --转记帐单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In
        Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
      End If;
    End If;
    --规则
    -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
    -- 2.主页id_In<>0 :
    If Nvl(入院病区id_In, 0) <> 0 Then
      n_病区id := 入院病区id_In;
    Elsif Nvl(主页id_In, 0) <> 0 Then
      Begin
        Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
        Into n_病区id, v_床号
        From 病人信息 A, 病案主页 B
        Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
      Exception
        When Others Then
          n_病区id := Null;
      End;
    End If;
  
    If Nvl(n_病区id, 0) = 0 Then
      --以入院科室为准
      n_病区id := Nvl(入院科室id_In, 0);
    End If;
  
    --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
    --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
    Select 病人id, 开单部门id, 开单人
    Into n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;
  
    --5.产生记帐单
    --需要检查是否已经转出
    Select Count(*)
    Into n_Count
    From 门诊费用记录 A
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
     (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
    If n_Count >= 1 Then
      v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
      Raise Err_Item;
    End If;
    If Mod(单据_In, 10) = 1 Then
      --收费按照结算序号查出包含NO号进行处理
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
      v_Billno     := Nextno(14);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
                              保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价,
                              Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                              Max(执行人) As 执行人, 划价人, Max(记帐单id) As 记帐单id, Max(是否急诊) As 是否急诊, 发生时间, Min(实际票号) As 实际票号,
                              Max(执行状态) As 执行状态
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And
                             Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '',
             r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1, 1);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In
              (Select ID
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In
              (Select ID
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
    Else
      --记账按照单据NO进行处理
      v_Billno     := Nextno(14);
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人,
                              Max(记帐单id) As 记帐单id, 发生时间, 实际票号, Max(执行状态) As 执行状态
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id,
                                保险编码, 费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间,
                                实际票号
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id,
             n_结帐id, -1 * r_Clinic.实收金额, 1);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In (Select ID
                         From 门诊费用记录
                         Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
    End If;
  Else
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
    If Nvl(n_立即销帐, 0) = 1 Then
      If Mod(单据_In, 10) = 1 Then
        Zl_门诊转住院_收费转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id, 原结帐id_In);
      Else
        --转记帐单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In
        Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
      End If;
    End If;
    --规则
    -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
    -- 2.主页id_In<>0 :
    If Nvl(入院病区id_In, 0) <> 0 Then
      n_病区id := 入院病区id_In;
    Elsif Nvl(主页id_In, 0) <> 0 Then
      Begin
        Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
        Into n_病区id, v_床号
        From 病人信息 A, 病案主页 B
        Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
      Exception
        When Others Then
          n_病区id := Null;
      End;
    End If;
  
    If Nvl(n_病区id, 0) = 0 Then
      --以入院科室为准
      n_病区id := Nvl(入院科室id_In, 0);
    End If;
  
    --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
    --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
    Select 病人id, 开单部门id, 开单人
    Into n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;
  
    --5.产生记帐单
    --需要检查是否已经转出
    Select Count(*)
    Into n_Count
    From 门诊费用记录 A
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
     (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
    If n_Count >= 1 Then
      v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
      Raise Err_Item;
    End If;
    If Mod(单据_In, 10) = 1 Then
      --收费按照结算序号查出包含NO号进行处理
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
      For r_Nos In (Select Distinct c.No
                    From 门诊费用记录 A, 门诊费用记录 C
                    Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In And c.No = a.No And
                          Mod(c.记录性质, 10) = 1 And c.记录状态 In (1, 3)) Loop
        v_Billno := Nextno(14);
      
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
           记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
          Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
                 Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
                 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
          From 门诊费用记录
          Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
      
        If Nvl(n_立即销帐, 0) = 1 Then
          Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
        End If;
      
        For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
                                保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价,
                                Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                                Max(执行人) As 执行人, 划价人, Max(记帐单id) As 记帐单id, Max(是否急诊) As 是否急诊, 发生时间, Min(实际票号) As 实际票号,
                                Max(执行状态) As 执行状态
                         From 门诊费用记录
                         Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And
                               Nvl(附加标志, 0) Not In (8, 9)
                         Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                  费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间
                         Having Sum(数次) <> 0) Loop
          Select 操作员编号, 操作员姓名
          Into n_操作员编号, v_操作员姓名
          From 门诊费用记录
          Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
          Insert Into 住院费用记录
            (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
             收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
             记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态)
          Values
            (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
             住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
             r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否,
             r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志,
             r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额,
             1, r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
             v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态);
          If Nvl(n_立即销帐, 0) = 1 Then
            Insert Into 门诊费用记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
               保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
               开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
            Values
              (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Nos.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
               1, r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别,
               r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码,
               r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
               r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额,
               0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In,
               操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1, 1);
          End If;
        End Loop;
      
        --8-工本费，9-误差费
        --病人余额
        Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
        Update 病人余额
        Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
        Returning 费用余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
          n_返回值 := n_实收合计;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --病人未结费用
        For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                      From 住院费用记录
                      Where NO = v_Billno And 记录性质 = 2
                      Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
          Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
                Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
                Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
          End If;
        End Loop;
      
        --6.药品相关数据处理
        For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                      From 住院费用记录 A, 材料特性 B
                      Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
          Update 药品收发记录
          Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
          Where NO = r_Nos.No And 单据 In (8, 9, 24, 25) And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
          If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
            --更新备货材料
            Update 药品收发记录
            Set 费用id = r_Fee.Id
            Where 单据 = 21 And 费用id In (Select ID
                                       From 门诊费用记录
                                       Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And
                                             序号 = r_Fee.序号);
          End If;
          --更新费用审核记录
          Update 费用审核记录
          Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
          Where 费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And
                性质 = 1;
          If Sql%NotFound Then
            --未找到数据时，要强制进行对应.
            Insert Into 费用审核记录
              (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
              Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
              From 门诊费用记录
              Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
          End If;
        End Loop;
        Update 未发药品记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
        Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
      End Loop;
    Else
      --记账按照单据NO进行处理
      v_Billno     := Nextno(14);
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人,
                              Max(记帐单id) As 记帐单id, 发生时间, 实际票号, Max(执行状态) As 执行状态
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id,
                                保险编码, 费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间,
                                实际票号
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id,
             n_结帐id, -1 * r_Clinic.实收金额, 1);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In (Select ID
                         From 门诊费用记录
                         Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊费用转住院_Insert;
/

--86257:刘尔旋,2015-08-06,门诊转住院分单据转出
Create Or Replace Procedure Zl_门诊转住院_三方卡结算
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  三方退费_In   Number := 0,
  结帐id_In     病人预交记录.结帐id%Type := Null
) As
  v_结帐ids    Varchar2(3000);
  n_组id       财务缴款分组.Id%Type;
  n_退现       Number;
  v_预交no     病人预交记录.No%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  v_Nos        Varchar2(3000);
  v_Info       Varchar2(5000);
  v_当前结算   Varchar2(3000);
  v_原结帐ids  Varchar2(5000);
  n_Tempid     病人预交记录.Id%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       病人预交记录.交易说明%Type;
  n_预交id     病人预交记录.Id%Type;
  n_原预交id   病人预交记录.Id%Type;
  n_病人id     病人信息.病人id%Type;
  n_原结帐id   病人预交记录.结帐id%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_卡序号     病人预交记录.卡类别id%Type;
  n_三方卡     Number;
  n_返回值     人员缴款余额.余额%Type;
  v_结算方式   病人预交记录.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_卡号       病人预交记录.卡号%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  v_交易说明   病人预交记录.交易说明%Type;
  n_原样退     Number;
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Min(c.序号) As 序号, Min(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;

  For r_结账id In (Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select 结帐id
                                             From 病人预交记录
                                             Where 结算序号 In (Select b.结算序号
                                                            From 门诊费用记录 A, 病人预交记录 B
                                                            Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                  a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                       Mod(记录性质, 10) = 1 And 记录状态 <> 0
                 Union
                 Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO In (Select Distinct NO
                              From 门诊费用记录
                              Where 结帐id In (Select a.结帐id
                                             From 门诊费用记录 A, 病人预交记录 B
                                             Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                   a.结帐id = b.结帐id))) Loop
    v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
  End Loop;
  v_原结帐ids := Substr(v_原结帐ids, 2);

  Begin
    Select 摘要
    Into v_Info
    From 病人预交记录
    Where 结算方式 Is Null And 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id;
  Exception
    When Others Then
      v_Info := '';
  End;
  --处理卡结算信息
  If v_Info Is Not Null Then
    While v_Info Is Not Null Loop
      v_当前结算 := Substr(v_Info, 1, Instr(v_Info, '|') - 1);
      n_三方卡   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_卡序号   := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
      n_冲销金额 := -1 * To_Number(v_当前结算);
    
      If n_三方卡 = 0 Then
        --消费卡
        Select 结算方式
        Into v_结算方式
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 结算卡序号 = n_卡序号 And Rownum < 2;
        Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_冲销金额, n_卡序号);
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) - n_冲销金额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
          n_返回值 := n_冲销金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
        End If;
      Else
        --结算卡
        Select 结算方式, 卡类别id, 卡号, 交易流水号, 交易说明
        Into v_结算方式, n_卡类别id, v_卡号, v_交易流水号, v_交易说明
        From 病人预交记录
        Where 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And 卡类别id = n_卡序号 And Rownum < 2;
        If Nvl(门诊退费_In, 0) = 1 Then
          If 三方退费_In = 0 Then
            v_Err_Msg := '存在无法退现的三方账户,无法进行退费!';
            Raise Err_Item;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_冲销金额
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
               -1 * n_结帐id, 0, 3);
          End If;
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - n_冲销金额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
            n_返回值 := -1 * n_冲销金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
          End If;
        Else
          Begin
            Select 1 Into n_退现 From 医疗卡类别 Where ID = n_卡类别id And 是否退现 = 1;
          Exception
            When Others Then
              n_退现 := 0;
          End;
        
          If 三方退费_In = 1 Or n_退现 = 0 Then
            v_结算方式 := v_结算方式;
            n_原样退   := 1;
          Else
            n_原样退 := 0;
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If 三方退费_In = 0 Then
            If n_原样退 = 1 Then
              Select 交易流水号, 交易说明, ID
              Into v_流水号, v_说明, n_原预交id
              From 病人预交记录
              Where 结帐id = n_原结帐id And 结算方式 = v_结算方式 And Rownum < 2;
            
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              Update 病人预交记录
              Set 金额 = 金额 + n_冲销金额
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位)
                Values
                  (n_预交id, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In, Null, Null,
                   Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2, n_卡类别id, Null, v_卡号, v_流水号, v_说明, Null);
                Update 三方结算交易 Set 交易id = n_预交id Where 交易id = n_原预交id;
              End If;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 - n_冲销金额
              Where 记录性质 = 3 And 记录状态 = 2 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式 And 结帐id = n_结帐id;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            
              Update 病人预交记录
              Set 金额 = 金额 + n_冲销金额
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_冲销金额, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, 2);
              End If;
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + n_冲销金额
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_冲销金额, 0);
              n_返回值 := n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If 三方退费_In = 1 Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - n_冲销金额
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * n_冲销金额);
              n_返回值 := -1 * n_冲销金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_冲销金额)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_冲销金额, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, n_卡类别id, Null, v_卡号, v_交易流水号, v_交易说明, Null, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End If;
      v_Info := Substr(v_Info, Instr(v_Info, '|') + 1);
    End Loop;
  End If;

  Delete From 病人预交记录 Where 结帐id = n_结帐id And 记录状态 = 2 And 结算方式 Is Null;
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_结帐id;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_三方卡结算;
/

--86257:刘尔旋,2015-08-07,门诊转住院分单据转出
Create Or Replace Procedure Zl_门诊转住院_收费转出
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  原结帐id_In   病人预交记录.结帐id%Type := Null,
  误差费_In     病人预交记录.冲预交%Type := Null
) As
  --门诊退费_In:0-门诊转住院立即销帐;1-门诊退费模式
  -- 门诊退费_In为1时:入院科室id_In和主页ID_IN可以不传入
  n_Count      Number(5);
  n_原结帐id   住院费用记录.结帐id%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  n_预交使用额 病人预交记录.冲预交%Type;
  n_实际冲销   病人预交记录.冲预交%Type;
  n_组id       财务缴款分组.Id%Type;
  n_病人id     病人信息.病人id%Type;
  v_预交no     病人预交记录.No%Type;
  n_预交金额   病人预交记录.冲预交%Type;
  n_打印id     票据使用明细.打印id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_误差费     病人预交记录.冲预交%Type;
  v_误差费     结算方式.名称%Type;
  n_返回值     病人余额.费用余额%Type;
  v_结算方式   结算方式.名称%Type;
  v_Nos        Varchar2(3000);
  v_结帐ids    Varchar2(3000);
  v_原结帐ids  Varchar2(3000);
  n_Tempid     病人预交记录.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_医保       Number;
  n_存在       Number;
  n_退现       Number;
  n_部分退费   Number;
  n_退费条数   Number;
  n_异常标志   Number;
  n_计算误差   Number;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Max(c.序号) As 序号, Max(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --误差费
  Begin
    Select 名称 Into v_误差费 From 结算方式 Where 性质 = 9 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现误差结算方式，请检查是否正确设置！';
      Raise Err_Item;
  End;

  If 原结帐id_In Is Null Then
  
    Select Count(NO), Sum(实收金额) Into n_Count, n_实收金额 From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '单据' || No_In || '不是收费单据或因并发原因他人操作了该单据,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
             收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额, -1 * 实收金额, 开单部门id,
             开单人, 执行部门id, 划价人, 执行人, -1, 执行时间, 操作员编号_In, 操作员姓名_In, 发生时间, 退费时间_In, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, 统筹金额,
             摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id, 1
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --1.2作废预交记录
    --作废冲预交部分
    For r_结账id In (Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select 结帐id
                                               From 病人预交记录
                                               Where 结算序号 In (Select b.结算序号
                                                              From 门诊费用记录 A, 病人预交记录 B
                                                              Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                    a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                         Mod(记录性质, 10) = 1 And 记录状态 <> 0
                   Union
                   Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select a.结帐id
                                               From 门诊费用记录 A, 病人预交记录 B
                                               Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                     a.结帐id = b.结帐id))) Loop
      v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
    End Loop;
    v_原结帐ids := Substr(v_原结帐ids, 2);
  
    Begin
      Select 1
      Into n_医保
      From 保险结算记录
      Where 记录id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        n_医保 := 0;
    End;
  
    If n_医保 = 1 Then
      Begin
        Select 1
        Into n_存在
        From 医保结算明细
        Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
      Exception
        When Others Then
          v_Err_Msg := '当前单据' || No_In || '不存在医保结算明细,无法进行门诊转住院!';
          Raise Err_Item;
      End;
    End If;
  
    --医保退款
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_医保.金额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_医保.结算方式, 1, -1 * r_医保.金额);
        n_返回值 := r_医保.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式 And Nvl(余额, 0) = 0;
      End If;
    
      Update 病人预交记录
      Set 冲预交 = 冲预交 + (-1 * r_医保.金额)
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_医保.金额, r_医保.结算方式, Null, 退费时间_In,
           Null, Null, Null, 操作员编号_In, 操作员姓名_In, r_医保.备注, n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id,
           0, 3);
      End If;
    
      Update 病人预交记录
      Set 记录状态 = 3
      Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
            结算方式 = r_医保.结算方式;
    
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = No_In And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (n_结帐id, No_In, r_医保.结算方式, -1 * r_医保.金额);
      End If;
      n_实收金额 := n_实收金额 - r_医保.金额;
    End Loop;
  
    Begin
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
    Exception
      When Others Then
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
    End;
  
    If n_实收金额 > 0 Then
      Begin
        Select Sum(冲预交)
        Into n_预交使用额
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)));
      Exception
        When Others Then
          n_预交使用额 := 0;
      End;
      --退预交
      If Nvl(n_预交使用额, 0) <> 0 Then
        --产生临时记录，用以后续退费处理
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 结算序号)
          Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null,
                 Null, Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null, 3, Null
          From 病人预交记录 A
          Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))
          Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In;
      End If;
    End If;
    --2.票据收回
    --可能以前没有打印,无收回
    Select Nvl(Max(ID), 0)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
    If n_打印id > 0 Then
      --多张单据循环调用时只能收回一次
      Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      End If;
    End If;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                         a.结算方式 = b.名称 And b.性质 In (1, 2, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0
                   Order By a.卡类别id, 性质 Desc) Loop
        If n_实收金额 > 0 Then
          Begin
            Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
          Exception
            When Others Then
              n_退现 := 0;
          End;
          If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
            If c_预交.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_实收金额 := n_实收金额 - c_预交.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
              v_结算方式 := c_预交.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
              If n_实收金额 >= c_预交.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id, Null, Null, Null, Null, Null, Null,
                     n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_实际冲销 := c_预交.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If c_预交.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := c_预交.冲预交;
              End If;
            End If;
          
            If c_预交.结算卡序号 Is Null Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, v_结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
              End If;
            
              --退原预交记录
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            End If;
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = c_预交.结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select ID From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      For r_Clinic In (Select 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                              发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, 划价人, Max(记帐单id) As 记帐单id, 发生时间,
                              实际票号
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间, 实际票号
                       Having Sum(数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
        Values
          (病人费用记录_Id.Nextval, 1, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1, r_Clinic.病人id,
           '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id,
           r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数,
           -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, 1);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                          a.结算方式 = b.名称 And (b.性质 In (1, 2, 7, 8)) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    
                    Having Sum(a.冲预交) <> 0
                    Order By a.卡类别id, 性质 Desc) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If n_实收金额 > 0 Then
          If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
            If r_Pay.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|',
                   n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_实收金额 := n_实收金额 - r_Pay.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
              v_结算方式 := r_Pay.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null Then
              If n_实收金额 >= r_Pay.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id, Null, Null, Null, Null, Null,
                     Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_实际冲销 := r_Pay.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If r_Pay.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := r_Pay.冲预交;
              End If;
            End If;
          
            If r_Pay.性质 Not In (3, 4, 7, 8) Then
              Update 病人预交记录
              Set 金额 = 金额 + n_实际冲销
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
              End If;
            
              --病人余额
              Update 病人余额
              Set 预交余额 = Nvl(预交余额, 0) + n_实际冲销
              Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
              Returning 预交余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_实际冲销, 0);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 病人余额
                Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
              End If;
            End If;
            --4.2缴款数据处理
            --   因为没有实际收病人的钱,所以不处理
            --部分退费情况，退原预交记录
            If r_Pay.性质 In (3, 4) Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, r_Pay.结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
              End If;
            End If;
          
            If r_Pay.性质 <> 8 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                   r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
              End If;
            End If;
          
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = v_结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          
          End If;
        End If;
      End Loop;
    End If;

    If 误差费_In Is Not Null Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
         Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
    End If;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
  Else
    --医保按结算转出
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
  
    For r_结帐ids In (Select Distinct a.结帐id
                    From 门诊费用记录 A
                    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                          a.记录状态 <> 0) Loop
      v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
    End Loop;
    v_结帐ids := Substr(v_结帐ids, 2);
    Select Count(a.No), Sum(a.实收金额)
    Into n_Count, n_实收金额
    From 门诊费用记录 A
    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '本次结算不是收费或因并发原因他人操作了该结算,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where 结帐id = 原结帐id_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    Begin
      Select 1
      Into n_部分退费
      From 门诊费用记录 A
      Where Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
  
    Begin
      Select 0
      Into n_部分退费
      From 门诊费用记录 A
      Where 记录性质 = 11 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select Count(Avg(1))
      Into n_退费条数
      From 病人预交记录 A
      Where a.记录性质 = 3 And a.记录状态 <> 0 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))
      Group By a.结算方式;
    Exception
      When Others Then
        n_退费条数 := 0;
    End;
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
             a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志, a.收入项目id,
             a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.执行人, -1, a.执行时间,
             操作员编号_In, 操作员姓名_In, a.发生时间, 退费时间_In, n_结帐id, -1 * a.结帐金额, a.保险项目否, a.保险大类id, a.统筹金额, a.摘要,
             Decode(Nvl(a.附加标志, 0), 9, 1, 0), a.保险编码, a.费用类型, n_组id, 1
      From 门诊费用记录 A
      Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1;
  
    --作废医保
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO In (Select Column_Value From Table(f_Str2list(v_Nos))) And
                       结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = r_医保.No And 结帐id = r_医保.结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (r_医保.结帐id, r_医保.No, r_医保.结算方式, -1 * r_医保.金额);
      End If;
    End Loop;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    --1.2作废预交记录
    --作废冲预交部分
    If n_部分退费 = 0 And Nvl(门诊退费_In, 0) = 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交,
                              卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                             Nvl(冲预交, 0) <> 0
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号,
                                卡号, 交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
          From Dual;
      End Loop;
    
      For v_预交 In (Select 病人id, Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录 A
                   Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                         a.结帐id <> n_结帐id
                   Group By 病人id, Nvl(预交类别, 2)
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), v_预交.预交金额, 1);
          n_返回值 := v_预交.预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      If n_退费条数 = 0 And Nvl(门诊退费_In, 0) = 0 Then
        --只使用了预交，原样退回预交
        For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, Max(结算方式) As 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间,
                                -1 * Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                         From 病人预交记录 A
                         Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                               Nvl(冲预交, 0) <> 0
                         Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                                  交易流水号, 交易说明, 合作单位, 结算性质) Loop
          Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
            Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                   r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                   操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                   r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
            From Dual;
          Select -1 * 冲预交 Into n_预交金额 From 病人预交记录 Where ID = n_Tempid;
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_预交金额, 0)
          Where 病人id = r_Prepay.病人id And 类型 = 1 And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_预交金额, 1);
            n_返回值 := n_预交金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Prepay.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
        Exception
          When Others Then
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
        End;
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null,
                 Null, Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null,
                 -1 * n_原结帐id, 3
          From 病人预交记录 A
          Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                Nvl(冲预交, 0) <> 0
          Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
      End If;
    End If;
  
    --作废门诊缴费及医保部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 Not In (7, 8);
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 校对标志)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质, 1
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 = 7;
  
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));
  
    --2.票据收回
    --可能以前没有打印,无收回
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                        a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
    
      Select Nvl(Max(ID), 0)
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = r_Nos.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
      If n_打印id > 0 Then
        --多张单据循环调用时只能收回一次
        Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        End If;
      End If;
    End Loop;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                         a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                         b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        Begin
          Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
        Exception
          When Others Then
            n_退现 := 0;
        End;
        If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
        Else
          If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
            v_结算方式 := c_预交.结算方式;
          Else
            If 结算方式_In Is Null Then
              Begin
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
              Exception
                When Others Then
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
              End;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
        
          If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
          End If;
          If c_预交.结算卡序号 Is Null Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - c_预交.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
              n_返回值 := c_预交.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            --部分退费情况，退原预交记录
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select a.Id
                     From 门诊费用记录 A
                     Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                           a.记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      For r_Nos In (Select Distinct NO
                    From 门诊费用记录
                    Where Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And
                          结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) = 1 And 记录状态 = 1;
      End Loop;
      For r_Clinic In (Select Min(a.记录性质) As 记录性质, a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别,
                              a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, Sum(a.数次) As 数次,
                              a.加班标志, a.附加标志, a.收入项目id, a.收据费目, a.标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额,
                              Sum(a.统筹金额) As 统筹金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, Max(a.记帐单id) As 记帐单id,
                              Max(a.是否急诊) As 是否急诊, a.发生时间, Min(a.实际票号) As 实际票号
                       From 门诊费用记录 A
                       Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (2, 3) And Nvl(a.附加标志, 0) Not In (8, 9)
                       Group By a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别, a.收费类别, a.收费细目id,
                                a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, a.加班标志, a.附加标志, a.收入项目id, a.收据费目,
                                a.标准单价, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.发生时间
                       Having Sum(a.数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Clinic.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
           1, r_Clinic.病人id, '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, -1, 1);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
    
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                          a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                          b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    
                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
        Else
          If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
            v_结算方式 := r_Pay.结算方式;
          Else
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If r_Pay.性质 = 8 Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
          End If;
          If r_Pay.性质 Not In (3, 4, 7, 8) Then
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If r_Pay.性质 In (3, 4) Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
            End If;
          End If;
        
          If r_Pay.结算卡序号 Is Null Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                 r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    If 误差费_In Is Not Null Then
      Begin
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
      Exception
        When Others Then
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
      End;
      Update 病人预交记录
      Set 冲预交 = 冲预交 - 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
      Update 病人预交记录
      Set 冲预交 = 冲预交 + 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_误差费;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
           Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
      End If;
    End If;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_收费转出;
/

--88874:刘尔旋,2015-09-28,发药窗口节点
--88395:刘尔旋,2015-09-11,就诊详情返回审核状态
--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--88016:刘尔旋,2015-09-01,服务窗查看报告限制
--87409:刘尔旋,2015-08-17,挂号预约不收费模式
--87310:刘尔旋,2015-08-06,就诊详情接口开单时间问题
--86902:刘尔旋,2015-08-04,自定义执行科室
--86629:刘尔旋,2015-07-28,就诊详情返回外检项目
Create Or Replace Procedure Zl_Third_Getvisitinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:根据挂号单号获取该次就诊详情(医嘱为主要显示)
  --入参:Xml_In:
  --<IN>
  --    <GHDH>挂号单号</GHDH>
  --    <JSKLB>结算卡类别</JSKLB>
  --    <MXGL>明细过滤</MXGL> 0-不过滤,明细包含治疗 1-过滤,明细不包含治疗,默认为1
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --  <GH>
  --     <YYSJ>预约时间</YYSJ> //yyyy-mm-dd hh24:mi:ss
  --     <JZSJ></JZSJ>      //实际就诊时间
  --     <DJH></DJH>        //单据号
  --     <JE></JE>          //金额
  --     <DJLX></DJLX>      //单据类型,1-收费单，4-挂号单
  --     <KDSJ></KDSJ>      //开单时间
  --     <JKFS></JKFS>      //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --     <ZFZT></ZFZT>  //支付状态,0-待支付，1-已支付，2-已退费
  --     <SFJSK></SFJSK>    //是否结算卡支付，0-否，1-是
  --  </GH>
  --  <YZLIST>
  --     <YZ>                   //医嘱返回与HIS中显示的内容相同
  --        <YZID><YZID>        //医嘱ID，返回组医嘱ID
  --        <YZLX><YZLX>        //医嘱类型,如处方、检查、检验
  --         <YZMC></YZMC>        //医嘱名称
  --        <ZXKS></ZXKS>       //执行科室
  --        <ZXKSID></ZXKSID>   //执行科室ID
  --        <FYCK></FYCK>       //发药窗口
  --        <YZMX>
  --           <MX>
  --              <YZNR></YZNR>        //医嘱内容
  --              <ZXZT></ZXZT>        //医嘱执行状态
  --              <SFFY>是否发药</SFFY> // 0-否 ，1-是
  --              <GG>规格</GG>
  --              <SL>数量</SL>
  --              <DW>计算单位</DW>
  --              <BZDJ>标准单价</BZDJ>
  --              <YSJE>应收金额</YSJE>
  --              <SSJE>实收金额</SSJE>
  --           </MX>
  --           <MX/>
  --        </YZMX>
  --        <BG></BG>                   //是否已出报告，是否签名
  --        <BGLY></BGLY>               //是否外检项目,1-院内项目，2-外检项目
  --        <BGLYSM></BGLYSM>           //外检项目说明
  --        <JZBG></JZBG>                //禁止显示报告。0-允许，1-禁止
  --        <JZTS></JZTS>                 //提示文字。对于禁止查看的报告，可返回用于提示病人的信息
  --        <BLID></BLID>              //病历ID，如果<BG>字段为1，该值不为空
  --        <DJLIST>
  --           <DJ>                //费用单据信息
  --              <DJH></DJH>      //费用单据号
  --              <DJLX></DJLX>    //单据类型
  --              <JE></JE>        //单据总金额
  --              <KDSJ></KDSJ>    //开单时间
  --              <ZFZT></ZFZT>    //支付状态,0-待支付，1-已支付，2-已退费,3-退费申请中,4-审核通过,5-审核未通过
  --              <SHSM></SHSM>    //审核说明,审核未通过原因
  --              <SFJSK></SFJSK>  //是否结算卡支付，0-否，1-是
  --           </DJ>
  --           <DJ/>
  --        </DJLIST>
  --     </YZ>
  --  </YZLIST>
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回
  --</OUTPUT>

  --------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);
  v_队列名称 排队叫号队列.队列名称%Type;

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  n_Add_Djlist Number(1); --是否增加了DJLIST的
  n_性质       Number(2);
  n_组医嘱id   Number(18);
  n_独立医嘱   Number(8);
  n_执行科室id Number(18);
  v_执行科室   Varchar2(50);
  n_退款金额   病人预交记录.冲预交%Type;
  n_明细过滤   Number(3);
  n_退费状态   病人退费申请.状态%Type;
  v_申请原因   病人退费申请.申请原因%Type;
  v_审核原因   病人退费申请.审核原因%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/MXGL')
  Into v_挂号单, v_卡类别, n_明细过滤
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  If n_明细过滤 Is Null Then
    n_明细过滤 := 1;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  n_性质 := 4;
  --1.获取挂号数据
  Begin
    Select Replace(摘要, '划价:', '') Into v_No From 病人挂号记录 Where NO = v_挂号单;
  Exception
    When Others Then
      v_No := Null;
  End;

  If v_No Is Not Null Then
    Select Count(*) Into n_Count From 门诊费用记录 Where NO = v_No And 记录性质 = 1;
    If n_Count <> 0 Then
      n_性质 := 1;
    End If;
  End If;
  If n_性质 = 4 Then
    v_No := v_挂号单;
  End If;

  n_Count := 0;
  For c_挂号 In (Select a.Id, v_No As NO, n_性质 As 记录性质, a.执行部门id, c.名称 As 执行部门,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, To_Char(a.预约时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi:ss') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志, Decode(Nvl(a.记录性质, 0), 2, 1, 0) As 缴款方式, b.结帐id As 结帐id
               From 病人挂号记录 A,
                    (Select Max(Decode(记录状态, 0, 0, 2, 0, Nvl(结帐id, 0))) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = n_性质 And NO = v_No) B, 部门表 C
               Where a.No = v_挂号单 And a.执行部门id = c.Id(+)) Loop
  
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
  
    Begin
      Select 排队号码, 队列名称
      Into v_排队号码, v_队列名称
      From 排队叫号队列
      Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
    Exception
      When Others Then
        v_排队号码 := Null;
    End;
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码, v_队列名称);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where 结帐id = c_挂号.结帐id And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    v_Temp := '<DJH>' || c_挂号.No || '</DJH>';
    v_Temp := v_Temp || '<YYSJ>' || c_挂号.预约时间 || '</YYSJ>';
    v_Temp := v_Temp || '<JZSJ>' || c_挂号.就诊时间 || '</JZSJ>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<JKFS>' || c_挂号.缴款方式 || '</JKFS>';
    v_Temp := v_Temp || '<JE>' || c_挂号.金额 || '</JE>';
    v_Temp := v_Temp || '<DJLX>' || n_性质 || '</DJLX>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
    v_Temp := '<GH>' || v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;

  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.组建医嘱及费用相关数据
  n_组医嘱id := 0;

  For c_医嘱 In (With 医嘱费用 As
                  (Select 医嘱id, 发送号, 记录性质, NO, Max(Nvl(执行状态, 0)) As 执行状态
                  From (Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(b.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+)
                         Union All
                         Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(c.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱附费 B, 病人医嘱发送 C
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id(+) And b.医嘱id = c.医嘱id(+) And b.发送号 = c.发送号(+))
                  Group By 医嘱id, 发送号, 记录性质, NO)
                 
                 Select Nvl(a.相关id, a.Id) As 组id, Decode(a.相关id, Null, 0, 1) As 附医嘱, a.Id, a.相关id,e.发药窗口,
                        Max(Decode(a.诊疗类别, 'E', Decode(q.操作类型, '2', '处方', '4', '处方', '6', '检验', m.名称), m.名称)) As 医嘱类型,
                        a.执行科室id, d.名称 As 执行科室, Decode(a.相关id, Null, a.医嘱内容, Null) As 组医嘱内容,
                        Max(Decode(a.诊疗类别, '5', 1, '6', 1, '7', 1, 0) * Decode(Nvl(e.执行状态, 0), 1, 1, 3, 1, 0)) As 发药状态,
                        Decode(a.相关id, Null, Null, q.名称) As 明细医嘱内容, s.规格, (e.数次 * e.付数) As 数量, e.计算单位 As 单位,
                        Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行') As 执行状态,
                        Max(Decode(p.审核时间, Null, Decode(C1.完成时间, Null, 0, 1), 1)) As 是否已出报告, c.病历id, e.No, e.记录性质 As 单据类型,
                        Max(e.标准单价) As 标准单价, Sum(e.应收金额) As 应收金额, Sum(e.实收金额) As 实收金额,
                        To_Char(e.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1) As 支付状态,
                        a.病人id
                 
                 From 病人医嘱记录 A, 医嘱费用 B, 病人医嘱报告 C, 电子病历记录 C1, 部门表 D, 门诊费用记录 E, 诊疗项目类别 M, 诊疗项目目录 Q, 收费项目目录 S, 检验标本记录 P
                 Where a.Id = b.医嘱id(+) And a.执行科室id = d.Id(+) And c.病历id = C1.Id(+) And a.Id = c.医嘱id(+) And
                       a.Id = p.医嘱id(+) And b.医嘱id = e.医嘱序号(+) And e.收费细目id = s.Id(+) And b.No = e.No(+) And
                       b.记录性质 = e.记录性质(+) And e.记录状态(+) <> 2 And a.挂号单 = v_挂号单 And a.诊疗类别 = m.编码(+) And
                       a.诊疗项目id = q.Id(+) And a.医嘱状态 In (3, 8)
                 Group By a.Id, a.婴儿, a.序号, a.相关id, e.发药窗口,a.诊疗类别, a.执行科室id, d.名称, a.医嘱内容, q.名称, s.规格, e.数次 * e.付数, e.计算单位,
                          Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行'), C1.完成时间,
                          Decode(c.病历id, Null, 0, 1), c.病历id, e.No, e.记录性质, e.登记时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1),
                          p.审核时间, a.病人id
                 Order By 组id, 附医嘱, Nvl(a.婴儿, 0), a.序号) Loop
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZLIST></YZLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
  
    If n_组医嘱id <> Nvl(c_医嘱.组id, 0) Then
      n_组医嘱id := Nvl(c_医嘱.组id, 0);
    
      Zl_Third_Custom_Getdeptinfo(n_组医嘱id, n_执行科室id, v_执行科室);
    
      If Nvl(n_执行科室id, 0) = 0 Then
        If c_医嘱.医嘱类型 = '检验' Then
          --检验医嘱以显示采集科室
          n_执行科室id := c_医嘱.执行科室id;
          v_执行科室   := c_医嘱.执行科室;
        Else
          Begin
            Select b.Id, b.名称
            Into n_执行科室id, v_执行科室
            From 病人医嘱记录 A, 部门表 B
            Where a.相关id = n_组医嘱id And a.执行科室id = b.Id And Rownum <= 1;
          Exception
            When Others Then
              n_执行科室id := c_医嘱.执行科室id;
              v_执行科室   := c_医嘱.执行科室;
          End;
        End If;
      End If;
    
      v_Temp := '<YZID>' || n_组医嘱id || '</YZID>';
      v_Temp := v_Temp || '<YZLX>' || c_医嘱.医嘱类型 || '</YZLX>';
      v_Temp := v_Temp || '<YZMC>' || c_医嘱.组医嘱内容 || '</YZMC>';
      v_Temp := v_Temp || '<ZXKS>' || v_执行科室 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || n_执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<FYCK>' || c_医嘱.发药窗口 || '</FYCK>';
      v_Temp := v_Temp || '<BG>' || c_医嘱.是否已出报告 || '</BG>';
      v_Temp := v_Temp || Zl_Third_Custom_Getrptfrom(n_组医嘱id);
      v_Temp := v_Temp || Zl_Third_Custom_Rptlimit(c_医嘱.病人id, n_组医嘱id);
      If Nvl(c_医嘱.是否已出报告, 0) = 1 And c_医嘱.病历id Is Not Null Then
        v_Temp := v_Temp || '<BLID>' || c_医嘱.病历id || '</BLID>';
      End If;
      v_Temp := '<YZ 医嘱ID="' || n_组医嘱id || '">' || v_Temp || '<YZMX></YZMX><DJLIST></DJLIST></YZ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    
      For v_费用 In (
                   
                   Select a.No, Mod(a.记录性质, 10) As 单据类型, To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间,
                           Max(Decode(Nvl(a.记录状态, 0), 0, 0, 3, 2, 1)) As 支付状态, Sum(a.实收金额) As 单据金额, Max(a.结帐id) As 结算卡支付
                   From 门诊费用记录 A
                   Where (a.No, a.记录性质) In
                         (Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱发送 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)
                          Union All
                          Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱附费 Q
                          Where m.Id = q.医嘱id(+) And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)) And
                         Nvl(a.记录状态, 0) In (0, 1, 3)
                   Group By a.No, Mod(a.记录性质, 10), To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss')) Loop
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
        Begin
          Select -1 * Sum(结帐金额)
          Into n_退款金额
          From 门诊费用记录 B
          Where b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 = 2;
        Exception
          When Others Then
            n_退款金额 := 0;
        End;
        Begin
          Select 状态, 申请原因, 审核原因
          Into n_退费状态, v_申请原因, v_审核原因
          From 病人退费申请
          Where NO = v_费用.No And Mod(记录性质, 10) = Mod(v_费用.单据类型, 10);
        Exception
          When Others Then
            n_退费状态 := -1;
            v_申请原因 := '';
            v_审核原因 := '';
        End;
      
        v_Temp := '<DJH>' || v_费用.No || '</DJH>';
        v_Temp := v_Temp || '<DJLX>' || v_费用.单据类型 || '</DJLX>';
        v_Temp := v_Temp || '<JE>' || v_费用.单据金额 || '</JE>';
        v_Temp := v_Temp || '<KDSJ>' || v_费用.开单时间 || '</KDSJ>';
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<ZFZT>' || v_费用.支付状态 || '</ZFZT>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<ZFZT>3</ZFZT>';
          End If;
          If n_退费状态 = 1 Then
            v_Temp := v_Temp || '<ZFZT>4</ZFZT>';
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<ZFZT>5</ZFZT>';
          End If;
        End If;
      
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<SHSM>' || '' || '</SHSM>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<SHSM>' || v_申请原因 || '</SHSM>';
          End If;
          If n_退费状态 = 1 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
        End If;
      
        v_Temp := v_Temp || '<YTJE>' || Nvl(n_退款金额, 0) || '</YTJE>';
        v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
        v_Temp := '<DJ>' || v_Temp || '</DJ>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/DJLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End Loop;
    End If;
  
    --只有一条记录的医嘱，在明细中增加该条医嘱，以获取执行状态
    Select Decode(Count(*), 0, 1, 0) Into n_独立医嘱 From 病人医嘱记录 Where 相关id = n_组医嘱id;
    If n_独立医嘱 = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.组医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
    If Nvl(c_医嘱.附医嘱, 0) = 1 Then
      If n_明细过滤 = 0 Or (n_明细过滤 = 1 And c_医嘱.医嘱类型 <> '治疗') Then
        v_Temp := '<YZNR>' || c_医嘱.明细医嘱内容 || '</YZNR>';
        v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
        v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
        v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
        v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
        v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
        v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
        v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
        v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
        v_Temp := '<MX>' || v_Temp || '</MX>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    End If;
  
  End Loop;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitinfo;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86629:刘尔旋,2015-07-28,就诊详情返回外检项目
Create Or Replace Function Zl_Third_Custom_Getrptfrom(医嘱id_In In 病人医嘱记录.Id%Type) Return Varchar2 As
  ----------------------------------------
  --功能：返回当前医嘱对应的诊疗项目是否外检项目
  --入参：医嘱ID
  --出参：<BGLY>标志<BGLY><BGLYSM>提醒信息</BGLYSM>
  --   标志：1-HIS项目，2-外检项目
  --   提醒信息：自定义文字说明，如取报告的地址，提示信息等
  --说明：如果传入的医嘱ID为组医嘱ID，只要该组医嘱下有1个医嘱为外检项目，则整个医嘱全部为外检项目。
  ----------------------------------------
  v_Return  Varchar2(200);
  v_Temp    Varchar2(32767);
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  v_Return := '<BGLY>1</BGLY><BGLYSM></BGLYSM>'; --医院项目返回内容
  Return(v_Return);
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Custom_Getrptfrom;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86797:刘尔旋,2015-07-23,建档病人自动产生门诊号
Create Or Replace Procedure Zl_Third_Buildpatient
(
  Patiinfo_In  In Xmltype,
  Patiinfo_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------
  --参数说明:
  -- 入参 Patiinfo_In:
  --<IN>
  --  <ZJH></ZJH>                 //证件号，目前仅支持身份证号
  --  <ZJLX></ZJLX>                       //证件类型(目前仅支持身份证,为空时默认为身份证)
  --  <XM></XM>                       //姓名
  --  <SJH></SJH>                      //手机号
  --</IN>

  --出参 Patiinfo_Out：
  --<OUTPUT>
  --       <BRID></BRID>                //病人ID
  --       <MZH></MZH>                  //门诊号
  --     <ERROR></ERROR>         //如果有错误返回该节点
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Pati_Id      病人信息.病人id%Type;
  n_Card_Type_Id 医疗卡类别.Id%Type;
  n_Count        Number(5);
  n_Sum          Number(5);
  v_校验位       Varchar2(50);

  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_手机号       病人信息.家庭电话%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  v_操作员       人员表.姓名%Type;
  v_医疗付款方式 病人信息.医疗付款方式%Type;
  n_门诊号       病人信息.门诊号%Type;
  v_证件类型     医疗卡类别.名称%Type;
  v_证件号       病人医疗卡信息.卡号%Type;

  v_Pattern Varchar2(500);
  v_Temp    Varchar2(32767); --临时XML
  v_Err_Msg Varchar2(2000);
  n_存在    Number(2);

  d_出生日期  病人信息.出生日期%Type;
  d_Curr_Time Date;

  Err_Item Exception;
Begin
  Patiinfo_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Sysdate Into d_Curr_Time From Dual;

  --新建病人：姓名、身份证号、手机号（存在家庭电话中）、出生日期、性别、年龄(后面三项可从身份证中获取)。
  Select Extractvalue(Value(I), 'IN/XM'), Extractvalue(Value(I), 'IN/ZJH'), Extractvalue(Value(I), 'IN/SJH'),
         Extractvalue(Value(I), 'IN/ZJLX')
  Into v_姓名, v_证件号, v_手机号, v_证件类型
  From Table(Xmlsequence(Extract(Patiinfo_In, 'IN'))) I;

  Begin
    If v_证件类型 Is Null Then
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 Like '%身份证%') And Rownum < 2;
    Else
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 = v_证件类型) And Rownum < 2;
    End If;
    n_存在 := 1;
  Exception
    When Others Then
      n_存在 := 0;
  End;

  If Nvl(n_存在, 0) = 1 Then
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    Select 门诊号 Into n_门诊号 From 病人信息 Where 病人id = n_Pati_Id;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_Pati_Id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  Else
    If v_姓名 Is Null Then
      v_Err_Msg := '传人姓名为空!';
      Raise Err_Item;
    End If;
    If v_证件类型 Like '%身份证%' Or v_证件类型 Is Null Then
      v_身份证号 := v_证件号;
    Else
      v_Err_Msg := '目前不支持身份证以外的方式建档！';
      Raise Err_Item;
    End If;
  
    If v_身份证号 Is Null Then
      v_Err_Msg := '传人身份证号为空!';
      Raise Err_Item;
    Else
      --身份证合法验证
      v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
    
      --地区检验
      If Instr(v_Pattern, Substr(v_身份证号, 1, 2)) = 0 Then
        v_Err_Msg := '身份证前两位地区码不正确!';
        Raise Err_Item;
      End If;
      --身份证长度检查
      If Length(v_身份证号) = 15 Then
        --检查身份证号:15位身份证号要求全部为数字
        v_Pattern := '^\d{15}$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符，请检查!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 15, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
        v_Pattern  := '^[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(v_身份证号, 7, 6), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
        End If;
      Elsif Length(v_身份证号) = 18 Then
        -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
        v_Pattern := '^\d{17}[0-9Xx]$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 17, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
        v_Pattern  := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(v_身份证号, 7, 8), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
          --计算校验位
          n_Sum     := (To_Number(Substr(v_身份证号, 1, 1)) + To_Number(Substr(v_身份证号, 11, 1))) * 7 +
                       (To_Number(Substr(v_身份证号, 2, 1)) + To_Number(Substr(v_身份证号, 12, 1))) * 9 +
                       (To_Number(Substr(v_身份证号, 3, 1)) + To_Number(Substr(v_身份证号, 13, 1))) * 10 +
                       (To_Number(Substr(v_身份证号, 4, 1)) + To_Number(Substr(v_身份证号, 14, 1))) * 5 +
                       (To_Number(Substr(v_身份证号, 5, 1)) + To_Number(Substr(v_身份证号, 15, 1))) * 8 +
                       (To_Number(Substr(v_身份证号, 6, 1)) + To_Number(Substr(v_身份证号, 16, 1))) * 4 +
                       (To_Number(Substr(v_身份证号, 7, 1)) + To_Number(Substr(v_身份证号, 17, 1))) * 2 +
                       To_Number(Substr(v_身份证号, 8, 1)) * 1 + To_Number(Substr(v_身份证号, 9, 1)) * 6 +
                       To_Number(Substr(v_身份证号, 10, 1)) * 3;
          n_Count   := Mod(n_Sum, 11);
          v_Pattern := '10X98765432';
          v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
          If v_校验位 <> Upper(Substr(v_身份证号, 18, 1)) Then
            v_Err_Msg := '身份证号码不正确，请检查。';
            Raise Err_Item;
          End If;
        End If;
      Else
        v_Err_Msg := '身份证长度不对,请检查。';
        Raise Err_Item;
      End If;
    
      If Nvl(v_年龄, '_') = '_' Then
        v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
      End If;
    End If;
  
    Select 名称 Into v_医疗付款方式 From 医疗付款方式 Where 缺省标志 = 1;
    Select 病人信息_Id.Nextval Into n_Pati_Id From Dual;
    n_门诊号 := Nextno(3);
    Insert Into 病人信息
      (病人id, 姓名, 身份证号, 家庭电话, 出生日期, 性别, 年龄, 登记时间, 门诊号, 医疗付款方式)
      Select n_Pati_Id, v_姓名, v_身份证号, v_手机号, d_出生日期, v_性别, v_年龄, d_Curr_Time, n_门诊号, v_医疗付款方式
      From Dual;
  
    --病人信息保存完后，完成医疗卡绑定（二代身份证卡类别的绑定）
    Begin
      If v_证件类型 Is Null Then
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 Like '%身份证%' And Rownum < 2;
      Else
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 = v_证件类型 And Rownum < 2;
      End If;
    Exception
      When No_Data_Found Then
        v_Err_Msg := '身份证卡类别不存在！';
        Raise Err_Item;
    End;
    Select b.姓名 Into v_操作员 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
  
    Zl_医疗卡变动_Insert(11, n_Pati_Id, n_Card_Type_Id, Null, v_身份证号, '创建虚拟卡', Null, v_操作员, d_Curr_Time);
  
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  End If;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatient;
/

--87771:刘尔旋,2015-09-10,服务窗接口错误处理方式统一
--86797:刘尔旋,2015-07-23,获取科室不包含停用部门
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室

  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Temp      Varchar(5000); --临时XML
  x_Templet   Xmltype; --模板XML
  n_查询天数  Number(5);
  n_Add_Lists Number(3);
  v_合作单位  合作单位安排控制.合作单位%Type;
  v_Err_Msg   Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW')
  Into n_查询天数, v_合作单位
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  If v_合作单位 Is Null Then
    For r_Dept In (Select Distinct a.科室id, b.名称
                   From 挂号安排 A, 部门表 B
                   Where a.停用日期 Is Null And a.科室id = b.Id) Loop
    
      If Nvl(n_Add_Lists, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
        n_Add_Lists := 1;
      End If;
      v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
      Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  Else
    For r_Dept In (Select Distinct 科室id, 名称
                   From (Select b.科室id, d.名称
                          From (Select a.Id
                                 From 挂号安排 A
                                 Where a.停用日期 Is Null And Not Exists
                                  (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                 Union All
                                 Select a.Id
                                 From 挂号安排 A, 合作单位安排控制 B
                                 Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                               挂号安排计划 C, 部门表 D
                          Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + n_查询天数) Or
                                (c.生效时间 Between Sysdate And Sysdate + n_查询天数) Or
                                (c.失效时间 Between Sysdate And Sysdate + n_查询天数)) And Not Exists
                           (Select 1 From 合作单位计划控制 Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                          Union All
                          Select b.科室id, d.名称
                          From (Select a.Id
                                 From 挂号安排 A
                                 Where a.停用日期 Is Null And Not Exists
                                  (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                 Union All
                                 Select a.Id
                                 From 挂号安排 A, 合作单位安排控制 B
                                 Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B, 部门表 D
                          Where a.Id = b.Id And Not Exists
                           (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null))) Loop
      If Nvl(n_Add_Lists, 0) = 0 Then
        --增加DJList节点
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
        n_Add_Lists := 1;
      End If;
      v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '</KS>';
      Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    End Loop;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptlist;
/

--86797:刘尔旋,2015-07-23,卡费不使用医保支付
Create Or Replace Procedure Zl_医疗卡记录_Delete
(
  单据号_In     住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type
) As
  Cursor c_Cardinfo Is
    Select a.Id As 费用id, Nvl(a.记帐费用, 0) As 记帐, a.结帐id, a.实际票号, a.病人id, Nvl(a.主页id, 0) As 主页id,
           Nvl(a.病人病区id, 0) As 病人病区id, Nvl(a.病人科室id, 0) As 病人科室id, Nvl(a.开单部门id, 0) As 开单部门id,
           Nvl(a.执行部门id, 0) As 执行部门id, a.收入项目id, a.实收金额, b.结算方式, b.冲预交, b.卡类别id, b.卡号, b.结算卡序号, b.结算序号, a.结论,
           b.Id As 预交id
    From 住院费用记录 A, 病人预交记录 B
    Where a.记录性质 = 5 And a.记录状态 = 1 And a.No = 单据号_In And a.结帐id = b.结帐id(+);
  r_Cardrow c_Cardinfo%RowType;

  v_费用id   住院费用记录.Id%Type;
  v_结帐id   住院费用记录.结帐id%Type;
  v_打印id   票据打印内容.Id%Type;
  n_返回值   病人余额.费用余额%Type;
  n_卡类别id Number(18);

  v_Date Date;

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  Open c_Cardinfo;
  Fetch c_Cardinfo
    Into r_Cardrow;
  n_组id := Zl_Get组id(操作员姓名_In);

  --首先判断要退卡的记录是否存在
  If c_Cardinfo%RowCount = 0 Then
    Close c_Cardinfo;
    v_Err_Msg := '[ZLSOFT]没有发现要退卡的记录,该记录可能已经退除！[ZLSOFT]';
    Raise Err_Item;
  Else
    Select Sysdate Into v_Date From Dual;
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  
    If r_Cardrow.记帐 = 0 Then
      Select 病人结帐记录_Id.Nextval Into v_结帐id From Dual;
    End If;
  
    --退除就诊卡费用记录
    Insert Into 住院费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 门诊标志, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
       附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额,
       缴款组id, 结论)
      Select v_费用id, NO, 实际票号, 记录性质, 2, 序号, 病人id, 主页id, 病人病区id, 病人科室id, 门诊标志, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
             -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 操作员编号_In, 操作员姓名_In,
             发生时间, v_Date, v_结帐id, Decode(v_结帐id, Null, Null, -结帐金额), n_组id, 结论
      From 住院费用记录
      Where ID = r_Cardrow.费用id;
  
    Update 住院费用记录 Set 记录状态 = 3 Where ID = r_Cardrow.费用id;
  
    --预交款里现收的结算金额
    If r_Cardrow.记帐 = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, v_Date, 操作员编号_In, 操作员姓名_In, -冲预交, v_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 5
        From 病人预交记录
        Where 记录性质 = 5 And 记录状态 = 1 And 结帐id = r_Cardrow.结帐id;
    
      Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 5 And 记录状态 = 1 And 结帐id = r_Cardrow.结帐id;
    
      --Zl_病人卡结算记录_Strike(结帐id_In In Varchar2,  预交id_In 病人预交记录.ID%Type := -1
      Zl_病人卡结算记录_Strike(r_Cardrow.结帐id, r_Cardrow.预交id);
    
    End If;
  
    --退卡收回票据
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 5 And b.No = 单据号_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 回收次数, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 回收次数, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 5 And 性质 = 1;
    End If;
  
    n_卡类别id := To_Number(Nvl(r_Cardrow.结论, '0'));
    If n_卡类别id = 0 Then
      --取就诊卡
      Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = '就诊卡' And Nvl(是否固定, 0) = 1;
    End If;
  
    --处理相关的变动信息
    --Zl_医疗卡变动_Insert (变动类型_In/病人id_In ,卡类别id_In, 原卡号_In, 医疗卡号_In, 变动原因_In, 密码_In, 操作员姓名_In, 变动时间_In
    --Ic卡号_In, 挂失方式_In)
    --变动类型_In:1-发卡(或11绑定卡);2-换卡;3-补卡(13-补卡停用);4-退卡(或14取消绑定); ５-密码调整(只记录);6-挂失(16取消挂失)
    Zl_医疗卡变动_Insert(4, r_Cardrow.病人id, n_卡类别id, r_Cardrow.实际票号, r_Cardrow.实际票号, Null, Null, 操作员姓名_In, v_Date, Null,
                    Null);
  
    ----------------------------------------------------------------------------------------------------------------------------------------
  
    --相关汇总表的处理
    If r_Cardrow.记帐 = 1 Then
      --汇总'病人余额'
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + (-1 * r_Cardrow.实收金额)
      Where 性质 = 1 And 病人id = r_Cardrow.病人id And Nvl(类型, 2) = Decode(Nvl(r_Cardrow.主页id, 0), 0, 1, 2)
      Returning 费用余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Cardrow.病人id, 1, Decode(Nvl(r_Cardrow.主页id, 0), 0, 1, 2), 0, -1 * r_Cardrow.实收金额);
        n_返回值 := -1 * r_Cardrow.实收金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = r_Cardrow.病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --汇总'病人未结费用'
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + (-1 * r_Cardrow.实收金额)
      Where 病人id = r_Cardrow.病人id And Nvl(主页id, 0) = r_Cardrow.主页id And Nvl(病人病区id, 0) = r_Cardrow.病人病区id And
            Nvl(病人科室id, 0) = r_Cardrow.病人科室id And Nvl(开单部门id, 0) = r_Cardrow.开单部门id And
            Nvl(执行部门id, 0) = r_Cardrow.执行部门id And 收入项目id + 0 = r_Cardrow.收入项目id And 来源途径 = 3;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (r_Cardrow.病人id, Decode(r_Cardrow.主页id, 0, Null, r_Cardrow.主页id),
           Decode(r_Cardrow.病人病区id, 0, Null, r_Cardrow.病人病区id), Decode(r_Cardrow.病人科室id, 0, Null, r_Cardrow.病人科室id),
           Decode(r_Cardrow.开单部门id, 0, Null, r_Cardrow.开单部门id), Decode(r_Cardrow.执行部门id, 0, Null, r_Cardrow.执行部门id),
           r_Cardrow.收入项目id, 3, -1 * r_Cardrow.实收金额);
      End If;
    
    Elsif r_Cardrow.结算方式 Is Not Null Then
      --汇总"人员缴款余额"
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Cardrow.冲预交)
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Cardrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Cardrow.结算方式, 1, -1 * r_Cardrow.冲预交);
        n_返回值 := -1 * r_Cardrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Cardrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End If;
  
    Close c_Cardinfo;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20999, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡记录_Delete;
/






---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--系统版本号
Update zlSystems Set 版本号='10.34.40' Where 编号=&n_System;
--部件版本号
Commit;
