--[连续升级]1
--[管理工具版本号]10.34.90
--本脚本支持从ZLHIS+ v10.34.80 升级到 v10.34.90
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--103946:黄捷,2016-12-15,RISID增加索引
Create Index 病人医嘱报告_IX_RISID On 病人医嘱报告(RISID)  Tablespace zl9Indexcis;

--103544:廖思奇,2016-12-08,增加字段
Alter Table 影像插件功能 Add 自动执行时机 Number(5) Default 0;

--103310:李南春,2016-12-08,医疗卡卡号增加回车符位
Alter table 医疗卡类别 add 设备是否启用回车 NUMBER(1) default 0;

--92667:涂建华,2016-12-06,增加报告原型的使用次数
Alter Table 影像报告原型清单 Add 使用次数 Number(18) Default 0;

--103157:黄捷,2016-12-02,RIS分科室启用控制
create table RIS启用控制
(
  ID Number(18),
  检查类型   VARCHAR2(20),
  场合   Number(1),
  部门ID   NUMBER(18),
  是否启用RIS     Number(1),
  是否启用预约     Number(1)
)Tablespace ZL9CISREC;

Alter Table RIS启用控制 Add Constraint RIS启用控制_PK Primary Key (ID) Using Index Tablespace zl9indexhis;
Alter Table RIS启用控制 Add Constraint RIS启用控制_FK_部门ID foreign key (部门ID) references 部门表 (ID);

Create Sequence RIS启用控制_ID Start With 1;

--101358:张德婷,2016-11-30,还原打印次数规则
alter table 输液配药记录 add 打印流水号 number(5);

--102641:胡俊勇,2016-11-28,RIS预约相关修改
Alter Table Ris检查预约 Add 序号 Number(18);

--102623:黄捷,2016-11-24,RIS打印预约通知
alter table RIS检查预约 add 是否打印 NUMBER(1);

Create Index RIS检查预约_IX_预约日期 On RIS检查预约(预约日期) Tablespace zl9Indexcis;

--91721:刘尔旋,2016-07-15,自动记账更改
Drop Procedure ZL1_AUTOAPTALL;
Drop View 病人自动费用;

--100217:张德婷,2016-10-11,保存实际操作人
alter table 输液配药记录 add 工作人员 varchar2(100);

--100911:廖思奇,2016-10-10,影像收藏类别 增加字段创建人ID,删除字段创建人(先删除相关约束，后面数据修正后删除字段)
Alter Table 影像收藏类别 Add 创建人ID Number(18);
Alter Table 影像收藏类别 Drop Constraint 影像收藏类别_FK_创建人;
Alter Table 影像收藏类别 Drop Constraint 影像收藏类别_UQ_创建人 Cascade Drop Index;
Create Index 影像收藏类别_IX_创建人ID On 影像收藏类别(创建人ID) Tablespace zl9Indexcis;
Alter Table 影像收藏类别 Add Constraint 影像收藏类别_FK_创建人ID Foreign Key (创建人ID) References 人员表(ID) On Delete Cascade;

--100908:廖思奇,2016-10-09,影像插件增加右键菜单和工具栏按钮
Alter Table 影像插件功能 Add 是否加入右键菜单 Number(1);
Alter Table 影像插件功能 Add 是否加入工具栏 Number(1);

--99758:梁唐彬,2016-09-22,部分退费问题医嘱执行计价增加执行状态
alter table 医嘱执行计价 add  执行状态 number(1);

--100939:黄捷,2016-09-22,RIS接口检查医嘱批量重发
Create Table RIS医嘱失败记录
(
   ID Number(18),
   病人来源 Number(1),
   病人ID Number(18),
   主页ID Number(5),
   挂号单号 Varchar2(8),
   发送号 Number(18),
   体检任务ID Number(18),
   体检报到号 Number(18),
   发送类型 Number(1),
   发送时间 date,
   重发次数 Number(2)
)Tablespace ZL9CISREC;

Alter Table RIS医嘱失败记录 Add Constraint RIS医嘱失败记录_PK Primary Key (ID) Using Index Pctfree 5 Tablespace zl9Indexcis;
Create Sequence RIS医嘱失败记录_ID Start With 1;

--96692:廖思奇,2016-09-21,增加自由配置病理号别的方式

Alter Table 病理号码规则 Add 名称 Varchar2(30);
Alter Table 病理检查信息 Add 号码规则ID Number(5);
Alter Table 病理号码记录 Add 号码规则ID Number(5);

Alter Table 病理号码记录 Add Constraint 病理号码记录_FK_号码规则ID  Foreign Key (号码规则ID) References 病理号码规则(id) On Delete Cascade;
Alter Table 病理号码规则 Add Constraint 病理号码规则_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexcis;
Alter Table 病理检查信息 Add Constraint 病理检查信息_FK_号码规则ID  Foreign key (号码规则ID) References 病理号码规则(id);

Create Index 病理检查信息_IX_号码规则ID On 病理检查信息(号码规则ID) Pctfree 5 Tablespace zl9Indexcis;
Create Index 病理号码记录_IX_号码规则ID On 病理号码记录(号码规则ID) Tablespace zl9Indexcis;
Drop Sequence 病理号码规则_ID;

--86035:胡俊勇,2016-08-24,处方审查功能关联修改
alter table 业务消息清单 modify  业务标识 varchar2(4000); 

--85987:余智勇,2015-07-02,新增处方审查系统
Create Table 处方审查参数(
       机器名 Varchar2(15), 
       服务对象 Number(1),
       是否开启审方 Number(1), 
       最后操作时间 Date,
       来源科室 Varchar2(4000)) 
Pctfree 10 Initrans 20
Tablespace Zl9baseitem;

Create Table 处方审查条件(
       ID Number(18), 
       类别 Number(2), 
       药名id Number(18),	
       科室id Number(18), 
       医生id Number(18), 
       诊断id Number(18), 
       疾病id Number(18)) 
Tablespace Zl9baseitem;

Create Table 处方审查项目(
       ID Number(18), 
       类别 Number(1),
       编码 Varchar2(10), 
       简称 Varchar2(50),
       内容 Varchar2(500), 
       是否门诊启用 Number(1), 
       是否住院启用 Number(1), 
       服务对象 Number(1),
       PASS结果 Varchar2(50),
       操作人 Varchar2(100), 
       操作时间 Date, 
       作废时间 Date)
Tablespace Zl9baseitem;

Create Table 处方审查常用理由(
       用户名 Varchar2(20),
       内容 Varchar2(500))
Tablespace Zl9medlst;

Create Table 处方审查记录(
       ID Number(18),
       病人id Number(18), 
       挂号id Number(18), 
       主页id Number(18),
       提交人 Varchar2(100), 
       提交时间 Date, 
       提交科室id Number(18),
       审查结果 Number(1),
       审查人 Varchar2(100), 
       审查时间 Date, 
       发药药房id Number(18), 
       综合理由 Varchar2(500),
       状态 Number(2),
       锁定用户 Varchar2(20),
       锁定时间 Date,
       待转出 Number(3)) 
Pctfree 10 Initrans 20 
Tablespace Zl9medlst;

Create Table 处方审查明细(
       审方id Number(18), 
       医嘱id Number(18), 
       最后提交 Number(1), 
       待转出 Number(3)) 
Pctfree 10 Initrans 20 
Tablespace Zl9medlst;

Create Table 处方审查结果(
       审方id Number(18), 
       医嘱id Number(18), 
       审查项目id Number(18),
       最后提交 Number(1),
       药师审查 Number(1),
       自动审查 Number(1),
       理由 Varchar2(500),
       待转出 Number(3)) 
Pctfree 10 Initrans 20 
Tablespace Zl9medlst;

Create Sequence 处方审查条件_Id Start With 1;
Create Sequence 处方审查记录_Id Start With 1;
Create Sequence 处方审查项目_Id Start With 1;

Alter Table 处方审查参数 Add Constraint 处方审查参数_Pk Primary Key(机器名, 服务对象) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查条件 Add Constraint 处方审查条件_Pk Primary Key(ID) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查项目 Add Constraint 处方审查项目_Pk Primary Key(ID) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查记录 Add Constraint 处方审查记录_Pk Primary Key(ID) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查明细 Add Constraint 处方审查明细_Pk Primary Key(审方id, 医嘱id) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查常用理由 Add Constraint 处方审查常用理由_Pk Primary Key(用户名, 内容) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查项目 Add Constraint 处方审查项目_Uq_编码 Unique(编码) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查项目 Add Constraint 处方审查项目_Uq_简称 Unique(简称) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查结果 Add Constraint 处方审查结果_Uq_审方Id Unique(审方id, 医嘱id, 审查项目id) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查记录 Add Constraint 处方审查记录_Uq_提交时间 Unique(提交时间, 提交科室id, 病人id, 发药药房id) Using Index Tablespace Zl9indexhis;
Alter Table 处方审查项目 Modify 编码 Constraint 处方审查项目_NN_编码 Not Null;
Alter Table 处方审查项目 Modify 简称 Constraint 处方审查项目_NN_简称 Not Null;
Alter Table 处方审查结果 Modify 审方Id Constraint 处方审查结果_NN_审方Id not null;

Create Index 处方审查记录_Ix_挂号id On 处方审查记录(挂号id) Tablespace Zl9indexhis;
Create Index 处方审查记录_Ix_病人id On 处方审查记录(病人id, 主页id) Tablespace Zl9indexhis;
Create Index 处方审查记录_Ix_审查时间 On 处方审查记录(审查时间) Tablespace Zl9indexhis;
Create Index 处方审查记录_Ix_状态 On 处方审查记录(状态) Tablespace Zl9indexhis;
Create Index 处方审查记录_Ix_锁定用户 On 处方审查记录(锁定用户) Tablespace Zl9indexhis;
Create Index 处方审查记录_Ix_待转出 On 处方审查记录(待转出) Tablespace Zl9indexhis;
Create Index 处方审查明细_Ix_医嘱id On 处方审查明细(医嘱id) Tablespace Zl9indexhis;
Create Index 处方审查明细_IX_待转出 ON 处方审查明细(待转出) Tablespace Zl9indexhis;
Create Index 处方审查结果_Ix_审查项目id On 处方审查结果(审查项目id) Tablespace Zl9indexhis;
Create Index 处方审查结果_IX_待转出 ON 处方审查结果(待转出) Tablespace Zl9indexhis;
Create Index 处方审查结果_IX_医嘱id ON 处方审查结果(医嘱id) Tablespace Zl9indexhis;

Alter Table 处方审查条件 Add Constraint 处方审查条件_Fk_科室ID Foreign Key(科室id) References 部门表(ID) On Delete Cascade;
Alter Table 处方审查条件 Add Constraint 处方审查条件_Fk_医生ID Foreign Key(医生id) References 人员表(ID) On Delete Cascade;
Alter Table 处方审查条件 Add Constraint 处方审查条件_Fk_诊断ID Foreign Key(诊断id) References 疾病诊断目录(ID) On Delete Cascade;
Alter Table 处方审查条件 Add Constraint 处方审查条件_Fk_疾病ID Foreign Key(疾病id) References 疾病编码目录(ID) On Delete Cascade;
Alter Table 处方审查条件 Add Constraint 处方审查条件_Fk_药名ID Foreign Key(药名id) References 诊疗项目目录(ID) On Delete Cascade;
Alter Table 处方审查记录 Add Constraint 处方审查记录_FK_病人Id Foreign Key(病人Id) References 病人信息(病人ID);
Alter Table 处方审查记录 Add Constraint 处方审查记录_FK_挂号Id Foreign Key(挂号Id) References 病人挂号记录(ID);
Alter Table 处方审查记录 Add Constraint 处方审查记录_FK_提交科室Id Foreign Key(提交科室Id) References 部门表(ID);
Alter Table 处方审查记录 Add Constraint 处方审查记录_FK_发药药房Id Foreign Key(发药药房Id) References 部门表(ID);
Alter Table 处方审查明细 Add Constraint 处方审查明细_Fk_审方id Foreign Key(审方id) References 处方审查记录(ID) On Delete Cascade;
Alter Table 处方审查明细 Add Constraint 处方审查明细_Fk_医嘱id Foreign Key(医嘱id) References 病人医嘱记录(ID);
Alter Table 处方审查结果 Add Constraint 处方审查结果_Fk_审方id Foreign Key(审方id) References 处方审查记录(ID) On Delete Cascade;
Alter Table 处方审查结果 Add Constraint 处方审查结果_Fk_审查项目id Foreign Key(审查项目id) References 处方审查项目(ID);
Alter Table 处方审查结果 Add Constraint 处方审查结果_Fk_医嘱id Foreign Key(医嘱id) References 病人医嘱记录(ID);

Create Index 处方审查记录_IX_提交科室ID ON 处方审查记录(提交科室ID) Tablespace Zl9indexhis;
Create Index 处方审查记录_IX_发药药房ID ON 处方审查记录(发药药房ID) Tablespace Zl9indexhis;

Create Index 处方审查条件_IX_科室ID ON 处方审查条件(科室ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_医生ID ON 处方审查条件(医生ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_诊断ID ON 处方审查条件(诊断ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_疾病ID ON 处方审查条件(疾病ID) Tablespace Zl9indexhis;
Create Index 处方审查条件_IX_药名ID ON 处方审查条件(药名ID) Tablespace Zl9indexhis;


--101414:冉俊明,2016-10-18,出诊表另存为模板功能调整
--68694:刘尔旋,2016-08-17,新挂号安排改进
ALTER TABLE 预约方式 add 预约天数 number(5);

ALTER  Table 时间段 modify 时间段 varchar2(10);
ALTER  Table 时间段 ADD  站点 varchar2(1);
ALTER  Table 时间段 ADD  号类 varchar2(10);
ALTER  Table 时间段 ADD  出诊预留时间 number(18);
ALTER  Table 时间段 ADD  休息时段 varchar2(200);




Alter Table 时间段  drop Constraint 时间段_PK   Cascade Drop Index;
Alter Table 时间段 Add Constraint 时间段_UQ_时间段 Unique (时间段,号类,站点) Using Index Tablespace zl9Indexhis;
Alter Table 时间段 Modify 时间段 Constraint 时间段_NN_时间段 Not Null;

Create Table 常用停诊原因(
   编码 varchar2(5),
   名称 varchar2(50),
   简码 varchar2(20),
   缺省标志 number(1) default 0)
TABLESPACE zl9BaseItem ;

Alter Table 常用停诊原因  Add Constraint 常用停诊原因_PK  Primary Key (编码) Using Index Tablespace zl9Indexhis;
Alter Table 常用停诊原因 Add Constraint 常用停诊原因_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;

Create Sequence 门诊诊室_ID start with 1;
ALTER TABLE 门诊诊室 add(ID number(18));

Alter Table 门诊诊室  drop Constraint 门诊诊室_PK   Cascade Drop Index;
Alter Table 门诊诊室 Add Constraint 门诊诊室_PK Primary Key(ID) Using Index Tablespace Zl9indexhis Enable Novalidate;
Alter Table 门诊诊室 Add Constraint 门诊诊室_UQ_编码 Unique (编码) Using Index Tablespace zl9Indexhis;

CREATE TABLE 门诊诊室适用科室 (
	诊室ID number(18),
	科室ID number(18),
	缺省标志 number(2)) 
TABLESPACE zl9BaseItem ;

Alter Table 门诊诊室适用科室  Add Constraint 门诊诊室适用科室_PK  Primary Key (诊室ID,科室ID) Using Index Tablespace zl9Indexhis;
Alter Table 门诊诊室适用科室 Add Constraint 门诊诊室适用科室_FK_诊室ID Foreign Key (诊室ID) References 门诊诊室( ID) On Delete Cascade;
Alter Table 门诊诊室适用科室 Add Constraint 门诊诊室适用科室_FK_科室ID Foreign Key (科室ID) References 部门表( ID) On Delete Cascade;

Create Index 门诊诊室适用科室_IX_科室id on 门诊诊室适用科室(科室id) Tablespace zl9Indexhis;

Create Table 法定假日表(
   年份 number(18),
   节日名称 varchar2(50),
   性质 number(18),
   开始日期 Date,
   终止日期 Date,
   备注 varchar2(1000),
   允许挂号 varchar2(500),
   允许预约 varchar2(500))
TABLESPACE zl9BaseItem ;

Alter Table 法定假日表  Add Constraint 法定假日表_PK  Primary Key (开始日期,年份,节日名称,性质) Using Index Tablespace zl9Indexhis;

ALTER TABLE 挂号合作单位 ADD 锁号时间 number(18) ;

  
Create Sequence 临床出诊号源_ID start with 1;
Create Table 临床出诊号源(
   ID number(18) not null,
   号类 varchar2(10),
   号码 varchar2(5),
   科室id number(18),
   项目ID number(18),
   医生id number(18),
   医生姓名 varchar2(50),
   是否建病案 number(2) default 0,
   预约天数 number(3),
   出诊频次 number(3),
   假日控制状态 number(2) ,
   是否假日换休 number(2) default 0,
   是否临床排班 number(2) default 0,
   排班方式 number(2),
   适用性别	varchar2(4),
   适用年龄段 varchar2(100),
   是否删除 number(2) default 0,
   建档时间 Date,
   撤档时间 Date)
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊号源 Add Constraint 临床出诊号源_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源 Add Constraint 临床出诊号源_UQ_号码 Unique (号码,撤档时间) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源 Add Constraint 临床出诊号源_UQ_科室项目 Unique (科室ID,项目ID,医生姓名,医生ID,撤档时间) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源 Add Constraint 临床出诊号源_FK_科室ID Foreign Key (科室ID) References 部门表( ID) ;
Alter Table 临床出诊号源 Add Constraint 临床出诊号源_FK_项目ID Foreign Key (项目ID) References 收费项目目录(ID) ;
Alter Table 临床出诊号源 Add Constraint 临床出诊号源_FK_医生id Foreign Key (医生id) References 人员表(ID) ;
 
Create Index 临床出诊号源_IX_项目ID on 临床出诊号源(项目ID) Tablespace zl9Indexhis;
Create Index 临床出诊号源_IX_医生id on 临床出诊号源(医生id) Tablespace zl9Indexhis;
Create Index 临床出诊号源_IX_医生姓名 on 临床出诊号源(医生姓名) Tablespace zl9Indexhis;

Create Sequence 临床出诊号源限制_ID start with 1;
Create Table 临床出诊号源限制(
   ID number(18) not null,
   号源ID number(18),
   上班时段 varchar2(10),
   限号数 number(10),
   限约数 number(10),
   是否序号控制 number(2) default 0,
   是否分时段  NUMBER(2),
   预约控制 number(2),
   是否独占 number(2) default 0,   
   分诊方式 number(3),
   诊室ID number(18))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊号源限制  Add Constraint 临床出诊号源限制_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源限制 Add Constraint 临床出诊号源限制_FK_号源ID Foreign Key (号源ID) References 临床出诊号源( ID) ;
Alter Table 临床出诊号源限制  Add Constraint 临床出诊号源限制_UQ_号源ID  Unique (号源ID,上班时段) Using Index Tablespace zl9Indexhis; 
Alter Table 临床出诊号源限制 Add Constraint 临床出诊号源限制_FK_诊室ID Foreign Key (诊室ID) References 门诊诊室( ID) ;
Create Index 临床出诊号源限制_IX_诊室ID on 临床出诊号源限制(诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊号源诊室(
   限制ID number(18),
   诊室ID number(18))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊号源诊室  Add Constraint 临床出诊号源诊室_PK  Primary Key (限制ID,诊室ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源诊室 Add Constraint 临床出诊号源诊室_FK_限制ID Foreign Key (限制ID) References 临床出诊号源限制( ID) ;
Alter Table 临床出诊号源诊室 Add Constraint 临床出诊号源诊室_FK_诊室ID Foreign Key (诊室ID) References 门诊诊室( ID) ;
create Index 临床出诊号源诊室_IX_诊室ID on 临床出诊号源诊室(诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊号源时段(
   限制ID number(18),
   序号 number(18),
   开始时间 Date,
   终止时间 Date,
   限制数量 number(10),
   是否预约 number(2))
TABLESPACE zl9BaseItem;

Alter Table 临床出诊号源时段  Add Constraint 临床出诊号源时段_PK  Primary Key (限制ID,序号) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源时段 Add Constraint 临床出诊号源时段_FK_限制ID Foreign Key (限制ID) References 临床出诊号源限制( ID) ;

Create Table 临床出诊号源控制(
   限制ID number(18),
   类型 number(2),
   性质 number(2),
   名称 varchar2(50),
   序号 number(18),
   控制方式 number(2),
   数量 number(16,5))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊号源控制  Add Constraint 临床出诊号源控制_PK  Primary Key (限制ID,类型,性质,名称,序号) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊号源控制 Add Constraint 临床出诊号源控制_FK_限制ID Foreign Key (限制ID) References 临床出诊号源限制(ID);

Create Sequence 临床出诊表_ID start with 1;

Create Table 临床出诊表(
   ID number(18) not null,
   排班方式 number(18),
   出诊表名 varchar2(50),
   年份 number(4),
   月份 number(2),
   周数 number(2),
   应用范围 number(2),
   科室ID number(18),
   备注 varchar2(100),
   发布人 varchar2(50),
   发布时间 Date,
   模板类型 Number(2))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊表  Add Constraint 临床出诊表_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊表  Add Constraint 临床出诊表_UQ_出诊表名  Unique (年份,月份,周数,出诊表名,排班方式) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊表 Add Constraint 临床出诊表_FK_科室ID Foreign Key (科室ID) References 部门表(ID) ;
Create Index 临床出诊表_IX_科室ID on 临床出诊表(科室ID) Tablespace zl9Indexhis;

Create Sequence 临床出诊安排_ID start with 1;
Create Table 临床出诊安排(
   ID number(18) not null,
   出诊ID number(18),
   号源ID number(18),
   项目ID number(18),
   医生id number(18),
   医生姓名 varchar2(50),
   排班规则 number(2),
   是否周六出诊 number(2),
   是否周日出诊 number(2),
   开始时间 Date,
   终止时间 Date,
   操作员姓名 varchar2(50),
   登记时间 Date,
   审核人 VARCHAR2(50),
   审核时间 Date,
   是否临时安排 number(2))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊安排 Add Constraint 临床出诊安排_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;

Alter Table 临床出诊安排 Add Constraint 临床出诊安排_FK_号源ID Foreign Key (号源ID) References 临床出诊号源( ID) ;
Alter Table 临床出诊安排 Add Constraint 临床出诊安排_FK_出诊ID Foreign Key (出诊ID) References 临床出诊表( ID) ;
Alter Table 临床出诊安排 Add Constraint 临床出诊安排_FK_项目ID Foreign Key (项目ID) References 收费项目目录(ID) ;
Alter Table 临床出诊安排 Add Constraint 临床出诊安排_FK_医生id Foreign Key (医生id) References 人员表(ID);

Create Index 临床出诊安排_IX_项目ID on 临床出诊安排(项目ID) Tablespace zl9Indexhis;
Create Index 临床出诊安排_IX_医生id on 临床出诊安排(医生id) Tablespace zl9Indexhis;
Create Index 临床出诊安排_IX_号源ID on 临床出诊安排(号源ID) Tablespace zl9Indexhis;
Create Index 临床出诊安排_IX_出诊ID on 临床出诊安排(出诊ID) Tablespace zl9Indexhis;

Create Sequence 临床出诊限制_ID start with 1;
Create Table 临床出诊限制(
   ID     number(18),
   安排ID number(18),
   限制项目 varchar2(20),
   上班时段 varchar2(10),
   限号数 number(10),
   限约数 number(10),
   是否序号控制 number(2),
   是否分时段 NUMBER(2),
   预约控制 number(2),
   分诊方式 number(2),
   诊室ID number(18),
   是否独占 number(2))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊限制  Add Constraint 临床出诊限制_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊限制  Add Constraint 临床出诊限制_UQ_安排ID  Unique (安排ID,限制项目,上班时段) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊限制 Add Constraint 临床出诊限制_FK_安排ID Foreign Key (安排ID) References 临床出诊安排( ID) ;
Alter Table 临床出诊限制 Add Constraint 临床出诊限制_FK_诊室id Foreign Key (诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊限制_IX_诊室ID on 临床出诊限制(诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊时段(
   限制ID number(18),
   序号 number(18),
   开始时间 Date,
   终止时间 Date,
   限制数量 number(10),
   是否预约 number(2))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊时段  Add Constraint 临床出诊时段_PK  Primary Key (限制ID,序号) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊时段 Add Constraint 临床出诊时段_FK_限制ID Foreign Key (限制ID) References 临床出诊限制( ID) ;


Create Table 临床出诊诊室(
   限制ID number(18),
   诊室ID number(18))
TABLESPACE zl9BaseItem ;
Alter Table 临床出诊诊室  Add Constraint 临床出诊诊室_PK  Primary Key (限制ID,诊室id) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊诊室 Add Constraint 临床出诊诊室_FK_限制ID Foreign Key (限制ID) References 临床出诊限制( ID) ;

Alter Table 临床出诊诊室 Add Constraint 临床出诊诊室_FK_诊室id Foreign Key (诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊诊室_IX_诊室ID on 临床出诊诊室(诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊挂号控制(
   限制ID number(18),
   类型 number(2),
   性质 number(2),
   名称 varchar2(50),
   序号 number(18),
   控制方式 number(2),
   数量 number(16,5))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊挂号控制  Add Constraint 临床出诊挂号控制_PK  Primary Key (限制ID,序号,名称,类型,性质) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊挂号控制 Add Constraint 临床出诊挂号控制_FK_限制ID Foreign Key (限制ID) References 临床出诊限制( ID) ;
 
Create Sequence 临床出诊记录_ID start with 1;
Create Table 临床出诊记录(
   ID number(18) not null,
   安排ID number(18),
   号源ID number(18),
   出诊日期 Date,
   上班时段 varchar2(10),
   开始时间 Date,
   终止时间 Date,
   停诊开始时间 Date,
   停诊终止时间 Date,
   停诊原因 varchar2(50),
   缺省预约时间 Date,
   提前挂号时间 Date,
   限号数 number(10),
   已挂数 number(10),
   限约数 number(10),
   已约数 number(10),
   其中已接收 number(10),
   是否序号控制 number(2) default 0,
   是否分时段 number(2) default 0,
   预约控制 number(2),
   是否独占 number(2),
   项目ID number(18),
   科室ID number(18),
   医生id number(18),
   医生姓名 varchar2(50),
   替诊开始时间 Date,
   替诊终止时间 Date,
   替诊医生id number(18),
   替诊医生姓名 varchar2(50),
   分诊方式 number(2),
   诊室ID Number(18),
   是否锁定 number(2) default 0,
   是否临时出诊 number(2) default 0,
   登记人 varchar2(50),
   登记时间 Date,
   是否发布 number(2) default 0,
   相关ID Number(18))
TABLESPACE zl9BaseItem;

Alter Table 临床出诊记录  Add Constraint 临床出诊记录_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;

Alter Table 临床出诊记录 Add Constraint 临床出诊记录_UQ_出诊日期 Unique(出诊日期, 号源ID, 上班时段, 相关ID) Using Index Tablespace Zl9indexhis;

Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_安排ID Foreign Key (安排ID) References 临床出诊安排( ID) ;
Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_号源ID Foreign Key (号源ID) References 临床出诊号源( ID) ;

Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_项目ID Foreign Key (项目ID) References 收费项目目录(ID) ;
Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_科室ID Foreign Key (科室ID) References 部门表(ID) ;
Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_医生id Foreign Key (医生id) References 人员表(ID) ;
Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_替诊医生id Foreign Key (替诊医生id) References 人员表(ID) ;
Alter Table 临床出诊记录 Add Constraint 临床出诊记录_FK_诊室id Foreign Key (诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊记录_IX_诊室ID on 临床出诊记录(诊室ID) Tablespace zl9Indexhis;

Create Index 临床出诊记录_IX_安排ID on 临床出诊记录(安排ID) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_号源ID on 临床出诊记录(号源ID) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_替诊医生id on 临床出诊记录(替诊医生id) Tablespace zl9Indexhis;

Create Index 临床出诊记录_IX_医生id on 临床出诊记录(医生id) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_项目ID on 临床出诊记录(项目ID) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_科室ID on 临床出诊记录(科室ID) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_开始时间 on 临床出诊记录(开始时间,号源ID) Tablespace zl9Indexhis;
Create Index 临床出诊记录_IX_相关ID On 临床出诊记录(相关ID) Tablespace zl9Indexhis;

Create Sequence 临床出诊停诊记录_ID start with 1;
Create Table 临床出诊停诊记录(
   ID number(18) not null,
   记录ID number(18),
   开始时间 Date,
   终止时间 Date,
   停诊原因 varchar2(50),
   替诊医生ID number(18),
   替诊医生姓名 varchar2(50),
   申请人 varchar2(50),
   申请时间 Date,
   审批人 varchar2(50),
   审批时间 Date,
   取消人 varchar2(50),
   取消时间 Date)
TABLESPACE zl9BaseItem ;
Alter Table 临床出诊停诊记录 Add 登记人 Varchar2(50);

Alter Table 临床出诊停诊记录  Add Constraint 临床出诊停诊记录_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊停诊记录 Add Constraint 临床出诊停诊记录_FK_记录ID Foreign Key (记录ID) References 临床出诊记录( ID) ;
Alter Table 临床出诊停诊记录 Add Constraint 临床出诊停诊记录_FK_替诊医生ID Foreign Key (替诊医生ID) References 人员表( ID) ;

Create Index 临床出诊停诊记录_IX_记录ID on 临床出诊停诊记录(记录ID) Tablespace zl9Indexhis;
Create Index 临床出诊停诊记录_IX_替诊医生ID on 临床出诊停诊记录(替诊医生ID) Tablespace zl9Indexhis;
Create Index 临床出诊停诊记录_IX_申请时间 on 临床出诊停诊记录(申请时间) Tablespace zl9Indexhis;
Create Index 临床出诊停诊记录_IX_审批时间 on 临床出诊停诊记录(审批时间) Tablespace zl9Indexhis;

Create Table 临床出诊序号控制(
   记录ID number(18),
   序号 number(18),
   预约顺序号 number(18),
   开始时间 Date,
   终止时间 Date,
   数量 number(10),
   是否预约 number(2),
   挂号状态 number(2),
   锁号时间 Date,
   类型   number(2),
   名称 varchar2(50),
   操作员姓名 varchar2(50),
   工作站IP varchar2(20),
   工作站名称 varchar2(200),
   备注 varchar2(100),
   是否停诊 Number(2) Default 0)
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊序号控制  Add Constraint 临床出诊序号控制_UQ_记录ID  Unique (记录ID,序号,预约顺序号) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊序号控制 Add Constraint 临床出诊序号控制_FK_记录ID Foreign Key (记录ID) References 临床出诊记录( ID) ;
Alter Table 临床出诊序号控制 Modify 记录ID Constraint 临床出诊序号控制_NN_记录ID Not Null;

Create Table 临床出诊诊室记录(
   记录ID number(18),
   诊室ID Number(18),
   当前分配 number(1) default 0)
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊诊室记录 Add Constraint 临床出诊诊室记录_PK  Primary Key (记录ID,诊室ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊诊室记录 Add Constraint 临床出诊诊室记录_FK_记录ID Foreign Key (记录ID) References 临床出诊记录( ID) ;
Alter Table 临床出诊诊室记录 Add Constraint 临床出诊诊室记录_FK_诊室id Foreign Key (诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊诊室记录_IX_诊室ID on 临床出诊诊室记录(诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊挂号控制记录(
   记录ID number(18),
   类型 number(2),
   性质 number(2),
   名称 varchar2(50),
   序号 number(18),
   控制方式 number(2),
   数量 number(16,5))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊挂号控制记录  Add Constraint 临床出诊挂号控制记录_PK  Primary Key (记录ID,名称,序号,类型,性质) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊挂号控制记录 Add Constraint 临床出诊挂号控制记录_FK_记录ID Foreign Key (记录ID) References 临床出诊记录(ID) ;

Create Sequence 病人服务信息记录_ID start with 1;
Create Table 病人服务信息记录(
   ID number(18) not null,
   通知类型 number(18),
   记录ID number(18),
   挂号ID number(18),
   号源ID number(18),
   号码 varchar2(10),
   科室ID number(18),
   项目ID number(18),
   医生ID number(18),
   医生姓名 varchar2(50),
   病人ID number(18),
   复诊方式 number(2),
   数量 number(10),
   开始时间 Date,
   终止时间 Date,
   通知原因 varchar2(100),
   登记人 varchar2(50),
   登记时间 Date,
   处理说明 varchar2(100),
   处理人 varchar2(50),
   处理时间 Date)
TABLESPACE zl9BaseItem ;

Alter Table 病人服务信息记录  Add Constraint 病人服务信息记录_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_号源ID Foreign Key (号源ID) References 临床出诊号源( ID) ;
Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_记录ID Foreign Key (记录ID) References 临床出诊记录( ID) ;

Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_项目ID Foreign Key (项目ID) References 收费项目目录(ID) ;
Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_医生id Foreign Key (医生id) References 人员表(ID) ;
Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_科室ID Foreign Key (科室ID) References 部门表(ID) ;
Alter Table 病人服务信息记录 Add Constraint 病人服务信息记录_FK_病人ID Foreign Key (病人ID) References 病人信息(病人ID) ;

Create Index 病人服务信息记录_IX_登记时间 on 病人服务信息记录(登记时间) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_处理时间 on 病人服务信息记录(处理时间) Tablespace zl9Indexhis;

Create Index 病人服务信息记录_IX_病人ID on 病人服务信息记录(病人ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_挂号ID on 病人服务信息记录(挂号ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_号码ID on 病人服务信息记录(号码) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_号源ID on 病人服务信息记录(号源ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_记录ID on 病人服务信息记录(记录ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_科室ID on 病人服务信息记录(科室ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_项目ID on 病人服务信息记录(项目ID) Tablespace zl9Indexhis;
Create Index 病人服务信息记录_IX_医生ID on 病人服务信息记录(医生ID) Tablespace zl9Indexhis;

Create Sequence 临床出诊变动记录_ID start with 1;
Create Table 临床出诊变动记录(
   ID number(18) not null,
   记录ID number(18),
   变动类型 number(2),
   原预约控制 number(2),
   现预约控制 number(2),
   原数量 number(10),
   现数量 number(10),
   原分诊方式 number(2),
   原门诊诊室 varchar2(20),
   原诊室ID number(18),
   现分诊方式 number(2),
   现门诊诊室 varchar2(20),
   现诊室ID number(18),
   操作员姓名 varchar2(50),
   登记时间 Date)
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊变动记录  Add Constraint 临床出诊变动记录_PK  Primary Key (ID) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊变动记录 Add Constraint 临床出诊变动记录_FK_记录ID Foreign Key (记录ID) References 临床出诊记录( ID) ;
Create Index 临床出诊变动记录_IX_记录ID on 临床出诊变动记录(记录ID) Tablespace zl9Indexhis;
Create Index 临床出诊变动记录_IX_登记时间 on 临床出诊变动记录(登记时间) Tablespace zl9Indexhis;

Alter Table 临床出诊变动记录 Add Constraint 临床出诊变动记录_FK_原诊室id Foreign Key (原诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊变动记录_IX_原诊室ID on 临床出诊变动记录(原诊室ID) Tablespace zl9Indexhis;

Alter Table 临床出诊变动记录 Add Constraint 临床出诊变动记录_FK_现诊室id Foreign Key (现诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊变动记录_IX_现诊室ID on 临床出诊变动记录(现诊室ID) Tablespace zl9Indexhis;

Create Table 临床出诊变动明细(
   变动ID number(18),
   变动性质 number(2),
   类型 number(2),
   名称 varchar2(50),
   序号 number(18),
   控制方式 number(2),
   数量 number(10),
   诊室ID number(18),
   门诊诊室 varchar2(20))
TABLESPACE zl9BaseItem ;

Alter Table 临床出诊变动明细  Add Constraint 临床出诊变动明细_PK  Primary Key (变动ID,名称,变动性质,序号) Using Index Tablespace zl9Indexhis;
Alter Table 临床出诊变动明细 Add Constraint 临床出诊变动明细_FK_变动ID Foreign Key (变动ID) References 临床出诊变动记录( ID) ;

Alter Table 临床出诊变动明细 Add Constraint 临床出诊变动明细_FK_诊室id Foreign Key (诊室id) References 门诊诊室(ID) ;
Create Index 临床出诊变动明细_IX_诊室ID on 临床出诊变动明细(诊室ID) Tablespace zl9Indexhis;

ALTER TABLE 病人挂号记录 ADD (出诊记录ID number(18));
Alter Table 病人挂号记录 Add Constraint 病人挂号记录_FK_出诊记录ID Foreign Key (出诊记录ID) References 临床出诊记录( ID) ;
Create Index 病人挂号记录_IX_出诊记录ID on 病人挂号记录(出诊记录ID) Tablespace zl9Indexhis;

--91721:刘尔旋,2016-07-15,自动记账更改
Alter Table 病案主页 Add 是否禁止自动记帐 Number(1);

--96690:廖思奇,2016-06-20,增加待处理人字段用于分配某医生写报告
Alter Table 影像检查记录 Add 待处理人 Varchar2(64);

--92798:余伟节,2016-08-11,路径医嘱审核
alter table 路径医嘱变动 add 审核状态 number(1);
alter table 路径医嘱变动 add 审核人 varchar2(100);
alter table 路径医嘱变动 add 审核时间 date;

--79968:余伟节,2016-08-30,新生儿登记身长、体重、血型、备注说明
alter table 病人新生儿记录 add  身长  number(16,5);

alter table 病人新生儿记录 add  体重  number(16,5);

alter table 病人新生儿记录 add  血型  varchar2(10);

alter table 病人新生儿记录 add 备注说明 varchar2(100);


-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--99873:刘尔旋,2016-12-21,门诊结帐检查未执行
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 265, '门诊结帐检查未发药项目', 参数值, '0',
         '在门诊结帐时是否检查病人的未发药品项目:0-不检查,1-检查并提示,2-检查并禁止'
  From zlParameters
  Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '出院时检查未发药项目' And Not Exists
   (Select 1 From zlParameters Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '门诊结帐检查未发药项目');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 266, '门诊结帐检查未执行项目', 参数值, '0',
         '在门诊结帐时是否检查病人的未执行项目:0-不检查,1-检查并提示,2-检查并禁止'
  From zlParameters
  Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '出院时检查未执行项目' And Not Exists
   (Select 1 From zlParameters Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '门诊结帐检查未执行项目');

--68694:刘尔旋,2016-08-17,新挂号安排改进
Update 门诊诊室 Set ID = Rownum Where ID Is Null;
Select 门诊诊室_Id.Nextval From Dual Connect By Rownum < (Select Nvl(Max(ID), 0) From 门诊诊室);

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Begin
  For c_记录 In (Select ID, 停诊开始时间, 停诊终止时间
               From 临床出诊记录
               Where 出诊日期 >= Trunc(Sysdate) And 停诊终止时间 > Sysdate And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1) Loop
  
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间;
  End Loop;
End;
/

--101951:梁经伙,2016-12-14,增加参数 ICD附码检查 
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 0, 0, 0, 0, 51, 'ICD附码检查', Null, '0',
         '主要出院诊断编码为C、D类时，主要出院诊断的ICD附码：1-必须填写，2-提示是否填写，0-不检查。'
  From Dual
  Where Not Exists
   (Select 1 From zlParameters Where 参数名 = 'ICD附码检查' And 模块 =1261 And Nvl(系统, 0) = &n_System);

--102791:刘尔旋,2016-12-08,预约排队按时点显示
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, Null, Null, Null, Null, Null, 270, '预约排队按时点显示', Null, '0',
         '控制预约挂号进入排队叫号列表后,分时段的号码是否到了发生时间才能显示.0-不时点显示,1-按时点显示'
  From Dual
  Where Not Exists
   (Select 1 From zlParameters Where 参数名 = '预约排队按时点显示' And 模块 Is Null And Nvl(系统, 0) = &n_System);

--103334:余智勇,2016-12-02,呼叫时通知开始发药
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 61, '呼叫时通知开始发药', Null, '0',
         '当启用药品自动化设备部件后，操作“呼叫”功能的同时通知设备开始发药！注意：只有注册相关部件后，参数设置窗体才可见。0-呼叫不通知设备；1-呼叫通知设备'
  From Dual
  Where Not Exists
   (Select 1 From zlParameters Where 参数名 = '呼叫时通知开始发药' And 模块 = 1341 And Nvl(系统, 0) = &n_System);

--102973:冉俊明,2016-11-30,对医保病人进行门诊收费，在进入结算窗口时光标是否缺省定位到“医保结算”按钮上。
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 1, 0, 0, 0, 112, '医保结算光标缺省定位', Null, '0',
         '对医保病人进行门诊收费，在进入结算窗口时光标是否缺省定位到"医保结算"按钮上。0-不缺省定位到"医保结算"按钮上，1-缺省定位到"医保结算"按钮上'
  From Dual
  Where Not Exists
   (Select 1 From zlParameters Where 参数名 = '医保结算光标缺省定位' And 模块 = 1121 And Nvl(系统, 0) = &n_System);

--95267:胡俊勇,2016-11-28,诊间支付
Update zlParameters
Set 参数名 = '门诊医嘱发送后启用诊间支付', 参数说明 = '门诊医嘱发送后启用诊间支付，启用参数后自动弹出扣费界面，1－启用，0－不启用' 
Where 参数名 = '启用诊间支付' And 模块 = 1252 And 系统=&n_System;

--101837:胡俊勇，2016-10-24，住院医生站病历质控消息
Insert Into 业务消息类型(编码,名称,说明,保留天数) 
Select 'ZLHIS_EMR_025','病历质控消息','新版病历模块处理病历后发送给住院医生站的一个通知消息。',7  From Dual;

update zlparameters 
set 参数说明='每位数分别代表不同消息类型：1病历审阅、2医嘱安排、3危急值、4报告撤销、5医嘱审核、6处方审查、7传染病报告、8病历质控'
where  参数名='自动刷新内容' and 模块=1261  And Nvl(系统,0) = &n_System;

Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 50, '病历质控消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有病历质控消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '病历质控消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);

--100217:张德婷,2016-10-11,保存实际操作人
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 1, 0, 37,'打印瓶签时填写各个环节的实际操作员', Null, '0', '启用该参数之后打印瓶签时填写各个环节的实际工作人员'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1345 And 参数名 = '打印瓶签时填写各个环节的实际操作员');


--97760:陈刘,2016-10-10,出院标记优先显示同时控制出院时间选择

Update zlParameters
Set 参数说明 = '1.出院并下达了出院医嘱：勾选了参数，则体温单上的出院标志则显示出院方式(好转、治愈等),' || Chr(13) ||
              '并且出院时间显示病人右键出院时选择的出院时间,否则显示出院医嘱的内容(如：尸体料理),出院时间显示医嘱上的出院时间' || Chr(13) ||
              '2.出院未下达出院医嘱：体温单上的出院标志均以出院方式为准'
Where 参数名 = '出院标志优先显示' And Nvl(模块, 0) = 1255 And Nvl(系统, 0) = &n_System;

--100911:廖思奇,2016-10-10,影像收藏类别 根据创建人将创建人ID查询出并赋值,然后删除创建人
Update 影像收藏类别
Set 创建人id =
     (Select Max(ID) From 人员表 Where 姓名 = 创建人 And 上级id Is Not Null);

--101336:余伟节,2016-10-09,电子病案打印
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1566, 1, 0, 0, 0, 1, '检验对应报表', Null, Null,
         '控制检验报告按指定报表输出 空-按缺省方式输出;不为空-按指定报表输出'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1566 And 参数名 = '检验对应报表');

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1566, 1, 0, 0, 0, 2, '检查对应报表', Null, Null,
         '控制检查报告按指定报表输出 空-按缺省方式输出;不为空-按指定报表输出'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1566 And 参数名 = '检查对应报表');

--96809:李南春,2016-10-08,医疗卡发放同时收取预交款
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1107, 1, 1, 0, 1, 18, '当前预交票据号', Null, Null,
         '收取预交款时使用的实际票据号'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '当前预交票据号' And Nvl(模块, 0) = 1107 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1107, 0, 0, 0, 0, 19, '预交发票打印方式', Null, Null,
         '主要控制病人发卡或补卡时进行缴预交款后的预交发票的打印'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '预交发票打印方式' And Nvl(模块, 0) = 1107 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1107, 0, 0, 0, 0, 20, '预交发票格式', Null, Null,
         '控制在完成缴预交后,根据预交类别决定打印哪种格式的票据'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '预交发票格式' And Nvl(模块, 0) = 1107 And Nvl(系统, 0) = &n_System);

--100272:刘尔旋,2016-09-23,轧帐区分门诊和住院预交
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1506, 0, 0, 0, 0, 3, '预交轧帐按门诊或住院分别轧帐', '0', '0',
         '预交轧帐时门诊和住院预交是否分别轧帐.1-分别轧帐;0-不分门诊和住院,缺省为0'
  From Dual
  Where Not Exists (Select 1
         From zlParameters
         Where 参数名 = '预交轧帐按门诊或住院分别轧帐' And Nvl(模块, 0) = 1506 And Nvl(系统, 0) = &n_System);

--86122:梁经伙,2016-09-21,增加参数“血透室书写新版护理记录”。
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1263, -null, -null, -null, -null, 24, '血透室书写新版护理记录', '0', '0',
         '控制医技站血透室使用的护理记录是旧版护理记录还是新版护理记录。0-医技站血透室使用旧版护理记录，1-医技站血透室使用新版护理记录。'
  From Dual
  Where Not Exists (Select 1
         From Zlparameters
         Where 参数名 = '血透室书写新版护理记录' And Nvl(模块, 0) = 1263 And Nvl(系统, 0) = &n_System);

--96692:廖思奇,2016-09-21,增加自由配置病理号别的方式，原来的号码规则ID采用的序列，现在修改为较小的数字，同时修改诊疗项目目录的执行分类。
Declare
  v_Sql Varchar2(4000);
  v_count Number(4);
Begin
  Select Count(1) Into v_count From Zlupgradeconfig  Where 项目 = '病理号码规则相关历史数据修正_20161124';
  If v_count =0 Then
    --判断是否有 病理检查信息_Fk_号码规则id 这个外键 并且禁用
    If Zl_Checkobject(3, '病理检查信息_FK_号码规则ID') > 0 Then
      v_Sql := 'Alter Table ' || '病理检查信息' || ' Disable Constraint ' || '病理检查信息_FK_号码规则ID';
      Execute Immediate v_Sql;
    End If;
  
    --判断是否有 病理号码记录_Fk_号码规则id 这个外键 并且禁用
    If Zl_Checkobject(3, '病理号码记录_FK_号码规则ID') > 0 Then
      v_Sql := 'Alter Table ' || '病理号码记录' || ' Disable Constraint ' || '病理号码记录_FK_号码规则ID';
      Execute Immediate v_Sql;
    End If;
  
    --判断是否有 病理号码规则_PK 并且禁用
    If Zl_Checkobject(3, '病理号码规则_PK') > 0 Then
      v_Sql := 'Alter Table ' || '病理号码规则' || ' Disable Constraint ' || '病理号码规则_PK';
      Execute Immediate v_Sql;
    End If;
    
    --由于修改了逻辑，统一增加1，以免出现病理号重复的问题
    Update 病理号码记录 Set 当前序号=当前序号+1;
  
    Update 病理号码规则 Set ID = 1, 名称 = '常规' Where 类型 = 0;
    Update 病理号码规则 Set ID = 2, 名称 = '冰冻' Where 类型 = 1;
    Update 病理号码规则 Set ID = 3, 名称 = '细胞' Where 类型 = 2;
    Update 病理号码规则 Set ID = 4, 名称 = '会诊' Where 类型 = 3;
    Update 病理号码规则 Set ID = 5, 名称 = '尸检' Where 类型 = 4;
    Update 病理号码规则 Set ID = 6, 名称 = '快速石蜡' Where 类型 = 5;
  
    Delete 病理号码规则 Where 类型 = -1;
  
    Update 诊疗项目目录 Set 执行分类 = 6 Where 执行分类 = 5 And 类别 = 'D' And 操作类型 = '病理';
    Update 诊疗项目目录 Set 执行分类 = 5 Where 执行分类 = 4 And 类别 = 'D' And 操作类型 = '病理';
    Update 诊疗项目目录 Set 执行分类 = 4 Where 执行分类 = 3 And 类别 = 'D' And 操作类型 = '病理';
    Update 诊疗项目目录 Set 执行分类 = 3 Where 执行分类 = 2 And 类别 = 'D' And 操作类型 = '病理';
    Update 诊疗项目目录 Set 执行分类 = 2 Where 执行分类 = 1 And 类别 = 'D' And 操作类型 = '病理';
    Update 诊疗项目目录 Set 执行分类 = 1 Where 执行分类 = 0 And 类别 = 'D' And 操作类型 = '病理';
  
    Update 病理检查信息 Set 号码规则id = 1 Where 检查类型 = 0;
    Update 病理检查信息 Set 号码规则id = 2 Where 检查类型 = 1;
    Update 病理检查信息 Set 号码规则id = 3 Where 检查类型 = 2;
    Update 病理检查信息 Set 号码规则id = 4 Where 检查类型 = 3;
    Update 病理检查信息 Set 号码规则id = 5 Where 检查类型 = 4;
    Update 病理检查信息 Set 号码规则id = 6 Where 检查类型 = 5;
  
    --重新启用之前被禁用的约束
    v_Sql := 'Alter Table ' || '病理号码规则' || ' Enable Constraint ' || '病理号码规则_PK';
    Execute Immediate v_Sql;
    v_Sql := 'Alter Table ' || '病理检查信息' || ' Enable Constraint ' || '病理检查信息_FK_号码规则ID';
    Execute Immediate v_Sql;
    v_Sql := 'Alter Table ' || '病理号码记录' || ' Enable Constraint ' || '病理号码记录_FK_号码规则ID';
    Execute Immediate v_Sql;
 
    Insert Into Zlupgradeconfig (项目, 内容) Values ('病理号码规则相关历史数据修正_20161124', '完成');
  End If;
End;
/

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 1, 0, 0, 1, 110, '病理号别过滤', Null, '在影像病理工作站，可在快速工具栏按病理号别过滤检查列表数据','用于保存快速过滤中病理号别的选择情况，提供记忆功能，以免每次都要重新设置'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1294 And 参数名 = '病理号别过滤');


--100507:冉俊明,2016-09-08,单据全部退费完后删除医嘱附费记录
--修正数据，删除费用单据已全部退费的病人医嘱附费记录
--考虑到门诊费用不会在很多天后再来退费，所以暂定修正一个星期以内的数据
Declare
  n_Count Number(8);
Begin
  For c_医嘱 In (Select Distinct NO, 医嘱序号
               From 门诊费用记录
               Where Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null And 登记时间 > Trunc(Sysdate) - 7) Loop
  
    Begin
      Select 1
      Into n_Count
      From (Select 序号, Sum(数量) As 剩余数量
             From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                    From 门诊费用记录
                    Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = c_医嘱.No
                    Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
             Group By 序号
             Having Sum(数量) <> 0)
      Where Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
  
    If Nvl(n_Count, 0) = 0 Then
      Delete From 病人医嘱附费 Where 记录性质 = 1 And 医嘱id = c_医嘱.医嘱序号 And NO = c_医嘱.No;
    End If;
  End Loop;
  Commit;
End;
/

--100367:张德婷,2016-09-06,静配中心空包药品收费
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1345, 0, 0, 1, 0, 38,'打包药品在发送环节收取配置费', Null, '0', '启用该参数之后打包药品在发送环节收取配置费'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1345 And 参数名 = '打包药品在发送环节收取配置费');

--100296:冉俊明,2016-09-02,字典管理中不能设置门诊诊室
Delete From zlBaseCode Where 系统 = &n_System And 表名 = '门诊诊室';

--100191:梁经伙,2016-09-02,对 疾病阳性记录 表做数据转出处理
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,8,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All
Select '疾病阳性记录',22,1,-NULL From Dual Union All
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0) A;

--100117:刘尔旋,2016-09-01,执行登记单打印方式
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1142, 0, 0, 0, 0, 9,'执行登记单打印方式', Null, '1', '执行登记后，是否打印执行登记单。0－不打印,1－自动打印,2-选择打印。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And Nvl(模块, 0) = 1142 And 参数名 = '执行登记单打印方式');

--99536:刘尔旋,2016-08-30,允许门诊转住院
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1137, 0, 0, 0, 0, 53,'出院病人允许门诊转住院', '0', '0', '允许出院病人进行门诊费用转住院操作。0－禁止，1－允许。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And Nvl(模块, 0) = 1137 And 参数名 = '出院病人允许门诊转住院');

--86118:王振涛,2016-08-29,添加扫描条码登记参数,补充10.34.90
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1212, 1, 0, 0, 0, 5,'扫描条码后直接登记', '0', '0', '在标本登记中，控制是否只扫描一次条码就进行登记'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 参数名 = '扫描条码后直接登记' And nvl(模块,0) = 1212 And nvl(系统,0) = &n_System);

--86035:胡俊勇,2016-08-24,处方审查功能关联修改
Insert Into 业务消息类型(编码,名称,说明,保留天数) 
Select 'ZLHIS_RECIPEAUDIT_001','门诊处方审查消息','门诊处方审查完成后产生的一个通知消息。',7  From Dual Union All
Select 'ZLHIS_RECIPEAUDIT_002','住院处方审查消息','住院处方审查完成后产生的一个通知消息。',7  From Dual;

Declare
  v_参数值 Zlparameters.参数值%Type;
  v_Temp   Zlparameters.参数值%Type;
Begin
  Update zlParameters
  Set 参数说明 = '每位数分别代表不同消息类型：1病历审阅、2医嘱安排、3危急值、4报告撤销、5医嘱审核、6处方审查、7传染病报告'
  Where 参数名 = '自动刷新内容' And 模块 = 1261;

  Update zlParameters
  Set 参数说明 = '每位数分别代表不同消息类型：1危急值、2传染病、3处方审查'
  Where 参数名 = '自动刷新内容' And 模块 = 1260;

  For c_Par In (Select a.参数值, Nvl(a.用户名, '空') As 用户名, Nvl(a.机器名, '空') As 机器名, a.参数id
                From zlUserParas A, zlParameters B
                Where a.参数id = b.Id And b.参数名 = '自动刷新内容' And b.模块 = 1261) Loop
    v_参数值 := c_Par.参数值;
    If Length(v_参数值) = 6 Then
      v_Temp := Substr(v_参数值, 6, 1);
      If v_Temp = '1' Then
        v_Temp := Substr(v_参数值, 1, 5) || '0' || '1';
        Update zlUserParas
        Set 参数值 = v_Temp
        Where Nvl(用户名, '空') = c_Par.用户名 And Nvl(机器名, '空') = c_Par.机器名 And 参数id = c_Par.参数id;
      End If;
    End If;
  End Loop;
End;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Insert Into zlBakTables(系统,组号,表名,序号,直接转出,停用触发器)
Select &n_System,2,A.* From (
Select 表名,序号,直接转出,停用触发器 From zlBakTables Where 1 = 0 Union All 
  Select '处方审查明细',14,1,-Null From Dual Union All 
  Select '处方审查结果',15,1,-Null From Dual Union All 
  Select '处方审查记录',18,1,-Null From Dual Union All 
Select 表名,序号,直接转出,停用触发器 From ZLBAKTABLES Where 1 = 0) A;

Insert Into zlComponent(部件,名称,主版本,次版本,附版本,系统,注册产品名称,注册产品简名,注册产品版本) Values('zl9RecipeAudit','处方审查部件',10,34,90,&n_System,'中联医院信息系统','ZLHIS+','10');

Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1351,'门诊处方审查','药剂师对门诊医生新开的处方进行审查，只有通过审查才能收费和配发药。',&n_System,'zl9RecipeAudit'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1352,'住院药嘱审查','药剂师对住院医生新开的药嘱进行审查，只有通过审查才能配发药。',&n_System,'zl9RecipeAudit'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1353,'处方审查项目','确定门诊处方和住院药嘱，需要审查哪些项目。',&n_System,'zl9RecipeAudit'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1354,'处方审查条件','门诊处方审查的处方，按本窗体条件设置提取和开展审查。',&n_System,'zl9RecipeAudit'); 
Insert Into zlPrograms(序号,标题,说明,系统,部件) Values(1355,'处方审查统计','可分别以门诊处方和住院药嘱来统计数据，并输出报表。',&n_System,'zl9RecipeAudit'); 

Insert Into zlMenus
  (组别, ID, 上级id, 标题, 快键, 说明, 系统, 模块, 短标题, 图标)
  Select 组别, Zlmenus_Id.Nextval, ID, '处方审查系统', Null, '药剂师对医生新开的门诊处方或住院药嘱审查的系统。', &n_System, -Null, '处方审查系统', 图标
  From zlMenus
  Where 标题 = '医疗管理系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null;

Insert Into zlMenus(组别,ID,上级ID,标题,快键,说明,系统,模块,短标题,图标) Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* From (
Select 组别,ID From zlMenus Where 标题 = '处方审查系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,(Select 标题,快键,说明,系统,模块,短标题,图标 From zlMenus Where 1 = 0 Union All
  Select '门诊处方审查', Null,'药剂师对门诊医生新开的处方进行审查，只有通过审查才能收费和发药。' ,&n_System,1351,'门诊处方审查' ,232 From Dual Union All
  Select '住院药嘱审查', Null,'药剂师对住院医生新开的药嘱进行审查，只有通过审查才能计费和发药。' ,&n_System,1352,'住院药嘱审查' ,234 From Dual Union All
  Select '处方审查项目', Null,'确定门诊处方和住院药嘱，需要审查哪些项目。' ,&n_System,1353,'处方审查项目' ,193 From Dual Union All
  Select '处方审查条件', Null,'门诊处方审查的处方，按本窗体条件设置提取和开展审查。' ,&n_System,1354,'处方审查条件' ,210 From Dual Union All
  Select '处方审查统计', Null,'可分别以门诊处方和住院药嘱来统计数据，并输出报表。' ,&n_System,1355,'处方审查统计' ,179 From Dual Union All
Select 标题,快键,说明,系统,模块,短标题,图标 From zlMenus Where 1 = 0) B;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明)
Select zlParameters_ID.Nextval,&n_System,-Null,A.* From (
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0 Union All 
  Select 0,0,0,0,241,'处方审查',Null,'0','是否启用处方审查系统功能与流程控制；0-门诊和住院都不启用；1-门诊启用，住院不启用；2-门诊不启用，住院启用；3-门诊和住院都启用' From Dual Union All
  Select 0,0,0,0,242,'门诊审方时机',Null,'1','确定门诊药师审方的介入时机；1-处方发送前；2-药房配发药前' From Dual Union All 
  Select 0,0,0,0,243,'门诊药师离岗时长',Null,'10','门诊药师审方离岗时长（单位分钟），即：超出设定时长值未审查的处方，医师可发送通过，避免病人长时间滞留临床科室或药房。' From Dual Union All
  Select 0,0,0,0,244,'处方审查依据',Null,'1','确定门诊处方/住院药嘱的审查依据什么开展。1-依据《处方点评管理规范》28项；2-依据《处方管理办法》7项' From Dual Union All
  Select 0,0,0,0,245,'提醒门诊医生不合格医嘱',Null,'0','门诊医生开方保存后，是否开启提醒医生有问题的药嘱。0-不提醒；1-提醒' From Dual Union All
  Select 0,0,0,0,246,'提醒住院医生不合格医嘱',Null,'0','住院医生开方保存后，是否开启提醒医生有问题的药嘱。0-不提醒；1-提醒' From Dual Union All
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0) A;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明)
Select zlParameters_ID.Nextval,&n_System,1351,A.* From (
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0 Union All 
  Select 0,1,0,0,1,'自动刷新病人列表','20','20','当病人列表无数据时，是否自动刷新病人列表，减少人为刷新操作。范围10秒-65秒；0表示不自动，20-65表示刷新的秒数间隔。' From Dual Union All
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0) A;

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明)
Select zlParameters_ID.Nextval,&n_System,1352,A.* From (
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0 Union All 
  Select 0,1,0,0,1,'自动刷新病人列表','20','20','当病人列表无数据时，是否自动刷新病人列表，减少人为刷新操作。范围10秒-65秒；0表示不自动，20-65表示刷新的秒数间隔。' From Dual Union All
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0) A;

Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A01', '药品皮试', '规定必须做皮试的药品，处方医师是否注明过敏试验及结果的判定', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A02', '用药与临床诊断的相符性', '处方用药与临床诊断的相符性', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A03', '剂量、用法的正确性', '剂量、用法的正确性', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A04', '剂型与给药途径的合理性', '选用剂型与给药途径的合理性', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A05', '是否有重复给药现象', '是否有重复给药现象', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A06', '药物相互作用和配伍禁忌', '是否有潜在临床意义的药物相互作用和配伍禁忌', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 1, 'A07', '其它用药不适宜情况', '其它用药不适宜情况', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-1', '处方内容缺', '处方的前记、正文、后记内容缺项', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-2', '药师签名签章不一致', '医师签名、签章不规范或者与签名、签章的留样不一致的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-3', '药师未对处方进行适宜性审核的', '药师未对处方进行适宜性审核的（处方后记的审核、调配、核对、发药栏目无审核调配药师及核对发药药师签名，或者单人值班调剂未执行双签名规定）', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-4', '新生儿、婴幼儿未写明日、月龄', '新生儿、婴幼儿处方未写明日、月龄的', 0, 0, 1, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-5', '西药、中成药与中药饮片未分别开具处方', '西药、中成药与中药饮片未分别开具处方的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-6', '未使用药品规范名称开具处方', '未使用药品规范名称开具处方的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-7', '药品书写不规范或不清楚', '药品的剂量、规格、数量、单位等书写不规范或不清楚的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-8', '用法用量使用含糊不清字句', '用法、用量使用“遵医嘱”、“自用”等含糊不清字句的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-9', '处方修改未签名或药品超量未注明原因', '处方修改未签名并注明修改日期，或药品超剂量使用未注明原因和再次签名的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-10', '未写临床诊断或书写不全', '开具处方未写临床诊断或临床诊断书写不全的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-11', '单张门急诊处方超五种药品', '单张门急诊处方超过五种药品的', 0, 0, 0, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-12', '延长处方用量未注明理由', '无特殊情况下，门诊处方超过7日用量，急诊处方超过3日用量，慢性病、老年病或特殊情况下需要适当延长处方用量未注明理由的', 0, 0, 0, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-13', '开具特殊管理药品未执行国家规定', '开具麻醉药品、精神药品、医疗用毒性药品、放射性药品等特殊管理药品处方未执行国家有关规定的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-14', '未按抗菌药物管理开具', '医师未按照抗菌药物临床应用管理规定开具抗菌药物处方的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '1-15', '中药饮片未按“君臣佐使”排列', '中药饮片处方药物未按照“君、臣、佐、使”的顺序排列，或未按要求标注药物调剂、煎煮等特殊要求的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-1', '适应证不适宜', '适应证不适宜的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-2', '遴选的药品不适宜', '遴选的药品不适宜的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-3', '药品剂型或给药途径不适宜', '药品剂型或给药途径不适宜的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-4', '无正当理由不首选国家基本药物', '无正当理由不首选国家基本药物的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-5', '用法、用量不适宜', '用法、用量不适宜的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-6', '联合用药不适宜', '联合用药不适宜的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-7', '重复给药', '重复给药的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-8', '有配伍禁忌或者不良相互作用', '有配伍禁忌或者不良相互作用的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '2-9', '其它用药不适宜', '其它用药不适宜情况的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '3-1', '无适应证用药', '无适应证用药', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '3-2', '无正当理由开具高价药', '无正当理由开具高价药的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '3-3', '无正当理由超说明书用药', '无正当理由超说明书用药的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 2, '3-4', '无正当理由为同一患者开2种以上作用相同药物', '无正当理由为同一患者同时开具2种以上药理作用相同药物的', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 3, 'C01', 'PASS结果', '合理用药监测结果', 0, 0, 2, Null, user, sysdate From Dual;
Insert Into 处方审查项目 (ID,类别,编码,简称,内容,是否门诊启用,是否住院启用,服务对象,PASS结果,操作人,操作时间) Select 处方审查项目_ID.Nextval, 4, 'D01', '中药注射剂两种以上', '中药注射剂两种以上（含两种）', 0, 0, 2, Null, user, sysdate From Dual;


--99036:刘尔旋,2016-08-17,专家号挂号限制
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 263,'专家号挂号限制', '0', '0', '对于存在医生的挂号安排的号别,同一病人挂号的限制数量。0-不限制;N-限制N个号。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '专家号挂号限制');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 264,'专家号预约限制', '0', '0', '对于存在医生的挂号安排的号别,同一病人预约的限制数量。0-不限制;N-限制N个号。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '专家号预约限制');

--68694:刘尔旋,2016-08-17,新挂号安排修改
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('01','手术','SS',0);
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('02','会诊','HZ',0);
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('03','公休','GX',0);
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('04','病假','BJ',0);
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('05','事假','SJ',0);
insert into 常用停诊原因(编码,名称,简码,缺省标志) values ('06','其他','QT',0);

Declare
  n_Count        Number(2);
  n_出诊id       临床出诊表.Id%Type;
  n_是否临时安排 临床出诊安排.是否临时安排%Type;
Begin
  Select Count(1) Into n_Count From 临床出诊表 Where 排班方式 = 0;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份)
    Values
      (临床出诊表_Id.Nextval, 0, '固定出诊表', To_Number(To_Char(Sysdate, 'yyyy')));
  Else
    Update 临床出诊表 Set 出诊表名 = '固定出诊表' Where 排班方式 = 0 And Rownum < 2 Returning ID Into n_出诊id;
    --将多个固定出诊表合并为一个出诊表
    If Nvl(n_Count, 0) > 1 Then
      For c_安排 In (Select a.Id, a.号源id
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.出诊id = b.Id And b.排班方式 = 0 And b.Id <> n_出诊id
                   Order By a.号源id, a.登记时间) Loop
        Begin
          Select 1
          Into n_是否临时安排
          From 临床出诊安排
          Where 出诊id = n_出诊id And 号源id = c_安排.号源id And 是否临时安排 = 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否临时安排 := 0;
        End;
        Update 临床出诊安排 Set 出诊id = n_出诊id, 是否临时安排 = n_是否临时安排 Where ID = c_安排.Id;
      End Loop;
    
      Delete From 临床出诊表 A Where Not Exists (Select 1 From 临床出诊安排 Where 出诊id = a.Id);
    End If;
  End If;
End;
/

--修正临床出诊停诊记录.登记人
Update 临床出诊停诊记录 Set 登记人 = 申请人 Where 登记人 Is Null;

--门诊诊室适用科室升级
Insert Into 门诊诊室适用科室
  (诊室id, 科室id, 缺省标志)
  Select *
  From (Select Distinct q.Id, m.科室id, 0 As 缺省标志
         From (Select Distinct b.科室id, 门诊诊室
                From 挂号安排诊室 A, 挂号安排 B
                Where a.号表id = b.Id
                Union All
                Select Distinct c.科室id, 门诊诊室
                From 挂号计划诊室 A, 挂号安排计划 B, 挂号安排 C
                Where a.计划id = b.Id And b.安排id = c.Id) M, 门诊诊室 Q
         Where m.门诊诊室 = q.名称);

Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 1114,'临床出诊安排','对本单位临床科室的出诊安排进行管理。',&n_System,'zl9RegEvent'); 

Insert Into zlPrograms(序号,标题,说明,系统,部件) Values( 1115,'患者服务中心','因停诊、替诊或复诊原估，客服人员通过电话通知病人以及对病人的预约信息进行退号、换诊及替诊等操作',&n_System,'zl9RegEvent'); 

Insert Into zlMenus(组别,ID,上级ID,标题,快键,说明,系统,模块,短标题,图标) Select A.组别,ZlMenus_ID.Nextval,A.ID,B.* 
From (
	Select 组别,ID From zlMenus Where 标题 = '门急诊挂号系统' And 组别 = '缺省' And 系统 = &n_System And 模块 Is Null) A,
	(	Select 标题,快键,说明,系统,模块,短标题,图标 From zlMenus Where 1 = 0 Union All
		Select '临床出诊安排' ,'A' ,'对本单位临床科室的出诊安排进行管理。' ,&n_System,1114,'出诊安排' ,236 From Dual Union All
		Select '患者服务中心' ,'B' ,'实现预约挂号登记,取消预约，换诊，替诊的操作权限。有该权限时，允许操作员进行预约登记,取消预约，换诊或替诊操作。' ,&n_System,1115,'服务中心' ,220 From Dual Union All
		Select 标题,快键,说明,系统,模块,短标题,图标 From zlMenus Where 1 = 0
          ) B;

--参数相关处理
Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明)
Select zlParameters_ID.Nextval,&n_System,-Null,-Null,-Null,-Null,-Null,A.* From (
Select 参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0 Union All 
     Select 256,'挂号排班模式','0','0','影响挂号（窗口，三方平台，自助等）的取数规则:0-计划排班模式,1-出诊表排班模式;在医院启用HIS系统后,一般不调整此参数,如果调整此参数,将会直接影响到挂号业务(窗口，三方平台，自助系统等)'
     From Dual Union All 
Select 参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0) A;

--参数脚本
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, -null, 1, 1,'显示停用号源', '0', '0', '查看临床出诊号源时是否显示已停用号源。0-不显示，1-显示。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '显示停用号源');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, -null, -null, 1, 1, 2,'只允许选院内医生', '0', '0', '进行号源设置时，选择的医生是否只能选择院内的医生。1-仅院内医生;0-允许选择外援医院或院内医生。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '只允许选院内医生');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, 0, 0, 3,'预约清单控制方式', '0', '0', '停诊时是否将预约清单输出到Excel中。0-不输出到Excel，1-自动输出到Excel,2-选择输出到Excel。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '预约清单控制方式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, 0, 0, 4,'预约清单打印方式', '0', '0', '0-不打印,1-自动打印,2-选择是否打印。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '预约清单打印方式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, 0, 0, 5,'出诊表打印方式', '0', '0', '0-不打印,1-自动打印,2-选择是否打印。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '出诊表打印方式');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, -null, -null, 0, 1, 6,'按替诊医生同步更新预约挂号单', '0', '0', '在替诊时，将根据替诊医生同步更新所有涉及替诊的预约挂号单。1-替诊同步更新,0-不更新。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '按替诊医生同步更新预约挂号单');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, -null, 1, 7,'显示缺省控制信息', '0', '1','在号源管理中控制在选择号源时，是否在下方显示控制的相关信息，比如：缺省的序号信息、诊室信息、三方预约控制信息等。0-不显示，1-显示。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '显示缺省控制信息');

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, -null, -null, 0, 1, 8,'替诊医生级别检查', '0', '1', '在替诊时是否检查替诊医生的级别。1-检查，则根据用户自定义函数Zl1_Ex_Isdoctorsamelevel()进行检查，缺省替诊医生的级别必须大于等于原医生的级别；0-不检查。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '替诊医生级别检查');
  
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 1, -null, -null, 1, 9,'显示无效临时安排', '0', '0', '查看固定安排规则时是否显示已失效的临时安排。0-不显示，1-显示。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1114 And 参数名 = '显示无效临时安排');
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1115, 0, 0, 0, 0, 1, '刷新方式', '0',
         '0', '消息的自动刷新策略,0-不刷新;1-自动刷新'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '刷新方式' And Nvl(模块, 0) = 1115 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1115, 0, 0, 0, 0, 2, '缺省预约方式', Null,
         Null, '预约时默认选择的预约方式'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '缺省预约方式' And Nvl(模块, 0) = 1115 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 65, '缺省预约方式', Null,
         Null, '预约时默认选择的预约方式'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '缺省预约方式' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 0, 0, 0, 0, 31, '缺省预约方式', Null,
         Null, '预约时默认选择的预约方式'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '缺省预约方式' And Nvl(模块, 0) = 1260 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1115, 0, 0, 0, 0, 3, '预约挂号单打印方式', Null,
         Null, '预约挂号单打印方式'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '预约挂号单打印方式' And Nvl(模块, 0) = 1115 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 68, '病人同科限挂N个号', '0',
         '0', '控制一个病人同一天在一科室中,只能挂N个号,0-不限制;N-限制数量'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '病人同科限挂N个号' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 69, '病人挂号科室限制', '0',
         '0', '同一病人在同一时间能否挂多个科室,0-不限制,>=1表示科室限制的数量'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '病人挂号科室限制' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);	

Update zlParameters
Set 参数名 = '病人同科限约N个号', 参数说明 = '在预约时,同一病人在同一时间及同一科室的数量限制,0-不限制;N-限制预约数量'
Where 参数名 = '病人同科限约一个号' And 模块 = 1111 And 系统 = &n_System And Not Exists
 (Select 1
       From zlParameters
       Where 参数名 = '病人同科限约N个号' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 39, '挂号时选择时间', '1',
         '1', '自助挂号挂专家号分时段的号别时，是否提供时段选择界面让用户选择挂号时间，0-不启用；1-启用。'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '挂号时选择时间' And Nvl(模块, 0) = 1802 And Nvl(系统, 0) = &n_System);
         
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 39, '预约时选择时间', '1',
         '1', '自助预约挂分时段的号别时，是否提供时段选择界面让用户选择预约时间,0-不启用；1-启用。'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '预约时选择时间' And Nvl(模块, 0) = 1803 And Nvl(系统, 0) = &n_System);

Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1539, 0, 0, 0, 0, 1,'自助挂号类别对照', Null,'普通|11009198|11009198|0||特诊|11009199|11009199|0||专家|11009200|11009200|0||专科|11009201|11009201|0||急诊|11009225|11009225|0', 
         '控制自助挂号在号类选择页面的各号类及号类的图标设置.'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1539 And 参数名 = '自助挂号类别对照');

Insert Into Zlprocedure
  (ID, 类型, 名称, 状态, 所有者, 说明)
  Select Zlprocedure_Id.Nextval, 2, 'Zl1_Ex_Isdoctorsamelevel', 3, User, '比较两个医生的职务大小' From Dual;
  
Insert Into zlAutoJobs
  (系统, 类型, 序号, 名称, 说明, 内容, 参数, 执行时间, 间隔时间)
  Select &n_System, 1, 11, '出诊记录自动生成', '按固定时间完成对挂号固定安排出诊记录自动生成。', 'Zl1_Auto_BuildingRegisterPlan', Null,
         Trunc(Sysdate) + 1 / 24, 1
  From Dual
  Where Not Exists (Select 1 From zlAutoJobs Where 系统 = &n_System And 类型 = 1 And 序号 = 11);

Insert Into zlBaseCode
  (系统, 表名, 固定, 说明, 分类)
Values
  (&n_System, '常用停诊原因', 0, '临床出诊安排的常用停诊原因。', '医疗工作');

--99389:刘尔旋,2016-08-09,部分审核记账单医嘱发送计费状态问题,历史数据修正
--问题简述:修正病人医嘱发送表中计费状态与费用状态不对应的问题
--使用范围:10.34版本之后针对病人医嘱发送计费状态的修正
--修正内容及方法:根据医嘱对应的费用记录的状态,反算出病人医嘱发送的计费状态
--修正的数据范围:病人医嘱发送的所有记录
Declare
  n_Count Number(18);
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
  n_Status  Number(18);
  v_Temp    Varchar2(4000);

  Procedure 计费状态_Update
  (
    场合_In         Integer := 0, --0:门诊;1-住院
    性质_In         Integer := 1, --1-收费单;2-记帐单
    No_In           门诊费用记录.No%Type,
    组医嘱id_In     病人医嘱记录.Id%Type,
    检查手术医嘱_In Number := 0
  ) As
    l_医嘱id   t_Numlist := t_Numlist();
    l_计费状态 t_Numlist := t_Numlist();
    n_Havedata Number(2);
    v_状态     Varchar2(200);
  Begin
  
    If 场合_In = 0 Then
      --门诊部分
      ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      n_Status   := 0; --0-表示不存在部分退;1-表示全部退,2-表示全退
      n_Havedata := 0;
      v_Temp     := Null;
      v_状态     := Null;
      For c_医嘱 In (Select 医嘱序号 As 医嘱id, Min(Min_记录状态) As Min_记录状态, Max(Max_记录状态) As Max_记录状态,
                          Max(Case
                                When 剩余数量 = 原始数量 And 原始数量 <> 0 Then --0：表示未退
                                 0
                                When 剩余数量 = 0 Then --2-表示全退
                                 2
                                Else
                                 3 --3--表示部分退
                              End) As 状态
                   From (Select 序号, 医嘱序号, Min(记录状态) As Min_记录状态, Max(记录状态) As Max_记录状态,
                                 Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量,
                                 Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0, 1, 0) * Decode(记录性质, 11, 0, 1) *
                                          Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                          From 门诊费用记录
                          Where Decode(性质_In, 2, 记录性质, Mod(记录性质, 10)) = 性质_In And NO = No_In And 价格父号 Is Null And
                                Nvl(附加标志, 0) <> 9 And
                                医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = 组医嘱id_In Or 相关id = 组医嘱id_In)
                          Group By 序号, 医嘱序号)
                   Group By 医嘱序号) Loop
      
        If Instr(Nvl(v_Temp, '') || ',', ',' || Nvl(c_医嘱.Min_记录状态, -1) || ',') = 0 Then
          v_Temp := Nvl(v_Temp, '') || ',' || Nvl(c_医嘱.Min_记录状态, -1);
        End If;
        If Instr(Nvl(v_Temp, '') || ',', ',' || Nvl(c_医嘱.Max_记录状态, -1) || ',') = 0 Then
          v_Temp := Nvl(v_Temp, '') || ',' || Nvl(c_医嘱.Max_记录状态, -1);
        End If;
      
        If Nvl(c_医嘱.状态, 0) = 2 And Nvl(n_Status, 0) = 0 Then
          --全退
          n_Status := 1;
        End If;
        If Nvl(c_医嘱.状态, 0) = 3 Then
          --部分收
          n_Status := 2;
        End If;
        If Instr(Nvl(v_状态, '') || ',', ',' || Nvl(c_医嘱.状态, 0) || ',') = 0 Then
          If v_状态 Is Not Null Then
            n_Status := 2;
          End If;
          v_状态 := Nvl(v_状态, '') || ',' || Nvl(c_医嘱.状态, 0);
        End If;
        If Nvl(c_医嘱.状态, 0) <> 0 Then
          l_医嘱id.Extend;
          l_医嘱id(l_医嘱id.Count) := c_医嘱.医嘱id;
          l_计费状态.Extend;
          l_计费状态(l_计费状态.Count) := Case
                                    When Nvl(c_医嘱.状态, 0) = 2 Then
                                     4
                                    Else
                                     2
                                  End;
        End If;
        n_Havedata := 1;
      End Loop;
    
    Else
      ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      n_Havedata := 0;
      n_Status   := 0;
      v_Temp     := Null;
      For c_医嘱 In (Select 医嘱序号 As 医嘱id, Min(Min_记录状态) As Min_记录状态, Max(Max_记录状态) As Max_记录状态,
                          Max(Case
                                When 剩余数量 = 原始数量 And 原始数量 <> 0 Then --0：表示未退
                                 0
                                When 剩余数量 = 0 Then --2-表示全退
                                 2
                                Else
                                 3 --3--表示部分退
                              End) As 状态
                   From (Select 序号, 医嘱序号, Sum(Nvl(Nvl(付数, 1) * 数次, 0)) As 剩余数量, Min(记录状态) As Min_记录状态,
                                 Max(记录状态) As Max_记录状态,
                                 Nvl(Sum(Decode(记录状态, 1, 1, 3, 1, 0, 1, 0) * Nvl(Nvl(付数, 1) * 数次, 0)), 0) As 原始数量
                          From 住院费用记录
                          Where 记录性质 = 性质_In And NO = No_In And 价格父号 Is Null And Nvl(附加标志, 0) <> 9 And
                                医嘱序号 + 0 In
                                (Select ID From 病人医嘱记录 Where ID = 组医嘱id_In Or 相关id = Nvl(组医嘱id_In, 0))
                          Group By 序号, 医嘱序号)
                   Group By 医嘱序号) Loop
      
        If Instr(Nvl(v_Temp, '') || ',', ',' || Nvl(c_医嘱.Min_记录状态, -1) || ',') = 0 Then
          v_Temp := Nvl(v_Temp, '') || ',' || Nvl(c_医嘱.Min_记录状态, -1);
        End If;
        If Instr(Nvl(v_Temp, '') || ',', ',' || Nvl(c_医嘱.Max_记录状态, -1) || ',') = 0 Then
          v_Temp := Nvl(v_Temp, '') || ',' || Nvl(c_医嘱.Max_记录状态, -1);
        End If;
      
        If Nvl(c_医嘱.状态, 0) = 2 And Nvl(n_Status, 0) = 0 Then
          --全退
          n_Status := 1;
        End If;
        If Nvl(c_医嘱.状态, 0) = 3 Then
          --部分退
          n_Status := 2;
        End If;
        If Nvl(c_医嘱.状态, 0) <> 0 Then
          l_医嘱id.Extend;
          l_医嘱id(l_医嘱id.Count) := c_医嘱.医嘱id;
          l_计费状态.Extend;
          l_计费状态(l_计费状态.Count) := Case
                                    When Nvl(c_医嘱.状态, 0) = 2 Then
                                     4
                                    Else
                                     2
                                  End;
        End If;
        n_Havedata := 1;
      End Loop;
    
    End If;
  
    If Nvl(n_Havedata, 0) <> 0 And Nvl(检查手术医嘱_In, 0) = 1 And Nvl(组医嘱id_In, 0) <> 0 Then
      If Instr(v_Temp || ',', ',0,') > 0 And
         (Instr(v_Temp || ',', ',1,') > 0 Or Instr(v_Temp || ',', ',2,') > 0 Or Instr(v_Temp || ',', ',3,') > 0) Then
        If n_Status = 1 Then
          --全退
          n_Status := 0;
        Else
          n_Status := 2;
        End If;
      End If;
      l_医嘱id.Extend;
      l_医嘱id(l_医嘱id.Count) := 组医嘱id_In;
      l_计费状态.Extend;
      l_计费状态(l_计费状态.Count) := Case
                                When Nvl(n_Status, 0) = 2 Then
                                 2
                                When Nvl(n_Status, 0) = 0 And Nvl(性质_In, 0) = 1 Then
                                 3
                                When Nvl(n_Status, 0) = 0 And Nvl(性质_In, 0) <> 1 Then
                                 1
                                Else
                                 4
                              End;
    
    End If;
  
    Forall I In 1 .. l_医嘱id.Count
      Update 病人医嘱发送 A
      Set a.计费状态 = l_计费状态(I)
      Where 医嘱id = l_医嘱id(I) And 记录性质 = 性质_In And NO = No_In And Nvl(a.计费状态, 0) <> l_计费状态(I);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 计费状态_Update;

Begin

  Update Zlupgradeconfig Set 内容 = Null Where 项目 = User || '_病人医嘱发送计费状态_20160802_1';
  If Sql%NotFound Then
    Insert Into Zlupgradeconfig (项目, 内容) Values (User || '_病人医嘱发送计费状态_20160802_1', Null);
  End If;

  n_Count := 0;
  For c_医嘱发送 In (
                 --1-门诊;2-住院;3-外来(今后用于辅诊部门接收外来病人);4-体检病人
                 Select /*+ rule*/
                  a.No, a.记录性质, a.门诊记帐, Max(Nvl(b.记录状态, -1)) As 记录状态, Min(Nvl(b.记录状态, -1)) As Min_记录状态, a.组医嘱id As 组医嘱id,
                   Max(Decode(Nvl(c.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱
                 From (Select Distinct c.记录性质, c.No, a.病人来源, c.门诊记帐, Nvl(a.相关id, a.Id) As 组医嘱id
                         From 病人医嘱记录 A, 病人医嘱发送 C
                         Where a.开嘱时间 >= Trunc(Sysdate) - 12 And (c.记录性质 = 1 Or Nvl(c.门诊记帐, 0) = 1) And a.Id = c.医嘱id And
                               (c.记录性质 = 1 Or Nvl(c.门诊记帐, 0) = 1)) A, 门诊费用记录 B, 病人医嘱记录 C
                 Where a.记录性质 = b.记录性质(+) And a.No = b.No(+) And a.组医嘱id = c.Id(+)
                 Group By a.No, a.记录性质, a.门诊记帐, a.组医嘱id
                 Union All
                 Select a.No, a.记录性质, a.门诊记帐, Max(Nvl(b.记录状态, -1)) As 记录状态, Min(Nvl(b.记录状态, -1)) As Min_记录状态,
                        a.组医嘱id As 组医嘱id, Max(Decode(Nvl(c.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱
                 From (Select Distinct c.记录性质, c.No, a.病人来源, c.门诊记帐, Nvl(a.相关id, a.Id) As 组医嘱id
                        From 病人医嘱记录 A, 病人医嘱发送 C,
                             (Select A1.病人id, A1.主页id
                               From 病案主页 A1, 病人信息 C1
                               Where A1.病人id = C1.病人id And A1.主页id = C1.主页id And C1.在院 = 1
                               Union All
                               Select A1.病人id, A1.主页id From 病案主页 A1 Where A1.出院日期 >= Trunc(Sysdate) - 6) B
                        Where a.病人id = b.病人id And a.主页id = b.主页id And a.Id = c.医嘱id And a.病人来源 = 2 And
                              (c.记录性质 = 2 And Nvl(c.门诊记帐, 0) <> 1)) A, 住院费用记录 B, 病人医嘱记录 C
                 Where a.记录性质 = b.记录性质(+) And a.No = b.No(+) And a.组医嘱id = c.Id(+) 
                 Group By a.No, a.记录性质, a.门诊记帐, a.组医嘱id) Loop
  
    --1.-删除了对应的划价单的，计费状态调整为0
    If Nvl(c_医嘱发送.记录状态, 0) = -1 Then
      Update 病人医嘱发送
      Set 计费状态 = 0
      Where 记录性质 = c_医嘱发送.记录性质 And NO = c_医嘱发送.No And Nvl(计费状态, 0) <> 0;
    End If;
  
    --2.收费或记帐处理
    If Nvl(c_医嘱发送.记录状态, 0) = 1 And Nvl(c_医嘱发送.检查手术医嘱, 0) = 1 And Nvl(c_医嘱发送.组医嘱id, 0) <> 0 Then
      --只有检查，手术医嘱才更新主医嘱的计费状态,其他部分，目前是正确的，不用修正
      ----1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分收费/退费(记帐/销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
      n_Status := Case
                    When Nvl(c_医嘱发送.Min_记录状态, -1) = 0 Then
                     2
                    When Nvl(c_医嘱发送.记录性质, 0) = 2 Then
                     1
                    Else
                     3
                  End;
      Update 病人医嘱发送
      Set 计费状态 = n_Status
      Where NO = c_医嘱发送.No And 记录性质 = c_医嘱发送.记录性质 And 医嘱id = c_医嘱发送.组医嘱id And Nvl(计费状态, 0) <> n_Status;
    End If;
  
    --3.存在销帐或退费的，需要区分部分退或全退
    If Nvl(c_医嘱发送.记录状态, 0) > 1 Then
      --需要分两种情况处理
      --   a.一张单据中存在多组医嘱，但可能这组一组不存在退费
      --   b.一张单据只有一级医嘱
    
      --计费状态_Update:
      --场合_In Integer := 0, --0:门诊;1-住院
      --性质_In Integer := 1 --1-收费单;2-记帐单
      --No_In   门诊费用记录.No%Type,
      --组医嘱ID_In 病人医嘱记录.ID%type,
      --检查手术医嘱_IN number:=0
      If Nvl(c_医嘱发送.记录性质, 0) = 1 Then
        计费状态_Update(0, 1, c_医嘱发送.No, Nvl(c_医嘱发送.组医嘱id, 0), Nvl(c_医嘱发送.检查手术医嘱, 0));
      Elsif Nvl(c_医嘱发送.门诊记帐, 0) = 1 Then
        计费状态_Update(0, 2, c_医嘱发送.No, Nvl(c_医嘱发送.组医嘱id, 0), Nvl(c_医嘱发送.检查手术医嘱, 0));
      Else
        计费状态_Update(1, 2, c_医嘱发送.No, Nvl(c_医嘱发送.组医嘱id, 0), Nvl(c_医嘱发送.检查手术医嘱, 0));
      End If;
    End If;
  
    n_Count := n_Count + 1;
    If n_Count > 10000 Then
      Update Zlupgradeconfig
      Set 内容 = To_Number(Nvl(内容, '0')) + n_Count
      Where 项目 = User || '_病人医嘱发送计费状态_20160802_1';
      Commit;
      n_Count := 0;
    End If;
  End Loop;
  Commit;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End;
/



--91721:刘尔旋,2016-07-15,自动记账更改,处理7天内的历史数据
Declare
  n_Exists   Number;
  n_费用余额 病人余额.费用余额%Type;
Begin
  For r_病案 In (Select 病人id, 主页id From 病案主页 Where 病人性质 = 0 And 出院日期 Between Sysdate - 7 And Sysdate) Loop
    Begin
      Select 1
      Into n_Exists
      From 病人结帐记录 A, 住院费用记录 B
      Where A.病人id = r_病案.病人id And a.Id = b.结帐id And b.主页id = r_病案.主页id And Nvl(中途结帐, 0) = 0 And 结帐类型 = 2;
    Exception
      When Others Then
        n_Exists := 0;
    End;
    If n_Exists = 1 Then
      Begin
        Select 费用余额 Into n_费用余额 From 病人余额 Where 病人id = r_病案.病人id And 类型 = 2;
      Exception
        When Others Then
          n_费用余额 := 0;
      End;
      If n_费用余额 = 0 Then
        Update 病案主页 Set 是否禁止自动记帐 = 1 Where 病人id = r_病案.病人id And 主页id = r_病案.主页id And 病人性质 = 0;
      End If;
    End If;
  End Loop;
End;
/

--99348:李南春,2016-08-12,自助增加挂号生成划价单和预约不收费用功能
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 43, '挂号生成划价单', '0',
         '0', '自助挂号保存为划价单'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '挂号生成划价单' And Nvl(模块, 0) = 1802 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 43, '收费预约', '1',
         '1', '自助预约立即收取挂号费用'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '收费预约' And Nvl(模块, 0) = 1803 And Nvl(系统, 0) = &n_System);

--91456:胡俊勇，2016-08-11，临床消息语单提示
--门诊医生站
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 1, 0, 0, 33, '启用语音提示', Null, '1', 
  '门诊医生站消息列表中的消息是否启用语音提醒；0－不启用，1－启用。只有能在消息列表中显示出来的消息才会被播报。'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '启用语音提示' And 模块=1260 And Nvl(系统,0) = &n_System); 
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 1, 0, 0, 34, '危机值消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有危机值消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '危机值消息语音配置' And 模块=1260 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 1, 0, 0, 36, '处方审查消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有处方审查消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '处方审查消息语音配置' And 模块=1260 And Nvl(系统,0) = &n_System);  
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1260, 1, 1, 0, 0, 37, '传染病消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有传染病消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '传染病消息语音配置' And 模块=1260 And Nvl(系统,0) = &n_System);

--住院医生站
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 42, '启用语音提示', Null, '1', 
  '住院医生站消息列表中的消息是否启用语音提醒；0－不启用，1－启用。只有能在消息列表中显示出来的消息才会被播报。'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '启用语音提示' And 模块=1261 And Nvl(系统,0) = &n_System);  
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 43, '病历审阅消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有病历审阅消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '病历审阅消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 44, '安排消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有安排消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '安排消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 45, '危机值消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有危机值消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '危机值消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 46, '报告撤消消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有报告撤消消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '报告撤消消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 47, '医嘱审核消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有医嘱审核消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '医嘱审核消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 48, '处方审查消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有处方审查消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '处方审查消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);  
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1261, 1, 1, 0, 0, 49, '传染病消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有传染病消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '传染病消息语音配置' And 模块=1261 And Nvl(系统,0) = &n_System);
  
--住院护士站
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 19, '启用语音提示', Null, '1', 
  '住院护士站消息列表中的消息是否启用语音提醒；0－不启用，1－启用。只有能在消息列表中显示出来的消息才会被播报。'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '启用语音提示' And 模块=1262 And Nvl(系统,0) = &n_System);  
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 20, '新开消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有新开消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '新开消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 21, '新停消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有新停消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '新停消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 22, '新废消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有新废消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '新废消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 23, '安排消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有安排消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '安排消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 24, '危机值消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有危机值消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '危机值消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 25, '输液拒绝消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有输液拒绝消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '输液拒绝消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1262, 1, 1, 0, 0, 26, '销帐申请消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有销帐申请消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '销帐申请消息语音配置' And 模块=1262 And Nvl(系统,0) = &n_System);
  
--医技工作站
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1263, 1, 1, 0, 0, 25, '启用语音提示', Null, '1', 
  '医技工作站消息列表中的消息是否启用语音提醒；0－不启用，1－启用。只有能在消息列表中显示出来的消息才会被播报。'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '启用语音提示' And 模块=1263 And Nvl(系统,0) = &n_System);  
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1263, 1, 1, 0, 0, 26, '销帐申请消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有销帐申请消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '销帐申请消息语音配置' And 模块=1263 And Nvl(系统,0) = &n_System);
Insert Into zlParameters(ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1263, 1, 1, 0, 0, 27, '待安排消息语音配置', Null, '1<sTab>0<sTab>iif([床号]<>"",[床号],"家庭床")+"有待安排消息。"<sTab>2',
          '固定格式依次为：状态<sTab>提示方式<sTab>内容<sTab>播放次数。状态0/1是否启用，提示方式0/1 0读文本，1wav音频,内容－文本或音频文件，播放次数'
  From Dual  Where Not Exists(Select 1 From zlParameters Where 参数名 = '待安排消息语音配置' And 模块=1263 And Nvl(系统,0) = &n_System);  

--92530:刘尔旋,2016-08-10,挂号限制
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 68, '病人同科限挂N个号', '0',
         '0', '控制一个病人同一天在一科室中,只能挂N个号,0-不限制;N-限制数量'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '病人同科限挂N个号' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 69, '病人挂号科室限制', '0',
         '0', '同一病人在同一时间能否挂多个科室,0-不限制,>=1表示科室限制的数量'
  From Dual
  Where Not Exists
   (Select 1
         From zlParameters
         Where 参数名 = '病人挂号科室限制' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);	

Update zlParameters
Set 参数名 = '病人同科限约N个号', 参数说明 = '在预约时,同一病人在同一时间及同一科室的数量限制,0-不限制;N-限制预约数量'
Where 参数名 = '病人同科限约一个号' And 模块 = 1111 And 系统 = &n_System And Not Exists
 (Select 1
       From zlParameters
       Where 参数名 = '病人同科限约N个号' And Nvl(模块, 0) = 1111 And Nvl(系统, 0) = &n_System);

--82428:刘尔旋,2016-08-08,病人信息职业字段历史数据修正
--问题简述:修正病人信息职业字段中含有chr(30)字符,导致医生站提取病人信息无法正确读取职业的问题
--使用范围:所有HIS版本涉及病人信息的都需要进行修正
--修正内容及方法:去掉病人信息表中职业字段中的chr(30)字符
--修正的数据范围:病人信息所有记录
Update 病人信息
Set 职业 = Replace(职业, Chr(30), Null)
Where 病人id In (Select 病人id From 病人信息 Where Instr(职业, Chr(30)) > 0);

--86251:梁经伙,2016-08-02,门诊首页、住院首页、电子病案查阅身份证号码的第13、14位是用掩码显示
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 247, '身份证加密显示', Null, '0',
         '门诊首页、住院首页、电子病案查阅身份证号码的第13、14位是用掩码显示。0-不用掩码；1-使用掩码'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And Nvl(模块, 0) = 0 And 参数名 = '身份证加密显示');

--89300:陈刘,2016-07-26,再次手术停止前次标注参数意义调整
Update zlParameters
Set 参数说明 = '1.在前次手术的标记天数内再次进行手术，将根据此参数值决定是否需要从本次手术后(含)终止上次手术剩余的天数标记,以及是以本次手术天数作为分母,还是以上次手术天数作为分母。' || Chr(13) || 
              '当参数值为0时:若在手术天内进行第2次手术，则将第1次手术天数作为分母，第2次手术天数作为分子填写，依次类推。'|| Chr(13) || 
              '当参数值为1时：若在手术天内进行第2次手术，则第1次手术天数标注从第2次手术前终止。'|| Chr(13) || 
              '当参数值为2时：若在手术天内进行第2次手术，则将第2次手术天数作为分母，第1次手术天数作为分子填写，依次类推。' || Chr(13) ||
              '2.手术的标记天数受"护理记录管理"中模块参数"手术后标注天数"。'
Where 系统 = &n_System And 模块 = 1255 And 参数名 = '再次手术停止前次标注';

--98352:梁经伙,2016-07-13,首页中不随诊时数据库中随诊标志填为Null，而不是0
update 病案主页 set  随诊标志 = NULL, 随诊期限 = NULL where 随诊标志 = 0;

--98323:蔡青松,2016-07-07,给参数采集工作站过滤添加缺省值
update zlParameters set 缺省值=';;;;所有标本;0;1;2;4;3;0;;;' where 参数名='采集工作站过滤' and 系统=&n_System and 模块=1211;

--95554:余智勇,2016-07-06,药房自助签到
Insert Into zlPrograms (序号,标题,说明,系统,部件) Values (1810,'门诊药房自助签到','病人在门诊药房自助签到',&n_System,'zl9WizardPharmacy');

Insert Into zlParameters(ID,系统,模块,私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明)
Select zlParameters_ID.Nextval,&n_System,1810,A.* From (
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0 Union All 
    Select 0,0,0,0,1,'是否身份识别',NULL,'0','门诊病人在门诊发药是否需要确认签到信息的类别后，再进行签到操作。0-不进入身份识别页面，以固定身份识别；1-要进入身份识别页面，为病人确定' From Dual Union All
    Select 0,1,0,0,2,'固定身份识别',NULL,NULL,'门诊病人在门诊发药不需要确认签到信息的类别时，进行固定身份识别签到。签到的固定身份，并且只能设置一种' From Dual Union All
    Select 0,1,0,0,3,'身份识别设置',NULL,NULL,'主要控制病人在药房签到时，本自助机的身份识别有哪些类别。'||CHR(13)||'根据卡类型的不同有三种识别方式:'||CHR(13)||'一是刷卡:从刷卡槽划过自动读卡'||CHR(13)||'二是接触式读卡:需要将卡插入读卡口，点击确认进行读卡'||CHR(13)||'三是非接触式读卡：将卡放在扫描器下方就能自动读卡' From Dual Union All 
    Select 0,0,0,0,4,'身份识别图标对照',NULL,NULL,'主要控制病人在药房签到时的身份识别方式页面中的识别方式的显示图像(包含按下和显示的图像控制)' From Dual Union All 
    Select 0,1,0,0,5,'自动返回时间',NULL,'0','主要是控制在签到的任何界面中无任何操作时，自动返回到首页的秒数。秒作单位。0表示无自动返回控制。' From Dual Union All
    Select 0,1,0,0,6,'所属药房',NULL,NULL,'主要是确认自助机终端病人签到的药房。自助机终端所属的药房ID。' From Dual Union All
Select 私有,本机,授权,固定,参数号,参数名,参数值,缺省值,参数说明 From zlParameters Where 1 = 0) A;


--73873:刘尔旋,2016-07-06,记帐报警划价费用的计算
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1150, 0, 0, 0, 0, 42, '记帐报警包含所有住院划价费用', Null, '1',
         '记帐报警时,住院记帐是否仅计算本次住院的划价费用:0-记帐报警时仅计算本次住院划价的费用 1-记帐报警时计算所有住院划价的费用'
  From Dual
  Where Not Exists
   (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1150 And 参数名 = '记帐报警包含所有住院划价费用');

--95774:许华峰,2016-07-05,影像病理站费用执行模式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 0, 0, 0, 109, '病理费用执行模式', Null, Null,'控制费用的执行时机，取值为报到时执行，检查时执行，报告时执行。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1294 And 参数名 = '病理费用执行模式');

--95774:许华峰,2016-06-23,影像医技站费用执行模式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 0, 0, 0, 0, 52, '医技费用执行模式', Null, Null,'控制费用的执行时机，取值为报到时执行，报告时执行。'
  From Dual
  Where Not Exists (Select 1 From zlParameters Where 系统 = &n_System And 模块 = 1290 And 参数名 = '医技费用执行模式');

--97655:李业庆,2016-06-21,卫材填单下可用库存参数值为1时按批次领用卫生材料参数值也应该为1
Update zlParameters
Set 参数值 = 1
Where 系统 = &n_System And 模块 Is Null And 参数号 = 258 And Nvl(参数值, 0) = 0 And Exists
 (Select 1 From zlParameters Where 系统 = &n_System And 模块 Is Null And 参数号 = 95 And Nvl(参数值, 0) = 1);

--94713:李业庆,2016-11-30,药品处方发药增加“查找时系统自动回车方式”
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1341, 0, 1, 0, 0, 60, '查找时系统自动回车方式', Null, '0', '通过录入扫描刷卡等方式查找时系统自动添加回车处理的方式，0-系统不自动回车,1-当录入达到项目或卡号长度时自动回车'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1341 And 参数名 = '查找时系统自动回车方式');

--92798:余伟节,2016-08-11,路径医嘱审核
Update 路径医嘱变动 Set 审核人 = 操作员 , 审核时间 =操作时间,审核状态=1  Where 审核时间 Is Null;


--100994:张永康,2016-09-21,玉溪医院历史数据转出测试集中修改
Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '病人卡结算对照','病人卡结算对照_PK' From Dual Union All
Select '病人卡结算记录','病人卡结算记录_PK' From Dual Union All
Select '三方结算交易','三方结算交易_PK' From Dual Union All
Select '门诊费用记录','门诊费用记录_IX_发生时间' From Dual Union All
Select '门诊费用记录','门诊费用记录_IX_结帐ID' From Dual Union All
Select '门诊费用记录','门诊费用记录_IX_医嘱序号' From Dual Union All
Select '门诊费用记录','门诊费用记录_UQ_NO' From Dual Union All
Select '住院费用记录','住院费用记录_IX_病人ID' From Dual Union All
Select '住院费用记录','住院费用记录_IX_发生时间' From Dual Union All
Select '住院费用记录','住院费用记录_IX_结帐ID' From Dual Union All
Select '住院费用记录','住院费用记录_UQ_NO' From Dual Union All
Select '病人结帐记录','病人结帐记录_IX_病人id' From Dual Union All
Select '病人结帐记录','病人结帐记录_IX_收费时间' From Dual Union All
Select '病人结帐记录','病人结帐记录_PK' From Dual Union All
Select '病人结帐记录','病人结帐记录_UQ_NO' From Dual Union All
Select '三方退款信息','三方退款信息_PK' From Dual Union All
Select '病人预交记录','病人预交记录_IX_结帐ID' From Dual Union All
Select '病人预交记录','病人预交记录_IX_收款时间' From Dual Union All
Select '病人预交记录','病人预交记录_UQ_NO' From Dual Union All
Select '费用补充记录','费用补充记录_IX_登记时间' From Dual Union All
Select '费用补充记录','费用补充记录_IX_结算ID' From Dual Union All
Select '费用补充记录','费用补充记录_PK' From Dual Union All
Select '医保结算明细','医保结算明细_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '收发记录补充信息','收发记录补充信息_IX_收发ID' From Dual Union All
Select '输液配药记录','输液配药记录_PK' From Dual Union All
Select '输液配药内容','输液配药内容_IX_收发ID' From Dual Union All
Select '药品留存计划','药品留存计划_IX_留存ID' From Dual Union All
Select '药品签名明细','药品签名明细_IX_收发ID' From Dual Union All
Select '药品签名记录','药品签名记录_PK' From Dual Union All
Select '药品收发门诊标志','药品收发门诊标志_PK' From Dual Union All
Select '药品收发住院标志','药品收发住院标志_PK' From Dual Union All
Select '药品收发记录','药品收发记录_IX_费用ID' From Dual Union All
Select '处方审查明细','处方审查明细_IX_医嘱ID' From Dual Union All
Select '处方审查结果','处方审查结果_UQ_审方ID' From Dual Union All
Select '处方审查记录','处方审查记录_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '人员收缴明细','人员收缴明细_PK' From Dual Union All
Select '人员收缴对照','人员收缴对照_PK' From Dual Union All
Select '人员收缴票据','人员收缴票据_PK' From Dual Union All
Select '人员收缴记录','人员收缴记录_IX_登记时间' From Dual Union All
Select '人员收缴记录','人员收缴记录_PK' From Dual Union All
Select '人员借款记录','人员借款记录_IX_借出时间' From Dual Union All
Select '票据打印明细','票据打印明细_IX_使用ID' From Dual Union All
Select '票据使用明细','票据使用明细_IX_领用ID' From Dual Union All
Select '票据打印内容','票据打印内容_PK' From Dual Union All
Select '票据领用记录','票据领用记录_IX_登记时间' From Dual Union All
Select '人员暂存记录','人员暂存记录_IX_登记时间' From Dual Union All
Select '人员暂存记录','人员暂存记录_IX_收缴ID' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '病人挂号汇总','病人挂号汇总_UQ_日期' From Dual Union All
Select '病人转诊记录','病人转诊记录_UQ_NO' From Dual Union All
Select '病人过敏记录','病人过敏记录_IX_病人ID' From Dual Union All
Select '病人诊断记录','病人诊断记录_IX_病历ID' From Dual Union All
Select '病人诊断记录','病人诊断记录_IX_病人ID' From Dual Union All
Select '病人诊断记录','病人诊断记录_PK' From Dual Union All
Select '病人手麻记录','病人手麻记录_IX_主页ID' From Dual Union All
Select '病人挂号记录','病人挂号记录_IX_发生时间' From Dual Union All
Select '病人挂号记录','病人挂号记录_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '病人护理明细','病人护理明细_IX_记录ID' From Dual Union All
Select '病人护理数据','病人护理数据_IX_文件ID' From Dual Union All
Select '病人护理打印','病人护理打印_IX_文件ID' From Dual Union All
Select '病人护理活动项目','病人护理活动项目_UQ_页号' From Dual Union All
Select '产程要素内容','产程要素内容_PK' From Dual Union All
Select '病人护理记录','病人护理记录_IX_主页ID' From Dual Union All
Select '病人护理内容','病人护理内容_IX_记录id' From Dual Union All
Select '病人护理要素内容','病人护理要素内容_UQ_页号' From Dual Union All
Select '病人护理文件','病人护理文件_IX_主页ID' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '电子病历附件','电子病历附件_PK' From Dual Union All
Select '电子病历格式','电子病历格式_PK' From Dual Union All
Select '电子病历图形','电子病历图形_PK' From Dual Union All
Select '疾病报告反馈','疾病报告反馈_PK' From Dual Union All
Select '疾病申报反馈','疾病申报反馈_PK' From Dual Union All
Select '电子病历内容','电子病历内容_UQ_对象序号' From Dual Union All
Select '影像报告驳回','影像报告驳回_IX_医嘱ID' From Dual Union All
Select '病人医嘱报告','病人医嘱报告_IX_病历ID' From Dual Union All
Select '病人医嘱报告','病人医嘱报告_PK' From Dual Union All
Select '报告查阅记录','报告查阅记录_IX_病历ID' From Dual Union All
Select '疾病申报记录','疾病申报记录_PK' From Dual Union All
Select '电子病历记录','电子病历记录_IX_病人ID' From Dual Union All
Select '电子病历记录','电子病历记录_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '病人路径医嘱','病人路径医嘱_PK' From Dual Union All
Select '病人路径执行','病人路径执行_IX_路径记录ID' From Dual Union All
Select '病人路径评估','病人路径评估_PK' From Dual Union All
Select '病人路径指标','病人路径指标_UQ_评估指标' From Dual Union All
Select '病人合并路径','病人合并路径_IX_首要路径记录ID' From Dual Union All
Select '病人合并路径评估','病人合并路径评估_PK' From Dual Union All
Select '病人出径记录','病人出径记录_IX_路径记录ID' From Dual Union All
Select '病人路径变异','病人路径变异_PK' From Dual Union All
Select '病人临床路径','病人临床路径_IX_病人ID' From Dual Union All
Select '病人医嘱计价','病人医嘱计价_UQ_收费细目ID' From Dual Union All
Select '病人医嘱附费','病人医嘱附费_PK' From Dual Union All
Select '病人医嘱附件','病人医嘱附件_PK' From Dual Union All
Select '病人医嘱执行','病人医嘱执行_PK' From Dual Union All
Select '病人医嘱打印','病人医嘱打印_UQ_医嘱ID' From Dual Union All
Select '医嘱执行打印','医嘱执行打印_PK' From Dual Union All
Select '病人诊断医嘱','病人诊断医嘱_IX_医嘱ID' From Dual Union All
Select '病人医嘱状态','病人医嘱状态_PK' From Dual Union All
Select '医嘱签名记录','医嘱签名记录_PK' From Dual Union All
Select '诊疗单据打印','诊疗单据打印_PK' From Dual Union All
Select '医嘱执行时间','医嘱执行时间_PK' From Dual Union All
Select '医嘱执行计价','医嘱执行计价_PK' From Dual Union All
Select '执行打印记录','执行打印记录_PK' From Dual Union All
Select '输血申请记录','输血申请记录_PK' From Dual Union All
Select '输血检验结果','输血检验结果_PK' From Dual Union All
Select '病人医嘱发送','病人医嘱发送_PK' From Dual Union All
Select '病人医嘱记录','病人医嘱记录_IX_挂号单' From Dual Union All
Select '病人医嘱记录','病人医嘱记录_IX_相关ID' From Dual Union All
Select '病人医嘱记录','病人医嘱记录_IX_主页ID' From Dual Union All
Select '病人医嘱记录','病人医嘱记录_PK' From Dual Union All
Select 'RIS检查预约','RIS检查预约_PK' From Dual Union All
Select '疾病阳性记录','疾病阳性记录_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '影像检查图象','影像检查图象_UQ_图像号' From Dual Union All
Select '影像检查序列','影像检查序列_UQ_序列号' From Dual Union All
Select '影像申请单图像','影像申请单图像_IX_医嘱ID' From Dual Union All
Select '影像收藏内容','影像收藏内容_IX_医嘱ID' From Dual Union All
Select '影像危急值记录','影像危急值记录_UQ_医嘱ID' From Dual Union All
Select '影像报告操作记录','影像报告操作记录_IX_医嘱ID' From Dual Union All
Select '影像报告记录','影像报告记录_IX_医嘱ID' From Dual Union All
Select '影像检查记录','影像检查记录_PK' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;


Insert Into zlBakTableindex(系统,表名,索引名)
Select 100,A.* From (
Select 表名,索引名 From zlBakTableindex Where 1 = 0 Union All
Select '检验申请项目','检验申请项目_PK' From Dual Union All
Select '检验项目分布','检验项目分布_IX_标本ID' From Dual Union All
Select '检验分析记录','检验分析记录_IX_标本ID' From Dual Union All
Select '检验操作记录','检验操作记录_IX_标本ID' From Dual Union All
Select '检验签名记录','检验签名记录_PK' From Dual Union All
Select '检验图像结果','检验图像结果_IX_标本ID' From Dual Union All
Select '检验质控记录','检验质控记录_PK' From Dual Union All
Select '检验试剂记录','检验试剂记录_PK' From Dual Union All
Select '检验拒收记录','检验拒收记录_IX_医嘱ID' From Dual Union All
Select '检验质控报告','检验质控报告_PK' From Dual Union All
Select '检验药敏结果','检验药敏结果_PK' From Dual Union All
Select '检验普通结果','检验普通结果_IX_检验标本ID' From Dual Union All
Select '检验标本记录','检验标本记录_IX_医嘱ID' From Dual Union All
Select 表名,索引名 From zlBakTableindex Where 1 = 0) A;

--101504:李业庆,2016-10-19,退料打印提醒方式
Insert Into Zlparameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1723, 0, 1, 1, 0, 15, '退料打印提醒方式', Null, '0', '在退料后对退料单打印的提醒方式:0-提示打印,1-自动打印,2-不打印。'
  From Dual
  Where Not Exists (Select 1 From Zlparameters Where 系统 = &n_System And 模块 = 1723 And 参数名 = '退料打印提醒方式');

-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--103923:黄捷,2016-12-16,RIS接口对象授权

--11 字典管理工具 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select null,11,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1001 部门管理（增删改）
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1001,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1002 人员管理 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1002,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1049 检查部位设置 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1049,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1054 诊疗项目管理 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1054,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1056 检查项目关联 增删改
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1056,'增删改',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1252 门诊医嘱下达 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1252,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1253 住院医嘱下达 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1253,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

-- 1254  住院医嘱发送 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1254,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All 
    Select 'RIS医嘱失败记录','SELECT' From Dual Union All
    Select 'b_zlXWInterface','EXECUTE' From Dual Union All
    Select 'RIS启用控制','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--1566 电子病案打印 基本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1566,'基本',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'RIS接口日志记录','SELECT' From Dual Union All 
    Select 'ZL_RIS接口日志记录_Insert','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--102600:梁经伙,2016-12-15,为1259模块增加 病案项目，病案重症监护情况 两张表的查询权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1259,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病案项目','SELECT' From Dual Union All 
    Select '病案重症监护情况','SELECT' From Dual Union All 
	Select '病案化疗记录','SELECT' From Dual Union All 
    Select '病案放疗记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103796:张险华,2016-12-13,病历增加权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2220,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',5,'控制批量质控功能',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2221,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',4,'控制批量质控功能',0 From Dual Union All
Select '全部提交',5,'控制全部提交功能',1 From Dual Union All
Select '全部撤销',6,'控制全部撤销功能',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,2222,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '批量质控',3,'控制批量质控功能',0 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--103157:黄捷,2016-12-02,RIS分科室启用控制
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1011,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '诊疗检查类型','SELECT' From Dual Union All 
    Select 'ris启用控制','SELECT' From Dual Union All 
    Select 'b_Zlxwinterface','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1287,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'ris启用控制','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--93116:刘尔旋,2016-11-29,结帐诊断
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1137,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
       Select '病人诊断医嘱','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--102930:刘尔旋,2016-11-22,门诊转住院权限缺失
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1137, '门诊费用转住院', User, a.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
 Select 'Zl_门诊转住院_三方卡结算', 'EXECUTE' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0) A;

--102263:胡俊勇,2016-11-04,权限添加
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1254, '修改打包状态和配液批次', 33, '临床护士有此权限时可以修改配液记录的打包状态和批次，否则不能修改。', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1254 And 功能 = '修改打包状态和配液批次');

--100140:张险华,2016-09-14,增加查看日志权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System, 2250, '查看日志', 10, '是否允许查看文档操作日志', 0 From Dual;

--95396:刘尔旋,2016-10-12,医生站修改费别权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1260,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '允许修改费别',18,'拥有该权限时，在医生站挂号处可以修改病人费别',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;


--101536:黄捷,2016-10-13,删除其他系统的Lob_Read对象
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl21_Lob_Read');
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl24_Lob_Read');
delete from zlProgPrivs  where 序号=1287 and upper(对象)=upper('Zl26_Lob_Read');

--85169:刘硕,2015-07-11, 处方审查系统相关的临床业务对象权限
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查项目','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查条件','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查参数','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查结果','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查明细','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查记录','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'处方审查记录_ID','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'ZL_处方审查_INSERT','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'ZL_处方审查_AUTO','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'ZL_处方审查_CANCEL','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1252,'基本',User,'ZL_处方审查_UPDATE','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查项目','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查条件','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查参数','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查结果','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查明细','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查记录','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'处方审查记录_ID','Select' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'ZL_处方审查_INSERT','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'ZL_处方审查_AUTO','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'ZL_处方审查_CANCEL','EXECUTE' from dual;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Select &n_System,1253,'基本',User,'ZL_处方审查_UPDATE','EXECUTE' from dual;

--85169:梁唐彬,2015-06-12,处方审查系统医嘱部分修改
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1252, '基本', User, 'Zl_病人医嘱记录_处方审查删除', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1252 And 功能 = '基本' And Upper(对象) = Upper('Zl_病人医嘱记录_处方审查删除'));

--99715:冉俊明,2016-10-09,部分退费非药品准退数计算有误。
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '门诊退费', User, 'zl_医嘱执行计价_修正', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '门诊退费' And Upper(对象) = Upper('zl_医嘱执行计价_修正'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1124, '结算退费', User, 'zl_医嘱执行计价_修正', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1124 And 功能 = '结算退费' And Upper(对象) = Upper('zl_医嘱执行计价_修正'));

--100837:刘尔旋,2016-09-29,挂号附加费处理
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1111,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1260,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1539,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1802,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1803,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'Zl_Fun_Regcustomname','EXECUTE' From Dual Union All
  Select 'Zl_Fun_Customregexpenses','EXECUTE' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--100933:黄捷,2016-09-23,1287模块无法授权
delete from zlprogprivs where 序号=1287 and upper(对象)=upper('ZlComponent') ;

--100336:李南春,2016-09-22,查询候诊人数
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1539, '基本', User, '病人挂号记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1539 And 功能 = '基本' And 对象 = '病人挂号记录');  

--100939:黄捷,2016-09-22,RIS接口检查医嘱批量重发

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1287,'基本',User,A.* From (
  Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select 'RIS医嘱失败记录','SELECT' From Dual Union All
  Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--99767:余伟节,2016-09-14,电子病案打印
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1566,'基本',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人医嘱发送','SELECT' From Dual Union All 
    Select '病历单据应用','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--100302:李小东,2016-09-07,技师工作站，添加“强制记账”权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1208,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '强制记帐',31,'拥有该权限时，当剩余款不足时可强制记账',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--100274:刘尔旋,2016-09-05,护士站余额退款功能
Insert Into zlProgFuncs(系统, 序号, 功能, 排列, 说明, 缺省值)
Select &n_System, 9000, a.* From (
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0 Union All
 Select '在院病人余额退款', 11, '护士工作站余额退款功能是否支持在院病人。', 1 From Dual Union All
 Select '出院病人余额退款', 12, '护士工作站余额退款功能是否支持出院病人。', 1 From Dual Union All
Select 功能, 排列, 说明, 缺省值 From zlProgFuncs Where 1 = 0) A;

--99724:刘尔旋,2016-08-29,挂号修改门诊号控制
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1260, '允许修改门诊号', 17, '对门诊医生工作或住院医生工作等的门诊号的修改权限。有该权限时，允许进行修改门诊号操作。', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1260 And 功能 = '允许修改门诊号');

--103936:余智勇,2016-12-15,补充数据库对象的权限脚本
--85987:余智勇,2015-07-02,新增处方审查系统
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1351,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1352,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1353,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1354,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1355,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
  Select '基本',-NULL,NULL,1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1351,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '病人信息','SELECT' From Dual Union All
  Select '病人医嘱记录','SELECT' From Dual Union All
  Select '病人医嘱发送','SELECT' From Dual Union All
  Select '部门人员','SELECT' From Dual Union All
  Select '部门性质说明','SELECT' From Dual Union All
  Select '处方审查常用理由','SELECT' From Dual Union All
  Select '处方审查参数','SELECT' From Dual Union All  
  Select '处方审查项目','SELECT' From Dual Union All
  Select '处方审查条件','SELECT' From Dual Union All
  Select '处方审查记录','SELECT' From Dual Union All
  Select '处方审查明细','SELECT' From Dual Union All
  Select '处方审查结果','SELECT' From Dual Union All
  Select '门诊费用记录','SELECT' From Dual Union All
  Select '收费项目目录','SELECT' From Dual Union All
  Select '收费项目别名','SELECT' From Dual Union All
  Select 'ZL_处方审查常用理由_UPDATE','EXECUTE' From Dual Union All
  Select 'ZL_处方审查_AUDIT','EXECUTE' From Dual Union All
  Select 'ZL_处方审查_AUDIT_DETAIL','EXECUTE' From Dual Union All
  Select 'ZL_处方审查参数_SAVE','EXECUTE' From Dual Union All
  Select 'ZL_处方审查记录_LOCK','EXECUTE' From Dual Union All
  Select 'ZL_业务消息清单_INSERT','EXECUTE' From Dual Union All
  Select 'ZL_FUN_PATI_CALORIE','EXECUTE' From Dual Union All
  Select '病人挂号记录','SELECT' From Dual Union All
  Select '病人过敏记录','SELECT' From Dual Union All
  Select '病人诊断记录','SELECT' From Dual Union All
  Select '疾病编码目录','SELECT' From Dual Union All
  Select '疾病诊断目录','SELECT' From Dual Union All
  Select '诊疗项目目录','SELECT' From Dual Union All
  Select '药品规格','SELECT' From Dual Union All
  Select '病人护理记录','SELECT' From Dual Union All
  Select '病人护理内容','SELECT' From Dual Union All
  Select '诊疗频率项目','SELECT' From Dual Union All
  Select '病人诊断医嘱','SELECT' From Dual Union All 
  Select '医疗卡类别','SELECT' From Dual Union All 
  Select '结算方式','SELECT' From Dual Union All 
  Select '卡消费接口目录','SELECT' From Dual Union All 
  Select '病人医疗卡信息','SELECT' From Dual Union All 
  Select '医疗卡挂失方式','SELECT' From Dual Union All 
  Select '床位状况记录','SELECT' From Dual Union All 
  Select '医疗付款方式','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1352,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '病人信息','SELECT' From Dual Union All
  Select '病人医嘱记录','SELECT' From Dual Union All
  Select '病人医嘱发送','SELECT' From Dual Union All
  Select '部门人员','SELECT' From Dual Union All
  Select '部门性质说明','SELECT' From Dual Union All
  Select '处方审查常用理由','SELECT' From Dual Union All
  Select '处方审查参数','SELECT' From Dual Union All  
  Select '处方审查项目','SELECT' From Dual Union All
  Select '处方审查条件','SELECT' From Dual Union All
  Select '处方审查记录','SELECT' From Dual Union All
  Select '处方审查明细','SELECT' From Dual Union All
  Select '处方审查结果','SELECT' From Dual Union All
  Select '收费项目目录','SELECT' From Dual Union All
  Select '收费项目别名','SELECT' From Dual Union All
  Select 'ZL_处方审查常用理由_UPDATE','EXECUTE' From Dual Union All
  Select 'ZL_处方审查_AUDIT','EXECUTE' From Dual Union All
  Select 'ZL_处方审查_AUDIT_DETAIL','EXECUTE' From Dual Union All
  Select 'ZL_处方审查参数_SAVE','EXECUTE' From Dual Union All
  Select 'ZL_处方审查记录_LOCK','EXECUTE' From Dual Union All
  Select 'ZL_业务消息清单_INSERT','EXECUTE' From Dual Union All
  Select 'ZL_FUN_PATI_CALORIE','EXECUTE' From Dual Union All
  Select '病案主页','SELECT' From Dual Union All
  Select '病案主页从表','SELECT' From Dual Union All
  Select '病人过敏记录','SELECT' From Dual Union All
  Select '病人诊断记录','SELECT' From Dual Union All
  Select '疾病编码目录','SELECT' From Dual Union All
  Select '疾病诊断目录','SELECT' From Dual Union All
  Select '诊疗项目目录','SELECT' From Dual Union All
  Select '药品规格','SELECT' From Dual Union All
  Select '病人护理记录','SELECT' From Dual Union All
  Select '病人护理内容','SELECT' From Dual Union All
  Select '诊疗频率项目','SELECT' From Dual Union All
  Select '病人诊断医嘱','SELECT' From Dual Union All 
  Select '医疗卡类别','SELECT' From Dual Union All 
  Select '结算方式','SELECT' From Dual Union All 
  Select '卡消费接口目录','SELECT' From Dual Union All 
  Select '病人医疗卡信息','SELECT' From Dual Union All 
  Select '医疗卡挂失方式','SELECT' From Dual Union All 
  Select '床位状况记录','SELECT' From Dual Union All 
  Select '医疗付款方式','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1353,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '处方审查项目','SELECT' From Dual Union All
  Select '处方审查项目_ID','SELECT' From Dual Union All
  Select 'ZL_处方审查项目_UPDATE','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1354,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '部门性质说明','SELECT' From Dual Union All
  Select '人员性质说明','SELECT' From Dual Union All
  Select '诊疗分类目录','SELECT' From Dual Union All
  Select '诊疗项目目录','SELECT' From Dual Union All
  Select '药品特性','SELECT' From Dual Union All
  Select '疾病编码目录','SELECT' From Dual Union All
  Select '疾病诊断目录','SELECT' From Dual Union All
  Select '处方审查条件','SELECT' From Dual Union All
  Select '疾病编码科室','SELECT' From Dual Union All 
  Select '疾病编码分类','SELECT' From Dual Union All 
  Select '疾病编码类别','SELECT' From Dual Union All 
  Select '疾病诊断分类','SELECT' From Dual Union All 
  Select '疾病诊断属类','SELECT' From Dual Union All 
  Select '疾病诊断科室','SELECT' From Dual Union All 
  Select '疾病诊断对照','SELECT' From Dual Union All 
  Select 'ZL_疾病诊断科室_INSERT','EXECUTE' From Dual Union All 
  Select 'ZL_疾病诊断科室_DELETE','EXECUTE' From Dual Union All 
  Select 'ZL_疾病编码科室_INSERT','EXECUTE' From Dual Union All 
  Select 'ZL_疾病编码科室_DELETE','EXECUTE' From Dual Union All 
  Select 'ZL_处方审查条件_UPDATE','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1355,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
  Select '部门性质说明','SELECT' From Dual Union All
  Select '人员性质说明','SELECT' From Dual Union All
  Select '病人医嘱记录','SELECT' From Dual Union All
  Select '收费项目目录','SELECT' From Dual Union All
  Select '处方审查项目','SELECT' From Dual Union All
  Select '处方审查记录','SELECT' From Dual Union All
  Select '处方审查明细','SELECT' From Dual Union All
  Select '处方审查结果','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1351,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
  Select NULL,&n_System,9001,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1352,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
  Select NULL,&n_System,9001,1,'基本',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;


--99572:冉俊明,2016-08-22,门诊收费历史异常单据处理
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '门诊收费', User, 'Zl_门诊收费结算_完成收费', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '门诊收费' And Upper(对象) = Upper('Zl_门诊收费结算_完成收费'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1121, '门诊退费', User, 'Zl_门诊收费结算_完成收费', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1121 And 功能 = '门诊退费' And Upper(对象) = Upper('Zl_门诊收费结算_完成收费'));

--68694:刘尔旋,2016-8-17,新挂号安排修改
--9000:费用公共模块
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,9000,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '挂号',2,'有此权限时,允许调用挂号接口进行挂号。',1 From Dual Union All 
    Select '预约',3,'有此权限时,允许调用挂号接口进行预约。',1 From Dual Union All 
    Select '挂号选项设置',4,'有此权限时,允许调用挂号选项设置接口进行虚拟模块挂号本机或者私有参数的设置。',1 From Dual Union All 
    Select '挂号费别打折',5,'病人挂号时使用打折费别的权限',1 From Dual Union All 
    Select '挂号病人建档',6,'门诊医生工作站挂号或者预约时是否支持新病人建档',0 From Dual Union All 
    Select '病人挂号凭条',-Null,'病人挂号凭条',NULL From Dual Union All 
    Select '挂号发票打印',-Null,'挂号发票打印',NULL From Dual Union All 
    Select '预约挂号单',-Null,'预约单打印',NULL From Dual Union All 
    Select '允许修改费别',8,'有此权限时,允许在医生站挂号时修改病人的费别,否则不能修改',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '基本'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '基本');
   
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '挂号'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '病人挂号' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '挂号');

Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '挂号病人建档'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '病人挂号' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '挂号病人建档');
   
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '预约'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '预约挂号' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '预约');
   
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '挂号费别打折'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '挂号费别打折' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '挂号费别打折');

Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '挂号选项设置'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '参数设置' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '挂号选项设置');
   
Insert Into zlRoleGrant
  (系统, 序号, 角色, 功能)
  Select &n_System, 9000, 角色, '预约挂号单'
  From zlRoleGrant A
  Where 系统 = &n_System And 序号 = 1260 And 功能 = '预约挂号单' And Not Exists
   (Select 1 From zlRoleGrant Where 系统 = &n_System And 角色 = a.角色 And 序号 = 9000 And 功能 = '预约挂号单');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1011, '基本', User, 'Zl_出诊表挂号_Turn', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1011 And 功能 = '基本' And 对象 = 'Zl_出诊表挂号_Turn');     


Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, '收费项目类别', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1111 And 功能 = '基本' And Upper(对象) = Upper('收费项目类别'));


--9000:费用公共模块(基本)
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, '病人照片', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('病人照片'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'ZL_病人照片_DELETE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('ZL_病人照片_DELETE'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, '病人免疫记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('病人免疫记录'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'ZL_病人信息从表_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('ZL_病人信息从表_UPDATE'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_病人过敏药物_DELETE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('Zl_病人过敏药物_DELETE'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_病人过敏药物_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('Zl_病人过敏药物_UPDATE'));
         
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_病人免疫记录_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('Zl_病人免疫记录_Delete'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_病人免疫记录_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('Zl_病人免疫记录_Update'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, '病人照片', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('病人照片'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'ZL_病人照片_DELETE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('ZL_病人照片_DELETE'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, '病人免疫记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('病人免疫记录'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'ZL_病人信息从表_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('ZL_病人信息从表_UPDATE'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'Zl_病人过敏药物_DELETE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('Zl_病人过敏药物_DELETE'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'Zl_病人过敏药物_UPDATE', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('Zl_病人过敏药物_UPDATE'));
         
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'Zl_病人免疫记录_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('Zl_病人免疫记录_Delete'));
         
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '基本', User, 'Zl_病人免疫记录_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '基本' And 对象 = Upper('Zl_病人免疫记录_Update'));


--9000:费用公共模块(挂号选项设置)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'挂号选项设置',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '票据领用记录','SELECT' From Dual Union All 
    Select '人员表','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--9000:费用公共模块(挂号)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'挂号',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '常用挂号摘要','SELECT' From Dual Union All 
    Select '一卡通目录','SELECT' From Dual Union All 
    Select '医疗付款方式','SELECT' From Dual Union All 
    Select '票据使用明细','SELECT' From Dual Union All 
    Select '票据打印内容','SELECT' From Dual Union All 
    Select '挂号序号状态','SELECT' From Dual Union All 
    Select '挂号安排','SELECT' From Dual Union All 
    Select '病人挂号汇总','SELECT' From Dual Union All 
    Select '挂号安排限制','SELECT' From Dual Union All 
    Select '病人信息','SELECT' From Dual Union All 
    Select '保险类别','SELECT' From Dual Union All 
    Select '病案主页','SELECT' From Dual Union All 
    Select '病人医疗卡信息','SELECT' From Dual Union All 
    Select '结算方式应用','SELECT' From Dual Union All 
    Select '结算方式','SELECT' From Dual Union All 
    Select '时间段','SELECT' From Dual Union All 
    Select '部门表','SELECT' From Dual Union All 
    Select '收费项目目录','SELECT' From Dual Union All 
    Select '人员表','SELECT' From Dual Union All 
    Select '挂号安排时段','SELECT' From Dual Union All 
    Select '挂号安排计划','SELECT' From Dual Union All 
    Select '挂号计划时段','SELECT' From Dual Union All 
    Select '挂号安排诊室','SELECT' From Dual Union All 
    Select '门诊诊室','SELECT' From Dual Union All 
    Select '收费价目','SELECT' From Dual Union All 
    Select '收入项目','SELECT' From Dual Union All 
    Select '收费从属项目','SELECT' From Dual Union All 
    Select '收费特定项目','SELECT' From Dual Union All 
    Select '人员性质说明','SELECT' From Dual Union All 
    Select '票据领用记录','SELECT' From Dual Union All 
    Select '收费执行科室','SELECT' From Dual Union All 
    Select '费别明细','SELECT' From Dual Union All 
    Select '病人余额','SELECT' From Dual Union All 
    Select '保险模拟结算','SELECT' From Dual Union All 
    Select '挂号计划限制','SELECT' From Dual Union All 
    Select '病人未结费用','SELECT' From Dual Union All 
    Select '病人挂号记录','SELECT' From Dual Union All 
    Select '病人医嘱记录','SELECT' From Dual Union All 
    Select '挂号安排停用状态','SELECT' From Dual Union All 
    Select 'zl_病人挂号记录_INSERT','EXECUTE' From Dual Union All 
    Select 'zl_病人挂号汇总_Update','EXECUTE' From Dual Union All 
    Select 'zl_门诊划价记录_Insert','EXECUTE' From Dual Union All 
    Select 'zl_一卡通结算_Update','EXECUTE' From Dual Union All 
    Select 'Zl_凭条打印记录_Update','EXECUTE' From Dual Union All 
    Select 'Zl_三方结算交易_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_三方接口更新_Update','EXECUTE' From Dual Union All 
    Select 'Zl_挂号安排_Autoupdate','EXECUTE' From Dual Union All 
    Select 'ZL_病人挂号记录_更新诊室','EXECUTE' From Dual Union All 
    Select 'zl_病人接诊','EXECUTE' From Dual Union All 
    Select 'Zl_Paticardcheck','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--9000:费用公共模块(预约)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'预约',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '常用挂号摘要','SELECT' From Dual Union All 
    Select '一卡通目录','SELECT' From Dual Union All 
    Select '医疗付款方式','SELECT' From Dual Union All 
    Select '票据使用明细','SELECT' From Dual Union All 
    Select '票据打印内容','SELECT' From Dual Union All 
    Select '挂号序号状态','SELECT' From Dual Union All 
    Select '挂号安排','SELECT' From Dual Union All 
    Select '病人挂号汇总','SELECT' From Dual Union All 
    Select '挂号安排限制','SELECT' From Dual Union All 
    Select '病人信息','SELECT' From Dual Union All 
    Select '保险类别','SELECT' From Dual Union All 
    Select '病案主页','SELECT' From Dual Union All 
    Select '病人医疗卡信息','SELECT' From Dual Union All 
    Select '结算方式应用','SELECT' From Dual Union All 
    Select '结算方式','SELECT' From Dual Union All 
    Select '时间段','SELECT' From Dual Union All 
    Select '部门表','SELECT' From Dual Union All 
    Select '收费项目目录','SELECT' From Dual Union All 
    Select '人员表','SELECT' From Dual Union All 
    Select '挂号安排时段','SELECT' From Dual Union All 
    Select '挂号安排计划','SELECT' From Dual Union All 
    Select '挂号计划时段','SELECT' From Dual Union All 
    Select '挂号安排诊室','SELECT' From Dual Union All 
    Select '门诊诊室','SELECT' From Dual Union All 
    Select '收费价目','SELECT' From Dual Union All 
    Select '收入项目','SELECT' From Dual Union All 
    Select '收费从属项目','SELECT' From Dual Union All 
    Select '收费特定项目','SELECT' From Dual Union All 
    Select '人员性质说明','SELECT' From Dual Union All 
    Select '票据领用记录','SELECT' From Dual Union All 
    Select '收费执行科室','SELECT' From Dual Union All 
    Select '费别明细','SELECT' From Dual Union All 
    Select '病人余额','SELECT' From Dual Union All 
    Select '保险模拟结算','SELECT' From Dual Union All 
    Select '挂号计划限制','SELECT' From Dual Union All 
    Select '病人未结费用','SELECT' From Dual Union All 
    Select '病人挂号记录','SELECT' From Dual Union All 
    Select '病人医嘱记录','SELECT' From Dual Union All 
    Select '挂号安排停用状态','SELECT' From Dual Union All 
    Select 'zl_病人挂号记录_INSERT','EXECUTE' From Dual Union All 
    Select 'zl_病人挂号汇总_Update','EXECUTE' From Dual Union All 
    Select 'zl_门诊划价记录_Insert','EXECUTE' From Dual Union All 
    Select 'zl_一卡通结算_Update','EXECUTE' From Dual Union All 
    Select 'Zl_凭条打印记录_Update','EXECUTE' From Dual Union All 
    Select 'Zl_三方结算交易_Insert','EXECUTE' From Dual Union All 
    Select 'Zl_三方接口更新_Update','EXECUTE' From Dual Union All 
    Select 'Zl_挂号安排_Autoupdate','EXECUTE' From Dual Union All 
    Select 'Zl_Paticardcheck','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--9000:费用公共模块(病人挂号凭条)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'病人挂号凭条',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人挂号记录','SELECT' From Dual Union All 
    Select '病人信息','SELECT' From Dual Union All 
    Select '病人预交记录','SELECT' From Dual Union All 
    Select '部门表','SELECT' From Dual Union All 
    Select '门诊费用记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--9000:费用公共模块(挂号发票打印)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'挂号发票打印',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '病人挂号记录','SELECT' From Dual Union All 
    Select '门诊费用记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--9000:费用公共模块(预约挂号单)
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'预约挂号单',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '部门表','SELECT' From Dual Union All 
    Select '挂号安排','SELECT' From Dual Union All 
    Select '门诊费用记录','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--数据处理
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select 系统, 序号, '挂收费号', 排列, '给病人挂收费号的操作权限。有该权限时，允许对病人进行挂费用不为0的号', 缺省值
  From zlProgFuncs
  Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Update Zlprogrelas Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Update zlProgPrivs Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Insert Into zlProgPrivs
  (系统, 序号, 功能, 对象, 所有者, 权限)
  Select 系统, 序号, '挂免费号', 对象, 所有者, 权限
  From zlProgPrivs A
  Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂收费号' And Not Exists
   (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1111 And 功能 = '挂免费号' And 对象 = a.对象);

Update zlRoleGrant Set 功能 = '挂收费号' Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

Delete From zlProgFuncs Where 序号 = 1111 And 系统 = &n_System And 功能 = '挂号';

--1114:临床出诊安排
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1114,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '基本',-Null,NULL,1 From Dual Union All 
    Select '时间段设置',1,'增加、删除、修改的挂号时间的操作权限。有该权限时，允许对挂号项目的各时间段进行定义',1 From Dual Union All 
    Select '节假日设置',2,'增加、删除、修改法定节假日的操作权限。有该权限时，允许对各法定节假日进行定义',1 From Dual Union All 
    Select '门诊诊室设置',3,'增加、删除、修改门诊诊室的操作权限。有该权限时，允许对各门诊诊室进行设置',1 From Dual Union All 
    Select '出诊号源设置',4,'增加、删除、修改、停用及启用出诊号源的操作权限。有该权限时，允许针对各号源进行增加，修改，删除,停用及启用',1 From Dual Union All 
    Select '模板管理',5,'增加、删除、修改出诊模板的操作权限。有该权限时，允许针对模板进行增加，修改及删除。',1 From Dual Union All 
    Select '出诊安排',6,'针对各号源的出诊进行安排的操作权限，有该权限时，允许针对各号源的出诊进行安排。',1 From Dual Union All 
    Select '发布安排',7,'针对指定的安排表进行发布操作，有该权限时，允许针对出诊表进行发布操作。',1 From Dual Union All 
    Select '取消发布',8,'针对已经发布的安排表进行取消操作，有该权限时，允许针对出诊表进行取消发布操作。',1 From Dual Union All 
    Select '临时出诊安排',9,'对已经发布的安排但又未进行出诊安排的号源进行临时出诊安排操作，有该权限时，允许针对未出诊的号源进行临时出诊安排。',1 From Dual Union All 
    Select '停诊',10,'对已经发布的安排进行停诊操作，有该权限时，允许针对号源进行停诊操作。',1 From Dual Union All 
    Select '替诊',11,'对已经发布的安排进行替诊操作，有该权限时，允许针对号源进行替诊操作。',1 From Dual Union All 
    Select '加号',12,'对已经发布的安排进行加号操作，有该权限时，允许针对号源进行加号操作。',1 From Dual Union All 
    Select '减号',13,'对已经发布的安排进行减号操作，有该权限时，允许针对号源进行减号操作。',1 From Dual Union All 
    Select '调整分诊诊室',14,'对已经发布的安排进行诊室调整操作，有该权限时，允许针对号源进行诊室调整操作。',1 From Dual Union All 
    Select '调整预约挂号',15,'对已经发布的安排进行合作单位和预约方式的预约控制调整操作，有该权限时，允许针对号源进行合作单位和预约方式的预约控制调整。',1 From Dual Union All 
    Select '停诊申请',16,'对医生较长时间停诊的申请操作，有此权限时，允许进行申请操作。',1 From Dual Union All 
    Select '停诊审批',17,'针对停诊申请进行审批操作，有此权限时，允许对申请进行审批操作。',1 From Dual Union All 
    Select '允许代他人停诊申请',18,'允许代他人停诊申请操作,有此权限时，允许代其他人填写申请单的操作。',1 From Dual Union All 
    Select '所有科室',19,'当不具有该权限时，只能查看和处理门诊部下放给本科相关的号源。',1 From Dual Union All 
    Select '参数设置',20,'对临床出诊安排的参数设置进行操作的权限。有该权限时，允许进行本地参数设置',1 From Dual Union All
    Select '审核临时固定安排', 21, '有该权限时，可以对发布后新增的临时固定安排或新增号源安排(固定安排)进行审核。', 1 From Dual Union All
    Select '取消临时固定安排审核', 22, '有该权限时，可以对审核后的临时固定安排进行取消审核。', 1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--1115:患者服务中心
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1115,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '基本',-Null,NULL,1 From Dual Union All 
    Select '停诊信息处理',1,'实现因发生停诊或替诊操作时，需要对对应的预约进行取消、换诊或替诊的操作权限。有该权限时，允许操作员对停诊或替诊所对应的预约进行取消，换诊或替诊操作。',1 From Dual Union All 
    Select '预约登记信息处理',2,'实现对复诊病人到期的预约登记信息进行提醒复诊或给病人预约挂号的操作权限。有该权限时，允许操作员对到期的预约登记的信息通知患者或给病人预约挂号的操作权限。',1 From Dual Union All 
    Select '预约挂号登记',3,'实现预约挂号的操作权限。有该权限时，允许操作员进行预约挂号操作。',1 From Dual Union All 
    Select '预约挂号单',Null,'预约挂号单',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 9000, '预约登记', 7, '对门诊医生工作或住院医生工作等的预约登记的操作权限。有该权限时，允许进行预约登记操作。', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记');

--今日就诊
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1539,'参数设置',2,'设置相关参数设置',1 From Dual
WHERE NOT exists(SELECT  1 From zlProgFuncs WHERE 系统=&n_system AND 序号=1539 And  功能='参数设置');

Insert Into zlModuleRelas(系统,模块,功能,相关系统,相关模块,相关类型,相关功能,缺省值)
Select &n_System,1115,A.* From (
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0 Union All
Select NULL,&n_System,9000,0,'挂号',1 From Dual Union All
Select NULL,&n_System,9000,0,'预约',1 From Dual Union All
Select NULL,&n_System,9000,0,'挂号选项设置',1 From Dual Union All
Select NULL,&n_System,9000,0,'挂号费别打折',1 From Dual Union All
Select 功能,相关系统,相关模块,相关类型,相关功能,缺省值 From zlModuleRelas Where 1 = 0) A;

--权限脚本
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1114,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '临床出诊表_ID','SELECT' From Dual Union All
Select '临床出诊安排_ID','SELECT' From Dual Union All
Select '临床出诊号源_ID','SELECT' From Dual Union All
Select '临床出诊号源限制_ID','SELECT' From Dual Union All
Select '临床出诊记录_ID','SELECT' From Dual Union All
Select '临床出诊变动记录_ID','SELECT' From Dual Union All
Select '临床出诊限制_ID','SELECT' From Dual Union All
Select '临床出诊号源限制','SELECT' From Dual Union All
Select '临床出诊号源时段','SELECT' From Dual Union All
Select '临床出诊号源控制','SELECT' From Dual Union All
Select '病人挂号记录','SELECT' From Dual Union All
Select '部门表','SELECT' From Dual Union All
Select '部门性质说明','SELECT' From Dual Union All
Select '常用停诊原因','SELECT' From Dual Union All
Select '法定假日表','SELECT' From Dual Union All
Select '挂号安排','SELECT' From Dual Union All
Select '挂号合作单位','SELECT' From Dual Union All
Select '号类','SELECT' From Dual Union All
Select '临床出诊安排','SELECT' From Dual Union All
Select '临床出诊变动记录','SELECT' From Dual Union All
Select '临床出诊变动明细','SELECT' From Dual Union All
Select '临床出诊表','SELECT' From Dual Union All
Select '临床出诊挂号控制','SELECT' From Dual Union All
Select '临床出诊挂号控制记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊号源诊室','SELECT' From Dual Union All
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊时段','SELECT' From Dual Union All
Select '临床出诊停诊记录','SELECT' From Dual Union All
Select '临床出诊限制','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '临床出诊诊室','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '门诊诊室','SELECT' From Dual Union All
Select '门诊诊室适用科室','SELECT' From Dual Union All
Select '上机人员表','SELECT' From Dual Union All
Select '时间段','SELECT' From Dual Union All
Select '收费项目目录','SELECT' From Dual Union All
Select '预约方式','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限)
Select &n_System,1114,User,A.* From (
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '时间段设置','Zl_上班时段_Modify','EXECUTE' From Dual Union All
Select '时间段设置','Zl_上班时段_Delete','EXECUTE' From Dual Union All
Select '节假日设置','Zl_法定假日表_Modify','EXECUTE' From Dual Union All
Select '节假日设置','Zl_法定假日表_Delete','EXECUTE' From Dual Union All
Select '门诊诊室设置','Zl_门诊诊室_Modify','EXECUTE' From Dual Union All
Select '门诊诊室设置','Zl_门诊诊室_Delete','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl_临床出诊号源_Stopandstart','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl_临床出诊号源_Modify','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl_临床出诊号源_Delete','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl_临床出诊号源限制_Modify','EXECUTE' From Dual Union All
Select '出诊号源设置','Zl_Age_Check','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊表_Add','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊表_Update','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊表_Delete','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊安排_Delete','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊上班时段_Delete','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊安排_Insert','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊限制_Insert','EXECUTE' From Dual Union All
Select '模板管理','Zl_临床出诊挂号控制_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊表_Delete','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊表_导入','EXECUTE' From Dual Union All
Select '出诊安排','Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊表_Add','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊表_Update','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊安排_Delete','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊上班时段_Delete','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊安排_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊限制_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊挂号控制_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊记录_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊挂号控制记录_Insert','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊安排_Applyto','EXECUTE' From Dual Union All
Select '出诊安排','Zl_Buildregisterplanbyrecord','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊安排_BatchDelete','EXECUTE' From Dual Union All
Select '出诊安排','Zl_Buildregisterfixedrule','EXECUTE' From Dual Union All
Select '出诊安排','Zl_Buildregisterplanbytemplet','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊安排_序号控制','EXECUTE' From Dual Union All
Select '出诊安排','Zl_临床出诊记录_Batchlock','EXECUTE' From Dual Union All
Select '发布安排','Zl_临床出诊安排_Publish','EXECUTE' From Dual Union All
Select '取消发布','Zl_临床出诊安排_Publish','EXECUTE' From Dual Union All
Select '临时出诊安排','Zl_临床出诊安排_Delete','EXECUTE' From Dual Union All
Select '临时出诊安排','Zl_临床出诊安排_Insert','EXECUTE' From Dual Union All
Select '临时出诊安排','Zl_临床出诊上班时段_Delete','EXECUTE' From Dual Union All
Select '临时出诊安排','Zl_临床出诊记录_Insert','EXECUTE' From Dual Union All
Select '临时出诊安排','Zl_临床出诊挂号控制记录_Insert','EXECUTE' From Dual Union All
Select '停诊','Zl_临床出诊记录_Stopvisit','EXECUTE' From Dual Union All
Select '替诊','Zl_临床出诊记录_Replacedoctor','EXECUTE' From Dual Union All
Select '替诊','Zl1_Ex_Isdoctorsamelevel','EXECUTE' From Dual Union All
Select '加号','Zl_临床出诊序号控制变动','EXECUTE' From Dual Union All
Select '减号','Zl_临床出诊序号控制变动','EXECUTE' From Dual Union All
Select '调整分诊诊室','Zl_临床出诊诊室_Update','EXECUTE' From Dual Union All
Select '调整预约挂号','Zl_临床出诊预约控制变动','EXECUTE' From Dual Union All
Select '调整预约挂号','Zl_临床出诊序号控制_Update','EXECUTE' From Dual Union All
Select '停诊申请','Zl_临床出诊停诊_Apply','EXECUTE' From Dual Union All
Select '停诊审批','Zl_临床出诊停诊_Audit','EXECUTE' From Dual Union All
Select '审核临时固定安排','Zl_临床出诊临时安排_Verify','EXECUTE' From Dual Union All
Select '取消临时固定安排审核','Zl_临床出诊临时安排_Cancel','EXECUTE' From Dual Union All
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限)
Select &n_System,1115,User,A.* From (
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '停诊信息处理','Zl_患者服务中心_换诊','EXECUTE' From Dual Union All
Select '停诊信息处理','Zl_患者服务中心_替诊','EXECUTE' From Dual Union All
Select '停诊信息处理','Zl_患者服务中心_更新','EXECUTE' From Dual Union All
Select '停诊信息处理','zl_病人挂号记录_出诊_DELETE','EXECUTE' From Dual Union All
Select '预约登记信息处理','Zl_患者服务中心_换诊','EXECUTE' From Dual Union All
Select '预约登记信息处理','Zl_患者服务中心_替诊','EXECUTE' From Dual Union All
Select '预约登记信息处理','Zl_患者服务中心_更新','EXECUTE' From Dual Union All
Select '预约登记信息处理','zl_病人挂号记录_出诊_DELETE','EXECUTE' From Dual Union All
Select '预约挂号登记','zl_病人挂号记录_出诊_INSERT','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_Billclass','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_Fun_Get临床出诊预约状态','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_临床出诊限制_Check','EXECUTE' From Dual Union All
Select '预约挂号登记','zl_病人挂号汇总_Update','EXECUTE' From Dual Union All
Select '预约挂号登记','zl_门诊划价记录_Insert','EXECUTE' From Dual Union All
Select '预约挂号登记','zl_一卡通结算_Update','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_凭条打印记录_Update','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_三方结算交易_Insert','EXECUTE' From Dual Union All
Select '预约挂号登记','Zl_三方接口更新_Update','EXECUTE' From Dual Union All
Select '基本','Zl_患者服务中心_更新','EXECUTE' From Dual Union All
Select '基本','门诊费用记录','SELECT' From Dual Union All
Select '基本','病人预交记录','SELECT' From Dual Union All
Select '基本','结算方式','SELECT' From Dual Union All
Select '基本','病人挂号记录','SELECT' From Dual Union All
Select '基本','病案主页','SELECT' From Dual Union All
Select '基本','临床部门','SELECT' From Dual Union All
Select '基本','医疗付款方式','SELECT' From Dual Union All
Select '基本','病人服务信息记录','SELECT' From Dual Union All
Select '基本','病人信息','SELECT' From Dual Union All
Select '基本','部门表','SELECT' From Dual Union All
Select '基本','收费项目目录','SELECT' From Dual Union All
Select '基本','临床出诊记录','SELECT' From Dual Union All
Select '基本','临床出诊号源','SELECT' From Dual Union All
Select '基本','收费价目','SELECT' From Dual Union All
Select '基本','收入项目','SELECT' From Dual Union All
Select '基本','收费从属项目','SELECT' From Dual Union All
Select '基本','临床出诊序号控制','SELECT' From Dual Union All
Select '基本','收费特定项目','SELECT' From Dual Union All
Select '基本','就诊登记记录','SELECT' From Dual Union All
Select '基本','人员表','SELECT' From Dual Union All
Select '基本','就诊变动记录','SELECT' From Dual Union All
Select '基本','临床出诊停诊记录','SELECT' From Dual Union All
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限)
Select &n_System,1111,User,A.* From (
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '取消预约','Zl_病人挂号记录_出诊_Delete','EXECUTE' From Dual Union All
Select '退号','Zl_病人挂号记录_出诊_Delete','EXECUTE' From Dual Union All
Select '挂收费号','Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select '挂免费号','Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select '预约挂号','Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select '挂收费号','Zl_预约挂号接收_出诊_insert','EXECUTE' From Dual Union All
Select '挂免费号','Zl_预约挂号接收_出诊_insert','EXECUTE' From Dual Union All
Select '预约挂号','Zl_预约挂号接收_出诊_insert','EXECUTE' From Dual Union All
Select '接收预约','Zl_预约挂号接收_出诊_insert','EXECUTE' From Dual Union All
Select '基本','Zl_挂号序号状态_出诊_Delete','EXECUTE' From Dual Union All
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限)
Select &n_System,1260,User,A.* From (
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0 Union All
Select '基本','Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select '基本','Zl_挂号序号状态_出诊_Delete','EXECUTE' From Dual Union All
Select 功能,对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约登记', User, 'Zl_病人预约登记_Insert', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记' And 对象 = Upper('Zl_病人预约登记_Insert'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约登记', User, 'ZL_患者服务中心_更新', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记' And 对象 = Upper('ZL_患者服务中心_更新'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约登记', User, '临床出诊号源', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记' And 对象 = Upper('临床出诊号源'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约登记', User, '病人服务信息记录', 'SELECT'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记' And 对象 = Upper('病人服务信息记录'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '基本', User, 'Zl_挂号序号状态_出诊_Delete', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '基本' And 对象 = Upper('Zl_挂号序号状态_出诊_Delete'));

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1111,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊挂号控制记录','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '临床出诊安排','SELECT' From Dual Union All
Select '临床出诊表','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 'Zl_Fun_Get临床出诊预约状态','EXECUTE' From Dual Union All
Select 'Zl_临床出诊限制_Check','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1113,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊挂号控制记录','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '临床出诊安排','SELECT' From Dual Union All
Select '临床出诊表','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'挂号',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊挂号控制记录','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '临床出诊安排','SELECT' From Dual Union All
Select '临床出诊表','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,9000,'预约',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊挂号控制记录','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '临床出诊安排','SELECT' From Dual Union All
Select '临床出诊表','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 'Zl_Fun_Get临床出诊预约状态','EXECUTE' From Dual Union All
Select 'Zl_临床出诊限制_Check','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1539,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '号类','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select '收费项目类别','SELECT' From Dual Union All
Select '收费项目目录','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1802,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 'Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select 'Zl_预约挂号接收_出诊_Insert','EXECUTE' From Dual Union All
Select 'Zl_Fun_Get临床出诊预约状态','EXECUTE' From Dual Union All
Select 'Zl_临床出诊限制_Check','EXECUTE' From Dual Union All
Select 'NextReservationNum','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1803,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
Select '临床出诊记录','SELECT' From Dual Union All
Select '临床出诊号源','SELECT' From Dual Union All
Select '临床出诊诊室记录','SELECT' From Dual Union All
Select '临床出诊序号控制','SELECT' From Dual Union All
Select 'Zl1_Auto_Buildingregisterplan','EXECUTE' From Dual Union All
Select 'Zl_病人挂号记录_出诊_Insert','EXECUTE' From Dual Union All
Select 'Zl_预约挂号接收_出诊_Insert','EXECUTE' From Dual Union All
Select 'Zl_Fun_Get临床出诊预约状态','EXECUTE' From Dual Union All
Select 'Zl_临床出诊限制_Check','EXECUTE' From Dual Union All
Select 'NextReservationNum','EXECUTE' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103221:刘尔旋,2016-12-26,开放停诊号码
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '病人挂号', User, 'zl_临床出诊序号控制_开放挂号', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '病人挂号' And 对象 = Upper('zl_临床出诊序号控制_开放挂号'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1260, '预约挂号', User, 'zl_临床出诊序号控制_开放挂号', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1260 And 功能 = '预约挂号' And 对象 = Upper('zl_临床出诊序号控制_开放挂号'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 9000, '预约登记', User, 'zl_临床出诊序号控制_开放挂号', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 9000 And 功能 = '预约登记' And 对象 = Upper('zl_临床出诊序号控制_开放挂号'));


--91721:刘尔旋,2016-07-15,自动记账更改
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1137, '住院费用结帐', User, 'Zl_病人自动记帐_Stop', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1137 And 功能 = '住院费用结帐' And 对象 = 'Zl_病人自动记帐_Stop');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1137, '结帐作废', User, 'Zl_病人自动记帐_Restore', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1137 And 功能 = '结帐作废' And 对象 = 'Zl_病人自动记帐_Restore');

--95554:余智勇,2016-07-06,药房自助签到
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1810,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
    Select '基本',-Null,NULL,1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1810,'基本',user,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '部门表','SELECT' From Dual Union All
    Select '部门性质说明','SELECT' From Dual Union All
    Select '未发药品记录','SELECT' From Dual Union All
    Select '消费卡目录','SELECT' From Dual Union All
    Select '病人卡结算记录','SELECT' From Dual Union All
    Select '病人信息','SELECT' From Dual Union All
    Select '病案主页','SELECT' From Dual Union All
    Select '药品收发记录','SELECT' From Dual Union All
    Select '门诊费用记录','SELECT' From Dual Union All
    Select '病人挂号记录','SELECT' From Dual Union All
    Select '病人医疗卡信息','SELECT' From Dual Union All
    Select '医疗付款方式','SELECT' From Dual Union All
    Select '病人余额','SELECT' From Dual Union All
    Select '医疗卡挂失方式','SELECT' From Dual Union All
    Select '医疗卡类别','SELECT' From Dual Union All
    Select '卡消费接口目录','SELECT' From Dual Union All
    Select '保险类别','SELECT' From Dual Union All
    Select 'ZL_未发药品记录_配药确认','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--92798:余伟节,2016-08-11,路径医嘱审核
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1078, '路径医嘱调整', 15, '具有该权限可以直接调整审核且未停用路径表单中的医嘱内容', 1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1078 And 功能 = '路径医嘱调整');

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1078, '路径医嘱调整', User, 'Zl_路径医嘱变动_Audit', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1078 And 功能 = '路径医嘱调整' And 对象 = Upper('Zl_路径医嘱变动_Audit'));

--80588:马政,2014-12-29,药品目录管理权限调整
Delete from zlProgFuncs where 系统=&n_System and 序号=1023 and 功能= '目录增删改';
Update zlProgFuncs set 说明='增加、删除、修改西成药品种的权限。有该权限时，允许对西成药品种进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理西成药品种';
Update zlProgFuncs set 说明='增加、删除、修改中成药品种的权限。有该权限时，允许对西成药品种进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理中成药品种';
Update zlProgFuncs set 说明='增加、删除、修改中草药品种的权限。有该权限时，允许对西成药品种进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理中草药品种';
Update zlProgFuncs set 说明='增加、删除、修改西成药规格的权限。有该权限时，允许对西成药规格进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理西成药规格';
Update zlProgFuncs set 说明='增加、删除、修改中成药规格的权限。有该权限时，允许对中成药规格进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理中成药规格';
Update zlProgFuncs set 说明='增加、删除、修改中草药规格的权限。有该权限时，允许对西成药品种进行增加、删除、修改' where 系统=&n_System and 序号=1023 and 功能='管理中草药规格';
Update zlProgFuncs set 说明='药品停用的权限。此权限与（管理西成药（中成药、中草药）；管理西成药品种（中草药品种、中草药品种）；管理西成药规格（中成药规格、中草药规格））权限结合起来使用，当具有该权限则能做对应分类、品种、规格停用。' where 系统=&n_System and 序号=1023 and 功能='药品停用';
Update zlProgFuncs set 说明='药品启用的权限。此权限与（管理西成药（中成药、中草药）；管理西成药品种（中草药品种、中草药品种）；管理西成药规格（中成药规格、中草药规格））权限结合起来使用，当具有该权限则能做对应分类、品种、规格启用。' where 系统=&n_System and 序号=1023 and 功能='药品启用'; 


--101279:李业庆,2016-11-04,高值卫材查询出院病人
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1712, '基本', User, '病案主页', 'SELECT'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1712 And 功能 = '基本' And 对象 = '病案主页');   

--102600:梁经伙,2016-11-15,关联授权脚本，把9001和电子病案查阅1259模块关联
Insert Into Zlmodulerelas
  (系统, 模块, 功能, 相关系统, 相关模块, 相关类型, 相关功能, 缺省值)
  Select &n_System, 9001, Null, &n_System, 1259, 1, '基本', 1
  From Dual
  Where Not Exists
   (Select 1 From Zlmodulerelas Where 系统 = &n_System And 模块 = 9001 And 相关模块 = 1259 And 相关功能 = '基本');

--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '停诊', User, 'Zl_临床出诊序号控制_开放挂号', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1114 And 功能 = '停诊' And Upper(对象) = Upper('Zl_临床出诊序号控制_开放挂号'));

--101414:冉俊明,2016-10-18,出诊表另存为模板功能调整
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1114, '模板管理', User, 'Zl_临床出诊表_Totemplet', 'EXECUTE'
  From Dual
  Where Not Exists
   (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1114 And 功能 = '模板管理' And Upper(对象) = Upper('Zl_临床出诊表_Totemplet'));

-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------
--86191:张德婷,2016-12-06,处方审查报表
--报表：ZL1_BILL_1341_9/医嘱更改通知单
Insert Into zlReports(ID,编号,名称,说明,密码,打印机,进纸,票据,打印方式,系统,程序ID,功能,修改时间,发布时间,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1341_9','医嘱更改通知单','提供审核未通过的药品退费的依据','W~?kFx8cc$(Hu>}}Z/BT',Null,15,1,0,100,Null,Null,Sysdate,Sysdate,To_Date('2015-09-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2015-09-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,100,1341,'医嘱更改通知单');
Insert Into zlRPTFmts(报表ID,序号,说明,W,H,纸张,纸向,动态纸张,图样) Values(zlReports_ID.CurrVal,1,'处方退药通知单',16134,16832,256,1,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'退费通知单','序号,131|姓名,202|性别,202|住院号,131|审核人,202|审核日期,202|药品名称,202|规格,202|付,139|单位,202|数量,139|单价,139|金额,139|科室,202|理由,202',User||'.收费项目别名,'||User||'.药品收发记录,'||User||'.门诊费用记录,'||User||'.收费项目目录,'||User||'.药品规格,'||User||'.诊疗项目目录,'||User||'.部门表,'||User||'.处方审查明细,'||User||'.处方审查记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select Distinct N.序号,' From Dual Union All
  Select 2,'                N.姓名,' From Dual Union All
  Select 3,'                N.性别,' From Dual Union All
  Select 4,'                N.标识号 as 住院号,' From Dual Union All
  Select 5,'                Y.审核人,' From Dual Union All
  Select 6,'                To_Char(Y.审核日期, ''yyyy-MM-dd hh24:mi:ss'') 审核日期,' From Dual Union All
  Select 7,'                ''【'' || D.编码 || ''】'' ||' From Dual Union All
  Select 8,'                Decode(A.名称, NULL, X.名称, A.名称) 药品名称,' From Dual Union All
  Select 9,'                Decode(D.规格,' From Dual Union All
  Select 10,'                       null,' From Dual Union All
  Select 11,'                       D.产地,' From Dual Union All
  Select 12,'                       Decode(D.产地, Null, D.规格, D.规格 || ''|'' || D.产地)) 规格,' From Dual Union All
  Select 13,'                Nvl(Y.付数, 1) 付,' From Dual Union All
  Select 14,'                Decode(''[1]'',''C.门诊包装'',C.门诊单位,C.住院单位) as 单位,' From Dual Union All
  Select 15,'                Abs(Round(Y.实际数量 / [1], 3)) 数量,' From Dual Union All
  Select 16,'                Round(Y.零售价 * [1], 4) 单价,' From Dual Union All
  Select 17,'                Abs(Y.零售金额) 金额,' From Dual Union All
  Select 18,'				M.名称 科室,' From Dual Union All
  Select 19,'				Q.综合理由 理由' From Dual Union All
  Select 20,'  From 药品收发记录 Y, ' From Dual Union All
  Select 21,'       门诊费用记录 N, ' From Dual Union All
  Select 22,'       收费项目目录 D, ' From Dual Union All
  Select 23,'       药品规格 C,' From Dual Union All
  Select 24,'       诊疗项目目录 X, ' From Dual Union All
  Select 25,'       部门表 M,处方审查明细 P,处方审查记录 Q,' From Dual Union All
  Select 26,'       (SELECT * FROM 收费项目别名 WHERE 性质=3 AND 码类<>2) A' From Dual Union All
  Select 27,' Where Q.id = P.审方id and M.id=n.病人科室id and N.医嘱序号=P.医嘱id And Y.费用ID = N.ID(+) and Nvl(N.费用状态(+),0)<>1' From Dual Union All
  Select 28,'       AND Y.NO=[0] and Y.单据=8' From Dual Union All
  Select 29,'       And Y.库房id=[2]' From Dual Union All
  Select 30,'       And Y.药品ID = D.ID' From Dual Union All
  Select 31,'       And D.ID=C.药品ID ' From Dual Union All
  Select 32,'       AND C.药名ID = X.ID ' From Dual Union All
  Select 33,'       And C.药品ID = A.收费细目ID(+)' From Dual Union All
  Select 34,' ' From Dual Union All
  Select 35,' ' From Dual Union All
  Select 36,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,1,'包装系数',3,'固定值列表…',0,'√门诊包装,c.门诊包装|住院包装,C.住院包装',Null,Null,Null,Null,Null,0);
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,2,'发药库房',1,'选择器定义…',0,Null,Null,'Select ID,''(''||编码||'')''||名称 库房
From 部门表
Where id In (Select 部门id From 部门性质说明
	Where 工作性质 In (''中药房'',''西药房'',''成药房''))
	and (撤档时间 is null or 撤档时间 = to_date(''3000-01-01'',''YYYY-MM-DD''))
Order by 库房',Null,'ID,131,'||CHR(38)||'B|库房,202,'||CHR(38)||'S'||CHR(38)||'D',User||'.部门性质说明,'||User||'.部门表|',0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签5',2,Null,0,'任意表1',21,'审核人:[退费通知单.审核人]',Null,405,5278,2340,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签7',2,Null,0,Null,0,'病人科室：',Null,495,1575,900,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签13',2,Null,0,Null,0,'退费理由：',Null,510,2010,900,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签8',2,Null,0,Null,0,'[退费通知单.科室]',Null,1515,1575,1530,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签14',2,Null,0,Null,0,'[退费通知单.理由]',Null,1515,1980,1530,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'单位名称',2,Null,0,'任意表1',12,'[单位名称]医嘱更改通知单',Null,3210,960,4530,375,0,1,1,'宋体',18,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签6',2,Null,0,'任意表1',23,'审核日期:[退费通知单.审核日期]',Null,7105,5263,2700,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签9',2,Null,0,Null,0,'姓名：',Null,7545,1560,540,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签10',2,Null,0,Null,0,'[退费通知单.姓名]',Null,8175,1560,1530,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,'退费通知单',Null,405,2328,9400,2760,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[退费通知单.药品名称]','4^255^药品名称',0,0,2325,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[退费通知单.规格]','4^255^规格',0,0,1110,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[退费通知单.付]','4^255^付',0,0,330,0,255,2,0,'宋体',0,0,0,0,0,0,0,Null,'#####0',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[退费通知单.单位]','4^255^单位',0,0,660,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[退费通知单.数量]','4^255^数量',0,0,1005,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,'#####0.000;-#####0.000; ;',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[退费通知单.单价]','4^255^单价',0,0,1005,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,'#####0.0000;-#####0.0000; ;',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[退费通知单.金额]','4^255^金额',0,0,1005,0,0,2,0,'宋体',0,0,0,0,0,0,0,Null,'#####0.00;-#####0.00; ;',Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1341_9/医嘱更改通知单
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1341,'医嘱更改通知单','提供审核未通过的药品退费的依据');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1341,'医嘱更改通知单',User,'部门表','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'部门性质说明','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'处方审查记录','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'处方审查明细','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'门诊费用记录','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'收费项目别名','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'收费项目目录','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'药品规格','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'药品收发记录','SELECT' From Dual Union All
  Select 100,1341,'医嘱更改通知单',User,'诊疗项目目录','SELECT' From Dual;


--68694:刘尔旋,2016-8-17,新挂号安排修改
--报表：ZL1_INSIDE_1114_1/固定出诊表
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1114_1','固定出诊表','固定出诊表','I`;g$oi|}90Fiql4H+LL',15,Null,0,&n_System,1114,'固定出诊表',Sysdate,Sysdate,0,To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'固定出诊表',0,11904,16832,9,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'出诊表名','出诊表名,202',User||'.临床出诊表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select 出诊表名 From 临床出诊表 Where 排班方式=0 And ID=[0]' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'临床出诊表_数据','科室名称,202|项目名称,202|医生姓名,202|周一,202|周二,202|周三,202|周四,202|周五,202|周六,202|周日,202',User||'.临床出诊表,'||User||'.临床出诊安排,'||User||'.临床出诊限制,'||User||'.临床出诊号源,'||User||'.部门表,'||User||'.收费项目目录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select e.名称 As 科室名称, f.名称 As 项目名称, b.医生姓名, ' From Dual Union All
  Select 2,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周一'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周一,' From Dual Union All
  Select 3,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周二'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周二,' From Dual Union All
  Select 4,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周三'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周三,' From Dual Union All
  Select 5,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周四'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周四,' From Dual Union All
  Select 6,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周五'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周五,' From Dual Union All
  Select 7,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周六'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周六,' From Dual Union All
  Select 8,'       f_List2str(Cast(Collect(Decode(c.限制项目, ''周日'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As 周日' From Dual Union All
  Select 9,'From 临床出诊表 A, 临床出诊安排 B, 临床出诊限制 C, 临床出诊号源 D, 部门表 E, 收费项目目录 F' From Dual Union All
  Select 10,'Where a.Id = b.出诊id And b.Id = c.安排id(+) And b.号源id = d.Id And d.科室id = e.Id And b.项目id = f.Id And a.排班方式 = 0 And' From Dual Union All
  Select 11,'      a.Id = [0]  ' From Dual Union All
  Select 12,'Group By e.名称, f.名称, b.医生姓名' From Dual Union All
  Select 13,'Order By e.名称, f.名称, b.医生姓名' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'任意表1',21,'发布人:[操作员姓名]',Null,150,6460,1710,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,Null,0,'[出诊表名.出诊表名]',Null,3960,435,2895,300,0,0,1,'宋体',14,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,'任意表1',23,'发布日期:[yyyy-mm-dd]',Null,9825,6460,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,Null,Null,150,930,11565,5430,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[临床出诊表_数据.科室名称]','4^255^科室',0,0,1320,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[临床出诊表_数据.项目名称]','4^255^项目',0,0,1800,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[临床出诊表_数据.医生姓名]','4^255^医生',0,0,1110,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[临床出诊表_数据.周一]','4^255^周一',0,0,1050,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[临床出诊表_数据.周二]','4^255^周二',0,0,945,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[临床出诊表_数据.周三]','4^255^周三',0,0,1080,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[临床出诊表_数据.周四]','4^255^周四',0,0,975,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,7,Null,Null,'[临床出诊表_数据.周五]','4^255^周五',0,0,960,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[临床出诊表_数据.周六]','4^255^周六',0,0,975,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[临床出诊表_数据.周日]','4^255^周日',0,0,1095,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_INSIDE_1114_1/固定出诊表
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1114,'固定出诊表','打印固定出诊表');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1114,'固定出诊表',User,'部门表','SELECT' From Dual Union All
  Select &n_System,1114,'固定出诊表',User,'临床出诊安排','SELECT' From Dual Union All
  Select &n_System,1114,'固定出诊表',User,'临床出诊表','SELECT' From Dual Union All
  Select &n_System,1114,'固定出诊表',User,'临床出诊号源','SELECT' From Dual Union All
  Select &n_System,1114,'固定出诊表',User,'临床出诊限制','SELECT' From Dual Union All
  Select &n_System,1114,'固定出诊表',User,'收费项目目录','SELECT' From Dual;

--报表：ZL1_INSIDE_1114_2/月出诊表
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1114_2','月出诊表','月出诊表','Wg"|?kw}~8-@sht1V+LL',15,'发送至 OneNote 2010',0,&n_System,1114,'月出诊表',Sysdate,Sysdate,0,To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'月出诊表(31日)',0,21563,11906,256,1,0);
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,2,'月出诊表(30日)',0,20843,11906,256,1,0);
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,3,'月出诊表(29日)',0,20258,11906,256,1,0);
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,4,'月出诊表(28日)',0,19778,11906,256,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'出诊表名','出诊表名,202',User||'.临床出诊表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select 出诊表名 From 临床出诊表 Where ID=[0] And 排班方式=1' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'临床出诊表_数据','科室名称,202|项目名称,202|医生姓名,202|C1,202|C2,202|C3,202|C4,202|C5,202|C6,202|C7,202|C8,202|C9,202|C10,202|C11,202|C12,202|C13,202|C14,202|C15,202|C16,202|C17,202|C18,202|C19,202|C20,202|C21,202|C22,202|C23,202|C24,202|C25,202|C26,202|C27,202|C28,202|C29,202|C30,202|C31,202',User||'.临床出诊安排,'||User||'.临床出诊表,'||User||'.临床出诊记录,'||User||'.临床出诊号源,'||User||'.部门表,'||User||'.收费项目目录',1,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select e.名称 As 科室名称, f.名称 As 项目名称, b.医生姓名, ' From Dual Union All
  Select 2,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''01'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C1,' From Dual Union All
  Select 3,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''02'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C2,' From Dual Union All
  Select 4,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''03'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C3,' From Dual Union All
  Select 5,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''04'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C4,' From Dual Union All
  Select 6,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''05'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C5,' From Dual Union All
  Select 7,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''06'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C6,' From Dual Union All
  Select 8,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''07'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C7,' From Dual Union All
  Select 9,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''08'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C8,' From Dual Union All
  Select 10,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''09'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C9,' From Dual Union All
  Select 11,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''10'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C10,' From Dual Union All
  Select 12,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''11'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C11,' From Dual Union All
  Select 13,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''12'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C12,' From Dual Union All
  Select 14,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''13'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C13,' From Dual Union All
  Select 15,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''14'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C14,' From Dual Union All
  Select 16,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''15'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C15,' From Dual Union All
  Select 17,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''16'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C16,' From Dual Union All
  Select 18,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''17'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C17,' From Dual Union All
  Select 19,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''18'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C18,' From Dual Union All
  Select 20,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''19'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C19,' From Dual Union All
  Select 21,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''20'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C20,' From Dual Union All
  Select 22,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''21'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C21,' From Dual Union All
  Select 23,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''22'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C22,' From Dual Union All
  Select 24,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''23'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C23,' From Dual Union All
  Select 25,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''24'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C24,' From Dual Union All
  Select 26,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''25'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C25,' From Dual Union All
  Select 27,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''26'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C26,' From Dual Union All
  Select 28,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''27'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C27,' From Dual Union All
  Select 29,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''DD''), ''28'', c.上班时段, Null)) As t_Strlist), ''/'', 1) As C28,' From Dual Union All
  Select 30,'       f_List2str(Cast(Collect(Case' From Dual Union All
  Select 31,'                                 When To_Number(To_Char(Last_Day(c.出诊日期), ''DD'')) < 29 Then' From Dual Union All
  Select 32,'                                  Null' From Dual Union All
  Select 33,'                                 Else' From Dual Union All
  Select 34,'                                  Decode(To_Char(c.出诊日期, ''DD''), ''29'', c.上班时段, '' '')' From Dual Union All
  Select 35,'                               End) As t_Strlist), ''/'', 1) As C29,' From Dual Union All
  Select 36,'       f_List2str(Cast(Collect(Case' From Dual Union All
  Select 37,'                                 When To_Number(To_Char(Last_Day(c.出诊日期), ''DD'')) < 30 Then' From Dual Union All
  Select 38,'                                  Null' From Dual Union All
  Select 39,'                                 Else' From Dual Union All
  Select 40,'                                  Decode(To_Char(c.出诊日期, ''DD''), ''30'', c.上班时段, '' '')' From Dual Union All
  Select 41,'                               End) As t_Strlist), ''/'', 1) As C30,' From Dual Union All
  Select 42,'       f_List2str(Cast(Collect(Case' From Dual Union All
  Select 43,'                                 When To_Number(To_Char(Last_Day(c.出诊日期), ''DD'')) < 31 Then' From Dual Union All
  Select 44,'                                  Null' From Dual Union All
  Select 45,'                                 Else' From Dual Union All
  Select 46,'                                  Decode(To_Char(c.出诊日期, ''DD''), ''31'', c.上班时段, '' '')' From Dual Union All
  Select 47,'                               End) As t_Strlist), ''/'', 1) As C31' From Dual Union All
  Select 48,'From 临床出诊安排 B, 临床出诊表 A, 临床出诊记录 C, 临床出诊号源 D, 部门表 E, 收费项目目录 F' From Dual Union All
  Select 49,'Where b.Id = c.安排id(+) And b.号源id = d.Id And b.出诊id = a.Id And b.项目id = f.Id And' From Dual Union All
  Select 50,'      d.科室id = e.Id And a.排班方式 = 1 And a.Id = [0]' From Dual Union All
  Select 51,'Group By e.名称, f.名称, b.医生姓名' From Dual Union All
  Select 52,'Order By e.名称, f.名称, b.医生姓名' From Dual Union All
  Select 53,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'任意表1',21,'发布人:[操作员姓名]',Null,150,6520,1710,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',12,'[出诊表名.出诊表名]',Null,9302,165,3150,300,0,0,1,'宋体',14,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,'任意表1',23,'发布时间:[yyyy-mm-dd]',Null,19458,6520,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,Null,Null,150,615,21198,5805,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,7,Null,Null,'[临床出诊表_数据.C5]','4^300^5^0^0',0,0,495,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,0,Null,Null,'[临床出诊表_数据.科室名称]','4^300^科室^0^0',0,0,1305,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,1,Null,Null,'[临床出诊表_数据.项目名称]','4^300^项目^0^0',0,0,1965,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,2,Null,Null,'[临床出诊表_数据.医生姓名]','4^300^医生^0^0',0,0,1110,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,3,Null,Null,'[临床出诊表_数据.C1]','4^300^1^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,4,Null,Null,'[临床出诊表_数据.C2]','4^300^2^0^0',0,0,555,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,5,Null,Null,'[临床出诊表_数据.C3]','4^300^3^0^0',0,0,495,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,6,Null,Null,'[临床出诊表_数据.C4]','4^300^4^0^0',0,0,480,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[临床出诊表_数据.C6]','4^300^6^0^0',0,0,495,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[临床出诊表_数据.C7]','4^300^7^0^0',0,0,510,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-11,10,Null,Null,'[临床出诊表_数据.C8]','4^300^8^0^0',0,0,465,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-12,11,Null,Null,'[临床出诊表_数据.C9]','4^300^9^0^0',0,0,510,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-13,12,Null,Null,'[临床出诊表_数据.C10]','4^300^10^0^0',0,0,465,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-14,13,Null,Null,'[临床出诊表_数据.C11]','4^300^11^0^0',0,0,480,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-15,14,Null,Null,'[临床出诊表_数据.C12]','4^300^12^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-16,15,Null,Null,'[临床出诊表_数据.C13]','4^300^13^0^0',0,0,540,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-17,16,Null,Null,'[临床出诊表_数据.C14]','4^300^14^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-18,17,Null,Null,'[临床出诊表_数据.C15]','4^300^15^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-19,18,Null,Null,'[临床出诊表_数据.C16]','4^300^16^0^0',0,0,540,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-20,19,Null,Null,'[临床出诊表_数据.C17]','4^300^17^0^0',0,0,540,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-21,20,Null,Null,'[临床出诊表_数据.C18]','4^300^18^0^0',0,0,570,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-22,21,Null,Null,'[临床出诊表_数据.C19]','4^300^19^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-23,22,Null,Null,'[临床出诊表_数据.C20]','4^300^20^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-24,23,Null,Null,'[临床出诊表_数据.C21]','4^300^21^0^0',0,0,570,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-25,24,Null,Null,'[临床出诊表_数据.C22]','4^300^22^0^0',0,0,585,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-26,25,Null,Null,'[临床出诊表_数据.C23]','4^300^23^0^0',0,0,600,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-27,26,Null,Null,'[临床出诊表_数据.C24]','4^300^24^0^0',0,0,615,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-28,27,Null,Null,'[临床出诊表_数据.C25]','4^300^25^0^0',0,0,570,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-29,28,Null,Null,'[临床出诊表_数据.C26]','4^300^26^0^0',0,0,540,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-30,29,Null,Null,'[临床出诊表_数据.C27]','4^300^27^0^0',0,0,570,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-31,30,Null,Null,'[临床出诊表_数据.C28]','4^300^28^0^0',0,0,585,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-32,31,Null,Null,'[临床出诊表_数据.C29]','4^300^29^0^0',0,0,525,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-33,32,Null,Null,'[临床出诊表_数据.C30]','4^300^30^0^0',0,0,585,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-34,33,Null,Null,'[临床出诊表_数据.C31]','4^300^31^0^0',0,0,585,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_INSIDE_1114_2/月出诊表
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1114,'月出诊表','打印月出诊表');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1114,'月出诊表',User,'部门表','SELECT' From Dual Union All
  Select &n_System,1114,'月出诊表',User,'临床出诊安排','SELECT' From Dual Union All
  Select &n_System,1114,'月出诊表',User,'临床出诊表','SELECT' From Dual Union All
  Select &n_System,1114,'月出诊表',User,'临床出诊号源','SELECT' From Dual Union All
  Select &n_System,1114,'月出诊表',User,'临床出诊记录','SELECT' From Dual Union All
  Select &n_System,1114,'月出诊表',User,'收费项目目录','SELECT' From Dual;

--报表：ZL1_INSIDE_1114_3/周出诊表
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1114_3','周出诊表','周出诊表','Tg"}<kw}}8-@pht1T+LL',15,Null,0,&n_System,1114,'周出诊表',Sysdate,Sysdate,0,To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'周出诊表',0,11904,16832,9,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'出诊表名','出诊表名,202',User||'.临床出诊表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select 出诊表名 From 临床出诊表 Where 排班方式=2 And ID=[0]' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'临床出诊表_数据','科室名称,202|项目名称,202|医生姓名,202|C1,202|C2,202|C3,202|C4,202|C5,202|C6,202|C7,202',User||'.临床出诊表,'||User||'.临床出诊安排,'||User||'.临床出诊记录,'||User||'.临床出诊号源,'||User||'.部门表,'||User||'.收费项目目录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select e.名称 As 科室名称, f.名称 As 项目名称, b.医生姓名, ' From Dual Union All
  Select 2,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 2, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C1,' From Dual Union All
  Select 3,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 3, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C2,' From Dual Union All
  Select 4,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 4, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C3,' From Dual Union All
  Select 5,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 5, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C4,' From Dual Union All
  Select 6,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 6, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C5,' From Dual Union All
  Select 7,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 7, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C6,' From Dual Union All
  Select 8,'       f_List2str(Cast(Collect(Decode(To_Char(c.出诊日期, ''D''), 1, c.上班时段, Null)) As t_Strlist), ''/'', 1) As C7' From Dual Union All
  Select 9,'From 临床出诊表 A, 临床出诊安排 B, 临床出诊记录 C, 临床出诊号源 D, 部门表 E, 收费项目目录 F' From Dual Union All
  Select 10,'Where a.Id = b.出诊id And b.号源id = d.Id And b.Id = c.安排id(+) And d.科室id = e.Id And b.项目id = f.Id And a.排班方式 = 2 And' From Dual Union All
  Select 11,'      a.Id = [0]' From Dual Union All
  Select 12,'Group By e.名称, f.名称, b.医生姓名' From Dual Union All
  Select 13,'Order By e.名称, f.名称, b.医生姓名' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'日期','C1,202|C2,202|C3,202|C4,202|C5,202|C6,202|C7,202',User||'.临床出诊表,'||User||'.临床出诊安排,'||User||'.临床出诊记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select To_Char(Trunc(出诊日期, ''d'') + 1, ''DD'') As C1, To_Char(Trunc(出诊日期, ''d'') + 2, ''DD'') As C2,' From Dual Union All
  Select 2,'       To_Char(Trunc(出诊日期, ''d'') + 3, ''DD'') As C3, To_Char(Trunc(出诊日期, ''d'') + 4, ''DD'') As C4,' From Dual Union All
  Select 3,'       To_Char(Trunc(出诊日期, ''d'') + 5, ''DD'') As C5, To_Char(Trunc(出诊日期, ''d'') + 6, ''DD'') As C6,' From Dual Union All
  Select 4,'       To_Char(Trunc(出诊日期, ''d'') + 7, ''DD'') As C7' From Dual Union All
  Select 5,'From (Select c.出诊日期' From Dual Union All
  Select 6,'       From 临床出诊表 A, 临床出诊安排 B, 临床出诊记录 C' From Dual Union All
  Select 7,'       Where a.Id = b.出诊id And b.Id = c.安排id(+) And a.排班方式 = 2 And a.Id = [0]' From Dual Union All
  Select 8,'			And c.出诊日期 Is Not Null And Rownum < 2)' From Dual Union All
  Select 9,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签2',2,Null,0,'任意表1',21,'发布人:[操作员姓名]',Null,210,4720,1710,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',12,'[出诊表名.出诊表名]',Null,4522,195,2895,300,0,0,1,'宋体',14,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签3',2,Null,0,'任意表1',23,'发布日期:[yyyy-mm-dd]',Null,9840,4720,1890,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,Null,Null,210,660,11520,3960,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[临床出诊表_数据.科室名称]','4^600^科室^0^0',0,0,1350,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[临床出诊表_数据.项目名称]','4^600^项目^0^0',0,0,1710,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,2,Null,Null,'[临床出诊表_数据.医生姓名]','4^600^医生^0^0',0,0,1350,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,3,Null,Null,'[临床出诊表_数据.C1]','4^600^周一
[日期.C1]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,4,Null,Null,'[临床出诊表_数据.C2]','4^600^周二
[日期.C2]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,5,Null,Null,'[临床出诊表_数据.C3]','4^600^周三
[日期.C3]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,6,Null,Null,'[临床出诊表_数据.C4]','4^600^周四
[日期.C4]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,7,Null,Null,'[临床出诊表_数据.C5]','4^600^周五
[日期.C5]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,8,Null,Null,'[临床出诊表_数据.C6]','4^600^周六
[日期.C6]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,9,Null,Null,'[临床出诊表_数据.C7]','4^600^周日
[日期.C7]^0^0',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_INSIDE_1114_3/周出诊表
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1114,'周出诊表','打印周出诊表');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1114,'周出诊表',User,'部门表','SELECT' From Dual Union All
  Select &n_System,1114,'周出诊表',User,'临床出诊安排','SELECT' From Dual Union All
  Select &n_System,1114,'周出诊表',User,'临床出诊表','SELECT' From Dual Union All
  Select &n_System,1114,'周出诊表',User,'临床出诊号源','SELECT' From Dual Union All
  Select &n_System,1114,'周出诊表',User,'临床出诊记录','SELECT' From Dual Union All
  Select &n_System,1114,'周出诊表',User,'收费项目目录','SELECT' From Dual;

--报表：ZL1_INSIDE_1114_4/病人预约清单
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1114_4','病人预约清单','病人预约清单','Lv!a7lom~"'||CHR(38)||'Fhyw*X,T\',15,'发送至 OneNote 2010',0,&n_System,1114,'病人预约清单',Sysdate,Sysdate,0,To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2016-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'病人预约清单',0,11906,16838,9,2,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'病人挂号记录_数据','姓名,202|性别,202|年龄,202|家庭地址,202|家庭电话,202|号别,202|号码,202|科室,202|收费项目,202|医生,202|替诊医生,202|预约单号,202|预约时间,135',User||'.病人挂号记录,'||User||'.病人信息,'||User||'.临床出诊号源,'||User||'.临床出诊记录,'||User||'.部门表,'||User||'.收费项目目录,'||User||'.病人服务信息记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select a.姓名, a.性别, a.年龄, b.家庭地址, b.家庭电话, c.号类 As 号别, c.号码, e.名称 As 科室, f.名称 As 收费项目, d.医生姓名 As 医生, d.替诊医生姓名 As 替诊医生,' From Dual Union All
  Select 2,'       a.No As 预约单号, a.发生时间 As 预约时间' From Dual Union All
  Select 3,'From 病人挂号记录 A, 病人信息 B, 临床出诊号源 C, 临床出诊记录 D, 部门表 E, 收费项目目录 F, 病人服务信息记录 G' From Dual Union All
  Select 4,'Where a.id = g.挂号id And g.通知类型 In (1,2) And a.记录状态 = 1 And a.病人id = b.病人id(+) And' From Dual Union All
  Select 5,'      g.记录id = d.Id And d.号源id = c.Id And d.科室id = e.Id And d.项目id = f.Id And g.记录id In (Select Column_Value From Table(f_Str2list([0])))' From Dual Union All
  Select 6,Null From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'出诊记录IDS',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签1',2,Null,0,'任意表1',12,'病人预约清单',Null,7545,195,1800,300,0,0,1,'宋体',14,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'任意表1',4,Null,0,Null,0,Null,Null,180,645,16530,4545,255,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,6,Null,Null,'[病人挂号记录_数据.号码]','4^315^号码',0,0,810,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,7,Null,Null,'[病人挂号记录_数据.科室]','4^315^科室',0,0,1440,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-3,8,Null,Null,'[病人挂号记录_数据.收费项目]','4^315^收费项目',0,0,1620,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-4,9,Null,Null,'[病人挂号记录_数据.医生]','4^315^医生',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-5,10,Null,Null,'[病人挂号记录_数据.替诊医生]','4^315^替诊医生',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-6,11,Null,Null,'[病人挂号记录_数据.预约单号]','4^315^预约单号',0,0,1005,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-7,12,Null,Null,'[病人挂号记录_数据.预约时间]','4^315^预约时间',0,0,1665,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-8,0,Null,Null,'[病人挂号记录_数据.姓名]','4^315^姓名',0,0,1140,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-9,1,Null,Null,'[病人挂号记录_数据.性别]','4^315^性别',0,0,705,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-10,2,Null,Null,'[病人挂号记录_数据.年龄]','4^315^年龄',0,0,855,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-11,3,Null,Null,'[病人挂号记录_数据.家庭地址]','4^315^家庭地址',0,0,2850,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-12,4,Null,Null,'[病人挂号记录_数据.家庭电话]','4^315^联系电话',0,0,1500,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-13,5,Null,Null,'[病人挂号记录_数据.号别]','4^315^号别',0,0,840,0,0,0,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,0,0,0,Null,Null,Null,Null,Null,Null,Null);

--报表：ZL1_INSIDE_1114_4/病人预约清单
Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1114,'病人预约清单','打印病人预约清单');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select &n_System,1114,'病人预约清单',User,'病人服务信息记录','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'病人挂号记录','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'病人信息','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'部门表','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'临床出诊号源','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'临床出诊记录','SELECT' From Dual Union All
  Select &n_System,1114,'病人预约清单',User,'收费项目目录','SELECT' From Dual;

--93185:涂建华,2016-07-07,增加免疫鉴别报表
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_INSIDE_1294_15','病理过程报告(免疫鉴别)','病理过程报告免疫鉴别报告','Lh*~$ohem95Nn`l4A$\L',15,Null,0,100,Null,Null,Sysdate,Sysdate,0,Sysdate,Sysdate);
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,&n_System,1294,'病理过程报告(免疫鉴别)');
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'免疫组化报告',0,11904,16832,9,1,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条12',1,Null,0,Null,0,Null,Null,765,2565,10095,15,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条9',1,Null,0,Null,0,Null,Null,1000,14065,10080,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签67',2,Null,0,Null,0,'姓名：',Null,915,2760,765,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签70',2,Null,0,Null,0,'疗区：',Null,915,3390,765,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签46',2,Null,0,Null,0,'病理诊断：',Null,915,4005,1275,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签47',2,Null,0,Null,0,'[报告内容.检查意见]',Null,915,4350,10245,705,0,0,0,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签44',2,Null,0,Null,0,'检查结果：',Null,990,8610,1275,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签45',2,Null,0,Null,0,'[报告内容.检查结果]',Null,990,8970,10170,4002,0,0,0,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签73',2,Null,0,Null,0,'*该检查为恶性肿瘤病人的个体化化疗提供最新的依据，仅供参考。',Null,1470,14955,5310,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签38',2,Null,0,Null,0,'[报告基本信息.姓名]',Null,1485,2760,2280,255,0,0,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签42',2,Null,0,Null,0,'[报告基本信息.开嘱科室]',Null,1500,3405,2760,255,0,0,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签49',2,Null,0,Null,0,'报告医师:[报告内容.报告医师]',Null,1635,14325,2940,210,0,0,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签35',2,Null,0,Null,0,'XXX 市 中 心 医 院',Null,3336,1116,4632,444,0,1,0,'宋体',22,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签36',2,Null,0,Null,0,'免疫鉴别检测报告单',Null,3984,1920,3348,360,0,0,1,'宋体',18,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签68',2,Null,0,Null,0,'性别：',Null,3855,2775,765,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签71',2,Null,0,Null,0,'住院号：',Null,3915,3390,1020,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签39',2,Null,0,Null,0,'[报告基本信息.性别]',Null,4650,2775,2280,255,0,0,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签52',2,Null,0,Null,0,'[报告基本信息.住院号]',Null,4800,3420,2520,255,0,2,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签50',2,Null,0,Null,0,'报告日期:[报告内容.报告日期]',Null,6855,14340,2940,210,0,1,1,'宋体',10.5,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签69',2,Null,0,Null,0,'年龄：',Null,7500,2805,765,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签72',2,Null,0,Null,0,'病理号：',Null,7515,3420,1020,255,0,0,1,'宋体',12,1,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签37',2,Null,0,Null,0,'[报告基本信息.病理号]',Null,8400,3435,2205,255,0,0,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标签40',2,Null,0,Null,0,'[报告基本信息.年龄]',Null,8415,2805,2280,255,0,0,1,'宋体',12,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'pic1',11,Null,0,Null,0,Null,Null,1470,5505,3570,2595,0,0,0,'宋体',9,0,0,1,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'pic2',11,Null,0,Null,0,Null,Null,6200,5495,3705,2625,0,0,0,'宋体',9,0,0,1,0,16777215,0,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'报告基本信息','病理号,202|姓名,202|性别,202|年龄,202|开嘱科室,202|开嘱医生,202|住院号,131',User||'.病理检查信息,'||User||'.病人医嘱记录,'||User||'.病人信息,'||User||'.部门表',0,'查询过程报告所需要的基本信息');
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,1,'select a.病理号,c.姓名, c.性别, c.年龄,d.名称 as 开嘱科室,b.开嘱医生,c.住院号');
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,2,'from 病理检查信息 a, 病人医嘱记录 b, 病人信息 c, 部门表 d'); 
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,3,'where a.医嘱id=b.id and b.病人id=c.病人id and b.开嘱科室id = d.id and a.病理号=[0]');
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'病理号',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'报告内容','标本名称,202|检查结果,202|检查意见,202|报告医师,202|报告日期,135|备注,202',User||'.病理过程报告',0,'查询过程报告的内容');
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,1,'select 标本名称,检查结果,检查意见,报告医师,报告日期,备注');
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,2,'from 病理过程报告 ');
Insert Into zlRPTSQLs(源ID,行号,内容) Values(zlRPTDatas_ID.CurrVal,3,'where ID=[0]');
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'过程报告ID',1,Null,0,Null,Null,Null,Null,Null,Null,0);

Insert into zlProgFuncs(系统,序号,功能,说明) Values(&n_System,1294,'病理过程报告(免疫鉴别)','病理过程报告免疫鉴别报告');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1294,'病理过程报告(免疫鉴别)',User,'病理过程报告','SELECT');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1294,'病理过程报告(免疫鉴别)',User,'病理检查信息','SELECT');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1294,'病理过程报告(免疫鉴别)',User,'病人信息','SELECT');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1294,'病理过程报告(免疫鉴别)',User,'病人医嘱记录','SELECT');
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限) Values(&n_System,1294,'病理过程报告(免疫鉴别)',User,'部门表','SELECT');


-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--94399:李小东,2016-12-22,部门、人员扩展信息维护
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;
  --        19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
  Update 部门表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
  Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  End If;

  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--94399:李小东,2016-12-22,部门、人员扩展信息维护
Create Or Replace Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形);8-电子病历附件;9-体温重叠标记;
  --        10-临床路径文件;11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录;19-部门扩展信息;20-人员扩展信息;
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
Begin
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    Return Null;
End Zl_Lob_Read;
/

--99873:刘尔旋,2016-12-22,门诊结帐未执行项目检查
Create Or Replace Function Zl_Pati_Check_Execute
(
  内容_In         Number,
  病人id_In       病人信息.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  婴儿_In         Number := -1,
  检查离院带药_In Number := 0,
  门诊检查_In     Number := 0
) Return Varchar2
--功能：检查病人是否存在未执行完成的内容
  --参数：
  --  内容_IN：1-检查药品和卫材,2-检查其他执行项目,3-检查未发血
  --  婴儿_IN：0=病人，1-N=婴儿，-1=不区分
  --返回：如果存在则返回一定格式的提示信息供程序使用，否则返回空
 As
  v_Text  Varchar2(4000);
  v_Drug  Varchar2(1510);
  v_Stuff Varchar2(1510);
  n_Count Number;
  n_Do    Number;
  n_共享  Number;
  Type t_Bool Is Ref Cursor;
  c_Bool t_Bool;
  v_No   住院费用记录.No%Type;
  v_项目 收费项目目录.名称%Type;
  v_部门 部门表.名称%Type;
  v_扣率 Varchar2(100);
  v_Sql  Varchar2(4000);
  v_Pars Varchar2(4000);
Begin
  If 内容_In = 1 Then
    --以药品收发记录中存在未发药品为准
    If Nvl(门诊检查_In, 0) = 0 Then
      --住院
      For r_Info In (Select Distinct a.No, Decode(a.收费类别, '4', 1, 0) As 卫材, d.名称 项目, c.名称 As 部门, To_Char(b.扣率) As 扣率
                     From 住院费用记录 A, 药品收发记录 B, 部门表 C, 收费项目目录 D
                     Where a.No = b.No And a.Id = b.费用id And a.收费细目id = d.Id And b.库房id + 0 = c.Id(+) And
                           a.收费类别 In ('4', '5', '6', '7') And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And
                           b.审核人 Is Null And a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And
                           (Nvl(a.婴儿费, 0) = 婴儿_In Or 婴儿_In = -1) And Nvl(b.摘要, '大医') <> '拒发') Loop
      
        n_Do := 1;
        If Substr(r_Info.扣率, 2) = '3' Then
          n_Do := 检查离院带药_In;
        End If;
        If n_Do = 1 Then
          If r_Info.卫材 = 0 Then
            If v_Drug Is Not Null Then
              If Instr(Chr(13) || Chr(10) || v_Drug || Chr(13) || Chr(10),
                       Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                        Nvl(r_Info.部门, '[未定药房]') || '未发药' || Chr(13) || Chr(10), 1) = 0 Then
                If Lengthb(v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                           Nvl(r_Info.部门, '[未定药房]') || '未发药') <= 1000 Then
                  v_Drug := v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                            Nvl(r_Info.部门, '[未定药房]') || '未发药';
                Else
                  v_Drug := v_Drug || Chr(13) || Chr(10) || '... ...';
                End If;
              End If;
            Else
              v_Drug := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定药房]') ||
                        '未发药';
            End If;
          Else
            If v_Stuff Is Not Null Then
              If Instr(Chr(13) || Chr(10) || v_Stuff || Chr(13) || Chr(10),
                       Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                        Nvl(r_Info.部门, '[未定部门]') || '未发放' || Chr(13) || Chr(10), 1) = 0 Then
                If Lengthb(v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                           Nvl(r_Info.部门, '[未定部门]') || '未发放') <= 1000 Then
                  v_Stuff := v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' ||
                             Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定部门]') || '未发放';
                Else
                  v_Stuff := v_Stuff || Chr(13) || Chr(10) || '... ...';
                End If;
              End If;
            Else
              v_Stuff := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定部门]') ||
                         '未发放';
            End If;
          End If;
        End If;
      End Loop;
    
      If v_Drug Is Not Null Then
        v_Drug := '存在未发药品：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Drug;
      End If;
      If v_Stuff Is Not Null Then
        v_Stuff := '存在未发放卫材料：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
      End If;
    
      If v_Drug Is Not Null And v_Stuff Is Not Null Then
        v_Text := v_Drug || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
      Elsif v_Drug Is Not Null Then
        v_Text := v_Drug;
      Elsif v_Stuff Is Not Null Then
        v_Text := v_Stuff;
      End If;
    Else
      --门诊
      For r_Info In (Select Distinct a.No, Decode(a.收费类别, '4', 1, 0) As 卫材, d.名称 项目, c.名称 As 部门, To_Char(b.扣率) As 扣率
                     From 门诊费用记录 A, 药品收发记录 B, 部门表 C, 收费项目目录 D
                     Where a.No = b.No And a.Id = b.费用id And a.收费细目id = d.Id And b.库房id + 0 = c.Id(+) And
                           a.收费类别 In ('4', '5', '6', '7') And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And
                           b.审核人 Is Null And a.病人id = 病人id_In And (Nvl(a.婴儿费, 0) = 婴儿_In Or 婴儿_In = -1) And
                           Nvl(b.摘要, '大医') <> '拒发') Loop
      
        n_Do := 1;
        If Substr(r_Info.扣率, 2) = '3' Then
          n_Do := 检查离院带药_In;
        End If;
        If n_Do = 1 Then
          If r_Info.卫材 = 0 Then
            If v_Drug Is Not Null Then
              If Instr(Chr(13) || Chr(10) || v_Drug || Chr(13) || Chr(10),
                       Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                        Nvl(r_Info.部门, '[未定药房]') || '未发药' || Chr(13) || Chr(10), 1) = 0 Then
                If Lengthb(v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                           Nvl(r_Info.部门, '[未定药房]') || '未发药') <= 1000 Then
                  v_Drug := v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                            Nvl(r_Info.部门, '[未定药房]') || '未发药';
                Else
                  v_Drug := v_Drug || Chr(13) || Chr(10) || '... ...';
                End If;
              End If;
            Else
              v_Drug := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定药房]') ||
                        '未发药';
            End If;
          Else
            If v_Stuff Is Not Null Then
              If Instr(Chr(13) || Chr(10) || v_Stuff || Chr(13) || Chr(10),
                       Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                        Nvl(r_Info.部门, '[未定部门]') || '未发放' || Chr(13) || Chr(10), 1) = 0 Then
                If Lengthb(v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                           Nvl(r_Info.部门, '[未定部门]') || '未发放') <= 1000 Then
                  v_Stuff := v_Stuff || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' ||
                             Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定部门]') || '未发放';
                Else
                  v_Stuff := v_Stuff || Chr(13) || Chr(10) || '... ...';
                End If;
              End If;
            Else
              v_Stuff := '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' || Nvl(r_Info.部门, '[未定部门]') ||
                         '未发放';
            End If;
          End If;
        End If;
      End Loop;
    
      If v_Drug Is Not Null Then
        v_Drug := '存在未发药品：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Drug;
      End If;
      If v_Stuff Is Not Null Then
        v_Stuff := '存在未发放卫材料：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
      End If;
    
      If v_Drug Is Not Null And v_Stuff Is Not Null Then
        v_Text := v_Drug || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Stuff;
      Elsif v_Drug Is Not Null Then
        v_Text := v_Drug;
      Elsif v_Stuff Is Not Null Then
        v_Text := v_Stuff;
      End If;
    End If;
  Elsif 内容_In = 2 Then
    --1.医技科室执行的项目,临床会诊
    --2.其他类特殊项目不需管执行
    --3.PACS已报到的(执行过程为">=2-检查中"不作为未执行完成的项目
    If Nvl(门诊检查_In, 0) = 0 Then
      n_Count := 1;
      Select zl_GetSysParameter(234) Into v_Pars From Dual;
      v_Pars := Replace(v_Pars, '|', ',');
      For r_Info In (Select Distinct b.No, c.名称 As 项目, d.名称 As 科室, Decode(Nvl(b.执行状态, 0), 0, '未执行', 3, '正在执行') As 执行状态
                     From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C, 部门表 D
                     Where a.病人id = 病人id_In And Nvl(a.主页id, 0) = 主页id_In And (Nvl(a.婴儿, 0) = 婴儿_In Or 婴儿_In = -1) And
                           a.Id = b.医嘱id And b.执行状态 In (0, 3) And a.诊疗项目id = c.Id And b.执行部门id + 0 = d.Id And
                           a.诊疗类别 Not In ('4', '5', '6', '7') And Not (a.诊疗类别 In ('F', 'D') And a.相关id Is Not Null) And
                           (d.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or d.撤档时间 Is Null) And
                           Not (a.诊疗类别 = 'D' And Nvl(b.执行过程, 0) >= 2) And
                           (Not (a.诊疗类别 = 'Z' And Nvl(c.操作类型, '0') <> '0') Or a.诊疗类别 = 'Z' And c.操作类型 = '7') And
                           c.Id Not In (Select Column_Value From Table(Cast(f_Num2list(v_Pars) As Zltools.t_Numlist)))) Loop
        If Lengthb(v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                   Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态) > 1000 Then
          v_Text := v_Text || Chr(13) || Chr(10) || '... ...';
          Exit;
        Else
          v_Text := v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                    Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态;
        End If;
      
        n_Count := n_Count + 1;
      End Loop;
    
      v_Text := Substr(v_Text, 3);
    Else
      For r_Info In (Select Distinct b.No, c.名称 As 项目, d.名称 As 科室, Decode(Nvl(b.执行状态, 0), 0, '未执行', 3, '正在执行') As 执行状态
                     From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C, 部门表 D
                     Where a.病人id = 病人id_In And a.主页id Is Null And (Nvl(a.婴儿, 0) = 婴儿_In Or 婴儿_In = -1) And
                           a.Id = b.医嘱id And b.执行状态 In (0, 3) And a.诊疗项目id = c.Id And b.执行部门id + 0 = d.Id And
                           a.诊疗类别 Not In ('4', '5', '6', '7') And Not (a.诊疗类别 In ('F', 'D') And a.相关id Is Not Null) And
                           (d.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or d.撤档时间 Is Null) And
                           Not (a.诊疗类别 = 'D' And Nvl(b.执行过程, 0) >= 2) And
                           (Not (a.诊疗类别 = 'Z' And Nvl(c.操作类型, '0') <> '0') Or a.诊疗类别 = 'Z' And c.操作类型 = '7')) Loop
        If Lengthb(v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                   Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态) > 1000 Then
          v_Text := v_Text || Chr(13) || Chr(10) || '... ...';
          Exit;
        Else
          v_Text := v_Text || Chr(13) || Chr(10) || '单据[' || Nvl(r_Info.No, '') || ']中的' || Nvl(r_Info.项目, '') || '：在' ||
                    Nvl(r_Info.科室, '[未定科室]') || r_Info.执行状态;
        End If;
      
        n_Count := n_Count + 1;
      End Loop;
    
      v_Text := Substr(v_Text, 3);
    End If;
  Elsif 内容_In = 3 Then
    v_Text := '';
    v_Drug := '';
    --检查是否安装了血库
    Begin
      Select 1
      Into n_共享
      From zlSystems
      Where Trunc(编号 / 100) = 22 And 所有者 = Sys_Context('USERENV', 'CURRENT_SCHEMA');
    Exception
      When Others Then
        n_共享 := 0;
    End;
    v_Sql := 'Select Distinct a.No, d.名称 项目, c.名称 As 部门, To_Char(b.扣率) As 扣率';
    v_Sql := v_Sql || ' From 住院费用记录 a, 血液收发记录 b, 部门表 c, 收费项目目录 d';
    v_Sql := v_Sql || ' Where a.Id = b.费用id And a.收费细目id = d.Id And b.库房id + 0 = c.Id(+) And a.收费类别 =:1 And b.单据 = 6';
    v_Sql := v_Sql || '  And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And a.病人id =:2 And Nvl(a.主页id, 0) =:3';
    v_Sql := v_Sql || '  And (Nvl(a.婴儿费, 0) =:4 Or -1 =:5) And Nvl(b.摘要,:6) <>:7';
    --共享安装：进行未发血液的检查
    If n_共享 = 1 Then
      Open c_Bool For v_Sql
        Using 'K', 病人id_In, 主页id_In, 婴儿_In, 婴儿_In, '大医', '拒发';
      Loop
        Fetch c_Bool
          Into v_No, v_项目, v_部门, v_扣率;
        Exit When c_Bool%NotFound;
        n_Do := 1;
        If Substr(v_扣率, 2) = '3' Then
          n_Do := 检查离院带药_In;
        End If;
        If n_Do = 1 Then
          If v_Drug Is Not Null Then
            If Instr(Chr(13) || Chr(10) || v_Drug || Chr(13) || Chr(10),
                     Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                      Nvl(v_部门, '[未定血库]') || '未发血' || Chr(13) || Chr(10), 1) = 0 Then
              If Lengthb(v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                         Nvl(v_部门, '[未定血库]') || '未发血') <= 1000 Then
                v_Drug := v_Drug || Chr(13) || Chr(10) || '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' ||
                          Nvl(v_部门, '[未定血库]') || '未发血';
              Else
                v_Drug := v_Drug || Chr(13) || Chr(10) || '... ...';
              End If;
            End If;
          Else
            v_Drug := '单据[' || Nvl(v_No, '') || ']中的' || Nvl(v_项目, '') || '：在' || Nvl(v_部门, '[未定血库]') || '未发血';
          End If;
        End If;
      End Loop;
      Close c_Bool;
      If v_Drug Is Not Null Then
        v_Drug := '存在未发放的血液：' || Chr(13) || Chr(10) || Chr(13) || Chr(10) || v_Drug;
      End If;
      v_Text := v_Drug;
    End If;
  End If;
  Return v_Text;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Pati_Check_Execute;
/

--103209:刘尔旋,2016-12-20,服务窗医保实时结算
Create Or Replace Procedure Zl_Third_Reghistory
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取历史挂号数据
  --入参:Xml_In:
  --<IN>
  --   <BRID>88393</BRID>    //卡号
  --   <JLS>5</JLS >       //记录条数，按日期由近到远
  --   <JSKLB></JSKLB>     //结算卡类别
  --   <ZD></ZD>           //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <GHLIST>       //如果为空表示没有找到数据
  --    <GH>
  --     <GHDH>N001</GHDH>   //挂号单号
  --     <KS>门诊外科</KS>     //挂号科室
  --     <KSID>42</KSID>    //科室id
  --     <DJSJ>2014-10-21 14:12:44</DJSJ>    //登记时间
  --     <YYSJ>2014-10-21 14:10</YYSJ>    //预约时间
  --     <ZXZT>1</ZXZT>     //状态(预约中等待付款、已挂号、候诊等)
  --     <DDFK>1</DDFK>     //是否付款
  --     <GHFS>支付宝</GHFS>    //挂号方式(支付宝、自助机、窗口)
  --     <YSXM>LEX</YSXM>    //医生姓名
  --    </GH>
  --   </GHLIST>
  --   <ERROR><MSG>错误信息</MSG></ERROR>     //如果有错误返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_卡类别       医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  n_记录数       Number(4);
  v_结算卡类别   Varchar2(100);
  n_是否付款     Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  v_状态         Varchar2(100);
  n_站点         Number(1);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT><GHLIST></GHLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/JLS'), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/ZD')
  Into n_病人id, n_记录数, v_结算卡类别, n_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  n_记录数 := Nvl(n_记录数, 0);

  If Nvl(n_卡类别id, 0) = 0 Then
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  Else
    For r_Reg In (Select Distinct a.No, a.执行部门id As 科室id, b.名称 As 科室, a.登记时间 As 创建时间, a.发生时间 As 预约时间,
                                  Decode(a.记录性质, 2, '预约中',
                                          Decode(a.执行状态, -1, '不就诊', 0, '等待就诊', 1, '完成就诊', 2, '正在就诊', '已挂号')) As 状态,
                                  Decode(c.记录状态, 0, 0, 1) As 是否付款, a.预约方式 As 挂号方式, a.执行人 As 医生姓名
                  From 病人挂号记录 A, 部门表 B, 门诊费用记录 C, 病人预交记录 D
                  Where a.病人id = n_病人id And a.执行部门id = b.Id And c.No = a.No And c.序号 = 1 And c.记录性质 = 4 And a.记录状态 = 1 And
                        c.结帐id = d.结帐id And (d.卡类别id = n_卡类别id Or d.卡类别id Is Null) And Not Exists
                   (Select 1
                         From 病人预交记录
                         Where 结帐id = c.结帐id And Nvl(卡类别id, 0) <> 0 And Nvl(卡类别id, 0) <> n_卡类别id) And
                        (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                  Order By a.登记时间 Desc) Loop
      If n_记录数 <> 0 Then
        Begin
          Select Decode(记录状态, 0, 0, 1)
          Into n_是否付款
          From 门诊费用记录
          Where 记录性质 = 1 And 病人id = n_病人id And Instr(摘要, '挂号:' || r_Reg.No) > 0 And Rownum < 2;
        Exception
          When Others Then
            n_是否付款 := r_Reg.是否付款;
        End;
        If n_是否付款 = 0 And r_Reg.状态 = '预约中' And Sysdate > r_Reg.预约时间 Then
          v_状态 := '已失效';
        Else
          v_状态 := r_Reg.状态;
        End If;
        v_Temp := '<GH>' || '<GHDH>' || r_Reg.No || '</GHDH>' || '<KS>' || r_Reg.科室 || '</KS>' || '<KSID>' ||
                  r_Reg.科室id || '</KSID>' || '<DJSJ>' || To_Char(r_Reg.创建时间, 'YYYY-MM-DD hh24:mi:ss') || '</DJSJ>' ||
                  '<YYSJ>' || To_Char(r_Reg.预约时间, 'YYYY-MM-DD hh24:mi:ss') || '</YYSJ>' || '<ZXZT>' || v_状态 ||
                  '</ZXZT>' || '<DDFK>' || n_是否付款 || '</DDFK>' || '<GHFS>' || r_Reg.挂号方式 || '</GHFS>' || '<YSXM>' ||
                  r_Reg.医生姓名 || '</YSXM>' || '</GH>';
        Select Appendchildxml(x_Templet, '/OUTPUT/GHLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        n_记录数 := n_记录数 - 1;
      End If;
    End Loop;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Reghistory;
/

--101951:梁经伙,2016-12-16,住院首页的诊断可以填写ICD附码
Create Or Replace Procedure Zl_病人诊断记录_Update
(
  Id_In       病人诊断记录.Id%Type,
  病人id_In   病人诊断记录.病人id%Type,
  主页id_In   病人诊断记录.主页id%Type,
  记录来源_In 病人诊断记录.记录来源%Type,
  诊断类型_In 病人诊断记录.诊断类型%Type,
  疾病id_In   病人诊断记录.疾病id%Type,
  诊断id_In   病人诊断记录.诊断id%Type,
  证候id_In   病人诊断记录.证候id%Type,
  诊断描述_In 病人诊断记录.诊断描述%Type,
  出院情况_In 病人诊断记录.出院情况%Type,
  是否未治_In 病人诊断记录.是否未治%Type,
  是否疑诊_In 病人诊断记录.是否疑诊%Type,
  诊断次序_In 病人诊断记录.诊断次序%Type := 1,
  备注_In     病人诊断记录.备注%Type := Null,
  入院病情_In 病人诊断记录.入院病情%Type := Null,
  发病时间_In 病人诊断记录.发病时间%Type := Null,
  附码id_In   病人诊断记录.疾病id%Type := Null
) Is
  --功能：更新病人诊断记录
  v_诊断id     病人诊断记录.Id%Type;
  d_记录日期   病人诊断记录.记录日期%Type;
  v_病人科室id 病人信息.当前科室id%Type;
  v_经治医师   人员表.姓名%Type;
  v_编码       疾病编码目录.编码%Type;
  n_Count      Number;
  v_发病时间   病人诊断记录.发病时间%Type;

  v_Temp     Varchar2(255);
  v_人员姓名 人员表.姓名%Type;
Begin
  --先判断当前诊断是指定的诊断来源的诊断，是则更新，否则新增
  Select Count(1) Into n_Count From 病人诊断记录 Where ID = Id_In And (记录来源 = 记录来源_In Or 记录来源_In Is Null);
  If n_Count = 1 Then
  
    --删除主诊断对应的附码诊断
    For Rs In (Select 病人id, 主页id, 诊断类型, 诊断次序, 编码序号
               From 病人诊断记录
               Where ID = Id_In And 记录来源 <> 4 And Nvl(编码序号, 1) = 1) Loop
      Delete From 病人诊断记录
      Where 病人id = Rs.病人id And Nvl(主页id, 0) = Nvl(Rs.主页id, 0) And 记录来源 <> 4 And 诊断次序 = Rs.诊断次序 And 诊断类型 = Rs.诊断类型 And
            Nvl(编码序号, 1) = 2;
    End Loop;
  
    Update 病人诊断记录
    Set 记录来源 = 记录来源_In, 诊断次序 = 诊断次序_In, 疾病id = 疾病id_In, 诊断id = 诊断id_In, 证候id = 证候id_In, 诊断描述 = 诊断描述_In, 入院病情 = 入院病情_In,
        出院情况 = 出院情况_In, 是否未治 = 是否未治_In, 是否疑诊 = 是否疑诊_In, 备注 = 备注_In, 发病时间 = 发病时间_In
    Where ID = Id_In
    Returning 记录日期 Into d_记录日期;
  Else
    Select 病人诊断记录_Id.Nextval Into v_诊断id From Dual;
  
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    d_记录日期 := Sysdate;
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 记录日期, 记录人, 备注, 发病时间)
      Select v_诊断id, 病人id, 主页id, 记录来源_In, 诊断类型_In, 诊断次序_In, 疾病id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In, 出院情况_In,
             是否未治_In, 是否疑诊_In, Sysdate, v_人员姓名, 备注_In, 发病时间_In
      From 病人诊断记录
      Where ID = Id_In;
  End If;

  If 附码id_In Is Not Null Then
    Insert Into 病人诊断记录
      (ID, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 记录日期, 记录人, 备注, 发病时间, 编码序号)
      Select 病人诊断记录_Id.Nextval, 病人id, 主页id, 记录来源_In, 诊断类型_In, 诊断次序_In, 附码id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In,
             出院情况_In, 是否未治_In, 是否疑诊_In, Sysdate, v_人员姓名, 备注_In, 发病时间_In, 2
      From 病人诊断记录
      Where ID = Id_In;
  End If;

  --如果是门诊第一诊断则更新病人挂号记录.发病时间
  v_发病时间 := 发病时间_In;
  If 诊断类型_In = 1 And 诊断次序_In = 1 Then
    If 发病时间_In Is Null Then
      --检查中医的发病时间，有则取中医的，否则清空
      Select Max(发病时间)
      Into v_发病时间
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 诊断次序 = 1;
    End If;
    If v_发病时间 Is Null Then
      --如果都为NULL，则取挂号记录中的
      Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
    Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
  End If;
  If 诊断类型_In = 11 And 诊断次序_In = 1 Then
    --如果是中医，则判断是否填写了西医的发病时间，没有填写，则修改，否则以西医发病时间为准
    Select Count(*)
    Into n_Count
    From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 诊断次序 = 1 And 发病时间 Is Not Null;
    If n_Count = 0 Then
      If v_发病时间 Is Null Then
        --如果都为NULL，则取挂号记录中的
        Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
      End If;
      Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
  End If;

  --如果是入院第一诊断，则判断是否是单病种
  If 诊断类型_In = 2 And 诊断次序_In = 1 And 记录来源_In = 3 Then
    If 疾病id_In Is Not Null Then
      Select 编码 Into v_编码 From 疾病编码目录 Where ID = 疾病id_In;
      Select Max(Upper(编码))
      Into v_编码
      From 单病种目录
      Where Instr('/' || Replace(Upper(Icd编码), ' ', '') || '/', '/' || Upper(v_编码) || '/') > 0 And Rownum < 2;
    Else
      v_编码 := '';
    End If;
    Update 病案主页 Set 单病种 = v_编码 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  --根据传入的主页id_In查询挂号记录来区分是门诊首页还是住院首页调用
  Begin
    Select 执行人, 执行部门id Into v_病人科室id, v_经治医师 From 病人挂号记录 Where ID = 主页id_In;
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 1, '诊断', v_病人科室id, v_经治医师, d_记录日期, d_记录日期);
  Exception
    When Others Then
      Null;
  End;
  If v_病人科室id Is Null And (诊断类型_In <> 1 Or 诊断类型_In <> 11) Then
    Begin
      Select 出院科室id, 住院医师
      Into v_病人科室id, v_经治医师
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', v_病人科室id, v_经治医师, d_记录日期, d_记录日期);
    Exception
      When Others Then
        Null;
    End;
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Update;
/

--101951:梁经伙,2016-12-15,住院首页也需要存储ICD附码
CREATE OR REPLACE Procedure Zl_病人诊断记录_Insert
(
  病人id_In   病人诊断记录.病人id%Type,
  主页id_In   病人诊断记录.主页id%Type,
  记录来源_In 病人诊断记录.记录来源%Type,
  病历id_In   病人诊断记录.病历id%Type,
  诊断类型_In 病人诊断记录.诊断类型%Type,
  疾病id_In   病人诊断记录.疾病id%Type,
  诊断id_In   病人诊断记录.诊断id%Type,
  证候id_In   病人诊断记录.证候id%Type,
  诊断描述_In 病人诊断记录.诊断描述%Type,
  出院情况_In 病人诊断记录.出院情况%Type,
  是否未治_In 病人诊断记录.是否未治%Type,
  是否疑诊_In 病人诊断记录.是否疑诊%Type,
  记录日期_In 病人诊断记录.记录日期%Type,
  医嘱id_In   Varchar2 := Null,
  诊断次序_In 病人诊断记录.诊断次序%Type := 1,
  备注_In     病人诊断记录.备注%Type := Null,
  入院病情_In 病人诊断记录.入院病情%Type := Null,
  发病时间_In 病人诊断记录.发病时间%Type := Null,
  记录人_In   病人诊断记录.记录人%Type := Null,
  Id_In       病人诊断记录.Id%Type := Null,
  附码id_In   病人诊断记录.疾病id%Type := Null
) Is
  --功能：插入病人诊断记录
  --医嘱id_In=与当前诊断相关联的，用","间隔的医嘱ID串
  v_诊断id 病人诊断记录.Id%Type;
  v_医嘱id 病人医嘱记录.Id%Type;

  v_病人科室id 病人信息.当前科室id%Type;
  v_经治医师   人员表.姓名%Type;
  v_编码       疾病编码目录.编码%Type;
  n_Count      Number;
  v_发病时间   病人诊断记录.发病时间%Type;

  v_Temp     Varchar2(255);
  v_人员姓名 人员表.姓名%Type;
Begin
  --当前操作人员
  If 记录人_In Is Null Then
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  Else
    v_人员姓名 := 记录人_In;
  End If;

  If Id_In Is Null Then
    Select 病人诊断记录_Id.Nextval Into v_诊断id From Dual;
  Else
    v_诊断id := Id_In;
  End If;

  v_医嘱id := Zl_To_Number(医嘱id_In);
  If v_医嘱id = 0 Then
    v_医嘱id := Null;
  End If;

  Insert Into 病人诊断记录
    (ID, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序, 疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
         记录日期, 记录人, 医嘱id, 备注, 发病时间)
  Values
    (v_诊断id, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 疾病id_In, 诊断id_In, 证候id_In, 诊断描述_In, 入院病情_In, 出院情况_In,
     是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In);

 If 附码id_In Is Not Null Then
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 病历id, 诊断类型, 诊断次序,疾病id, 诊断id, 证候id, 诊断描述, 入院病情, 出院情况, 是否未治, 是否疑诊, 
          记录日期, 记录人, 医嘱id, 备注, 发病时间,编码序号)
      Select 病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 记录来源_In, 病历id_In, 诊断类型_In, 诊断次序_In, 附码id_In, 诊断id_In, 证候id_In, 诊断描述_In,
           入院病情_In, 出院情况_In, 是否未治_In, 是否疑诊_In, 记录日期_In, v_人员姓名, v_医嘱id, 备注_In, 发病时间_In,2
      From Dual;
  End If;

  --如果是门诊第一诊断则更新病人挂号记录.发病时间
  v_发病时间 := 发病时间_In;
  If 诊断类型_In = 1 And 诊断次序_In = 1 Then
    If 发病时间_In Is Null Then
      --检查中医的发病时间，有则取中医的，否则清空
      Select Max(发病时间)
      Into v_发病时间
      From 病人诊断记录
      Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 11 And 诊断次序 = 1;
    End If;
    If v_发病时间 Is Null Then
      --如果都为NULL，则取挂号记录中的
      Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
    Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
  End If;
  If 诊断类型_In = 11 And 诊断次序_In = 1 Then
    --如果是中医，则判断是否填写了西医的发病时间，没有填写，则修改，否则以西医发病时间为准
    Select Count(*)
    Into n_Count
    From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 1 And 诊断次序 = 1 And 发病时间 Is Not Null;
    If n_Count = 0 Then
      If v_发病时间 Is Null Then
        --如果都为NULL，则取挂号记录中的
        Select Max(发病时间) Into v_发病时间 From 病人挂号记录 Where 病人id = 病人id_In And ID = 主页id_In;
      End If;
      Update 病人挂号记录 Set 发病时间 = v_发病时间 Where 病人id = 病人id_In And ID = 主页id_In;
    End If;
  End If;

  If 医嘱id_In Is Not Null Then
    For r_Advice In (Select Column_Value As 医嘱id From Table(Cast(f_Num2list(医嘱id_In) As Zltools.t_Numlist))) Loop
      Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (v_诊断id, r_Advice.医嘱id);
    End Loop;
  End If;

  --如果是入院第一诊断，则判断是否是单病种
  If 诊断类型_In = 2 And 诊断次序_In = 1 And 记录来源_In = 3 Then
    If 疾病id_In Is Not Null Then
      Select 编码 Into v_编码 From 疾病编码目录 Where ID = 疾病id_In;
      Select Max(Upper(编码))
      Into v_编码
      From 单病种目录
      Where Instr('/' || Replace(Upper(Icd编码), ' ', '') || '/', '/' || Upper(v_编码) || '/') > 0 And Rownum < 2;
    Else
      v_编码 := '';
    End If;
    Update 病案主页 Set 单病种 = v_编码 Where 病人id = 病人id_In And 主页id = 主页id_In;
  End If;

  --根据传入的主页id_In查询挂号记录来区分是门诊首页还是住院首页调用
  Begin
    Select 执行人, 执行部门id Into v_病人科室id, v_经治医师 From 病人挂号记录 Where ID = 主页id_In;
    Zl_电子病历时机_Insert(病人id_In, 主页id_In, 1, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
  Exception
    When Others Then
      Null;
  End;
  If v_病人科室id Is Null And (诊断类型_In <> 1 Or 诊断类型_In <> 11) Then
    Begin
      Select 出院科室id, 住院医师
      Into v_病人科室id, v_经治医师
      From 病案主页
      Where 病人id = 病人id_In And 主页id = 主页id_In;
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '诊断', v_病人科室id, v_经治医师, 记录日期_In, 记录日期_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断记录_Insert;
/

--103232:冉俊明,2016-12-23,临床出诊安排，按序号时段开放停诊安排。
Create Or Replace Procedure Zl_临床出诊序号控制_开放挂号
(
  记录id_In 临床出诊记录.Id%Type,
  数量_In   Number
) As
  --功能：按序号开放已停诊安排
  --参数：
  --     数量_In:开放数量
  n_是否分时段   临床出诊记录.是否分时段%Type;
  n_是否序号控制 临床出诊记录.是否序号控制%Type;
  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;

  n_最小数量 Number;
  n_最大数量 Number;
  n_Count    Number;
  l_序号     t_Numlist := t_Numlist();

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Begin
    Select 是否分时段, 是否序号控制, 停诊开始时间, 停诊终止时间
    Into n_是否分时段, n_是否序号控制, d_停诊开始时间, d_停诊终止时间
    From 临床出诊记录
    Where ID = 记录id_In;
  Exception
    When Others Then
      v_Err_Msg := '未查找到出诊安排，不能开放停诊安排！';
      Raise Err_Item;
  End;

  If Nvl(n_是否序号控制, 0) = 0 Or Nvl(n_是否分时段, 0) = 0 Then
    v_Err_Msg := '出诊安排不是启用了序号且启用时段的，不能开放停诊安排！';
    Raise Err_Item;
  End If;

  If d_停诊开始时间 Is Null Then
    v_Err_Msg := '当前上班时段无停诊安排，不能开放停诊安排！';
    Raise Err_Item;
  End If;

  If Sysdate > d_停诊开始时间 Then
    v_Err_Msg := '当前时间已大于了停诊开始时间，不能再开放停诊安排！';
    Raise Err_Item;
  End If;

  Begin
    --And a.开始时间 <> a. 终止时间 
    --开始时间与终止时间相等的是加号的序号
    Select Sum(Decode(a.是否停诊, 1, 0, 1) * Decode(Nvl(a.挂号状态, 0), 0, 0, 1)) As 最小数量, Count(1) As 最大数量
    Into n_最小数量, n_最大数量
    From 临床出诊序号控制 A
    Where a.记录id = 记录id_In And a.开始时间 Between d_停诊开始时间 And d_停诊终止时间 And a.开始时间 <> a.终止时间;
  Exception
    When Others Then
      n_最小数量 := 0;
      n_最大数量 := 0;
  End;
  If Nvl(n_最小数量, 0) > Nvl(数量_In, 0) Then
    v_Err_Msg := '开放数量不能小于最小开放数量 ' || Nvl(n_最小数量, 0) || ' ！';
    Raise Err_Item;
  End If;
  If Nvl(n_最大数量, 0) < Nvl(数量_In, 0) Then
    v_Err_Msg := '开放数量不能大于最大开放数量 ' || Nvl(n_最大数量, 0) || ' ！';
    Raise Err_Item;
  End If;

  If Nvl(数量_In, 0) = 0 Then
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And Nvl(是否停诊, 0) = 0;
  Else
    --先将上次开放的未使用的号设置为停诊状态
    Update 临床出诊序号控制
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And Nvl(是否停诊, 0) = 0 And Nvl(挂号状态, 0) = 0;
  
    n_Count := Nvl(数量_In, 0) - Nvl(n_最小数量, 0);
    --And 开始时间 <> 终止时间 
    --开始时间与终止时间相等的是加号的序号
    For c_序号 In (Select 序号, 是否停诊, 挂号状态
                 From 临床出诊序号控制
                 Where 记录id = 记录id_In And 开始时间 Between d_停诊开始时间 And d_停诊终止时间 And 开始时间 <> 终止时间
                 Order By 序号) Loop
      If n_Count = 0 Then
        Exit;
      Else
        --上次开放的已使用的号不改变其停诊状态
        If Not (Nvl(c_序号.是否停诊, 0) = 0 And Nvl(c_序号.挂号状态, 0) <> 0) Then
          l_序号.Extend();
          l_序号(l_序号.Count) := c_序号.序号;
          n_Count := n_Count - 1;
        End If;
      End If;
    End Loop;
  
    If Nvl(数量_In, 0) - Nvl(n_最小数量, 0) <> l_序号.Count Then
      v_Err_Msg := '开放数量与实际可开放数量不等，开放停诊安排失败！';
      Raise Err_Item;
    End If;
  
    Forall I In 1 .. l_序号.Count
      Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = 记录id_In And 序号 = l_序号(I);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊序号控制_开放挂号;
/

--103632:冉俊明,2016-12-15,门诊医保多单据一次结算部分退费时医嘱发送的计费状态不正确。
Create Or Replace Procedure Zl_门诊收费记录_重收
(
  原结帐id_In     门诊费用记录.结帐id%Type,
  冲销id_In       门诊费用记录.结帐id%Type,
  重收结帐id_In   门诊费用记录.结帐id%Type,
  排开医保结算_In Varchar2 := Null
) As
  --排开医保结算_IN:多个用逗号分离(只某些医保结算,允许退现金)
  Cursor c_Fee_Data Is
    Select ID
    From 门诊费用记录 A
    Where 结帐id = 原结帐id_In And Not Exists
     (Select 1
           From 门诊费用记录 B
           Where Mod(b.记录性质, 10) = 1 And a.No = b.No And a.序号 = b.序号 And 结帐id = 冲销id_In)
    Order By ID;

  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  d_登记时间   门诊费用记录.登记时间%Type;
  n_缴款组id   门诊费用记录.缴款组id%Type;
  n_病人id     门诊费用记录.病人id%Type;
  Err_Item Exception;
  v_Err_Msg    Varchar2(255);
  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  n_结算金额   门诊费用记录.实收金额%Type;
  n_冲销金额   病人预交记录.冲预交%Type;
  n_Count      Number(18);
Begin
  Begin
    Select 操作员编号, 操作员姓名, 登记时间, 缴款组id, 病人id
    Into v_操作员编号, v_操作员姓名, d_登记时间, n_缴款组id, n_病人id
    From 门诊费用记录
    Where 结帐id = 冲销id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := 'NO';
  End;

  If Nvl(v_Err_Msg, '-') = 'NO' Then
    v_Err_Msg := '由于并发操作,该单据可能已经初他人退费或删除,不能再进行退费操作！';
    Raise Err_Item;
  End If;

  --1.处理界面选择的且是部分退或部分执行的
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位,
     付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态, 执行时间,
     操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
           收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
           执行人, 执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
           缴款组id
    From (Select NO, Max(实际票号) As 实际票号, 11 As 记录性质, 1 As 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式,
                  费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 1 As 付数, Max(发药窗口) As 发药窗口, Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次,
                  Max(加班标志) As 加班标志, Max(附加标志) As 附加标志, 收入项目id, 收据费目, 记帐费用, Avg(标准单价) As 标准单价, Sum(应收金额) As 应收金额,
                  Sum(实收金额) As 实收金额, 开单部门id, 开单人, 执行部门id, Max(划价人) As 划价人, Max(执行人) 执行人, Max(执行状态) As 执行状态, 1 As 费用状态,
                  Max(执行时间) 执行时间, v_操作员编号 As 操作员编号, v_操作员姓名 As 操作员姓名, 发生时间, d_登记时间 As 登记时间, 重收结帐id_In As 结帐id,
                  Sum(结帐金额) As 结帐金额, Max(保险项目否) As 保险项目否, 保险大类id, Sum(统筹金额) As 统筹金额,
                  Max(Decode(记录性质, 1, 摘要, 11, 摘要, Null)) As 摘要, Max(是否上传) As 是否上传, Max(保险编码) As 保险编码, Max(费用类型) As 费用类型,
                  Max(Decode(记录性质, 1, 结论, 11, 结论, Null)) As 结论, n_缴款组id As 缴款组id
           From 门诊费用记录
           Where Mod(记录性质, 10) = 1 And (NO, 序号) In (Select NO, 序号 From 门诊费用记录 Where 结帐id = 冲销id_In)
           Group By NO, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id, 计算单位, 收入项目id,
                    收据费目, 记帐费用, 开单部门id, 开单人, 执行部门id, 发生时间, 保险大类id
           Having Sum(Nvl(付数, 1) * Nvl(数次, 0)) <> 0);

  For c_冲销 In (Select NO, 序号, 从属父号, 价格父号, 收入项目id, -1 * Sum(Nvl(付数, 1) * Nvl(数次, 0)) As 数次, Sum(标准单价) As 标准单价,
                      -1 * Sum(应收金额) As 应收金额, -1 * Sum(实收金额) As 实收金额, -1 * Sum(统筹金额) As 统筹金额, -1 * Sum(结帐金额) As 结帐金额
               From 门诊费用记录
               Where 记录性质 = 11 And 结帐id = 重收结帐id_In
               Group By NO, 序号, 从属父号, 价格父号, 收入项目id) Loop
    Update 门诊费用记录
    Set 数次 = Nvl(数次, 0) + Nvl(c_冲销.数次, 0), 实收金额 = Nvl(实收金额, 0) + Nvl(c_冲销.实收金额, 0),
        应收金额 = Nvl(应收金额, 0) + Nvl(c_冲销.应收金额, 0), 结帐金额 = Nvl(结帐金额, 0) + Nvl(c_冲销.结帐金额, 0),
        统筹金额 = Nvl(统筹金额, 0) + Nvl(c_冲销.统筹金额, 0)
    Where NO = c_冲销.No And 序号 = c_冲销.序号 And Nvl(从属父号, -1) = Nvl(c_冲销.从属父号, '-1') And
          Nvl(价格父号, -1) = Nvl(c_冲销.价格父号, '-1') And 收入项目id = c_冲销.收入项目id And 结帐id = 冲销id_In;
  End Loop;

  --2.处理界面未选退费部分,需要全退且产生11的重收记录
  Open c_Fee_Data;
  Loop
    Fetch c_Fee_Data Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --退费记录
    Forall I In 1 .. t_费用id.Count
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
         计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 费用状态,
         执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
        Select 病人费用记录_Id.Nextval, a.No, a.实际票号, 1, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
               a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志,
               a.收入项目id, a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, 执行人,
               Nvl(q.执行状态, -1) As 执行状态, 1, a.执行时间, v_操作员编号, v_操作员姓名, a.发生时间, d_登记时间, 冲销id_In, -1 * a.结帐金额, a.保险项目否,
               a.保险大类id, -1 * a.统筹金额, a.摘要, a.是否上传, a.保险编码, a.费用类型, a.结论, n_缴款组id As 缴款组id
        From 门诊费用记录 A,
             (Select j.No, j.序号, Nvl(Max(j.执行状态), 0) - 1 As 执行状态
               From 门诊费用记录 M, 门诊费用记录 J
               Where m.Id = t_费用id(I) And m.No = j.No And m.序号 = j.序号 And Mod(j.记录性质, 10) = 1 And j.记录状态 = 2
               Group By j.No, j.序号) Q
        Where ID = t_费用id(I) And a.No = q.No(+) And a.序号 = q.序号(+);
  
    --将原记录状态由1变为3
    Forall I In 1 .. t_费用id.Count
      Update 门诊费用记录 Set 记录状态 = 3 Where ID = t_费用id(I) And 记录状态 = 1;
  
    --重新收费记录
    If Nvl(重收结帐id_In, 0) <> 0 Then
      Forall I In 1 .. t_费用id.Count
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 11, 1, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
                 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id,
                 划价人, 执行人, 执行状态, 1, 执行时间, v_操作员编号, v_操作员姓名, 发生时间, d_登记时间, 重收结帐id_In, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传,
                 保险编码, 费用类型, 结论, n_缴款组id As 缴款组id
          From 门诊费用记录
          Where ID = t_费用id(I);
    End If;
  End Loop;
  Close c_Fee_Data;

  Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null;
  If n_Count = 0 Then
    --退费结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
             -1 * 冲销id_In, 2, 3
      From 病人预交记录
      Where 结帐id = 原结帐id_In And 结算方式 In (Select 名称 From 结算方式 Where 性质 In (3, 4)) And
            Instr(',' || 排开医保结算_In || ',', ',' || 结算方式 || ',') = 0 And Mod(记录性质, 10) <> 1;
    --将原误差费全部退了
    --Insert Into 病人预交记录
    --  (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志)
    --  Select 病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, 结算方式, d_登记时间, v_操作员编号, v_操作员姓名, -1 * 冲预交, 冲销id_In, n_缴款组id,
    --         -1 * 冲销id_In, 2
    --  From 病人预交记录
    --  Where 结帐id = 原结帐id_In And 结算方式 = v_误差费 And Mod(记录性质, 10) <> 1;
  
    Select Sum(冲预交) Into n_冲销金额 From 病人预交记录 Where 结帐id = 冲销id_In;
    Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 冲销id_In;
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 2, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, -1 * (Nvl(n_冲销金额, 0) - Nvl(n_结算金额, 0)),
       冲销id_In, n_缴款组id, -1 * 冲销id_In, 1, 3);
  
  End If;
  If Nvl(重收结帐id_In, 0) <> 0 Then
    Select Count(1) Into n_Count From 病人预交记录 Where 结帐id = 重收结帐id_In And 结算方式 Is Null;
    If n_Count = 0 Then
      Select Sum(结帐金额) Into n_结算金额 From 门诊费用记录 Where 结帐id = 重收结帐id_In;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 1, n_病人id, Null, d_登记时间, v_操作员编号, v_操作员姓名, n_结算金额, 重收结帐id_In, n_缴款组id,
         -1 * 冲销id_In, 1, 3);
    End If;
  
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    For c_No In (Select Distinct NO From 门诊费用记录 Where 记录性质 = 11 And 结帐id = 重收结帐id_In) Loop
      Zl_医嘱发送_计费状态_Update(0, 1, 2, c_No.No);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_重收;
/

--103685:余伟节,2016-12-09,支持婴儿年龄格式X天X小时
Create Or Replace Function Zl_Age_Calc
(
  病人id_In   病人信息.病人id%Type,
  出生日期_In Date := Null,
  计算日期_In Date := Null
) Return Varchar2
--功能:根据出生日期计算年龄.当天登记病人,保持年龄不变.
  --返回:1天以内：X小时[X分钟],1天至1月以内：X天[X小时],1月至1岁以内：X月[X天],1岁至儿童年龄上限：X岁[X月],>=儿童年龄上限：X岁
  --说明:1天以内，是指按出生日期24小时算;1月以内，是指对天计算；比如7.8日出生，8.8日才算1月;1岁以内，也是对天计算。;“以内”都是指“<”。
 As
  d_出生日期      Date;
  d_计算日期      Date;
  n_Days          Number;
  n_Months        Number;
  v_年龄          病人信息.年龄%Type;
  n_Upperagelimit Number; --参数:年龄上限

  v_Return Varchar2(20); --由于病人信息等相关表的年龄字段为10个字符，所以最大允许10个字符或5个汉字
Begin
  --当天登记的病人不用重算年龄
  If Nvl(病人id_In, 0) <> 0 Then
    Begin
      Select 年龄
      Into v_年龄
      From 病人信息
      Where 病人id = 病人id_In And Floor(Sysdate - 登记时间) = 0 And 年龄 Is Not Null;
    Exception
      When Others Then
        Null;
    End;
    If v_年龄 Is Not Null Then
      v_Return := v_年龄;
      Return v_Return;
    End If;
  End If;

  If 出生日期_In Is Null Then
    If Nvl(病人id_In, 0) <> 0 Then
      Select 出生日期 Into d_出生日期 From 病人信息 Where 病人id = 病人id_In;
    End If;
    If d_出生日期 Is Null Then
      Return Null;
    End If;
  Else
    d_出生日期 := 出生日期_In;
  End If;
  If 计算日期_In Is Null Then
    Select Sysdate Into d_计算日期 From Dual;
  Else
    d_计算日期 := 计算日期_In;
  End If;
  --如果出生日期大于计算日期,则直接为0小时
  If (d_计算日期 - d_出生日期) < 0 Then
    v_Return := '0小时';
    Return v_Return;
  End If;
  --获取儿童年龄的上限
  Begin
    Select Nvl(参数值, 14)
    Into n_Upperagelimit
    From zlParameters
    Where 系统 = 100 And Nvl(模块, 0) = 0 And 参数号 = 147;
  Exception
    When Others Then
      n_Upperagelimit := 14;
  End;
  n_Months := Trunc(Months_Between(d_计算日期, d_出生日期));
  If n_Months < 12 * n_Upperagelimit Then
    --小于1岁的情况
    If n_Months < 12 Then
      --小于1月
      If n_Months < 1 Then
        n_Days := Trunc(d_计算日期 - d_出生日期);
        --一天以内
        If n_Days = 0 Then
          n_Days := Trunc((d_计算日期 - d_出生日期) * 24 * 60);
          If Mod(n_Days, 60) = 0 Then
            v_Return := n_Days / 60 || '小时';
          Else
            v_Return := Floor(n_Days / 60) || '小时' || Mod(n_Days, 60) || '分钟';
          End If;
        Else
          --一天至一月  精确到小时 :X天X小时
          n_Days := Trunc((d_计算日期 - d_出生日期) * 24);
          If Mod(n_Days, 24) = 0 Then
            v_Return := n_Days / 24 || '天';
          Else
            v_Return := Floor(n_Days / 24) || '天' || Mod(n_Days, 24) || '小时';
          End If;
        End If;
      Else
        --大于1月
        n_Days := Trunc(Add_Months(d_计算日期, -1 * n_Months) - d_出生日期);
        If n_Days >= 31 Then
          --针对计算日期是2月份最后一天,出生日期刚好大于2月份最后一天且当天不是本月的最后一天
          --如：计算日期：2016-02-29   出生日期：2015-01-30
          n_Months := n_Months + 1;
          n_Days   := n_Days - 31;
        End If;
        If n_Days = 0 Then
          v_Return := n_Months || '月';
        Else
          v_Return := n_Months || '月' || n_Days || '天';
        End If;
      End If;
    Else
      --1岁到小于婴儿年龄上限的情况
      If Mod(n_Months, 12) = 0 Then
        v_Return := n_Months / 12 || '岁';
      Else
        v_Return := Floor(n_Months / 12) || '岁' || Mod(n_Months, 12) || '月';
      End If;
    End If;
  Else
    --大于等于婴儿年龄上限(直接X岁)
    v_Return := Floor(n_Months / 12) || '岁';
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Calc;
/

--103685:余伟节,2016-12-09,解决婴儿年龄支持X天X小时
Create Or Replace Function Zl_Age_Check
(
  年龄_In     病人信息.年龄%Type,
  出生日期_In Date := Null
) Return Varchar2
--年龄格式:X小时[X分钟];X天[X小时];X月[X天];X岁[X月]
 As
  v_Return           Varchar2(1000);
  v_Info             Varchar2(1000);
  v_Tmpone           Varchar2(20);
  v_Tmptwo           Varchar2(20);
  v_Unitone          Varchar2(4);
  v_Unittwo          Varchar2(4);
  n_Ageformatcorrect Number(1);
  n_Ageformat        Number(1);
  v_Age              病人信息.年龄%Type;
  v_Birthday         Varchar2(20);
Begin
  v_Info             := '1|年龄格式只能为:X小时[X分钟] 或 X天[X小时] 或 X月[X天] 或 X岁[X月]，并且X为正整数。';
  n_Ageformatcorrect := 0;
  --检查年龄格式是否正确
  For I In 1 .. 4 Loop
    If I = 1 Then
      v_Unitone := '岁';
      v_Unittwo := '月';
    Elsif I = 2 Then
      v_Unitone := '月';
      v_Unittwo := '天';
    Elsif I = 3 Then
      v_Unitone := '天';
      v_Unittwo := '小时';
    Else
      v_Unitone := '小时';
      v_Unittwo := '分钟';
    End If;
    --1:X岁[X月],2:X月[X天],3:X天,4:X小时[X分钟]
    If Instr(年龄_In, v_Unitone, 1) > 0 And n_Ageformatcorrect = 0 Then
      If Instr(年龄_In, v_Unitone, 1) = 1 Then
        v_Return := v_Info;
        Return v_Return;
      Else
        v_Tmpone := Substr(年龄_In, 1, Instr(年龄_In, v_Unitone, 1) - 1);
        --岁前面必须为数字
        If Translate(v_Tmpone, '\0123456789', '\') Is Null Then
          If To_Number(v_Tmpone) > 200 And v_Unitone = '岁' Then
            v_Return := '1|年龄格式为:X岁时，岁数不能大于200岁。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 12 And v_Unitone = '月' Then
            v_Return := '1|年龄格式为:X月时，月份数必须小于12个月。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 31 And v_Unitone = '天' Then
            v_Return := '1|年龄格式为:X天时，天数必须小于31天。';
            Return v_Return;
          Elsif To_Number(v_Tmpone) >= 24 And v_Unitone = '小时' Then
            v_Return := '1|年龄格式为:X小时时，小时数必须小于24小时。';
            Return v_Return;
          End If;
          If Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone) - 1 = Length(年龄_In) Then
            n_Ageformatcorrect := I;
            Exit;
          Else
            v_Tmpone := Substr(年龄_In, Instr(年龄_In, v_Unitone, 1) + Length(v_Unitone));
            If Instr(v_Tmpone, v_Unittwo, 1) = 0 Or Length(v_Tmpone) = Length(v_Unittwo) Or
               Substr(v_Tmpone, Length(v_Tmpone) - Length(v_Unittwo) + 1, Length(v_Unittwo)) <> v_Unittwo Then
              v_Return := v_Info;
              Return v_Return;
            Else
              v_Tmptwo := Substr(v_Tmpone, 1, Length(v_Tmpone) - Length(v_Unittwo));
              If Translate(v_Tmptwo, '\0123456789', '\') Is Null Then
                If To_Number(v_Tmptwo) >= 12 And v_Unittwo = '月' Then
                  v_Return := '1|年龄格式为:[X岁X月]时，月份数必须小于12个月。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 31 And v_Unittwo = '天' Then
                  v_Return := '1|年龄格式为:[X月X天]时，天数必须小于31天。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 60 And v_Unittwo = '分钟' Then
                  v_Return := '1|年龄格式为:[X小时X分钟]时，分钟数必须小于60分钟。';
                  Return v_Return;
                Elsif To_Number(v_Tmptwo) >= 24 And v_Unittwo = '小时' Then
                  v_Return := '1|年龄格式为:[X天X小时]时，小时数必须小于24小时。';
                  Return v_Return;
                Else
                  n_Ageformatcorrect := I;
                  Exit;
                End If;
              Else
                v_Return := v_Info;
                Return v_Return;
              End If;
            End If;
          End If;
        Else
          v_Return := v_Info;
          Return v_Return;
        End If;
      End If;
    End If;
  End Loop;

  --年龄不再上述任何一个范围:如年龄为:51、1周1天
  If n_Ageformatcorrect = 0 Then
    v_Return := v_Info;
    Return v_Return;
  End If;
  --年龄格式正确，检查年龄段是否在出生日期段内
  If 出生日期_In Is Null Then
    Return Null;
  End If;
  v_Birthday := To_Char(出生日期_In, 'YYYY-MM-DD hh24:mi:ss');
  If Substr(v_Birthday, 12) = '00:00:00' Then
    v_Birthday := Substr(v_Birthday, 1, 10);
  Else
    v_Birthday := Substr(v_Birthday, 1, 16);
  End If;
  v_Age := Zl_Age_Calc(0, 出生日期_In);
  --计算根据出生日期计算出来的年龄在那一个段
  n_Ageformat := 0;
  v_Tmpone    := '';
  If Instr(v_Age, '岁', 1) > 0 Then
    n_Ageformat := 1;
    v_Tmpone    := 'X岁[X月]';
  Elsif Instr(v_Age, '月', 1) > 0 Then
    n_Ageformat := 2;
    v_Tmpone    := 'X月[X天]';
  Elsif Instr(v_Age, '天', 1) > 0 Then
    n_Ageformat := 3;
    v_Tmpone    := 'X天[小时]';
  Elsif Instr(v_Age, '小时', 1) > 0 Then
    n_Ageformat := 4;
    v_Tmpone    := 'X小时[X分钟]';
  End If;
  v_Return := '';
  If n_Ageformat = 0 Then
    v_Return := '1|计算年龄的函数：Zl_Age_Calc 存在问题,请直接与开发商联系。';
    Return v_Return;
  End If;
  --检查根据出生日期计算出来的年龄段和传入的年龄年龄段是否相同
  If n_Ageformatcorrect <> n_Ageformat Then
    v_Return := '1|年龄[' || 年龄_In || ']与出生日期计算出来的年龄[' || v_Age || ']在格式上不一致，';
    v_Return := v_Return || '当前年龄格式应该为:' || v_Tmpone || '。';
    Return v_Return;
  End If;
  --同一时间段内则坚持年龄是否相等
  If 年龄_In <> v_Age Then
    v_Return := '0|年龄[' || 年龄_In || ']与出生日期不一致，' || v_Birthday || '出生到现在应该是[' || v_Age || ']。';
  End If;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Age_Check;
/

--103544:廖思奇,2016-12-08,过程增加对应参数
CREATE OR REPLACE Procedure Zl_影像插件功能_Update
(
  插件id_In           In 影像插件功能.插件id%Type,
  名称_In             In 影像插件功能.名称%Type,
  方法_In             In 影像插件功能.方法%Type,
  方法参数_In         In 影像插件功能.方法参数%Type,
  是否启用_In         In 影像插件功能.是否启用%Type,
  是否加入右键菜单_In In 影像插件功能.是否加入右键菜单%Type,
  是否加入工具栏_In   In 影像插件功能.是否加入工具栏%Type,
  自动执行时机_In     In 影像插件功能.自动执行时机%Type,
  Vbs脚本_In          In 影像插件功能.Vbs脚本%Type
) Is

  n_功能序号 影像插件功能.功能序号%Type;
  n_Id       Number;

Begin

  Select Nvl(Max(功能序号), 0) + 1 Into n_功能序号 From 影像插件功能 Where 插件id = 插件id_In;
  Select Nvl(Max(ID), 0) + 1 Into n_Id From 影像插件功能;

  Insert Into 影像插件功能
    (ID, 插件id, 功能序号, 名称, 方法, 方法参数, 是否启用, 是否加入右键菜单, 是否加入工具栏, 自动执行时机, Vbs脚本)
  Values
    (n_Id, 插件id_In, n_功能序号, 名称_In, 方法_In, 方法参数_In, 是否启用_In, 是否加入右键菜单_In, 是否加入工具栏_In, 自动执行时机_In, Vbs脚本_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像插件功能_Update;
/

--103310:李南春,2016-12-08,医疗卡卡号增加回车符位
Create Or Replace Procedure Zl_医疗卡类别_Update
(
  Id_In             In 医疗卡类别.Id%Type,
  编码_In           In 医疗卡类别.编码%Type,
  名称_In           In 医疗卡类别.名称%Type,
  短名_In           In 医疗卡类别.短名%Type,
  前缀文本_In       In 医疗卡类别.前缀文本%Type,
  卡号长度_In       In 医疗卡类别.卡号长度%Type,
  缺省标志_In       In 医疗卡类别.缺省标志%Type,
  是否固定_In       In 医疗卡类别.是否固定%Type,
  是否严格控制_In   In 医疗卡类别.是否严格控制%Type,
  是否刷卡_In       In 医疗卡类别.是否刷卡%Type,
  是否自制_In       In 医疗卡类别.是否自制%Type,
  是否存在帐户_In   In 医疗卡类别.是否存在帐户%Type,
  是否全退_In       In 医疗卡类别.是否全退%Type,
  部件_In           In 医疗卡类别.部件%Type,
  备注_In           In 医疗卡类别.备注%Type,
  特定项目_In       In 医疗卡类别.特定项目%Type,
  收费细目id_In     In 收费项目目录.Id%Type,
  结算方式_In       In 医疗卡类别.结算方式%Type,
  是否启用_In       In 医疗卡类别.是否启用%Type,
  卡号密文_In       In 医疗卡类别.卡号密文%Type,
  是否重复使用_In   In 医疗卡类别.是否重复使用%Type,
  密码长度_In       In 医疗卡类别.密码长度%Type,
  密码长度限制_In   In 医疗卡类别.密码长度限制%Type,
  密码规则_In       In 医疗卡类别.密码规则%Type,
  是否退现_In       In 医疗卡类别.是否退现%Type,
  操作方式_In       In Integer := 0,
  是否模糊查找_In   In 医疗卡类别.是否模糊查找%Type := 0,
  密码输入限制_In   In 医疗卡类别.密码输入限制%Type := 0,
  是否缺省密码_In   In 医疗卡类别.是否缺省密码%Type := 0,
  是否制卡_In       In 医疗卡类别.是否制卡%Type := 0,
  是否发卡_In       In 医疗卡类别.是否发卡%Type := 0,
  是否写卡_In       In 医疗卡类别.是否写卡%Type := 0,
  险类_In           In 医疗卡类别.险类%Type := 0,
  发卡性质_In       In 医疗卡类别.发卡性质%Type := 0,
  是否转帐及代扣_In In 医疗卡类别.是否转帐及代扣%Type := 0,
  是否持卡消费_In   In 医疗卡类别.是否持卡消费%Type := 0,
  发送调用接口_In   In 医疗卡类别.发送调用接口%Type := 0,
  设备是否启用回车_In   In 医疗卡类别.设备是否启用回车%Type := 0
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  If Nvl(是否自制_In, 0) = 1 And Nvl(是否存在帐户_In, 0) = 1 Then
    v_Err_Msg := '[ZLSOFT]是否存在帐户只有非自制卡才会存在,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 0 And Nvl(是否存在帐户_In, 0) = 1 And 结算方式_In Is Null Then
    v_Err_Msg := '[ZLSOFT]第三方机构的卡结算，必须要设置结算方式,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;
  If Nvl(是否自制_In, 0) = 1 And 特定项目_In Is Null Then
    v_Err_Msg := '[ZLSOFT]特定项目必须输入,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  If 操作方式_In = 0 Then
    Insert Into 医疗卡类别
      (ID, 编码, 名称, 短名, 前缀文本, 卡号长度, 缺省标志, 是否固定, 是否严格控制, 是否刷卡, 是否自制, 是否存在帐户, 是否全退, 部件, 备注, 特定项目, 结算方式, 是否启用, 卡号密文, 是否重复使用,
       密码长度, 密码长度限制, 密码规则, 是否退现, 是否模糊查找, 密码输入限制, 是否缺省密码, 是否制卡, 是否发卡, 是否写卡, 险类, 发卡性质, 是否转帐及代扣, 是否持卡消费, 发送调用接口, 设备是否启用回车)
    Values
      (Id_In, 编码_In, 名称_In, 短名_In, 前缀文本_In, 卡号长度_In, 缺省标志_In, 是否固定_In, 是否严格控制_In, 是否刷卡_In, 是否自制_In, 是否存在帐户_In, 是否全退_In,
       部件_In, 备注_In, 特定项目_In, 结算方式_In, 是否启用_In, 卡号密文_In, 是否重复使用_In, 密码长度_In, 密码长度限制_In, 密码规则_In, 是否退现_In, 是否模糊查找_In,
       密码输入限制_In, 是否缺省密码_In, 是否制卡_In, 是否发卡_In, 是否写卡_In, 险类_In, 发卡性质_In, 是否转帐及代扣_In, 是否持卡消费_In, 发送调用接口_In, 设备是否启用回车_In);
  
  Else
  
    Delete 收费特定项目 Where 特定项目 = (Select Max(特定项目) From 医疗卡类别 Where ID = Id_In);
  
    Update 医疗卡类别
    Set 编码 = 编码_In, 名称 = 名称_In, 短名 = 短名_In, 前缀文本 = 前缀文本_In, 卡号长度 = 卡号长度_In, 缺省标志 = 缺省标志_In, 是否严格控制 = 是否严格控制_In,
        是否刷卡 = 是否刷卡_In, 是否自制 = 是否自制_In, 是否存在帐户 = 是否存在帐户_In, 是否全退 = 是否全退_In, 部件 = 部件_In, 备注 = 备注_In, 特定项目 = 特定项目_In,
        结算方式 = 结算方式_In, 是否启用 = 是否启用_In, 卡号密文 = 卡号密文_In, 是否重复使用 = 是否重复使用_In, 密码长度 = 密码长度_In, 密码长度限制 = 密码长度限制_In,
        密码规则 = 密码规则_In, 是否退现 = 是否退现_In, 是否模糊查找 = 是否模糊查找_In, 密码输入限制 = 密码输入限制_In, 是否缺省密码 = 是否缺省密码_In, 是否制卡 = 是否制卡_In,
        是否发卡 = 是否发卡_In, 是否写卡 = 是否写卡_In, 险类 = 险类_In, 发卡性质 = 发卡性质_In, 是否转帐及代扣 = 是否转帐及代扣_In, 是否持卡消费 = 是否持卡消费_In,
        发送调用接口 = 发送调用接口_In, 设备是否启用回车 = 设备是否启用回车_In
    Where ID = Id_In;
    If Nvl(缺省标志_In, 0) = 1 Then
      Update 医疗卡类别 Set 缺省标志 = 0 Where ID <> Id_In;
    End If;
  
  End If;
  If Not 特定项目_In Is Null And Nvl(收费细目id_In, 0) <> 0 Then
    Insert Into 收费特定项目 (特定项目, 收费细目id) Values (特定项目_In, 收费细目id_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医疗卡类别_Update;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Registdelcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号检查
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --  <XL></XL>                  //险类
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  n_险类       病人信息.险类%Type;
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS'),
         To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
    If Nvl(n_缴款方式, 0) = 0 Then
      If Nvl(n_险类, 0) = 0 Then
        Select Nvl(Max(1), 0)
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 <> v_结算方式 And Mod(记录性质, 10) <> 1 And Rownum < 2;
      Else
        Select Nvl(Max(1), 0)
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B, 结算方式 C
        Where a.结帐id = b.结帐id And 结算方式 <> v_结算方式 And Mod(记录性质, 10) <> 1 And a.结算方式 = c.名称 And c.性质 Not In (3, 4) And
              Rownum < 2;
        If n_存在 = 0 Then
          Select Nvl(Max(1), 0)
          Into n_存在
          From 保险结算记录 A,
               (Select Distinct 结帐id
                 From 门诊费用记录
                 Where NO = v_No And 记录性质 = 4
                 Union
                 Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
          Where a.记录id = b.结帐id And 险类 <> n_险类 And Rownum < 2;
        End If;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的挂号单据包含' || v_结算方式 || '以外的结算方式,无法退号!';
        Raise Err_Item;
      End If;
    Else
      Begin
        Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If n_缴款方式 = 0 Then
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
    If n_实收金额 <> n_挂号金额 Then
      v_Err_Msg := '传入的退款金额与实际挂号金额不符，请检查!';
      Raise Err_Item;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdelcheck;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Paymentinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:获取指定单据交易信息 
  --入参:Xml_In: 
  --<IN>
  --    <DJ>单据号,性质|....</DJ> //可以传入多个单据
  --    <JSKLB>结算卡类别</JSKLB>
  --    <XL>险类</XL>          //为空代表普通病人
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  --<DJ>  //如果为空表示没有找到数据
  --    <DJH>单据号</DJH>
  --    <JLXZ>记录性质</JLXZ>   
  --    <YSJE>应收金额</YSJE>
  --    <SSJE>实收金额</SSJE>
  --    <FYMC>收据费目</FYMC> //(多个用逗号分离 )
  --    <JSKZF>结算卡支付</JSKZF> //:0-不是结算卡支付;1-结算卡支付(入参中:JSKLB判断,存在该类别支付的,返回1,否则返回0)
  --    <FKSJ>付款时间</FKSJ>
  --    <JYLSH>交易流水号</JYLSH> //(非结算卡支付的，不返回)
  --    <YXTK>是否允许退款</YXTK>            //0不允许1允许
  --    <YBJS>医保是否结算</YBJS>   //1-已结算;0-未结算
  --    <KP>是否开票</KP>  1是0否
  --    <SQZT>退费申请状态</SQZT>                  //退费申请状态,0-未申请,1-申请中,2-审核通过,3-审核未通过
  --    <JZTFSM>禁止退款说明</JZTFSM>
  --    <YJZID>结帐ID</YJZID>                  //已收费单据的结帐ID
  --</DJ>
  --<ERROR><MSG></MSG></ERROR>          //错误情况返回
  --</OUTPUT>
  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  x_Templet      Xmltype; --模板XML 
  v_No           Varchar2(4000);
  v_结算卡类别   Varchar2(100);
  n_结算卡类别id 医疗卡类别.Id%Type;

  n_Temp       Number(18);
  n_Mark       Number(5);
  v_Temp       Varchar2(32767); --临时XML 
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_医保结算   Number(2);
  n_允许退款   Number(2);
  n_退费状态   病人退费申请.状态%Type;
  v_审核原因   病人退费申请.审核原因%Type;
  v_说明       Varchar2(100);
  n_补结算     Number(18);
  v_结算方式   结算方式.名称%Type;
  n_已开医嘱   Number(2);
  n_险类       病人信息.险类%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/DJ'), Extractvalue(Value(A), 'IN/JSKLB'),
         To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into v_No, v_结算卡类别, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_No Is Null Then
    v_Err_Msg := '不能找到指定的收费单据(当前单据为空)';
    Raise Err_Item;
  End If;
  If v_结算卡类别 Is Not Null Then
    v_Err_Msg := Null;
    Begin
      n_结算卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_结算卡类别id := 0;
    End;
    If Nvl(n_结算卡类别id, 0) = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 结算方式
        Into n_结算卡类别id, v_Err_Msg, v_结算方式
        From 医疗卡类别
        Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := v_结算卡类别 || '不存在!';
      End;
    Else
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 结算方式
        Into n_结算卡类别id, v_Err_Msg, v_结算方式
        From 医疗卡类别
        Where ID = n_结算卡类别id;
      Exception
        When Others Then
          n_结算卡类别id := 0;
          v_Err_Msg      := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  For c_收费单 In (Select /*+ rule*/
                 记录性质, NO, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Max(收款时间) As 收款时间, Max(结帐id) As 结帐id, Max(是否退款) As 是否退款,
                 Max(是否打印) As 是否打印, Max(记录状态) As 记录状态, f_List2str(Cast(Collect(收据费目) As t_Strlist)) As 收据费目,
                 Max(挂号单) As 挂号单
                
                From (Select 记录性质, NO, 收据费目, Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额,
                              To_Char(Max(登记时间), 'yyyy-mm-dd hh24:mi:ss') As 收款时间, Max(结帐id) As 结帐id,
                              Max(Decode(Nvl(a.执行状态, 0), 1, 0, 1)) As 是否退款, Max(Decode(a.实际票号, Null, 0, 1)) 是否打印,
                              Max(a.记录状态) As 记录状态, Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', ''))) As 挂号单
                       From 门诊费用记录 A, Table(f_Str2list2(v_No, '|', ',')) B
                       Where a.No = b.C1 And a.记录性质 = b.C2 And 记录状态 In (1, 3)
                       Group By 记录性质, NO, 收据费目
                       Order By 记录性质, NO, 收据费目)
                Group By 记录性质, NO) Loop
    n_Temp := 0;
    If n_结算卡类别id <> 0 Then
      Begin
        Select 交易流水号, 1
        Into v_交易流水号, n_Temp
        From 病人预交记录
        Where 卡类别id = n_结算卡类别id And 结帐id = Nvl(c_收费单.结帐id, 0);
      Exception
        When Others Then
          n_Temp := 0;
      End;
    
    End If;
    Begin
      Select Count(*) Into n_补结算 From 费用补充记录 Where 收费结帐id = Nvl(c_收费单.结帐id, 0) And Rownum < 2;
    Exception
      When Others Then
        n_补结算 := 0;
    End;
  
    Select Decode(Nvl(Count(*), 0), 0, 0, 1)
    Into n_医保结算
    From 保险结算记录
    Where 性质 = 1 And 记录id = Nvl(c_收费单.结帐id, 0);
  
    n_允许退款 := Nvl(c_收费单.是否退款, 0);
    n_已开医嘱 := 0;
  
    If c_收费单.挂号单 Is Not Null Then
      Begin
        Select 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = c_收费单.挂号单;
      Exception
        When Others Then
          n_已开医嘱 := 0;
      End;
      If Nvl(n_已开医嘱, 0) = 1 Then
        n_允许退款 := 0;
      End If;
    End If;
    If Nvl(n_已开医嘱, 0) = 1 Then
      v_说明 := '挂号单已开医嘱';
    Elsif Nvl(n_允许退款, 0) = 0 Then
      v_说明 := '单据已经执行';
    End If;
  
    If n_险类 Is Null Then
      Select Nvl(Max(1), 0) Into n_Mark From 病人预交记录 A Where a.结帐id = c_收费单.结帐id And a.结算方式 <> v_结算方式;
    
      If Nvl(n_医保结算, 0) = 1 Then
        v_说明     := '单据已经医保结算';
        n_允许退款 := 0;
      End If;
    Else
      Select Nvl(Max(1), 0)
      Into n_Mark
      From 病人预交记录 A, 结算方式 B
      Where a.结帐id = c_收费单.结帐id And a.结算方式 <> v_结算方式 And a.结算方式 = b.名称 And b.性质 Not In (3, 4);
      If n_Mark = 0 Then
        Select Nvl(Max(1), 0) Into n_Mark From 保险结算记录 A Where a.记录id = c_收费单.结帐id And 险类 <> n_险类;
      End If;
    End If;
    If Nvl(n_Mark, 0) = 1 Then
      v_说明     := '该单据包含不能退费的结算方式';
      n_允许退款 := 0;
    End If;
  
    If Nvl(n_补结算, 0) <> 0 Then
      v_说明     := '单据已经补充结算';
      n_允许退款 := 0;
      n_医保结算 := 1;
    End If;
  
    If Nvl(n_允许退款, 0) = 1 Then
      --检查是否有可退数量
      Select Decode(Nvl(Count(*), 0), 0, 0, 1)
      Into n_允许退款
      From (Select 序号, Sum(Nvl(付数, 0) * 数次) As 数量
             From 门诊费用记录 A
             Where NO = c_收费单.No And Mod(记录性质, 10) = c_收费单.记录性质 And 价格父号 Is Null Having Sum(Nvl(付数, 0) * 数次) <> 0
             Group By 序号);
      If Nvl(c_收费单.记录状态, 0) = 3 And n_允许退款 = 0 Then
        v_说明     := '单据已全退';
        n_允许退款 := 0;
      Elsif Nvl(c_收费单.记录状态, 0) = 3 Then
        v_说明     := '单据已部分退费';
        n_允许退款 := 0;
      End If;
    End If;
  
    If Nvl(n_允许退款, 0) = 1 And Nvl(c_收费单.是否打印, 0) = 1 Then
      v_说明     := '单据已开发票';
      n_允许退款 := 0;
    End If;
  
    Begin
      Select 状态, 审核原因
      Into n_退费状态, v_审核原因
      From 病人退费申请
      Where NO = c_收费单.No And Mod(记录性质, 10) = Mod(c_收费单.记录性质, 10);
    Exception
      When Others Then
        n_退费状态 := -1;
        v_审核原因 := '';
    End;
    n_退费状态 := n_退费状态 + 1;
    If n_退费状态 = 3 Then
      v_说明     := v_审核原因;
      n_允许退款 := 0;
    End If;
  
    v_Temp := '<DJH>' || c_收费单.No || '</DJH>';
    v_Temp := v_Temp || '<JLXZ>' || c_收费单.记录性质 || '</JLXZ>';
    v_Temp := v_Temp || '<YSJE>' || c_收费单.应收金额 || '</YSJE>';
    v_Temp := v_Temp || '<SSJE>' || c_收费单.实收金额 || '</SSJE>';
    v_Temp := v_Temp || '<FYMC>' || c_收费单.收据费目 || '</FYMC>';
    v_Temp := v_Temp || '<FKSJ>' || c_收费单.收款时间 || '</FKSJ>';
    v_Temp := v_Temp || '<JSKZF>' || n_Temp || '</JSKZF>';
    v_Temp := v_Temp || '<JYLSH>' || Nvl(v_交易流水号, '') || '</JYLSH>';
    v_Temp := v_Temp || '<YXTK>' || Nvl(n_允许退款, 0) || '</YXTK>';
    v_Temp := v_Temp || '<YBJS>' || n_医保结算 || '</YBJS>';
    v_Temp := v_Temp || '<KP>' || Nvl(c_收费单.是否打印, 0) || '</KP>';
    v_Temp := v_Temp || '<SQZT>' || n_退费状态 || '</SQZT>';
    v_Temp := v_Temp || '<JZTFSM>' || v_说明 || '</JZTFSM>';
    v_Temp := v_Temp || '<YJZID>' || c_收费单.结帐id || '</YJZID>';
    v_Temp := '<DJ>' || v_Temp || '</DJ>';
  
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End Loop;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Paymentinfo;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Getpayfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取收费划价单费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <DJH></DJH> //单据号
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <MXLIST>        //项目明细
  --    <ITEM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </ITEM>
  --    <ITEM>
  --    ...
  --    </ITEM>
  --  </MXLIST>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  v_Nos        Varchar2(4000);
  n_病人id     病人信息.病人id%Type;
  v_费别       病人信息.费别%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/DJH')
  Into n_病人id, v_Nos
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_总金额 := 0;

  For c_项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
               From 门诊费用记录 A, 收费项目目录 B, Table(f_Str2list(v_Nos)) C
               Where a.收费细目id = b.Id And a.No = c.Column_Value And a.记录性质 = 1 And a.记录状态 = 0
               Order By NO, 序号) Loop
    n_总金额 := n_总金额 + Nvl(c_项目.实收金额, 0);
    v_号码   := c_项目.计算单位;
    v_Temp   := v_Temp || '<ITEM><DJH>' || c_项目.No || '</DJH><MC>' || c_项目.项目名称 || '</MC>' || '<ID>' || c_项目.项目id ||
                '</ID>' || '<SL>' || c_项目.付数 * c_项目.数次 || '</SL>' || '<YSJE>' || c_项目.应收金额 || '</YSJE>' || '<SSJE>' ||
                c_项目.实收金额 || '</SSJE>' || '<SJFM>' || c_项目.收据费目 || '</SJFM></ITEM>';
  End Loop;

  v_Temp := '<MXLIST>' || v_Temp || '</MXLIST>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getpayfeedetail;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
Create Or Replace Procedure Zl_Third_Charge_Del
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费交易 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    <YJZID>原结帐ID</YJZID>       //原结帐ID
  --    <CXID>冲销ID</CXID>          //冲销ID
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;
  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_结帐金额   门诊费用记录.结帐金额%Type;
  n_误差额     病人预交记录.冲预交%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  l_挂号单     t_Strlist := t_Strlist();
  v_挂号单     门诊费用记录.No%Type;
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  v_结算卡类别 Varchar2(100);
  v_结帐ids    Varchar2(1000);

  n_消费卡id 消费卡目录.Id%Type;
  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);

  d_退费时间 病人预交记录.收款时间%Type;

  v_退费结算 Varchar2(2000);
  v_普通结算 Varchar2(4000);
  n_Temp     Number(18);

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Procedure Third_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   2.三方卡退费结算:
    --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:结算方式|结算金额|结算号码|结算摘要
    --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊退费结算_Modify(2, n_病人id, 冲销id_In, v_退费结算, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    冲销id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    退款金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    摘要_In       病人预交记录.摘要%Type,
    
    Xmlexpned_In Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
  
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  
    v_退费结算 := v_结算方式 || '|' || 退款金额_In || '|' || ' |' || Nvl(摘要_In, ' ');
    --   4-消费卡结算:
    --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||
    --     ②退支票额_In:传入零
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --卡类别ID|卡号|消费卡ID|消费金额||.
    v_退费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 退款金额_In;
    Zl_门诊退费结算_Modify(4, n_病人id, 冲销id_In, v_退费结算, 0, Null, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 冲销id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB')
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --人员id,人员编号,人员姓名 
  v_Temp       := Zl_Identity(1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  v_结帐ids    := Null;

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --1.先进行退费

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_冲销id, d_退费时间 From Dual;

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
    Begin
      Select 结算序号, 结帐id, 病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录
      Where 结帐id In (Select 结帐id
                     From 门诊费用记录
                     Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
    If Instr(',' || v_结帐ids || ',', ',' || n_结帐id || ',') = 0 Then
      v_结帐ids := v_结帐ids || ',' || n_结帐id;
    End If;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
    Begin
      Select Max(Decode(Instr(摘要, '挂号:'), 0, '', Replace(摘要, '挂号:', '')))
      Into v_挂号单
      From 门诊费用记录
      Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
    Exception
      When Others Then
        v_挂号单 := Null;
    End;
    If Not v_挂号单 Is Null Then
      l_挂号单.Extend;
      l_挂号单(l_挂号单.Count) := v_挂号单;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 = v_结算方式;
      If Nvl(n_Temp, 0) = 0 Then
        v_Err_Msg := '本次退费的单据不是' || v_结算方式 || '结算的,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    Zl_门诊收费记录_销帐(c_费用.单据号, v_操作员编码, v_操作员姓名, c_费用.退款序号, d_退费时间, v_摘要, n_冲销id);
    n_Count := n_Count + 1;
  End Loop;
  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.处理退费的结算信息

  n_结帐金额 := 0;

  --检查总金额是否正确 
  Select Sum(结帐金额) Into n_结帐金额 From 门诊费用记录 Where 结帐id = n_冲销id;

  n_误差额 := -1 * Nvl(n_结帐金额, 0) - Nvl(n_退款总额, 0);
  If Abs(n_误差额) > 1.00 Then
    v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
    Raise Err_Item;
  End If;

  --2.确定支付方式
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Third_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                               c_结算方式.Expend);
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Square_Cardbalance_Modfiy(n_冲销id, c_结算方式.卡类别, c_结算方式.卡号, c_结算方式.退款金额, c_结算方式.交易流水号, c_结算方式.交易说明, c_结算方式.摘要,
                                c_结算方式.Expend);
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Zl_门诊退费结算_Modify(4, n_病人id, n_冲销id, Null, c_结算方式.退款金额, Null, Null, Null, Null, 0, 0, 0, 0);
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定指付方式，不允缴款!';
        Raise Err_Item;
      End If;
      --结算方式|结算金额|结算号码|结算摘要||..
      v_退费结算 := c_结算方式.结算方式 || '|' || c_结算方式.退款金额 || '| |' || Nvl(c_结算方式.摘要, '  ');
      v_普通结算 := Nvl(v_普通结算, '') || '||' || v_退费结算;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||..
  --     ②退支票额_In:传入零
  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式!';
    Raise Err_Item;
  End If;

  --5.普通结算及完成结
  If v_普通结算 Is Not Null Then
    v_普通结算 := Substr(v_普通结算, 3);
  End If;
  Zl_门诊退费结算_Modify(1, n_病人id, n_冲销id, v_普通结算, 0, Null, Null, Null, Null, 0, 0, n_误差额, 2);

  If v_结帐ids Is Not Null Then
    v_结帐ids := Substr(v_结帐ids, 2);
  End If;

  If l_挂号单.Count <> 0 Then
    For I In 0 .. l_挂号单.Count Loop
      x_Templet := Xmltype('<IN></IN>');
      v_Temp    := '<GHDH>' || l_挂号单(I) || '</GHDH>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<JSKLB>' || 4 || '</JSKLB>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
      v_Temp := '<GHJE>' || 0 || '</GHJE>';
      Select Appendchildxml(x_Templet, '/IN', Xmltype(v_Temp)) Into x_Templet From Dual;
      Zl_Third_Registdel(x_Templet, Xml_Out);
    End Loop;
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_退费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YJZID>' || v_结帐ids || '</YJZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CXID>' || n_冲销id || '</CXID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Del;
/

--102666:胡俊勇,2016-11-30,门诊病人诊断医嘱对应
Create Or Replace Procedure Zl_病人诊断医嘱_Insert
(
  医嘱id_In  In 病人诊断医嘱.医嘱id%Type,
  诊断ids_In In Varchar2,
  诊断id_In  In 病人诊断医嘱.诊断id%Type := Null,
  医嘱ids_In In Varchar2 := Null
) Is
  n_Count Number(1);
  Err_Custom Exception;
  v_Error Varchar2(2000);
Begin
  If Not 诊断ids_In Is Null Then
    For r_Diag In (Select Column_Value As 诊断id From Table(Cast(f_Num2list(诊断ids_In) As Zltools.t_Numlist))) Loop
      Select Count(1) Into n_Count From 病人诊断记录 Where ID = r_Diag.诊断id;
      If n_Count = 1 Then
        Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (r_Diag.诊断id, 医嘱id_In);
      Else
        v_Error := '申请单对应的诊断被删除，请重新选择申请单对应的诊断！';
        Raise Err_Custom;
      End If;
    End Loop;
  End If;

  If Not 诊断id_In Is Null Then
    Select Count(1) Into n_Count From 病人诊断记录 Where ID = 诊断id_In;
    If n_Count = 0 Then
      v_Error := '对应的诊断被删除，请重新选择申请单对应的诊断！';
      Raise Err_Custom;
    End If;
    For r_Diag In (Select Column_Value As 医嘱id From Table(Cast(f_Num2list(医嘱ids_In) As Zltools.t_Numlist))) Loop
      Insert Into 病人诊断医嘱 (诊断id, 医嘱id) Values (诊断id_In, r_Diag.医嘱id);
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人诊断医嘱_Insert;
/

--102641:胡俊勇,2016-11-28,RIS预约相关修改
Create Or Replace Procedure Zl_Ris检查预约_Insert
(
  医嘱id_In     In Ris检查预约.医嘱id%Type,
  预约id_In     In Ris检查预约.预约id%Type,
  预约日期_In   In Ris检查预约.预约日期%Type,
  设备id_In     In Ris检查预约.检查设备id%Type,
  设备名称_In   In Ris检查预约.检查设备名称%Type,
  开始时间_In   In Ris检查预约.预约开始时间%Type,
  结束时间_In   In Ris检查预约.预约结束时间%Type,
  开始时间段_In In Ris检查预约.预约开始时间段%Type,
  结束时间段_In In Ris检查预约.预约结束时间段%Type,
  序号_In       In Ris检查预约.序号%Type
) Is
Begin
  Insert Into Ris检查预约
    (医嘱id, 预约id, 预约日期, 检查设备id, 检查设备名称, 预约开始时间, 预约结束时间, 预约开始时间段, 预约结束时间段, 序号)
  Values
    (医嘱id_In, 预约id_In, 预约日期_In, 设备id_In, 设备名称_In, 开始时间_In, 结束时间_In, 开始时间段_In, 结束时间段_In, 序号_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Ris检查预约_Insert;
/

--103097:王振涛,2016-11-24,处理多个年龄单位的情况
CREATE OR REPLACE Function Zl_Get_Reference
(
  Type_In       In Number, --0=参考 1=参考ID 2=危急参考 3=危急参考下限 4=危急参考上限
  项目id_In     In Number,
  标本类型_In   In Varchar2,
  性别_In       In Number,
  出生日期_In   In Date,
  仪器id_In     In Number := Null,
  年龄_In       In Varchar2 := Null,
  申请科室id_In In Number := Null
) Return Varchar2 As

  Cursor v_Reference_Type Is
    Select a.Id,
           Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
           Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
            Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限, Nvl(b.多参考, 0) 多参考
    From 检验项目参考 A, 检验项目 B,
         (Select '9999990' ||
                   Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式


           From 检验仪器项目 C, 检验项目 D
           Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
    Where a.项目id = 项目id_In And a.项目id = b.诊治项目id;

  v_Return Varchar2(4000);
  v_Sql    Varchar2(4000);

  Type c_Type Is Ref Cursor; --声明REF游标类型
  r_Emp v_Reference_Type%RowType; --声明一个行类型变量
  Cur   c_Type; --声明REF游标类型的变量

  v_结果类型 Number(1);

  v_年数     Number(18, 1);
  v_月数     Number(18, 1);
  v_日数     Number(18, 1);
  v_小时     Number(18, 1);
  v_出生日期 Date;
  v_Pos      Number(4);
  v_多参考   Number(4);
  v_Value    Number(18);
  v_Valuerec Varchar2(255);
  v_年龄     Varchar2(50);
  v_结果参考 Varchar2(1000);
  v_参考id   Number(18);
  v_危紧参考 Varchar2(1000);
  v_警示下限 Varchar2(1000);
  v_警示上限 Varchar2(1000);
  d_Sysdate  Date;

  v_项目id_Bound   检验项目参考.项目id%Type;
  v_标本类型_Bound 检验项目参考.标本类型%Type;
  v_性别域1_Bound  检验项目参考.性别域%Type;
  v_性别域2_Bound  检验项目参考.性别域%Type;
  v_性别域3_Bound  检验项目参考.性别域%Type;
  v_仪器id_Bound   检验项目参考.仪器id%Type;

  v_年龄单位日_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年_Bound   检验项目参考.年龄单位%Type;

  v_年龄单位日1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位月1_Bound   检验项目参考.年龄单位%Type;
  v_年龄单位小时1_Bound 检验项目参考.年龄单位%Type;
  v_年龄单位年1_Bound   检验项目参考.年龄单位%Type;

  v_临床特征_Bound   检验项目参考.临床特征%Type;
  v_申请科室id_Bound 检验项目参考.申请科室id%Type;
  v_年龄_1           Varchar2(50);
  v_年龄_2           Varchar2(50);

  Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
    n_Tmp Number;
  Begin
    n_Tmp := To_Number(v_In);
    If n_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;

  Function Zlsplit
  (
    v_Str       In Varchar2,
    v_Delimiter In Varchar2,
    v_Number    In Number
  ) Return Varchar2 Is
    v_Record     Varchar2(1000);
    v_Currrecord Varchar2(1000);
    v_Currnum    Number;
  Begin
    v_Record  := v_Str || v_Delimiter;
    v_Currnum := 0;
    While v_Record Is Not Null Loop
      v_Currrecord := Substr(v_Record, 1, Instr(v_Record, v_Delimiter) - 1);
      If v_Currnum = v_Number Then
        Return(v_Currrecord);
      End If;

      v_Currnum := v_Currnum + 1;
      v_Record  := Replace(v_Delimiter || v_Record, v_Delimiter || v_Currrecord || v_Delimiter);
    End Loop;

    Return('');
  End Zlsplit;
  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar(10);
  Begin
    Strnum := '';
    For Intbit In 1 .. 10 Loop
      If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
        Exit;
      End If;
      Strnum := Strnum || Substr(Vstr, Intbit, 1);
      Null;
    End Loop;
    Result := To_Number(Strnum);
    Return(Result);
  End Zlval;

Begin
  d_Sysdate := Sysdate;

  v_Sql := ' Select a.id,Trim(To_Char(A.参考低值, C.格式)) || ''～'' || Trim(To_Char(A.参考高值, C.格式)) || ' ||
           ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 结果参考, B.结果类型, B.取值序列, ' ||
           ' Trim(To_Char(A.警示下限, C.格式)) || ''～'' || Trim(To_Char(A.警示上限, C.格式)) || ' || ' Decode(A.临床特征, Null, '''', ''成人'', '''', ''婴儿'','''', '' '' || A.临床特征) As 危急参考,a.警示下限,a.警示上限,
             nvl(b.多参考,0) 多参考 ' || ' From 检验项目参考 A, 检验项目 B, ' || ' (Select ''9999990'' || ' ||
           ' Decode(Max(Nvl(C.小数位数, -1)), 0, '''', -1, ''.00'', Substr(''.000000'', 1, 1 + Max(Nvl(C.小数位数, -1)))) As 格式 ' ||
           ' From 检验仪器项目 C, 检验项目 D ' || ' Where D.诊治项目ID = :项目ID And D.诊治项目ID = C.项目ID(+)) C ' ||
           ' Where A.项目ID = :项目ID And A.项目ID = B.诊治项目ID ';

  v_项目id_Bound := 项目id_In;

  v_年龄 := 年龄_In;
  If v_年龄 = '岁' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '月' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '小时' Then
    v_年龄 := Null;
  End If;

  If v_年龄 = '天' Then
    v_年龄 := Null;
  End If;

  If Nvl(标本类型_In, '') <> '' Or 标本类型_In Is Not Null Then
    v_Sql := v_Sql || ' And A.标本类型 = :标本类型 ';
  Else
    v_Sql := v_Sql || ' And (A.标本类型 = :标本类型 or 1=1) ';
  End If;
  v_标本类型_Bound := 标本类型_In;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    --V_Sql := V_Sql || ' And A.性别域 = Nvl(' || 性别_In || ', 1) ';
    v_Sql := v_Sql || ' And decode(A.性别域,null,:性别,0,:性别,A.性别域) = Nvl(:性别, 1) ';

  Else
    v_Sql := v_Sql || ' And (decode(A.性别域,null,:性别1,0,:性别2,A.性别域) = Nvl(:性别3, 1) or 1 = 1) ';
  End If;
  v_性别域1_Bound := 性别_In;
  v_性别域2_Bound := 性别_In;
  v_性别域3_Bound := 性别_In;

  If Nvl(仪器id_In, '') <> '' Or 仪器id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null) ';
  Else
    v_Sql := v_Sql || ' And (A.仪器id = :仪器ID Or A.仪器id Is Null or 1=1) ';
  End If;
  v_仪器id_Bound := 仪器id_In;

  If Nvl(v_年龄, '') <> '' Or v_年龄 Is Not Null Then
    If Instr(v_年龄, '岁') > 0 Or Instr(v_年龄, '月') > 0 Or Instr(v_年龄, '天') > 0 Or Instr(v_年龄, '小时') > 0 Or
       Sub_Is_Number(v_年龄) Then
      --处理日期
      v_出生日期 := 出生日期_In;
      v_年龄_1   := v_年龄;
      If Instr(v_年龄_1, '岁') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '岁'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '岁') + 1);
      Elsif Instr(v_年龄, '月') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '月'));
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '月') + 1);
      Elsif Instr(v_年龄, '小时') > 0 Then
        v_年龄   := Substr(v_年龄_1, 1, Instr(v_年龄_1, '小时') + 1);
        v_年龄_2 := Substr(v_年龄_1, Instr(v_年龄_1, '小时') + 2);
        If v_年龄 = '0小时' Or v_年龄 = '0时' Then
          v_年龄 := ' ';
        End If;
      End If;
      If v_年龄 Is Not Null And (v_年龄 = '成人' Or v_年龄 = '婴儿' Or v_年龄 = '岁') = False Then
        If Substr(v_年龄, 1, 1) = '*' Then
          v_出生日期 := Add_Months(d_Sysdate, -216);
        Else
          If Substr(v_年龄, Length(v_年龄)) = '月' Then
            v_出生日期 := Add_Months(d_Sysdate, -1 * Nvl(Zlval(v_年龄), 0));
          Else
            If Substr(v_年龄, Length(v_年龄)) = '天' Then
              v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0);
            Else
              If Substr(v_年龄, Length(v_年龄) - 1) = '小时' Then
                If Nvl(Zlval(v_年龄), 0) <> 0 Then
                  v_出生日期 := d_Sysdate - Nvl(Zlval(v_年龄), 0) / 24;
                End If;
              Else
                v_出生日期 := Add_Months(d_Sysdate, -12 * Nvl(Zlval(v_年龄), 0)) - 1;
              End If;
            End If;
          End If;
          If v_年龄_2 Is Not Null Then
            If Substr(v_年龄_2, Length(v_年龄_2)) = '月' Then
              v_出生日期 := Add_Months(v_出生日期, -1 * Nvl(Zlval(v_年龄_2), 0));
            Else
              If Substr(v_年龄_2, Length(v_年龄_2)) = '天' Then
                v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0);
              Else
                If Substr(v_年龄_2, Length(v_年龄_2) - 1) = '小时' Then
                  If Nvl(Zlval(v_年龄_2), 0) <> 0 Then
                    v_出生日期 := v_出生日期 - Nvl(Zlval(v_年龄_2), 0) / 24;
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
      If Not (v_出生日期 Is Null) Then
        v_年数 := Round(Months_Between(d_Sysdate, v_出生日期) / 12 ,1);
        v_月数 := Round(Months_Between(d_Sysdate, v_出生日期) ,1);
        v_日数 := Round(d_Sysdate - v_出生日期 ,1);
        v_小时 := Round((d_Sysdate - (v_出生日期 - 1 / 24)) * 24 - 1);
      End If;
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日_Bound   := v_日数;
  v_年龄单位月_Bound   := v_月数;
  v_年龄单位小时_Bound := v_小时;
  v_年龄单位年_Bound   := v_年数;
  If Instr(v_年龄, '成人') > 0 Or Instr(v_年龄, '婴儿') > 0 Or Instr(v_年龄, '分钟') > 0 Then
    --处理成人和婴儿
    v_Sql := v_Sql || ' And A.临床特征 =:年龄';
  Else
    v_Sql := v_Sql || ' And (A.临床特征 =:年龄 or 1=1)';
    v_Sql := v_Sql || ' And instr(''婴儿,成人'',nvl(临床特征,'' '')) <= 0  ';
  End If;

  v_临床特征_Bound := Replace(v_年龄, '分钟', '婴儿');

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' And (A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) ';
  Else
    v_Sql := v_Sql || ' And ((A.申请科室ID = :申请科室ID Or nvl(A.申请科室ID,0) = 0) or 1=1) ';
  End If;
  v_申请科室id_Bound := 申请科室id_In;

  If (Nvl(v_年龄, '') = '' Or v_年龄 Is Null) And (出生日期_In <> '' Or 出生日期_In Is Not Null) Then
    --按出生日期查询
    If Not (出生日期_In Is Null) Then
      v_年数 := Round(Months_Between(d_Sysdate, 出生日期_In) / 12 - 0.5);
      v_月数 := Round(Months_Between(d_Sysdate, 出生日期_In) - 0.5);
      v_日数 := Round(d_Sysdate - 出生日期_In - 0.5);
      v_小时 := Round((d_Sysdate - (出生日期_In - 1 / 24)) * 24 - 1);

      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) )';
    Else
      v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
               ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
    End If;

  Else
    v_Sql := v_Sql || 'And (Decode(A.年龄单位, ''日'',:日, ''月'',:月,''小时'',:小时,:年) ' ||
             ' Between Nvl(A.年龄下限, -9999) And Nvl(A.年龄上限, 9999) or 1=1 )';
  End If;
  v_年龄单位日1_Bound   := v_日数;
  v_年龄单位月1_Bound   := v_月数;
  v_年龄单位小时1_Bound := v_小时;
  v_年龄单位年1_Bound   := v_年数;

  --加上排序
  v_Sql := v_Sql || ' Order By a.默认 desc,A.临床特征 ';

  If Nvl(申请科室id_In, '') <> '' Or 申请科室id_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.申请科室ID  ';
  End If;

  If Nvl(性别_In, '') <> '' Or 性别_In Is Not Null Then
    v_Sql := v_Sql || ' ,a.性别域 desc  ';
  Else
    v_Sql := v_Sql || ' ,a.性别域 ';
  End If;

  v_Sql := v_Sql || ' ,a.id ';

  v_Return := '';
  Open Cur For v_Sql
    Using v_项目id_Bound, v_项目id_Bound, v_标本类型_Bound, v_性别域1_Bound, v_性别域2_Bound, v_性别域3_Bound, v_仪器id_Bound, v_年龄单位日_Bound, v_年龄单位月_Bound, v_年龄单位小时_Bound, v_年龄单位年_Bound, v_临床特征_Bound, v_申请科室id_Bound, v_年龄单位日1_Bound, v_年龄单位月1_Bound, v_年龄单位小时1_Bound, v_年龄单位年1_Bound;

  Loop
    Fetch Cur
      Into r_Emp;
    Exit When Cur%NotFound;
    If Cur%RowCount > 0 Then

      v_结果类型 := r_Emp.结果类型;
      v_Valuerec := r_Emp.取值序列;
      v_参考id   := r_Emp.Id;
      v_多参考   := r_Emp.多参考;

      If Nvl(v_Return, '') = '' Or v_Return Is Null Then
        If Type_In = 2 Then
          v_Return := r_Emp.危急参考;
        Else
          v_Return := r_Emp.结果参考;
        End If;
      Else
        If Type_In = 2 Then
          v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.危急参考;
        Else
          If v_多参考 = 1 Then
            v_Return := v_Return || Chr(13) || Chr(10) || r_Emp.结果参考;
          End If;
        End If;
      End If;

      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    End If;
  End Loop;

  If v_Return = '' Or v_Return Is Null Then
    Begin
      Select 结果参考, 结果类型, 取值序列, ID, 危急参考, 警示下限, 警示上限
      Into v_结果参考, v_结果类型, v_Valuerec, v_参考id, v_危紧参考, v_警示下限, v_警示上限
      From (Select a.Id,
                    Trim(To_Char(a.参考低值, c.格式)) || '～' || Trim(To_Char(a.参考高值, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 结果参考, b.结果类型, b.取值序列,
                    Trim(To_Char(a.警示下限, c.格式)) || '～' || Trim(To_Char(a.警示上限, c.格式)) ||
                     Decode(a.临床特征, Null, '', '成人', '', '婴儿', '', ' ' || a.临床特征) As 危急参考, a.警示下限, a.警示上限
             From 检验项目参考 A, 检验项目 B,
                  (Select '9999990' ||
                            Decode(Max(Nvl(c.小数位数, -1)), 0, '', -1, '.00', Substr('.000000', 1, 1 + Max(Nvl(c.小数位数, -1)))) As 格式
                    From 检验仪器项目 C, 检验项目 D
                    Where d.诊治项目id = 项目id_In And d.诊治项目id = c.项目id(+)) C
             Where a.项目id = 项目id_In And a.项目id = b.诊治项目id
             Order By a.默认 Desc, a.临床特征, a.性别域)
      Where Rownum = 1;
      If Type_In = 2 Then
        v_Return := v_危紧参考;
      Else
        v_Return := v_结果参考;
      End If;
      --只增加第一个选出的警示参考
      If v_警示下限 = '' Or v_警示下限 Is Null Then
        v_警示下限 := r_Emp.警示下限;
      End If;
      If v_警示上限 = '' Or v_警示上限 Is Null Then
        v_警示上限 := r_Emp.警示上限;
      End If;
    Exception
      When Others Then
        v_Return := Null;
    End;
  End If;
  If v_Return <> '' Or v_Return Is Not Null Then

    If v_Return = '～' Then
      v_Return := '';
    Else
      If v_结果类型 = 2 Then
        v_Pos := Instr(v_Return, '～');

        Begin
          Select To_Number(Substr(v_Return, 1, v_Pos - 1)) Into v_Value From Dual;
        Exception
          When Others Then
            v_Value := 0;
        End;
        v_Return := Zlsplit(v_Valuerec, ';', v_Value);
      End If;
    End If;
    If Type_In = 0 Then
      Return v_Return;
    Elsif Type_In = 1 Then
      Return v_参考id;
    Elsif Type_In = 2 Then
      Return v_Return;
    Elsif Type_In = 3 Then
      Return v_警示下限;
    Elsif Type_In = 4 Then
      Return v_警示上限;
    End If;
  End If;
  Close Cur; --关闭游标
  Return v_Return;
End Zl_Get_Reference;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_结帐费用记录_Insert
(
  Id_In       住院费用记录.Id%Type,
  No_In       住院费用记录.No%Type,
  记录性质_In 住院费用记录.记录性质%Type,
  记录状态_In 住院费用记录.记录状态%Type,
  执行状态_In 住院费用记录.执行状态%Type,
  序号_In     住院费用记录.序号%Type,
  结帐金额_In 住院费用记录.结帐金额%Type,
  结帐id_In   住院费用记录.结帐id%Type
) As
  n_Next_Id    住院费用记录.Id%Type;
  n_病人id     住院费用记录.病人id%Type;
  n_主页id     住院费用记录.主页id%Type;
  n_病人病区id 住院费用记录.病人病区id%Type;
  n_病人科室id 住院费用记录.病人科室id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  n_执行部门id 住院费用记录.执行部门id%Type;
  n_收入项目id 住院费用记录.收入项目id%Type;
  n_门诊标志   住院费用记录.门诊标志%Type;
  n_记帐费用   住院费用记录.记帐费用%Type;
  v_操作员     住院费用记录.操作员姓名%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;
  v_操作员编码 住院费用记录.操作员编号%Type;

  n_结帐金额 住院费用记录.结帐金额%Type;
  n_实收金额 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;
  n_类别     Number(18);
  v_Temp     Varchar2(500);
  Err_Custom Exception;
  Err_Special Exception;
  v_Error Varchar2(255);
  n_来源  Number;
Begin
  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员姓名 := v_Temp;
  End If;

  If Id_In <> 0 Then
    Begin
      Select 2 Into n_来源 From 住院费用记录 Where ID = Id_In;
    Exception
      When Others Then
        n_来源 := 1;
    End;
  
    --第一次结帐但部分结
    If n_来源 = 1 Then
      Update 门诊费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    Else
      Update 住院费用记录 Set 结帐金额 = 结帐金额_In, 结帐id = 结帐id_In Where ID = Id_In And 结帐id Is Null;
    End If;
  
    If Sql%RowCount = 0 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  
    n_Next_Id := Id_In;
  Else
    --结以前的余帐
    Select 病人费用记录_Id.Nextval Into n_Next_Id From Dual;
  
    If Mod(记录性质_In, 10) = 3 Or Mod(记录性质_In, 10) = 5 Then
      --自动记帐或就诊卡;肯定是住院
      n_来源 := 2;
    Else
      Begin
        Select 2
        Into n_来源
        From 住院费用记录
        Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
              Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      Exception
        When Others Then
          n_来源 := 1;
      End;
    End If;
  
    If n_来源 = 1 Then
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
         执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要)
        Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄,
               标识号, 付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, Null,
               Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In, 结帐id_In, 保险项目否,
               保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要
        From 门诊费用记录
        Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
              Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
    
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 门诊费用记录
      Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And
            Nvl(执行状态, 0) = 执行状态_In;
    
    Else
      Insert Into 住院费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 床号, 病人病区id,
         病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人,
         开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额, 结帐id, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型,
         是否急诊, 摘要, 医疗小组id)
        Select n_Next_Id, NO, 实际票号, To_Number('1' || 记录性质_In), 记录状态, 序号, 从属父号, 价格父号, 多病人单, 记帐单id, 病人id, 主页id, 医嘱序号, 门诊标志,
               姓名, 性别, 年龄, 标识号, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 记帐费用, 收入项目id,
               收据费目, 标准单价, Null, Null, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行人, 执行时间, 操作员姓名, 操作员编号, 结帐金额_In,
               结帐id_In, 保险项目否, 保险大类id, 统筹金额, 保险编码, 费用类型, 是否急诊, 摘要, 医疗小组id
        From 住院费用记录
        Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Nvl(执行状态, 0) = Nvl(执行状态_In, 0) And
              Substr(记录性质, Length(记录性质), 1) = 记录性质_In And Rownum = 1;
      --检查多次结帐后结帐金额是否高于原金额
      Select Nvl(Sum(实收金额), 0), Nvl(Sum(结帐金额), 0)
      Into n_实收金额, n_结帐金额
      From 住院费用记录
      Where NO = No_In And 序号 = 序号_In And 记录状态 = 记录状态_In And Substr(记录性质, Length(记录性质), 1) = 记录性质_In And
            Nvl(执行状态, 0) = 执行状态_In;
    End If;
    If n_结帐金额 > n_实收金额 Then
      If n_来源 = 1 Then
        Select Max(b.操作员姓名)
        Into v_操作员
        From 门诊费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      Else
        Select Max(b.操作员姓名)
        Into v_操作员
        From 住院费用记录 A, 病人结帐记录 B
        Where a.Id = Id_In And b.Id = a.结帐id;
      End If;
      If v_操作员 Is Null Then
        v_Error := '未发现结帐的费用,当前结帐操作不能继续。';
        Raise Err_Custom;
      Else
        If v_操作员姓名 = v_操作员 Then
          v_Error := '发现已经被结帐的费用,当前结帐操作不能继续。';
          Raise Err_Special;
        Else
          v_Error := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  End If;
  If n_来源 = 1 Then
    Select 病人id, Null, Null, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 门诊费用记录
    Where ID = n_Next_Id;
    n_类别 := 1;
  Else
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用
    Into n_病人id, n_主页id, n_病人病区id, n_病人科室id, n_开单部门id, n_执行部门id, n_收入项目id, n_门诊标志, n_记帐费用
    From 住院费用记录
    Where ID = n_Next_Id;
  
    If Nvl(n_门诊标志, 0) = 1 Or Nvl(n_门诊标志, 0) = 2 Then
      n_类别 := n_门诊标志;
    Elsif Nvl(n_主页id, 0) = 0 Or Nvl(n_门诊标志, 0) = 4 Then
      n_类别 := 1;
    Else
      n_类别 := 2;
    End If;
  End If;

  --病人余额
  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) - 结帐金额_In
  Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
  Returning 费用余额 Into n_返回值;
  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, n_类别, 0, -1 * 结帐金额_In);
    n_返回值 := -1 * 结帐金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = n_病人id;
  End If;

  --病人未结费用
  Update 病人未结费用
  Set 金额 = Nvl(金额, 0) - 结帐金额_In
  Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(n_主页id, 0) And Nvl(病人病区id, 0) = Nvl(n_病人病区id, 0) And
        Nvl(病人科室id, 0) = Nvl(n_病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(n_开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(n_执行部门id, 0) And
        收入项目id + 0 = n_收入项目id And 来源途径 + 0 = n_门诊标志
  Returning 金额 Into n_返回值;
  If Sql%RowCount = 0 Then
    Insert Into 病人未结费用
      (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
    Values
      (n_病人id, Decode(n_主页id, 0, Null, n_主页id), Decode(n_病人病区id, 0, Null, n_病人病区id), n_病人科室id, n_开单部门id, n_执行部门id,
       n_收入项目id, n_门诊标志, -1 * 结帐金额_In);
    n_返回值 := -1 * 结帐金额_In;
  End If;
  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人未结费用 Where 病人id = n_病人id And Nvl(金额, 0) = 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐费用记录_Insert;
/

--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_结帐费用记录_Batch
(
  Ids_In    Varchar2,
  病人id_In 住院费用记录.病人id%Type,
  结帐id_In 住院费用记录.结帐id%Type
  
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
  v_Temp    Varchar2(500);
  Err_Special Exception;
  v_操作员     住院费用记录.操作员姓名%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;
  v_操作员编码 住院费用记录.操作员编号%Type;

  n_门诊结算合计 住院费用记录.结帐金额%Type;
  n_住院结算合计 住院费用记录.结帐金额%Type;
  n_类别         Number;

  n_来源   Number; --1门诊;2-住院;3-门诊和住院
  n_返回值 病人余额.费用余额%Type;
Begin
  --人员id,人员编号,人员姓名
  v_Temp := Zl_Identity(1);
  If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_操作员姓名 := v_Temp;
  End If;
  n_门诊结算合计 := 0;
  n_住院结算合计 := 0;
  Begin
    Select Case
             When Max(住院来源) = 1 And Max(门诊来源) = 1 Then
              3
             When Max(门诊来源) = 1 Then
              1
             Else
              2
           End
    Into n_来源
    From (Select /*+ Rule*/
            1 As 住院来源, 0 As 门诊来源
           From 住院费用记录 A, (Select Column_Value From Table(Cast(f_Num2list(Ids_In) As Zltools.t_Numlist))) J
           Where a.Id = j.Column_Value And 病人id + 0 = 病人id_In And 结帐id Is Null And Rownum = 1
           Union All
           Select /*+ Rule*/
            0 As 住院来源, 1 As 门诊来源
           From 门诊费用记录 A, (Select Column_Value From Table(Cast(f_Num2list(Ids_In) As Zltools.t_Numlist))) J
           Where a.Id = j.Column_Value And 病人id + 0 = 病人id_In And 结帐id Is Null And Rownum = 1);
  Exception
    When Others Then
      n_来源 := 2;
  End;

  --第一次结帐并且全结,Ids_In最大长度限制3998
  If n_来源 = 1 Then
    Update 门诊费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  Elsif n_来源 = 2 Then
    Update 住院费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  Else
    Update 门诊费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  
    Update 住院费用记录
    Set 结帐金额 = 实收金额, 结帐id = 结帐id_In
    Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0 And 结帐id Is Null;
  End If;

  If Sql%RowCount = 0 Then
    If n_来源 = 1 Then
      Select Max(b.操作员姓名)
      Into v_操作员
      From 门诊费用记录 A, 病人结帐记录 B
      Where Instr(',' || Ids_In || ',', ',' || a.Id || ',') > 0 And b.Id = a.结帐id;
    Else
      Select Max(b.操作员姓名)
      Into v_操作员
      From 住院费用记录 A, 病人结帐记录 B
      Where Instr(',' || Ids_In || ',', ',' || a.Id || ',') > 0 And b.Id = a.结帐id;
    End If;
    If v_操作员 Is Null Then
      v_Err_Msg := '未发现结帐的费用,当前结帐操作不能继续。';
      Raise Err_Item;
    Else
      If v_操作员姓名 = v_操作员 Then
        v_Err_Msg := '发现已经被结帐的费用,当前结帐操作不能继续。';
        Raise Err_Special;
      Else
        v_Err_Msg := '发现已经被其他人结帐的费用,当前结帐操作不能继续。';
        Raise Err_Item;
      End If;
    End If;
  End If;
  If n_来源 = 2 Or n_来源 = 3 Then
    For r_f In (Select 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用, Sum(结帐金额) 结帐金额

                From 住院费用记录
                Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0
                Group By 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用) Loop
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_f.结帐金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(r_f.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_f.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_f.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_f.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_f.执行部门id, 0) And 收入项目id + 0 = r_f.收入项目id And 来源途径 + 0 = r_f.门诊标志;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, r_f.主页id, r_f.病人病区id, r_f.病人科室id, r_f.开单部门id, r_f.执行部门id, r_f.收入项目id, r_f.门诊标志, -1 * r_f.结帐金额);
      End If;
    
      If Nvl(r_f.门诊标志, 0) = 1 Or Nvl(r_f.门诊标志, 0) = 2 Then
        n_类别 := r_f.门诊标志;
      Elsif Nvl(r_f.主页id, 0) = 0 Or Nvl(r_f.门诊标志, 0) = 4 Then
        n_类别 := 1;
      Else
        n_类别 := 2;
      End If;
    
      If n_类别 = 1 Then
        n_门诊结算合计 := Nvl(n_门诊结算合计, 0) + Nvl(r_f.结帐金额, 0);
      Else
        n_住院结算合计 := Nvl(n_住院结算合计, 0) + Nvl(r_f.结帐金额, 0);
      End If;
    End Loop;
  End If;
  If n_来源 = 3 Or n_来源 = 1 Then
    For r_f In (Select Null As 主页id, Null As 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用, Sum(结帐金额) 结帐金额
                From 门诊费用记录
                Where 病人id = 病人id_In And Instr(',' || Ids_In || ',', ',' || ID || ',') > 0
                Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id, 门诊标志, 记帐费用) Loop
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - r_f.结帐金额
      Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(r_f.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_f.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_f.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_f.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_f.执行部门id, 0) And 收入项目id + 0 = r_f.收入项目id And 来源途径 + 0 = r_f.门诊标志;
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, r_f.主页id, r_f.病人病区id, r_f.病人科室id, r_f.开单部门id, r_f.执行部门id, r_f.收入项目id, r_f.门诊标志, -1 * r_f.结帐金额);
      End If;
      If Nvl(r_f.门诊标志, 0) = 1 Or Nvl(r_f.门诊标志, 0) = 2 Then
        n_类别 := r_f.门诊标志;
      Elsif Nvl(r_f.主页id, 0) = 0 Or Nvl(r_f.门诊标志, 0) = 4 Then
        n_类别 := 1;
      Else
        n_类别 := 2;
      End If;
    
      If n_类别 = 1 Then
        n_门诊结算合计 := Nvl(n_门诊结算合计, 0) + Nvl(r_f.结帐金额, 0);
      Else
        n_住院结算合计 := Nvl(n_住院结算合计, 0) + Nvl(r_f.结帐金额, 0);
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 病人id = 病人id_In And Nvl(金额, 0) = 0;

  --病人余额
  If Nvl(n_门诊结算合计, 0) <> 0 Then
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - n_门诊结算合计
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (病人id_In, 1, 1, 0, -1 * n_门诊结算合计);
      n_返回值 := -1 * n_门诊结算合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = 病人id_In And 类型 = 1;
    End If;
  End If;
  If Nvl(n_住院结算合计, 0) <> 0 Then
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) - n_住院结算合计
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
    Returning 费用余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (病人id_In, 1, 2, 0, -1 * n_住院结算合计);
      n_返回值 := -1 * n_住院结算合计;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0 And 病人id = 病人id_In And 类型 = 2;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐费用记录_Batch;
/

--102112:冉俊明,2016-12-22,门诊划价收费时门诊病人标识号填写了住院号。
--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
Create Or Replace Procedure Zl_病人划价收费_Insert
(
  No_In         门诊费用记录.No%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  发药窗口_In   Varchar2 := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  登记时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：用于收费时收取划价单费用
  --参数：
  --      发药窗口_In:执行部门ID1|发药窗口1;...;执行部门IDn|发药窗口n

  --        病人来源_IN:1-门诊;2-住院
  --说明：
  --        1.收取划价费用时,才计算费用相关汇总,在划价时不处理;但药品相关汇总(姓名除外)划价时已经计算。
  --        2.收取划价费用时,目前界面及过程中未处理加收工本费,由划价时直接处理。
  --该游标为划价原单据内容
  Cursor c_Price Is
    Select ID
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 操作员姓名 Is Null
    Order By 序号;

  n_Array_Size Number := 200;
  t_费用id     t_Numlist;
  v_部门名称   部门表.名称%Type;

  v_标识号   门诊费用记录.标识号%Type;
  n_病人来源 门诊费用记录.门诊标志%Type;
  v_付款方式 医疗付款方式.名称%Type;

  --临时变量
  n_Count      Number;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_新病人模式 Number;
  v_出库no     药品收发记录.No%Type;
  v_Date       Date;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;
  n_组id 财务缴款分组.Id%Type;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Select Count(ID)
  Into n_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 操作员姓名 Is Null;
  If n_Count = 0 Then
    Select Max(操作员姓名) Into v_操作员姓名 From 门诊费用记录 Where 记录性质 = 1 And NO = No_In;
    If v_操作员姓名 Is Not Null Then
      If v_操作员姓名 = 操作员姓名_In Then
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Special;
      Else
        v_Err_Msg := '不能读取划价单内容,该单据已经被收费！';
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '不能读取划价单内容,该单据已经被删除！';
      Raise Err_Item;
    End If;
  End If;
  v_Date := 登记时间_In;
  If v_Date Is Null Then
    Select Sysdate Into v_Date From Dual;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    Select Decode(当前科室id, Null, 门诊号, 住院号), Decode(当前科室id, Null, 1, 2)
    Into v_标识号, n_病人来源
    From 病人信息
    Where 病人id = 病人id_In;
  End If;

  ------------------------------------------------------------------------------------------------------------------------
  --批量更新
  Open c_Price;
  Loop
    Fetch c_Price Bulk Collect
      Into t_费用id Limit n_Array_Size;
    Exit When t_费用id.Count = 0;
  
    --循环处理门诊费用记录
    Forall I In 1 .. t_费用id.Count
    --执行状态相关字段不处理,在划价时处理;因为可能未收费发药,这种已执行的划价单是允许收费操作的。
    --为保证与预交结算记录的时间相同,重新填写登记时间,但药品部分不变动。
      Update 门诊费用记录
      Set 记录状态 = 1, 病人id = Decode(病人id_In, 0, Null, 病人id_In), 门诊标志 = Decode(标识号, Null, Nvl(n_病人来源, 门诊标志), 门诊标志),
          标识号 = Nvl(标识号, v_标识号), 付款方式 = 付款方式_In, 姓名 = 姓名_In, 年龄 = 年龄_In, 性别 = 性别_In,
          --可能保持医嘱发送的内容
          病人科室id = Nvl(病人科室id_In, 病人科室id), 开单部门id = Nvl(开单部门id_In, 开单部门id), 开单人 = Nvl(开单人_In, 开单人), 结帐金额 = 实收金额,
          结帐id = 结帐id_In, 发生时间 = 发生时间_In, 登记时间 = v_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 是否急诊 = 是否急诊_In,
          缴款组id = n_组id, 费用状态 = 1, 执行状态 = Decode(Nvl(执行状态, 0), -1, Null, Nvl(执行状态, 0))
      Where ID = t_费用id(I) And 记录状态 = 0;
  
    If Sql%RowCount <> t_费用id.Count Then
      Select Count(1)
      Into n_Count
      From 门诊费用记录
      Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
      If n_Count <> t_费用id.Count Then
        v_Err_Msg := '由于并发操作,该单据已经删除！';
        Raise Err_Item;
      Else
        Select Max(操作员姓名)
        Into v_操作员姓名
        From 门诊费用记录
        Where 记录状态 = 1 And ID In (Select Column_Value From Table(t_费用id));
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Special;
        Else
          v_Err_Msg := '由于并发操作,该单据已经收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;

  Close c_Price;

  --相关汇总表的处理
  --药品部分非费用信息的修改
  --药品未发记录(如果已发药则修改不到),分离发药时无库房ID
  --可能存在材料和药品库房相同，但材料无发药窗口
  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 24 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  Update 未发药品记录
  Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 对方部门id = 开单部门id_In, 已收费 = 1, 填制日期 = v_Date
  Where 单据 = 8 And NO = No_In And
        Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  --药品收发记录(可能已经发药或取消发药,所有记录更改)
  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 24 And NO = No_In And
        费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');

  -------------------------------------------------------------------------------------------
  --处理备货卫材
  n_Count := Null;
  Begin
    Select Count(*), Max(a.No)
    Into n_Count, v_出库no
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And b.收费类别 = '4' And b.记录性质 = 1 And b.记录状态 = 1 And b.No = No_In And
          Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0 And Rownum <= 1;
  Exception
    When Others Then
      Null;
  End;
  If Nvl(n_Count, 0) > 0 Then
    If Nvl(病人科室id_In, 0) <> 0 Then
      Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
    End If;
    v_Err_Msg := LPad(' ', 4);
    v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                        '门诊号:' || Nvl(v_标识号, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
  
    Update 药品收发记录
    Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date), 摘要 = v_Err_Msg
    Where 单据 = 21 And NO = v_出库no And
          费用id + 0 In (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 = '4');
  End If;

  Update 药品收发记录
  Set 对方部门id = 开单部门id_In, 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
  Where 单据 = 8 And NO = No_In And
        费用id + 0 In
        (Select ID From 门诊费用记录 Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));

  If Not 发药窗口_In Is Null Then
    --更新发药窗口
    For v_窗口 In (Select To_Number(C1) As C1, C2 From Table(f_Str2list2(发药窗口_In, ';', '|'))) Loop
    
      Update 门诊费用记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And 执行部门id = Nvl(v_窗口.C1, 执行部门id) And 收费类别 In ('5', '6', '7');
    
      Update 药品收发记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            费用id + 0 In (Select ID
                         From 门诊费用记录
                         Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
      Update 未发药品记录
      Set 发药窗口 = Nvl(v_窗口.C2, 发药窗口)
      Where 单据 = 8 And NO = No_In And 库房id = Nvl(v_窗口.C1, 库房id) And
            Nvl(库房id, 0) In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 1 And 记录状态 = 1 And NO = No_In And 收费类别 In ('5', '6', '7'));
    
    End Loop;
  End If;

  --更新部份病人信息
  If 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    --通过划价单收费时不允许改费别,因为费用不允许变
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
    
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;

  --医嘱处理
  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 1, No_In);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人划价收费_Insert;
/

--85987:梁唐彬,2016-11-22,修改医嘱清除处方审查数据

CREATE OR REPLACE Procedure Zl_病人医嘱记录_Delete
(
  --功能：删除指定医嘱,适用于门诊和住院。
  --参数：
  --      医嘱ID_IN：当前要删除的医嘱的ID(是可见行的单条医嘱ID，不是组ID)
  --      删相关_IN=0时,只删除指定ID的医嘱(医嘱编辑程序调用)。
  --          1.相关医嘱的同步删除及删除之后的序号调整由程序处理后调用对应过程。
  --          2.被删除的医嘱应该未校对,程序应已控制。
  --          3.病人医嘱状态的内容会自动删除；病人医嘱计价，病人医嘱发送未校对的没有记录。
  --      删相关_IN=1时,删除整条医嘱(管理界面调用)，如给药途径，检查组合，手术附项，中药配方。
  --          1.需要在过程中同时调整相关记录的序号。
  --          2.一并给药的只删除当前药品记录(不包括给药途径)。
  医嘱id_In 病人医嘱记录.Id%Type,
  删相关_In Number := 0
) Is
  v_状态            病人医嘱记录.医嘱状态%Type;
  v_相关id          病人医嘱记录.相关id%Type;
  v_病人id          病人医嘱记录.病人id%Type;
  v_挂号单          病人医嘱记录.挂号单%Type;
  v_主页id          病人医嘱记录.主页id%Type;
  v_婴儿            病人医嘱记录.婴儿%Type;
  v_序号            病人医嘱记录.序号%Type;
  v_内容            病人医嘱记录.医嘱内容%Type;
  v_路径执行id      病人路径执行.Id%Type;
  v_Other路径执行id 病人路径执行.Id%Type;
  v_路径执行方式    临床路径项目.执行方式%Type;
  v_内容要求        临床路径项目.内容要求%Type;
  v_Count           Number(5);
  v_路径记录id      病人临床路径.Id%Type;
  v_变异原因        病人路径执行.变异原因%Type;
  n_是否评估        Number(5);
  n_路径项目id      病人路径执行.项目id%Type;
  n_Islast          Number(5);
  n_Del_Count       Number(5);
  n_Del类型         Number(2); --0-只删除指定ID的医嘱，1-删除整条医嘱
  v_诊疗类别        病人医嘱记录.诊疗类别%Type;
  v_审核状态        病人医嘱记录.审核状态%Type;
  v_诊疗项目ID      病人医嘱记录.诊疗项目ID%Type;
  v_启用血库        zlParameters.参数值%Type;
  v_执行分类        诊疗项目目录.执行分类%type;
  v_处方审查锁定ids Varchar2(4000);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态:并发操作
  Begin
    Select 病人id, 挂号单, 主页id, 婴儿, 医嘱状态, 相关id, 医嘱内容, 诊疗类别, 审核状态,诊疗项目ID
    Into v_病人id, v_挂号单, v_主页id, v_婴儿, v_状态, v_相关id, v_内容, v_诊疗类别, v_审核状态,v_诊疗项目ID
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '未发现要删除的医嘱记录，可能已被其他人删除。';
        Raise Err_Custom;
      End;
  End;
  If v_挂号单 Is Null Then
    If Not v_状态 In (1, 2, -1) Then
      v_Error := '医嘱"' || v_内容 || '"已经过校对，不能再删除。';
      Raise Err_Custom;
    End If;
  Else
    If v_状态 <> 1 Then
      v_Error := '医嘱"' || v_内容 || '"已经被发送或作废，不能删除。';
      Raise Err_Custom;
    End If;
  End If;

  --输血医嘱并发处理
  if v_诊疗类别 = 'K' and v_审核状态 in (2,5) then 
    --是否安装了血库系统
    Select count(1) into v_Count  From zlSystems Where 编号=2200;
    If Nvl(v_Count, 0) > 0 Then
      select 执行分类 into v_执行分类 from 诊疗项目目录 where  ID = v_诊疗项目ID;
      if not (nvl(v_执行分类,0) = 1) then
        --是否启用了血库管理系统
        Select Zl_Getsysparameter(236) into v_启用血库 From Dual;
        if Nvl(v_启用血库,'0') <> '0' then
          if v_审核状态 = 5 then
             v_Error := '正在配血，';
          else
             v_Error := '并且已完成配血，';
          end if;
          v_Error := '医嘱"' || v_内容 ||'"已被血库接收，' || v_Error || '不能删除，若需删除请与输血科联系。';
          Raise Err_Custom;
        end if;
      end if;
    end if;
  end if;

  Select Count(*)
  Into v_Count
  From 病人医嘱状态
  Where 医嘱id = 医嘱id_In And 操作类型 In (1, 11) And 签名id Is Not Null;
  If Nvl(v_Count, 0) > 0 Then
    v_Error := '医嘱"' || v_内容 || '"已经电子签名,不能删除。';
    Raise Err_Custom;
  End If;

  --处方审查撤销
  If v_相关id Is Null Then
    Zl_处方审查_Cancel(医嘱id_In, v_处方审查锁定ids);
  Else
    Zl_处方审查_Cancel(v_相关id, v_处方审查锁定ids);
  End If;

  If v_处方审查锁定ids Is Not Null Then
    v_Error := '医嘱"' || v_内容 || '"已锁定，正在进行处方审查，不能再删除。';
    Raise Err_Custom;
  End If;

  --判断删整组还是指定ID的医嘱
  If Nvl(删相关_In, 0) = 0 Then
    n_Del类型 := 0;
  Else
    If v_相关id Is Null Then
      --检查组合,手术及附加,中药配方,检验组合,以及独立医嘱
      Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      n_Del类型 := 1;
    Else
      --成药一并给药的情况(无申请)
      --先判断是否一并给药
      Select Count(*) Into n_Del_Count From 病人医嘱记录 Where 相关id = v_相关id;
      If n_Del_Count = 1 Then
        --单独给药:同时删除其给药途径
        Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
        n_Del类型 := 1;
      Else
        --一并给药:只删除当前药品
        n_Del_Count := 1;
        Select 序号 Into v_序号 From 病人医嘱记录 Where ID = 医嘱id_In;
        n_Del类型 := 0;
      End If;
    End If;
  End If;
  --
  Begin
    --如果不是路径的医嘱，则不查询路径执行表
    Select Count(1) Into v_Count From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In;

    If v_Count > 0 Then
      --外连接是因为路径外项目的项目id是空
      --游标循环处理：存在同一天，同一条医嘱对应多个路径项目的情况。
      --必须生成的项目需要填写变异原因，不删项目，只删医嘱；非必须生成的项目，直接删除医嘱和对应项目
      For Rs In (Select a.Id, d.执行方式, d.内容要求, a.路径记录id, a.变异原因, a.项目id
                 From 病人路径执行 A, 病人路径医嘱 B, 临床路径项目 D
                 Where b.病人医嘱id = 医嘱id_In And b.路径执行id = a.Id And a.项目id = d.Id(+)) Loop
        v_路径执行id   := Rs.Id;
        v_路径执行方式 := Rs.执行方式;
        v_内容要求     := Rs.内容要求;
        v_路径记录id   := Rs.路径记录id;
        v_变异原因     := Rs.变异原因;
        n_路径项目id   := Rs.项目id;

        Select Count(1)
        Into n_是否评估
        From 病人路径执行 A, 病人路径评估 B
        Where a.路径记录id = b.路径记录id And a.阶段id = b.阶段id And a.天数 = b.天数 And a.Id = v_路径执行id;

        If n_是否评估 > 0 Then
          v_Error := '该医嘱对应的临床路径项目已经评估，请取消评估再删除。';
          Raise Err_Custom;
        End If;
        --生成时填了变异原因的必须适用的项目允许删除
        If Not v_路径执行方式 Is Null And v_变异原因 Is Null Then
          If v_路径执行方式 <> 3 Then
            --如果必须生成的项目，选择生成的医嘱还剩最后一个，则不允许删除
            If v_内容要求 = 1 Then
              --路径内外的医嘱进行一并给药时，可以删除原有的给药途径
              If Nvl(删相关_In, 0) = 0 And v_相关id Is Null Then
                Select Count(*)
                Into v_Count
                From 病人路径医嘱 A
                Where a.路径执行id = v_路径执行id And a.病人医嘱id <> 医嘱id_In;
              Else
                Select Count(*)
                Into v_Count
                From 病人路径医嘱 A
                Where a.路径执行id = v_路径执行id And
                      a.病人医嘱id Not In
                      (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In Or ID = v_相关id);
              End If;
              If v_Count = 0 Then
                v_Error := '该医嘱对应的临床路径项目不是必要时生成的，不能删除。';
                Raise Err_Custom;
              End If;
            Else
              --执行方式：0-无须执行(也可用于实现标签)，1-每天执行，2-至少执行一次，3-必要时执行,4-必须执行一次（所在阶段必须且仅执行一次）


              If v_路径执行方式 = 2 Or v_路径执行方式 = 4 Then
                --程序界面已经处理（当阶段为多天的情况下,当前天数不是阶段最后一天时,执行方式为2或4时，是允许不添加变异原因就删除医嘱的）
        Null;
        Else
                v_Error := '该医嘱对应的临床路径项目是必须生成的，需要添加变异原因才能删除。';
                Raise Err_Custom;
              End If;
            End If;
          End If;
        End If;

        --判断是否是最后一条医嘱，分几种情况，一组医嘱，一条医嘱
        If n_Del类型 = 0 Then
          Select Count(1)
          Into n_Islast
          From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
          Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And b.Id = c.路径执行id And a.Id = v_路径记录id;
        Else
          --n_Del类型=1的都是删整组医嘱，有可能传入的是相关ID=null的也有可能是传入的相关ID<>null的
          If v_相关id Is Null Then
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C, 病人医嘱记录 D
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And a.Id = v_路径记录id And c.病人医嘱id = d.Id And
                  c.路径执行id = b.Id And (d.Id <> 医嘱id_In And d.相关id <> 医嘱id_In);
          Else
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And c.路径执行id = b.Id And a.Id = v_路径记录id And
                  (c.病人医嘱id <> 医嘱id_In And c.病人医嘱id <> v_相关id);
          End If;
        End If;

        If n_Islast = 1 Then
          --是最后一条项目的最后一条医嘱，就调用路径项目删除的过程
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Zl_病人路径生成_Delete(v_路径执行id,3);
          Else
            --必须生成但没有生成填写过变异原因的不删除项目
            Zl_病人路径生成_Delete(v_路径执行id, 2);
          End If;
        Else
          If n_Del类型 = 0 Then
            Delete From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In And 路径执行id = v_路径执行id;

            --如果当前药品删除后，该执行id下只剩给药途径，则要该执行ID更改为一并给药中其他药品的执行ID
            If v_相关id Is Not Null Then
              Select Nvl(Max(c.Id), 0)
              Into v_Other路径执行id
              From 病人路径医嘱 A, 病人医嘱记录 B, 病人路径执行 C
              Where c.Id = a.路径执行id And b.相关id = v_相关id And b.Id <> 医嘱id_In And a.病人医嘱id = b.Id And
                    a.路径执行id <> v_路径执行id And c.登记时间 = (Select Max(d.登记时间)
                                                       From 病人路径执行 D, 病人医嘱记录 E, 病人路径医嘱 F
                                                       Where e.Id = f.病人医嘱id And d.Id = f.路径执行id And e.相关id = v_相关id And
                                                             f.路径执行id <> v_路径执行id);

              If v_Other路径执行id <> 0 Then
                Select Count(1)
                Into v_Count
                From 病人路径执行 A, 病人路径执行 B
                Where a.Id = v_Other路径执行id And b.Id = v_路径执行id And a.阶段id = b.阶段id And a.天数 = b.天数;

                If v_Count > 0 Then
                  Update 病人路径医嘱
                  Set 路径执行id = v_Other路径执行id
                  Where 病人医嘱id = v_相关id And 路径执行id = v_路径执行id And Not Exists
                   (Select 1 From 病人路径医嘱 C Where 路径执行id = v_路径执行id And 病人医嘱id <> v_相关id);
                End If;
              End If;
            End If;
          Else
            If v_相关id Is Null Then
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And
                    病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
            Else
              --单独给药:同时删除其给药途径
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And 病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
            End If;
          End If;
          --该项目对应的医嘱删除完后，则删除路径项目，如果变异原因不为空且不是路径外项目则不删除项目，只删医嘱
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Delete From 病人路径执行
            Where ID = v_路径执行id And Not Exists (Select 1 From 病人路径医嘱 Where 路径执行id = v_路径执行id);
          End If;
        End If;
      End Loop;
    End If;
  End;

  --删除关联诊断后删除医嘱
  If n_Del类型 = 0 Then
    Delete From 病人诊断医嘱 Where 医嘱id = 医嘱id_In;
    Delete From 病人医嘱记录 Where ID = 医嘱id_In;
  Else
    If v_相关id Is Null Then
      Delete From 病人诊断医嘱
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      --单独给药:同时删除其给药途径
      Delete From 病人诊断医嘱 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
    End If;
  End If;

  If Nvl(删相关_In, 0) <> 0 Then
    --调整序号
    Update 病人医嘱记录
    Set 序号 = 序号 - n_Del_Count
    Where 病人id = v_病人id And Nvl(主页id, 0) = Nvl(v_主页id, 0) And Nvl(挂号单, '空') = Nvl(v_挂号单, '空') And
          Nvl(婴儿, 0) = Nvl(v_婴儿, 0) And 序号 > v_序号;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Delete;
/

--85987:梁唐彬,2016-11-22,修改医嘱清除处方审查数据

Create Or Replace Procedure Zl_病人医嘱记录_Update
(
  Id_In           病人医嘱记录.Id%Type,
  相关id_In       病人医嘱记录.相关id%Type,
  序号_In         病人医嘱记录.序号%Type,
  医嘱状态_In     病人医嘱记录.医嘱状态%Type,
  医嘱期效_In     病人医嘱记录.医嘱期效%Type,
  诊疗项目id_In   病人医嘱记录.诊疗项目id%Type,
  收费细目id_In   病人医嘱记录.收费细目id%Type,
  天数_In         病人医嘱记录.天数%Type,
  单次用量_In     病人医嘱记录.单次用量%Type,
  总给予量_In     病人医嘱记录.总给予量%Type,
  医嘱内容_In     病人医嘱记录.医嘱内容%Type,
  医生嘱托_In     病人医嘱记录.医生嘱托%Type,
  标本部位_In     病人医嘱记录.标本部位%Type,
  执行频次_In     病人医嘱记录.执行频次%Type,
  频率次数_In     病人医嘱记录.频率次数%Type,
  频率间隔_In     病人医嘱记录.频率间隔%Type,
  间隔单位_In     病人医嘱记录.间隔单位%Type,
  执行时间方案_In 病人医嘱记录.执行时间方案%Type,
  计价特性_In     病人医嘱记录.计价特性%Type,
  执行科室id_In   病人医嘱记录.执行科室id%Type,
  执行性质_In     病人医嘱记录.执行性质%Type,
  紧急标志_In     病人医嘱记录.紧急标志%Type,
  开始执行时间_In 病人医嘱记录.开始执行时间%Type,
  执行终止时间_In 病人医嘱记录.执行终止时间%Type,
  病人科室id_In   病人医嘱记录.病人科室id%Type,
  开嘱科室id_In   病人医嘱记录.开嘱科室id%Type,
  开嘱医生_In     病人医嘱记录.开嘱医生%Type,
  开嘱时间_In     病人医嘱记录.开嘱时间%Type,
  检查方法_In     病人医嘱记录.检查方法%Type := Null,
  执行标记_In     病人医嘱记录.执行标记%Type := Null,
  可否分零_In     病人医嘱记录.可否分零%Type := Null,
  摘要_In         病人医嘱记录.摘要%Type := Null,
  操员作姓名_In   病人医嘱状态.操作人员%Type := Null,
  零费记帐_In     病人医嘱记录.零费记帐%Type := Null,
  用药目的_In     病人医嘱记录.用药目的%Type := Null,
  用药理由_In     病人医嘱记录.用药理由%Type := Null,
  审核状态_In     病人医嘱记录.审核状态%Type := Null,
  超量说明_In     病人医嘱记录.超量说明%Type := Null,
  首次用量_In     病人医嘱记录.首次用量%Type := Null,
  手术情况_In     病人医嘱记录.手术情况%Type := Null,
  组合项目id_In   病人医嘱记录.组合项目id%Type := Null,
  皮试结果_In     病人医嘱记录.皮试结果%Type := Null
  --功能：被医生或护士修改了部分内容的医嘱记录。可用于门诊或住院。
  --说明：Update时之所以涉及诊疗项目ID,计价特性变化,是因为给药途径,用法的变化
  --      Update时之所以涉及期效变化,是因为自由录入医嘱可任意改变期效
) Is
  v_Count Number;

  v_Temp     Varchar2(255);
  v_人员姓名 病人医嘱状态.操作人员%Type;
  v_处方审查锁定IDs varChar2(4000);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查该医嘱状态:并发操作
  Begin
    Select 医嘱状态 Into v_Count From 病人医嘱记录 Where ID = Id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱"' || 医嘱内容_In || '"已经不存在,可能已被其他人删除。';
        Raise Err_Custom;
      End;
  End;
  If v_Count Not In (-1, 1, 2) Then
    v_Error := '医嘱"' || 医嘱内容_In || '"已经校对或发送,不能再修改。';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 1 And 签名id Is Not Null;
  If Nvl(v_Count, 0) > 0 Then
    v_Error := '医嘱"' || 医嘱内容_In || '"已经电子签名,不能再修改。';
    Raise Err_Custom;
  End If;

  --处方审查撤销
  If 相关id_In Is Null Then
     zl_处方审查_cancel(Id_In,v_处方审查锁定IDs);
  End If;

  If v_处方审查锁定IDs Is Not Null Then
  v_Error :=  '医嘱"' || 医嘱内容_In || '"已锁定，正在进行处方审查，不能再修改。';
    Raise Err_Custom;
  End If;

  --当前操作人员
  If 操员作姓名_In Is Not Null Then
    v_人员姓名 := 操员作姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --病人医嘱记录
  Update 病人医嘱记录
  Set 相关id = 相关id_In,
      --比如一并给药，重新设置检查部位等引起的相关ID变化
      序号 = 序号_In, 医嘱状态 = 医嘱状态_In,
      --!因为只能修改未校对医嘱，所以应该为新开，校对疑问的医嘱修改后为新开
      医嘱期效 = 医嘱期效_In, 诊疗项目id = 诊疗项目id_In, 收费细目id = 收费细目id_In, 天数 = 天数_In, 单次用量 = 单次用量_In, 总给予量 = 总给予量_In, 医嘱内容 = 医嘱内容_In,
      医生嘱托 = 医生嘱托_In, 标本部位 = 标本部位_In, 检查方法 = 检查方法_In, 执行标记 = 执行标记_In, 执行频次 = 执行频次_In, 频率次数 = 频率次数_In, 频率间隔 = 频率间隔_In,
      间隔单位 = 间隔单位_In, 执行时间方案 = 执行时间方案_In, 计价特性 = 计价特性_In, 执行科室id = 执行科室id_In, 执行性质 = 执行性质_In, 可否分零 = 可否分零_In,
      --药品根据外购药,出院带药的调整时会发生变化
      紧急标志 = 紧急标志_In, 开始执行时间 = 开始执行时间_In, 执行终止时间 = 执行终止时间_In,
      --!长嘱的终止时间可以修改,临嘱应该为空
      病人科室id = 病人科室id_In,
      --修改时更新为病人的当前科室
      开嘱科室id = 开嘱科室id_In,
      --修改后会根据当前科室变化
      开嘱医生 = 开嘱医生_In, 审核标记 = Decode(Nvl(Instr(开嘱医生_In, '/'), 0), 0, Decode(审核标记, 1, Null, 审核标记), 1),
      --护士开医嘱时可以更改
      开嘱时间 = 开嘱时间_In,
      --补录的可以修改
      摘要 = 摘要_In, 零费记帐 = 零费记帐_In, 手术时间 = Decode(诊疗类别, 'F', To_Date(标本部位_In, 'yyyy-mm-dd hh24:mi:ss'), Null),
      用药目的 = 用药目的_In, 用药理由 = 用药理由_In, 审核状态 = 审核状态_In, 超量说明 = 超量说明_In, 首次用量 = 首次用量_In, 手术情况 = 手术情况_In, 组合项目id = 组合项目id_In,
      皮试结果 = 皮试结果_In
  Where ID = Id_In;

  --病人医嘱状态:更新医生新开这条
  --因为可能同时：新开(修改)->自动校对(住院医生发送)->互斥自动停止(住院医生发送临嘱停止),因此分别-2,-1秒
  If 医嘱状态_In <> -1 Then
    Update 病人医嘱状态
    Set 操作人员 = v_人员姓名, 操作时间 = Sysdate - 2 / 60 / 60 / 24
    Where 医嘱id = Id_In And 操作类型 = 1; --新开这条始终有,校对疑问保留作为历史记录
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Update;
/

--0:梁唐彬,2016-11-10,过程内容兼容性调整不涉及问题修改
Create Or Replace Procedure Zl_门诊医嘱发送_Insert
(
  医嘱id_In     病人医嘱发送.医嘱id%Type,
  发送号_In     病人医嘱发送.发送号%Type,
  记录性质_In   病人医嘱发送.记录性质%Type,
  No_In         病人医嘱发送.No%Type,
  记录序号_In   病人医嘱发送.记录序号%Type,
  发送数次_In   病人医嘱发送.发送数次%Type,
  首次时间_In   病人医嘱发送.首次时间%Type,
  末次时间_In   病人医嘱发送.末次时间%Type,
  发送时间_In   病人医嘱发送.发送时间%Type,
  执行状态_In   病人医嘱发送.执行状态%Type,
  执行部门id_In 病人医嘱发送.执行部门id%Type,
  计费状态_In   病人医嘱发送.计费状态%Type,
  First_In      Number := 0,
  样本条码_In   病人医嘱发送.样本条码%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：填写病人医嘱发送记录 
  --参数：First_IN=表示是否一组医嘱的第一医嘱行,以便处理医嘱相关内容(如成药,配方的第一行,因为给药途径,配方煎法,用法可能为叮嘱不发送) 
) Is
  --包含病人及医嘱(一组医嘱中第一行)相关信息的游标 
  Cursor c_Advice Is
    Select Nvl(a.相关id, a.Id) As 组id, a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
           a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, Nvl(a.紧急标志, 0) As 紧急标志
    From 病人医嘱记录 A, 病人信息 B, 诊疗项目目录 C
    Where a.病人id = b.病人id And a.诊疗项目id = c.Id And a.Id = 医嘱id_In
    Group By Nvl(a.相关id, a.Id), a.序号, a.病人id, a.挂号单, a.婴儿, b.姓名, c.操作类型, a.诊疗类别, a.医嘱状态, a.医嘱内容, a.开嘱医生, a.开始执行时间,
             a.执行时间方案, a.频率次数, a.频率间隔, a.间隔单位, a.紧急标志;
  r_Advice c_Advice%RowType;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  --其它临时变量 
  v_Temp     Varchar2(255);
  v_Count    Number;
  v_病人性质 病案主页.病人性质%Type;
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_入院方式 入院方式.名称%Type;
  d_开始时间 病人医嘱记录.开始执行时间%Type;
  n_医嘱状态 病人医嘱记录.医嘱状态%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --如果首次时间为空则填入开始执行时间
  Select 开始执行时间,医嘱状态 Into d_开始时间,n_医嘱状态 From 病人医嘱记录 Where ID = 医嘱id_In;
  Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
  --是一组医嘱的第一行时处理医嘱内容 
  If Nvl(First_In, 0) = 1 or n_医嘱状态 = 1 Then
   
  
    --并发操作检查 
    --------------------------------------------------------------------------------------- 
    If Nvl(r_Advice.医嘱状态, 0) <> 1 Then
      v_Error := '"' || r_Advice.姓名 || '"的医嘱"' || r_Advice.医嘱内容 || '"已经被其他人发送。' || Chr(13) || Chr(10) ||
                 '该病人的医嘱发送失败。请重新读取发送清单再试。';
      Raise Err_Custom;
    End If;
  
    --发送后的医嘱处理:临嘱发送后自动停止 
    --------------------------------------------------------------------------------------- 
    Update 病人医嘱记录
    Set 医嘱状态 = 8, 执行终止时间 = 末次时间_In,
        --可能没有 
        停嘱时间 = 发送时间_In,
        --要作为发送时间显示 
        停嘱医生 = v_人员姓名 --要作为发送人显示,不同于住院,门诊医嘱无护士操作 
    Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    Insert Into 病人医嘱状态
      (医嘱id, 操作类型, 操作人员, 操作时间)
      Select ID, 8, v_人员姓名, 发送时间_In From 病人医嘱记录 Where ID = r_Advice.组id Or 相关id = r_Advice.组id;
  
    --特殊医嘱的处理 
    --------------------------------------------------------------------------------------- 
    If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --1-留观;2-住院; 
      If Instr(',1,2,', r_Advice.操作类型) > 0 And 执行部门id_In Is Not Null Then
        --满足产生新的预约登记的条件：1.当前无预约,2.当前不在院,3-无要求预约时间内的住院记录 
      
        --删除超过挂号有效天数的预约登记 
        Begin
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0;
        Exception
          When Others Then
            v_Count := 0;
        End;
        If Nvl(v_Count, 0) > 0 Then
          Zl_入院病案主页_Delete(r_Advice.病人id, 0, 0, 0);
          v_Count := 0;
        End If;
      
        If v_Count = 0 Then
          Select Count(*) Into v_Count From 病案主页 Where 病人id = r_Advice.病人id And 出院日期 Is Null;
        End If;
        If v_Count = 0 Then
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And (入院日期 >= r_Advice.开始执行时间 Or 出院日期 >= r_Advice.开始执行时间);
        End If;
        If v_Count = 0 Then
          If r_Advice.操作类型 = '1' Then
            --留观医嘱,将病人在"开始时间"留观到临床执行科室 
            Begin
              v_病人性质 := 2;
              Select Decode(服务对象, 1, 1, 2)
              Into v_病人性质
              From 部门性质说明
              Where 工作性质 = '临床' And 部门id = 执行部门id_In;
            Exception
              When Others Then
                Null;
            End;
          Elsif r_Advice.操作类型 = '2' Then
            --住院医嘱,将病人在"开始时间"登记到临床执行科室 
            v_病人性质 := 0;
          End If;
        
          Open c_Pati(r_Advice.病人id);
          Fetch c_Pati
            Into r_Pati;
        
          v_入院方式 := Null;
          If r_Advice.紧急标志 = 1 Then
            v_入院方式 := '急诊';
          Else
            Select Decode(急诊, 1, '急诊', Null)
            Into v_入院方式
            From 病人挂号记录
            Where NO = r_Advice.挂号单 And 记录性质 = 1 And 记录状态 = 1;
          End If;
        
          If v_病人性质 = 1 Then
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.门诊号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          Else
            Zl_入院病案主页_Insert(1, v_病人性质, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别,
                             r_Pati.出生日期, r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份,
                             r_Pati.身份证号, r_Pati.出生地点, r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址,
                             r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系, r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位,
                             r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行, r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额,
                             r_Pati.担保性质, 执行部门id_In, Null, Null, v_入院方式, Null, Null, r_Advice.开嘱医生, r_Pati.籍贯, r_Pati.区域,
                             r_Advice.开始执行时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null, Null, r_Pati.险类,
                             v_人员编号, v_人员姓名, 0, Null, Null, 0);
          End If;
          Close c_Pati;
        End If;
      End If;
    End If;
  
   
  End If;
  Close c_Advice;
  --填写发送记录 
  --------------------------------------------------------------------------------------- 
  Insert Into 病人医嘱发送
    (医嘱id, 发送号, 记录性质, NO, 记录序号, 发送数次, 发送人, 发送时间, 执行状态, 执行部门id, 计费状态, 首次时间, 末次时间, 样本条码, 门诊记帐)
  Values
    (医嘱id_In, 发送号_In, 记录性质_In, No_In, 记录序号_In, 发送数次_In, v_人员姓名, 发送时间_In, 执行状态_In, 执行部门id_In, 计费状态_In,
     Nvl(首次时间_In, d_开始时间), Nvl(末次时间_In, d_开始时间), 样本条码_In, Decode(记录性质_In, 2, 1, Null));

  --手术和检查医嘱同步更新主医嘱的计费状态   
  If 计费状态_In = 1 And  r_Advice.组ID <> 医嘱id_In  And (r_Advice.诊疗类别 = 'D' Or r_Advice.诊疗类别 = 'F') Then   
     Update 病人医嘱发送 Set 计费状态 = 1 Where 医嘱ID = r_Advice.组ID And 发送号 = 发送号_In;
  End If;
  
  --自动填为已执行时，需要同步处理费用执行状态及审核划价状态 
  If 执行状态_In = 1 Then
    Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, Null, v_人员编号, v_人员姓名, 执行部门id_In);
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 3, 发送号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱发送_Insert;
/

--101975:胡俊勇,2016-11-08,草药医嘱分配数量
Create Or Replace Function Zl_Dispensechspecs
(
  药名id_In   药品规格.药名id%Type,
  形态_In     药品规格.中药形态%Type, --0-散装，1-中药饮片，2-免煎剂
  数量_In     药品库存.可用数量%Type, --按剂量单位传入
  付数_In     药品库存.可用数量%Type,
  药房_In     药品库存.库房id%Type,
  分离发药_In Integer := 0, --分离分药模式,只能处理定价.不能处理实价药品
  场合_In     Number := 1, -- 1-门诊 ，2-住院
  药品ids_In  Varchar2 := Null --指定药品的分配
) Return Varchar2 As
  --返回:药品id,数量;药品id,数量;...(散装只选择一个规格)
  --                             不能完全分配时返回:剂量为6和10的情况下,17克的分配=23755,6;23756,10|1
  --                             不能分配时返回空,例如:剂量为6和10的情况下,3克的分配
  n_本次数量     药品库存.可用数量%Type;
  n_总数量       药品库存.可用数量%Type;
  n_包数         药品库存.可用数量%Type;
  n_总包数       药品库存.可用数量%Type;
  n_剩余数量     药品库存.可用数量%Type := 0;
  v_分配结果     Varchar2(1000);
  n_可用数量     药品库存.可用数量%Type;
  n_总数量tmp    药品库存.可用数量%Type;
  n_上次总数量   药品库存.可用数量%Type;
  n_本次数量tmp  药品库存.可用数量%Type;
  n_减少数量     药品库存.可用数量%Type;
  n_上次计量系数 药品库存.可用数量%Type;
  n_方式         药品出库检查.检查方式%Type;
  --Select Zl_Dispensechspecs(7366,2,28,1,76) as txt From dual
  --可能存在不同批次的,所以要汇总
  Cursor c_Medi(v_药品ids Varchar) Is
    Select a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, Sum(a.可用数量) * b.剂量系数 可用数量
    From 药品库存 A, 药品规格 B, 收费项目目录 C
    Where a.药品id = b.药品id And b.药名id = 药名id_In And a.药品id = c.Id And Decode(分离发药_In, 1, c.是否变价, 0) = 0 And 库房id = 药房_In And
          a.性质 = 1 And b.中药形态 = 形态_In And (Nvl(a.批次, 0) = 0 Or a.效期 Is Null Or a.效期 > Trunc(Sysdate)) And
          (b.药品id In (Select Column_Value From Table(f_Num2list(v_药品ids))) Or v_药品ids Is Null) And c.服务对象 In (场合_In, 3)
    Group By a.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零)
    Having Nvl(Sum(a.可用数量), 0) > 0
    Order By b.剂量系数 Desc, 可用数量;
  --不限定库存的时候
  Cursor c_Medi_Nostock Is
    Select b.药品id, b.剂量系数, Decode(场合_In, 2, b.住院可否分零, b.门诊可否分零) As 可否分零, 数量_In As 可用数量
    From 药品规格 B, 收费项目目录 C
    Where b.药名id = 药名id_In And b.药品id = c.Id And b.中药形态 = 形态_In And
          (b.药品id In (Select Column_Value From Table(f_Num2list(药品ids_In))) Or 药品ids_In Is Null) And c.服务对象 In (场合_In, 3)
    Order By b.剂量系数 Desc;

  Type t_Medi Is Table Of c_Medi%Rowtype;
  r_Medi t_Medi;
Begin
  Open c_Medi(Null);
  Fetch c_Medi Bulk Collect
    Into r_Medi;
  Close c_Medi;
  n_可用数量 := 0;
  For J In 1 .. r_Medi.Count Loop
    n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
  End Loop;

  If n_可用数量 < 数量_In Then
    Select Nvl(Max(检查方式), 0) Into n_方式 From 药品出库检查 Where 库房id = 药房_In;
    If n_方式 <> 2 Then
      Open c_Medi_Nostock;
      Fetch c_Medi_Nostock Bulk Collect
        Into r_Medi;
      Close c_Medi_Nostock;
      n_可用数量 := 0;
      For J In 1 .. r_Medi.Count Loop
        n_可用数量 := n_可用数量 + r_Medi(J).可用数量;
      End Loop;
    End If;
  Elsif 药品ids_In Is Not Null Then
    Open c_Medi(药品ids_In);
    Fetch c_Medi Bulk Collect
      Into r_Medi;
    Close c_Medi;
  End If;

  If Not r_Medi Is Null Then
    For J In 0 .. r_Medi.Count - 1 Loop
      --第二层循环是为了处理"大规格"优先时不能完成分配的情况,例如:剂量为6和10的情况下,12克的分配
      v_分配结果 := Null;
      n_总数量   := 数量_In;
      n_总包数   := 0;
      n_剩余数量 := 0;
      For I In 1 + J .. r_Medi.Count Loop
        --按剂量大小的倒序分配满足了"最少用包原则"
        --总数量(3)可能小于剂量系数(5),存在不能分零的情况
        --如果总数量刚好等于所有规格的库存之和,但大于任何一种规格的库存,这种特殊情况因处理复杂,实用价值不高,不处理(返回空)
        n_本次数量 := 0;
        n_包数     := 0;
        If n_总数量 <= r_Medi(I).可用数量 Then
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If r_Medi(I).可否分零 = 1 Then
              --不分零
              n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
              n_本次数量 := n_包数 * r_Medi(I).剂量系数;
            Else
              n_包数     := n_总数量 / r_Medi(I).剂量系数;
              n_本次数量 := n_总数量;
            End If;
          End If;
        
          --这里处理连续的两种规格分配时，大包用后，小包不能用的情况。比如：规格为小包为6g/包，大包为10g/包，现在总量是22g，如果是原来的方式，则是大包2包，余2g 分不尽，
          --                                                   现修改为在大包分了两包后，小包分不尽的时候，则将已分的大包循环减一个计量系数，这里大包的计量系数为10g，
          --                                                  已分了20g，现在减10g，就余下12g，然后小包就可以分尽了。最后结果就为大包 1包10g，小包2包12g。
          --如果中间隔了一个规格，本分支不能解决。比如：三个规格，前两种分不尽，后两种也分不尽，只有第一种和第三种才分的尽的，这种情况应该不多。
          If ((n_总数量 < r_Medi(I).剂量系数 And n_总数量 > 0) Or n_总数量 - n_本次数量 <> 0) And I <> 1 + J And v_分配结果 Is Not Null Then
            n_减少数量 := 0;
            --每次减上次的总量，都将减的数量累加起来。
            n_总数量tmp := n_总数量 + n_上次计量系数;
            n_减少数量  := n_减少数量 + n_上次计量系数;
            Loop
              --循环减，直到将上次分配的减完。
              Exit When n_总数量tmp >= n_上次总数量;
              If r_Medi(I).可否分零 = 1 Then
                --不分零的才会出现这种
                n_本次数量tmp := Floor(n_总数量tmp / r_Medi(I).剂量系数) * r_Medi(I).剂量系数;
              End If;
              --如果能够分尽，则更新本次的数量，并将上次的数量重新修改。
              If n_总数量tmp = n_本次数量tmp Then
                n_包数     := Floor(n_总数量tmp / r_Medi(I).剂量系数);
                n_本次数量 := n_本次数量tmp;
                If n_上次总数量 - n_总数量 - n_减少数量 = 0 Then
                  --如果上次分配的被减完了，则删除上次分配的结果。
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ';', -1) - 1);
                Else
                  v_分配结果 := Substr(v_分配结果, 1, Instr(v_分配结果, ',', -1)) || (n_上次总数量 - n_总数量 - n_减少数量);
                End If;
                --这里由于上次的数量发生了变化，所以总数量也要修改。
                n_总数量 := n_总数量 + n_减少数量;
                Exit;
              End If;
              n_总数量tmp := n_总数量tmp + n_上次计量系数;
              n_减少数量  := n_减少数量 + n_上次计量系数;
            End Loop;
          End If;
        
          If n_总数量 >= r_Medi(I).剂量系数 Then
            If 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
              If v_分配结果 Is Null Then
                v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
              Else
                v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
              End If;
            
              n_上次总数量   := n_总数量;
              n_总包数       := n_总包数 + n_包数;
              n_总数量       := n_总数量 - n_本次数量;
              n_上次计量系数 := r_Medi(I).剂量系数;
              If 形态_In = 0 Then
                Exit; --散装只能使用一种规格
              End If;
            End If;
          End If;
        Elsif n_总数量 >= r_Medi(I).剂量系数 And n_总数量 > r_Medi(I).可用数量 And n_总数量 <= n_可用数量 Then
          --处理了单个规格库存不足，但是所有规格的总数量够用的情况。（这里处理为如果某一个规格数量不足，就能用多少用多少）
          If r_Medi(I).可否分零 = 1 Then
            --不分零
            n_包数     := Floor(r_Medi(I).可用数量 / r_Medi(I).剂量系数);
            n_本次数量 := n_包数 * r_Medi(I).剂量系数;
          Else
            n_包数     := r_Medi(I).可用数量 / r_Medi(I).剂量系数;
            n_本次数量 := r_Medi(I).可用数量;
          End If;
        
          If 付数_In * n_本次数量 <= n_可用数量 Then
            If v_分配结果 Is Null Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            Else
              v_分配结果 := v_分配结果 || ';' || r_Medi(I).药品id || ',' || n_本次数量;
            End If;
            n_上次总数量   := n_总数量;
            n_总包数       := n_总包数 + n_包数;
            n_总数量       := n_总数量 - n_本次数量;
            n_可用数量     := n_可用数量 - n_本次数量;
            n_上次计量系数 := r_Medi(I).剂量系数;
            If 形态_In = 0 Then
              Exit; --散装只能使用一种规格
            End If;
          End If;
        End If;
      End Loop;
      If n_总数量 = 0 Then
        n_剩余数量 := 0;
        Exit;
      Elsif n_剩余数量 = 0 And v_分配结果 Is Not Null Then
        n_剩余数量 := n_总数量;
      End If;
    End Loop;
  End If;

  If n_总数量 = 0 Or n_剩余数量 <> 0 Then
    --检查是否适用"倍量优先原则"
    If n_剩余数量 <> 0 Then
      n_总数量 := 数量_In - n_剩余数量;
    Else
      n_总数量 := 数量_In;
    End If;
    For I In 1 .. r_Medi.Count Loop
      If n_总数量 >= r_Medi(I).剂量系数 And n_总数量 <= r_Medi(I).可用数量 Then
        n_包数     := Floor(n_总数量 / r_Medi(I).剂量系数);
        n_本次数量 := n_包数 * r_Medi(I).剂量系数;
        If n_总数量 = n_本次数量 And 付数_In * n_本次数量 <= r_Medi(I).可用数量 Then
          If n_包数 <= n_总包数 Then
            If n_剩余数量 <> 0 Then
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量 || '|' || n_剩余数量;
            Else
              v_分配结果 := r_Medi(I).药品id || ',' || n_本次数量;
            End If;
          End If;
          Exit;
        End If;
      End If;
    End Loop;
  
    Return v_分配结果;
  Else
    Return Null;
  End If;
End Zl_Dispensechspecs;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表
(
  病人id_In In 病人医嘱记录.病人id%Type,
  主页id_In In 病人医嘱记录.主页id%Type
) Return Varchar2 Is
  Pragma Autonomous_Transaction;
  
  TYPE C_REPORT_LIST IS REF CURSOR;
  C_REPORT_ITEM C_REPORT_LIST;

  v_Return Varchar2(4000);  
  v_Sql    Varchar2(4000);
  v_Temp   Varchar2(2000);
  n_Count  Number;
  
  n_ITEM_Id       Varchar2(64);
  n_ITEM_YZID     Number(18);
  v_ITEM_GP       Varchar2(64);
  v_ITEM_MC       Varchar2(1024);
  n_ITEM_BGLX     Number(18);
  v_ITEM_BGR      Varchar2(64);
  v_ITEM_BGSJ     Varchar2(64);  

Begin
  
    Select Count(*) Into n_Count From user_tables Where table_name =Upper('zlTempReportList');
    
    if n_Count > 0 then
      v_sql := 'Truncate Table zlTempReportList';
      Execute Immediate v_sql;
      Commit;
    Else
      v_sql := 'Create Global Temporary Table zlTempReportList(
               ID Varchar2(64),   
               YZID Number(18),             
               GP Number(1),
               MC Varchar2(1024),
               BGLX Number(1),
               BGR Varchar2(64),
               BGSJ Date
              ) On Commit Preserve Rows'; 
                    
      Execute Immediate v_sql;
    End if;

    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                           Select b.病历id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                           From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                           Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And A.相关id Is Null And B.RISID Is Null And
                           c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                           a.病人id = :1 And nvl(a.主页id,0) = :2';  
    Begin                   
        Execute Immediate v_Sql Using 病人id_In,主页id_In;
    Exception
      When Others Then
        Begin
          v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                                 Select b.病历id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                                 From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                                 Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                                 c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                                 a.病人id = :1 And nvl(a.主页id,0) = :2';  
          Execute Immediate v_Sql Using 病人id_In,主页id_In;
        Exception
          When Others Then Null;
        end; 
    End;
    
    
    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ) 
                          Select b.检查报告id || '''' As ID, a.Id As YZID, Decode(d.检查uid, Null, 0, 1) As GP, a.医嘱内容 As MC, 1 as BGLX, c.最后编辑人 As BGR, c.最后审核时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D, 病人医嘱发送 E
                          where a.Id = b.医嘱id And b.检查报告id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                          c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                          a.病人id = :1 And nvl(a.主页id,0) = :2';
    Begin
        Execute Immediate v_Sql Using 病人id_In,主页id_In;
    Exception
      When Others Then Null;
    End;
     
    
    v_Sql := 'Insert Into zlTempReportList(Id, YZID, GP, MC, BGLX, BGR, BGSJ)
                          Select b.RISID || '''' As ID, a.Id As YZID, 2 As GP, a.医嘱内容 As MC, 2 as BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                          Where a.Id = b.医嘱id And b.病历ID = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Not Null And
                          c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态=1 And
                          a.病人id = :1 And nvl(a.主页id,0) = :2';     
    Begin
        Execute Immediate v_Sql Using 病人id_In,主页id_In; 
    Exception
      When Others Then Null;
    End;
    
    Commit;
    
    v_Sql := 'Select Id, YZID, GP, MC, BGLX, BGR, To_Char(BGSJ,''yyyy-mm-dd hh24:mi:ss'') As BGSJ  From zlTempReportList Order by BGSJ';

    Open C_REPORT_ITEM For v_Sql;
    Loop
      Fetch C_REPORT_ITEM INTO n_ITEM_ID, n_ITEM_YZID, v_ITEM_GP, v_ITEM_MC, n_ITEM_BGLX, v_ITEM_BGR, v_ITEM_BGSJ;
      Exit When C_REPORT_ITEM%NotFound;
      
      v_Temp := '<FILE>' || 
                      '<ID>' || n_ITEM_ID || '</ID>' || 
                      '<YZID>' || n_ITEM_YZID || '</YZID>' ||
                      '<GP>' || v_ITEM_GP || '</GP>' || 
                      '<MC>' || v_ITEM_MC || '</MC>' || 
                      '<BGLX>' || n_ITEM_BGLX || '</BGLX>' || 
                      '<BGR>' || v_ITEM_BGR || '</BGR>' ||
                      '<BGSJ>' || v_ITEM_BGSJ || '</BGSJ>' || 
             '</FILE>';

      v_Return := v_Return || v_Temp;
    End Loop;
    Close C_REPORT_ITEM;

    If v_Return <> ' ' Then
      v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
    End If;

    Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表;
/

--102414:涂建华,2016-12-09,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告列表Ex
(
  医嘱ID_In In 病人医嘱记录.id%Type
) Return Varchar2 Is
  Pragma Autonomous_Transaction;
  
  TYPE C_REPORT_LIST IS REF CURSOR;
  C_REPORT_ITEM C_REPORT_LIST;

  v_Return Varchar2(4000);  
  v_Sql    Varchar2(4000);
  v_Temp   Varchar2(2000);
  n_Count  Number;
  
  n_ITEM_Id       Varchar2(64);
  n_ITEM_YZID     Number(18);
  v_ITEM_YZNR     Varchar2(1024);
  v_ITEM_MC       Varchar2(60);
  n_ITEM_BGLX     Number(18);
  v_ITEM_BGR      Varchar2(64);
  v_ITEM_BGSJ     Varchar2(64);  

Begin
  
    Select Count(*) Into n_Count From user_tables Where table_name =Upper('zlTempReportListEx');
    
    if n_Count > 0 then
      v_sql := 'Truncate Table zlTempReportListEx';
      Execute Immediate v_sql;
      Commit;
    Else
      v_sql := 'Create Global Temporary Table zlTempReportListEx(
               ID Varchar2(64),   
               YZID Number(18),             
               YZNR Varchar2(1024),
               MC Varchar2(60),
               BGLX Number(1),
               BGR Varchar2(64),
               BGSJ Date
              ) On Commit Preserve Rows'; 
                    
      Execute Immediate v_sql;
    End if;

    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                           Select b.病历id || '''' As ID, a.Id As YZID, a.医嘱内容 As YXNR, c.病历名称 as MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                           From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                           Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Null And
                           c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                           a.ID = :1';  
    Begin                   
        Execute Immediate v_Sql Using 医嘱ID_In;
    Exception
      When Others Then
        Begin
          v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                                 Select b.病历id || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.病历名称 As MC, 0 As BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                                 From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                                 Where a.Id = b.医嘱id And b.病历id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                                 c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                                 a.id = :1';  
          Execute Immediate v_Sql Using 医嘱ID_In;
        Exception
          When Others Then Null;
        end; 
    End;
    
    
    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ) 
                          Select b.检查报告id || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.文档标题 As MC, 1 as BGLX, c.最后编辑人 As BGR, c.最后审核时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 影像报告记录 C, 影像检查记录 D, 病人医嘱发送 E
                          where a.Id = b.医嘱id And b.检查报告id = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And
                          c.最后审核时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                          a.id = :1';
    Begin
        Execute Immediate v_Sql Using 医嘱ID_In;
    Exception
      When Others Then Null;
    End;
     
    
    v_Sql := 'Insert Into zlTempReportListEx(Id, YZID, YZNR, MC, BGLX, BGR, BGSJ)
                          Select b.RISID || '''' As ID, a.Id As YZID, a.医嘱内容 As YZNR, c.病历名称 As MC, 2 as BGLX, c.保存人 As BGR, c.完成时间 As BGSJ
                          From 病人医嘱记录 A, 病人医嘱报告 B, 电子病历记录 C, 影像检查记录 D, 病人医嘱发送 E
                          Where a.Id = b.医嘱id And b.病历ID = c.Id And A.Id=E.医嘱ID And a.诊疗类别 = ''D'' And 相关id Is Null And B.RISID Is Not Null And
                          c.完成时间 Is Not Null And a.Id = d.医嘱id(+) And a.医嘱期效 = 1 And a.医嘱状态 In (3, 5, 6, 7, 8) And E.执行状态 = 1 And
                          a.id = :1';     
    Begin
        Execute Immediate v_Sql Using 医嘱ID_In; 
    Exception
      When Others Then Null;
    End;
    
    Commit;
    
    v_Sql := 'Select Id, YZID, YZNR, MC, BGLX, BGR, To_Char(BGSJ,''yyyy-mm-dd hh24:mi:ss'') As BGSJ  From zlTempReportListEx Order by BGSJ';

    Open C_REPORT_ITEM For v_Sql;
    Loop
      Fetch C_REPORT_ITEM INTO n_ITEM_ID, n_ITEM_YZID, v_ITEM_YZNR, v_ITEM_MC, n_ITEM_BGLX, v_ITEM_BGR, v_ITEM_BGSJ;
      Exit When C_REPORT_ITEM%NotFound;
      
      v_Temp := '<FILE>' || 
                      '<ID>' || n_ITEM_ID || '</ID>' || 
                      '<YZID>' || n_ITEM_YZID || '</YZID>' ||
                      '<YZNR>' || v_ITEM_YZNR || '</YZNR>' || 
                      '<MC>' || v_ITEM_MC || '</MC>' || 
                      '<BGLX>' || n_ITEM_BGLX || '</BGLX>' || 
                      '<BGR>' || v_ITEM_BGR || '</BGR>' ||
                      '<BGSJ>' || v_ITEM_BGSJ || '</BGSJ>' || 
             '</FILE>';

      v_Return := v_Return || v_Temp;
    End Loop;
    Close C_REPORT_ITEM;

    If v_Return <> ' ' Then
      v_Return := '<FILELIST>' || v_Return || '</FILELIST>';
    End If;

    Return v_Return;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告列表Ex;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档提纲
(
  报告id_In In 病人医嘱报告.检查报告ID%Type
) Return Varchar2 Is
  v_报告提纲 Varchar2(1000);
  v_提纲内容 Varchar2(100);

  x_Content xmltype;
  n_NodeNum number(2);
  Xcdom            Xmldom.Domdocument;
  Section_List     Xmldom.Domnodelist;
Begin
    v_报告提纲 := '';

    Select b.报告内容 Into x_Content From 病人医嘱报告 a, 影像报告记录 b Where a.检查报告id=b.id And  a.检查报告id = 报告id_In;

    Xcdom         := Xmldom.Newdomdocument(x_Content);
    Section_List  := Xmldom.Getelementsbytagname(Xcdom, 'section');
    n_NodeNum     := Xmldom.Getlength(Section_List);

    For i in 0..n_NodeNum-1 Loop
      v_提纲内容 := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, i)), 'title');

      If Nvl(v_提纲内容,' ') != ' ' Then
        v_报告提纲 := v_报告提纲 || '<split>' || v_提纲内容;
      End If;
    End Loop;
    
    Return(Substr(v_报告提纲, 8));
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取文档提纲;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历提纲
(
  报告id_In In 病人医嘱报告.病历id%Type
) Return Varchar2 Is
  v_报告提纲 Varchar2(1000);

  Cursor c_报告提纲 Is
    Select Distinct a.内容文本
    From 电子病历内容 A, 电子病历内容 B, 病人医嘱报告 C
    Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = c.病历id And c.病历id = 报告id_In;
Begin
  For Row_Cols In c_报告提纲 Loop
    v_报告提纲 := '<split>' || Row_Cols.内容文本 || v_报告提纲;
  End Loop;

  Return(Substr(v_报告提纲, 8));

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取病历提纲;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告提纲
(
  报告id_In In Varchar2,
  报告来源_In In Number
) Return Varchar2 Is
  v_报告提纲 Varchar2(2000);
  n_病历ID Number(18);
  
  v_Sql Varchar2(100);
Begin
  If 报告来源_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档提纲(:1)  From Dual';  
    Begin                   
        Execute Immediate v_Sql Into v_报告提纲 Using 报告id_In ;
    Exception
      When Others Then v_报告提纲 := '';          
    End;
  Else
    n_病历ID := To_Number(报告id_In);
      
    If 报告来源_In = 2 Then
      v_Sql := 'Select 病历ID From 病人医嘱报告 Where RISID=:1';
      Execute Immediate v_Sql Into n_病历ID Using 报告id_In ;
    End If;
      
    v_Sql := 'Select Zlpub_Pacs_获取病历提纲(:1)  From Dual';  
    Begin                   
        Execute Immediate v_Sql Into v_报告提纲 Using n_病历ID ;
    Exception
      When Others Then v_报告提纲 := '';          
    End;
  End If;

  Return v_报告提纲;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取报告提纲;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档文本
(
  Ids_In   In Varchar2
)Return XmlType Is
  Docxml XmlType;
  
  File_Id Varchar2(32);
  n_Adviceid Number(18);
  
  x_Content    Xmltype;
  Section_Node Xmldom.Domnode;
  Element_Node Xmldom.Domnode;
  Xcdom        Xmldom.Domdocument;
  Node_List    Xmldom.Domnodelist;
  Section_List Xmldom.Domnodelist;
  
  n_Count Number(1);
  --标记变量
  
  n_Len     Number(3);
  n_Width   Number(4);
  n_Height  Number(4);
  v_Id      Varchar2(100);
  v_Title   Varchar2(100);
  v_Newline Varchar2(2);
  v_Text    Varchar2(4000);
  v_Name    Varchar2(100);
  v_Type    Varchar2(20);
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';
  
  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    
    If File_Id Is Null Then
      Exit;
    End If;      
    
    --开始某个文件读取
    Begin
      Select a.医嘱id,
             Appendchildxml(Docxml, '/ZlEPR',
                             Xmlelement("Document",
                                         Xmlattributes(b.姓名 As "姓名", b.病人id As "病人ID", b.主页id As "主页ID", a.文档标题 As "文件名",
                                                        Rawtohex(a.Id) As "文件ID")))
      Into n_Adviceid, Docxml
      From 影像报告记录 A, 病人医嘱记录 B
      Where a.Id = Hextoraw(File_Id) And a.医嘱id = b.Id;
    Exception
      --给定的文件ID无效
      When Others Then
        Return Null;
    End;
    
    Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                           Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
    Into Docxml
    From Dual;
      
    --开始读取内容
    Select b.报告内容 Into x_Content From 影像报告记录 B Where b.Id || '' = File_Id;
      
    Xcdom := Xmldom.Newdomdocument(x_Content);
      
    Section_List := Xmldom.Getelementsbytagname(Xcdom, 'zlxml');
    Section_Node := Xmldom.Item(Section_List, 0);
    Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*');
    n_Len        := Xmldom.Getlength(Node_List);
      
    For I In 0 .. n_Len - 1 Loop
      Element_Node := Xmldom.Item(Node_List, I);
        
      v_Name    := Xmldom.Getnodename(Element_Node);
      v_Newline := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'br');
        
      If v_Newline Is Null Then
        v_Newline := '1';
      End If;
        
      If v_Name = 'section' Then
        --提纲
        v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
        v_Id    := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid');
          
        Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]',
                               Xmlelement("Compend", Xmlattributes(v_Title As "Name", v_Id As "ID")))
        Into Docxml
        From Dual;
      Elsif v_Name = 'utext' Then
        --文本
        v_Text := LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Text", Xmlattributes(v_Newline As "NewLine"), v_Text))
          Into Docxml
          From Dual;
        End If;
      Elsif v_Name = 'element' Then
        --要素
        v_Title := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'title');
        v_Text  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'value') ||
                   Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                             v_Text))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Element", Xmlattributes(v_Title As "Name", v_Newline As "NewLine"),
                                             v_Text))
          Into Docxml
          From Dual;
        End If;
      Elsif v_Name = 'image' Then
        --图片
        n_Width  := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'width');
        n_Height := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'height');
        v_Name   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'key');
        v_Type   := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'class');
          
        If Nvl(v_Name, ' ') <> ' ' Then
          If Nvl(v_Id, ' ') = ' ' Then
            Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                   Xmlelement("Picture",
                                               Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                              n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                              v_Name As "PicName", n_Adviceid As "AdviceID",
                                                              v_Type As "Type")))
            Into Docxml
            From Dual;
          Else
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                   Xmlelement("Picture",
                                               Xmlattributes(n_Width As "OrigWidth", n_Height As "OrigHeight",
                                                              n_Width As "ShowWidth", n_Height As "ShowHeight",
                                                              v_Name As "PicName", n_Adviceid As "AdviceID",
                                                              v_Type As "Type")))
            Into Docxml
            From Dual;
          End If;
        End If;
          
      Elsif v_Name = 'signature' Then
        --签名
        v_Text := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'displayinfo');
          
        If Nvl(v_Id, ' ') = ' ' Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                                 Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID="' || File_Id || '"]/descendant::Compend[@ID="' || v_Id || '"]',
                                 Xmlelement("Sign", Xmlattributes(v_Newline As "NewLine"), Zl_Eprsplit(v_Text, ';', 1)))
          Into Docxml
          From Dual;
        End If;
      End If;
    End Loop;
      
    For Aa In (Select '/' || a.Ftp目录 || '/ReportImages/' || To_Char(b.创建时间, 'YYYYMMDD') || '/' || b.Id || '/' As v_Ftppath
               From 影像设备目录 A, 影像报告记录 B
               Where a.设备号 = b.设备号 And b.Id = File_Id) Loop
        
      Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                             Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
      Into Docxml
      From Dual;
    End Loop;
  End Loop;
  
  Return Docxml;
End Zlpub_Pacs_获取文档文本;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历文本
(
  Ids_In   In Varchar2,
  From_In Number
)Return XmlType Is
  Docxml XmlType;
  
  File_Id Varchar2(32);
  n_Adviceid Number(18);
  
  v_Sql        Varchar2(1000);
  
  --标记变量
  v_Mark     Varchar2(500);
  v_Marks    Varchar2(2500);
  Makxml     Xmltype;
  Maksxml    Xmltype;
  v_Ftppath  Varchar2(200);
  
  v_Newline Varchar2(2);
Begin
  Select Xmltype('<?xml version="1.0" encoding="' || Value || '"?><ZlEPR></ZlEPR>')
  Into Docxml
  From Nls_Database_Parameters
  Where Parameter = 'NLS_CHARACTERSET';
  
  For J In 1 .. 1000 Loop
    File_Id := 0;
    Select Zl_Eprsplit(Ids_In, '|', J) Into File_Id From Dual;
    
    If File_Id Is Null Then
      Exit;
    End If;  
    
    If From_In = 2 Then
       --RIS报告
       v_Sql := 'Select 病历Id From 病人医嘱报告 Where RISID = :1';
       Execute Immediate v_Sql Into File_Id Using File_Id;
    End If;
        
    --开始某个病历文件读取
    Begin
      Select Appendchildxml(Docxml, '/ZlEPR',
                             Xmlelement("Document",
                                         Xmlattributes(b.姓名 As "姓名", a.病人id As "病人ID", a.主页id As "主页ID", a.病历名称 As "文件名",
                                                        a.Id As "文件ID")))
      Into Docxml
      From 电子病历记录 A, 病人信息 B
      Where a.Id = File_Id And a.编辑方式 = 0 And a.病人id = b.病人id;
          
      Select 医嘱id Into n_Adviceid From 病人医嘱报告 Where 病历id = File_Id;
    Exception
      --给定的病历文件ID无效
      When Others Then Return Null;
    End;
        
    Select Insertchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]', 'Compend',
                           Xmlelement("Compend", Xmlattributes('0' As "ID", '内容' As "Name")))
    Into Docxml
    From Dual;
      
    Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                           Xmlelement("Text", Xmlattributes(Nvl(Null, 0) As "NewLine"), '内容文本'))
    Into Docxml
    From Dual;
      
    For Rs In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
               From (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                      From 电子病历内容
                      Where 文件id = File_Id And 对象序号 > 0 And 对象序号 <> ID And 终止版 = 0)
               Start With 父id Is Null
               Connect By Prior ID = 父id
               Order Siblings By 对象序号, 内容行次) Loop
      If Rs.对象类型 = 1 Then
        --提纲
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']',
                                 Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Compend", Xmlattributes(Rs.内容文本 As "Name", Rs.Id As "ID")))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 2 Then
        --文本
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Text", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 3 Then
        --表格
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Table",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Table",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 1) As "Rows",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 2) As "Cols",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 3) As "Width",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 4) As "Height",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 5) As "ColWidthString",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
          
        ---对表格的单元格进行填充
        For Rs_Cell In (Select ID, 父id, 对象序号, 对象类型, 对象属性, 内容行次, 内容文本, 是否换行, 要素名称
                        From 电子病历内容
                        Where 文件id = File_Id And 父id = Rs.Id And 终止版 = 0
                        Order By 内容行次, ID) Loop
          If Rs_Cell.对象类型 = 2 Or Rs_Cell.对象类型 = 4 Then
            If Zl_Eprsplit(Rs_Cell.对象属性, '|', 26) Is Null Then
              --兼容历史病历
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                     Xmlelement("Cell",
                                                 Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) As "Row",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Col",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 2) || '_' ||
                                                                 Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row_Col",
                                                                Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "Width",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 6) As "Height",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "MergeNo",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                 Rs_Cell.内容文本))
              Into Docxml
              From Dual;
            Else
              Select Appendchildxml(Docxml,
                                     '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                     Xmlelement("Cell",
                                                 Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) As "Row",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Col",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 3) || '_' ||
                                                                 Zl_Eprsplit(Rs_Cell.对象属性, '|', 4) As "Row_Col",
                                                                Decode(Rs_Cell.对象类型, 2, 0, 4, 1) As "Type",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '', 6) As "Width",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 7) As "Height",
                                                                Zl_Eprsplit(Rs_Cell.对象属性, '|', 5) As "MergeNo",
                                                                Nvl(Rs.是否换行, 0) As "NewLine", Rs_Cell.Id As "ID"),
                                                 Rs_Cell.内容文本))
              Into Docxml
              From Dual;
            End If;
          Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) = 2 Then
            --单元格图由Webservice直接读取BLOB之后直接写文件以提高速度
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id || ']',
                                   Xmlelement("Picture",
                                               Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                              Rs_Cell.Id As "ID"), Rs_Cell.Id))
            Into Docxml
            From Dual;
              
            If Nvl(n_Adviceid, 0) = 0 Then
              n_Adviceid := Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0');
            End If;
          Elsif Rs_Cell.对象类型 = 5 And Zl_Eprsplit(Rs_Cell.对象属性, ';', 1) <> 2 Then
            --单元格图由Webservice直接读取BLOB之后直接写文件以提高速度
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Table[@ID=' || Rs.Id ||
                                    ']/Cell[@Row_Col="' || Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) || '_' ||
                                    Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) || '"]',
                                   Xmlelement("Picture",
                                               Xmlattributes(Zl_Eprsplit(Rs_Cell.对象属性, ';', 2) As "Row",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 3) As "Col",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 8) As "OrigWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 9) As "OrigHeight",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 6) As "ShowWidth",
                                                              Zl_Eprsplit(Rs_Cell.对象属性, ';', 7) As "ShowHeight",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 12), ' ') As "PicName",
                                                              Nvl(Zl_Eprsplit(Rs_Cell.对象属性, ';', 13), '0') As "AdviceID",
                                                              Rs_Cell.Id As "ID"), Rs_Cell.Id))
            Into Docxml
            From Dual;
            --制作标记子节点集
            v_Mark  := '';
            Makxml  := Null;
            Maksxml := Null;
            For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次
                            From 电子病历内容
                            Where 父id = Rs_Cell.Id
                            Order By 内容行次) Loop
              v_Marks := v_Mark || Rs_Mark.内容文本;
              v_Marks := Replace(v_Marks, '||', '^');
              For I In 1 .. 100 Loop
                v_Mark := Zl_Eprsplit(v_Marks, '^', I);
                If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
                  --最后一个标记信息不全，存在下一行中
                  Exit;
                Else
                  Select Xmlelement("Mark",
                                     Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型",
                                                Zl_Eprsplit(v_Mark, '|', 3) As "内容", Zl_Eprsplit(v_Mark, '|', 4) As "点集",
                                                Zl_Eprsplit(v_Mark, '|', 5) As "X1", Zl_Eprsplit(v_Mark, '|', 6) As "Y1",
                                                Zl_Eprsplit(v_Mark, '|', 7) As "X2", Zl_Eprsplit(v_Mark, '|', 8) As "Y2",
                                                Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                                Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                                Zl_Eprsplit(v_Mark, '|', 11) As "线条色",
                                                Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                                Zl_Eprsplit(v_Mark, '|', 13) As "线型",
                                                Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                                Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
                  Into Makxml
                  From Dual;
                  Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
                End If;
              End Loop;
            End Loop;
            --向Picture插入标记子节点
            Select Appendchildxml(Docxml,
                                   '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs_Cell.Id || ']',
                                   Maksxml)
            Into Docxml
            From Dual;
          End If;
        End Loop;
      Elsif Rs.对象类型 = 4 Then
        --要素
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Element", Xmlattributes(Rs.要素名称 As "Name", Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 5 And Nvl(Rs.内容行次, 0) = 0 Then
        --图片由Webservice直接读取BLOB之后直接写文件以提高速度
 
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Picture",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Picture",
                                             Xmlattributes(Zl_Eprsplit(Rs.对象属性, ';', 8) As "OrigWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 9) As "OrigHeight",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 6) As "ShowWidth",
                                                            Zl_Eprsplit(Rs.对象属性, ';', 7) As "ShowHeight",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 12), ' ') As "PicName",
                                                            Nvl(Zl_Eprsplit(Rs.对象属性, ';', 13), '0') As "AdviceID",
                                                            Nvl(Rs.是否换行, 0) As "NewLine", Rs.Id As "ID"), Rs.Id))
          Into Docxml
          From Dual;
        End If;
        --制作标记子节点集
        v_Mark  := '';
        Makxml  := Null;
        Maksxml := Null;
        For Rs_Mark In (Select ID, 父id, 内容文本, 内容行次 From 电子病历内容 Where 父id = Rs.Id Order By 内容行次) Loop
          v_Marks := v_Mark || Rs_Mark.内容文本;
          v_Marks := Replace(v_Marks, '||', '^');
          For I In 1 .. 100 Loop
            v_Mark := Zl_Eprsplit(v_Marks, '^', I);
            If Zl_Eprsplit(v_Mark, '|', 15) Is Null Then
              --最后一个标记信息不全，存在下一行中
              Exit;
            Else
              Select Xmlelement("Mark",
                                 Xmlforest(Zl_Eprsplit(v_Mark, '|', 2) As "类型", Zl_Eprsplit(v_Mark, '|', 3) As "内容",
                                            Zl_Eprsplit(v_Mark, '|', 4) As "点集", Zl_Eprsplit(v_Mark, '|', 5) As "X1",
                                            Zl_Eprsplit(v_Mark, '|', 6) As "Y1", Zl_Eprsplit(v_Mark, '|', 7) As "X2",
                                            Zl_Eprsplit(v_Mark, '|', 8) As "Y2", Zl_Eprsplit(v_Mark, '|', 9) As "填充色",
                                            Zl_Eprsplit(v_Mark, '|', 10) As "填充方式",
                                            Zl_Eprsplit(v_Mark, '|', 11) As "线条色", Zl_Eprsplit(v_Mark, '|', 12) As "字体色",
                                            Zl_Eprsplit(v_Mark, '|', 13) As "线型", Zl_Eprsplit(v_Mark, '|', 14) As "线宽",
                                            Zl_Eprsplit(v_Mark, '|', 15) As "字体"))
              Into Makxml
              From Dual;
              Select Xmlconcat(Maksxml, Makxml) Into Maksxml From Dual;
            End If;
          End Loop;
        End Loop;
        --向Picture插入标记子节点
        Select Appendchildxml(Docxml,
                               '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Picture[@ID=' || Rs.Id || ']',
                               Maksxml)
        Into Docxml
        From Dual;
      Elsif Rs.对象类型 = 7 Then
        --诊断
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Diagnosise", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"), Rs.内容文本))
          Into Docxml
          From Dual;
        End If;
      Elsif Rs.对象类型 = 8 Then
        --签名
        If Rs.父id Is Null Then
          Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID=' || File_Id || ']/Compend[@ID=0]',
                                 Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Zl_Eprsplit(Rs.内容文本, ';', 1)))
          Into Docxml
          From Dual;
        Else
          Select Appendchildxml(Docxml,
                                 '/ZlEPR/Document[@文件ID=' || File_Id || ']/descendant::Compend[@ID=' || Rs.父id || ']',
                                 Xmlelement("Sign", Xmlattributes(Nvl(Rs.是否换行, 0) As "NewLine"),
                                             Zl_Eprsplit(Rs.内容文本, ';', 1)))
          Into Docxml
          From Dual;
        End If;
      End If;
    End Loop;
      
    For Aa In (Select A1.Ftp目录 || '/' || To_Char(l.接收日期, 'yyyymmdd') || '/' || l.检查uid As v_Ftppath
               From 影像检查记录 L, 影像设备目录 A1
               Where l.位置一 = A1.设备号(+) And l.医嘱id = n_Adviceid) Loop
        
      Select Appendchildxml(Docxml, '/ZlEPR/Document[@文件ID="' || File_Id || '"]/Compend[@ID=0]',
                             Xmlelement("FtpPath", Xmlattributes(v_Newline As "NewLine"), Aa.v_Ftppath))
      Into Docxml
      From Dual;
    End Loop;
    
  End Loop;
  
  Return Docxml;  
End Zlpub_Pacs_获取病历文本;
/  

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取报告文本
(
  Ids_In In Varchar2,
  From_In Number
) Return Xmltype Is
--Ids_In规则是以 '|' 分隔的ID串，开始/结尾无 '|'
  --根所给定的病历文件ID串生成内容XML并返回XMLType
  Docxml XmlType;
  v_Sql Varchar2(1000);
Begin
    
  If From_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档文本(:1) From Dual';
    Execute Immediate v_Sql Into Docxml Using Ids_In;
  Else
    v_Sql := 'Select Zlpub_Pacs_获取病历文本(:1, :2) From Dual';
    Execute Immediate v_Sql Into Docxml Using Ids_In, From_In;
  End If;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End Zlpub_Pacs_获取报告文本;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取文档内容
( 
  报告ID_In In 影像报告记录.ID%Type, 
  报告提纲_In In 影像报告记录.诊断意见%Type 
) Return Varchar2 Is 
  x_Content        xmltype; 
  Xcdom            Xmldom.Domdocument; 
  Section_List     Xmldom.Domnodelist; 
  Section_Node     Xmldom.Domnode; 
  Node_List        Xmldom.Domnodelist; 
  n_Len            Number; 
  Element_Node     Xmldom.Domnode; 
  p_Node           Xmldom.Domnode; 
  Enum_Node        Xmldom.Domnode; 
  e_Node           Xmldom.Domnodelist; 
  c_Node           Xmldom.Domnode; 
  Enumeration_List Xmldom.Domnodelist; 
  Enumeration_Node Xmldom.Domnode; 
  Item_List        Xmldom.Domnodelist; 
  Item_Node        Xmldom.Domnode; 
  Item_Node1       Xmldom.Domnode; 
  v_Name           Varchar2(100); 
  v_Result         Varchar2(4000); 
  n_i              Number; 
  n_Num            Number; 
  n_j              Number; 
  n_Enum           Number; 
  v_Val            Varchar2(20); 
  v_Content        Varchar2(4000); 
  v_Eleid          Varchar2(50); 
  v_Multisel       Varchar2(10); 
Begin 
    v_Result := ''; 
    
    Select 报告内容 Into x_Content From 影像报告记录 Where id = 报告ID_In;

    Select Deletexml(x_Content, '//image') Into x_Content From Dual; 
 
    Xcdom := Xmldom.Newdomdocument(x_Content); 
 
    For Myrow In (Select Column_Value Name From Table(f_Str2list(报告提纲_In))) Loop 
      n_i := -1; 
      --循环提纲名称 
      Section_List := Xmldom.Getelementsbytagname(Xcdom, 'section'); 
      n_Len        := Xmldom.Getlength(Section_List); 
 
      For I In 0 .. n_Len - 1 Loop 
        If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Section_List, I)), 'title') = Myrow.Name Then 
          n_i := I; 
          Exit; 
        End If; 
      End Loop; 
 
      If n_i >= 0 Then 
        Section_Node := Xmldom.Item(Section_List, n_i); 
        Node_List    := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Section_Node), '*'); 
        n_Len        := Xmldom.Getlength(Node_List); 
 
        For I In 0 .. n_Len - 1 Loop 
          Element_Node := Xmldom.Item(Node_List, I); 
          v_Name       := Xmldom.Getnodename(Element_Node); 
 
          If v_Name = 'element' Then 
            If Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit') Is Not Null Then 
              v_Content := Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
 
              If Instr(v_Content, 'textstyleno') > 0 Then 
                v_Content := ''; 
              End If; 
              --如果有单位 
              v_Result := v_Result || v_Content || Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'unit'); 
            Else 
              p_Node := Xmldom.Getparentnode(Element_Node); 
              If Xmldom.Getnodename(p_Node) <> 'enumvalues' Then 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)); 
              End If; 
            End If; 
          Elsif v_Name = 'utext' Then 
            v_Result := v_Result || LTrim(LTrim(Xmldom.Getnodevalue(Xmldom.Getfirstchild(Element_Node)), ':'), '：'); 
          Elsif v_Name = 'e_list' Or v_Name = 'e_enum' Or v_Name = 'e_etree' Or v_Name = 'e_utree' Then 
            Enumeration_List := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumeration'); 
            n_Num            := Xmldom.Getlength(Enumeration_List); 
 
            If v_Name = 'e_enum' And n_Num > 0 Then 
              For J In 0 .. n_Num - 1 Loop 
                Enumeration_Node := Xmldom.Item(Enumeration_List, J); 
                Item_List        := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'item'); 
                n_j              := Xmldom.Getlength(Item_List); 
 
                For K In 0 .. n_j - 1 Loop 
                  Item_Node := Xmldom.Item(Item_List, K); 
                  If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'checked') = '1' Then 
                    v_Val := Xmldom.Getattribute(Xmldom.Makeelement(Item_Node), 'val'); 
 
                    For Z In 0 .. n_j - 1 Loop 
                      Item_Node1 := Xmldom.Item(Item_List, Z); 
                      If Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'val') = v_Val And 
                         Xmldom.Getattribute(Xmldom.Makeelement(Item_Node1), 'issymbol') = '0' Then 
                        v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.Getfirstchild(Item_Node1)); 
                        Exit; 
                      End If; 
                    End Loop; 
                  End If; 
                End Loop; 
              End Loop; 
            Else 
              --这里处理枚举有无的情况 
              v_Eleid := Xmldom.Getattribute(Xmldom.Makeelement(Element_Node), 'sid'); --获取元素ID 
 
              Select Extractvalue(b.值域描述, '/root/multisel') 
              Into v_Multisel 
              From 影像报告元素清单 A, 影像报告值域清单 B 
              Where a.值域id = b.id And a.id = Hextoraw(v_Eleid); 
 
              If v_Multisel = 2 And v_Name = 'e_enum' Then 
                --为是否类型的枚举 
                v_Result := v_Result || Xmldom.Getnodevalue(Xmldom.getLastChild(Element_Node)); 
              Else 
                Enum_Node := Xmldom.Item(Xmldom.Getelementsbytagname(Xmldom.Makeelement(Element_Node), 'enumvalues'), 0); 
                e_Node := Xmldom.Getelementsbytagname(Xmldom.Makeelement(Enum_Node), 'element'); 
                n_Enum := Xmldom.Getlength(e_Node); 
 
                For K In 0 .. n_Enum - 1 Loop 
                  c_Node   := Xmldom.Item(e_Node, K); 
                  v_Result := v_Result || Xmldom.Getattribute(Xmldom.Makeelement(c_Node), 'showtext'); 
 
                  If K <> n_Enum - 1 Then 
                    v_Result := v_Result || '、'; 
                  End If; 
                End Loop; 
              End If; 
            End If; 
          End If; 
        End Loop; 
      End If; 
    End Loop; 
 
    Xmldom.Freedocument(Xcdom); 
 
    Return translate(v_Result,chr(13)||chr(10),','); 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zlpub_Pacs_获取文档内容; 
/

--102414:涂建华,2016-12-09,pacs依赖接口调整，支持多份报告
CREATE OR REPLACE Function Zlpub_Pacs_获取病历内容
(
  报告ID_In   In Number,
  报告来源_In In Number,
  报告提纲_In In Varchar2
) Return Varchar2 Is
  Type t_Str_Table Is Table Of Varchar2(4000);
  a_Return t_Str_Table := t_Str_Table();

  v_Return        Varchar2(4000);
  v_Temp          Varchar2(4000);
  n_Count         Number(2);
  n_病历ID        Number(18);

  v_Sql           Varchar2(1000);
Begin
  n_病历ID := 报告id_In;
  v_Return       := '';

  If 报告来源_In = 2 Then
     v_Sql := 'Select 病历ID From 病人医嘱报告 Where RISID=:1';
     Execute Immediate v_Sql Into n_病历ID Using 报告id_In;
  End If;

  Begin
    Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
    Into a_Return
    From 电子病历内容
    Where 终止版 = 0  And 对象类型 In(2,4) And 文件id = n_病历ID 
    Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 1)
    Connect By Prior ID=父ID
    Order By 对象序号;

    For n_Count In 1 .. a_Return.Count Loop
      If v_Return Is Null Then
        If n_Count = 1 Then
          v_Temp := a_Return(n_Count);
          If Instr(v_Temp,报告提纲_In) <> 1 Then
            v_Return := v_Temp;
          End If; 
        Else
          v_Return := a_Return(n_Count);
        End If;
        
      Else
        v_Return := v_Return || a_Return(n_Count);
      End If;
    End Loop;

  Exception
    When Others Then
      v_Return := Null;
  End;

  Begin
    If v_Return Is Null Then
      Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
      Into a_Return
      From 电子病历内容
      Where 终止版 = 0  And 对象类型 In(2,4) And 文件id = n_病历ID
      Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 3)
      Connect By Prior ID=父ID
      Order By 对象序号;

      For n_Count In 1 .. a_Return.Count Loop
        If v_Return Is Null Then
          v_Return := a_Return(n_Count);
        Else
          v_Return := v_Return || a_Return(n_Count);
        End If;
      End Loop;

    End If;
  Exception
    When Others Then
      v_Return := Null;
  End;

  If v_Return Is Null Then
    Select Decode(是否换行, 1, 内容文本 || Chr(10) || Chr(13), 内容文本) Bulk Collect
    Into a_Return
    From 电子病历内容
    Where 终止版 = 0  And Substr(对象属性,1,1) = '0' And 文件id = n_病历ID
    Start With  父id = (Select ID From 电子病历内容 Where 文件id = n_病历ID And 内容文本 = 报告提纲_In And 对象类型 = 1)
    Connect By Prior ID=父ID
    Order By 对象序号;

    For n_Count In 1 .. a_Return.Count Loop
        If v_Return Is Null Then
          If n_Count = 1 Then
            v_Temp := a_Return(n_Count);
            If Instr(v_Temp,报告提纲_In) <> 1 Then
              v_Return := v_Temp;
            End If; 
          Else
            v_Return := a_Return(n_Count);
          End If;
          
        Else
          v_Return := v_Return || a_Return(n_Count);
        End If;
    End Loop;
  End If;

  Return v_Return;
End Zlpub_Pacs_获取病历内容;
/

--102414:涂建华,2016-11-30,pacs依赖接口调整，支持多份报告
Create Or Replace Function Zlpub_Pacs_获取提纲内容
(
  报告id_In   In Varchar2,
  报告来源_In In Number,
  报告提纲_In In Varchar2
) Return Varchar2 Is

  v_Result        Varchar2(4000);
  v_Singleresult  Varchar2(4000);
  v_Sql           Varchar2(1000);
  
Begin
  v_Result       := '';
  v_Singleresult := '';

  If 报告来源_In = 1 Then
    v_Sql := 'Select Zlpub_Pacs_获取文档内容(:1, :2) From Dual';
    Execute Immediate v_Sql Into v_Singleresult Using 报告id_In,报告提纲_In;
  Else
    v_Sql := 'Select Zlpub_Pacs_获取病历内容(:1, :2, :3) From Dual';
    Execute Immediate v_Sql Into v_Singleresult Using 报告id_In,报告来源_In, 报告提纲_In;
  End If;
  
  If v_Result Is Null And Not v_Singleresult Is Null Then
    v_Result := v_Singleresult;
  Elsif Not v_Singleresult Is Null Then
    v_Result := v_Result || ';' || v_Singleresult;
  End If;
    
  Return v_Result;
      
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zlpub_Pacs_获取提纲内容;
/

--101736:冉俊明,2016-11-07,手工记帐缺省执行科室调整。
Create Or Replace Procedure Zl_收费细目_Dept
(
  收费细目id_In In 收费项目目录.Id%Type,
  执行科室_In   In Number,
  应用范围_In   In Number,
  分类id_In     In 收费项目目录.分类id%Type,
  类别_In       In 收费项目目录.类别%Type,
  科室列表_In   In Varchar2, --开单科室定向执行的说明串，以'|'分割，每个定向按'开单科室id^执行科室id'形式组织
  门诊执行_In   In 诊疗执行科室.执行科室id%Type := Null,
  住院执行_In   In 诊疗执行科室.执行科室id%Type := Null
) Is
  Type t_收费细目 Is Ref Cursor;

  c_收费细目   t_收费细目;
  v_Id         收费项目目录.Id%Type;
  v_执行科室   收费项目目录.执行科室%Type;
  v_Records    Varchar2(4000); --临时记录开单科室定向执行科室的字符串
  v_Currrec    Varchar2(1000); --包含在定向执行科室字符串中的一个定向
  v_Fields     Varchar2(1000);
  v_开单科室id 收费执行科室.开单科室id%Type := Null;
  v_执行科室id 收费执行科室.执行科室id%Type := Null;
Begin
  --首先按不同范围打开记录集
  If 应用范围_In = 1 Then
    --同级项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select ID, 执行科室 From 收费项目目录 Where 分类id Is Null Order By 编码;
    Else
      Open c_收费细目 For
        Select ID, 执行科室 From 收费项目目录 Where 分类id = 分类id_In Order By 编码;
    End If;
  Elsif 应用范围_In = 2 Then
    --分类下所有项目
    If 分类id_In Is Null Then
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With 上级id Is Null Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    Else
      Open c_收费细目 For
        Select c.Id, c.执行科室
        From 收费项目目录 C, (Select ID From 收费分类目录 Start With ID = 分类id_In Connect By Prior ID = 上级id) D
        Where d.Id = c.分类id
        Order By 编码;
    End If;
  Elsif 应用范围_In = 3 Then
    --类别下所有项目
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where 类别 = 类别_In Order By 编码;
  Else
    Open c_收费细目 For
      Select ID, 执行科室 From 收费项目目录 Where ID = 收费细目id_In;
  End If;

  --接着修改
  Loop
    Fetch c_收费细目
      Into v_Id, v_执行科室;
    Exit When c_收费细目%NotFound;
  
    If v_执行科室 = 4 Or v_执行科室 = 0 Then
      Delete From 收费执行科室 Where 收费细目id = v_Id;
    End If;
  
    Update 收费项目目录 Set 执行科室 = 执行科室_In Where ID = v_Id;
  
    If 执行科室_In = 4 And 门诊执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 1, Null, 门诊执行_In);
    End If;
    If (执行科室_In = 4 Or 执行科室_In = 0) And 住院执行_In Is Not Null Then
      Insert Into 收费执行科室 (收费细目id, 病人来源, 开单科室id, 执行科室id) Values (v_Id, 2, Null, 住院执行_In);
    End If;
    If 执行科室_In <> 4 Or 科室列表_In Is Null Then
      v_Records := Null;
    Else
      v_Records := 科室列表_In || '|';
    End If;
    While v_Records Is Not Null Loop
      v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Fields     := v_Currrec;
      v_开单科室id := To_Number(Substr(v_Fields, 1, Instr(v_Fields, '^') - 1));
      v_Fields     := Substr(v_Fields, Instr(v_Fields, '^') + 1);
      v_执行科室id := To_Number(v_Fields);
      Insert Into 收费执行科室
        (收费细目id, 病人来源, 开单科室id, 执行科室id)
      Values
        (v_Id, Null, Decode(v_开单科室id, 0, Null, v_开单科室id), v_执行科室id);
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  End Loop;

  Close c_收费细目;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_收费细目_Dept;
/

--102117:胡俊勇,2016-11-02,出院医嘱发送前检查
Create Or Replace Procedure Zl_病人变动记录_Change
(
  病人id_In     病案主页.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  转入科室id_In 病人变动记录.科室id%Type,
  操作员编号_In 病人变动记录.操作员编号%Type,
  操作员姓名_In 病人变动记录.操作员姓名%Type
) As
  -----------------------------------------------------------
  --说明：病人转科登记
  -----------------------------------------------------------
  v_Count  Number;
  v_科室id 病人临床路径.科室id%Type;
  v_年龄   病人信息.年龄%Type;
  v_姓名   病人信息.姓名%Type;
  Err_Custom Exception;
  v_Error Varchar2(255);
Begin
  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能转科。';
    Raise Err_Custom;
  End If;

  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院科室id = 转入科室id_In;
  If v_Count > 0 Then
    v_Error := '操作失败,当前该病人所在的科室和即将转入的科室相同,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;

  --一次住院只有一个路径，临床路径正在执行时不允许转科(除非是从ICU转出或转入)
  Select Nvl(Max(科室id), 0)
  Into v_科室id
  From 病人临床路径 a
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.状态 = 1;
  If v_科室id <> 0 Then
    Select Count(*)
    Into v_Count
    From 部门性质说明 c
    Where (c.部门id = v_科室id Or c.部门id = 转入科室id_In) And c.工作性质 = 'ICU';
    If v_Count = 0 Then
      v_Error := '该病人的临床路径正在执行中,不能转科。';
      Raise Err_Custom;
    End If;
  End If;

  --检查未校对的医嘱，或已校对但未发送的临嘱
  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And Nvl(婴儿, 0) = 0 And
          Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --修改病人临床路径表中的科室ID
  Update 病人临床路径 Set 科室id = 转入科室id_In Where 病人id = 病人id_In And 主页id = 主页id_In And 状态 = 1;

  --不填写开始时间和终止时间
  Insert Into 病人变动记录
    (Id, 病人id, 主页id, 开始时间, 开始原因, 病区id, 科室id, 操作员编号, 操作员姓名)
  Values
    (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, Null, 3, Null, 转入科室id_In, 操作员编号_In, 操作员姓名_In);

  Update 病案主页 Set 状态 = 2 Where 病人id = 病人id_In And 主页id = 主页id_In;

  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 Is Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Change;
/

--101833:刘尔旋,2016-10-24,脚本同步处理
Create Or Replace Procedure Zl_挂号安排_Delete
(
  Id_In   挂号安排.Id%Type,
  删除_In 挂号安排.是否删除%Type
) Is
  n_Count Number;
Begin
  Begin
    Select Count(*)
    Into n_Count
    From 病人挂号汇总 A, 挂号安排 B
    Where a.项目id = b.项目id And b.Id = Id_In And a.号码 = b.号码 Having Sum(Nvl(已挂数, 0)) > 0 Or Sum(Nvl(已约数, 0)) > 0;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(删除_In, 0) = 1 And Nvl(n_Count, 0) = 0 Then
    Update 挂号安排 Set 执行计划id = Null Where ID = Id_In;
    Delete 挂号计划限制 Where 计划id = Id_In;
    Delete 挂号计划时段 Where 计划id = Id_In;
    Delete 挂号计划诊室 Where 计划id = Id_In;
    Delete 挂号安排计划 Where 安排id = Id_In;
    Delete 挂号安排限制 Where 安排id = Id_In;
    Delete 挂号安排时段 Where 安排id = Id_In;
    Delete 挂号安排诊室 Where 号表id = Id_In;
    Delete 挂号安排停用状态 Where 安排id = Id_In;
    Delete 挂号安排 Where ID = Id_In;
  Else
    Update 挂号安排 Set 是否删除 = 1, 停用日期 = Sysdate Where ID = Id_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Delete;
/

--101833:刘尔旋,2016-10-24,脚本同步处理
Create Or Replace Procedure Zl_挂号计划时段_批量应用
(
  计划id_In 挂号计划时段.计划id%Type,
  Type_In   Number := 1
) As
  --type_in
  --1-应用与本人
  --2-应用与本科室
  --3 or others -应用于所有
  Cursor c_Deposit
  (
    Tp     Number,
    n_Id   挂号安排计划.Id %Type,
    n_科室 挂号安排.科室id%Type,
    n_医生 挂号安排.医生id%Type
  ) Is
    Select 目标id, 源id As ID
    From (With Tb As (Select a.Id, a.安排id
                      From (Select a.Id, a.安排id, a.项目id, a.号码, a.生效时间, a.失效时间, a.分诊方式, a.序号控制, a.安排人, a.安排时间, a.审核人, a.审核时间,
                                    a.实际生效, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六
                             From 挂号安排计划 A, 挂号安排 B
                             Where a.安排id = b.Id And a.Id <> n_Id And
                                   Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) > Sysdate And 实际生效 Is Not Null And
                                   Nvl(b.医生id, 0) = Decode(Tp, 1, n_医生, Nvl(b.医生id, 0)) And
                                   b.科室id = Decode(Tp, 2, n_科室, b.科室id)) A,
                           (Select a.Id, a.安排id, a.项目id, a.号码, a.生效时间, a.失效时间, a.分诊方式, a.序号控制, a.安排人, a.安排时间, a.审核人, a.审核时间,
                                    a.实际生效, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六
                             From 挂号安排计划 A, 挂号安排 B
                             Where a.安排id = b.Id And a.Id = n_Id) B
                      Where Nvl(a.周一, '_') = Nvl(b.周一, '_') And Nvl(a.周二, '_') = Nvl(b.周二, '_') And
                            Nvl(a.周三, '_') = Nvl(b.周三, '_') And Nvl(a.周四, '_') = Nvl(b.周四, '_') And
                            Nvl(a.周五, '_') = Nvl(b.周五, '_') And Nvl(a.周六, '_') = Nvl(b.周六, '_') And
                            Nvl(a.周日, '_') = Nvl(b.周日, '_') And Nvl(a.序号控制, 0) = Nvl(b.序号控制, 0))
           Select a.目标id, a.源id
           From (Select Count(1) As 统计, a.计划id As 目标id, b.计划id As 源id
                  From (Select 计划id, 限制项目, Nvl(限号数, 0) As 限号数, Nvl(限约数, 0) As 限约数
                         From 挂号计划限制
                         Where 计划id In (Select ID From Tb)) A,
                       (Select 计划id, 限制项目, Nvl(限号数, 0) As 限号数, Nvl(限约数, 0) As 限约数
                         From 挂号计划限制
                         Where 计划id = n_Id) B
                  Where a.限制项目 = b.限制项目 And a.限号数 = b.限号数 And a.限约数 = b.限约数
                  Group By a.计划id, b.计划id) A,
                (Select Count(1) As 统计, 计划id From 挂号计划限制 Where 计划id = n_Id Group By 计划id) B
           Where a.源id = b.计划id And a.统计 = b.统计) B;

  --应用于 游标
  n_科室id 挂号安排.科室id%Type;
  n_医生id 挂号安排.医生id%Type;
  Err_Item Exception;
  v_Err_Msg Varchar2(500);
Begin
  Begin
    Select b.科室id, b.医生id
    Into n_科室id, n_医生id
    From 挂号安排计划 A, 挂号安排 B
    Where a.安排id = b.Id And a.Id = 计划id_In;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]没有找到对应的挂号安排计划信息!请检查![ZLSOFT]';
      Raise Err_Item;
  End;
  For r_Deposit In c_Deposit(Type_In, 计划id_In, n_科室id, n_医生id) Loop
    Delete 挂号计划时段 Where 计划id = r_Deposit.目标id;
    Insert Into 挂号计划时段
      (计划id, 序号, 星期, 开始时间, 结束时间, 限制数量, 是否预约)
      Select r_Deposit.目标id, 序号, 星期, 开始时间, 结束时间, 限制数量, 是否预约
      From 挂号计划时段
      Where 计划id = r_Deposit.Id;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号计划时段_批量应用;
/

--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_Common Is
  Type t_Refcur Is Ref Cursor;

--1 获取参数的缓冲数据
Procedure p_GetParInfBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In  In 影像参数说明.模块%Type
  );
  
--2 功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
  Function f_Str2list
  (
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined;
  
--3  获取参数值的缓冲数据
--当前用户所在计算机的参数值
Procedure p_GetParValueBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  科室ID_In In Varchar2,
  机器名_In In Varchar2,
  用户ID_In In Number);

--4  获取权限的缓冲数据
Procedure p_GetPopedomBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_IN In 影像参数说明.模块%Type,
  用户名_In In Varchar2);

--5  设置参数值
Procedure p_SetParameterValue(
  参数ID_In    In 影像参数取值.参数ID%Type,
  参数标识_In In 影像参数取值.参数标识%Type,
  参数值_In    In 影像参数取值.参数值%Type);

--6  获取用户账号信息
Function f_Get_Personal_Info_By_Account(
	Account_In In Varchar2
) Return Xmltype;

end b_PACS_Common ;

/



--*************************************************************************************
--*                  影像报告原型管理(---实现部分---)                                                        *
--*************************************************************************************
CREATE OR REPLACE Package Body b_PACS_Common  Is

--1 获取参数的缓冲数据
Procedure p_GetParInfBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In  In 影像参数说明.模块%Type
) Is
Begin
Open  Val For
   Select RawToHex(ID) As ID,RawToHex(PID) As PID,系统,模块,参数名,默认值,参数级别,启用条件
   From 影像参数说明
   Where 系统=系统_In And 模块=模块_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_GetParInfBuf;

--2 功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined As
    v_Str Long;
    P     Number;
    --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
    --参数：Str_In,如:甲抗,胃溃疡,胃出血...,Split_In,分隔符,缺省为,号
    --说明：
    --1．当SQL语句中涉及“IN(常量1, 常量2,…) ”子句时使用这种方式以便利用绑定变量。
    --2．使用这两个函数时，需要在SQL语句中加入“/*+ Rule*/”提示，因为Cbo下临时内存表没有统计数据,。
    --3．两种调用示例
    --Select /*+ Rule*/ * From Sample_List Where Title In (Select * From Table(f_Str2list('甲抗,胃溃疡,胃出血'));
    --Select /*+ Rule*/ A.* From Sample_List A, Table(f_Str2list('甲抗,胃溃疡,胃出血')) B Where A.Title = B.Column_Value;
  Begin
    If Str_In Is Null Then
      Return;
    End If;
    v_Str := Str_In || Split_In;
    Loop
      P := Instr(v_Str, Split_In);
      Exit When(Nvl(P, 0) = 0);
      Pipe Row(Trim(Substr(v_Str, 1, P - 1)));
      v_Str := Substr(v_Str, P + 1);
    End Loop;
    Return;
  End;

--3  获取参数值的缓冲数据
--当前用户所在计算机的参数值
Procedure p_GetParValueBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  科室ID_In In Varchar2,
  机器名_In In Varchar2,
  用户ID_In In Number
) Is
Begin
	Open  Val For
	    Select RawToHex(b.ID) As ID, RawToHex(b.参数ID) As 参数ID,b.参数标识,b.参数值
		From 影像参数说明 a, 影像参数取值 b
		Where  a.id=b.参数id And a.系统=系统_In And a.模块=模块_In and (a.参数级别=0 or a.参数级别=1 or (a.参数级别=2 and b.参数标识=科室ID_In) or (a.参数级别=3 and b.参数标识=用户ID_In) or (a.参数级别=4 and b.参数标识=机器名_In));
Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
End 	p_GetParValueBuf;

--4  获取权限的缓冲数据
Procedure p_GetPopedomBuf(
  Val           Out t_Refcur,
  系统_In In 影像参数说明.系统%Type,
  模块_In In 影像参数说明.模块%Type,
  用户名_In In Varchar2
)Is
Begin
    --返回用户, 模块号,功能
	Open  Val For
	    Select a.用户,b.系统, b.序号 as 模块, b.功能
		From zluserroles a, zlrolegrant b
		Where a.角色=b.角色 And a.用户=用户名_In And b.系统=系统_In And b.序号=模块_In;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_GetPopedomBuf;

--5  更新参数值
Procedure p_SetParameterValue(
  参数ID_In    In 影像参数取值.参数ID%Type,
  参数标识_In In 影像参数取值.参数标识%Type,
  参数值_In    In 影像参数取值.参数值%Type
)Is
Begin
	Update 影像参数取值 Set 参数值=参数值_In Where 参数ID=参数ID_In And 参数标识=参数标识_In;
	If Sql%RowCount = 0 Then
	  Insert Into 影像参数取值(ID, 参数ID,参数标识,参数值)
	  Values(sys_guid(), 参数ID_In,参数标识_In,参数值_In);
	End If;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm);
End p_SetParameterValue;

--6  获取用户账号信息
Function f_Get_Personal_Info_By_Account(
	Account_In In Varchar2
) Return Xmltype Is
  Docxml   Xmltype;
Begin 
  Select Xmltype('<root></root>') Into Docxml From Dual;  
  Select Appendchildxml(Docxml, '/root',
                         Xmlconcat(Xmlelement("code", a.Id), Xmlelement("full_name", a.姓名),
                                    Xmlelement("sex", Xmlattributes(a.性别 As "display"),
                                                Decode(a.性别, '男', '1', '女', '2', '未知', '0', '9')),
                                    Xmlelement("birthday", To_Char(a.出生日期, 'yyyy-mm-dd')),
                                    Xmlelement("idcard_num", a.身份证号)))
  Into Docxml
  From 人员表 A, 上机人员表 B
  Where b.用户名 = Account_In And b.人员id = a.Id And Nvl(a.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate;  

  Select Appendchildxml(Docxml, '/root',
                         Xmlelement("departments",
                                     Xmlagg(Xmlelement("department", Xmlattributes(c.名称 As "display", d.缺省 As "current"),
                                                        Xmlelement("dept_value", c.Id)))))
  Into Docxml
  From 上机人员表 B, 部门表 C, 部门人员 D
  Where b.用户名 = Account_In And b.人员id = d.人员id And d.部门id = c.Id;

  For r_Record In (Select d.部门id, Xmlelement("subjects", Xmlagg(Xmlelement("subject", c.名称))) As 部门学科
                   From 临床部门 A, 上机人员表 B, 部门人员 D, 临床性质 C
                   Where b.用户名 = Account_In And b.人员id = d.人员id And a.部门id = d.部门id And a.工作性质 = c.编码
                   Group By d.部门id
                   Order By d.部门id) Loop
    Select Appendchildxml(Docxml, '/root/departments/department[dept_value=' || r_Record.部门id || ']', r_Record.部门学科)
    Into Docxml
    From Dual;
  End Loop;

  Return Docxml;
Exception
  When Others Then
    Return Null;
End f_Get_Personal_Info_By_Account;

End b_PACS_Common;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
Create Or Replace Package b_PACS_Config Is
  Type t_Refcur Is Ref Cursor;

  -- 功    能：获取影像字典清单
  Procedure p_GetAllDictList(
	Val			Out t_Refcur
  );

  -- 功    能：获取影像字典内容
  Procedure p_GetAllDictItems(
    Val           Out t_Refcur,
	字典ID_In	In 影像字典内容.字典ID%Type
  );

  -- 功    能：新增或修改影像字典内容
  Procedure p_EditDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	旧编号_In		In 影像字典内容.编号%Type,
	编号_In			In 影像字典内容.编号%Type,
	名称_In			In 影像字典内容.名称%Type,
	简码_In			In 影像字典内容.简码%Type,
	说明_In			In 影像字典内容.说明%Type
  );

  -- 功    能：删除影像字典内容
  Procedure p_DelDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	编号_In			In 影像字典内容.编号%Type
  );
End b_PACS_Config;
/

--*************************************************************************************
--*								   (---实现部分---)                                    *
--*************************************************************************************
Create Or Replace Package Body b_PACS_Config  Is
  -- 功    能：获取影像字典清单
  Procedure p_GetAllDictList(
	Val			Out t_Refcur
  )
  Is
	strSql varchar2(100);
  Begin
	strSql := 'select Rawtohex(ID) ID,编号,名称,说明,是否系统,分组 From 影像字典清单';
	Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllDictList;

  -- 功    能：获取影像字典内容
  Procedure p_GetAllDictItems(
    Val           Out t_Refcur,
	字典ID_In		In 影像字典内容.字典ID%Type
  )
  Is
	strSql varchar2(200);
  Begin
	strSql := 'Select Rawtohex(A.字典id) Rid, A.编号, A.名称, A.简码, A.说明 '||
			  'From 影像字典内容 A Where A.字典id = '''|| 字典ID_In ||'''';
	Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllDictItems;

  -- 功    能：新增或修改影像字典内容
  Procedure p_EditDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	旧编号_In		In 影像字典内容.编号%Type,
	编号_In			In 影像字典内容.编号%Type,
	名称_In			In 影像字典内容.名称%Type,
	简码_In			In 影像字典内容.简码%Type,
	说明_In			In 影像字典内容.说明%Type
  )
  Is
	n_Num Number;
	v_Msg Varchar2(50);
	Err	  Exception;
  Begin
	If 旧编号_In<>'-1' Then
	  Select Count(字典ID) Into n_Num From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In And 编号<>旧编号_In;
	  If n_Num > 0 Then
		v_Msg:='所属字典ID和编号重复!';
		Raise Err;
	  End IF;

	  Update 影像字典内容 A
	  Set A.编号 = 编号_In,A.名称 = 名称_In,A.简码 = 简码_In,A.说明 = 说明_In
	  Where A.字典ID = 字典ID_In And A.编号 = 旧编号_In;
	Else
	  Select Count(字典ID) Into n_Num From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In;
	  If n_Num > 0 Then
		v_Msg:='所属字典ID和编号重复!';
		Raise Err;
	  End IF;
	
	  Insert Into 影像字典内容(字典ID,编号,名称,简码,说明)
	  Values(字典ID_In,编号_In,名称_In,简码_In,说明_In);
	End If;
  Exception
	When Err Then
	  Raise_Application_Error(-20101,v_Msg);
	When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDictItem;

  -- 功    能：删除影像字典内容
  Procedure p_DelDictItem(
	字典ID_In		In 影像字典内容.字典ID%Type,
	编号_In			In 影像字典内容.编号%Type
  )
  Is
  Begin
	Delete From 影像字典内容 Where 字典ID = 字典ID_In And 编号 = 编号_In;
  Exception
	When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDictItem;
End b_PACS_Config;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	);
  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
	Stop_Flag    Number,
	Condition_In Varchar2
	);
  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
	种类_In         影像报告原型清单.种类%Type,
	编码_In         影像报告原型清单.编码%Type,
	名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
	说明_In         影像报告原型清单.说明%Type,
	可否重置页面_In 影像报告原型清单.可否重置页面%Type,
	可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
	是否禁用_In     影像报告原型清单.是否禁用%Type,
	创建人_In       影像报告原型清单.创建人%Type,
	内容_In         影像报告原型清单.内容%Type,
	控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
	专用插件_In     影像报告原型清单.专用插件%Type,
	Copy_Id_In      影像报告原型清单.ID%Type,
	Only_Head_In    Varchar2,
	分组_In         影像报告原型清单.分组%Type
	);
  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    Id_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
    设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
    可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_Id_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	);
  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);
  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);
  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    Id_In 影像报告原型清单.Id%Type
	);

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	);
  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind;
  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);
  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
	编码_In 影像报告预备提纲.编码%Type,
	名称_In 影像报告预备提纲.名称%Type,
	说明_In 影像报告预备提纲.说明%Type
	);
  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline;
  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	);
  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	);
  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	);
  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
    Val           Out t_Refcur,		
	原型ID_In 影像报告原型片段.原型ID%Type,
    片段ID_In 影像报告原型片段.片段ID%Type
	);
  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    Id_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	);
  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	);
  --21.获取已经设置了关联的原型片段类别的信息

  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型id_In Varchar2
	);
  --23.获取能复制的原型名称

  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	);
  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型id_In 影像报告原型清单.Id%Type
	);
  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	);
  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	);
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	);
  --29.获取关于原型导出的重复信息

  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
    Id_In        影像报告原型清单.Id%Type,
    编码_In      Varchar2,
    名称_In      Varchar2
	);
  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,	
	Id_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	);
  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	);

  ----32.获取元素或者提纲的名称集合
  --Procedure p_Get_Antetype_Ele_Section(
  --原型ID_In  影像报告原型清单.Id%Type,
  --Val     Out t_Refcur);

  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型id_In 影像报告动作.原型id%Type
	);

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	);
  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	);

  --37.获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	);
  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	);
  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	);
  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type);
  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	);
  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	);
  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	);
  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type
	);
  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	);
  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	);
  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	);
  --50.删除文档处理
  Procedure p_Del_Doc_Process(
    Id_In        影像报告动作.ID%Type,
	Del_Event_In Number
	);

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	);
  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	);
  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
	Val           Out t_Refcur,
	ID_In Varchar2
	);
  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	);
  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	);
  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	);
  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
    编码_In 影像报告插件.编码%Type,
    名称_In 影像报告插件.名称%Type
	);
  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	);
  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
    条件_In Varchar2
	);
  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	);
  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
	应用场合_In   影像报告原型应用.应用场合%Type,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	);
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	);
  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
    名称_In 影像报告原型清单.名称%Type,
    ID_In  影像报告原型清单.ID%Type
	);

  --69  获取影像存储设备
  Procedure p_GetStorageDevice(
		Val           Out t_Refcur);

End b_PACS_RptAntetype;
/

--影像报告原型管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptAntetype Is
  --Create By Hwei;
  --2014/11/25

  --1.获取文件原型类别
  Procedure p_Get_Antetypelistkind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, a.名称, a.编码 || '-' || a.名称 As 标题
        From 影像报告种类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelistkind;

  --2.根据文档类型获取文档信息
  Procedure p_Get_Antetypelis_By_Kind(
	Val           Out t_Refcur,
	种类_In      影像报告原型清单.种类%Type,
    Stop_Flag    Number,
    Condition_In Varchar2
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And a.分组 Is Not Null
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.
               种类 = 种类_In
                 And ((a.是否禁用 <> 1 And Stop_Flag = 1) Or (Stop_Flag = 0))
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelis_By_Kind;

  --3.添加一个文档原型
  Procedure p_Add_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    创建人_In       影像报告原型清单.创建人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str Xmltype;
  Begin
    Begin
      If Copy_ID_In Is Null or Copy_ID_In = 0 Then
        x_Str := 内容_In;
      Else
        Select Decode(Only_Head_In,
                      1,
                      Deletexml(a.内容, '/zlxml/document/node()'),
                      a.内容)
          Into x_Str
          From 影像报告原型清单 A
         Where a.id = Copy_ID_In;
      End If;
    Exception
      When Others Then
        x_Str := 内容_In;
    End;
  
    Insert Into 影像报告原型清单
      (ID,
       种类,
       编码,
       名称,
	   设备号,
       说明,
       可否重置页面,
       可否重置格式,
	   可否书写多份,
       是否禁用,
       创建人,
       创建时间,
       内容,
       控制选项,
	   词句加载时机,
	   插件加载时机,
       专用插件,
       分组)
    Values
      (ID_In,
       种类_In,
       编码_In,
       名称_In,
	   设备号_In,
       说明_In,
       可否重置页面_In,
       可否重置格式_In,
	   可否书写多份_In,
       是否禁用_In,
       创建人_In,
       sysdate,
       x_Str,
       控制选项_In,
	   词句加载时机_In,
	   插件加载时机_In,
       专用插件_In,
       分组_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetypelist;

  --4.修改一个文档原型
  Procedure p_Edit_Antetypelist(
    ID_In           影像报告原型清单.ID%Type,
    种类_In         影像报告原型清单.种类%Type,
    编码_In         影像报告原型清单.编码%Type,
    名称_In         影像报告原型清单.名称%Type,
	设备号_In		影像设备目录.设备号%Type,
    说明_In         影像报告原型清单.说明%Type,
    可否重置页面_In 影像报告原型清单.可否重置页面%Type,
    可否重置格式_In 影像报告原型清单.可否重置格式%Type,
	可否书写多份_In 影像报告原型清单.可否书写多份%Type,
    是否禁用_In     影像报告原型清单.是否禁用%Type,
    修改人_In       影像报告原型清单.修改人%Type,
    内容_In         影像报告原型清单.内容%Type,
    控制选项_In     影像报告原型清单.控制选项%Type,
	词句加载时机_In 影像报告原型清单.词句加载时机%Type,
	插件加载时机_In 影像报告原型清单.插件加载时机%Type,
    专用插件_In     影像报告原型清单.专用插件%Type,
    Copy_ID_In      影像报告原型清单.ID%Type,
    Only_Head_In    Varchar2,
    分组_In         影像报告原型清单.分组%Type
	) As
    x_Str     Xmltype;
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告原型清单 A
     Where (a.编码 = 编码_In Or a.名称 = 名称_In)
       And ID <> ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在相同的文档编码或者名称，请重新填写！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If Copy_ID_In Is Null or Copy_ID_In = 0 Then
      x_Str := 内容_In;
    Else
      Select Decode(Only_Head_In,
                    1,
                    Deletexml(a.内容, '/zlxml/document/node()'),
                    a.内容)
        Into x_Str
        From 影像报告原型清单 A
       Where a.id = Copy_ID_In;
    End If;
  
    Update 影像报告原型清单
       Set 种类         = 种类_In,
           编码         = 编码_In,
           名称         = 名称_In,
		   设备号		= 设备号_In,
           说明         = 说明_In,
           可否重置页面 = 可否重置页面_In,
           可否重置格式 = 可否重置格式_In,
		   可否书写多份 = 可否书写多份_In,
           是否禁用     = NVL(是否禁用_In, 是否禁用),
           修改人       = 修改人_In,
           修改时间     = sysdate,
           内容         = x_Str,
           控制选项     = 控制选项_In,
		   词句加载时机 =词句加载时机_In,
		   插件加载时机 =插件加载时机_In,
           专用插件     = 专用插件_In,
           分组         = 分组_In
     Where ID = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist;

  --5.删除一个文件原型
  Procedure p_Del_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(ID) Into n_Num From 影像报告记录 A Where a.原型id = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该原型已经被文档使用，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(原型ID)
      Into n_Num
      From 影像报告原型片段
     Where 影像报告原型片段.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该文档下存在词句关联，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(ID)
      Into n_Num
      From 影像报告范文清单
     Where 影像报告范文清单.原型ID = ID_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]存在以此原型建立的范文信息，不允许删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告原型清单 C Where c.Id = ID_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetypelist;

  --6.根据ID获取文件原型
  Procedure p_Get_Antetypelist_By_Id(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select rawtohex(a.ID) ID,
             a.种类,
             a.编码,
             a.名称,
			 a.设备号,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
			 a.可否书写多份,
             Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
             Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
             Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
             (Nvl(a.控制选项, XmlType('<NULL/>'))).GetClobVal() as 控制选项,
			 a.词句加载时机,
			 a.插件加载时机,
             a.是否禁用,
             (Nvl(a.专用插件, XmlType('<NULL/>'))).GetClobVal() as 专用插件,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             a.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_By_Id;

  --7.获取原型XML内容
  Procedure p_Get_Antetypelist_Content(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select (Nvl(a.内容, XmlType('<ZLXML/>'))).GetClobVal() As 内容
        From 影像报告原型清单 A
       Where a.Id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Content;

  --8.停用或启用文件原型
  Procedure p_Stop_Antetypelist(
    ID_In 影像报告原型清单.Id%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 是否禁用 = Decode(是否禁用, 1, 0, 0, 1)
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Stop_Antetypelist;

  --9.新增文档种类信息
  Procedure p_Add_Doc_Kind(
    编码_In 影像报告种类.编码%Type,
    名称_In 影像报告种类.名称%Type,
    说明_In 影像报告种类.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告种类 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 编码_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告种类
      (编码, 名称, 说明)
    Values
      (编码_In, 名称_In, 说明_In);
  
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Kind;

  --10.删除文档种类信息
  Procedure p_Del_Doc_Kind As
  Begin
    Delete From 影像报告种类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Kind;

  --11.获取预备提纲信息
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID, 编码, 名称, 说明, 最后编辑时间
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Pre_Outline;

  --12.添加预备提纲信息
  Procedure p_Add_Pre_Outline(
    ID_In   影像报告预备提纲.ID%Type,
    编码_In 影像报告预备提纲.编码%Type,
    名称_In 影像报告预备提纲.名称%Type,
    说明_In 影像报告预备提纲.说明%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(200);
    Err_Item Exception;
  Begin
    Select Count(a.编码)
      Into n_Num
      From 影像报告预备提纲 A
     Where a.编码 = 编码_In
        Or a.名称 = 名称_In;
  
    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能相同！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If 编码_In Is Null Or 名称_In Is Null Then
      v_Err_Msg := '[ZLSOFT]种类的编码或者名称不能为空！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Insert Into 影像报告预备提纲
      (ID, 编码, 名称, 说明, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, sysdate);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Pre_Outline;

  --13.删除预备提纲信息
  Procedure p_Del_Pre_Outline As
  Begin
    Delete From 影像报告预备提纲;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Pre_Outline;

  --14.获取导出的文档原型信息
  Procedure p_Output_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select '类别' As 类别,
             b.编码 As ID,
             Null As 种类,
             b.名称 As 种类名称,
             b.编码 As 编码,
             b.名称 As 名称,
             b.说明 As 说明,
             Null As 可否重置页面,
             Null As 可否重置格式,
             Null As 是否禁用,
             Null As 创建人,
             Null As 创建时间,
             Null As 修改人,
             Null As 修改时间,
             Null As 内容
        From 影像报告种类 B
      Union All
      Select '原型' 类别,
             RawToHex(a.Id) ID,
             a.种类,
             b.名称 种类名称,
             a.编码,
             a.名称,
             a.说明,
             a.可否重置页面,
             a.可否重置格式,
             a.是否禁用,
             a.创建人,
             a.创建时间,
             a.修改人,
             a.修改时间,
             Null As 内容
        From 影像报告原型清单 A, 影像报告种类 B
       Where a.种类 = b.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Output_Antetypelist;

  --15.添加原型片段
  Procedure p_Add_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type) As
  Begin
    Insert Into 影像报告原型片段
      (原型ID, 片段ID)
    Values
      (原型ID_In, 片段ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Antetype_Fragments;

  --16.删除原型片段
  Procedure p_Del_Antetype_Fragments(
    原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Delete From 影像报告原型片段 Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Antetype_Fragments;

  --17.获取原型片段
  Procedure p_Get_Antetype_Fragments(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments;

  --18.获取某个原型关联的某个片段分类
  Procedure p_Get_Antetype_f_Byaidfid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type,
	片段ID_In 影像报告原型片段.片段ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(片段ID) 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = 原型ID_In
         And a.片段ID = 片段ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_f_Byaidfid;

  --19.插入文档原型XML内容
  Procedure p_Edit_Antetypelist_Content(
    ID_In     影像报告原型清单.Id%Type,
	内容_In   影像报告原型清单.内容%Type,
	修改人_In 影像报告原型清单.修改人%Type
	) As
  Begin
    Update 影像报告原型清单
       Set 内容 = 内容_In, 修改人 = 修改人_In, 修改时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Antetypelist_Content;

  --20.获取所有原型
  Procedure p_Get_All_Antetype_Lists(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             编码 || '-' || 名称 As 名称,
             分组,
             a.种类,
             a.是否禁用,
             a.说明,
             Decode(a.是否禁用, 1, 2, 1) Imageindex,
             (Nvl(a.内容, XmlType('<ZLXML/>'))).GetClobVal() As 内容
        From 影像报告原型清单 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Antetype_Lists;

  --21.获取已经设置了关联的原型片段类别的信息
  Procedure p_Get_Antetype_Fragments_Info(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(ID) ID,
             a.编码,
             a.名称,
             a.编码 || '-' || a.名称 标题,
             a.说明
        From 影像报告片段清单 A
       Where a.Id In (Select b.片段id
                        From 影像报告原型片段 B
                       Where b.原型id = 原型ID_In)
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Fragments_Info;

  --22.获取选择的类别下面的短语名称
  Procedure p_Get_Selected_Fragments(
	Val           Out t_Refcur,
	原型ID_In Varchar2
	) As
    v_Sql  Varchar2(4000);
    v_Aids Varchar2(4000);
    v_Msg  Varchar2(4000);
    Err Exception;
  Begin
    For Myrow In (Select RawtoHex(a.片段id) ID
                    From 影像报告原型片段 A
                   Where a.原型id = 原型ID_In) Loop
      If v_Aids Is Null Then
        v_Aids := '''' || Myrow.Id || '''';
      Else
        v_Aids := v_Aids || ',''' || Myrow.Id || '''';
      End If;
    End Loop;
  
    If v_Aids Is Null Then
      If Substr(原型ID_In, 0, 1) <> '''' Then
        v_Aids := '''' || 原型ID_In || '''';
      Else
        v_Aids := 原型ID_In;
      End If;
    End If;
  
    v_Sql := 'Select Distinct  RawtoHex(a.id) ID,  RawtoHex(a.上级ID) 上级ID , a.编码, a.编码 || ''-'' || a.名称 标题,Decode(a.节点类型, 0, 0, 1) 节点类型
      From 影像报告片段清单 A
      Start With a.Id In (' || v_Aids || ')
      Connect By Prior a.Id = a.上级ID
      Order By a.编码';
  
    Open Val For v_Sql;
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Selected_Fragments;

  --23.获取能复制的原型名称
  Procedure p_Get_Copy_Antetype(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID, a.编码 || '-' || a.名称 标题
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Copy_Antetype;

  --24.获取原型的分组信息
  Procedure p_Get_Antetype_Category(
	Val           Out t_Refcur,
	种类_In 影像报告原型清单.种类%Type
	) As
  Begin
    Open Val For
      Select Distinct a.分组 As 分组
        From 影像报告原型清单 A
       Where a.种类 = 种类_In
         and a.分组 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Category;

  --25.根据原型同步范文提纲
  Procedure p_Synchronous_Sample(
    原型ID_In 影像报告原型清单.Id%Type
	) As
    x_Content Xmltype;
    x_Result  Xmltype;
    Cursor c_Antetype Is
      Select Extractvalue(c.Column_Value, '/section/@iid') Iid,
             Extractvalue(c.Column_Value, '/section/@title') Title,
             c.Column_Value As Content
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.内容, '/zlxml//section'))) C
       Where a.Id = 原型ID_In;
    n_i               Number;
    n_j               Number;
    n_Count           Number;
    x_Subdocuments    Xmltype;
    x_Docparameters   Xmltype;
    x_Antetypecontent Xmltype;
    v_Textstyleno     Varchar2(10);
    v_Parastyleno     Varchar2(10);
    x_Acontent        Xmltype;
  Begin
    For Mysample In (Select b.id, b.内容
                       From 影像报告范文清单 B
                      Where b.原型id = 原型ID_In) Loop
      x_Content := Mysample.内容;
      n_i       := 1;
      If x_Content Is Null Then
        Select a.内容
          Into x_Result
          From 影像报告原型清单 A
         Where a.Id = 原型ID_In;
      Else
        Begin
          Select Extractvalue(c.Column_Value, '/section/@textstyleno') Textstyleno,
                 Extractvalue(c.Column_Value, '/section/@parastyleno') Parastyleno
            Into v_Textstyleno, v_Parastyleno
            From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C
           Where Rownum = 1;
        Exception
          When Others Then
            v_Textstyleno := '1';
            v_Parastyleno := '1';
        End;
      
        For Myantetype In c_Antetype Loop
          For I In 1 .. 1 Loop
            If n_i <> 1 Or n_Count <> 0 Or n_Count Is Null Then
              Select Count(*)
                Into n_Count
                From Table(Xmlsequence(Extract(x_Content, '/zlxml//section'))) C;
            End If;
            If n_Count < n_i Then
              Select Updatexml(Myantetype.Content,
                               '//section/@textstyleno',
                               v_Textstyleno)
                Into x_Acontent
                From Dual;
              Select Updatexml(x_Acontent,
                               '//section/@parastyleno',
                               v_Parastyleno)
                Into x_Acontent
                From Dual;
              Select Appendchildxml(x_Content,
                                    '/zlxml/document',
                                    x_Acontent)
                Into x_Content
                From Dual;
              Exit;
            End If;
            n_j := 1;
            For Mysample In (Select Extractvalue(c.Column_Value,
                                                 '/section/@iid') Iid,
                                    Extractvalue(c.Column_Value,
                                                 '/section/@title') Title
                               From Table(Xmlsequence(Extract(x_Content,
                                                              '/zlxml//section'))) C) Loop
              If n_i = n_j Then
                If Myantetype.Iid <> Mysample.Iid Then
                  Select Updatexml(Myantetype.Content,
                                   '//section/@textstyleno',
                                   v_Textstyleno)
                    Into x_Acontent
                    From Dual;
                  Select Updatexml(x_Acontent,
                                   '//section/@parastyleno',
                                   v_Parastyleno)
                    Into x_Acontent
                    From Dual;
                  Select Deletexml(x_Content,
                                   '//section[@iid="' || Myantetype.Iid || '"]')
                    Into x_Content
                    From Dual;
                  Select Insertxmlbefore(x_Content,
                                         '//section[@iid="' || Mysample.Iid || '"]',
                                         x_Acontent)
                    Into x_Content
                    From Dual;
                  n_j := n_j + 1;
                  Exit;
                Else
                  n_j := n_j + 1;
                  Exit;
                End If;
              End If;
              n_j := n_j + 1;
            End Loop;
            n_i := n_i + 1;
          End Loop;
        End Loop;
        x_Result := x_Content;
        For Mysample2 In (Select Iid
                            From (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From Table(Xmlsequence(Extract(x_Content,
                                                                   '/zlxml//section'))) C) C
                           Where c.Iid Not In
                                 (Select Extractvalue(c.Column_Value,
                                                      '/section/@iid') Iid
                                    From 影像报告原型清单 A,
                                         Table(Xmlsequence(Extract(a.内容,
                                                                   '/zlxml//section'))) C
                                   Where a.Id = 原型ID_In)) Loop
          Select Deletexml(x_Result,
                           '//section[@iid="' || Mysample2.Iid || '"]')
            Into x_Result
            From Dual;
        End Loop;
      End If;
    
      Update 影像报告范文清单 X
         Set x.内容 = x_Result
       Where x.Id = Mysample.Id;
    End Loop;
  
    Select a.内容
      Into x_Antetypecontent
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
    Select Extract(x_Antetypecontent, 'zlxml/subdocuments')
      Into x_Subdocuments
      From Dual;
    Select Extract(x_Antetypecontent, 'zlxml/docparameters')
      Into x_Docparameters
      From Dual;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/subdocuments', x_Subdocuments)
     Where 原型ID = 原型ID_In;
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容, '/zlxml/docparameters', x_Docparameters)
     Where 原型ID = 原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Synchronous_Sample;

  --26.获取导出的原型列表
  Procedure p_Get_Out_Antetypelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID,
             编码,
             标题,
             Parentid,
             种类,
             是否禁用,
             说明,
             Imageindex,
             名称
        From (Select a.编码 As ID,
                     a.编码 As 编码,
                     a.名称 As 标题,
                     '' As Parentid,
                     '-1' As 种类,
                     0 As 是否禁用,
                     a.说明 As 说明,
                     4 As Imageindex,
                     a.名称 名称
                From 影像报告种类 A
              Union
              Select Distinct a.种类 || '-' || a.分组 As ID,
                              (Select Min(编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              Max(a.分组) As 名称,
                              a.种类 As Parentid,
                              '0' As 种类,
                              0 As 是否禁用,
                              '' As 说明,
                              4 As Imageindex,
                              a.分组
                From 影像报告原型清单 A
               Where a.分组 Is Not Null
               Group By a.种类, a.分组
              Union
              Select RawTohex(ID),
                     a.编码,
                     编码 || '-' || 名称 As 标题,
                     Decode(a.分组, Null, a.种类, a.种类 || '-' || a.分组) Parentid,
                     a.种类 As 种类,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 1, 0, 2),
                     a.名称
                From 影像报告原型清单 A) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Out_Antetypelist;

  --27.通过编码获取原型种类信息
  Procedure p_Get_Antetype_Kind_By_Code(
	Val           Out t_Refcur,
	编码_In 影像报告种类.编码%Type
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明
        From 影像报告种类 A
       Where a.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Kind_By_Code;
  --28.获取事件信息，不包含固定事件
  Procedure p_Get_Doc_Event(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawtoHex(a.id) ID,
             a.种类,
             a.原型id,
             a.编号,
             a.名称,
             a.说明,
             a.元素iid,
             a.扩展标记
        From 影像报告事件 A
       Where a.种类 <> 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event;

  --29.获取关于原型导出的重复信息
  Procedure p_Get_Antetypelist_Same_Info(
	Val           Out t_Refcur,
	Tablename_In Varchar2,
	ID_In        影像报告原型清单.Id%Type,
	编码_In      Varchar2,
	名称_In      Varchar2
	) As
    n_Num    Number;
    v_Result Varchar2(100);
    v_Sql    Varchar2(4000);
  Begin
    If ID_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where id=' ||
               ID_In;
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        v_Result := 'ID重复';
      End If;
    End If;
    If 编码_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 编码=''' ||
               编码_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',编码重复';
        Else
          v_Result := '编码重复';
        End If;
      End If;
    End If;
    If 名称_In Is Not Null Then
      v_Sql := 'select count(*) from ' || Tablename_In || ' where 名称=''' ||
               名称_In || '''';
      Execute Immediate v_Sql
        Into n_Num;
      If n_Num > 0 Then
        If v_Result Is Not Null Then
          v_Result := v_Result || ',名称重复';
        Else
          v_Result := '名称重复';
        End If;
      End If;
    End If;
    Open Val For
      Select v_Result Result From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetypelist_Same_Info;

  --30.获取事件重复的信息
  Procedure p_Event_Same_Info(
	Val           Out t_Refcur,
	ID_In      影像报告事件.Id%Type,
    原型ID_In  影像报告事件.原型ID%Type,
    元素IID_In 影像报告事件.元素IID%Type,
    种类_In    影像报告事件.种类%Type,
    名称_In    影像报告事件.名称%Type,
    编号_In    影像报告事件.编号%Type
	) As
    v_Same_Antetype Varchar2(50);
    n_Same_Id       Number;
    n_Same_Title    Number;
    n_Same_Seqnum   Number;
    n_Maxnum        Number;
  Begin
    Select Count(*)
      Into n_Same_Title
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.名称 = 名称_In;
    Select Count(*)
      Into n_Same_Seqnum
      From 影像报告事件 A
     Where a.原型ID = 原型ID_In
       And a.种类 = 种类_In
       And a.编号 = 编号_In;
    Begin
      Select a.Id
        Into v_Same_Antetype
        From 影像报告事件 A
       Where a.原型ID = 原型ID_In
         And a.元素IID = 元素IID_In;
    Exception
      When Others Then
        v_Same_Antetype := '';
    End;
  
    Select Count(*) Into n_Same_Id From 影像报告事件 A Where a.Id = ID_In;
    Select Max(a.编号) Into n_Maxnum From 影像报告事件 A;
  
    Open Val For
      Select v_Same_Antetype As Sameaid,
             n_Same_Id       As Sameid,
             n_Same_Title    As Sametitle,
             n_Same_Seqnum   As Sameseqnum,
             n_Maxnum        As Maxnum
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Event_Same_Info;

  --31.获取原型校验的类别集合
  Procedure p_Get_Process_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 动作类型
        From (Select Extractvalue(c.Column_Value, '/step/kind') As 动作类型
                From 影像报告动作 A,
                     Table(Xmlsequence(Extract(a.内容, '/root/step'))) C) B
       Where b.动作类型 Is Not Null;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Process_Kind;


  --33.获取指定原型的文档处理
  Procedure p_Get_Doc_Process_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In 影像报告动作.原型id%Type
	) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             (Nvl(p.内容, XmlType('<NULL/>'))).GetClobVal() As 内容, --Nvl(p.内容,'<NULL/>') As 内容,
             RawtoHex(p.事件ID) 事件ID,
             0 Is_Event
        From 影像报告动作 P
       Where p.原型ID = 原型ID_In
      Union All
      Select RawtoHex(e.id) ID,
             e.名称,
             e.种类,
             e.编号,
             e.说明,
             Null,
             (XmlType('<Null/>')).GetClobVal() As 内容, --(Null,'<NULL/>') As 内容,
             Null,
             1
        From 影像报告事件 E
       Where e.Id In (Select RawtoHex(事件ID) 事件ID
                        From 影像报告动作
                       Where 原型ID = 原型ID_In)
       Order By Is_Event, 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process_Of_Antetype;

  --34. 根据字典名称获取相应子项
  Procedure p_Get_Dictitems_By_Title(
	Val           Out t_Refcur,
	名称_In 影像字典清单.名称%Type
	) As
  Begin
    Open Val For
      Select a.编号, a.名称, Rawtohex(a.字典id) As 字典ID
        From 影像字典内容 A
       Where a.字典id In (Select id From 影像字典清单 b Where b.名称 = 名称_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Dictitems_By_Title;

  --35.获得所有的预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, a.编码, a.名称
        From 影像报告预备提纲 a
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Phr_Onlines;

  --36.获取所有词句信息
  Procedure p_Get_All_Fragment(
	Val           Out t_Refcur,
	学科_In Varchar2
	) As
  Begin
    If 学科_In <> '' Then
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Where (a.学科 In
               (Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(学科_In, ','))
                 Intersect
                 Select /*+rule*/
                  Column_Value As Lable
                   From Table(b_PACS_RptPublic.f_Str2list(a.学科, ','))) And
               a.节点类型 <> 0)
            Or a.节点类型 = 0
            Or a.学科 Is Null
         Order By a.编码, a.上级id;
    Else
      Open Val For
        Select RawToHex(a.id) ID,
               RawToHex(a.上级id) 上级id,
               a.编码,
               a.名称,
               a.说明,
               a.节点类型,
               (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
               a.学科,
               a.标签,
               a.是否私有,
               a.作者
          From 影像报告片段清单 A
         Order By a.上级id, a.节点类型, a.编码, a.名称;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment;

  --37. 获取词句信息
  Procedure p_Get_Fragment_Filter(
	Val           Out t_Refcur,
	原型id_In 影像报告原型片段.原型ID%Type,
    作者_In   影像报告片段清单.作者%Type,
    学科_In   影像报告片段清单.学科%Type,
    Type_In   Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(b.Id) ID,
               Rawtohex(b.上级id) 上级id,
               b.编码,
               b.名称,
               b.说明,
               b.节点类型,
               (Nvl(b.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
               b.学科,
               b.标签,
               b.是否私有,
               b.作者,
               b.最后编辑时间
          From 影像报告原型片段 A, 影像报告片段清单 B
         Where a.片段id = b.id
           And a.原型id = 原型id_In;
    Else
      Open Val For
        Select /*+ rule*/
         Rawtohex(b.Id) ID,
         Rawtohex(b.上级id) 上级id,
         b.编码,
         b.名称,
         b.说明,
         b.节点类型,
         (Nvl(b.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
         b.学科,
         b.标签,
         b.是否私有,
         b.作者,
         b.最后编辑时间
          From 影像报告片段清单 B
         Where b.上级id = 原型id_In
           And (b.是否私有 = 0 Or (b.是否私有 = 1 And b.作者 = 作者_In))
           And (b.学科 Is Null Or
               (b.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(b.学科, 学科_In) > 0));
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_Filter;

  --38.根据原型获取关联的片段标签值
  Procedure p_Get_Label_By_Aid(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select Distinct b.标签
        From 影像报告片段清单 B
       Start With b.上级id In (Select a.片段id
                               From 影像报告原型片段 A
                              Where a.原型id = 原型ID_In)
      Connect By Prior b.Id = b.上级id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Label_By_Aid;

  --39.获取所有词句分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) ID,
             Rawtohex(a.上级id) 上级id,
             a.编码,
             a.名称,
             a.说明,
             a.节点类型
        From 影像报告片段清单 A
       Where a.节点类型 = 0
       Start With 上级id Is Null
      Connect By Prior id = 上级id
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_All_Fragment_Class;

  --40.获取表名对应的最后编辑时间
  Procedure p_Get_Data_Last_Edit_Time(
	Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Data_Last_Edit_Time;

  --41.添加文档事件
  Procedure p_Add_Doc_Event(
    ID_In       影像报告事件.ID%Type,
    种类_In     影像报告事件.种类%Type,
    原型ID_In   影像报告事件.原型ID%Type,
    编号_In     影像报告事件.编号%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    n_Seq_Num  影像报告事件.编号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = 原型ID_In
       And 种类 = 种类_In
       And 名称 = 名称_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上已存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (编号_In Is Null Or 编号_In = 0) Then
      Select Nvl(Max(编号), 0) + 1 Into n_Seq_Num From 影像报告事件;
    Else
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where 原型ID = 原型ID_In
         And 种类 = 种类_In
         And 编号 = 编号_In;
      If n_Is_Exist > 0 Then
        v_Err_Msg := '[ZLSOFT]原型上已存在相同编号的事件[ZLSOFT]';
        Raise Err_Item;
      End If;
      n_Seq_Num := 编号_In;
    End If;
  
    Insert Into 影像报告事件
      (ID, 种类, 原型ID, 编号, 名称, 说明, 元素IID, 扩展标记)
    Values
      (ID_In,
       种类_In,
       原型ID_In,
       n_Seq_Num,
       名称_In,
       说明_In,
       元素IID_In,
       扩展标记_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Event;

  --42.修改文档事件
  Procedure p_Update_Doc_Event(
    Id_In       影像报告事件.Id%Type,
    种类_In     影像报告事件.种类%Type,
    名称_In     影像报告事件.名称%Type,
    说明_In     影像报告事件.说明%Type,
    元素IID_In  影像报告事件.元素IID%Type,
    扩展标记_In 影像报告事件.扩展标记%Type
	) As
    r_Aid      影像报告事件.原型ID%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告事件 Where ID = Id_In;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告事件
     Where 原型ID = r_Aid
       And 种类 = 种类_In
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Update 影像报告事件
       Set 种类     = 种类_In,
           名称     = 名称_In,
           说明     = 说明_In,
           元素IID  = 元素IID_In,
           扩展标记 = 扩展标记_In
     Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Event;

  --43.删除文档事件
  Procedure p_Delete_Doc_Event(
    Id_In 影像报告事件.Id%Type
	) As
    n_Kind     影像报告事件.种类%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select 种类 Into n_Kind From 影像报告事件 Where ID = Id_In;
  
    If n_Kind = 1 Then
      v_Err_Msg := '[ZLSOFT]不允许删除固定事件[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Select Count(*) Into n_Is_Exist From 影像报告动作 Where 事件ID = Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]事件已经被使用,不能被删除！[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    Delete From 影像报告事件 Where ID = Id_In;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Doc_Event;

  --44.删除所有未被使用的文档事件
  Procedure p_Delete_Unused_Doc_Events(
    Count_Out Out Number
	) As
  Begin
    Delete From 影像报告事件
     Where 种类 <> 1
       And ID Not In
           (Select 事件ID From 影像报告动作 Where 事件ID Is Not Null);
    Count_Out := Sql%RowCount;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Delete_Unused_Doc_Events;

  --45.获取指定原型的文档事件
  Procedure p_Get_Doc_Event_Of_Antetype(
	Val           Out t_Refcur,
	原型ID_In       影像报告事件.原型ID%Type,
	Include_Base_In Number
	) As
  Begin
    If Include_Base_In = 1 Then
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where (t.种类 = 1 Or t.原型id = 原型ID_In)
           And t.Id = p.事件ID(+)
         Order By t.编号;
    Else
      Open Val For
        Select Rawtohex(t.Id) ID,
               t.种类,
               t.名称,
               t.说明,
               t.元素iid,
               t.扩展标记,
               Nvl(p.Used_Count, 0) Used_Count
          From 影像报告事件 T,
               (Select Count(*) Used_Count, Max(事件ID) 事件ID
                  From 影像报告动作
                 Where 事件ID Is Not Null
                 Group By 事件ID) P
         Where t.原型id = 原型ID_In
           And t.种类 <> 1
           And t.Id = p.事件ID(+)
         Order By t.编号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Event_Of_Antetype;

  --46.修改文档处理编号
  Procedure p_Update_Doc_Process_Seqnum(
    Id_In   影像报告动作.Id%Type,
	序号_In 影像报告动作.序号%Type) As
  Begin
    Update 影像报告动作 Set 序号 = 序号_In Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process_Seqnum;

  --47.添加文档处理
  Procedure p_Add_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    原型ID_In       影像报告动作.原型ID%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    序号_In         影像报告动作.序号%Type,
    内容_In         影像报告动作.内容%Type
	) As
    n_Seq_Num  影像报告动作.序号%Type;
    n_Is_Exist Number(1) := 0;
    v_Err_Msg  Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = 原型ID_In
       And 名称 = 名称_In;
    If (序号_In Is Null Or 序号_In = 0) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = 原型ID_In
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 序号_In;
    End If;
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
    Insert Into 影像报告动作
      (ID, 原型ID, 事件ID, 动作类型, 名称, 说明, 可否手工执行, 序号, 内容)
    Values
      (Id_In,
       原型ID_In,
       事件ID_In,
       动作类型_In,
       名称_In,
       说明_In,
       可否手工执行_In,
       n_Seq_Num,
       内容_In);
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Add_Doc_Process;

  --48.修改文档处理
  Procedure p_Update_Doc_Process(
    Id_In           影像报告动作.Id%Type,
    事件ID_In       影像报告动作.事件ID%Type,
    动作类型_In     影像报告动作.动作类型%Type,
    名称_In         影像报告动作.名称%Type,
    说明_In         影像报告动作.说明%Type,
    可否手工执行_In 影像报告动作.可否手工执行%Type,
    内容_In         影像报告动作.内容%Type
	) As
    r_Aid          影像报告事件.原型ID%Type;
    r_Old_Event_Id 影像报告动作.事件ID%Type;
    n_Seq_Num      影像报告事件.编号%Type;
    n_Is_Exist     Number(1) := 0;
    v_Err_Msg      Varchar2(100);
    Err_Item Exception;
  Begin
    Select 原型ID Into r_Aid From 影像报告动作 Where ID = Id_In;
    If (事件ID_In Is Not Null) Then
      Select Count(*)
        Into n_Is_Exist
        From 影像报告事件
       Where (原型ID Is Null Or 原型ID = r_Aid)
         And ID = 事件ID_In;
    
      If n_Is_Exist = 0 Then
        v_Err_Msg := '[ZLSOFT]关联的事件不存在[ZLSOFT]';
        Raise Err_Item;
      End If;
    
    End If;
  
    Select Count(*)
      Into n_Is_Exist
      From 影像报告动作
     Where 原型ID = r_Aid
       And 名称 = 名称_In
       And ID <> Id_In;
  
    If n_Is_Exist > 0 Then
      v_Err_Msg := '[ZLSOFT]原型上存在相同命名的动作[ZLSOFT]';
      Raise Err_Item;
    End If;
  
    If (r_Old_Event_Id <> 事件ID_In Or
       (事件ID_In Is Null And r_Old_Event_Id Is Not Null)) Then
      If (事件ID_In Is Null) Then
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID Is Null;
      Else
        Select Nvl(Max(序号), 0) + 1
          Into n_Seq_Num
          From 影像报告动作
         Where 原型ID = r_Aid
           And 事件ID = 事件ID_In;
      End If;
    Else
      n_Seq_Num := 0;
    End If;
  
    If n_Seq_Num > 0 Then
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In,
             序号         = n_Seq_Num
       Where ID = Id_In;
    Else
      Update 影像报告动作
         Set 事件id       = 事件ID_In,
             动作类型     = 动作类型_In,
             名称         = 名称_In,
             说明         = 说明_In,
             可否手工执行 = 可否手工执行_In,
             内容         = 内容_In
       Where ID = Id_In;
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Doc_Process;

  --49.获取元素或者提纲的名称集合
  Procedure p_Get_Antetype_Ele_Section(
	Val           Out t_Refcur,
	原型ID_In 影像报告原型清单.Id%Type,
	Type_In   Varchar2
	) As
    c_Content Clob;
  Begin
    /*Select To_Clob(a.内容)*/
    Select a.内容.getclobval()
      Into c_Content
      From 影像报告原型清单 A
     Where a.Id = 原型ID_In;
  
    If Type_In = '1' Then
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/*/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '/zlxml/document//element[@sid and @title]|/zlxml/document//e_list[@sid and @title]|/zlxml/document//e_enum[@sid and @title]|/zlxml/document//e_etree[@sid and @title]|/zlxml/document//e_utree[@sid and @title]'))) C) A
         Where a.Name Is Not Null;
    Else
      Open Val For
        Select Distinct Name
          From (Select Extractvalue(c.Column_Value, '/section/@title') As Name
                  From Table(Xmlsequence(Extract(Xmltype(c_Content),
                                                 '//section'))) C) A
         Where a.Name Is Not Null;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Antetype_Ele_Section;

  --50.删除文档处理
  Procedure p_Del_Doc_Process(Id_In        影像报告动作.ID%Type,
                              Del_Event_In Number) As
    r_Event_Id   影像报告动作.事件ID%Type := Null;
    n_Event_Kind 影像报告事件.种类%Type;
    n_Is_Exist   Number(1) := 0;
  Begin
    If Del_Event_In = 1 Then
      Select Max(e.Id), Max(e.种类)
        Into r_Event_Id, n_Event_Kind
        From 影像报告动作 P, 影像报告事件 E
       Where p.Id = Id_In
         And p.事件id = e.Id;
    End If;
  
    Delete From 影像报告动作 Where ID = Id_In;
  
    If Del_Event_In = 1 Then
      If (r_Event_Id Is Not Null And n_Event_Kind <> 1) Then
        Select Count(*)
          Into n_Is_Exist
          From 影像报告动作
         Where 事件id = r_Event_Id;
        If n_Is_Exist = 0 Then
          Delete From 影像报告事件
           Where ID = r_Event_Id
             And 种类 <> 1;
        End If;
      End If;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Doc_Process;

  --51.查询元素值域类别的覆盖情况
  Procedure p_Get_Ele_Same_Info(
	Val           Out t_Refcur,
	Id_In    影像报告值域清单.Id%Type,
	Code_In  Varchar2,
	Title_In Varchar2,
	Flag_In  Varchar2
	) As
    v_Result  Varchar2(50);
    v_Id      Varchar2(50);
    v_Code_Id Varchar2(50);
    n_Num     Number;
  Begin
    If Flag_In = 1 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.Id = Id_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.编码 = Code_In;
    
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素分类 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素分类 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素分类 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 2 Then
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告元素清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告元素清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告元素清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    If Flag_In = 3 Then
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.Id = Id_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.Id = Id_In;
        If v_Id Is Not Null Then
          v_Result := 'ID重复';
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.编码 = Code_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Code_Id
          From 影像报告值域清单 A
         Where a.编码 = Code_In;
        If v_Code_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',编码重复';
          Else
            v_Result := '编码重复';
          End If;
        End If;
      End If;
    
      Select Count(ID)
        Into n_Num
        From 影像报告值域清单 A
       Where a.名称 = Title_In;
      If n_Num > 0 Then
        Select Rawtohex(a.Id)
          Into v_Id
          From 影像报告值域清单 A
         Where a.名称 = Title_In;
        If v_Id Is Not Null Then
          If v_Result Is Not Null Then
            v_Result := v_Result || ',名称重复';
          Else
            v_Result := '名称重复';
          End If;
        End If;
      End If;
    
    End If;
  
    Open Val For
      Select v_Result As Result, v_Id As ID, v_Code_Id As Codesameid
        From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Ele_Same_Info;

  --52.获得所有的插件信息
  Procedure p_Get_DocPluginList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             Decode(显示样式, '1', '嵌入式', '弹出式') 显示样式II,
             Decode(种类, '1', '专用插件', '共享插件') 种类II,
             类名,
             库名,
             是否禁用,
             Decode(是否禁用, '1', '停用', '启用') IsEnable
        From 影像报告插件;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocPluginList;

  --53.该ID的插件是否被原型使用过
  Procedure p_IsExit_DocPluginByID(
    Val           Out t_Refcur,
	ID_In Varchar2
	) As
    CURSOR C_EVENT Is
      Select t.专用插件.getclobval() 专用插件 From 影像报告原型清单 t;
    anum Int := 0;
    sult Varchar2(6666);
  Begin
    For temp In C_EVENT Loop
      If instr(temp.专用插件, ID_In) > 0 Then
        anum := anum + 1;
      End If;
    End Loop;
    Open Val For
      Select anum From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExit_DocPluginByID;

  --54.新增报告插件信息
  Procedure p_AddDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Insert Into 影像报告插件
      (ID, 编码, 名称, 说明, 显示样式, 种类, 类名, 库名, 是否禁用)
    Values
      (ID_In,
       编码_In,
       名称_In,
       说明_In,
       显示样式_In,
       种类_In,
       类名_In,
       库名_In,
       是否禁用_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddDocPlugin;

  --55.修改报告插件信息
  Procedure p_EditDocPlugin(
    ID_In       影像报告插件.ID%Type,
    编码_In     影像报告插件.编码%Type,
    名称_In     影像报告插件.名称%Type,
    说明_In     影像报告插件.说明%Type,
    显示样式_In 影像报告插件.显示样式%Type,
    种类_In     影像报告插件.种类%Type,
    类名_In     影像报告插件.类名%Type,
    库名_In     影像报告插件.库名%Type,
    是否禁用_In 影像报告插件.是否禁用%Type
	) As
  Begin
    Update 影像报告插件
       Set 编码     = 编码_In,
           名称     = 名称_In,
           说明     = 说明_In,
           显示样式 = 显示样式_In,
           种类     = 种类_In,
           类名     = 类名_In,
           库名     = 库名_In,
           是否禁用 = 是否禁用_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDocPlugin;

  --56.删除报告插件信息
  Procedure p_DelDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Delete From 影像报告插件 Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelDocPlugin;

  --57.改变插件的可用状态
  Procedure p_IsEnableDocPlugin(
    ID_In 影像报告插件.ID%Type
	) As
  Begin
    Update 影像报告插件 a
       Set 是否禁用 = Decode(a.是否禁用, 1, 0, 1)
     Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsEnableDocPlugin;

  --58.通过ID获得对应的插件信息
  Procedure p_GetDocPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocPluginByID;

  --59.判断编码和名称是否已存在
  Procedure p_IsExitDocPlugin(
	Val           Out t_Refcur,
	ID_In   影像报告插件.ID%Type,
	编码_In 影像报告插件.编码%Type,
	名称_In 影像报告插件.名称%Type
	) As
  Begin
    Open Val For
      Select Count(id)
        From 影像报告插件 a
       Where (a.编码 = 编码_In Or a.名称 = 名称_In)
         and a.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_IsExitDocPlugin;

  --60.通过ID获得对应的专用插件信息
  Procedure p_GetDocSpecPluginByID(
	Val           Out t_Refcur,
	ID_In 影像报告插件.ID%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(Id) ID,
             编码,
             名称,
             说明,
             显示样式,
             种类,
             类名,
             库名,
             是否禁用
        From 影像报告插件
       Where id = ID_In
         And 种类 = 1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDocSpecPluginByID;

  --61.获得诊疗列表信息
  Procedure p_GetDiagnosisList(
	Val           Out t_Refcur,
	类别_In Varchar2,
	条件_In Varchar2
	) As
  Begin
    Open Val For
      Select to_char(a.id) ID,
             a.编码,
             a.名称,
             (Select b.名称 From 诊疗项目类别 b Where b.编码 = a.类别) 类别
        From 诊疗项目目录 a
       Where (a.id In (Select t.诊疗项目id From 影像检查项目 t) And a.类别 = 类别_In)
         And (a.编码 Like 条件_In || '%' Or a.名称 Like 条件_In || '%');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisList;

  --62.获得诊疗类别列表
  Procedure p_GetDiagnosisClass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.编码, t.名称, t.简码 From 诊疗项目类别 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDiagnosisClass;

  --63.添加影像报告原型应用信息
  Procedure p_AddMedicalAntetype(
    诊疗项目ID_In 影像报告原型应用.诊疗项目ID%Type,
    应用场合_In   影像报告原型应用.应用场合%Type,
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Insert Into 影像报告原型应用
      (诊疗项目ID, 应用场合, 报告原型ID)
    Values
      (诊疗项目ID_In, 应用场合_In, 报告原型ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMedicalAntetype;

  --64.删除原型ID对应的病历单据应用信息
  Procedure p_DelMedicalAntetype(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告原型应用 Where 报告原型ID = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMedicalAntetype;

  --65.通过原型ID获得对应的病历单据应用信息
  Procedure p_GetMedicalByAID(
	Val           Out t_Refcur,
	报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Open Val For
      Select id,
             x.编码,
             x.名称,
             x.类别,
             Sum(x.门诊) 门诊,
             Sum(x.住院) 住院,
             Sum(x.外诊) 外诊,
             Sum(x.体检) 体检
        From (Select id,
                     编码,
                     名称,
                     类别,
                     Decode(应用场合, '1', 1, 0) as 门诊,
                     Decode(应用场合, '2', 1, 0) as 住院,
                     Decode(应用场合, '3', 1, 0) as 外诊,
                     Decode(应用场合, '4', 1, 0) as 体检
                From (Select to_Char(a.诊疗项目id) ID,
                             (Select b.编码
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 编码,
                             (Select b.名称
                                From 诊疗项目目录 b
                               Where b.id = a.诊疗项目id) as 名称,
                             (Select c.名称
                                From 诊疗项目类别 c
                               Where c.编码 = (Select b.类别
                                               From 诊疗项目目录 b
                                              Where b.id = a.诊疗项目id)) As 类别,
                             a.应用场合
                        From 影像报告原型应用 a
                       Where a.报告原型id = 报告原型ID_In)) x
       Group By x.id, x.编码, x.名称, x.类别;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMedicalByAID;

  --66.根据原型ID删除动作信息
  Procedure p_DelDocProcessByAid(
    报告原型ID_In 影像报告原型应用.报告原型ID%Type
	) As
  Begin
    Delete From 影像报告动作 t Where t.原型id = 报告原型ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;
  --67.获取ID对应的原型的树形结构
  Procedure p_GetAntetypeTreeByID(
	Val           Out t_Refcur,
	ID_In 影像报告原型清单.ID%Type
	) As
  Begin
    Open Val For
      Select ID, 编码, 名称, 标题, 分组, 是否禁用, 说明, Imageindex
        From (Select Distinct 分组 As ID,
                              (Select Min(b.编码)
                                 From 影像报告原型清单 B
                                Where b.分组 = a.分组) As 编码,
                              a.分组 As 名称,
                              a.分组 As 标题,
                              null As 分组,
                              0 As 是否禁用,
                              null As 说明,
                              0 As Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In
              Union
              Select RawtoHex(ID) ID,
                     a.编码,
                     a.名称 As 名称,
                     编码 || '-' || 名称 As 标题,
                     分组,
                     a.是否禁用,
                     a.说明,
                     Decode(a.是否禁用, 1, 2, 1) Imageindex
                From 影像报告原型清单 A
               Where a.id = ID_In) A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAntetypeTreeByID;

  --68.原型是否存在对应的编码或名称
  procedure p_IsExitAntetype(
	Val           Out t_Refcur,
	编码_In 影像报告原型清单.编码%Type,
	名称_In 影像报告原型清单.名称%Type,
	ID_In  影像报告原型清单.ID%Type
	) As
  begin
    Open Val For
      Select Count(*) AS num
        From 影像报告原型清单 t
       where (t.编码 = 编码_In
          or t.名称 = 名称_In) and t.id<>ID_In;
  End p_IsExitAntetype;

  --69. 获取影像存储设备
  Procedure p_GetStorageDevice(
	Val           Out t_Refcur
	) Is 
  Begin 
	Open Val For
		Select 设备号||' - '||设备名 As 存储设备, 设备号, IP地址, FTP目录, FTP用户名, FTP密码, 共享目录用户名, 共享目录密码, 共享目录  
		From 影像设备目录 Where 类型 = 1;
	Exception
	  When Others Then
	  Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStorageDevice;
End b_PACS_RptAntetype;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptCombo Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  --1.功  能：获得影像报告组句列表
  Procedure p_GetComboList(
    Val Out t_Refcur
	);
  --2.功  能：添加影像报告组句信息
  Procedure p_AddComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --3.功  能;修改影像报告组句信息
  Procedure p_EditComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --4.功  能：通过ID删除影像报告组句信息
  Procedure p_DelComboInfo(
    ID_In In 影像报告组句清单.ID%Type
	);
  --5.功  能：根据ID获得影像报告组句信息
  Procedure p_GetComboInfoByID(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	);
  --6.功  能：获得影像报告组句的所有分组信息
  Procedure p_GetComboAllGroup(
    Val Out t_Refcur
	);
  --7.功  能：获得ID对应的影像报告组句的短语信息
  Procedure p_GetComboContent(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	);
  --8.功  能：更新ID对应的影像报告组句的短语信息
  Procedure p_EditComboContent(
	ID_In   In 影像报告组句清单.ID%Type,
	组成_In Varchar2
	);
  --9.功 能：获取编辑人对应的最后修改影像报告组句信息
  Procedure p_GetComboInfoByEditor(
	Val           Out t_Refcur,
	编辑人_In In 影像报告组句清单.编辑人%Type
	);
  --10.功  能：新增片段到组合句
  Procedure p_Append_Fragment_Tocombo(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type
	);

  --11.功  能：修改片段到组合句
  Procedure p_Update_Combo_Fragment(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type,
    Pid_In  In Varchar2
	);
  --12.功  能：根据分类ID查询词句
  Procedure p_Get_Fragment_By_Typeid(
	Val           Out t_Refcur,
	Id_In In 影像报告组句清单.ID%Type
	);
  --13.功  能：获取下一个编码
  Procedure p_Get_ComboNextCode(
    Val Out t_Refcur
	);
end b_PACS_RptCombo;
/

--影像报告组句管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptCombo Is
  --Create By Hwei;
  --2014/11/25

  --1.功  能：获得影像报告组句列表
  Procedure p_GetComboList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             名称,
             说明,
             分组,
             多组,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             编辑人,
             最后编辑时间
        From 影像报告组句清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboList;

  --2.功  能：添加影像报告组句信息
  Procedure p_AddComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	) As
  Begin
    Insert Into 影像报告组句清单
      (ID, 编码, 名称, 说明, 分组, 多组, 组成, 编辑人, 最后编辑时间)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, 分组_In, 多组_In, 组成_In, 编辑人_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddComboInfo;

  --3.功  能;修改影像报告组句信息
  Procedure p_EditComboInfo(
    ID_In     In 影像报告组句清单.ID%Type,
    编码_In   In 影像报告组句清单.编码%Type,
    名称_In   In 影像报告组句清单.名称%Type,
    说明_In   In 影像报告组句清单.说明%Type,
    分组_In   In 影像报告组句清单.分组%Type,
    多组_In   In 影像报告组句清单.多组%Type,
    组成_In   In Varchar2,
    编辑人_In In 影像报告组句清单.编辑人%Type
	) As
  Begin
    Update 影像报告组句清单
       set 编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           分组         = 分组_In,
           多组         = 多组_In,
           组成         = 组成_In,
           编辑人       = 编辑人_In,
           最后编辑时间 = SysDate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditComboInfo;

  --4.功  能：通过ID删除影像报告组句信息
  Procedure p_DelComboInfo(
    ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Delete From 影像报告组句清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelComboInfo;

  --5.功  能：根据ID获得影像报告组句信息
  Procedure p_GetComboInfoByID(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             名称,
             说明,
             分组,
             多组,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             编辑人,
             最后编辑时间
        From 影像报告组句清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboInfoByID;

  --6.功  能：获得影像报告组句的所有分组信息
  Procedure p_GetComboAllGroup(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Distinct 分组 From 影像报告组句清单;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboAllGroup;

  --7.功  能：获得ID对应的影像报告组句的短语信息
  Procedure p_GetComboContent(
	Val           Out t_Refcur,
	ID_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成
        From 影像报告组句清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboContent;

  --8.功  能：更新ID对应的影像报告组句的短语信息
  Procedure p_EditComboContent(
    ID_In   In 影像报告组句清单.ID%Type,
    组成_In In Varchar2
	) As
  Begin
    Update 影像报告组句清单 Set 组成 = 组成_In Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditComboContent;

  --9.功 能：获取编辑人对应的最后修改影像报告组句信息
  Procedure p_GetComboInfoByEditor(
	Val           Out t_Refcur,
	编辑人_In In 影像报告组句清单.编辑人%Type
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 编辑人, 最后编辑时间
        From 影像报告组句清单 t1
       Where Not Exists (Select 1
                From 影像报告组句清单
               Where 最后编辑时间 > t1.最后编辑时间)
         And 编辑人 = 编辑人_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetComboInfoByEditor;

  --10.功  能：新增片段到组合句
  Procedure p_Append_Fragment_Tocombo(
    Text_In In XmlType,
	Id_In   In 影像报告组句清单.ID%Type
	) As
  Begin
    Update 影像报告组句清单 A
       Set a.组成 = Appendchildxml(a.组成, '/root', Text_In)
     Where a.ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Append_Fragment_Tocombo;

  --11.功  能：修改片段到组合句
  Procedure p_Update_Combo_Fragment(
    Text_In In XmlType,
    Id_In   In 影像报告组句清单.ID%Type,
    Pid_In  In Varchar2
	) As
  Begin
    Update 影像报告组句清单 A
       Set a.组成 = Updatexml(a.组成,
                            '/root/sentence[@sid="' || Pid_In || '"]',
                            Text_In)
     Where a.ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Update_Combo_Fragment;

  --12.功  能：根据分类ID查询词句
  Procedure p_Get_Fragment_By_Typeid(
	Val           Out t_Refcur,
	Id_In In 影像报告组句清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             上级id,
             编码,
             名称,
             说明,
             节点类型,
             (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             学科,
             标签,
             是否私有,
             作者,
			 (Nvl(a.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件, 
             最后编辑时间
        From 影像报告片段清单 A
       Where a.上级id = Id_In
         And a.节点类型 <> 0;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Fragment_By_Typeid;

  --13.功  能：获取下一个编码
  Procedure p_Get_ComboNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告组句清单') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ComboNextCode;
End b_PACS_RptCombo;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptCommon Is
  Type t_Refcur Is Ref Cursor;

  --获取预备提纲>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	);

  --元素分类>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Eleclass(
    Val Out t_Refcur
	);

  --原型片段>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --原型列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_By_Id(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);

  --原型内容>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_Content(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	);

  --范文清单>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Samplelist_By_Aid(
    Val           Out t_Refcur,
	Antetypelist_Id_In Varchar2,
	Condition_In       影像报告范文清单.名称%Type,
	Author_In          影像报告范文清单.作者%Type,
	Subjects_In        影像报告范文清单.学科%Type
	);

  --获取插件配置根据插件ID获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigById(
    Val           Out t_Refcur,
	Id_In 影像报告插件.ID%Type
	);

  --获取插件配置根据原型清单获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigByAId(
    Val           Out t_Refcur,
	Aid_In 影像报告原型清单.ID%Type
	);

  --获取元素>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Element(
    Val Out t_Refcur
	);

  --获取片段列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	);

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Range_List(
    Val Out t_Refcur
	);

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Combo_List(
    Val Out t_Refcur
	);

  --获取原型片段根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentDirectory_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --根据原型id获取片段数据
  Procedure p_Get_FragmentData_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	);

  --获取数据表的最后更新时间>>>>>>>>>>>>>>>>>>>>>>>>>>>
  procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
	Table_Name_In Varchar2
	);

  --获取片段列表根据上级ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Bypid(
    Val           Out t_Refcur,
	Pid_In 影像报告片段清单.上级ID%Type
	);

  --获取片段列表根据节点类型>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Byleaf(
    Val           Out t_Refcur,
	Leaf_In 影像报告片段清单.节点类型%Type
	);

  --获取值域信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Range_List_Byid(
    Val           Out t_Refcur,
	Id_In 影像报告值域清单.Id%Type
	);

  --根据元素ID获取值域ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Getelementrid_By_Eid(
    Val           Out t_Refcur,
	Eid_In 影像报告元素清单.Id%Type
	);

  --获取计量单位列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_GetMasure_UnitList(
    Val Out t_Refcur
	);

  --获取文档种类信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Doc_Kind(
    Val Out t_Refcur
	);

  --功能：获取所有学科信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Subjects(
    Val Out t_Refcur
	);

  --查看是否存在相应的编码或者名称(用于导入导出)>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exits_Doc_Kinds(
    Val           Out t_Refcur,
	编码_In      Varchar2,
	名称_In      Varchar2,
	Tablename_In Varchar2
	);

  --是否存在相同的ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exist_Id(
    Val           Out t_Refcur,
	Id_In        Number,
	Tablename_In Varchar2
	);

  --通过名称获取ID信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Id_By_Title(
    Val           Out t_Refcur,
	名称_In      Varchar2,
	Tablename_In Varchar2,
	Type_In      Varchar2
	);

  --通过简称片段清单
  procedure p_Get_FragmentSampleName(
    Val           Out t_Refcur,
	简称_In Varchar2
	);

  --更新ID对应的片段内容
  procedure p_Update_PhraseContent(
    Id_In      影像报告片段清单.ID%type,
	Name_In		影像报告片段清单.名称%Type,
	Content_In Varchar2
	);
  --获取原型ID对应的第一层片段节点
  procedure p_Get_FragmentData_LevelOne(
    Val           Out t_Refcur,
	AId_In 影像报告原型清单.ID%type
	);

  -- 获取片段的下层节点
  procedure p_GetFragmentDataListByFID(
    Val           Out t_Refcur,
	FId_In 影像报告片段清单.ID%type
	);
end b_PACS_RptCommon;
/



--*************************************************************************************
--*                  影像报告原型管理(---实现部分---)                                                        *
--*************************************************************************************
CREATE OR REPLACE Package Body b_PACS_RptCommon Is
  -- 功    能：该方法只用于演示...

  --获取预备提纲>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Pre_Outline(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) As ID, a.编码, a.名称, a.说明
        From 影像报告预备提纲 A
       Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --元素分类>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Eleclass(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(A.ID) As ID,
             A.编码,
             A.名称,
             A.说明,
             RawToHex(A.上级ID) 上级ID
        From 影像报告元素分类 A
       Order By 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型片段>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetype_Fragments(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(A.片段ID) As 片段ID
        From 影像报告原型片段 A
       Where a.原型ID = Aid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型清单>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_By_Id(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select /*+rule*/
       RawToHex(A.ID) As ID,
       a.种类,
       a.编码,
       a.名称,
       a.说明,
       a.可否重置页面 As 页面重置,
       a.可否重置格式 As 格式重置,
       Extractvalue(b.Column_Value, '/root/print_hf_mode') Printhfmode,
       Extractvalue(b.Column_Value, '/root/print_follow_pages') Printfollowpages,
       Nvl(Extractvalue(b.Column_Value, '/root/print_limit'), 0) Printlimit,
       (Nvl(a.控制选项, XmlType('<NULL/>'))).GetClobVal() As 控制选项,
       a.创建人,
       a.创建时间,
       a.修改人,
       a.修改时间,
       a.是否禁用,
       A.分组
        From 影像报告原型清单 A,
             Table(Xmlsequence(Extract(a.控制选项, '/root'))) B
       Where a.Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --原型内容>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Antetypelist_Content(
    Val           Out t_Refcur,
	Id_In 影像报告原型清单.Id%Type
	) As
  Begin
    Open Val For
      Select (Nvl(a.内容, XmlType('<ZLXML/>'))).GetClobVal() As 内容
        From 影像报告原型清单 A
       Where a.Id = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过原型ID获得相应的范文信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Samplelist_By_Aid(
    Val           Out t_Refcur,
	Antetypelist_Id_In Varchar2,
	Condition_In       影像报告范文清单.名称%Type,
	Author_In          影像报告范文清单.作者%Type,
	Subjects_In        影像报告范文清单.学科%Type
	) As
  Begin
    --直接获取该原型下的范文列表
    If Length(Antetypelist_Id_In) > 30 Then
      Open Val For
        Select /*+rule*/
         RawToHex(A.ID) as ID,
         a.名称,
         a.作者,
         a.说明,
         a.学科,
         a.编号,
         a.标签,
         a.是否私有
          From 影像报告范文清单 A
         Where a.原型ID = Hextoraw(Antetypelist_Id_In)
           And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
               Subjects_In Is Null Or
               (a.学科 Is Not Null And
               b_PACS_RptPublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
               a.是否私有 = 0));
    Else
      --获得一个存在原型信息的范文树形结构
      Open Val For
        Select Distinct a.分组 As ID,
                        a.分组 As 名称,
                        '' as 说明,
                        '' As 原型ID,
                        'category' As 类型,
                        '' As 作者,
                        '' As 学科,
                        Null as 最后编辑时间,
                        '' As 标签,
                        0 As 是否私有,
                        0 As Imgindex
          From 影像报告原型清单 A
         Where a.种类 = Antetypelist_Id_In
           And Exists
         (Select ID From 影像报告范文清单 C Where c.原型ID = a.Id)
           And a.分组 Is Not Null
        Union
        Select m.*
          From (Select RawToHex(B.ID) As ID,
                       b.名称,
                       b.说明,
                       b.分组 As 原型ID,
                       'antetype' As 类型,
                       '' As 作者,
                       '' As 学科,
                       Null as 最后编辑时间,
                       '' As 标签,
                       0 As 是否私有,
                       0 As Imgindex
                  From 影像报告原型清单 B
                 Where b.种类 = Antetypelist_Id_In
                   And Exists (Select ID
                          From 影像报告范文清单 C
                         Where c.原型ID = b.Id)
                 Order By b.编码) M
        
        Union All
        Select n.*
          From (Select /*+rule*/
                 RawToHex(A.ID) As ID,
                 a.名称,
                 a.说明,
                 RawToHex(A.原型ID) As 原型ID,
                 'sample' As 类型,
                 a.作者,
                 a.学科,
                 a.最后编辑时间,
                 a.标签,
                 a.是否私有,
                 Decode(a.是否私有, 1, 2, 1) As Imgindex
                  From 影像报告范文清单 A, 影像报告原型清单 C
                 Where a.原型ID = c.Id
                   And c.种类 = Antetypelist_Id_In
                   And ((a.名称 Like '%' || Condition_In || '%' And
                       Condition_In Is Not Null) Or Condition_In Is Null)
                   And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
                       Subjects_In Is Null Or
                       (a.学科 Is Not Null And
                       b_PACS_RptPublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
                       a.是否私有 = 0))
                 Order By a.编号, a.名称) N;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取插件配置根据插件ID获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigById(
    Val           Out t_Refcur,
	Id_In 影像报告插件.ID%Type
	) As
    v_Sql Varchar2(1000);
  Begin
    If (Id_In Is Not Null) Then
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式  From 影像报告插件 T Where t.Id =:Id_In And Rownum = 1';
      
        Open Val For v_Sql
          Using Id_In;
      End;
    Else
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 From 影像报告插件 T where 是否禁用 = 0 order by t.编码';
      
        Open Val For v_Sql;
      End;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取插件配置根据原型清单获取>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Plugin_ConfigByAId(
    Val           Out t_Refcur,
	Aid_In 影像报告原型清单.ID%Type
	) As
    v_Sql Varchar2(1000);
  Begin
    If (Aid_In Is Not Null) Then
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 ' ||
                 ' From 影像报告插件 T ' || ' Where t.Id in ( ' ||
                 ' Select X.pluginid from 影像报告原型清单 K, ' ||
                 '  (XMLTable(''*//pluginid''  Passing K.专用插件 Columns pluginid varchar2(32) Path ''/pluginid''))  X ' ||
                 ' Where K.id=:Aid_In) And 是否禁用 = 0' || ' Union All ' ||
                 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 ' ||
                 ' From 影像报告插件 T ' || ' Where 是否禁用 = 0 And t.种类=0 ';
      
        Open Val For v_Sql
          Using Aid_In;
      End;
    Else
      Begin
        v_Sql := 'Select RawToHex(T.ID) as ID, t.编码, t.说明, t.名称, t.类名, t.库名, t.是否禁用,t.种类,T.显示样式 From 影像报告插件 T where 是否禁用 = 0 order by t.编码';
      
        Open Val For v_Sql;
      End;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取所有元素>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Element(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) as ID,
             RawToHex(T.分类ID) as 分类ID,
             T.编码,
             T.名称,
             T.前缀,
             T.后缀,
             T.说明,
             T.数据类型,
             T.数值形态,
             T.最小长度,
             T.最大长度,
             T.最小小数位,
             T.最大小数位,
             T.计量单位,
             (Nvl(T.扩展描述, XmlType('<NULL/>'))).GetClobVal() As 扩展描述,
             T.值域ID,
             T.值域种类
        From 影像报告元素清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取片段列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             t.编码,
             t.名称,
             t.说明,
             t.节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             t.学科,
             t.标签,
             t.是否私有,
             t.作者,
             t.最后编辑时间,
			 (Nvl(t.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件
        From 影像报告片段清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取值域列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Range_List(
    Val Out t_Refcur
	) as
  begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.分类ID) As 分类ID,
             T.编码,
             T.名称,
             T.说明,
             T.数据类型,
             T.值域种类,
             (Nvl(t.值域描述, XmlType('<NULL/>'))).GetClobVal() As 值域描述,
             t.最后编辑时间
        From 影像报告值域清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end;

  --获取组句列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Combo_List(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             T.编码,
             T.名称,
             T.说明,
             T.多组,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             T.编辑人,
             T.最后编辑时间,
             T.分组
        From 影像报告组句清单 T;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取原型片段目录根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentDirectory_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      Select 名称,
             RawToHex(ID) As ID,
             4 as ImageIndex,
             RawToHex(上级ID) As 上级ID,
             '<NULL/>' As 组成,
             编码,
             节点类型,
             是否私有,
             作者,
             标签,
			 说明,
             学科
        From 影像报告片段清单
       Where ID In (Select ID
                      From 影像报告片段清单
                     Start With ID In (Select 片段ID
                                         From 影像报告原型片段
                                        Where 原型ID = Aid_In)
                    Connect By Prior 上级ID = ID)
       order by 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取原型片段数据根据原型ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_FragmentData_ByAid(
    Val           Out t_Refcur,
	Aid_In 影像报告原型片段.原型ID%Type
	) As
  Begin
    Open Val For
      With TabFragmentId As
       (Select 片段ID From 影像报告原型片段 Where 原型ID = Aid_In)
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间,
             EXTRACTValue( 适应条件, '/Root/Rad') 项目,
             EXTRACTValue( 适应条件, '/Root/Part') 部位, 
             EXTRACTValue( 适应条件, '/Root/Kind') 类别,
             EXTRACTValue( 适应条件, '/Root/Sex') 性别,
             0 as 提纲状态,
             0 as 适应状态
        From 影像报告片段清单 t
       Where Id Not In (Select 片段ID From TabFragmentId)
       Start With ID In (Select 片段ID From TabFragmentId)
      Connect By Prior 上级ID = ID
      Union All
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间,
             EXTRACTValue( 适应条件, '/Root/Rad') 项目,
             EXTRACTValue( 适应条件, '/Root/Part') 部位, 
             EXTRACTValue( 适应条件, '/Root/Kind') 类别,
             EXTRACTValue( 适应条件, '/Root/Sex') 性别,
             0 as 提纲状态,
             0 as 适应状态
        From 影像报告片段清单 t
       Start With ID In (Select 片段ID From TabFragmentId)
      Connect By Prior ID = 上级ID
       order by 编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取数据表的最后更新时间>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
	Table_Name_In Varchar2
	) As
    v_sql Varchar2(4000);
  Begin
    v_sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open val For v_sql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取片段列表根据上级ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Bypid(
    Val           Out t_Refcur,
	Pid_In 影像报告片段清单.上级ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             T.编码,
             T.名称,
             T.说明,
             T.节点类型,
             (Nvl(T.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             T.学科,
             T.标签,
             T.是否私有,
             T.作者,
			 (Nvl(T.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件,
             T.最后编辑时间
        From 影像报告片段清单 T
       Where T.上级ID = Pid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过节点类型获取词句列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Fragment_List_Byleaf(
    Val           Out t_Refcur,
	Leaf_In 影像报告片段清单.节点类型%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             T.编码,
             T.名称,
             T.说明,
             T.节点类型,
             (Nvl(T.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             T.学科,
             T.标签,
             T.是否私有,
             T.作者,
             T.最后编辑时间
        From 影像报告片段清单 T
       Where t.节点类型 = Leaf_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取值域信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Range_List_Byid(
    Val           Out t_Refcur,
	Id_In 影像报告值域清单.Id%Type
	) As
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.分类ID) As 分类ID,
             T.编码,
             T.名称,
             T.说明,
             T.数据类型,
             T.值域种类,
             (Nvl(T.值域描述, XmlType('<NULL/>'))).GetClobVal() As 值域描述
        From 影像报告值域清单 T
       Where ID = Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --根据元素ID获取值域ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Getelementrid_By_Eid(
    Val           Out t_Refcur,
	Eid_In 影像报告元素清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(A.值域ID) As 值域ID
        From 影像报告元素清单 A
       Where a.Id = Eid_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --获取计量单位列表>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_GetMasure_UnitList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 编码, 名称, 说明, 前缀 From 影像报告计量单位;
  End p_GetMasure_UnitList;

  --获取文档种类信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Doc_Kind(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select a.编码, a.名称, a.说明 From 影像报告种类 A Order By a.编码;
  End;

  --功能：获取所有学科信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_All_Subjects(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select rawtohex(b.字典id) ID, b.编号 As 编码, b.名称, b.简码, b.说明
        From 影像字典清单 A, 影像字典内容 B
       Where a.名称 = '专业学科'
         And a.Id = b.字典id
       Order By 编码;
  End;

  --查看是否存在相应的编码或者名称(用于导入导出)>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exits_Doc_Kinds(
    Val           Out t_Refcur,
	编码_In      Varchar2,
	名称_In      Varchar2,
	Tablename_In Varchar2
	) As
    v_Type Varchar2(50);
    n_Num  Number;
    v_Sql  Varchar2(100);
  Begin
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' AND 名称 =''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '1';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 <>''' ||
             编码_In || ''' AND 名称 = ''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '2';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' or 名称 =''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num = 0 Then
      v_Type := '3';
    End If;
    v_Sql := 'SELECT COUNT(*) FROM ' || Tablename_In || ' WHERE 编码 =''' ||
             编码_In || ''' AND 名称 <>''' || 名称_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    If n_Num > 0 Then
      v_Type := '4';
    End If;
    Open Val For
      Select v_Type As Type From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --是否存在相同的ID>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_If_Exist_Id(
    Val           Out t_Refcur,
	Id_In        Number,
	Tablename_In Varchar2
	) As
    v_Sql Varchar2(100);
    n_Num Number;
  Begin
    v_Sql := 'select count(id) from ' || Tablename_In || ' where id=''' ||
             Id_In || '''';
    Execute Immediate v_Sql
      Into n_Num;
    Open Val For
      Select Decode(n_Num, 0, 0, 1) Num From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过名称获取ID信息>>>>>>>>>>>>>>>>>>>>>>>>>>>
  Procedure p_Get_Id_By_Title(
    Val           Out t_Refcur,
	名称_In      Varchar2,
	Tablename_In Varchar2,
	Type_In      Varchar2
	) As
    v_Id  Varchar2(50);
    v_Sql Varchar2(100);
  Begin
    If Type_In = '1' Then
      v_Sql := 'select id from ' || Tablename_In || ' where 名称=''' || 名称_In || '''';
    Else
      v_Sql := 'select 编码 from ' || Tablename_In || ' where 名称=''' || 名称_In || '''';
    End If;
    v_Id := '';
    Execute Immediate v_Sql
      Into v_Id;
    Open Val For
      Select v_Id ID From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --通过简称片段清单
  Procedure p_Get_FragmentSampleName(
	Val           Out t_Refcur,
	简称_In Varchar2
	) as
  Begin
    Open Val For
      Select RawToHex(T.ID) As ID,
             RawToHex(T.上级ID) As 上级ID,
             t.编码,
             t.名称,
             t.说明,
             t.节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             t.学科,
             t.标签,
             t.是否私有,
             t.作者,
             t.最后编辑时间
        From 影像报告片段清单 T
      Where t.名称 LIKE '%' || 简称_In || '%';
      --Where  F_TRANS_PINYIN_CAPITAL(t.名称) LIKE '%' || 简称_In || '%';
  End p_Get_FragmentSampleName;

  --更新ID对应的片段内容
  Procedure p_Update_PhraseContent(
	Id_In      影像报告片段清单.ID%Type,
	Name_In		影像报告片段清单.名称%Type,
	Content_In Varchar2
	) as
  Begin
    Update 影像报告片段清单 t 
	Set t.组成 = Content_In, t.名称=Name_In 
	Where t.id = Id_In;
  End p_Update_PhraseContent;

  --获取原型ID对应的第一层片段节点
  Procedure p_Get_FragmentData_LevelOne(
	Val           Out t_Refcur,
	AId_In 影像报告原型清单.ID%Type
	) as
  Begin
    Open Val For
      With TabFragmentId As
       (Select 片段ID From 影像报告原型片段 Where 原型ID = Aid_In)
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单 t
       Where Id In (Select 片段ID From TabFragmentId);
  
  End p_Get_FragmentData_LevelOne;

  -- 获取片段的下层节点
  Procedure p_GetFragmentDataListByFID(
	Val           Out t_Refcur,
	FId_In 影像报告片段清单.ID%Type
	) as
  Begin
    Open Val For
      Select RawToHex(ID) As ID,
             RawToHex(上级ID) As 上级ID,
             编码,
             名称,
             说明,
             节点类型,
             (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成,
             学科,
             标签,
             是否私有,
             作者,
             最后编辑时间
        From 影像报告片段清单 t
       Where 上级ID = FId_In;
  End p_GetFragmentDataListByFID;

End b_PACS_RptCommon;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptElement Is
  --Create By Hwei;
  --2014/11/25
  Type t_Refcur Is Ref Cursor;

  Procedure p_GetElementClassList(
    Val Out t_Refcur
	);

  --2.功  能：新增影像报告元素分类信息
  Procedure p_AddElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	);

  --3.功  能：修改影像报告元素分类信息
  Procedure p_EditElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	);

  --4.功  能：删除影像报告元素分类信息
  Procedure p_DelelEmentClass(
    ID_In In 影像报告元素分类.ID%Type
	);

  --5.功  能：获得分类对应的影像报告值域信息列表
  Procedure p_GetRangeByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告值域清单.分类ID%Type
	);

  --6.功  能：获得ID对应的影像报告值域信息
  Procedure p_GetRangeByID(
    Val           Out t_Refcur,
	ID_In In 影像报告值域清单.ID%Type
	);

  --7.功  能：新增影像报告值域信息
  Procedure p_AddRange(
    ID_In          In 影像报告值域清单.ID%Type,
	分类ID_In    In 影像报告值域清单.分类ID%Type,
	编码_In       In 影像报告值域清单.编码%Type,
	名称_In       In 影像报告值域清单.名称%Type,
	说明_In       In 影像报告值域清单.说明%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	值域描述_In In Varchar2);

  --8.功  能：修改影像报告值域信息
  Procedure p_EditRange(
    ID_In         In 影像报告值域清单.ID%Type,
	分类ID_In   In 影像报告值域清单.分类ID%Type,
	编码_In       In 影像报告值域清单.编码%Type,
	名称_In       In 影像报告值域清单.名称%Type,
	说明_In       In 影像报告值域清单.说明%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	值域描述_In In Varchar2
	);

  --9.功  能：删除影像报告值域信息
  Procedure p_DelRange(
    ID_In In 影像报告值域清单.ID%Type
	);

  --10.功  能：获得分类对应的影像报告元素列表
  Procedure p_GetElementByClass(
    Val           Out t_Refcur,
    分类ID_In In 影像报告元素清单.分类ID%Type
	);

  --11.功  能：获得ID对应的影像报告元素信息
  Procedure p_GetElementByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素清单.ID%Type
	);

  --12.功 能：新增影像报告元素信息
  Procedure p_AddElement(
    ID_In           In 影像报告元素清单.ID%Type,
	分类ID_In     In 影像报告元素清单.分类ID%Type,
	编码_In         In 影像报告元素清单.编码%Type,
	名称_In         In 影像报告元素清单.名称%Type,
	说明_In         In 影像报告元素清单.说明%Type,
	前缀_In         In 影像报告元素清单.前缀%Type,
	后缀_In         In 影像报告元素清单.后缀%Type,
	数据类型_In   In 影像报告元素清单.数据类型%Type,
	数值形态_In   In 影像报告元素清单.数值形态%Type,
	最小长度_In   In 影像报告元素清单.最小长度%Type,
	最大长度_In   In 影像报告元素清单.最大长度%Type,
	最小小数位_In In 影像报告元素清单.最小小数位%Type,
	最大小数位_In In 影像报告元素清单.最大小数位%Type,
	计量单位_In   In 影像报告元素清单.计量单位%Type,
	扩展描述_In   In Varchar2,
	值域ID_In      In 影像报告元素清单.值域ID%Type,
	值域种类_In   In 影像报告元素清单.值域种类%Type
	);

  --13.功 能：修改影像报告元素信息
  Procedure p_EditElement(
    ID_In         In 影像报告元素清单.ID%Type,
	分类ID_In     In 影像报告元素清单.分类ID%Type,
	编码_In       In 影像报告元素清单.编码%Type,
	名称_In       In 影像报告元素清单.名称%Type,
	前缀_In       In 影像报告元素清单.前缀%Type,
    后缀_In       In 影像报告元素清单.后缀%Type,
    说明_In       In 影像报告元素清单.说明%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In   In 影像报告元素清单.计量单位%Type,
    扩展描述_In   In Varchar2,
    值域ID_In     In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	);

  --14.功 能：删除影像报告元素信息
  Procedure p_DelElement(
    ID_In 影像报告元素清单.ID%Type
	);

  --15.功 能：通过ID获取影像报告分类信息
  Procedure p_GetElementClassByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素分类.ID%Type
	);
  --16.功  能：获取元素的下一个编码
  Procedure p_Get_ElementNextCode(
    Val Out t_Refcur
	);
  --17.功  能：获取元素分类的下一个编码
  Procedure p_Get_ElementClassNextCode(
    Val Out t_Refcur
	);
  --18.功  能：获取对应的值域类型所在的元素类别
  Procedure p_Get_ElementClassByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	);
  --19.功  能：获取值域类型对应的值域信息
  Procedure p_Get_RangeByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	);
  --20.功  能：获取对应的值域类型和数据类型所在的元素类别
  Procedure p_Get_ElementClassByKindType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	);
  --21.功  能：获取值域类型和数据类型对应的值域信息
  Procedure p_Get_RangeByKindAndType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	);
  --22.功 能：获取最后修改影像报告元素分类信息
  Procedure p_GetElementClassLastID(
    Val Out t_Refcur
	);
  --23.功 能：获取编辑人对应的最后修改影像报告元素信息ID
  Procedure p_GetElementLastID(
    Val Out t_Refcur
	);
  --24.功 能：获取最后修改影像报告值域信息ID
  Procedure p_GetRangeLastID(
    Val Out t_Refcur
	);
  --25.功 能：添加计量单位信息
  Procedure p_AddMasure_Unit(
    编码_In 影像报告计量单位.编码%Type,
    名称_In 影像报告计量单位.名称%Type,
    说明_In 影像报告计量单位.说明%Type,
    前缀_In 影像报告计量单位.前缀%Type
	);
  --26.功  能：修改计量单位
  Procedure p_EditMasure_Unit(
    原编码_In 影像报告计量单位.编码%Type,
    编码_In   影像报告计量单位.编码%Type,
    名称_In   影像报告计量单位.名称%Type,
    说明_In   影像报告计量单位.说明%Type,
    前缀_In   影像报告计量单位.前缀%Type
	);
  --27.功  能：删除计量单位
  Procedure p_DelMasure_Unit(
    编码_In 影像报告计量单位.编码%Type
	);
  --28.功  能：判断计量单位的编码是否已存在
  Procedure p_If_Exist_Masure_Unit(
    Val           Out t_Refcur,
	编码_In 影像报告计量单位.编码%Type
	);
  --29.功  能： 判断元素编码是否已存在
  Procedure p_If_Exist_ElementCode(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	编码_In 影像报告元素清单.编码%Type
	);
  --30.功  能： 判断元素名称是否已存在
  Procedure p_If_Exist_ElementName(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	名称_In 影像报告元素清单.名称%Type
	);
  --31.功  能： 判断值域编码是否已存在
  Procedure p_If_Exist_RangeCode(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	编码_In 影像报告值域清单.编码%Type
	);
  --32.功  能： 判断值域标题是否已存在
  Procedure p_If_Exist_RangeName(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	名称_In 影像报告值域清单.名称%Type
	);
  --33.获得元素列表
  Procedure p_GetElementList(
    Val Out t_Refcur
	);
  --34.获得值域列表
  Procedure p_GetRangeList(
    Val Out t_Refcur
	);
  --35.判断元素分类的标题和编码是否存在
  Procedure p_If_Exist_ElementClass(
    Val           Out t_Refcur,
	ID_In   影像报告元素分类.ID%Type,
	编码_In 影像报告元素分类.编码%Type,
	名称_In 影像报告元素分类.名称%Type
	) ;
    --36.判断该元素分类下面是否有值域或者元素
  Procedure p_Is_CanDel_ElementClass(
    Val           Out t_Refcur,
	ID_In 影像报告元素分类.ID%Type
	);
End b_PACS_RptElement;
/

	--影像报告元素值域(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptElement Is

  --1.功   能：获取全部的影像报告元素分类
  Procedure p_GetElementClassList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(上级ID) 上级ID,
             编码,
             名称,
             '[' || 编码 || ']' || 名称 As 标题,
             说明,
             最后编辑时间
        From 影像报告元素分类;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassList;

  --2.功  能：新增影像报告元素分类信息
  Procedure p_AddElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	) As
  Begin
    Insert Into 影像报告元素分类
      (ID, 编码, 名称, 说明, 最后编辑时间,上级ID)
    Values
      (ID_In, 编码_In, 名称_In, 说明_In, Sysdate,上级ID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddElementClass;

  --3.功  能：修改影像报告元素分类信息
  Procedure p_EditElementClass(
    ID_In   In 影像报告元素分类.ID%Type,
	编码_In In 影像报告元素分类.编码%Type,
	名称_In In 影像报告元素分类.名称%Type,
	说明_In In 影像报告元素分类.说明%Type,
	上级ID_In In 影像报告元素分类.上级ID%Type
	) As
  Begin
    Update 影像报告元素分类
       Set 编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           最后编辑时间 = Sysdate,
           上级ID=上级ID_In
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditElementClass;

  --4.功  能：删除影像报告元素分类信息
  Procedure p_DelelEmentClass(
    ID_In In 影像报告元素分类.ID%Type
	) As
  Begin
    Delete From 影像报告元素分类 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelelEmentClass;

  --5.功  能：获得分类对应的影像报告值域信息列表
  Procedure p_GetRangeByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告值域清单.分类ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             说明,
             数据类型,
             值域种类,
             (Nvl(t.值域描述, XmlType('<NULL/>'))).GetClobVal() As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t
       Where 分类ID = 分类ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeByClass;

  --6.功  能：获得ID对应的影像报告值域信息
  Procedure p_GetRangeByID(
    Val           Out t_Refcur,
	ID_In In 影像报告值域清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             '[' || 编码 || ']' || 名称 标题,
             说明,
             数据类型,
             值域种类,
             (Nvl(t.值域描述, XmlType('<NULL/>'))).GetClobVal() As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeByID;

  --7.功  能：新增影像报告值域信息
  Procedure p_AddRange(
    ID_In       In 影像报告值域清单.ID%Type,
	分类ID_In   In 影像报告值域清单.分类ID%Type,
    编码_In     In 影像报告值域清单.编码%Type,
    名称_In     In 影像报告值域清单.名称%Type,
    说明_In     In 影像报告值域清单.说明%Type,
    数据类型_In In 影像报告值域清单.数据类型%Type,
    值域种类_In In 影像报告值域清单.值域种类%Type,
    值域描述_In In Varchar2
	) As
  Begin
    Insert Into 影像报告值域清单
      (ID, 分类ID, 编码, 名称, 说明, 数据类型, 值域种类, 值域描述, 最后编辑时间)
    Values
      (ID_In, 分类ID_In, 编码_In, 名称_In, 说明_In, 数据类型_In, 值域种类_In, 值域描述_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddRange;

  --8.功  能：修改影像报告值域信息
  Procedure p_EditRange(
    ID_In       In 影像报告值域清单.ID%Type,
    分类ID_In   In 影像报告值域清单.分类ID%Type,
    编码_In     In 影像报告值域清单.编码%Type,
    名称_In     In 影像报告值域清单.名称%Type,
    说明_In     In 影像报告值域清单.说明%Type,
    数据类型_In In 影像报告值域清单.数据类型%Type,
    值域种类_In In 影像报告值域清单.值域种类%Type,
    值域描述_In In Varchar2
	) As
  Begin
    Update 影像报告值域清单
       Set 分类ID       = 分类ID_In,
           编码         = 编码_In,
           名称         = 名称_In,
           说明         = 说明_In,
           数据类型     = 数据类型_In,
           值域种类     = 值域种类_In,
           值域描述     = 值域描述_In,
           最后编辑时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditRange;

  --9.功  能：删除影像报告值域信息
  Procedure p_DelRange(
    ID_In In 影像报告值域清单.ID%Type
	) As
  Begin
    Delete From 影像报告值域清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelRange;

  --10.功  能：获得分类对应的影像报告元素列表
  Procedure p_GetElementByClass(
    Val           Out t_Refcur,
	分类ID_In In 影像报告元素清单.分类ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             前缀,
             后缀,
             说明,
             数据类型,
             数值形态,
             最小长度,
             最大长度,
             最小小数位,
             最大小数位,
             计量单位,
             (Nvl(t.扩展描述, XmlType('<NULL/>'))).GetClobVal() As 扩展描述,
             RawToHex(值域ID) 值域ID,
             值域种类,
             最后编辑时间
        From 影像报告元素清单 t
       Where 分类ID = 分类ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementByClass;

  --11.功  能：获得ID对应的影像报告元素信息
  Procedure p_GetElementByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素清单.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             前缀,
             后缀,
             说明,
             数据类型,
             数值形态,
             最小长度,
             最大长度,
             最小小数位,
             最大小数位,
             计量单位,
             (Nvl(t.扩展描述, XmlType('<NULL/>'))).GetClobVal() As 扩展描述,
             RawToHex(值域ID) 值域ID,
             值域种类,
             最后编辑时间
        From 影像报告元素清单 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementByID;

  --12.功 能：新增影像报告元素信息
  Procedure p_AddElement(
    ID_In            In 影像报告元素清单.ID%Type,
    分类ID_In     In 影像报告元素清单.分类ID%Type,
    编码_In         In 影像报告元素清单.编码%Type,
    名称_In         In 影像报告元素清单.名称%Type,
    说明_In         In 影像报告元素清单.说明%Type,
    前缀_In         In 影像报告元素清单.前缀%Type,
    后缀_In         In 影像报告元素清单.后缀%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In   In 影像报告元素清单.计量单位%Type,
    扩展描述_In   In Varchar2,
    值域ID_In      In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	) As
  Begin
    Insert Into 影像报告元素清单
      (ID, 分类ID, 编码, 名称,  前缀, 后缀, 说明,  数据类型,  数值形态,  最小长度,  最大长度,
       最小小数位,  最大小数位,  计量单位,   扩展描述, 值域ID,  值域种类, 最后编辑时间)
    Values
      (ID_In, 分类ID_In, 编码_In, 名称_In, 前缀_In, 后缀_In, 说明_In, 数据类型_In, 数值形态_In, 最小长度_In, 最大长度_In,
       最小小数位_In, 最大小数位_In, 计量单位_In, 扩展描述_In, 值域ID_In, 值域种类_In, Sysdate);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddElement;

  --13.功 能：修改影像报告元素信息
  Procedure p_EditElement(
    ID_In           In 影像报告元素清单.ID%Type,
    分类ID_In     In 影像报告元素清单.分类ID%Type,
    编码_In        In 影像报告元素清单.编码%Type,
    名称_In        In 影像报告元素清单.名称%Type,
    前缀_In        In 影像报告元素清单.前缀%Type,
    后缀_In        In 影像报告元素清单.后缀%Type,
    说明_In        In 影像报告元素清单.说明%Type,
    数据类型_In   In 影像报告元素清单.数据类型%Type,
    数值形态_In   In 影像报告元素清单.数值形态%Type,
    最小长度_In   In 影像报告元素清单.最小长度%Type,
    最大长度_In   In 影像报告元素清单.最大长度%Type,
    最小小数位_In In 影像报告元素清单.最小小数位%Type,
    最大小数位_In In 影像报告元素清单.最大小数位%Type,
    计量单位_In    In 影像报告元素清单.计量单位%Type,
    扩展描述_In    In Varchar2,
    值域ID_In      In 影像报告元素清单.值域ID%Type,
    值域种类_In   In 影像报告元素清单.值域种类%Type
	) As
  Begin

    Update 影像报告元素清单
       Set 分类ID       = 分类ID_In,
           编码         = 编码_In,
           名称         = 名称_In,
           前缀         = 前缀_In,
           后缀         = 后缀_In,
           说明         = 说明_In,
           数据类型     = 数据类型_In,
           数值形态     = 数值形态_In,
           最小长度     = 最小长度_In,
           最大长度     = 最大长度_In,
           最小小数位   = 最小小数位_In,
           最大小数位   = 最大小数位_In,
           计量单位     = 计量单位_In,
           扩展描述     = 扩展描述_In,
           值域ID       = 值域ID_In,
           值域种类     = 值域种类_In,
           最后编辑时间 = Sysdate
     Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditElement;

  --14.功 能：删除影像报告元素信息
  Procedure p_DelElement(
    ID_In 影像报告元素清单.ID%Type
	) As
  Begin
    Delete From 影像报告元素清单 Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelElement;

  --15.功 能：通过ID获取影像报告分类信息
  Procedure p_GetElementClassByID(
    Val           Out t_Refcur,
	ID_In In 影像报告元素分类.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID, 编码, 名称, 说明, 最后编辑时间,RawToHex(上级id) 上级ID
        From 影像报告元素分类 t
       Where ID = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassByID;

  --16.功  能：获取元素的下一个编码
  Procedure p_Get_ElementNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告元素清单') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementNextCode;

  --17.功  能：获取元素分类的下一个编码
  Procedure p_Get_ElementClassNextCode(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select b_pacs_rptpublic.f_Get_Nextcode('影像报告元素分类') As 编码
        From dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassNextCode;

  --18.功  能：获取对应的值域类型所在的元素类别
  Procedure p_Get_ElementClassByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	) As
  Begin
    Open Val For
      Select Distinct 分类名称, 分类ID
        From (Select RawToHex(分类ID) 分类ID,
                     (Select a.名称
                        From 影像报告元素分类 A
                       Where a.Id = t.分类id) As 分类名称
                From 影像报告值域清单 T
               Where t.值域种类 = 值域种类_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassByKind;

  --19.功  能：获取值域类型对应的值域信息
  Procedure p_Get_RangeByKind(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             RawToHex(分类ID) 分类ID,
             名称,
             数据类型,
             (Select a.名称 From 影像报告元素分类 A Where a.Id = t.分类id) As 分类名称,
             值域种类
        From 影像报告值域清单 T
       Where t.值域种类 = 值域种类_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RangeByKind;

  --20.功  能：获取对应的值域类型和数据类型所在的元素类别
  Procedure p_Get_ElementClassByKindType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	) As
  Begin
    Open Val For
      Select Distinct 分类名称, 分类ID
        From (Select RawToHex(分类id) 分类ID,
                     (Select a.名称
                        From 影像报告元素分类 A
                       Where a.Id = t.分类id) As 分类名称
                From 影像报告值域清单 T
               Where t.值域种类 = 值域种类_In
                 and t.数据类型 = 数据类型_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ElementClassByKindType;

  --21.功  能：获取值域类型和数据类型对应的值域信息
  Procedure p_Get_RangeByKindAndType(
    Val           Out t_Refcur,
	值域种类_In In 影像报告值域清单.值域种类%Type,
	数据类型_In In 影像报告值域清单.数据类型%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             编码,
             RawToHex(分类ID) 分类ID,
             名称,
             数据类型,
             (Select a.名称 From 影像报告元素分类 A Where a.Id = t.分类id) As 分类名称,
             值域种类
        From 影像报告值域清单 T
       Where t.值域种类 = 值域种类_In
         and t.数据类型 = 数据类型_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RangeByKindAndType;

  --22.功 能：获取编辑人对应的最后修改影像报告原型分类信息ID
  Procedure p_GetElementClassLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告元素分类 t1
       Where Not Exists (Select 1
                From 影像报告元素分类
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementClassLastID;

  --23.功 能：获取编辑人对应的最后修改影像报告元素信息ID
  Procedure p_GetElementLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告元素清单 t1
       Where Not Exists (Select 1
                From 影像报告元素清单
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementLastID;

  --24.功 能：获取最后修改影像报告值域信息ID
  Procedure p_GetRangeLastID(
    Val Out t_Refcur
	) AS
  Begin
    Open Val For
      Select RawToHex(ID) ID, 最后编辑时间
        From 影像报告值域清单 t1
       Where Not Exists (Select 1
                From 影像报告值域清单
               Where 最后编辑时间 > t1.最后编辑时间);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeLastID;

  --25.功 能：添加计量单位信息
  Procedure p_AddMasure_Unit(
    编码_In 影像报告计量单位.编码%Type,
    名称_In 影像报告计量单位.名称%Type,
    说明_In 影像报告计量单位.说明%Type,
    前缀_In 影像报告计量单位.前缀%Type
	) As
  Begin
    Insert Into 影像报告计量单位
      (编码, 名称, 说明, 前缀)
    Values
      (编码_In, 名称_In, 说明_In, 前缀_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddMasure_Unit;

  --26.功  能：修改计量单位
  Procedure p_EditMasure_Unit(
    原编码_In 影像报告计量单位.编码%Type,
    编码_In   影像报告计量单位.编码%Type,
    名称_In   影像报告计量单位.名称%Type,
    说明_In   影像报告计量单位.说明%Type,
    前缀_In   影像报告计量单位.前缀%Type
	) As
  Begin
    Update 影像报告计量单位
       Set 编码 = 编码_In, 名称 = 名称_In, 说明 = 说明_In, 前缀 = 前缀_In
     Where 编码 = 原编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditMasure_Unit;

  --27.功  能：删除计量单位
  Procedure p_DelMasure_Unit(
    编码_In 影像报告计量单位.编码%Type
	) As
  Begin
    Delete from 影像报告计量单位 Where 编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_DelMasure_Unit;

  --28.功  能：判断计量单位的编码是否已存在
  Procedure p_If_Exist_Masure_Unit(
    Val           Out t_Refcur,
	编码_In 影像报告计量单位.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.编码) 数量
        From 影像报告计量单位 t
       Where t.编码 = 编码_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_Masure_Unit;

  --29.功  能： 判断元素编码是否已存在
  Procedure p_If_Exist_ElementCode(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	编码_In 影像报告元素清单.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素清单 t
       Where t.编码 = 编码_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementCode;

  --30.功  能： 判断元素名称是否已存在
  Procedure p_If_Exist_ElementName(
    Val           Out t_Refcur,
	ID_In   影像报告元素清单.ID%Type,
	名称_In 影像报告元素清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素清单 t
       Where t.名称 = 名称_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementName;

  --31.功  能： 判断值域编码是否已存在
  Procedure p_If_Exist_RangeCode(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	编码_In 影像报告值域清单.编码%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告值域清单 t
       Where t.编码 = 编码_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_RangeCode;

  --32.功  能： 判断值域名称是否已存在
  Procedure p_If_Exist_RangeName(
    Val           Out t_Refcur,
	ID_In   影像报告值域清单.ID%Type,
	名称_In 影像报告值域清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告值域清单 t
       Where t.名称 = 名称_In
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_RangeName;

  --33.获得元素列表
  Procedure p_GetElementList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(t.ID) ID,
             RawToHex(t.分类ID) 分类ID,
             t.编码,
             t.名称,
             t.前缀,
             t.后缀,
             t.说明,
             t.数据类型,
             t.数值形态,
             t.最小长度,
             t.最大长度,
             t.最小小数位,
             t.最大小数位,
             t.计量单位,
             (Nvl(t.扩展描述, XmlType('<NULL/>'))).GetClobVal() As 扩展描述,
             RawToHex(t.值域ID) 值域ID,
             (select a.名称 from 影像报告值域清单 a Where a.id=t.值域ID)as 值域名称,
             t.值域种类,
             t.最后编辑时间
        From 影像报告元素清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetElementList;

  --34.获得值域列表
  Procedure p_GetRangeList(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(分类ID) 分类ID,
             编码,
             名称,
             说明,
             数据类型,
             值域种类,
             (Nvl(t.值域描述, XmlType('<NULL/>'))).GetClobVal() As 值域描述,
             最后编辑时间
        From 影像报告值域清单 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetRangeList;

  --35.判断元素分类的标题和编码是否存在
  Procedure p_If_Exist_ElementClass(
    Val           Out t_Refcur,
    ID_In   影像报告元素分类.ID%Type,
	编码_In 影像报告元素分类.编码%Type,
	名称_In 影像报告元素分类.名称%Type
	) As
  Begin
    Open Val For
      Select Count(t.ID) 数量
        From 影像报告元素分类 t
       Where (t.名称 = 名称_In or t.编码 = 编码_In)
         and t.id <> ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_If_Exist_ElementClass;

  --36.判断该元素分类下面是否有值域或者元素
  Procedure p_Is_CanDel_ElementClass(
    Val           Out t_Refcur,
	ID_In 影像报告元素分类.ID%Type
	) As
    ElementCount int;
    RangeCount   int;
    ElementClassCout int;
  Begin
    Select Count(*)
      into ElementCount
      From 影像报告元素清单 a
     Where a.分类id = ID_In;
    Select Count(*)
      into RangeCount
      From 影像报告值域清单 b
     Where b.分类id = ID_In;
     Select Count(*)
      into ElementClassCout
      From 影像报告元素分类 b
     Where b.上级id = ID_In;
    ElementCount := ElementCount + RangeCount+ElementClassCout;
    Open Val For
      Select ElementCount Count From Dual;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Is_CanDel_ElementClass;

End b_PACS_RptElement;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptFragments Is
  Type t_Refcur Is Ref Cursor;


  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	);
  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	);
  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) ;


  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.ID%Type
	) ;


   Procedure p_Get_Label_By_Typeid(
     Val           Out t_Refcur,
	 Id_In 影像报告片段清单.ID%Type
	 ) ;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.ID%Type,
    Pid_In    影像报告片段清单.上级ID%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) ;

  --功能：删除短语分类
   Procedure p_Del_Fragmenttype(
     Id_In 影像报告片段清单.ID%Type
	 );

    --功能：添加短语
  Procedure p_Add_Fragment(
     Id_In      影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

   --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    );
   --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.ID%Type
	);

  procedure p_Get_All_Fragment_List(
    Val Out t_Refcur
	);

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.ID%Type,
    Pid_In      影像报告片段清单.上级ID%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) ;

procedure p_Get_Data_Last_Edit_Time(
  Val           Out t_Refcur,
  Table_Name_In varchar2
  );

   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	);

  --功能：根据片段ID，设置当前片段的适应条件
  Procedure p_Edit_FragmentConditionById
  (
    ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  );
  
  --功能：根据片段的父ID，设置整个目录或子目录片段的适应条件
  Procedure p_Edit_FragmentConditionByPid
  (
    上级ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In    In 影像报告片段清单.适应条件%Type
  );

  --功能：获取当前检查的片段适应条件
  Procedure p_Get_FraConditionByOrderId
  (
    Val           Out t_Refcur,
	医嘱ID_In    影像检查记录.医嘱ID%Type
  );

  --功能：获取影像检查类别
  Procedure p_Get_CheckLueKind
  (
    Val           Out t_Refcur
  );
  
  --功能：根据类别获取诊疗检查部位
  Procedure p_Get_CheckPartList
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  );
  
  --功能：根据类别获取影像检查项目
  Procedure p_Get_CheckRadListByKind
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  );
  
  --功能：根据诊疗编码获取影像检查项目
  Procedure p_Get_CheckRadListByCode
  (
    Val           Out t_Refcur,
    Code_In       Varchar2
  );

  --判断是否有相同的代码
  Procedure p_Get_HasSameCode
  (
  Val      Out t_Refcur,
  ID_In      In 影像报告片段清单.ID%Type,
  Code_In  影像报告片段清单.编码%Type
  );

  --判断是否有相同的名称
  Procedure p_Get_HasSameName
  (
  Val      Out t_Refcur,
  ID_In    In 影像报告片段清单.ID%Type,
  PID_In    In 影像报告片段清单.上级ID%Type,
  Name_In  In 影像报告片段清单.名称%Type,
  Author_In In  影像报告片段清单.作者%Type
  );

  End  b_PACS_RptFragments;
/
CREATE OR REPLACE Package Body b_PACS_RptFragments Is

  ------------------------------------------------------------------------
  --片段模块
  ------------------------------------------------------------------------

  --功能：获取所有预备提纲
  Procedure p_Get_All_Phr_Onlines(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(ID) ID, 编码, 名称 From 影像报告预备提纲 Order By 编码;
  End p_Get_All_Phr_Onlines;

  --功能：获取所有短语分类
  Procedure p_Get_All_Fragment_Class(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型
      From 影像报告片段清单 A
      Where a.节点类型 = 0
      Start With 上级id Is Null
      Connect By Prior ID = 上级id
      Order By 上级ID Desc, 编码;
  End p_Get_All_Fragment_Class;

  --功能：获取当前用户学科所有短语包括父节点
  Procedure p_Get_All_Fragment(
    Val           Out t_Refcur,
    Subjects_In 影像报告片段清单.学科%Type
	) As
  Begin
    If Subjects_In <> '' Then
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成, 
			a.学科, a.标签, a.是否私有, a.作者, (Nvl(a.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件,a.最后编辑时间, a.节点类型 As Image
        From 影像报告片段清单 A
        Where (a.学科 In (Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(Subjects_In, ','))
                        Intersect
                        Select /*+rule*/
                         Column_Value As Lable
                        From Table(b_Pacs_Common.f_Str2list(a.学科, ','))) And a.节点类型 <> 0) Or a.节点类型 = 0 Or a.学科 Is Null
        Order By 编码, 上级id;
    Else
      Open Val For
        Select Rawtohex(a.Id) As ID, Rawtohex(a.上级id) As 上级id, a.编码, a.名称, a.说明, a.节点类型, (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成, 
			a.学科, a.标签, a.是否私有, a.作者, (Nvl(a.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件,a.最后编辑时间, a.节点类型 As Image
        From 影像报告片段清单 A
        Order By 上级id, 节点类型, 编码, 名称;
    End If;
  End p_Get_All_Fragment;

  --功能：根据分类ID查找短语
  Procedure p_Get_Fragment_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
  ) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID, a.上级ID,a.编码, a.名称, a.说明, a.节点类型, (Nvl(a.组成, XmlType('<NULL/>'))).GetClobVal() As 组成, 
				a.学科, a.标签, a.是否私有, a.作者, (Nvl(a.适应条件, XmlType('<NULL/>'))).GetClobVal() As 适应条件, a.最后编辑时间,a.节点类型 As Image
      From 影像报告片段清单 A
      Where a.上级id = Hextoraw(Id_In) And a.节点类型 <> 0;
  End p_Get_Fragment_By_Typeid;

  --功能：查找某分类下所有短语标签
  Procedure p_Get_Label_By_Typeid(
    Val           Out t_Refcur,
    Id_In 影像报告片段清单.Id%Type
    ) As
  Begin
    Open Val For
      Select Distinct 标签 From 影像报告片段清单 Where 上级id = Hextoraw(Id_In) And 标签 Is Not Null;
  End p_Get_Label_By_Typeid;

  --功能：新增短语分类
  Procedure p_Add_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 编码 = Code_In Or 名称 = Title_In And 节点类型 = 0 And 上级id = Hextoraw(Pid_In);

    If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Author_In, Sysdate);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragmenttype;

  --功能：修改短语分类
  Procedure p_Edit_Fragmenttype(
    Id_In     影像报告片段清单.Id%Type,
    Pid_In    影像报告片段清单.上级id%Type,
    Code_In   影像报告片段清单.编码%Type,
    Title_In  影像报告片段清单.名称%Type,
    Note_In   影像报告片段清单.说明%Type,
    Leaf_In   影像报告片段清单.节点类型%Type,
    Author_In 影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 = 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]分类名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 作者 = Author_In,
          最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragmenttype;

  --功能：删除短语分类
  Procedure p_Del_Fragmenttype(
    Id_In 影像报告片段清单.Id%Type
	) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where 节点类型 <> 0 And
          ID In (Select ID From 影像报告片段清单 Connect By Prior ID = 上级id Start With ID = Hextoraw(Id_In));

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]该分类下存在短语，暂不能删除！[ZLSOFT]';
      Raise Err_Item;
    Else
      Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragmenttype;

  --功能：添加短语
  Procedure p_Add_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
  Begin

      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Fragment;

  --功能：修改短语
  Procedure p_Edit_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    n_Num     Number;
    v_Err_Msg Varchar2(100);
    Err_Item Exception;
  Begin
    Select Count(ID)
    Into n_Num
    From 影像报告片段清单
    Where (编码 = Code_In Or 名称 = Title_In) And 节点类型 <> 0 And 上级id = Hextoraw(Pid_In) And ID <> Hextoraw(Id_In);

	If n_Num > 0 Then
      v_Err_Msg := '[ZLSOFT]短语的名称或编码已经存在！[ZLSOFT]';
      Raise Err_Item;
    Else
      Update 影像报告片段清单
      Set 上级id = Hextoraw(Pid_In), 编码 = Code_In, 名称 = Title_In, 说明 = Note_In, 节点类型 = Leaf_In, 组成 = Content_In,
          学科 = Subjects_In, 标签 = Label_In, 是否私有 = Private_In, 作者 = Author_In, 最后编辑时间 = Sysdate
      Where ID = Hextoraw(Id_In);
    End If;

  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, v_Err_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Fragment;

  --
  Procedure p_Get_All_Fragment_List(Val Out t_Refcur) As
  Begin
    Open Val For
      Select Rawtohex(t.Id) As ID, Rawtohex(t.上级id) As 上级id, t.编码, t.名称, t.说明, t.节点类型, (Nvl(t.组成, XmlType('<NULL/>'))).GetClobVal() As 组成, t.学科, t.标签, t.是否私有, t.作者,
             t.最后编辑时间
      From 影像报告片段清单 T;
  End p_Get_All_Fragment_List;

  --功能：删除短语
  Procedure p_Del_Fragment(
    Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Delete 影像报告片段清单 Where ID = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Del_Fragment;

  --功能：导入短语
  Procedure p_Import_Fragment(
    Id_In       影像报告片段清单.Id%Type,
    Pid_In      影像报告片段清单.上级id%Type,
    Code_In     影像报告片段清单.编码%Type,
    Title_In    影像报告片段清单.名称%Type,
    Note_In     影像报告片段清单.说明%Type,
    Leaf_In     影像报告片段清单.节点类型%Type,
    Content_In  影像报告片段清单.组成%Type,
    Subjects_In 影像报告片段清单.学科%Type,
    Label_In    影像报告片段清单.标签%Type,
    Private_In  影像报告片段清单.是否私有%Type,
    Author_In   影像报告片段清单.作者%Type
    ) As
    v_Num Number(2);
  Begin
    Select Count(ID)
    Into v_Num
    From 影像报告片段清单
    Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
          (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));

    If v_Num > 0 Then
      Update 影像报告片段清单
      Set 组成 = Content_In, 最后编辑时间 = Sysdate, 是否私有 = 0
      Where ((编码 = Code_In Or 名称 = Title_In) And 上级id = Hextoraw(Pid_In)) Or
            (上级id Is Null And (编码 = Code_In Or 名称 = Title_In));
    Else
      Insert Into 影像报告片段清单
        (ID, 上级id, 编码, 名称, 说明, 节点类型, 组成, 学科, 标签, 是否私有, 作者, 最后编辑时间)
      Values
        (Hextoraw(Id_In), Hextoraw(Pid_In), Code_In, Title_In, Note_In, Leaf_In, Content_In, Subjects_In, Label_In,
         Private_In, Author_In, Sysdate);
    End If;

  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Import_Fragment;

  --
  Procedure p_Get_Data_Last_Edit_Time(
    Val           Out t_Refcur,
    Table_Name_In Varchar2
    ) As
    v_Sql Varchar2(4000);
  Begin
    v_Sql := 'select max(最后编辑时间) maxvalue from ' || Table_Name_In;
    Open Val For v_Sql;
  End p_Get_Data_Last_Edit_Time;
  
   --功能：判断片段分类能否删除
  Procedure p_IsCanDel_FragmentType(
    Val           Out t_Refcur,
	Id_In 影像报告片段清单.Id%Type
	) As
  Begin
    Open Val For
      Select Count(t.id) Count
        From 影像报告片段清单 t
       Where 上级id = Hextoraw(Id_In);
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_IsCanDel_FragmentType;
  
  --功能：根据片段ID，设置当前片段的适应条件
  Procedure p_Edit_FragmentConditionById
  (
    ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  )As
  Begin
    Update 影像报告片段清单 Set 适应条件 = 适应条件_In Where ID = Hextoraw(ID_In) And 节点类型 != 0;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_FragmentConditionById;
  
  --功能：根据片段的父ID，设置整个目录或子目录片段的适应条件
  Procedure p_Edit_FragmentConditionByPid
  (
    上级ID_In      In 影像报告片段清单.ID%Type,
    适应条件_In In 影像报告片段清单.适应条件%Type
  )As
  Begin
    Update 影像报告片段清单 Set 适应条件 = 适应条件_In Where 上级ID = Hextoraw(上级ID_In) And 节点类型 != 0;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_FragmentConditionByPid;

  --功能：获取当前检查的片段适应条件
  Procedure p_Get_FraConditionByOrderId(
    Val           Out t_Refcur,
	  医嘱ID_In    影像检查记录.医嘱ID%Type
	) As
  Begin
    Open Val For
	  Select a.id, a.性别,c.影像类别, d.编码||' - '||d.名称 检查类别, c.影像类别||' - '||e.编码||' - '||e.名称 检查项目, A.医嘱内容
      From 病人医嘱记录 a, 病人医嘱发送 b, 影像检查记录 c, 影像检查类别 d, 诊疗项目目录 e
      Where a.id = b.医嘱id and b.医嘱id=c.医嘱id and c.影像类别 = d.编码 and a.诊疗项目id = e.id and a.id = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_FraConditionByOrderId;

  --功能：获取影像检查类别
  Procedure p_Get_CheckLueKind
  (
    Val           Out t_Refcur
  ) As
  Begin
    Open Val For
      Select 编码||' - '||名称 检查类别 From 影像检查类别;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckLueKind;
  
  --功能：根据类别获取诊疗检查部位
  Procedure p_Get_CheckPartList
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  ) As
  Begin
    Open Val For
      Select Distinct 类型||分组 IID, '' 上级ID, 类型||' - '||分组 诊疗部位 From 诊疗检查部位 a,
      Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) b Where a.类型 = b.Column_Value
      Union Select 类型||分组||名称 IID, 类型||分组 上级ID, 类型||' - '||名称 诊疗部位 From 诊疗检查部位 c,
      Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) d Where c.类型 = d.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckPartList;
  
  --功能：根据类别获取影像检查项目
  Procedure p_Get_CheckRadListByKind
  (
    Val           Out t_Refcur,
    Kind_In       Varchar2
  ) As
  Begin
    Open Val For
      Select I.编码, r.影像类别||' - '||I.编码||' - '||I.名称 检查项目
      From 诊疗项目目录 I, 影像检查项目 R, Table(Cast(f_Str2list(''||Kind_In||'') As zlTools.t_Strlist)) M
      Where I.ID = R.诊疗项目id And R.影像类别=M.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckRadListByKind;
  
  --功能：根据诊疗编码获取影像检查项目
  Procedure p_Get_CheckRadListByCode
  (
    Val           Out t_Refcur,
    Code_In       Varchar2
  ) As
  Begin
    Open Val For
      Select I.编码, r.影像类别||' - '||I.编码||' - '||I.名称 检查项目
      From 诊疗项目目录 I, 影像检查项目 R, Table(Cast(f_Str2list(''||Code_In||'') As zlTools.t_Strlist)) M
      Where I.ID = R.诊疗项目id And I.编码=M.Column_Value;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_CheckRadListByCode;

  --判断是否有相同的代码
  Procedure p_Get_HasSameCode
  (
  Val      Out t_Refcur,
  ID_In      In 影像报告片段清单.ID%Type,
  Code_In  影像报告片段清单.编码%Type
  ) As
  Begin
  Open Val For
    Select Count(1) From 影像报告片段清单 Where ID<>ID_In And 编码=Code_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_HasSameCode;

  --判断是否有相同的名称
  Procedure p_Get_HasSameName
  (
  Val      Out t_Refcur,
  ID_In    In 影像报告片段清单.ID%Type,
  PID_In    In 影像报告片段清单.上级ID%Type,
  Name_In  In 影像报告片段清单.名称%Type,
  Author_In In  影像报告片段清单.作者%Type
  ) As
  Begin
  Open Val For
    Select Count(1) From 影像报告片段清单 Where 上级ID=PID_In And 作者=Author_In And ID<>ID_In And 名称=Name_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Get_HasSameName;

End  b_PACS_RptFragments;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptManage Is
  Type t_Refcur Is Ref Cursor;

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	);

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In 影像报告记录.报告质量%Type
	);
                                
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	);
                                
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	);

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type 
	);

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	);

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor);

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	);

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	);

 --10、添加文档的操作日志
 Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,                               
                               操作人_In   影像报告操作记录.操作人%Type,                               
                               操作类型_In 影像报告操作记录.操作类型%Type);

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	);

  --12、获取签名类型
  Procedure p_Get_SysConfigSignature(
    Val           Out t_Refcur,
	科室ID_In		In 部门表.ID%Type
	);

--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  );


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  );

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  );

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  );

--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In	影像报告驳回.医嘱ID%Type, 
  报告ID_In	影像报告驳回.检查报告ID%Type, 
  驳回理由_In 影像报告驳回.驳回理由%Type, 
  驳回时间_In 影像报告驳回.驳回时间%Type, 
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  );

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  );

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In	影像报告驳回.检查报告ID%Type
  );

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型id_In 影像报告动作.原型id%Type
  );

--20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In  Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In    Varchar2
    );

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    );

  --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
    );

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );
  
  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
    ID_IN  影像报告记录.id%TYPE   
    );

  --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱ID_IN  影像报告记录.医嘱ID%TYPE   
    );
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,  
    科室ID_IN  影像流程参数.科室ID%TYPE
    );

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    );

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  );

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    );

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    );

  --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    );

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
    Val           Out t_Refcur,
    医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
    报告ID_IN  影像报告记录.ID%TYPE
    );
  
  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  );

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    );

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type);
end b_PACS_RptManage;
/

--影像报告业务(---实现部分---)***************************************************

CREATE OR REPLACE Package Body b_PACS_RptManage Is

  --1、锁定报告人
  Procedure p_Edit_Doc_Lockinfo(
    报告_Id_In 影像报告记录.Id%Type,
	锁定人_In  影像报告记录.锁定人%Type
	) Is
  Begin
  
    --  报告ID为空，则清空所有“锁定人_In”正在锁定的标记
    If 报告_Id_In Is Null Then
      Update 影像报告记录 A Set a.锁定人 = '' Where a.锁定人 = 锁定人_In;
    Else
      Update 影像报告记录 A
         Set a.锁定人 = 锁定人_In
       Where a.Id = 报告_Id_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_Lockinfo;

  --2、评定报告质量
  Procedure p_Edit_Doc_EvaluatRptQuality(
    报告Id_In 影像报告记录.Id%Type,
	质量等级_In  影像报告记录.报告质量%Type
	) Is
  Begin
    Update 影像报告记录 Set 报告质量 = 质量等级_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatRptQuality;
  
  --3、评定阴阳性
  Procedure p_Edit_Doc_EvaluatResult(
    报告Id_In 影像报告记录.Id%Type,
	检查结果_In 影像报告记录.结果阳性%Type
	) Is
  Begin
     Update 影像报告记录 Set 结果阳性 = 检查结果_In Where Id = 报告Id_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_EvaluatResult;
  
  --4、报告发放/回收
  Procedure p_Edit_Doc_ReportRelease(
    报告Id_In 影像报告记录.Id%Type,
	当前操作人_In 影像报告记录.报告发放人%Type
	) Is
    v_报告发放     影像报告记录.报告发放%Type; 
  Begin
    
    Begin 
		  Select nvl(报告发放,0) Into v_报告发放 From 影像报告记录 where ID=报告Id_In; 
    Exception 
      When Others Then 
        v_报告发放 :=0; 
    End; 
     
    Update 影像报告记录 Set 报告发放 =decode(v_报告发放,0,1,0),报告发放人=decode(v_报告发放,0,当前操作人_In,'') Where ID=报告Id_In; 
     
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Doc_ReportRelease; 

 --5、新增，修改报告
  Procedure p_影像报告记录_新增(
    原型ID_In     影像报告记录.原型ID%Type,
    报告内容_In   影像报告记录.报告内容%Type,
    记录人_In     影像报告记录.记录人%Type,
    最后编辑人_In 影像报告记录.最后编辑人%Type,
    Id_In         影像报告记录.Id%Type,
    医嘱ID_In     影像报告记录.医嘱ID%Type
  ) As
    --原型ID_In 原型ID
    --保存文档书写记录
    --1 处理匿名数据
    --2 保存文档书写记录、状态
    --3 处理编辑日志
    --4 更新文档任务
    v_报告id    影像报告记录.Id%Type;
    v_原型名称  影像报告原型清单.名称%Type;
    v_设备号    影像报告原型清单.设备号%Type;
    v_报告序号  number;
    x_Editlog   Xmltype;
    Cur_Time    Date;
    To_Editlist t_Editlist;
    Tn_Editlist t_Editlist;
    v_Msg       Varchar2(200);
    v_New       number;
    Err_Custom  Exception;
    v_Result    影像报告记录.诊断意见%Type;
    v_操作ID    影像报告操作记录.ID%Type;

    Function Elist_Filter(
    Source_t t_Editlist
    ) Return t_Editlist Is
      Target_t t_Editlist := t_Editlist();
    Begin

      --对独立文档来说，这个函数只是将 Source_t按照编辑时间排序后输出
      For Rs In (Select /*+rule*/
                  *
                   From Table(Cast(Source_t As t_Editlist)) A
                  Order By a.编辑时间) Loop
        Target_t.Extend;
        Target_t(Target_t.Count) := t_Edits(Rs.编辑人,
                                            Rs.编辑时间,
                                            Rs.签名,
                                            Rs.审订签名);
      End Loop;
      Return Target_t;
    End;

    Function Build_Editlog(
    Tn_Edit t_Editlist,
    To_Edit t_Editlist,
    v_Did   影像报告记录.Id%Type) Return Xmltype Is
      --Tn_Edit 本次保存的新编辑记录；To_Edit上次保存的旧编辑记录
      --将两次编辑记录，组合成一个编辑记录

      x_Return Xmltype;
      r_Saveid Raw(16);
      n_Class  Number;
      --n_Class 编辑日志中的操作类别： 1-创建、2-删除、3-编辑、4-签名、5-审订、6-审签、7-撤签
      v_Signor  影像报告记录.创建人%Type;
      v_Adjunct 影像报告记录.创建人%Type;
      Tns_Edit  t_Editlist;
      Tos_Edit  t_Editlist;

      Function Atitle(原型ID 影像报告原型清单.Id%Type) Return Varchar2 Is
        v_原型名称 影像报告原型清单.名称%Type;
      Begin
        --根据原型ID，返回原型名称
        If 原型ID Is Null Then
          Return Null;
        Else
          Select 名称 Into v_原型名称 From 影像报告原型清单 Where ID = 原型ID;
          Return v_原型名称;
        End If;
      End;

    Begin
      x_Return := Xmltype('<root></root>');
      If v_Did Is Null Then
        --表明是新增文档，新增文档传null进来
        Select Sys_Guid() Into r_Saveid From Dual;

        --PACS报告没有子文档，但是下面构造XML的语句保留成跟EMR相同，这里的v_Subiid赋值为空
        Tns_Edit := Elist_Filter(Tn_Edit);
        Select Decode(Tns_Edit(Tns_Edit.Count).签名, 0, 1, 4)
          Into n_Class
          From Dual;
        Select Appendchildxml(x_Return,
                              '/root',
                              Xmlelement("operate",
                                         Xmlforest(r_Saveid As "saving_id",
                                                   n_Class As "class",
                                                   To_Char(Cur_Time,
                                                           'yyyy-mm-dd hh24:mi:ss') As
                                                   "cur_time",
                                                   最后编辑人_In As "operator",
                                                   Decode(n_Class,
                                                          4,
                                                          Tns_Edit(Tns_Edit.Count).编辑人,
                                                          '') As "signer",
                                                   '' As Adjunct)))
          Into x_Return
          From Dual;
      Else
        --不是新增的文档？
        Select Sys_Guid() Into r_Saveid From Dual;

        v_Signor  := '';
        v_Adjunct := '';
        Tns_Edit  := Elist_Filter(Tn_Edit);
        Tos_Edit  := Elist_Filter(To_Edit);
        If Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 0 Then
          --最近一次是签名
          If Tos_Edit.Count = 0 Then
            --新增子文档直接签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
            --之前没签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次普通签名
            n_Class  := 4;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次签名
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count)
         .签名 = 1 And Tns_Edit(Tns_Edit.Count).审订签名 = 1 Then
          --审订签名
          If Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
            --之前没审签，可能是已签名或已审订
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 > Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --多次审签
            n_Class  := 6;
            v_Signor := Tns_Edit(Tns_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 < Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --撤消多次审签
            n_Class   := 7;
            v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
          Elsif Tos_Edit(Tos_Edit.Count)
           .审订签名 = 1 And Tns_Edit(Tns_Edit.Count)
                .编辑时间 = Tos_Edit(Tos_Edit.Count).编辑时间 Then
            --无变化
            n_Class := -1;
          End If;
        Elsif Tns_Edit(Tns_Edit.Count).编辑人 Is Null And Tos_Edit.Count = 0 Then
          n_Class := 1;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        Elsif Tns_Edit(Tns_Edit.Count)
         .编辑人 Is Null And Tos_Edit(Tos_Edit.Count).编辑人 Is Null Then
          n_Class := 3;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 0 Then
          n_Class := 5;
        Elsif Tns_Edit(Tns_Edit.Count)
         .审订签名 = 0 And Tos_Edit(Tos_Edit.Count).审订签名 = 1 Then
          n_Class   := 7;
          v_Adjunct := Tos_Edit(Tos_Edit.Count).编辑人;
        End If;

        If n_Class <> -1 Then
          Select Appendchildxml(x_Return,
                                '/root',
                                Xmlelement("operate",
                                           Xmlforest(r_Saveid As "saving_id",
                                                     n_Class As "class",
                                                     To_Char(Cur_Time,
                                                             'yyyy-mm-dd hh24:mi:ss') As
                                                     "cur_time",
                                                     最后编辑人_In As "operator",
                                                     Decode(n_Class,
                                                            4,
                                                            v_Signor,
                                                            6,
                                                            v_Signor,
                                                            '') As "signer",
                                                     v_Adjunct As Adjunct)))
            Into x_Return
            From Dual;
        End If;

      End If;
      Return x_Return;
    End Build_Editlog;

    Function Get_NextRPTNum(
    AntetypeName 影像报告原型清单.名称%Type,
    Order_ID 影像报告记录.医嘱Id%Type
    )
      Return Number Is
        v_序号 Number;
        v_count Number;
        v_num Number;
      Begin

        v_count :=0;
        v_num :=1;
        loop
             select count(*)+v_num into v_序号 from 影像报告记录 where 医嘱ID=Order_ID;
             select count(*) into v_count from 影像报告记录 where 医嘱ID=Order_ID and 文档标题=AntetypeName||'_'||v_序号;

             if v_count =0 then
               exit;
             end if;

             v_num := v_num +1;
         end loop;

         return v_序号;
     End;

  Begin

    Select 名称, 设备号,Sysdate
      Into v_原型名称,v_设备号, Cur_Time
      From 影像报告原型清单
     Where ID = 原型ID_In;

    --------------------1 保存文档书写记录、状态--------------------
    --提取文档的签名和编辑（新增、修改）记录
    Tn_Editlist := b_PACS_RptPublic.f_Geteditlist(报告内容_In);

    --------------------2 处理编辑日志--------------------
    select count(*) into v_New from 影像报告记录 where ID=Id_In;

    v_报告id := Id_In;
    select zlpub_pacs_取提纲内容byxml (报告内容_In,'诊断意见') into v_Result from dual;
    If v_New=0 Then
      --新增报告
      To_Editlist := t_Editlist();
      x_Editlog   := Build_Editlog(Tn_Editlist, To_Editlist, Null);

      --取报告序号
      v_报告序号 := Get_NextRPTNum(v_原型名称,医嘱ID_In);

      Insert Into 影像报告记录
        (ID,
         原型ID,
         文档标题,
         报告内容,
         创建时间,
         创建人,
         报告状态,
         最后编辑时间,
         最后编辑人,
         编辑日志,
         医嘱ID,
         记录人,
         诊断意见,
         设备号)
      Values
        (v_报告id,
         原型ID_In,
         v_原型名称||'_'||v_报告序号,
         报告内容_In,
         Cur_Time,
         最后编辑人_In,
         1,
         Cur_Time,
         最后编辑人_In,
         x_Editlog,
         医嘱ID_In,
         记录人_In,
         v_Result,
         v_设备号);
      Insert Into 病人医嘱报告(医嘱ID,检查报告ID)Values(医嘱ID_In,v_报告id);
      
      Select Sys_Guid() Into v_操作ID From Dual;
      Insert Into 影像报告操作记录(ID, 报告ID,医嘱ID,文档标题,操作人,操作时间,操作类型) 
             Values(v_操作ID,v_报告id,医嘱ID_In,v_原型名称||'_'||v_报告序号,最后编辑人_In,sysdate,6);

    Else
      --提取文件原始编辑记录,必需在更新之前提取
      Select b_PACS_RptPublic.f_Geteditlist(报告内容)
        Into To_Editlist
        From 影像报告记录
       Where ID = v_报告id;

      x_Editlog := Build_Editlog(Tn_Editlist, To_Editlist, v_报告id);
      Select Appendchildxml(编辑日志,
                            '/root',
                            Extract(x_Editlog, '/root/*'))
             Into x_Editlog From 影像报告记录 Where ID = v_报告id;

       Update 影像报告记录
                Set 报告内容     = 报告内容_In,
                最后编辑时间 = Cur_Time,
                最后编辑人   = 最后编辑人_In,
                编辑日志     = x_Editlog,
                记录人       =记录人_In,
                诊断意见     =v_Result
                Where ID = v_报告id;
       end if;

  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_新增;

  --6、获取书写的文档内容
  Procedure p_Get_Doc_Content(
    Val           Out t_Refcur,
	DocID_In 影像报告记录.Id%Type
	) As
  Begin
    Open Val For
      Select  (Nvl(a.报告内容, XmlType('<ZLXML/>'))).GetClobVal() As 报告内容 From 影像报告记录 A Where a.Id = DocID_In;
  End;

  --7、设置报告打印作废信息
  Procedure p_Checkrejectsignature(Signdate_In Date,
                                   报告ID_In   影像报告操作记录.报告Id%Type,
                                   作废人_In   影像报告操作记录.作废人%Type,
                                   作废说明_In 影像报告操作记录.作废说明%Type,
                                   Val         Out Sys_Refcursor) As
  Begin
    Open Val For
      Select 操作人, 操作时间
        From 影像报告操作记录
       Where 报告ID = 报告ID_In
         And 操作类型=1
         And 操作时间 >= Signdate_In
         And 作废时间 Is Null
       Order By 操作时间 Asc;
    --作废打印记录
    Update 影像报告操作记录 B
       Set 作废人 = 作废人_In, 作废时间 = Sysdate, b.作废说明 = 作废说明_In
     Where 报告ID = 报告ID_In And 操作类型=1
       And 操作时间 >= Signdate_In;

  End p_Checkrejectsignature;

  --8、查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val           Out t_Refcur,
	原型ID_In 影像报告范文清单.原型ID%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型ID = 原型ID_In;
  End;

  --9、删除文档范文
  Procedure p_Del_影像报告范文清单(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单 Where Id = Id_In;
  End;
  
 --10、添加文档的操作日志
  Procedure p_影像报告操作记录_Add(Id_In       影像报告操作记录.Id%Type,
                               报告ID_In   影像报告操作记录.报告ID%Type,
                               操作人_In   影像报告操作记录.操作人%Type,
                               操作类型_In 影像报告操作记录.操作类型%Type) As
  n_医嘱ID 影像报告操作记录.医嘱ID%Type;
  n_文档标题 影像报告记录.文档标题%Type;
  Begin

  Begin
    Select 医嘱ID,文档标题 Into n_医嘱ID,n_文档标题 From 影像报告记录 Where ID = 报告ID_In;
  Exception
    When Others Then
      null;
  End;
  if n_医嘱ID is not null then
    Insert Into 影像报告操作记录
      (ID, 报告ID,医嘱ID,文档标题,操作人,操作时间,操作类型)
    Values
      (Id_In, 报告ID_In, n_医嘱ID,n_文档标题,操作人_In, sysdate,操作类型_In);
    if 操作类型_In=1 then
        update 影像报告记录 set 报告打印=1 where ID=报告ID_In;
    end if;
  end if;
  Exception
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End;

  --11、删除报告
  Procedure p_影像报告记录_删除(
    报告_Id_In 影像报告记录.Id%Type
	) As
  Begin    

    Delete From 影像报告记录 Where 影像报告记录.Id = Hextoraw(报告_Id_In);

    Delete From 病人医嘱报告 Where 检查报告ID =hextoraw(报告_Id_In);

  Exception   
    When Others Then
      Zl_Errorcenter(SQLCode, SQLErrM);
  End p_影像报告记录_删除;


--12、获取签名类型
Procedure p_Get_SysConfigSignature(
  Val           Out t_Refcur,
  科室ID_In		In 部门表.ID%Type
  )Is
Begin
    --返回用户, 模块号,功能
	Open  Val For 
	    select Zl_Fun_Getsignpar(7, 科室ID_In) as 签名类型 from dual;
Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--13、获取账户签名印章
Procedure p_Get_PersonSignImg(
  Val           Out t_Refcur,
  ID_In		In 人员表.ID%Type
  )Is
  v_sql Varchar2(1000);
  n_count Number(5);
Begin                
  Select Count(*) Into n_Count From user_tables Where table_name =Upper('影像签名图片');
  
  If n_Count > 0 Then
     v_sql := 'Truncate Table 影像签名图片';
     Execute Immediate v_sql;   
     
     v_sql := 'Insert Into 影像签名图片 Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;
     Execute Immediate v_sql;  
  Else
     v_sql := 'Create GLOBAL TEMPORARY TABLE 影像签名图片 ON COMMIT PRESERVE ROWS AS Select a.id, to_lob(a.签名图片) as 签名图片 From 人员表 a Where a.ID=' || ID_In;  
     Execute Immediate v_sql;    
  End If; 
   
  v_sql := 'Select 签名图片 From 影像签名图片 Where Id=:ID';

  --返回用户, 模块号,功能
  Open  Val For v_sql Using ID_In;  

  --Open  Val For 
  --  Select To_Blob(签名图片) As 签名图片 From 人员表 Where ID=ID_In;

Exception
  When Others Then
  Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;


--14、获取签名的证书信息
Procedure p_Get_SignCertInfo(
  Val           Out t_Refcur,
  证书ID_In		人员证书记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select ID, CertDN,CertSN,SignCert,EncCert From 人员证书记录 Where ID=证书ID_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;

--15、更新报告状态
Procedure p_Update_ReportState(
  报告Id_In  影像报告记录.ID%Type,
  报告状态_In  影像报告记录.报告状态%Type,
  审核人_In   影像报告记录.最后审核人%Type
  )Is
Begin
  --报告状态1-未签名；2-已诊断；3-已审核；4-已终审；5-诊断驳回；6-审核驳回
  --如果报告状态是1-未签名；2-已诊断;5-诊断驳回，此时是没有审核人的
  if (报告状态_In=1) or (报告状态_In=2) or (报告状态_In=5) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=null,最后审核时间=null Where ID=报告Id_In;
  elsif (报告状态_In=3) or (报告状态_In=4) then 
    Update 影像报告记录 Set 报告状态=报告状态_In,最后审核人=审核人_In,最后审核时间=sysdate Where ID=报告Id_In;
  else
    Update 影像报告记录 Set 报告状态=报告状态_In Where ID=报告Id_In;
  end if;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--16、获取报告状态
Procedure p_Get_ReportState(
  Val           Out t_Refcur,
  报告Id_In	影像报告记录.ID%Type
  )Is
Begin
	Open  Val For 
	    Select 报告状态 From 影像报告记录 Where ID=报告Id_In;
Exception
  When Others Then
		Zl_Errorcenter(Sqlcode, Sqlerrm); 
End;



--17、报告驳回
Procedure p_Reject_Report(
  医嘱ID_In  影像报告驳回.医嘱ID%Type,
  报告ID_In  影像报告驳回.检查报告ID%Type,
  驳回理由_In 影像报告驳回.驳回理由%Type,
  驳回时间_In 影像报告驳回.驳回时间%Type,
  驳回人_In   影像报告驳回.驳回人%Type,
  待处理人_In  影像报告记录.待处理人%Type,
  报告状态_In 影像报告记录.报告状态%Type
  )Is
Begin
  Insert Into 影像报告驳回(ID, 医嘱ID,检查报告ID,驳回理由,驳回时间,驳回人)
  Values(影像报告驳回_ID.NEXTVAL, 医嘱ID_IN, 报告ID_In, 驳回理由_IN, 驳回时间_IN, 驳回人_IN);

  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人=待处理人_In Where ID=报告ID_In;

  --Update 病人医嘱发送 Set 执行过程=-1 Where 医嘱ID= 医嘱ID_IN;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--17.1、撤销报告驳回
Procedure p_Reject_Cancel(
  ID_In       影像报告驳回.ID%Type,
  报告ID_In    影像报告驳回.检查报告ID%Type,
  报告状态_In   影像报告记录.报告状态%Type
  )Is
Begin
  Update 影像报告驳回 Set 是否撤销=1 Where ID=ID_In;
  Update 影像报告记录 Set 报告状态=报告状态_In,待处理人='' Where ID=报告ID_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End;

--18、获取报告驳回信息
Procedure p_Get_RejectInfo(
  Val           Out t_Refcur,
  报告ID_In  影像报告驳回.检查报告ID%Type
  )Is
Begin
  Open  Val For
    Select A.ID, A.驳回理由, A.驳回时间, A.驳回人, Nvl( A.是否撤销,0) As 驳回状态, B.报告状态
    From 影像报告驳回 A, 影像报告记录 B Where A.检查报告ID=报告Id_In And A.检查报告ID = B.ID Order by 驳回时间;
End;

--19、获取原型动作
Procedure p_Get_Doc_Process(
  Val           Out t_Refcur,
  原型ID_In 影像报告动作.原型id%Type
  ) As
  Begin
    Open Val For
      Select RawtoHex(p.id) ID,
             p.名称 As 动作名称,
			 e.名称 As 事件名称,
			 e.种类 As 事件种类,
			 e.元素IID As 元素IID,
             p.动作类型,
             p.序号,
             p.说明,
             p.可否手工执行,
             (Nvl(p.内容,XmlType('<NULL/>'))).GetClobVal() As 内容, 
             RawtoHex(p.事件ID) 事件ID
        From 影像报告动作 P, 影像报告事件 E
       Where p.事件ID = e.Id(+) And p.原型ID=原型ID_In
       Order By 动作类型, 序号;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_Doc_Process;

  --20、通过学科筛选获得相应的范文信息
  Procedure p_Get_Samplelist_By_Conditions(
    Val           Out t_Refcur,
    原型id_In       Varchar2,
    学科_In          Varchar2,
    Condition_In Varchar2, --过滤筛选
    作者_In          Varchar2
  ) As
  Begin

    Open Val For
      Select /*+ rule*/ Rawtohex(a.Id) ID, a.名称, a.作者, a.说明,
             Nvl2(a.说明, a.说明 || '作者:' || a.作者, '作者:' || a.作者) Content, a.标签, a.学科
      From 影像报告范文清单 A
      Where a.原型ID = Hextoraw(原型id_In) And
            ((a.学科 Is Null And a.是否私有 = 0) Or 学科_In Is Null Or a.作者 = 作者_In Or
            (a.学科 Is Not Null And  b_PACS_RptPublic.f_If_Intersect(a.学科, 学科_In) > 0 And a.是否私有 = 0)) And
            (Condition_In Is Null Or
            (a.标签 Is Not Null And Condition_In Is Not Null And b_PACS_RptPublic.f_If_Intersect(a.标签, Condition_In) > 0))
      Order By a.编号;

  End p_Get_Samplelist_By_Conditions;

  --21、通过部门ID获取部门名称
  Procedure p_Get_部门名称_By_ID(
    Val           Out t_Refcur,
    ID_IN 部门表.ID%TYPE
    )Is
  begin
       open val for
       select 名称 from 部门表 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_部门名称_By_ID;
    

 --22、提取所有预备提纲
  Procedure p_Get_AllPreOutlines(
    Val           Out t_Refcur
  )Is
  begin
       open val for
       Select Rawtohex(ID) ID, a.编码, a.名称 From 影像报告预备提纲 a Order By a.编码;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_AllPreOutlines;

  --23、提取文档标题
  Procedure p_Get_reportTitle_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  begin
       open val for
       select 文档标题 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_reportTitle_By_ID;

  --24、提取报告锁定人
  Procedure p_Get_报告锁定人_By_ID(
    Val           Out t_Refcur,
	ID_IN  影像报告记录.id%TYPE   
    )Is
  Begin
       Open Val For
         Select 锁定人 From 影像报告记录 Where id =ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_报告锁定人_By_ID;

 --25、通过医嘱ID获取报告列表
  Procedure p_Get_影像报告记录_By_医嘱ID(
    Val           Out t_Refcur,
	医嘱ID_IN  影像报告记录.医嘱ID%TYPE
    )Is
  Begin
       Open Val For
       Select RawToHex(ID) As REPORTID, RawToHex(原型ID) As ANTETYPEID, 医嘱ID As ORDERID,文档标题 As REPORTNAME,
              创建时间 As REPORTDATE, Decode(Nvl(报告状态,0),1,'编辑中',2,'已诊断',3,'已审核',4,'已终审',5,'诊断驳回','审核驳回') As REPORTSTATE,
              创建人 As CreateUser,最后审核时间 As ExamineyDate,最后审核人 As ExamineyUser,Decode(Nvl(结果阳性,0),1,'阳性','') As RESULTPOSITIVE,
              Nvl(报告质量,0) As INNERQUALITY,' ' As REPORTQUALITY, Decode(Nvl(报告打印,0),0,'未打印','已打印') As ReportPrint,
              Decode(Nvl(报告发放,0),0,'未发放','已发放') As REPORTRELEASE ,记录人 as RECDOCTOR From 影像报告记录 Where 医嘱ID =医嘱ID_IN
              order by REPORTDATE desc;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像报告记录_By_医嘱ID;
  
  --26、查询影像流程参数值
  Procedure p_Get_影像流程参数值(
    Val           Out t_Refcur,
	科室ID_IN  影像流程参数.科室ID%TYPE
    )Is
  Begin
       Open val For
       Select 参数名,参数值 From 影像流程参数 Where 科室ID=科室ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像流程参数值;

  --27、根据医嘱ID，查询对应的原型列表
  Procedure p_Get_影像原型列表_By_医嘱ID(
    Val           Out t_Refcur,
    医嘱_IN  影像检查记录.医嘱ID%TYPE   
    )Is
  Begin
       Open Val For
       Select Rawtohex(c.Id) As Antetypeid, c.名称 As Antetypename, c.说明
       From 病人医嘱记录 A, 影像报告原型应用 B, 影像报告原型清单 C
       Where a.Id = 医嘱_In And a.诊疗项目id = b.诊疗项目id And b.报告原型id = c.Id And a.病人来源 = b.应用场合
       Order By c.使用次数 Desc;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_影像原型列表_By_医嘱ID;

  --28、根据报告ID查询打印记录
  procedure p_Get_ReportPrintLog_By_报告ID
  (
       val out sys_refcursor  ,
       报告_IN  影像报告操作记录.报告ID%TYPE
  )is
  begin
       open val for
       Select  c.文档标题 , b.操作人, To_Char(b.操作时间, 'yyyy-MM-dd HH24:mi') 打印时间, b.作废人,
               To_Char(b.作废时间, 'yyyy-MM-dd HH24:mi') 作废时间, b.作废说明
               From 影像报告操作记录 B, 影像报告记录 C
               Where c.Id = 报告_IN And b.报告ID = c.Id And 操作类型=1 Order By b.操作时间;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_ReportPrintLog_By_报告ID;

  --29、根据医嘱ID查询报告发放列表
  Procedure p_Get_ReportReleaseList(
    Val           Out t_Refcur,
    医嘱_IN  影像报告记录.医嘱ID%TYPE   
    )Is
  Begin
       Open val For
       Select rawtohex(ID) As 报告ID, 文档标题 As 报告名称,最后编辑时间 as 报告日期,
              decode(nvl(报告发放,0),0,'未发放','已发放') As 报告发放 
              From 影像报告记录 Where 报告状态 Between 2 And 4 And 医嘱ID =医嘱_IN;
       
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_ReportReleaseList;

  --30、根据报告ID查询驳回记录数量
  Procedure p_Get_RejectedCount(
    Val           Out t_Refcur,
    报告_IN  影像报告驳回.检查报告ID%TYPE
    )Is
  Begin
       Open val For
       Select count(*) As 驳回数量 From 影像报告驳回 Where 检查报告ID=报告_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_RejectedCount;

   --31、根据医嘱ID查询报告动作需要的一些ID们
  Procedure p_Get_DocProcess_IDs(
    Val           Out t_Refcur,
    医嘱_IN  病人医嘱记录.ID%TYPE
    )Is
  Begin
       open val for
       select ID as 医嘱ID,主页ID,挂号单 from 病人医嘱记录 where ID=医嘱_IN;

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocProcess_IDs;

  --32、根据医嘱ID和报告ID查询报告的一些参数
  Procedure p_Get_DocInfo(
       Val           Out t_Refcur,
       医嘱ID_IN  影像检查记录.医嘱ID%TYPE,
       报告ID_IN  影像报告记录.ID%TYPE
  )Is
  Begin
      If 报告ID_IN Is Null Then 
        Open Val For 
        Select 执行科室ID,'创建人' As 创建人 From 影像检查记录 Where 医嘱ID=医嘱ID_IN;
      Else
        Open Val For
        Select 执行科室ID,创建人 From 影像检查记录 A,影像报告记录 b Where a.医嘱ID=B.医嘱ID and b.id=报告ID_IN;
      End if;
       

  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_DocInfo;

  --33、查询一个检查中相同原型ID的报告数量
   Procedure p_Get_SameAntetypeDocCounts(
       Val           Out t_Refcur,
       医嘱ID_IN  影像报告记录.医嘱ID%TYPE,
       原型ID_IN  影像报告记录.原型ID%TYPE
  )Is
  Begin      
        Open Val For
        Select count(id) as DocCounts From 影像报告记录 Where 医嘱ID=医嘱ID_IN and 原型ID=原型ID_IN;    
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_SameAntetypeDocCounts;

  --34、提取报告图存储信息
  Procedure p_Get_DocImageSaveInof_By_ID(
    Val           Out t_Refcur,
	  ID_IN  影像报告记录.id%TYPE
    )Is
  begin
       open val for
       select 设备号,创建时间 from 影像报告记录 where id=ID_IN;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  end p_Get_DocImageSaveInof_By_ID;

  --35、修改原型使用次数
  Procedure p_Update_Antetypeusecount(Id_In 影像报告原型清单.Id%Type) Is
  Begin
    Update 影像报告原型清单 Set 使用次数 = 使用次数 + 1 Where ID = Id_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Update_Antetypeusecount;

End b_PACS_RptManage;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptParam Is
  Type t_Refcur Is Ref Cursor;

  --功能1：获得活动的参数列表
  Procedure p_GetPrograms(
    Val Out t_Refcur
	);
  --功能2：通过模块号获取影像参数信息
  Procedure p_GetParamByQum(
    Val           Out t_Refcur,
	模块_In 影像参数说明.模块%Type
	);
  --功能3：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue(
    Val           Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能4：获得部门信息
  Procedure p_GetDepart(
    Val Out t_Refcur
	);
  --功能5：获得人员信息
  Procedure p_GetUsersInfo(
    Val Out t_Refcur
	);
  --功能6：获得机器名信息
  Procedure p_GetMachinesInfo(
    Val Out t_Refcur
	);
  --功能7：获取所有的影像参数信息
  Procedure p_GetAllParam(
    Val Out t_Refcur
	);
  --功能8：获得所有部门的所有的参数取值信息
  Procedure p_GetValueAllDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能9：得ID对应部门的所有的参数取值信息
  Procedure p_GetValueByDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	部门ID_In 部门表.ID%Type
	);
  --功能9：获取所有的用户对应的参数值
  Procedure p_GetValueAllUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能10：获取用户ID对应的参数信息
  Procedure p_GetValueByUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	用户ID_In 人员表.ID%Type
	);
  --功能11：获取所有的工作站对应的参数值
  Procedure p_GetValueAllMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能12：获取工作站名称对应的参数信息
  Procedure p_GetValueByMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	机器名_In zlclients.工作站%Type
	);
  --功能13：添加参数信息
  Procedure p_AddParamValue(
    ID_In       影像参数取值.ID%Type,
    参数ID_In   影像参数取值.参数ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	);

  --功能14：修改参数信息
  Procedure p_EditParamValue(
    ID_In       影像参数取值.ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	);

  --功能15:通过ID获得参数信息
  Procedure p_GetParamByID(
    Val Out t_Refcur,
	ID_In 影像参数说明.ID%Type
	);
  --功能16：修改ID对应的参数级别
  Procedure p_ChangeAdjustByID(
    ID_In     影像参数说明.ID%Type,
	Adjust_In 影像参数说明.参数级别%Type
	);
  --功能17：获得对应参数标识的参数取值信息
  Procedure p_GetValueBySign(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	);
  --功能18：修改ID对应的参数信息的默认值
  Procedure p_EditDaultValue(
    ID_In     影像参数说明.ID%Type,
	默认值_In 影像参数说明.默认值%Type);

  --功能19：通过部门获得人员信息
  Procedure p_GetUserByDID(
    Val Out t_Refcur,
	DID_In 部门人员.部门ID%Type
	);
  --功能21:通过ID获得参数取值
  Procedure p_GetParamValueByCID(
    Val Out t_Refcur,
	CID_In 影像参数取值.参数ID%Type
	);
  --功能22:通过ID获得模块号的参数取值
  Procedure p_GetValueLevel0(
    Val Out t_Refcur,
	参数ID_In   影像参数取值.参数ID%Type,
	参数标识_In 影像参数取值.参数标识%Type
	);
end b_PACS_RptParam;
/

--影像报告参数---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptParam Is
  --create by hwei;

  --功能1：获得活动的参数列表
  Procedure p_GetPrograms(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select 序号, 标题, Decode(A.标题, '', 序号, 序号 || '-' || 标题) 名称
        From (Select Distinct (t.模块) 序号,
                              (Select y.标题
                                 From zlprograms y
                                Where to_char(y.序号) = t.模块) 标题
                From 影像参数说明 t) A;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetPrograms;
  --功能2：通过模块号获取影像参数信息
  Procedure p_GetParamByQum(
    Val Out t_Refcur,
	模块_In 影像参数说明.模块%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明,
             '― ―' 参数值
        From 影像参数说明 t
       Where t.模块 = 模块_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamByQum;

  --功能3：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
    paramPiont nvarchar2(50);
    paramLevel Number := -1;
    paramCount Number := -1;
  Begin
    Select a.参数级别
      Into paramLevel
      From 影像参数说明 a
     Where a.id = 参数ID_In
       And rownum <= 1;
    If paramLevel = 1 Then
      Select count(t.id)
        Into paramCount
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      IF paramCount <> 0 THEN
        Select t.参数标识
          Into paramPiont
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
      End If;
      IF paramCount <> 0 And
         Replace(translate(paramPiont, '0123456789', '0'), '0', '') IS NULL THEN
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 (Select a.标题
                    From zlprograms a
                   Where a.序号 = t.参数标识
                     And rownum <= 1) As 标识名称,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      Else
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 t.参数标识 As 标识名称,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      End If;
    Elsif paramLevel = 2 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               (Select a.名称 From 部门表 a Where a.id = t.参数标识) as 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Elsif paramLevel = 3 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               (Select a.姓名
                  From 人员表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Else
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               t.参数标识 As 标识名称,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValue;

  --功能4：获得部门信息
  Procedure p_GetDepart(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select ID, 上级ID, t.编码, t.名称 from 部门表 t Order by t.名称;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDepart;
  --功能5：获得人员信息
  Procedure p_GetUsersInfo(Val Out t_Refcur) As
  Begin
    Open Val For
      Select ID, t.编号, t.姓名, t.简码, t.身份证号
        From 人员表 t
       Order by t.姓名;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetUsersInfo;

  --功能6：获得机器名信息
  Procedure p_GetMachinesInfo(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select t.工作站, t.ip, t.部门 From zlclients t Order by t.工作站;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetMachinesInfo;

  --功能7：获取所有的影像参数信息
  Procedure p_GetAllParam(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明
        From 影像参数说明 t;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetAllParam;
  --功能8：获得所有部门的所有的参数取值信息
  Procedure p_GetValueAllDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.id, t.参数id, t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllDepart;

  --功能9：得ID对应部门的所有的参数取值信息
  Procedure p_GetValueByDepart(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	部门ID_In 部门表.ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 部门表 s
       Where s.id = 部门ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByDepart;

  --功能9：获取所有的用户对应的参数值
  Procedure p_GetValueAllUser(
    Val Out t_Refcur,
    参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 人员表 s;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllUser;

  --功能10：获取用户ID对应的参数信息
  Procedure p_GetValueByUser(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	用户ID_In 人员表.ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.id As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.id) As 参数值
        From 人员表 s
       Where s.id = 用户ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByUser;

  --功能11：获取所有的工作站对应的参数值
  Procedure p_GetValueAllMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) As ID,
             RawToHex(参数ID_In) As 参数ID,
             s.工作站 As 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) As 参数值
        From zlclients s;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueAllMachine;

  --功能12：获取工作站名称对应的参数信息
  Procedure p_GetValueByMachine(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type,
	机器名_In zlclients.工作站%Type
	) As
  Begin
    Open Val For
      Select (Select RawToHex(ID) ID
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) as ID,
             RawToHex(参数ID_In) as 参数ID,
             s.工作站 as 参数标识,
             (Select t.参数值
                From 影像参数取值 t
               Where t.参数id = 参数ID_In
                 And t.参数标识 = s.工作站) as 参数值
        From zlclients s
       Where s.工作站 = 机器名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueByMachine;
  --功能13：添加参数信息
  Procedure p_AddParamValue(
    ID_In       影像参数取值.ID%Type,
    参数ID_In   影像参数取值.参数ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	) As
  Begin
    Insert Into 影像参数取值 t
      (ID, 参数ID, 参数标识, 参数值)
    ValueS
      (ID_In, 参数ID_In, 参数标识_In, 参数值_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_AddParamValue;

  --功能14：修改参数信息
  Procedure p_EditParamValue(
    ID_In       影像参数取值.ID%Type,
    参数标识_In 影像参数取值.参数标识%Type,
    参数值_In   影像参数取值.参数值%Type
	) As
  Begin
    Update 影像参数取值 t
       Set 参数标识 = 参数标识_In, 参数值 = 参数值_In
     Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditParamValue;
  --功能15:通过ID获得参数信息
  Procedure p_GetParamByID(
    Val Out t_Refcur,
	ID_In 影像参数说明.ID%Type
	) As
  Begin
    Open Val For
      Select RawToHex(ID) ID,
             RawToHex(PID) PID,
             t.分组,
             t.参数序号,
             t.参数名,
             t.默认值,
             t.参数级别,
             t.取值范围,
             t.启用条件,
             t.说明
        From 影像参数说明 t
       Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamByID;
  --功能16：修改ID对应的参数级别
  Procedure p_ChangeAdjustByID(
    ID_In     影像参数说明.ID%Type,
	Adjust_In 影像参数说明.参数级别%Type) As
  Begin
    Delete From 影像参数取值 a Where a.参数id = ID_In;
    Update 影像参数说明 t Set t.参数级别 = Adjust_In Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_ChangeAdjustByID;

  --功能17：获得对应参数标识的参数取值信息
  Procedure p_GetValueBySign(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.id, t.参数id, t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueBySign;

  --功能18：修改ID对应的参数信息的默认值
  Procedure p_EditDaultValue(
    ID_In     影像参数说明.ID%Type,
	默认值_In 影像参数说明.默认值%Type) As
  Begin
    Update 影像参数说明 t Set t.默认值 = 默认值_In Where t.id = ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_EditDaultValue;

  --功能19：通过部门获得人员信息
  Procedure p_GetUserByDID(
    Val Out t_Refcur,
	DID_In 部门人员.部门ID%Type
	) As
  Begin
    Open Val For
      Select ID, t.编号, t.姓名, t.简码, t.身份证号
        From 人员表 t
       Where t.id In
             (Select a.人员id From 部门人员 a Where a.部门id = DID_In);
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetUserByDID;
  --功能20：通过参数ID号获取影像参数取值信息
  Procedure p_GetParamValue1(
    Val Out t_Refcur,
	参数ID_In 影像参数取值.参数ID%Type
	) As
    paramLevel number := -1;
    paramPiont nvarchar2(50);
    paramCount number := -1;
  Begin
    Select a.参数级别
      Into paramLevel
      From 影像参数说明 a
     Where a.id = 参数ID_In
       And rownum <= 1;
    If paramLevel = 1 then
      Select Count(t.id)
        into paramCount
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      Select t.参数标识
        into paramPiont
        From 影像参数取值 t
       Where t.参数id = 参数ID_In;
      IF paramCount <> 0 and
         Replace(translate(paramPiont, '0123456789', '0'), '0', '') IS NULL THEN
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 (Select a.标题
                    From zlprograms a
                   Where a.序号 = t.参数标识
                     And rownum <= 1) As 参数标识,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      Else
        Open Val For
          Select RawToHex(ID) ID,
                 RawToHex(参数ID) 参数ID,
                 t.参数标识,
                 t.参数值
            From 影像参数取值 t
           Where t.参数id = 参数ID_In;
      End if;
    Elsif paramLevel = 2 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               (Select a.名称
                  From 部门表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Elsif paramLevel = 3 Then
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               (Select a.姓名
                  From 人员表 a
                 Where a.id = t.参数标识
                   And rownum <= 1) As 参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    Else
      Open Val For
        Select RawToHex(ID) ID,
               RawToHex(参数ID) 参数ID,
               t.参数标识,
               t.参数值
          From 影像参数取值 t
         Where t.参数id = 参数ID_In;
    End If;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValue1;
  --功能21:通过ID获得参数取值
  Procedure p_GetParamValueByCID(
    Val Out t_Refcur,
	CID_In 影像参数取值.参数ID%Type
	) As
  Begin
    Open Val For
      Select t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = CID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetParamValueByCID;

  --功能22:通过ID获得模块号的参数取值
  Procedure p_GetValueLevel0(
    Val Out t_Refcur,
	参数ID_In   影像参数取值.参数ID%Type,
	参数标识_In 影像参数取值.参数标识%Type
	) As
  Begin
    Open Val For
      Select t.参数标识, t.参数值
        From 影像参数取值 t
       Where t.参数id = 参数ID_In
         And t.参数标识 = 参数标识_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetValueLevel0;
End b_PACS_RptParam;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_PACS_RptPluginOriginal Is
  Type t_Refcur Is Ref Cursor;

  -- 功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
  );

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     In varchar2,
    EditorType_In Number := 0 --0:PACS报告编辑器，1--电子病历编辑器，2--报告文档编辑器
    );

  --功    能：根据医嘱ID获取检查信息
  Procedure p_GetStudyInfoByAdviceId(
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  );

  --功    能：获取报告图像总数
  Procedure p_GetReportImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2
  );

  --功    能：获取报告图像数据
  Procedure p_GetReportImageData(
    Val         Out t_Refcur,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number
  );

  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2,
    是否临时_In In number:=0
  );

  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
  );

  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val         Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
  );

  --功能;获取图像备注
  procedure P_Get_NormalNote(
    Val         Out t_Refcur
  );

  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in in 影像字典内容.名称%Type,
    code_In 影像字典内容.简码%Type
  );

  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
    num_In  影像字典内容.编号%Type
  );

  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
  );

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
  );
  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  );

  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2,
    user_In nvarchar2
  );

  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2
  );

  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2,
    user_In nvarchar2
  );

  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
    user_In nvarchar2
  );
  
  --功能：根据图像UID获取检查信息
  Procedure p_GetStudyInfoByImageUID(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    图像UID_In In 影像检查图象.图像UID%Type
  );
  
  --功能：根据检查UID获取FTP信息
  Procedure p_GetFtpinfoByStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  );
  
  --功能：根据科室ID获取FTP信息
  Procedure p_GetFtpinfoByDeptId(
    Val Out t_Refcur,
    科室ID_In In 影像流程参数.科室ID%Type
  );
  
  --功能：根据医嘱ID获取FTP信息
  Procedure p_GetFtpinfoByAdvicetId(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type
  );
  
  --功能：获取检查UID
  Procedure p_GetStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  );
  
  --功能：获取序列UID
  Procedure p_GetSeriesUID(
    Val Out t_Refcur,
    序列UID_In In 影像检查序列.序列UID%Type
  );
  
  --功能：根据设备号获取设备信息
  Procedure p_GetDeviceInfo(
    Val Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  );
  
  --获取医技站存储设备号
  Procedure p_GetDeviceIdByAdviceId(
    Val Out t_Refcur,
    医嘱ID_In In 病人医嘱发送.医嘱ID%Type
  );
End b_PACS_RptPluginOriginal;
/

--影像报告范文管理(---实现部分---)***************************************************
CREATE OR REPLACE Package Body b_PACS_RptPluginOriginal Is

  --功    能：获取历史报告记录
  Procedure p_GetReportHistory(
    Val                   Out t_Refcur,
    医嘱id_In             In 病人医嘱记录.ID%Type,
    人员id_In             In 部门人员.人员id%Type,
    当前科室id_In         In 部门人员.部门ID%Type,
    查看其他科历史报告_In In number := 0
  ) Is
    strSql     varchar2(4000);
    strSqlBack varchar2(4000);
    strFilter  varchar2(400);
  Begin
    If 查看其他科历史报告_In = 1 Then
      strFilter := ' ';
    Else
      strFilter := ' And c.执行科室id+0 in (select 部门id from 部门人员 where 人员id = '|| 人员id_In ||
                   ' union all select to_Number(' || 当前科室id_In || ') from dual) ';
    End If;

    strSql := 'Select 2 as 报告类型, f.编码'||'||''-''||'||'f.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别,b.创建人 as 报告人,' ||
              'to_char(b.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间,b.文档标题 报告名称, c.医嘱内容, TO_CHAR(RAWTOHEX(b.id)) 报告ID ' ||
              'From 影像检查记录 A, 影像报告记录 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 部门表 F ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id =' ||
              医嘱id_In || ' And e.执行科室ID = F.ID And b.医嘱id = c.Id And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null ' || strFilter ||
              ' union all ' ||
              'Select 1 as 报告类型, g.编码'||'||''-''||'||'g.名称 As 科室名称, c.Id As 医嘱id, a.影像类别 as 类别, a.报告人, ' ||
              'to_char(f.创建时间,''yyyy-mm-dd hh24:mi:ss'') as 创建时间, a.影像类别||''报告'' 报告名称, c.医嘱内容,TO_CHAR( b.病历id) as 报告ID ' ||
              'From 影像检查记录 A, 病人医嘱报告 B, 病人医嘱记录 C, 影像检查记录 D, 病人医嘱记录 E, 电子病历记录 F, 部门表 G ' ||
              'Where a.医嘱id = b.医嘱id And d.医嘱id = e.Id And e.Id = ' ||
              医嘱id_In || ' And e.执行科室ID = g.ID And b.医嘱id = c.Id And b.病历ID Is Not Null And ' ||
              '(c.病人id = e.病人id Or a.关联id = d.关联id) And c.相关id Is Null And b.病历id = f.id ' || strFilter;

    strSqlBack := strSql;
    strSqlBack := replace(strSqlBack, '影像检查记录', 'H影像检查记录');
    strSqlBack := replace(strSqlBack, '病人医嘱报告', 'H病人医嘱报告');
    strSqlBack := replace(strSqlBack, '病人医嘱记录', 'H病人医嘱记录');

    strSql := strSql || ' UNION ALL ' || strSQLBack || ' Order By 创建时间 Asc';

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportHistory;

  --功    能：获取对应报告内容
  Procedure p_GetReportContent(
    Val           Out t_Refcur,
    报告ID_In     varchar2,
    EditorType_In Number := 0 --0:电子病历编辑器，1--PACS报告编辑器，2--报告文档编辑器
    ) Is
    strSql varchar2(1000);
  Begin
    If EditorType_In = 1 Then
      strSql := 'Select a.内容文本 As 标题, b.对象属性, b.内容文本 As 正文,b.开始版 as 版本 From 电子病历内容 a,电子病历内容 b ' ||
                'Where a.文件id = ' || 报告ID_In ||
                ' And a.对象类型 = 3 And a.Id = b.父ID And b.对象类型 = 2 and b.终止版=0 ';
    ElsIf EditorType_In = 0 Then
      strSql := 'select 内容 from 电子病历格式 where 文件ID=' || 报告ID_In;
    Else
      strSql := 'Select 报告内容 As 内容 From 影像报告记录 Where ID=HexToRaw(''' ||
                报告ID_In || ''')';
    End If;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportContent;

  --功    能：根据医嘱ID获取检查信息
  Procedure p_GetStudyInfoByAdviceId(
    Val       Out t_Refcur,
    医嘱id_In In 影像检查记录.医嘱id%Type
  ) Is
    strSql varchar2(100);
  Begin
    strSql := 'Select 检查UID,报告图象,接收日期,检查号,姓名,性别,年龄 from 影像检查记录 where 医嘱ID =' || 医嘱id_In;
    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyInfoByAdviceId;

  --功    能：获取报告图像总数
  Procedure p_GetReportImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2
  ) Is
  Begin
    Open Val For
      Select Count(B.Column_Value) 返回值
      From 影像检查记录 A, Table(Cast(f_Str2list(Replace(A.报告图象,';',',')) As zlTools.t_Strlist)) B Where 医嘱ID = 查询条件_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetReportImageCount;

  --功    能：获取报告图像数据
  Procedure p_GetReportImageData(
    Val         Out t_Refcur,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number
  ) Is
  Begin
    Open Val For
         Select * from (Select rownum as 顺序号, rownum as 图像号, B.FTP用户名 As User1,B.FTP密码 As Pwd1,B.IP地址 As Host1,'/'||B.Ftp目录||'/' As Root1,
          Decode(A.接收日期,Null,'',to_Char(A.接收日期,'YYYYMMDD')||'/')||A.检查UID||'/'||Replace(Trim(D.Column_Value),'.jpg','') As URL,B.设备号 as 设备号1,
          C.FTP用户名 As User2,C.FTP密码 As Pwd2,C.IP地址 As Host2,'/'||C.Ftp目录||'/' As Root2,
          C.设备号 as 设备号2,Replace(Trim(D.Column_Value),'.jpg','') AS 图像UID,A.检查UID,'' 序列UID,0 动态图,'' 编码名称,'' 采集时间, '' 录制长度
          From 影像检查记录 A, 影像设备目录 B, 影像设备目录 C, Table(Cast(f_Str2list(Replace(A.报告图象,';',',')) As zlTools.t_Strlist)) D
          Where A.位置一 = B.设备号(+) And A.位置二 = C.设备号(+) And A.医嘱id = 查询条件_In)
          Where 顺序号 >= 开始位置_In and 顺序号<=结束位置_In;

  End p_GetReportImageData;

  --功    能：获取预览图像总数
  Procedure p_GetStudyImageCount(
    Val Out t_Refcur,
    查询条件_In In varchar2,
    是否临时_In In number:=0
  ) Is
    strSql varchar2(2000);
  Begin
    if 是否临时_In = 0 then
      strSql := 'select T1.返回值+T2.返回值 as 返回值 from ' ||
              '(select count(1) as 返回值 from 影像检查图象 a, 影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T1,' ||
              '(select count(1) as 返回值 from H影像检查图象 a, H影像检查序列 b, 影像检查记录 c ' ||
              'where a.序列UID=b.序列UID and b.检查UID=c.检查UID and c.医嘱ID=''' ||
              查询条件_In || ''') T2';
    else
      strSql := 'select count(1)  as 返回值 from 影像临时图象  where  序列UID='''||查询条件_In || '''';
    end if;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageCount;

  --功    能：获取预览图像数据
  Procedure p_GetStudyImageData(
    Val         Out t_Refcur,
    查询方式_In In varchar2,
    查询条件_In In varchar2,
    开始位置_In In number,
    结束位置_In In number,
    是否临时_In In number
  ) Is
    strSql    varchar2(2000);
    strFilter varchar2(100);
  Begin
    if 查询方式_In = 0 then
      strFilter := 'and c.医嘱ID=''' || 查询条件_In || '''';
    elsif 查询方式_In = 1 then
      strFilter := 'and B.序列UID=''' || 查询条件_In || '''';
    else
      strFilter := 'and A.图像UID=''' || 查询条件_In || '''';
    end if;

    strSql := 'Select * from (Select rownum as 顺序号, T.* from(' ||
              'Select A.图像号,D.FTP用户名 As User1,D.FTP密码 As Pwd1,D.IP地址 As Host1,''/''||D.Ftp目录||''/'' As Root1,' ||
              'Decode(C.接收日期,Null,'''',to_Char(C.接收日期,''YYYYMMDD'')||''/'')||C.检查UID||''/''||A.图像UID As URL,d.设备号 as 设备号1,' ||
              'E.FTP用户名 As User2,E.FTP密码 As Pwd2,E.IP地址 As Host2,''/''||E.Ftp目录||''/'' As Root2,' ||
              'e.设备号 as 设备号2, A.图像UID,C.检查UID,B.序列UID,A.动态图,A.编码名称,A.采集时间, A.录制长度 ' ||
              'From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像设备目录 D,影像设备目录 E ' ||
              'Where A.序列UID=B.序列UID And B.检查UID=C.检查UID And C.位置一=D.设备号(+) And C.位置二=E.设备号(+) ' ||
              strFilter || ' '|| 'Order by 序列UID, 图像号) T ) ' ||
              'Where 顺序号>=' || 开始位置_In || ' and 顺序号<=' || 结束位置_In || '';

    if 是否临时_In = 1 then
      strSql:= replace(strSql,'影像检查','影像临时');
    end if;

    Open Val For strSql;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyImageData;

  --功能：获取临时图像序列
  Procedure p_Get_TempImageSeries(
    Val Out t_Refcur,
    时间范围_In In Number,
    姓名_In In 影像临时记录.姓名%Type:=null
  ) As
  Begin
    If 姓名_In Is Null Then
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate
        order by 序号;
    Else
      Open Val For
        select B.序列UID,A.姓名,A.检查号 As 序号, A.接收日期 from 影像临时记录 A,影像临时序列 B
        where A.检查uid = B.检查uid And A.接收日期 Between Sysdate-时间范围_In And Sysdate and a.姓名 = 姓名_In
        order by 序号;
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：获取图像备注
  Procedure p_Get_Normalnote(
    Val Out t_Refcur
  ) As
  Begin
    Open Val For
      Select b.编号 As 编号, b.名称 As 名称
        From 影像字典清单 A, 影像字典内容 B
       Where a.Id = b.字典id
         And a.名称 = '影像图像备注';
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End;

  --功能：插入常用图像备注
  Procedure p_Insert_Normalnote(
    note_in In 影像字典内容.名称%Type,
    code_In 影像字典内容.简码%Type
  ) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Select Decode(Max(to_number(编号)), Null, 0, Max(to_number(编号)))
      Into n_Num
      From 影像字典内容
     Where 字典id = dictionary_id;
    n_Num := n_Num + 1;
    Insert Into 影像字典内容
      (字典id, 编号, 名称, 说明)
    Values
      (dictionary_id, to_char(n_Num), note_in, '影像图像备注');
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Insert_Normalnote;

  --功能：修改常用图像备注
  Procedure p_Edit_Normalnote(
    note_in In 影像字典内容.名称%Type,
    num_In  影像字典内容.编号%Type
  ) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Update 影像字典内容 t
       Set t.名称 = note_in
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Edit_Normalnote;

  --功能：删除常用图像备注
  Procedure p_Del_Normalnote(
    num_In 影像字典内容.编号%Type
  ) As
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Delete 影像字典内容 t
     Where t.字典id = dictionary_id
       And t.编号 = num_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Del_Normalnote;

  --功能：获取备注的下一个编码
  Procedure p_Get_NormalNum(
    Val Out t_Refcur
  ) As
    n_Num         Number;
    dictionary_id Varchar2(36);
  Begin
    Select id
      Into dictionary_id
      From 影像字典清单
     Where 说明 = '影像图像备注';
    Open Val For
      Select Decode(Max(to_number(编号)), Null, 1, Max(to_number(编号) + 1)) 编号
        From 影像字典内容 t
       Where t.字典id = dictionary_id;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_NormalNum;

  --功能：获取插件ID
  Procedure p_Get_PlugID(
    Val     Out t_Refcur,
    类名_In In 影像报告插件.类名%Type
  ) Is
  Begin
    Open Val For
      Select RawToHex(ID) ID From 影像报告插件 Where 类名 = 类名_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_Get_PlugID;

  --功能：插入编辑器字体参数
  Procedure p_SetFontParam(
    font_In nvarchar2,
    user_In nvarchar2
  ) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = font_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, font_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFontParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFontParam(
    Val Out t_Refcur,
    user_In nvarchar2
  ) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '字体设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFontParam;

  --功能：插入编辑器窗体参数
  Procedure p_SetFormParam(
    form_In nvarchar2,
    user_In nvarchar2
  ) As
    m_ID     nvarchar2(36);
    numcount int;
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Select Count(*)
      Into numcount
      From 影像参数取值 t
     Where t.参数id = m_ID
       And t.参数标识 = user_In;
    If numcount > 0 then
      Update 影像参数取值 a
         Set a.参数值 = form_In
       Where a.参数标识 = user_In
         And a.参数id = m_ID;
    Else
      Insert Into 影像参数取值 a
        (ID, 参数ID, 参数标识, 参数值)
      Values
        (sys_Guid(), m_ID, user_In, form_In);
    End If;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_SetFormParam;

  --功能：获取编辑器字体参数
  Procedure p_GetFormParam(
    Val Out t_Refcur,
    user_In nvarchar2
  ) As
    m_ID nvarchar2(36);
  Begin
    Select RawToHex(ID)
      Into m_ID
      From 影像参数说明
     Where 模块 = 'ImageEditor'
       And 参数名 = '窗口设置';
    Open Val For
      Select a.参数值
        From 影像参数取值 a
       Where a.参数id = m_ID
         And a.参数标识 = user_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFormParam;
  
  --功能：根据图像UID获取检查信息
  Procedure p_GetStudyInfoByImageUID(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type,
    图像UID_In In 影像检查图象.图像UID%Type
  )As
  Begin
    Open Val For
      Select D.检查UID From 影像检查图象 A,影像检查序列 B,影像检查记录 C,影像临时序列 D
      Where C.医嘱ID=医嘱ID_In And A.图像UID=图像UID_In And A.序列UID=B.序列UID And B.检查UID=C.检查UID And A.序列UID = D.序列UID;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyInfoByImageUID;
  
  --功能：根据检查UID获取FTP信息
  Procedure p_GetFtpinfoByStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  )As
  Begin
    Open Val For
      Select D.FTP用户名 As FtpUser,D.FTP密码 As FtpPwd,C.位置一,C.位置二,C.位置三,C.接收日期,
      D.IP地址 As Host,'/'||D.Ftp目录||'/' As Root,Decode(C.接收日期,Null,'',to_Char(C.接收日期,'YYYYMMDD')||'/')||C.检查UID As URL
      From 影像检查记录 C,影像设备目录 D Where Decode(C.位置一,Null,C.位置二,C.位置一)=D.设备号(+) And C.检查UID= 检查UID_In Union All
      Select D.FTP用户名 As FtpUser,D.FTP密码 As FtpPwd,C.位置一,C.位置二,C.位置三,C.接收日期,
      D.IP地址 As Host,'/'||D.Ftp目录||'/' As Root,Decode(C.接收日期,Null,'',to_Char(C.接收日期,'YYYYMMDD')||'/')||C.检查UID As URL
      From 影像临时记录 C,影像设备目录 D Where Decode(C.位置一,Null,C.位置二,C.位置一)=D.设备号(+) And C.检查UID= 检查UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByStudyUID;
  
  --功能：根据科室ID获取FTP信息
  Procedure p_GetFtpinfoByDeptId(
    Val Out t_Refcur,
    科室ID_In In 影像流程参数.科室ID%Type
  )As
  Begin
    Open Val For
      Select a.设备号, a.ip地址, a.ftp用户名, a.ftp密码 From 影像设备目录 a, 影像流程参数 b
      Where a.设备号 = b.参数值 And b.参数名 = '存储设备号' And b.科室id=科室ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByDeptId;
  
  --功能：根据医嘱ID获取FTP信息
  Procedure p_GetFtpinfoByAdvicetId(
    Val Out t_Refcur,
    医嘱ID_In In 影像检查记录.医嘱ID%Type
  )As
  Begin
    Open Val For
      Select a.设备号, a.ip地址, a.ftp用户名, a.ftp密码 From 影像设备目录 a, 影像检查记录 b 
      Where b.位置一 = a.设备号(+) And b.医嘱id =医嘱ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetFtpinfoByAdvicetId;
  
  --功能：获取检查UID
  Procedure p_GetStudyUID(
    Val Out t_Refcur,
    检查UID_In In 影像检查记录.检查UID%Type
  )As
  Begin
    Open Val For
      Select 检查UID from 影像检查记录 where 检查UID = 检查UID_In Union All Select 检查UID from 影像临时记录 where 检查UID = 检查UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetStudyUID;
  
  --功能：获取序列UID
  Procedure p_GetSeriesUID(
    Val Out t_Refcur,
    序列UID_In In 影像检查序列.序列UID%Type
  )As
  Begin
    Open Val For
      Select 序列UID from 影像检查序列 where 序列UID = 序列UID_In Union All Select 序列UID from 影像临时序列 where 序列UID = 序列UID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetSeriesUID;
  
  --功能：根据设备号获取设备信息
  Procedure p_GetDeviceInfo(
    Val Out t_Refcur,
    设备号_In In 影像设备目录.设备号%Type
  )As
  Begin
    Open Val For
      Select 设备号,设备名,'/'||Decode(Ftp目录,Null,'',Ftp目录||'/') As URL,FTP用户名,FTP密码,IP地址
      From 影像设备目录 Where 类型=1 and 设备号=设备号_In and NVL(状态,0)=1;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDeviceInfo;
  
  --获取医技站存储设备号
  Procedure p_GetDeviceIdByAdviceId(
    Val Out t_Refcur,
    医嘱ID_In In 病人医嘱发送.医嘱ID%Type
  )As
  Begin
    Open Val For
      Select d.参数值 From 医技执行房间 a, 病人医嘱发送 b, 影像DICOM服务对 c, 影像DICOM服务参数 d
      Where a.科室ID = b.执行部门id And a.执行间 = b.执行间 And a.检查设备 = c.设备号
      And c.服务功能='图像接收' And c.服务ID=d.服务ID And d.参数名称='存储设备' And b.医嘱id=医嘱ID_In;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End p_GetDeviceIdByAdviceId;
End b_PACS_RptPluginOriginal;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
Create Or Replace Package b_PACS_RptPublic Is
  Type t_Strlist Is Table Of Varchar2(4000);
  --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
  Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
    ) Return t_Strlist
    Pipelined;

  --功能:跟据传入的表名称提取表中最大的Code并递增
  Function f_Get_Nextcode(
    Tablename_In Varchar2,
    Len_In       Number := 0,
    Mount_In     Number := 0,
    Pre_In       Varchar2 := Null
    ) Return Varchar2;

  --功能：生成字符串拼音首码
  Function f_Spellcode(
    v_Instr  In Varchar2,
    v_Outnum In Integer := 10
    ) Return Varchar2;

  --错误处理中心
  Procedure zl_ErrorCenter(
    Err_Num In Number,
    Err_Msg In Varchar2
    );

 --从传入的XML中提取编辑记录
  Function f_Geteditlist(
    Content_In In Xmltype
	) Return t_Editlist;

  Function Xml2clob(
    Xml_In Xmltype
	) Return Clob;

  Function f_Getlastedit(
    Content_In In Xmltype
	) Return t_Editlist;
  
  ----拆分匿名数据
  --Function f_Disjoin_Anonym
  --(
    --Content_In    In Xmltype,
    --x_Anonym_Data Out Xmltype
  --) Return Xmltype;

  ----合并匿名数据
  --Function f_Incorporate_Anonym
  --(
    --Content_In    In Xmltype,
    --x_Anonym_Data In Xmltype
  --) Return Clob;

  --设置XML的节点值,当节点为<ele></ele>此类闭合节点时，Updatexml函数无效
  Procedure p_Set_Elementtext(
    Texture In Out Xmltype,
    Ename   In Varchar2,
    Eaname  In Varchar2,
    Eatext  In Varchar2,
    Etext   In Varchar2
    );
  --根据子文档ID提取子文档当前状态
 Function f_Get_Docstatus(
    Content_In In Xmltype
    ) Return Varchar2;

  Function f_If_Intersect(
    Str1 Varchar2,
    Str2 Varchar2
    ) Return Number;

End b_PACS_RptPublic;
/

Create Or Replace Package Body b_PACS_RptPublic Is

  Function Xml2clob(
    Xml_In Xmltype
	) Return Clob As
  Begin
    Return Xml_In.Getclobval();
  End Xml2clob;

  Function f_Str2list(
    Str_In   In Varchar2,
    Split_In In Varchar2 := ','
  ) Return t_Strlist
    Pipelined As
    v_Str Long;
    P     Number;
    --功能：将由逗号分隔的不带引号的字符序列转换为单列数据表
    --参数：Str_In,如:甲抗,胃溃疡,胃出血...,Split_In,分隔符,缺省为,号
    --说明：
    --1．当SQL语句中涉及“IN(常量1, 常量2,…) ”子句时使用这种方式以便利用绑定变量。
    --2．使用这两个函数时，需要在SQL语句中加入“/*+ Rule*/”提示，因为Cbo下临时内存表没有统计数据,。
    --3．两种调用示例
    --Select /*+ Rule*/ * From Sample_List Where Title In (Select * From Table(f_Str2list('甲抗,胃溃疡,胃出血'));
    --Select /*+ Rule*/ A.* From Sample_List A, Table(f_Str2list('甲抗,胃溃疡,胃出血')) B Where A.Title = B.Column_Value;
  Begin
    If Str_In Is Null Then
      Return;
    End If;
    v_Str := Str_In || Split_In;
    Loop
      P := Instr(v_Str, Split_In);
      Exit When(Nvl(P, 0) = 0);
      Pipe Row(Trim(Substr(v_Str, 1, P - 1)));
      v_Str := Substr(v_Str, P + 1);
    End Loop;
    Return;
  End;

  Function f_Get_Nextcode(
    Tablename_In Varchar2,
    Len_In       Number := 0,
    Mount_In     Number := 0,
    Pre_In       Varchar2 := Null
  ) Return Varchar2 Is
    --跟据传入的表名称提取表中最大的Code并递增
    --Len_In        当指定长度时，按指定长度最大Code递增，大于表字段长度或不传时为表字段长度
    --Mount_In      当指定长度时，最大Code每位不能再进位时是否扩容长度，=0不扩容，＝1扩容 比如当前最大Code为 Z99,如果扩容则返回1A00否则返回Z99
    --递增规则：数字0123456789 字母A...Z,递增到达9或Z时前一位增长并且当前位转为0或A，如果前一个为非数字或字母则向前一位递增
    --字母全部为大写，无小写,当无指定长度Code时返回指定长度01，比如指定长度为5，则返回 00001
    v_Sql      Varchar2(100);
    v_Maxcode  Varchar2(150);
    v_Origcode Varchar2(150);
    v_Old      Varchar2(6);
    v_New      Varchar2(6);
    v_Return   Varchar2(150);
    n_Collen   Number;
    n_Length   Number;
    Err_Custom Exception;
    v_Msg Varchar2(200);
    Function f_Char_Carry(Word_In Varchar2) Return Varchar2 As
      v_Temp Varchar2(6);
      n_Asc  Number;
    Begin
      Select Ascii(Upper(Word_In)) Into n_Asc From Dual;
      If n_Asc = 57 Then
        v_Temp := '0';
      Elsif n_Asc = 90 Then
        v_Temp := 'A';
      Elsif n_Asc >= 48 And n_Asc <= 56 Or n_Asc >= 65 And n_Asc <= 89 Then
        v_Temp := Chr(Ascii(Word_In) + 1);
      Else
        v_Temp := Word_In;
      End If;
      Return v_Temp;
    End;
  Begin
    Begin
      Select Data_Length
      Into n_Collen
      From User_Tab_Cols
      Where Table_Name = Upper(Tablename_In) And Upper(Column_Name) = '编码';
    Exception
      When Others Then
        Null;
        v_Msg := '没有当前要查找的表，或表中没有【编码】字段！';
        Raise Err_Custom;
    End;
  
    --当传入长度为0或大于字段长度时取当前最大长度，否则取传入长度相当的最大编码
    If Len_In = 0 Or Len_In > n_Collen Then
      v_Sql := 'Select Max(Length(编码)) From ' || Tablename_In;
      Execute Immediate v_Sql
        Into n_Length;
    Else
      n_Length := Len_In;
    End If;
  
    If Nvl(n_Length, 0) = 0 Then
      Return '1';
    End If;
    
    If (Pre_In Is Not Null) And Length(Pre_In) >= n_Length Then
      v_Msg := '指定编码的长度应该大于前缀长度';
      Raise Err_Custom;
    End If;
  
    --查找指定前缀编码的最大值
    If Pre_In Is Not Null Then
      v_Sql := 'Select Max(编码) From ' || Tablename_In || ' Where upper(substr(code,1,length(''' || Pre_In ||
               '''))) =' || '' || 'upper(''' || Pre_In || ''')';
      Execute Immediate v_Sql
        Into v_Maxcode;
    Else
      v_Sql := 'Select Max(编码) From ' || Tablename_In || ' Where Length(编码)=' || n_Length;
      Execute Immediate v_Sql
        Into v_Maxcode;
    End If;
  
    --如果最大的code为空，那么赋值为1,前面增加0的数量由最长长度决定
    If v_Maxcode Is Null Then
      If Pre_In Is Null Then
        Select LPad('1', n_Length, '0') Into v_Maxcode From Dual;
        Return v_Maxcode;
      Else
        Select Pre_In || LPad('1', n_Length - Length(Pre_In), '0') Into v_Maxcode From Dual;
        Return v_Maxcode;
      End If;
    Else
      If Pre_In Is Null Then
        v_Maxcode  := Upper(v_Maxcode);
        v_Origcode := v_Maxcode;
      Else
        --补充为指定长度
        v_Maxcode := Upper(Pre_In || LPad(Substr(v_Maxcode, Length(Pre_In) + 1), n_Length - Length(Pre_In), '0'));
        --指定前缀时，仅以前缀后的字符串作为计算的值
        v_Origcode := Substr(v_Maxcode, Length(Pre_In) + 1);
        v_Maxcode  := v_Origcode;
      End If;
      
      For I In 0 .. Length(v_Maxcode) Loop
        If I = Length(v_Maxcode) Then
          If Len_In <> 0 And Mount_In = 0 Then
            --指定长度并且不扩容长度，已在到最大时，不再进位
            Return v_Origcode;
          Else
            v_Old := 'Z';
            v_New := '1';
          End If;
        Else
          v_Old := Substr(v_Maxcode, Length(v_Maxcode) - I, 1);
          v_New := f_Char_Carry(v_Old);
        End If;
      
        --新旧值相等表明为非数字或字母,需要向前查找
        If v_Old != v_New Then
          v_Return := Substr(v_Maxcode, 0, Length(v_Maxcode) - I - 1) || v_New ||
                      Substr(v_Maxcode, Length(v_Maxcode) - I + 1);
          If v_New != '0' And v_New != 'A' Then
            If Pre_In Is Null Then
              Return v_Return;
            Else
              Return Pre_In || v_Return;
            End If;
          Else
            --等于‘0’表明当前进位,前一位递增
            v_Maxcode := v_Return;
          End If;
        End If;
      End Loop;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

  --功能：生成字符串拼音首码
  --参数：v_Instr需要生成拼音的字符串；v_Outnum 生成首码长度，默认10，超过40个字符最大10
  Function f_Spellcode(
    v_Instr  In Varchar2,
    v_Outnum In Integer := 10
  ) Return Varchar2 Is
    v_Spell     Varchar2(40);
    v_Input     Varchar2(1000);
    v_Bitchar   Varchar2(100);
    r_Bitchar   Varchar2(100);
    v_Bitnum    Integer;
    v_Outmaxnum Integer;
    Function f_Nlssort(p_Word In Varchar2) Return Varchar2 As
    Begin
      Return Nlssort(p_Word, 'NLS_SORT=SCHINESE_PINYIN_M');
    End;
  Begin
    If v_Outnum < 1 Or v_Outnum > 40 Then
      v_Outmaxnum := 10;
    Else
      v_Outmaxnum := v_Outnum;
    End If;
  
    If v_Instr Is Null Or Length(LTrim(v_Instr)) = 0 Then
      v_Spell := '';
    Else
      v_Input := Upper(v_Instr);
      v_Spell := '';
      For v_Bitnum In 1 .. Length(v_Input) Loop
        v_Bitchar := Substr(v_Input, v_Bitnum, 1);
        r_Bitchar := f_Nlssort(v_Bitchar);
        If r_Bitchar >= f_Nlssort('吖') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'A';
        Elsif r_Bitchar >= f_Nlssort('八') And r_Bitchar <= f_Nlssort('簿') Then
          v_Spell := v_Spell || 'B';
        Elsif r_Bitchar >= f_Nlssort('嚓') And r_Bitchar <= f_Nlssort('e') Then
          v_Spell := v_Spell || 'C';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('z') Then
          v_Spell := v_Spell || 'D';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'E';
        Elsif r_Bitchar >= f_Nlssort('发') And r_Bitchar <= f_Nlssort('g') Then
          v_Spell := v_Spell || 'F';
        Elsif r_Bitchar >= f_Nlssort('旮') And r_Bitchar <= f_Nlssort('B') Then
          v_Spell := v_Spell || 'G';
        Elsif r_Bitchar >= f_Nlssort('o') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'H';
        Elsif r_Bitchar >= f_Nlssort('丌') And r_Bitchar <= f_Nlssort('h') Then
          v_Spell := v_Spell || 'J';
        Elsif r_Bitchar >= f_Nlssort('咔') And r_Bitchar <= f_Nlssort('i') Then
          v_Spell := v_Spell || 'K';
        Elsif r_Bitchar >= f_Nlssort('垃') And r_Bitchar <= f_Nlssort('^') Then
          v_Spell := v_Spell || 'L';
        Elsif r_Bitchar >= f_Nlssort('`') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'M';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'N';
        Elsif r_Bitchar >= f_Nlssort('p') And r_Bitchar <= f_Nlssort('a') Then
          v_Spell := v_Spell || 'O';
        Elsif r_Bitchar >= f_Nlssort('r') And r_Bitchar <= f_Nlssort('曝') Then
          v_Spell := v_Spell || 'P';
        Elsif r_Bitchar >= f_Nlssort('七') And r_Bitchar <= f_Nlssort('d') Then
          v_Spell := v_Spell || 'Q';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('U') Then
          v_Spell := v_Spell || 'R';
        Elsif r_Bitchar >= f_Nlssort('仨') And r_Bitchar <= f_Nlssort('R') Then
          v_Spell := v_Spell || 'S';
        Elsif r_Bitchar >= f_Nlssort('@') And r_Bitchar <= f_Nlssort('X') Then
          v_Spell := v_Spell || 'T';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('F') Then
          v_Spell := v_Spell || 'W';
        Elsif r_Bitchar >= f_Nlssort('夕') And r_Bitchar <= f_Nlssort('R') Then
          v_Spell := v_Spell || 'X';
        Elsif r_Bitchar >= f_Nlssort('丫') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'Y';
        Elsif r_Bitchar >= f_Nlssort('') And r_Bitchar <= f_Nlssort('') Then
          v_Spell := v_Spell || 'Z';
        Elsif Instr('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.+-*/', v_Bitchar) > 0 Then
          v_Spell := v_Spell || v_Bitchar;
        Elsif Instr('ⅠⅡⅢⅣⅤⅥⅦⅧⅨ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || Chr(Ascii(v_Bitchar) - 41664);
        Elsif Instr('ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || Chr(Ascii(v_Bitchar) - 41856);
        Elsif Instr('Αα', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'A';
        Elsif Instr('Ββ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'B';
        Elsif Instr('Γγ', v_Bitchar) > 0 Then
          v_Spell := v_Spell || 'G';
        End If;
        Exit When Length(v_Spell) > Nvl(v_Outmaxnum, 40) - 1;
      End Loop;
    End If;
    Return(v_Spell);
  End;

  Procedure zl_ErrorCenter(
    Err_Num In Number,
    Err_Msg In Varchar2
  ) Is
    v_Outnum Number := 0;
    v_Outmsg Varchar2(1000) := '';
    v_Temp   Varchar2(1000) := '';
  
    Cursor Cur_Ind_Cols Is
      Select Table_Name, Column_Name From All_Ind_Columns Where Instr(Err_Msg, Index_Owner || '.' || Index_Name) > 0;
  
    Cursor Cur_Con_Cols Is
      Select Table_Name, Column_Name
      From All_Cons_Columns
      Where (Owner, Constraint_Name) =
            (Select r_Owner, r_Constraint_Name
             From All_Constraints
             Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 0 And Rownum < 2);
  Begin
    If Err_Num = -1 Then
      For Row_Cols In Cur_Ind_Cols Loop
        v_Temp   := Row_Cols.Table_Name;
        v_Outmsg := v_Outmsg || '、' || Row_Cols.Column_Name;
      End Loop;
    
      v_Outmsg := '[ZLSOFT]' || v_Temp || '的(' || Substr(v_Outmsg, 2) || ')出现重复！[ZLSOFT]';
      v_Outnum := -20000;
    Elsif Err_Num = -1000 Then
      v_Outmsg := '[ZLSOFT]打开的数据表太多，必要时请系统管理员修改数据库的Open_Cursors配置。';
      v_Outnum := -20001;
    Elsif Err_Num = -1400 Or Err_Num = -1407 Then
      Select Table_Name, Column_Name
      Into v_Temp, v_Outmsg
      From All_Tab_Columns
      Where Instr(Err_Msg, '"' || Owner || '"."' || Table_Name || '"."' || Column_Name || '"') > 0 And Rownum < 2;
      v_Outmsg := '[ZLSOFT]' || v_Temp || '的(' || v_Outmsg || ')必须输入！[ZLSOFT]';
      v_Outnum := -20002;
    Elsif Err_Num = -1401 Then
      v_Outmsg := '[ZLSOFT]由于赋予的值超过了列宽限制，导致增加或更新失败。[ZLSOFT]';
      v_Outnum := -20003;
    Elsif Err_Num = -2290 Then
      Select Table_Name, Search_Condition
      Into v_Temp, v_Outmsg
      From All_Constraints
      Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 1 And Rownum < 2;
    
      If Instr(v_Outmsg, 'IS NOT NULL') > 0 Then
        v_Outmsg := '[ZLSOFT]' || v_Temp || ' 的 ' || Replace(v_Outmsg, 'IS NOT NULL', '必须输入！') || '[ZLSOFT]';
        v_Outnum := -20004;
      Else
        v_Outmsg := Err_Msg;
        v_Outnum := -20999;
      End If;
    Elsif Err_Num = -2292 Then
      Select Table_Name
      Into v_Temp
      From All_Constraints
      Where Instr(Err_Msg, Owner || '.' || Constraint_Name) > 1 And Rownum < 2;
    
      For Row_Cols In Cur_Con_Cols Loop
        v_Outmsg := v_Outmsg || '、' || Row_Cols.Column_Name;
      End Loop;
    
      v_Outmsg := '[ZLSOFT]该记录在 ' || v_Temp || ' 中已经使用,' || Chr(13) || '不能删除或修改(' || Substr(v_Outmsg, 2) || ')[ZLSOFT]';
      v_Outnum := -20005;
    Else
      v_Outmsg := Err_Msg;
      v_Outnum := -20999;
    End If;
    Raise_Application_Error(v_Outnum, Substr(v_Outmsg, 1, 100));
  End zl_ErrorCenter;

  --从文档中提取的编辑记录
  Function f_Geteditlist(
    Content_In In Xmltype
	) Return t_Editlist As
    --提取文档编辑、签名及修订记录,返回格式可能如下（独立文档SUBIID为空）：
    --  Subiid  Subaid  编辑人  编辑时间             签名 审订签名
    --  AAAAAA  AID     Null    Null                 0    0     第一条用于表示创建记录
    --  AAAAAA  AID     张险华  2012-05-31 12:01:02  1    0
    --  AAAAAA  AID     韩洪    2012-05-31 12:05:02  0    0
    --  AAAAAA  AID     韩洪    2012-05-31 12:06:02  1    1
    --  AAAAAA  AID     韩洪    2012-05-31 12:07:02  0    0
    --  AAAAAA  AID     张险华  2012-05-31 12:08:02  0    0
    --  AAAAAA  AID     张险华  2012-05-31 12:09:02  1    1
    --  BBBBBB............
    Content_c Clob;
    Xcdoc     Xmldom.Domdocument;
  
    Targetdoc Dbms_Xmldom.Domdocument;
  
    Signlist     Xmldom.Domnodelist;
    l_s          Number;
    n_Isnull     Number;
    Signname     Varchar2(64);
    Signtime     Date;
    Isaduit      Number(1);
    Xxdoc        Xmltype;
    Xaudit       Xmltype;
    Xa_Text      Xmltype;
    Textlist     Xmldom.Domnodelist;
    l_t          Number;
    Starttime    Date;
    Aftertime    Date;
    Aduitname    Varchar2(64);
    Aduittime    Date;
    Revisiontime Varchar2(20);
    Ts_Editlist  t_Editlist;
    Ta_Editlist  t_Editlist;
    r_Editlist   t_Editlist := t_Editlist();
    
    Function Sortbytime(t_e t_Editlist) Return t_Editlist Is
      Tm_List t_Editlist := t_Editlist();
    Begin
      For Rs In (Select * From Table(Cast(t_e As t_Editlist)) A Order By a.编辑时间) Loop
        Tm_List.Extend;
        Tm_List(Tm_List.Count) := t_Edits( Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
      End Loop;
      Return Tm_List;
    End Sortbytime;
    
  Begin
    If Content_In Is Null Then
      r_Editlist := t_Editlist();
      Return r_Editlist;
    End If;
    --图片可能会超过64K,单节点超过64K时Newdomdocument会宕机,Newdomdocument(clob)方式会偶尔导致"通信通道文件结束"
    Content_c := Xml2clob(Content_In);
    
    --独立文档,直接给文档赋值
    Xcdoc   := Xmldom.Newdomdocument(Content_c);
    
    Signlist    := Xmldom.Getelementsbytagname(Xcdoc, 'signature');
    l_s         := Xmldom.Getlength(Signlist);
    l_s         := Nvl(l_s, 0);
    Ts_Editlist := t_Editlist();
    
    --遍历所有签名记录
    For L In 0 .. l_s - 1 Loop
      --提取签名位；1-签名位；0-真实签名
      n_Isnull := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'isnull');
      
      If Nvl(n_Isnull, 0) = 0 Then
        --如果不是签名位，那就是一个真实签名
        --displayinfo 签名显示信息
        Signname := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'displayinfo');
        If Signname Is Not Null Then
          --“签名显示信息”不为空
          Select Substr(Signname, 1, Decode(Instr(Signname, ','), 0, Length(Signname) + 1, Instr(Signname, ',')) - 1)
          Into Signname
          From Dual;
          --signtime 签名时间
          Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'signtime');
          Signtime     := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
          --isaudit 审签标记
          Isaduit      := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Signlist, L)), 'isaudit');
          Isaduit      := Nvl(Isaduit, 0);
          Ts_Editlist.Extend;
          Ts_Editlist(Ts_Editlist.Count) := t_Edits( Signname, Signtime, 1, Isaduit);
        End If;
      End If;
    End Loop;
    
    Xxdoc := Xmldom.Getxmltype(Xcdoc);
    --遍历所有以新增或删除为标记的修订记录
    --ratag 修订新增标记,取值为系统登录账号名称;  rdtag 修订删除标记,取值为系统登录账号名称
    Xa_Text     := Xxdoc.Extract('//*[@ratag!=""]|//*[@rdtag!=""]');
    Xaudit      := Xmltype('<root></root>');
    Xaudit      := Xaudit.Appendchildxml('/root', Xa_Text);
    Textlist    := Xmldom.Getchildnodes(Xmldom.Getfirstchild(Xmldom.Makenode(Xmldom.Newdomdocument(Xaudit))));
    l_t         := Xmldom.Getlength(Textlist);
    Ta_Editlist := t_Editlist();
    For L In 0 .. l_t - 1 Loop
      --ratag 修订新增标记,取值为系统登录账号名称
      Aduitname := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'ratag');
      If Nvl(Aduitname, 'a') = 'a' Then
        --从ratag取不到值，说明是删除记录
        Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'rdtime');
        Aduittime    := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
        Aduitname    := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'rdtag');
      Else
        Revisiontime := Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(Textlist, L)), 'ratime');
        Aduittime    := To_Date(Revisiontime, 'yyyy-mm-dd hh24:mi:ss');
      End If;
      Ta_Editlist.Extend;
      Ta_Editlist(Ta_Editlist.Count) := t_Edits( Aduitname, Aduittime, 0, 0);
    End Loop;
    --先按时间排序
    Ts_Editlist := Sortbytime(Ts_Editlist);
    Ta_Editlist := Sortbytime(Ta_Editlist);
    --虚拟第一条用于表示创建记录
    r_Editlist.Extend;
    r_Editlist(r_Editlist.Count) := t_Edits( Null,
                                            To_Date('1945-08-06 09:16:02', 'yyyy-mm-dd hh24:mi:ss'), 0, 0);
    
    --当次签名与下次签名之间被认定为修订记录,重新生成编辑列表
    For L In 1 .. Ts_Editlist.Count Loop
      Starttime := Ts_Editlist(L).编辑时间;
      If L = Ts_Editlist.Count Then
        --只是作为审订时间在两次签名时间之间的判断参照，当循环到最后一次签名时，此参照失去意义,所以赋值可以大于当前系统时间
        Aftertime := Sysdate + 1;
      Else
        Aftertime := Ts_Editlist(L + 1).编辑时间;
      End If;
      r_Editlist.Extend;
      r_Editlist(r_Editlist.Count) := Ts_Editlist(L);
      
      Aduitname := 'A';
      For N In 1 .. Ta_Editlist.Count Loop
        Aduittime := Ta_Editlist(N).编辑时间;
        If Aduittime Between Starttime And Aftertime Then
          Starttime := Aduittime;
          If Aduitname <> Ta_Editlist(N).编辑人 Then
            --不同人的修订记录或第一条修订记录
            Aduitname := Ta_Editlist(N).编辑人;
            r_Editlist.Extend;
            r_Editlist(r_Editlist.Count) := t_Edits( Aduitname, Aduittime, 0, 0);
          Else
            --同一人不同时间多处修订,只取最后一次时间
            r_Editlist(r_Editlist.Count).编辑时间 := Aduittime;
          End If;
        Elsif Aduittime>Aftertime then
          --因为修订记录经过时间排序，如果不在签名记录之间则是下次签名后的修订
          Exit;
        End If;
      End Loop;
    End Loop;
  
    If Not Xmldom.Isnull(Xcdoc) Then
      Xmldom.Freedocument(Xcdoc);
    End If;
  
    If Not Xmldom.Isnull(Targetdoc) Then
      Xmldom.Freedocument(Targetdoc);
    End If;
  
    Return r_Editlist;
  End f_Geteditlist;

  Function f_Getlastedit(
    Content_In In Xmltype
	) Return t_Editlist As
    t_List   t_Editlist := t_Editlist();
    r_List   t_Editlist := t_Editlist();
    
    Function Lastlist(
      t_e       t_Editlist
    ) Return t_Editlist Is
      Tm_List t_Editlist := t_Editlist();
    Begin
      For Rs In (Select * From Table(Cast(t_e As t_Editlist)) A  Order By a.编辑时间 Desc) Loop
        Tm_List.Extend;
        Tm_List(Tm_List.Count) := t_Edits( Rs.编辑人, Rs.编辑时间, Rs.签名, Rs.审订签名);
        Return Tm_List;
      End Loop;
    End Lastlist;
    
  Begin
    Select f_Geteditlist(Content_In) Into t_List From Dual;
    r_List.Extend;
    r_List(r_List.Count) := Lastlist(t_List) (1);
    Return r_List;
  End f_Getlastedit;
  
  
  --设置XML的节点值,当节点为<ele></ele>此类闭合节点时，Updatexml函数无效
  Procedure p_Set_Elementtext(
    Texture In Out Xmltype,
    Ename   In Varchar2,
    Eaname  In Varchar2,
    Eatext  In Varchar2,
    Etext   In Varchar2
  ) Is
    --参数：     Texture 操作的XML
    --           Ename 需要设置的节点名称
    --           Eaname 需要设置的节点内属性名称，用于精确定位
    --           Eatext 需要设置的节点内属性值，用于精确定位
    --           Ttext 需要设置的元素值
    x_Dom   Xmldom.Domdocument;
    x_Nlist Xmldom.Domnodelist;
    x_Text  Xmldom.Domnode;
    x_Node  Xmldom.Domnode;
    n_Len   Number;
    v_Val   Varchar2(2000);
    Procedure Freeall Is
    Begin
      If Not Xmldom.Isnull(x_Text) Then
        Xmldom.Freenode(x_Text);
      End If;
    
      If Not Xmldom.Isnull(x_Node) Then
        Xmldom.Freenode(x_Node);
      End If;
    
      If Not Xmldom.Isnull(x_Dom) Then
        Xmldom.Freedocument(x_Dom);
      End If;
    End Freeall;
  Begin
    If Texture Is Null Then
      Return;
    End If;
  
    x_Dom   := Xmldom.Newdomdocument(Texture);
    x_Nlist := Xmldom.Getelementsbytagname(x_Dom, Ename);
    n_Len   := Xmldom.Getlength(x_Nlist);
    For I In 0 .. n_Len - 1 Loop
      If Xmldom.Getattribute(Xmldom.Makeelement(Xmldom.Item(x_Nlist, I)), Eaname) = Eatext Then
        For J In 0 .. Xmldom.Getlength(Xmldom.Getchildnodes(Xmldom.Item(x_Nlist, I))) - 1 Loop
          x_Node := Xmldom.Item(Xmldom.Getchildnodes(Xmldom.Item(x_Nlist, I)), J);
          If Xmldom.Getnodetype(x_Node) = Xmldom.Text_Node Then
            --找到文本节点
            v_Val := Xmldom.Getnodevalue(x_Node);
            Exit;
          Else
            v_Val := Null;
          End If;
        End Loop;
      
        If v_Val Is Null Then
          x_Text := Xmldom.Makenode(Xmldom.Createtextnode(x_Dom, Etext));
          x_Text := Xmldom.Importnode(x_Dom, x_Text, True);
          x_Node := Xmldom.Appendchild(Xmldom.Item(x_Nlist, I), x_Text);
        Else
          Xmldom.Setnodevalue(x_Node, Etext);
        End If;
        Texture := Xmldom.Getxmltype(x_Dom);
        Freeall;
        Return;
      End If;
    End Loop;
  
    Freeall;
  End p_Set_Elementtext;

  --根据子文档ID提取子文档当前状态
  Function f_Get_Docstatus(
    Content_In In Xmltype
  ) Return Varchar2 Is
    n_Sign   Number;
    n_Audit  Number;
    v_Editor Varchar2(200);
    v_n      Varchar2(20);
  Begin
    For Rs In (Select *
               From Table(Cast((Select b_PACS_RptPublic.f_Geteditlist(Content_In) From Dual) As t_Editlist))
               Order By 编辑时间 Asc) Loop
      n_Sign   := Rs.签名;
      n_Audit  := Rs.审订签名;
      v_Editor := Rs.编辑人;
    End Loop;
    If n_Sign = 0 And n_Audit = 0 And v_Editor Is Null Then
      v_n := '编辑中';
    Elsif n_Sign = 1 And n_Audit = 0 Then
      v_n := '已签名';
    Elsif n_Sign = 0 And n_Audit = 0 And v_Editor Is Not Null Then
      v_n := '审订中';
    Elsif n_Sign = 1 And n_Audit = 1 Then
      v_n := '已审签';
    End If;
    Return v_n;
  End f_Get_Docstatus;

  Function f_If_Intersect
  (
    Str1 Varchar2,
    Str2 Varchar2
  ) Return Number As
    n_Num Number;
  Begin
  
    Select Count(*)
    Into n_Num
    From (Select a.Column_Value Value
           From Table(b_PACS_RptPublic.f_Str2list(Str1, ',')) A
           Intersect
           Select b.Column_Value Value From Table(b_PACS_RptPublic.f_Str2list(Str2, ',')) B);
  
    Return n_Num;
  End;

Begin
  -- Initialization
  Null;

End b_PACS_RptPublic;
/
--99999:涂建华,2016-10-21,64位oracle服务器调用xml的GetClobVal方法内容改变问题
CREATE OR REPLACE Package b_Pacs_RptSampleList Is
  Type t_Refcur Is Ref Cursor;

  -- Author  : SEEKING
  -- Created : 2014/10/30 10:05:38
  -- Purpose : 范文管理

  --查找范文的原型类别

  Procedure p_Get_Sample_List_Type(
    Val Out t_Refcur,
    Type_In Varchar2,
    Kind_In varchar2
	);

  --新增文档原型
  Procedure p_Add_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
	Aid_In      影像报告范文清单.原型id%Type,
	Seq_Num_In  影像报告范文清单.编号%Type,
	Title_In    影像报告范文清单.名称%Type,
	Note_In     影像报告范文清单.说明%Type,
	Content_In  影像报告范文清单.内容%Type,
	Subject_In  影像报告范文清单.学科%Type,
	Label_In    影像报告范文清单.标签%Type,
	Private_In  影像报告范文清单.是否私有%Type,
	Author_In   影像报告范文清单.作者%Type,
	Lasttime_In 影像报告范文清单.最后编辑时间%Type
	);

  --编辑范文信息
  Procedure p_Edit_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
    Aid_In      影像报告范文清单.原型id%Type,
    Seq_Num_In  影像报告范文清单.编号%Type,
    Title_In    影像报告范文清单.名称%Type,
    Note_In     影像报告范文清单.说明%Type,
    Content_In  影像报告范文清单.内容%Type,
    Subject_In  影像报告范文清单.学科%Type,
    Label_In    影像报告范文清单.标签%Type,
    Private_In  影像报告范文清单.是否私有%Type,
    Author_In   影像报告范文清单.作者%Type,
    Lasttime_In 影像报告范文清单.最后编辑时间%Type
	);
  --删除文档范文
  Procedure p_Del_Sample_List(
    Id_In 影像报告范文清单.Id%Type
	);

  --通过原型ID获得相应的范文信息
  Procedure p_Get_Samplelist_By_Aid(
    Val Out t_Refcur,
    Antetypelist_Id_In 影像报告范文清单.原型id%Type,
    Author_In          影像报告范文清单.作者%Type,
    Subjects_In        Varchar2
	);

  --通过种类id获取范文树
  Procedure p_Get_Samplelist_By_Kind(
    Val Out t_Refcur,
    Kind_In      Varchar2,
    Condition_In Varchar2,
    Author_In    影像报告范文清单.作者%Type,
    Subjects_In  Varchar2
	);

  --通过ID查找相应的范文信息
  Procedure p_Get_Samplelist_By_Id(
    Val Out t_Refcur,                                   
    Id_In 影像报告范文清单.Id%Type
	);

  --查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val Out t_Refcur,
	Aid_In 影像报告范文清单.原型id%Type
	);

  --获取范文XML信息
  Procedure p_Get_Samplexml(
    Val Out t_Refcur,     
	Id_In 影像报告范文清单.Id%Type
	);

  --修改范文XML信息
  Procedure p_Edit_Samplexml(
    Id_In      影像报告范文清单.Id%Type,
	Content_In 影像报告范文清单.内容%Type
	);

  --导出的范文列表
  Procedure p_Output_Samplelist(
    Val Out t_Refcur
	);

  --是否存在相应的原型类别
  Procedure p_If_Exist_Antetypelist(
    Val Out t_Refcur,
	Title_In 影像报告原型清单.名称%Type
	);

  --同一个类别下是否存在相同名称的范文
  Procedure p_If_Exist_Samplelist(
    Val Out t_Refcur,
    Type_In  影像报告原型清单.名称%Type,
    Title_In 影像报告范文清单.名称%Type
	);

  --通过范文ID获得范文对应的树形结构
  Procedure p_Get_SamplelistTree_By_Id(
    Val Out t_Refcur,
    Id_In 影像报告范文清单.Id%Type
	);

End b_Pacs_RptSampleList;
/

CREATE OR REPLACE Package Body b_Pacs_RptSampleList Is

  ------------------------------------------------------------------------
  --范文管理
  ------------------------------------------------------------------------

  --查找范文的原型类别

  Procedure p_Get_Sample_List_Type(
    Val Out t_Refcur,
    Type_In Varchar2,
    Kind_In Varchar2
	) As
  Begin
    If Type_In = '1' Then
      Open Val For
        Select Rawtohex(a.Id) ID, a.编码 || '-' || a.名称 名称
          From 影像报告原型清单 A
         Where a.Id In (Select Distinct b.原型id From 影像报告范文清单 B)
           and a.种类 = Kind_In;
    Else
      Open Val For
        Select Rawtohex(a.Id) ID, a.编码 || '-' || a.名称 名称
          From 影像报告原型清单 A
         where a.种类 = Kind_In
         Order By a.编码;
    End If;
  
  End p_Get_Sample_List_Type;
  --新增文档原型
  Procedure p_Add_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
	Aid_In      影像报告范文清单.原型id%Type,
	Seq_Num_In  影像报告范文清单.编号%Type,
	Title_In    影像报告范文清单.名称%Type,
	Note_In     影像报告范文清单.说明%Type,
	Content_In  影像报告范文清单.内容%Type,
	Subject_In  影像报告范文清单.学科%Type,
	Label_In    影像报告范文清单.标签%Type,
	Private_In  影像报告范文清单.是否私有%Type,
	Author_In   影像报告范文清单.作者%Type,
	Lasttime_In 影像报告范文清单.最后编辑时间%Type
	) As
    n_Num Number;
    v_Msg Varchar2(200);
    Err Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告范文清单 A
     Where a.原型id = Hextoraw(Aid_In)
       And a.名称 = Title_In;
  
    If n_Num > 0 Then
      v_Msg := '[ZLSOFT]在同一个原型下的范文名称不能相同！[ZLSOFT]';
      Raise Err;
    End If;
  
    Insert Into 影像报告范文清单
      (ID,
       原型id,
       编号,
       名称,
       说明,
       内容,
       学科,
       标签,
       是否私有,
       作者,
       最后编辑时间)
    Values
      (Hextoraw(Id_In),
       Hextoraw(Aid_In),
       Seq_Num_In,
       Title_In,
       Note_In,
       Content_In,
       Subject_In,
       Label_In,
       Private_In,
       Author_In,
       Sysdate);
  
    --这里添加对于该范文的处理,页眉页脚，页面设置
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/subdocuments',
                          (Select Extract(内容, 'zlxml/subdocuments')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页眉页脚
  
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/docparameters',
                          (Select Extract(内容, 'zlxml/docparameters')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页面设置
  
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Add_Sample_List;

  --编辑范文信息
  Procedure p_Edit_Sample_List(
    Id_In       影像报告范文清单.Id%Type,
    Aid_In      影像报告范文清单.原型id%Type,
    Seq_Num_In  影像报告范文清单.编号%Type,
    Title_In    影像报告范文清单.名称%Type,
    Note_In     影像报告范文清单.说明%Type,
    Content_In  影像报告范文清单.内容%Type,
    Subject_In  影像报告范文清单.学科%Type,
    Label_In    影像报告范文清单.标签%Type,
    Private_In  影像报告范文清单.是否私有%Type,
    Author_In   影像报告范文清单.作者%Type,
    Lasttime_In 影像报告范文清单.最后编辑时间%Type
	) As
    n_Num Number;
    v_Msg Varchar2(200);
    Err Exception;
  Begin
    Select Count(a.Id)
      Into n_Num
      From 影像报告范文清单 A
     Where a.原型id = Hextoraw(Aid_In)
       And a.名称 = Title_In
       And a.Id <> Hextoraw(Id_In);
  
    If n_Num > 0 Then
      v_Msg := '[ZLSOFT]在同一个原型下的范文名称不能相同！[ZLSOFT]';
      Raise Err;
    End If;
    Update 影像报告范文清单
       Set 原型id       = Hextoraw(Aid_In),
           编号         = Decode(Seq_Num_In, 0, 编号, Seq_Num_In),
           名称         = Title_In,
           说明         = Note_In,
           内容         = Content_In,
           学科         = Subject_In,
           标签         = Label_In,
           是否私有     = Private_In,
           作者         = Author_In,
           最后编辑时间 = Sysdate
     Where ID = Hextoraw(Id_In);
  
    --这里添加对于该范文的处理,页眉页脚，页面设置
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/subdocuments',
                          (Select Extract(内容, 'zlxml/subdocuments')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页眉页脚
  
    Update 影像报告范文清单
       Set 内容 = Updatexml(内容,
                          '/zlxml/docparameters',
                          (Select Extract(内容, 'zlxml/docparameters')
                             From 影像报告原型清单
                            Where ID = Hextoraw(Aid_In)))
     Where ID = Hextoraw(Id_In); --处理页面设置
  
  Exception
    When Err Then
      Raise_Application_Error(-20101, v_Msg);
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End p_Edit_Sample_List;

  --删除文档范文
  Procedure p_Del_Sample_List(
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Delete From 影像报告范文清单
     Where 影像报告范文清单.Id = Hextoraw(Id_In);
  End p_Del_Sample_List;

  --通过原型ID获取该原型下的范文列表
  Procedure p_Get_Samplelist_By_Aid(
    Val Out t_Refcur,
    Antetypelist_Id_In 影像报告范文清单.原型id%Type,
    Author_In          影像报告范文清单.作者%Type,
    Subjects_In        Varchar2
	) As
  Begin
    Open Val For
      Select /*+rule*/
       Rawtohex(a.Id) As ID,
       a.名称,
       a.作者,
       a.说明,
       a.学科,
       a.编号 Seqnum,
       a.标签,
       a.是否私有
        From 影像报告范文清单 A
       Where a.原型id = Hextoraw(Antetypelist_Id_In)
         And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
             Subjects_In Is Null Or
             (a.学科 Is Not Null And
             b_pacs_rptpublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
             a.是否私有 = 0));
  End p_Get_Samplelist_By_Aid;

  --通过种类id获取范文树
  Procedure p_Get_Samplelist_By_Kind(
    Val Out t_Refcur,
    Kind_In      Varchar2,
    Condition_In Varchar2,
    Author_In    影像报告范文清单.作者%Type,
    Subjects_In  Varchar2
	) As
  Begin
  
    --获得一个存在原型信息的范文树形结构
    Open Val For
      Select a.分组 As ID,
             a.分组 As 名称,
             '' 说明,
             '' As 上级id,
             ' category' As Type,
             '' As 作者,
             '' As 学科,
             Null 修改时间,
             '' As 标签,
             0 As Private,
             0 As Imgindex
        From 影像报告原型清单 A
       Where a.种类 = Kind_In
         And Exists
       (Select ID From 影像报告范文清单 C Where c.原型id = a.Id)
         And a.分组 Is Not Null
      Union
      Select m.*
        From (Select Rawtohex(b.Id) As ID,
                     b.名称,
                     b.说明,
                     b.分组 上级id,
                     'antetype' As Type,
                     '' As 作者,
                     '' As 学科,
                     Null 修改时间,
                     '' As 标签l,
                     0 As Private,
                     0 As Imgindex
                From 影像报告原型清单 B
               Where b.种类 = Kind_In
                 And Exists
               (Select ID From 影像报告范文清单 C Where c.原型id = b.Id)
               Order By b.编码) M
      Union All
      Select n.*
        From (Select /*+rule*/
               Rawtohex(a.Id) As ID,
               a.名称,
               a.说明,
               Rawtohex(a.原型id) As 上级id,
               'sample' As Type,
               a.作者,
               a.学科,
               a.最后编辑时间 As 修改时间,
               a.标签,
               a.是否私有 As Private,
               Decode(a.是否私有, 1, 2, 1) As Imgindex
                From 影像报告范文清单 A, 影像报告原型清单 C
               Where a.原型id = c.Id
                 And c.种类 = Kind_In
                 And ((a.名称 Like '%' || Condition_In || '%' And
                     Condition_In Is Not Null) Or Condition_In Is Null)
                 And (a.作者 = Author_In Or (a.学科 Is Null And a.是否私有 = 0) Or
                     Subjects_In Is Null Or
                     (a.学科 Is Not Null And
                     b_pacs_rptpublic.f_If_Intersect(a.学科, Subjects_In) > 0 And
                     a.是否私有 = 0))
               Order By a.编号, a.名称) N;
  
  End p_Get_Samplelist_By_Kind;

  --通过ID查找相应的范文信息
  Procedure p_Get_Samplelist_By_Id(
    Val Out t_Refcur,
	Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Open Val For
      Select Rawtohex(a.Id) As ID,
             Rawtohex(a.原型id) As 原型id,
             a.编号,
             a.名称,
             a.说明,
             a.学科,
             a.标签,
             a.是否私有,
             a.作者,
             a.最后编辑时间 Lasttime
        From 影像报告范文清单 A
       Where a.Id = Hextoraw(Id_In);
  
  End p_Get_Samplelist_By_Id;

  --查询相应原型下的最大序号
  Procedure p_Get_Samplelist_Maxseqnum(
    Val Out t_Refcur,
    Aid_In 影像报告范文清单.原型id%Type
	) As
  Begin
    Open Val For
      Select Nvl(Max(a.编号), 0) + 1 As Num
        From 影像报告范文清单 A
       Where a.原型id = Hextoraw(Aid_In);
  End p_Get_Samplelist_Maxseqnum;

  --获取范文XML信息
  Procedure p_Get_Samplexml(
    Val Out t_Refcur,
	Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    Open Val For
      Select A.内容.getclobval() 内容 From 影像报告范文清单 A Where a.Id = Id_In;
  End p_Get_Samplexml;

  --修改范文XML信息
  Procedure p_Edit_Samplexml(
    Id_In      影像报告范文清单.Id%Type,
	Content_In 影像报告范文清单.内容%Type
	) As
  Begin
    Update 影像报告范文清单
       Set 内容 = Content_In
     Where ID = Hextoraw(Id_In);
  End p_Edit_Samplexml;

  --导出的范文列表
  Procedure p_Output_Samplelist(
    Val Out t_Refcur
	) As
  Begin
    Open Val For
      Select *
        From (Select Rawtohex(a.Id) As ID,
                     Null As Aid,
                     a.名称 As Antetypename,
                     Null As Code,
                     a.名称 As Title,
                     a.说明 As Note,
                     Null As Content,
                     Null As Subject,
                     Null As Label,
                     Null As Private,
                     Null As Author,
                     Null As Lasttime,
                     '' As Flag,
                     1 As Image,
                     'antetype' As Type
                From 影像报告原型清单 A
               Where Exists (Select b.Id
                        From 影像报告范文清单 B
                       Where b.原型id = a.Id)
               Order By a.编码)
      Union All
      Select Rawtohex(c.Id) As ID,
             Rawtohex(c.原型id) As Aid,
             d.名称,
             c.编号,
             c.名称,
             c.说明,
             '',
             c.学科,
             c.标签,
             c.是否私有,
             c.作者,
             c.最后编辑时间,
             '',
             0,
             'sample'
        From 影像报告范文清单 C, 影像报告原型清单 D
       Where c.原型id = d.Id;
  
  End p_Output_Samplelist;

  --是否存在相应的原型类别
  Procedure p_If_Exist_Antetypelist(
    Val Out t_Refcur,
	Title_In 影像报告原型清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(a.Id) Num
        From 影像报告原型清单 A
       Where a.名称 = Title_In;
  End p_If_Exist_Antetypelist;

  --同一个类别下是否存在相同名称的范文
  Procedure p_If_Exist_Samplelist(
    Val Out t_Refcur,
    Type_In  影像报告原型清单.名称%Type,
    Title_In 影像报告范文清单.名称%Type
	) As
  Begin
    Open Val For
      Select Count(a.Id) Num, Max(a.Id) ID
        From 影像报告范文清单 A, 影像报告原型清单 B
       Where a.原型id = b.Id
         And a.名称 = Title_In
         And b.名称 = Type_In;
  End p_If_Exist_Samplelist;
  
  --通过范文ID获得范文对应的树形结构
  Procedure p_Get_SamplelistTree_By_Id(
    Val Out t_Refcur,
    Id_In 影像报告范文清单.Id%Type
	) As
  Begin
    --'EE7CD4A510B045A9BBE6D8CC7DB6EE30'
    Open Val For
      Select RawToHex(t.ID) as ID,
             t.名称,
             T.说明,
             RawToHex(T.原型ID) 原型ID,
             'sample' 类型,
             t.作者,
             t.学科,
             t.最后编辑时间,
             t.标签,
             t.是否私有,
             2 IMGINDEX
        From 影像报告范文清单 t
       Where t.id = Id_In
      Union All
      Select RawToHex(x.id) as ID,
             x.名称,
             x.说明,
             x.分组 原型ID,
             'antetype' 类型,
             null 作者,
             null 学科,
             null 最后编辑时间,
             null 标签,
             0 是否私有,
             0 IMGINDEX
        From 影像报告原型清单 x
       Where x.id = (Select t.原型id
                       From 影像报告范文清单 t
                      where t.id = Id_In
                        and rownum <= 1)
      Union All
      Select x.分组 as ID,
             x.分组 名称,
             null 说明,
             null 原型ID,
             'category' 类型,
             null 作者,
             null 学科,
             null 最后编辑时间,
             null 标签,
             0 是否私有,
             0 IMGINDEX
        From 影像报告原型清单 x
       Where x.ID = (Select t.原型id
                       From 影像报告范文清单 t
                      where t.id = Id_In
                        and rownum <= 1);
  End p_Get_SamplelistTree_By_Id;
End b_Pacs_RptSampleList;
/

--101804:刘尔旋,2016-10-21,调用费用虚拟模块生成费用时手术和检查类主医嘱计费状态问题
Create Or Replace Procedure Zl_病人医嘱发送_计费
(
  医嘱id_In 病人医嘱执行.医嘱id%Type,
  发送号_In 病人医嘱执行.发送号%Type
  --功能：医技站将医嘱标记为已计费,每条医嘱处理,因为可能如附加手术不计费 
) Is

  n_主医嘱id 病人医嘱记录.Id%Type := Null;
Begin

  --检查和手术医嘱需要同步更新主医嘱的计费状态
  Select Max(ID)
  Into n_主医嘱id
  From 病人医嘱记录
  Where ID In (Select Max(Nvl(相关id, 0)) From 病人医嘱记录 Where ID = 医嘱id_In) And Instr(',D,F,', ',' || 诊疗类别 || ',') > 0;

  Update 病人医嘱发送
  Set 计费状态 = 1
  Where (医嘱id = 医嘱id_In Or 医嘱id = Nvl(n_主医嘱id, 0)) And 发送号 = 发送号_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱发送_计费;
/

--101706:刘鹏飞,2016-10-21,页码重整活动项目页码位移处理
Create Or Replace Procedure Zl_病人护理打印_Retrypage
(
  文件id_In   In 病人护理打印.文件id%Type,
  开始页号_In In 病人护理打印.开始页号%Type,
  开始行号_In In 病人护理打印.开始行号%Type := 1,
  清除打印_In In Number := 0
) Is
  Cursor c_Page(c_Id 病人护理打印.文件id%Type) Is
    Select 行数, 记录id, 发生时间, 开始页号, 开始行号, 待转出 From 病人护理打印 Where 文件id = c_Id Order By 发生时间;
  Type t_Page Is Table Of c_Page%Rowtype;
  r_Page t_Page;

  v_Username   人员表.姓名%Type;
  n_Startpage  病人护理打印.开始页号%Type;
  n_Endpage    病人护理打印.结束页号%Type;
  n_Startrow   病人护理打印.开始行号%Type;
  n_Endrow     病人护理打印.结束行号%Type;
  n_Row        病人护理打印.行数%Type;
  n_Pagerows   Number;
  n_Actives    Number;
  n_Differpage Number;
  n_活动页号   病人护理活动项目.页号%Type;
  n_Minpage    病人护理打印.开始页号%Type;
  Err_Item Exception;
  v_Err_Msg Varchar2(500);
Begin
  n_Startpage := 开始页号_In;
  n_Startrow  := 开始行号_In;
  v_Username  := Zl_Username;
  Begin
    --提取该护理文件格式每页有效数据行
    Select To_Number(内容文本)
    Into n_Pagerows
    From 病历文件结构
    Where 对象属性 = '有效数据行' And
          父id = (Select a.Id
                 From 病历文件结构 a, 病人护理文件 b
                 Where a.文件id = b.格式id And b.Id = 文件id_In And a.对象序号 = 1 And a.父id Is Null);
  Exception
    When Others Then
      v_Err_Msg := '文件ID为【' || 文件id_In || '】的护理文件有效数据行丢失,请在病历文件管理中重新保存改文件的样式！';
      Raise Err_Item;
  End;
  Open c_Page(文件id_In);
  Fetch c_Page Bulk Collect
    Into r_Page;
  Close c_Page;
  If r_Page.Count = 0 Then
    Return;
  End If;
  Select Nvl(Min(开始页号), 0) Into n_Minpage From 病人护理打印 Where 文件id = 文件id_In;
  --主要修正以前错误的数据(活动项目的页码肯定不小于文件开始页码)
  Select Nvl(Max(页号), 0) Into n_活动页号 From 病人护理活动项目 Where 文件id = 文件id_In;
  n_Differpage := n_Minpage - n_活动页号;
  If n_Differpage > 0 And n_活动页号 > 0 Then
    Update 病人护理活动项目 Set 页号 = 页号 + n_Differpage Where 文件id = 文件id_In;
  End If;
  If 清除打印_In <> 0 Then
    Update 病人护理打印
    Set 行差 = 0, 打印人 = Null, 打印时间 = Null, 打印页号 = Null, 打印行号 = Null, 打印标识 = Null, 打印结束页号 = Null
    Where 文件id = 文件id_In;
  Else
    If r_Page.Count = 0 Then
      Return;
    End If;
    If r_Page(1).开始页号 = 开始页号_In And r_Page(1).开始行号 = 开始行号_In Then
      Return;
    End If;
  End If;
  --活动项目页码修正(原有页码和现有页码发生变化才进行修正)
  n_Differpage := 开始页号_In - n_Minpage;
  If n_Differpage <> 0 And n_活动页号 > 0 Then
    Update 病人护理活动项目 Set 页号 = 页号 + n_Differpage Where 文件id = 文件id_In;
  End If;
  For i In 1 .. r_Page.Count Loop
    n_Row     := r_Page(i).行数;
    n_Endpage := n_Startpage;
    n_Endrow  := n_Startrow + n_Row - 1;
    If n_Endrow > n_Pagerows Then
      n_Endpage := n_Endpage + 1;
      n_Endrow  := n_Endrow - n_Pagerows;
      If n_Endrow > n_Pagerows Then
        n_Endrow := n_Pagerows;
        n_Row    := n_Endrow + n_Pagerows - n_Startrow + 1;
      End If;
      --翻页时，自动依据当前页的设置产生新页的活动项目设置
      Begin
        Select 1 Into n_Actives From 病人护理活动项目 Where 文件id = 文件id_In And 页号 = n_Startpage And Rownum < 2;
      Exception
        When Others Then
          n_Actives := 0;
      End;
    
      If n_Actives = 0 Then
        Insert Into 病人护理活动项目
          (文件id, 页号, 列号, 列头名称, 序号, 项目序号, 部位, 操作员, 操作时间)
          Select 文件id, n_Startpage, 列号, 列头名称, 序号, 项目序号, 部位, v_Username, Sysdate
          From 病人护理活动项目
          Where 文件id = 文件id_In And 页号 = n_Startpage - 1;
      End If;
    End If;
    Update 病人护理打印
    Set 开始页号 = n_Startpage, 开始行号 = n_Startrow, 结束页号 = n_Endpage, 结束行号 = n_Endrow, 打印人 = Null, 打印时间 = Null
    Where 文件id = 文件id_In And 记录id = r_Page(i).记录id;
    n_Startpage := n_Endpage;
    If n_Endrow = n_Pagerows Then
      n_Startpage := n_Startpage + 1;
      n_Startrow  := 1;
    Else
      n_Startrow := n_Endrow + 1;
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人护理打印_Retrypage;
/

--101414:冉俊明,2016-10-21,出诊表另存为模板功能调整
Create Or Replace Procedure Zl_临床出诊表_Totemplet
(
  出诊id_In   临床出诊表.Id%Type,
  模板id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  应用范围_In 临床出诊表.应用范围%Type,
  科室id_In   临床出诊表.科室id%Type,
  备注_In     临床出诊表.备注%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  站点_In     部门表.站点%Type,
  人员id_In   人员表.Id%Type := Null
) As
  --功能：由月/周出诊表生成模板
  --参数：
  --        出诊id_In 月/周出诊表的出诊ID
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --说明：
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_模板id   临床出诊表.Id%Type;
  n_模板类型 临床出诊表.模板类型%Type;

  n_安排id 临床出诊安排.Id%Type;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 临床出诊安排 B, 临床出诊记录 C, 部门表 D
  Where a.Id = b.号源id And b.Id = c.安排id And a.科室id = d.Id And a.排班方式 In (1, 2) And Nvl(a.是否删除, 0) = 0 And
        (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
       --当前人员可操作的号源
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点
        And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前出诊表中无有效的安排，不能另存为模板！';
    Raise Err_Item;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板
  Select Count(1) Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Rownum < 2;
  If Nvl(n_Count, 0) > 0 Then
    v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的模板！';
    Raise Err_Item;
  End If;

  Begin
    Select Decode(排班方式, 1, 2, 0)
    Into n_模板类型
    From 临床出诊表
    Where ID = 出诊id_In And 排班方式 In (1, 2) And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '未发现当前出诊表！';
      Raise Err_Item;
  End;

  n_模板id := 模板id_In;
  If Nvl(n_模板id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_模板id From Dual;
  End If;

  --模板，肯定是新出诊表
  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型)
  Values
    (n_模板id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, n_模板类型);

  --月/周出诊表保存为模板
  For c_安排 In (Select b.Id As 安排id, b.号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 临床出诊安排 B, 部门表 D
               Where a.Id = b.号源id And a.科室id = d.Id And a.排班方式 In (1, 2) And Nvl(a.是否删除, 0) = 0 And
                     (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In) Loop
  
    Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
  
    --1.临床出诊安排
    --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期
    If Nvl(n_模板类型, 0) = 2 Then
      --按天安排出诊的月出诊表保存为特定日期的规则
      Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 6, Null, Null, Null, Null, 操作员_In,
                       操作时间_In);
    Else
      Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 1, Null, Null, Null, Null, 操作员_In,
                       操作时间_In);
    End If;
  
    For c_记录 In (Select 临床出诊限制_Id.Nextval As 限制id, Decode(b.Id, Null, a.Id, b.Id) As 记录id,
                        Decode(To_Char(a.出诊日期, 'D'), '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                                '1', '周日') As 限制项目, To_Number(To_Char(a.出诊日期, 'dd')) || '日' As 出诊日期, a.上班时段,
                        Decode(b.Id, Null, a.限号数, b.限号数) As 限号数, Decode(b.Id, Null, a.限约数, b.限约数) As 限约数,
                        Decode(b.Id, Null, a.是否分时段, b.是否分时段) As 是否分时段, Decode(b.Id, Null, a.是否序号控制, b.是否序号控制) As 是否序号控制,
                        Decode(b.Id, Null, a.预约控制, b.预约控制) As 预约控制, Decode(b.Id, Null, a.是否独占, b.是否独占) As 是否独占,
                        Decode(b.Id, Null, a.分诊方式, b.分诊方式) As 分诊方式
                 From 临床出诊记录 A, 临床出诊记录 B
                 Where a.Id = b.相关id(+) And a.安排id = c_安排.安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0) Loop
    
      --2.临床出诊限制
      If Nvl(n_模板类型, 0) = 2 Then
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.出诊日期, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      Else
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.限制项目, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      End If;
    
      --3.临床出诊诊室
      Insert Into 临床出诊诊室
        (限制id, 诊室id)
        Select c_记录.限制id, 诊室id From 临床出诊诊室记录 Where 记录id = c_记录.记录id;
    
      --4.临床出诊时段
      --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号
      If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id;
      Else
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id And 预约顺序号 Is Null;
      End If;
    
      --5.临床出诊挂号控制
      Insert Into 临床出诊挂号控制
        (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
        Select c_记录.限制id, 类型, 性质, 名称, 序号, 控制方式, 数量
        From 临床出诊挂号控制记录
        Where 记录id = c_记录.记录id;
    End Loop;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Totemplet;
/

--101393:胡俊勇,2016-12-16,电子签明参数判断
Create Or Replace Procedure Zl_病人医嘱记录_校对
(
  --功能：校对指定的医嘱
  --参数：医嘱ID_IN=Nvl(相关ID,ID)
  --      状态_IN=校对通过3或校对疑问2
  --      自动校对_IN=保存之后调用自动校对,自动填写计价内容
  --说明：一组医嘱只能调用一次,过程同时完成处理一组医嘱的校对
  医嘱id_In     病人医嘱记录.Id%Type,
  状态_In       病人医嘱记录.医嘱状态%Type,
  校对时间_In   病人医嘱状态.操作时间%Type,
  校对说明_In   病人医嘱状态.操作说明%Type := Null,
  自动校对_In   Number := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --用于医嘱检查
  v_状态       病人医嘱记录.医嘱状态%Type;
  v_期效       病人医嘱记录.医嘱期效%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_主页id     病人医嘱记录.主页id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_医嘱内容   病人医嘱记录.医嘱内容%Type;
  v_开嘱时间   病人医嘱记录.开嘱时间%Type;
  v_开始时间   病人医嘱记录.开始执行时间%Type;
  v_开嘱医生   病人医嘱记录.开嘱医生%Type;
  v_前提id     病人医嘱记录.前提id%Type;
  v_执行标记   病人医嘱记录.执行标记%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_标本部位   病人医嘱记录.标本部位%Type;
  v_停止时间   病人医嘱记录.开嘱时间%Type;
  v_开嘱科室id 病人医嘱记录.开嘱科室id%Type;

  --用于变更护理等级
  v_诊疗类别   病人医嘱记录.诊疗类别%Type;
  v_诊疗项目id 病人医嘱记录.诊疗项目id%Type;
  v_操作类型   诊疗项目目录.操作类型%Type;
  v_护理等级id 病案主页.护理等级id%Type;
  v_紧急标志   病人医嘱记录.紧急标志%Type;
  v_入院方式   入院方式.名称%Type;

  v_Stopadviceids 病人医嘱记录.医嘱内容%Type;
  n_Adviceid      病人医嘱记录.病人id%Type;
  n_标记          Number(18);
  --与该项目同一自动停止互斥组的项目:组中应该都是长嘱(包括当前医嘱),程序应已检查。
  --注意应加婴儿条件,同时也应停止除当前医嘱外的其它相同诊疗项目的医嘱。
  Cursor c_Exclude Is
    Select Distinct b.Id As 医嘱id, b.开始执行时间, b.执行终止时间, b.上次执行时间, b.开嘱医生, b.执行时间方案, b.频率间隔, b.频率次数, b.间隔单位
    From 诊疗互斥项目 A, 病人医嘱记录 B
    Where a.类型 = 3 And a.项目id = b.诊疗项目id And b.Id <> 医嘱id_In And Nvl(b.医嘱期效, 0) = 0 And b.医嘱状态 In (3, 5, 6, 7) And
          b.病人id = v_病人id And Nvl(b.主页id, 0) = Nvl(v_主页id, 0) And Nvl(b.婴儿, 0) = Nvl(v_婴儿, 0) And
          a.组编号 In (Select Distinct 组编号 From 诊疗互斥项目 Where 类型 = 3 And 项目id = v_诊疗项目id)
    Order By b.Id;
  v_终止时间 病人医嘱记录.执行终止时间%Type;

  --护理等级互斥
  Cursor c_Nurse Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'H' And b.操作类型 = '1' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录入出量互斥
  Cursor c_Patiio Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 = '12' And a.病人id = v_病人id And Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And
          Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;

  --记录病情互斥
  Cursor c_Patistate Is
    Select a.Id As 医嘱id, a.开始执行时间, a.执行终止时间, a.上次执行时间, a.开嘱医生
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.诊疗类别 = 'Z' And b.操作类型 In ('9', '10') And a.病人id = v_病人id And
          Nvl(a.主页id, 0) = Nvl(v_主页id, 0) And Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0) And Nvl(a.医嘱期效, 0) = 0 And
          a.医嘱状态 In (3, 5, 6, 7) And a.Id <> 医嘱id_In;
  --变动有效记录
  Cursor c_Oldinfo Is
    Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = v_病人id And c.主页id = v_主页id And
                 c.开始时间 = (Select Min(开始时间)
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间) And
                 NVL(c.终止时间|| '','空') = (Select  NVL(Min(终止时间)|| '','空')
                           From 病人变动记录
                           Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间)) A, 病人变动记录 B
    
    Where b.病人id = v_病人id And b.主页id = v_主页id And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null And 开始时间 <= v_开始时间;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
  r_Oldinfo      c_Oldinfo%RowType;
  r_Endinfo      c_Endinfo%RowType;
  v_变动终止原因 病人变动记录.终止原因%Type;
  v_变动终止时间 病人变动记录.终止时间%Type;
  v_变动终止人员 病人变动记录.终止人员%Type;

  --包含病人(婴儿)的所有未停长嘱(含配方长嘱)
  Cursor c_Needstop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select a.Id, a.诊疗类别, b.操作类型, b.执行频率
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.病人id = v_病人id And a.主页id = v_主页id And (v_婴儿 = -1 Or Nvl(a.婴儿, 0) = Nvl(v_婴儿, 0)) And
          Nvl(a.医嘱期效, 0) = 0 And a.医嘱状态 Not In (1, 2, 4, 8, 9) And a.开始执行时间 < v_Stoptime
    Order By a.序号;
  --包含病人(婴儿)的已停但未确认的长嘱,终止执行时间在指定时间之后
  Cursor c_Havestop
  (
    v_病人id   病人医嘱记录.病人id%Type,
    v_主页id   病人医嘱记录.主页id%Type,
    v_婴儿     病人医嘱记录.婴儿%Type,
    v_Stoptime Date
  ) Is
    Select ID
    From 病人医嘱记录
    Where 病人id = v_病人id And 主页id = v_主页id And (v_婴儿 = -1 Or Nvl(婴儿, 0) = Nvl(v_婴儿, 0)) And Nvl(医嘱期效, 0) = 0 And
          医嘱状态 = 8 And 执行终止时间 > v_Stoptime And 开始执行时间 < v_Stoptime
    Order By 序号;

  --取一组医嘱的计价内容
  Cursor c_Price Is
    Select a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别 As 收费类别, a.诊疗类别, e.操作类型, e.试管编码,
           Sum(Decode(Nvl(c.是否变价, 0), 1, Nvl(d.缺省价格, d.原价), Null)) As 单价
    From 病人医嘱记录 A, 诊疗收费关系 B, 收费项目目录 C, 收费价目 D, 诊疗项目目录 E
    Where a.诊疗项目id = b.诊疗项目id And b.收费项目id = c.Id And c.Id = d.收费细目id And
          (a.相关id Is Null And a.执行标记 In (1, 2) And b.费用性质 = 1 Or
          a.标本部位 = b.检查部位 And a.检查方法 = b.检查方法 And Nvl(b.费用性质, 0) = 0 Or
          a.检查方法 Is Null And Nvl(b.费用性质, 0) = 0 And b.检查部位 Is Null And b.检查方法 Is Null) And
          a.诊疗类别 Not In ('5', '6', '7') And Nvl(a.计价特性, 0) = 0 And Nvl(a.执行性质, 0) Not In (0, 5) And c.服务对象 In (2, 3) And
          (c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or c.撤档时间 Is Null) And Sysdate Between d.执行日期 And
          Nvl(d.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD')) And Nvl(b.收费数量, 0) <> 0 And
          Not (Nvl(c.是否变价, 0) = 1 And Nvl(Nvl(d.缺省价格, d.原价), 0) = 0) And a.诊疗项目id = e.Id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Group By a.Id, b.收费项目id, b.收费数量, b.从属项目, b.费用性质, b.收费方式, c.类别, a.诊疗类别, e.操作类型, e.试管编码;

  Cursor c_Pati(v_病人id 病人信息.病人id%Type) Is
    Select * From 病人信息 Where 病人id = v_病人id;
  r_Pati c_Pati%RowType;

  v_材料id 采血管类型.材料id%Type;

  --其它临时变量
  v_Count    Number;
  v_Date     Date;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Function Getadvicetext(v_医嘱id 病人医嘱记录.Id%Type) Return Varchar2 Is
    v_Text 病人医嘱记录.医嘱内容%Type;
    v_类别 病人医嘱记录.诊疗类别%Type;
    v_配方 Number;
  Begin
    Select 诊疗类别, 医嘱内容 Into v_类别, v_Text From 病人医嘱记录 Where ID = v_医嘱id;
    If v_类别 = 'E' Then
      --西药，中成药的医嘱内容
      Begin
        Select 诊疗类别, Decode(诊疗类别, '7', v_Text, 医嘱内容)
        Into v_类别, v_Text
        From 病人医嘱记录
        Where 相关id = v_医嘱id And 诊疗类别 In ('5', '6', '7') And Rownum = 1;
      Exception
        When Others Then
          Null;
      End;
      If v_类别 = '7' Then
        v_配方 := 1;
      End If;
    End If;
    If Length(v_Text) > 30 Then
      v_Text := Substr(v_Text, 1, 30) || '...';
    End If;
    If Length(v_Text) > 20 Then
      v_Text := '"' || v_Text || '"' || Chr(13) || Chr(10);
    Else
      v_Text := '"' || v_Text || '"';
    End If;
    If v_配方 = 1 Then
      v_Text := '中药配方' || v_Text;
    End If;
    Return(v_Text);
  End;
Begin
  --检查医嘱状态是否正确:并发操作
  Begin
    Select a.医嘱期效, a.医嘱状态, a.开嘱时间, a.开嘱医生, a.开始执行时间, a.病人id, a.主页id, a.婴儿, a.医嘱内容, a.诊疗类别, a.诊疗项目id, a.前提id,
           Nvl(b.操作类型, '0'), Nvl(a.执行标记, 0), a.执行科室id, a.标本部位, a.开嘱科室id, Nvl(a.紧急标志, 0) As 紧急标志
    Into v_期效, v_状态, v_开嘱时间, v_开嘱医生, v_开始时间, v_病人id, v_主页id, v_婴儿, v_医嘱内容, v_诊疗类别, v_诊疗项目id, v_前提id, v_操作类型, v_执行标记,
         v_执行科室id, v_标本部位, v_开嘱科室id, v_紧急标志
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id(+) And a.Id = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '医嘱已被删除，不能进行校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
        Raise Err_Custom;
      End;
  End;
  If v_状态 <> 1 Then
    v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"不是新开的医嘱，不能通过校对。' || Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
    Raise Err_Custom;
  End If;
  --再次检查校对时间的有效性:并发操作
  If To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') <= To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开嘱时间 ' || To_Char(v_开嘱时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  Else
    If To_Char(校对时间_In, 'YYYY-MM-DD HH24:MI') < To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') Then
      v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"的校对时间不能小于开始执行时间 ' || To_Char(v_开始时间, 'YYYY-MM-DD HH24:MI') || '。' ||
                 Chr(13) || Chr(10) || '这可能是并发操作引起的，请重新读取校对数据。';
      Raise Err_Custom;
    End If;
  End If;

  --如果要求签名，检查校对时是否有签名(并发取消签名)
  If 状态_In = 3 Then
    Select Zl_Fun_Getsignpar(Decode(v_前提id, Null, 1, 3), v_开嘱科室id) Into v_Count From Dual;
    If v_Count = 1 Then
      --证书停用或未注册证书不进入签名环节只判断一条数据即可
      For C In (Select a.是否停用
                From 人员证书记录 A, 人员表 B
                Where a.人员id = b.Id And b.姓名 = v_开嘱医生
                Order By a.注册时间 Desc) Loop
        If Nvl(c.是否停用, 0) = 0 Then
          Select Count(*)
          Into v_Count
          From 病人医嘱状态 A
          Where 操作类型 = 1 And 医嘱id = 医嘱id_In And
                (签名id Is Null And Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 X
                  Where r.Id = x.人员id And r.姓名 = a.操作人员 And x.人员性质 = '护士') And Not Exists
                 (Select 1
                  From 人员表 R, 人员性质说明 Y
                  Where r.Id = y.人员id And r.姓名 = a.操作人员 And y.人员性质 = '医生') Or 签名id Is Not Null Or a.操作人员 <> v_开嘱医生);
          If Nvl(v_Count, 0) = 0 Then
            v_Error := '医嘱"' || Getadvicetext(医嘱id_In) || '"还没有电子签名，不能通过校对。';
            Raise Err_Custom;
          End If;
        End If;
        Exit;
      End Loop;
    End If;
  End If;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --因为可能同时：新开->自动校对->互斥自动停止,因此分别-2,-1秒
  Select Sysdate - 1 / 60 / 60 / 24 Into v_Date From Dual;

  Update 病人医嘱记录
  Set 医嘱状态 = 状态_In, 校对护士 = v_人员姓名, 校对时间 = 校对时间_In
  Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间, 操作说明)
    Select ID, 状态_In, v_人员姓名, v_Date, 校对说明_In From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;

  --校对通过时的其它处理
  If 状态_In = 3 Then
    --自动校对时，自动填写缺省的计价内容
    If Nvl(自动校对_In, 0) = 1 Then
      --1.变价的计价项目,如果最低限价不为0,则缺省为最低限价,否则不加入;可再手工计价.
      --2.对于非药嘱药品和在用卫材未定执行科室,发送时会取缺省的,可再手工设置。
      For r_Price In c_Price Loop
        --取(检验)医嘱的管码和材料,采集方式以检验项目的为准
        v_材料id := Null;
        If r_Price.诊疗类别 = 'E' And r_Price.操作类型 = '6' Then
          Begin
            Select c.材料id
            Into v_材料id
            From 病人医嘱记录 A, 诊疗项目目录 B, 采血管类型 C
            Where a.诊疗项目id = b.Id And b.试管编码 = c.编码 And a.相关id = r_Price.Id And Rownum = 1;
          Exception
            When Others Then
              Null;
          End;
        Elsif r_Price.诊疗类别 = 'C' And r_Price.试管编码 Is Not Null Then
          Begin
            Select 材料id Into v_材料id From 采血管类型 Where 编码 = r_Price.试管编码;
          Exception
            When Others Then
              Null;
          End;
        End If;
      
        --判断处理检验试管费用的收取
        If (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And r_Price.收费项目id = Nvl(v_材料id, 0) Or
           Not (Nvl(r_Price.收费方式, 0) = 1 And r_Price.收费类别 = '4' And Nvl(v_材料id, 0) <> 0)) Then
          Insert Into 病人医嘱计价
            (医嘱id, 收费细目id, 数量, 单价, 从项, 执行科室id, 费用性质, 收费方式)
          Values
            (r_Price.Id, r_Price.收费项目id, r_Price.收费数量, r_Price.单价, r_Price.从属项目, Null, r_Price.费用性质, r_Price.收费方式);
        End If;
      End Loop;
    End If;
  
    --自由录入的临嘱医嘱标记为停止
    If Nvl(v_期效, 0) = 1 And v_诊疗项目id Is Null Then
      Update 病人医嘱记录
      Set 医嘱状态 = 8, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    
      Insert Into 病人医嘱状态
        (医嘱id, 操作类型, 操作人员, 操作时间)
        Select ID, 8, v_人员姓名, Sysdate From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    End If;
  
    --将同一自动停止互斥组中的病人其它医嘱停止(如果尚未停止)
    For r_Exclude In c_Exclude Loop
      Select Decode(Sign(r_Exclude.开始执行时间 - v_开始时间), 1, r_Exclude.开始执行时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Select Decode(Sign(r_Exclude.执行终止时间 - v_开始时间), -1, r_Exclude.执行终止时间, v_开始时间)
      Into v_终止时间
      From Dual;
      Zl_病人医嘱记录_停止(r_Exclude.医嘱id, v_终止时间, v_开嘱医生, 1);
      v_Stopadviceids := v_Stopadviceids || ',' || r_Exclude.医嘱id;
    End Loop;
  
    --对一些特殊医嘱的处理
    If v_诊疗类别 = 'H' And v_操作类型 = '1' And Nvl(v_期效, 0) = 0 Then
      --校对护理等级时,同步更改病人护理等级
      If Nvl(v_婴儿, 0) = 0 Then
        --病人当前应处于正常住院状态
        v_Temp := Null;
        Begin
          Select Decode(状态, 1, '等待入科', 2, '正在转科', 3, '已预出院', Null)
          Into v_Temp
          From 病案主页
          Where 病人id = v_病人id And 主页id = v_主页id;
        Exception
          When Others Then
            Null;
        End;
        If v_Temp Is Not Null Then
          v_Error := '病人当前处于' || v_Temp || '状态,医嘱"' || v_医嘱内容 || '"不能通过校对。';
          Raise Err_Custom;
        End If;
      
        Begin
          --根据收费对照处理，当前医嘱计价表还没有填写
          --未设置时,不处理；相同时,不处理；有多个时,只取一个。
          Select a.收费项目id
          Into v_护理等级id
          From 诊疗收费关系 A, 收费项目目录 B
          Where a.收费项目id = b.Id And b.类别 = 'H' And Nvl(b.项目特性, 0) <> 0 And a.诊疗项目id = v_诊疗项目id And Rownum = 1 And
                Not Exists
           (Select 1 From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 护理等级id = a.收费项目id);
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      --变动记录的时间加上秒，以便回退操作时区分同一分种的校对、停止等操作
      v_开始时间 := To_Date(To_Char(v_开始时间, 'yyyy-mm-dd hh24:mi') || To_Char(Sysdate, 'ss'), 'yyyy-mm-dd hh24:mi:ss');
      If v_护理等级id Is Not Null Then
        Zl_病人变动记录_Nurse(v_病人id, v_主页id, v_护理等级id, v_开始时间, v_人员编号, v_人员姓名);
      End If;
    
      --并停止其它护理等级医嘱(护理等级应该都为"持续性"长嘱,且只有一个未停)
      For r_Nurse In c_Nurse Loop
        Select Decode(Sign(r_Nurse.开始执行时间 - v_开始时间), 1, r_Nurse.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Nurse.执行终止时间 - v_开始时间), -1, r_Nurse.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Nurse.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Nurse.医嘱id;
      End Loop;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 In ('9', '10') And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --病重病危医嘱：9-病重;10-病危
      --停止相同医嘱
      For r_Patistate In c_Patistate Loop
        Select Decode(Sign(r_Patistate.开始执行时间 - v_开始时间), 1, r_Patistate.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patistate.执行终止时间 - v_开始时间), -1, r_Patistate.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patistate.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patistate.医嘱id;
      End Loop;
    
      --产生病情变动
      Open c_Oldinfo; --必须在处理之前先打开
      Fetch c_Oldinfo
        Into r_Oldinfo;
      Open c_Endinfo;
      Fetch c_Endinfo
        Into r_Endinfo;
      If c_Endinfo%RowCount = 0 Then
        Close c_Endinfo;
        v_Error := '未发现该病人当前有效的变动记录！';
        Raise Err_Custom;
      End If;
      Select Count(*)
      Into v_Count
      From 病人变动记录
      Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 Is Null And 终止时间 Is Null;
      If v_Count > 0 Then
        v_Error := '病人当前处于转科状态，请先办理转科确认或者取消转科状态。';
        Raise Err_Custom;
      End If;
    
      Update 病案主页
      Set 当前病况 = Decode(v_操作类型, '9', '重', '10', '危')
      Where 病人id = v_病人id And 主页id = v_主页id;
    
      --取消上次变动
      If r_Oldinfo.终止时间 Is Not Null Then
        v_变动终止时间 := r_Oldinfo.终止时间;
        v_变动终止原因 := r_Oldinfo.终止原因;
        v_变动终止人员 := r_Oldinfo.终止人员;
        --取消上次变动
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名, 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 = v_变动终止时间 And 终止原因 = v_变动终止原因;
        --更新将来的记录如果有停止到将来的则删除上次计算时间
        Update 病人变动记录
        Set 病情 = Decode(v_操作类型, '9', '重', '10', '危'), 上次计算时间 = Null
        Where 病人id = v_病人id And 主页id = v_主页id And 开始时间 > v_开始时间;
      Else
        Update 病人变动记录
        Set 终止时间 = v_开始时间, 终止原因 = 13, 终止人员 = v_人员姓名,
            上次计算时间 = Decode(Sign(Nvl(上次计算时间, v_开始时间) - v_开始时间), 1, Null, 上次计算时间)
        Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null;
      End If;
    
      While c_Oldinfo%Found Loop
        Insert Into 病人变动记录
          (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号, 操作员姓名,
           终止时间, 终止原因, 终止人员)
        Values
          (病人变动记录_Id.Nextval, v_病人id, v_主页id, v_开始时间, 13, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
           r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师, r_Oldinfo.主治医师,
           r_Oldinfo.主任医师, Decode(v_操作类型, '9', '重', '10', '危'), v_人员编号, v_人员姓名, v_变动终止时间, v_变动终止原因, v_变动终止人员);
      
        Fetch c_Oldinfo
          Into r_Oldinfo;
      End Loop;
    
      Close c_Oldinfo;
      Close c_Endinfo;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '12' And Nvl(v_期效, 0) = 0 And Nvl(v_婴儿, 0) = 0 Then
      --记录入出量的医嘱，互斥
      For r_Patiio In c_Patiio Loop
        Select Decode(Sign(r_Patiio.开始执行时间 - v_开始时间), 1, r_Patiio.开始执行时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Select Decode(Sign(r_Patiio.执行终止时间 - v_开始时间), -1, r_Patiio.执行终止时间, v_开始时间)
        Into v_终止时间
        From Dual;
        Zl_病人医嘱记录_停止(r_Patiio.医嘱id, v_终止时间, v_开嘱医生, 1);
        v_Stopadviceids := v_Stopadviceids || ',' || r_Patiio.医嘱id;
      End Loop;
    Elsif (v_诊疗类别 = 'Z' And v_操作类型 In ('3', '4', '5', '6', '11', '14') And
          (v_操作类型 <> '14' Or v_操作类型 = '14' And v_执行标记 = 1)) Or (v_诊疗类别 = 'F' And v_执行标记 = 1) Then
      v_Count := 0;
      If v_操作类型 = '4' Or v_操作类型 = '14' Or v_诊疗类别 = 'F' Then
        --保持与以前校对时相同的处理
        If Nvl(v_婴儿, 0) = 0 Then
          v_Count := 1;
        End If;
      Else
        --这几个特殊医嘱在校对中停止医嘱是新加的内容，保持与发送中相同的处理
        v_Count := 1;
        If Nvl(v_婴儿, 0) = 0 Then
          v_婴儿 := -1;
        Else
          v_婴儿 := Nvl(v_婴儿, 0);
        End If;
      End If;
      If v_Count = 1 Then
        If v_诊疗类别 = 'F' And v_执行标记 = 1 Then
          --在手术当天(取整)停止
          v_开始时间 := Trunc(To_Date(v_标本部位, 'yyyy-mm-dd hh24:mi:ss'));
        End If;
      
        --几个特殊医嘱校对时停止前面的长嘱,在医嘱开始时终止：3-转科;4-术后;5-出院;6-转院,11-死亡,14-术前
        For r_Needstop In c_Needstop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Select Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间)
          Into v_停止时间
          From 病人医嘱记录
          Where ID = r_Needstop.Id;
          Update 病人医嘱记录
          Set 医嘱状态 = 8, 执行终止时间 = v_停止时间, 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Needstop.Id;
        
          Insert Into 病人医嘱状态
            (医嘱id, 操作类型, 操作人员, 操作时间)
            Select ID, 8, v_人员姓名, 校对时间_In From 病人医嘱记录 Where ID = r_Needstop.Id;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Needstop.Id;
        End Loop;
        --已停止未确认的长嘱,终止时间在医嘱开始后的,调前其终止时间(同时多个特殊医嘱的情况)
        For r_Havestop In c_Havestop(v_病人id, v_主页id, v_婴儿, v_开始时间) Loop
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Sign(开始执行时间 - v_开始时间), 1, 开始执行时间, v_开始时间), 停嘱时间 = 校对时间_In, 停嘱医生 = v_开嘱医生
          Where ID = r_Havestop.Id;
        
          --不修改停止医嘱的操作人员，因为停止时，医生可能已进行电子签名
          Update 病人医嘱状态 Set 操作时间 = 校对时间_In Where 医嘱id = r_Havestop.Id And 操作类型 = 8;
          v_Stopadviceids := v_Stopadviceids || ',' || r_Havestop.Id;
        End Loop;
        --处理长期备用医嘱(没有执行（发送）过的标记未用）
        Update 病人医嘱记录
        Set 执行标记 = -1
        Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 0 And 执行频次 = '必要时' And 上次执行时间 Is Null And 医嘱状态 In (3, 5, 6, 7) And
              执行标记 <> -1;
        --如果是转院转科死亡出院医嘱同时处理临时备用医嘱。
        If v_操作类型 In ('3', '5', '6', '11') Then
          Update 病人医嘱记录
          Set 执行标记 = -1
          Where 病人id = v_病人id And 主页id = v_主页id And 医嘱期效 = 1 And 执行频次 = '需要时' And 医嘱状态 = 3 And 执行标记 <> -1;
        End If;
      End If;
    Elsif v_诊疗类别 = 'Z' And v_操作类型 = '2' Then
      --对留观病人下达入院通知;
      --预约登记的条件：1.当前无预约,2.当前是门诊留观病人（在院时也允许，因为需要先预约,入院接收时检查了必须出院后才能接收）
      Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And Nvl(主页id, 0) = 0;
      If v_Count = 0 Then
        Select Count(*) Into v_Count From 病案主页 Where 病人id = v_病人id And 主页id = v_主页id And 病人性质 <> 1;
      End If;
      If v_Count = 0 Then
        Open c_Pati(v_病人id);
        Fetch c_Pati
          Into r_Pati;
        Close c_Pati;
      
        v_入院方式 := Null;
        If v_紧急标志 = 1 Then
          v_入院方式 := '急诊';
        End If;
      
        Zl_入院病案主页_Insert(1, 0, r_Pati.病人id, r_Pati.住院号, Null, r_Pati.姓名, r_Pati.性别, r_Pati.年龄, r_Pati.费别, r_Pati.出生日期,
                         r_Pati.国籍, r_Pati.民族, r_Pati.学历, r_Pati.婚姻状况, r_Pati.职业, r_Pati.身份, r_Pati.身份证号, r_Pati.出生地点,
                         r_Pati.家庭地址, r_Pati.家庭地址邮编, r_Pati.家庭电话, r_Pati.户口地址, r_Pati.户口地址邮编, r_Pati.联系人姓名, r_Pati.联系人关系,
                         r_Pati.联系人地址, r_Pati.联系人电话, r_Pati.工作单位, r_Pati.合同单位id, r_Pati.单位电话, r_Pati.单位邮编, r_Pati.单位开户行,
                         r_Pati.单位帐号, r_Pati.担保人, r_Pati.担保额, r_Pati.担保性质, v_执行科室id, Null, Null, v_入院方式, Null, Null,
                         v_开嘱医生, r_Pati.籍贯, r_Pati.区域, v_开始时间, Null, Null, r_Pati.医疗付款方式, Null, Null, Null, Null, Null,
                         Null, r_Pati.险类, v_人员编号, v_人员姓名, 0, Null, Null, 0);
      End If;
    End If;
    --医嘱停止消息的处理
    If v_Stopadviceids Is Not Null Then
      v_Stopadviceids := Substr(v_Stopadviceids, 2);
      Select Max(a.Id)
      Into n_标记
      From 病人医嘱记录 A
      Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.医嘱期效 = 0 And a.医嘱状态 = 8 And
            Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
      If n_标记 Is Not Null Then
        Select Max(a.Id)
        Into n_Adviceid
        From 病人医嘱记录 A
        Where a.Id In (Select Column_Value From Table(f_Num2list(v_Stopadviceids))) And a.紧急标志 = 1 And a.医嘱期效 = 0 And
              a.医嘱状态 = 8 And Nvl(a.执行标记, 0) <> -1 And a.病人来源 <> 3;
        If n_Adviceid Is Not Null Then
          n_Adviceid := n_标记;
          Select Nvl(Max(0), 2)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.优先程度 = 2 And a.是否已阅 = 0;
        Else
          Select Nvl(Max(0), 1)
          Into n_标记
          From 业务消息清单 A
          Where a.病人id = v_病人id And a.就诊id = v_主页id And a.类型编码 = 'ZLHIS_CIS_002' And a.是否已阅 = 0;
        End If;
        If n_标记 > 0 Then
          For R In (Select a.病人性质 As 性质, a.出院科室id As 科室id, a.当前病区id As 病区id
                    From 病案主页 A
                    Where a.病人id = v_病人id And a.主页id = v_主页id) Loop
            Zl_业务消息清单_Insert(v_病人id, v_主页id, r.科室id, r.病区id, r.性质, '有新停止医嘱。', '0010', 'ZLHIS_CIS_002', n_Adviceid, n_标记,
                             0, Null, r.病区id);
          End Loop;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_校对;
/

--103236:刘尔旋,2016-12-22,支付宝服务窗停诊处理
--102103:刘尔旋,2016-11-07,支付宝简易模式挂号
--68694:刘尔旋,2016-10-20,新挂号安排
--100934:刘尔旋,2016-10-11,锁号并发处理
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <CZJLID>1</CZJLID>       //出诊记录ID,出诊表排班模式下传入
  --  <RQ>2013-11-21 09:00</RQ>     //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --  <SJD>时间段</SJD>        //锁号的时间段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- 错误信息  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码         挂号安排.号码%Type;
  d_日期         Date;
  n_操作类型     Number(3);
  n_序号控制     Number(3);
  n_存在         Number(3);
  n_分时段       Number(3);
  n_限号数       挂号安排限制.限号数%Type;
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  n_号序         挂号序号状态.序号%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  n_状态         挂号序号状态.状态%Type;
  v_合作单位     合作单位安排控制.合作单位%Type;
  n_合约模式     Number(3);
  n_启用合作单位 Number(3);
  v_Temp         Varchar2(32767); --临时XML
  v_Optemp       Varchar2(300);
  x_Templet      Xmltype; --模板XML
  n_Exists       Number(2);
  n_记录id       临床出诊记录.Id%Type;
  n_序号         临床出诊序号控制.序号%Type;
  n_数量         临床出诊序号控制.数量%Type;
  n_顺序号       临床出诊序号控制.预约顺序号%Type;
  d_启用时间     Date;
  v_时间段       Varchar2(200);
  v_Para         Varchar2(2000);
  n_挂号模式     Number(3);
  d_时段开始     Date;
  d_序号时间     Date;
  d_时段结束     Date;
  n_出诊         Number(3);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM'), Extractvalue(Value(A), 'IN/CZJLID'), Extractvalue(Value(A), 'IN/SJD')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名, n_记录id, v_时间段
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;
  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(d_日期, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(d_日期, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      Begin
        Select a.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_日期, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If v_时间段 Is Not Null And n_操作类型 = 1 Then
    Begin
      d_时段开始 := To_Date(To_Char(d_日期, 'yyyy-mm-dd') || Substr(v_时间段, 1, Instr(v_时间段, '-') - 1), 'yyyy-mm-dd hh24:mi:ss');
      If Substr(v_时间段, Instr(v_时间段, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(d_日期, 'yyyy-mm-dd') || Substr(v_时间段, Instr(v_时间段, '-') + 1), 'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_Optemp := Zl_Identity(1);
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_Optemp From Dual;
  Select Substr(v_Optemp, Instr(v_Optemp, ',') + 1) Into v_操作员姓名 From Dual;

  If n_记录id Is Null Then
    If n_操作类型 = 0 Then
      --解锁
      Select Nvl(Max(1), 0)
      Into n_Exists
      From 挂号序号状态
      Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码 And
            Rownum < 2;
      If n_Exists = 1 Then
        Delete 挂号序号状态
        Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(d_日期) And 号码 = v_号码;
        v_Temp := '<HX>' || n_号序 || '</HX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Else
        v_Temp := '没有发现需要解锁的序号';
        Raise Err_Item;
      End If;
    End If;
  
    If n_操作类型 = 1 Then
      --锁号
      Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                     Null)
      Into v_星期
      From Dual;
      Begin
        Select 序号控制, ID
        Into n_序号控制, n_计划id
        From (Select 序号控制, ID
               From 挂号安排计划
               Where 号码 = v_号码 And d_日期 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                     Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
               Order By 生效时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
      End;
      If n_序号控制 = 1 Then
        If Nvl(n_计划id, 0) <> 0 Then
          Select Nvl(Max(1), 0)
          Into n_分时段
          From 挂号计划时段
          Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
          Select Nvl(Max(1), 0)
          Into n_启用合作单位
          From 合作单位计划控制
          Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
          If v_时间段 Is Null Then
            Begin
              Select 1, a.状态, a.操作员姓名, a.机器名
              Into n_存在, n_状态, v_验证姓名, v_验证机器名
              From 挂号序号状态 A, 挂号计划时段 B
              Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
                    To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                n_存在 := 0;
            End;
          Else
            n_存在 := 0;
          End If;
        
          If n_存在 = 1 Then
            If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
              Null;
            Else
              --传入时间的序号已经被使用
              v_Temp := '传入时间' || d_日期 || '的序号已被使用';
              Raise Err_Item;
            End If;
          Else
            If n_分时段 = 1 Then
              If v_时间段 Is Null Then
                --精确定位序号
                Begin
                  Select 序号
                  Into n_号序
                  From 挂号计划时段
                  Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Rownum < 2;
                Exception
                  When Others Then
                    Select Max(序号) + 1
                    Into n_号序
                    From (Select Distinct 序号
                           From 挂号计划时段
                           Where 计划id = n_计划id And 星期 = v_星期
                           Union
                           Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                  
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              Else
                --时间段自动取序号
                Begin
                  Select Min(a.序号)
                  Into n_号序
                  From 挂号计划时段 A, 挂号序号状态 B
                  Where a.序号 = b.序号(+) And Nvl(b.状态, 0) = 0 And b.号码(+) = v_号码 And Trunc(b.日期(+)) = Trunc(d_日期) And
                        a.计划id = n_计划id And a.星期 = v_星期 And To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi');
                  If Nvl(n_号序, 0) = 0 Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号计划时段
                             Where 计划id = n_计划id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号计划时段
                             Where 计划id = n_计划id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                End;
                Begin
                  Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
                  Into d_序号时间
                  From 挂号计划时段
                  Where 计划id = n_计划id And 星期 = v_星期 And 序号 = n_号序;
                Exception
                  When Others Then
                    d_序号时间 := d_日期;
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_序号时间 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_序号时间, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              End If;
              v_Temp := '<HX>' || n_号序 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位计划控制
                               Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              Else
                Select Count(1)
                Into n_合约模式
                From 合作单位计划控制
                Where 序号 = 0 And 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
                If n_合约模式 = 0 Then
                  Begin
                    Select 序号
                    Into n_号序
                    From (Select 序号
                           From 合作单位计划控制 A
                           Where 计划id = n_计划id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                                 (Not Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                         机器名 = v_机器名))
                           Order By 序号)
                    Where Rownum < 2;
                  Exception
                    When Others Then
                      n_号序 := 0;
                  End;
                  If n_号序 = 0 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位计划控制
                               Where 计划id = n_计划id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              End If;
            End If;
          End If;
        Else
          Select Nvl(Max(1), 0)
          Into n_分时段
          From 挂号安排时段
          Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
          Select Nvl(Max(1), 0)
          Into n_启用合作单位
          From 合作单位安排控制
          Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
          If v_时间段 Is Null Then
            Begin
              Select 1, a.状态, a.操作员姓名, a.机器名
              Into n_存在, n_状态, v_验证姓名, v_验证机器名
              From 挂号序号状态 A, 挂号安排时段 B
              Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(d_日期) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
                    To_Char(b.开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And Rownum < 2;
            Exception
              When Others Then
                n_存在 := 0;
            End;
          Else
            n_存在 := 0;
          End If;
          If n_存在 = 1 Then
            If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
              Null;
            Else
              --传入时间的序号已经被使用
              v_Temp := '传入时间' || d_日期 || '的序号已被使用';
              Raise Err_Item;
            End If;
          Else
            If n_分时段 = 1 Then
              If v_时间段 Is Null Then
                Begin
                  Select 序号
                  Into n_号序
                  From 挂号安排时段
                  Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Rownum < 2;
                Exception
                  When Others Then
                    Select Max(序号) + 1
                    Into n_号序
                    From (Select Distinct 序号
                           From 挂号安排时段
                           Where 安排id = n_安排id And 星期 = v_星期
                           Union
                           Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_日期 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_日期, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              Else
                --时间段自动取序号
                Begin
                  Select Min(a.序号)
                  Into n_号序
                  From 挂号安排时段 A, 挂号序号状态 B
                  Where a.序号 = b.序号(+) And Nvl(b.状态, 0) = 0 And b.号码(+) = v_号码 And Trunc(b.日期(+)) = Trunc(d_日期) And
                        a.安排id = n_安排id And a.星期 = v_星期 And To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi');
                  If n_号序 Is Null Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号安排时段
                             Where 安排id = n_安排id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      Select Max(序号) + 1
                      Into n_号序
                      From (Select Distinct 序号
                             From 挂号安排时段
                             Where 安排id = n_安排id And 星期 = v_星期
                             Union
                             Select Distinct 序号 From 挂号序号状态 Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期));
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '的序号已被使用完';
                      Raise Err_Item;
                    End If;
                  
                End;
                Begin
                  Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
                  Into d_序号时间
                  From 挂号安排时段
                  Where 安排id = n_安排id And 星期 = v_星期 And 序号 = n_号序;
                Exception
                  When Others Then
                    d_序号时间 := d_日期;
                End;
                Begin
                  Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号码 And 日期 = d_序号时间 And 序号 = n_号序;
                Exception
                  When Others Then
                    Insert Into 挂号序号状态
                      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                    Values
                      (v_号码, d_序号时间, n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                End;
              End If;
              v_Temp := '<HX>' || n_号序 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
                If Trunc(d_日期) = Trunc(Sysdate) Then
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位安排控制
                               Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              Else
                Select Count(1)
                Into n_合约模式
                From 合作单位安排控制
                Where 序号 = 0 And 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0;
                If n_合约模式 = 0 Then
                  Begin
                    Select 序号
                    Into n_号序
                    From (Select 序号
                           From 合作单位安排控制 A
                           Where 安排id = n_安排id And 合作单位 = v_合作单位 And 限制项目 = v_星期 And 数量 <> 0 And
                                 (Not Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 <> 5) Or Exists
                                  (Select 1
                                   From 挂号序号状态
                                   Where 号码 = v_号码 And 序号 = a.序号 And Trunc(日期) = Trunc(d_日期) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                                         机器名 = v_机器名))
                           Order By 序号)
                    Where Rownum < 2;
                  Exception
                    When Others Then
                      n_号序 := 0;
                  End;
                  If n_号序 = 0 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                Else
                  n_号序 := 1;
                  Select 限号数 Into n_限号数 From 挂号安排限制 Where 安排id = n_安排id And 限制项目 = v_星期;
                  For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                               From 挂号序号状态
                               Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期)
                               
                               Union
                               Select 序号, Null, Null, Null
                               From 合作单位安排控制
                               Where 安排id = n_安排id And 限制项目 = v_星期 And 数量 <> 0
                               Order By 序号) Loop
                    Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
                    If r_序号.序号 = n_号序 Then
                      n_号序 := n_号序 + 1;
                    End If;
                  End Loop;
                  If n_号序 > n_限号数 Then
                    v_Temp := '传入号别' || v_号码 || '的所有序号已被用完';
                    Raise Err_Item;
                  Else
                    Begin
                      Select 1
                      Into n_存在
                      From 挂号序号状态
                      Where 号码 = v_号码 And Trunc(日期) = Trunc(d_日期) And 序号 = n_号序;
                    Exception
                      When Others Then
                        Insert Into 挂号序号状态
                          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
                        Values
                          (v_号码, Trunc(d_日期), n_号序, 5, v_操作员姓名, '移动锁号', Sysdate, v_机器名);
                    End;
                    v_Temp := '<HX>' || n_号序 || '</HX>';
                    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End If;
  Else
    --出诊表排班模式
    If n_操作类型 = 0 Then
      --解锁
      Select Nvl(Max(1), 0)
      Into n_Exists
      From 临床出诊序号控制
      Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_号序 Or 备注 = n_号序) And 记录id = n_记录id And
            Rownum < 2;
      If n_Exists = 1 Then
        Update 临床出诊序号控制
        Set 挂号状态 = 0
        Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_号序 Or 备注 = n_号序) And 记录id = n_记录id;
        v_Temp := '<HX>' || n_号序 || '</HX>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Else
        v_Temp := '没有发现需要解锁的序号';
        Raise Err_Item;
      End If;
    End If;
  
    If n_操作类型 = 1 Then
      --锁号
      Select Nvl(Max(1), 0)
      Into n_出诊
      From 临床出诊记录
      Where ID = n_记录id And d_日期 Between 开始时间 And 终止时间 And Rownum < 2;
      If Nvl(n_出诊, 0) = 0 Then
        v_Temp := '传入的出诊记录与时间不符,请检查!';
        Raise Err_Item;
      End If;
      If n_号序 Is Null Then
        Select 是否序号控制, 是否分时段 Into n_序号控制, n_分时段 From 临床出诊记录 Where ID = n_记录id;
        Select Nvl(Max(1), 0)
        Into n_启用合作单位
        From 临床出诊挂号控制记录
        Where 记录id = n_记录id And 名称 = v_合作单位 And 类型 = 1 And 性质 = 1 And Rownum < 2;
        If n_序号控制 = 1 Then
          If n_分时段 = 1 Then
            If v_时间段 Is Null Then
              Update 临床出诊序号控制
              Set 备注 = 备注
              Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                    Rownum < 2;
              Begin
                Select 1, 挂号状态, 操作员姓名, 工作站名称
                Into n_存在, n_状态, v_验证姓名, v_验证机器名
                From 临床出诊序号控制
                Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                      Nvl(挂号状态, 0) <> 0 And Rownum < 2;
              Exception
                When Others Then
                  n_存在 := 0;
              End;
            Else
              n_存在 := 0;
            End If;
          
            If n_存在 = 1 Then
              If n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名 Then
                Null;
              Else
                --传入时间的序号已经被使用
                v_Temp := '传入时间' || d_日期 || '的序号已被使用';
                Raise Err_Item;
              End If;
            Else
              If v_时间段 Is Null Then
                Begin
                  Select 序号
                  Into n_序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(d_日期, 'hh24:mi') And
                        Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And Rownum < 2;
                Exception
                  When Others Then
                    If Trunc(d_日期) = Trunc(Sysdate) Then
                      Select Min(序号)
                      Into n_序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                      If Nvl(n_序号, 0) = 0 Then
                        Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                      End If;
                    Else
                      v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                      Raise Err_Item;
                    End If;
                End;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
              Else
                Begin
                  Select Min(序号)
                  Into n_序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
                        Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And
                        To_Char(开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Rownum < 2;
                  If Nvl(n_序号, 0) = 0 Then
                    If d_时段结束 Is Null Then
                      If Trunc(d_日期) = Trunc(Sysdate) Then
                        Select Min(序号)
                        Into n_序号
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                        If Nvl(n_序号, 0) = 0 Then
                          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                        End If;
                      Else
                        v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                        Raise Err_Item;
                      End If;
                    
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '序号已被使用完,无法预约';
                      Raise Err_Item;
                    End If;
                  End If;
                Exception
                  When Others Then
                    If d_时段结束 Is Null Then
                      If Trunc(d_日期) = Trunc(Sysdate) Then
                        Select Min(序号)
                        Into n_序号
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 开始时间 >= d_日期 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                        If Nvl(n_序号, 0) = 0 Then
                          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                        End If;
                      Else
                        v_Temp := '传入时间' || d_日期 || '没有找到对应的序号,无法预约';
                        Raise Err_Item;
                      End If;
                    Else
                      v_Temp := '传入时间段' || v_时间段 || '序号已被使用完,无法预约';
                      Raise Err_Item;
                    End If;
                End;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
              End If;
            End If;
            v_Temp := '<HX>' || n_序号 || '</HX>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Else
            If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
              --非合作单位
              Select Min(序号)
              Into n_序号
              From 临床出诊序号控制
              Where 记录id = n_记录id And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
              If Nvl(n_序号, 0) = 0 Then
                Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
              End If;
              Update 临床出诊序号控制
              Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
              Where 记录id = n_记录id And 序号 = n_序号;
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                  Select 记录id, n_序号,
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'),
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And Rownum < 2;
              End If;
              v_Temp := '<HX>' || n_序号 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Else
              --合作单位
              Begin
                Select 控制方式
                Into n_合约模式
                From 临床出诊挂号控制记录
                Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约模式 := 4;
              End;
              If n_合约模式 = 0 Then
                v_Temp := '本号别禁止该合作单位预约!';
                Raise Err_Item;
              End If;
              If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
                Select Min(序号)
                Into n_序号
                From 临床出诊序号控制
                Where 记录id = n_记录id And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_序号 = 0 Then
                  Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
                End If;
              End If;
              If n_合约模式 = 3 Then
                Select Min(a.序号)
                Into n_序号
                From 临床出诊序号控制 A, 临床出诊挂号控制记录 B
                Where a.记录id = n_记录id And a.记录id = b.记录id And b.类型 = 1 And b.性质 = 1 And b.名称 = v_合作单位 And a.序号 = b.序号 And
                      Nvl(a.挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_序号 = 0 Then
                  v_Temp := '本号别合作单位可预约序号已经全部使用完!';
                  Raise Err_Item;
                End If;
              End If;
              Update 临床出诊序号控制
              Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
              Where 记录id = n_记录id And 序号 = n_序号;
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
                  Select 记录id, n_序号,
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'),
                         To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                  'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And Rownum < 2;
              End If;
              v_Temp := '<HX>' || n_序号 || '</HX>';
              Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            End If;
          End If;
        End If;
      Else
        --非序号控制
        If n_分时段 = 1 Then
          If v_合作单位 Is Null Or n_启用合作单位 = 0 Then
            Begin
              If v_时间段 Is Null Then
                Select 序号, 数量
                Into n_号序, n_数量
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
              Else
                Select Min(序号)
                Into n_号序
                From 临床出诊序号控制 A
                Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                      数量 > (Select Count(1)
                            From 临床出诊序号控制
                            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                If Nvl(n_号序, 0) = 0 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                End If;
                Select 数量
                Into n_数量
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
              End If;
              Select Count(1)
              Into n_Exists
              From 临床出诊序号控制
              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
            
              If n_Exists >= n_数量 Then
                v_Temp := '本号别可用序号已经全部使用完!';
                Raise Err_Item;
              Else
                Select Min(预约顺序号)
                Into n_顺序号
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                If n_顺序号 = 0 Then
                  Select Max(预约顺序号) + 1
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                End If;
                Update 临床出诊序号控制
                Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                If Sql%RowCount = 0 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                    Select 记录id, n_序号,
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And Rownum < 2;
                End If;
                v_Temp := '<HX>' || n_号序 || '</HX>';
                Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
              End If;
            Exception
              When Others Then
                Null;
            End;
          Else
            --合作单位
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              v_Temp := '本号别禁止该合作单位预约!';
              Raise Err_Item;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
              Begin
                If v_时间段 Is Null Then
                  Select 序号, 数量
                  Into n_号序, n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
                Else
                  Select Min(序号)
                  Into n_号序
                  From 临床出诊序号控制 A
                  Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                        数量 > (Select Count(1)
                              From 临床出诊序号控制
                              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                  If Nvl(n_号序, 0) = 0 Then
                    v_Temp := '本号别可用序号已经全部使用完!';
                    Raise Err_Item;
                  End If;
                  Select 数量
                  Into n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
                End If;
                Select Count(1)
                Into n_Exists
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
                If n_Exists >= n_数量 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                Else
                  Select Min(预约顺序号)
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                  If n_顺序号 = 0 Then
                    Select Max(预约顺序号) + 1
                    Into n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                  End If;
                  Update 临床出诊序号控制
                  Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                  Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                  If Sql%RowCount = 0 Then
                    Insert Into 临床出诊序号控制
                      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                      Select 记录id, n_序号,
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'),
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And Rownum < 2;
                  End If;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Exception
                When Others Then
                  Null;
              End;
            End If;
            If n_合约模式 = 3 Then
              Begin
                If v_时间段 Is Null Then
                  Select 序号
                  Into n_号序
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = d_日期;
                  Select 数量
                  Into n_数量
                  From 临床出诊挂号控制记录
                  Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And 序号 = n_号序;
                Else
                  Select Min(序号)
                  Into n_号序
                  From 临床出诊序号控制 A
                  Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                        数量 > (Select Count(1)
                              From 临床出诊序号控制
                              Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
                  If Nvl(n_号序, 0) = 0 Then
                    v_Temp := '本号别可用序号已经全部使用完!';
                    Raise Err_Item;
                  End If;
                  Select 数量
                  Into n_数量
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_号序;
                End If;
                Select Count(1)
                Into n_Exists
                From 临床出诊序号控制
                Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) <> 0;
                If n_Exists >= n_数量 Then
                  v_Temp := '本号别可用序号已经全部使用完!';
                  Raise Err_Item;
                Else
                  Select Min(预约顺序号)
                  Into n_顺序号
                  From 临床出诊序号控制
                  Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
                  If n_顺序号 = 0 Then
                    Select Max(预约顺序号) + 1
                    Into n_顺序号
                    From 临床出诊序号控制
                    Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_号序;
                  End If;
                  Update 临床出诊序号控制
                  Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名
                  Where 记录id = n_记录id And 序号 = n_序号 And 预约顺序号 = n_顺序号;
                  If Sql%RowCount = 0 Then
                    Insert Into 临床出诊序号控制
                      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号)
                      Select 记录id, n_序号,
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'),
                             To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'),
                                      'yyyy-mm-dd hh24:mi:ss'), 1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名, n_顺序号
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And Rownum < 2;
                  End If;
                  v_Temp := '<HX>' || n_号序 || '</HX>';
                  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
                End If;
              Exception
                When Others Then
                  Null;
              End;
            End If;
          End If;
        End If;
      End If;
    Else
      n_序号 := n_号序;
      Update 临床出诊序号控制
      Set 挂号状态 = 5, 操作员姓名 = v_操作员姓名, 工作站名称 = v_机器名, 锁号时间 = Sysdate
      Where 记录id = n_记录id And 序号 = n_序号;
      If Sql%RowCount = 0 Then
        Begin
          Insert Into 临床出诊序号控制
            (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称)
            Select 记录id, n_序号,
                   To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(d_日期, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   1, 是否预约, 5, Sysdate, v_合作单位, 1, v_操作员姓名, v_机器名
            From 临床出诊序号控制
            Where 记录id = n_记录id And Rownum < 2;
        Exception
          When Others Then
            v_Temp := '传入的锁号序号已被使用!';
            Raise Err_Item;
        End;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Lockno;
/

--101358:张德婷,2016-11-30,还原打印次数规则
--100217:张德婷,2016-10-11,保存实际操作人
CREATE OR REPLACE Procedure Zl_输液配药记录_打印
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  打印时间_In In 输液配药记录.打印时间%Type,
  工作人员_In    In 输液配药记录.工作人员%Type:=null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);
  n_Count  Number(5);
  n_Row    NUmber(5);
Begin

  n_Count := 0;
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);

    n_Count := n_Count + 1;
    select count(id) into n_Row from 输液配药记录 where Nvl(打印标志, 0)<>0 and 打印时间 between Trunc(打印时间_In ) And Trunc(打印时间_In+1) - 1 / 24 / 60 / 60;
    
    if  工作人员_In is null then 
      Update 输液配药记录
      Set 打印标志 =nvl(打印标志,0)+1, 打印流水号=decode(Nvl(打印流水号, 0),0,n_Row+1,打印流水号), 打印时间 = 打印时间_In, 打印序号 = n_Count
      Where ID = v_Tansid;
    else
      Update 输液配药记录
      Set 打印标志 =nvl(打印标志,0)+1, 打印流水号=decode(Nvl(打印流水号, 0),0,n_Row+1,打印流水号), 打印时间 = 打印时间_In, 打印序号 = n_Count,工作人员=工作人员_In
      Where ID = v_Tansid;
    end if;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_打印;
/

--96692:廖思奇,2016-10-11,删除不用的过程
Drop Procedure ZL_病理号码_规则;

--100911:廖思奇,2016-10-10,将参数创建人改为创建人ID
Create Or Replace Function Zl_影像收藏类别_新增
(
  上级id_In   影像收藏类别.上级id%Type,
  收藏类别_In 影像收藏类别.收藏类别%Type,
  是否共享_In 影像收藏类别.是否共享%Type,
  创建人id_In 影像收藏类别.创建人id%Type,
  创建时间_In 影像收藏类别.创建时间%Type
) Return Number Is
  Pragma Autonomous_Transaction;

  v_收藏id 影像收藏类别.Id%Type;

Begin
  Select 影像收藏类别_Id.Nextval Into v_收藏id From Dual;

  Insert Into 影像收藏类别
    (ID, 上级id, 收藏类别, 是否共享, 创建人id, 创建时间)
  Values
    (v_收藏id, 上级id_In, 收藏类别_In, 是否共享_In, 创建人id_In, 创建时间_In);

  Commit;

  Return v_收藏id;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像收藏类别_新增;
/

--100911:廖思奇,2016-10-10,修正参数ID的类型
Create Or Replace Procedure Zl_影像收藏类别_更新分类
(
  Id_In       In 影像收藏类别.Id%Type,
  新上级id_In In 影像收藏类别.上级id%Type
) Is

Begin
  Update 影像收藏类别 Set 上级id = 新上级id_In Where ID = Id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像收藏类别_更新分类;
/

--100908:廖思奇,2016-10-09,影像插件增加右键菜单和工具栏按钮
Create Or Replace Procedure Zl_影像插件功能_Update
(
  插件id_In           In 影像插件功能.插件id%Type,
  名称_In             In 影像插件功能.名称%Type,
  方法_In             In 影像插件功能.方法%Type,
  方法参数_In         In 影像插件功能.方法参数%Type,
  是否启用_In         In 影像插件功能.是否启用%Type,
  是否加入右键菜单_In In 影像插件功能.是否加入右键菜单%Type,
  是否加入工具栏_In   In 影像插件功能.是否加入工具栏%Type,
  Vbs脚本_In          In 影像插件功能.Vbs脚本%Type
) Is

  n_功能序号 影像插件功能.功能序号%Type;
  n_Id       Number;

Begin

  Select Nvl(Max(功能序号), 0) + 1 Into n_功能序号 From 影像插件功能 Where 插件id = 插件id_In;
  Select Nvl(Max(ID), 0) + 1 Into n_Id From 影像插件功能;

  Insert Into 影像插件功能
    (ID, 插件id, 功能序号, 名称, 方法, 方法参数, 是否启用, 是否加入右键菜单, 是否加入工具栏, Vbs脚本)
  Values
    (n_Id, 插件id_In, n_功能序号, 名称_In, 方法_In, 方法参数_In, 是否启用_In, 是否加入右键菜单_In, 是否加入工具栏_In, Vbs脚本_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像插件功能_Update;
/

--99758:梁唐彬,2016-10-09,费用部分退费问题
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Delete
( 
  医嘱id_In     病人医嘱执行.医嘱id%Type, 
  发送号_In     病人医嘱执行.发送号%Type, 
  执行时间_In   病人医嘱执行.执行时间%Type, 
  单独执行_In   Number := 0, 
  自动取消_In   Number := 0, 
  执行部门id_In 门诊费用记录.执行部门id%Type := 0 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
) Is 
  --除了要执行的主记录,还包含了附加手术,检查部位的记录 
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同 
  V_组id     病人医嘱记录.Id%Type; 
  V_诊疗类别 病人医嘱记录.诊疗类别%Type; 
  V_病人来源 病人医嘱记录.病人来源%Type; 
  V_费用性质 病人医嘱发送.记录性质%Type; 
  V_操作类型 诊疗项目目录.操作类型%Type; 
 
  V_自动取消 Number; 
  V_执行状态 Number; 
 
  N_执行次数 Number; 
  N_剩余次数 Number; 
  N_执行状态 Number; 
  N_执行结果 Number; 
  
  n_发送数次 Number;
  n_单次数次 Number;
  v_Count    Number;
  n_登记数次 Number;
  d_要求时间 date;
  
  D_登记时间 病人医嘱执行.登记时间%Type; 
  N_取消执行 Number; 
  N_Diffday  Number(18, 3); 
  Err_Custom Exception; 
  V_Error Varchar2(2000); 
Begin 
  Select A.病人来源, Nvl(A.相关id, A.Id), A.诊疗类别, Nvl(B.操作类型, '0') 操作类型 
  Into V_病人来源, V_组id, V_诊疗类别,V_操作类型 
  From 病人医嘱记录 A, 诊疗项目目录 B 
  Where A.Id = 医嘱id_In And A.诊疗项目id = B.Id; 
 
  Select Nvl(执行结果, 1), 登记时间 
  Into N_执行结果, D_登记时间 
  From 病人医嘱执行 
  Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In And 执行时间 = 执行时间_In; 
  -----取消执行有效天数限制 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into N_取消执行 From Dual; 
  Select Sysdate - D_登记时间 Into N_Diffday From Dual; 
  --登记时间超过取消执行天数的记录，不允许删除医嘱执行记录 
  If N_Diffday > N_取消执行 Then 
    V_Error := '医嘱执行登记时间超过了取消执行有效天数，不能删除医嘱执行记录！'; 
    Raise Err_Custom; 
  End If; 
 
  If V_病人来源 = 2 Then 
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2)) 
    Into V_费用性质 
    From 病人医嘱发送 
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
  Else 
    V_费用性质 := 1; 
  End If; 
 
  --病人医嘱执行 
  Delete From 病人医嘱执行 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In And 执行时间 = 执行时间_In; 
  --对于未执行的医嘱执行记录的删除，不更新医嘱发送以及费用信息的执行状态 
  If N_执行结果 <> 0 Then 
    Select Decode(A.执行状态, 1, A.发送数次, C.登记次数), Decode(A.执行状态, 1, 0, A.发送数次 - C.登记次数)  ,A.发送数次,C.登记次数


    Into N_执行次数, N_剩余次数  ,n_发送数次,n_登记数次
    From 病人医嘱发送 A, 
         (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(B.本次数次), 0) As 登记次数 
           From 病人医嘱执行 B 
           Where B.医嘱id = 医嘱id_In And B.发送号 = 发送号_In And Nvl(B.执行结果, 1) <> 0) C 
    Where A.医嘱id = C.医嘱id And A.发送号 = C.发送号 And A.医嘱id = 医嘱id_In And A.发送号 = 发送号_In; 
   
    --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
    Select Decode(N_剩余次数, 0, 1, Decode(N_执行次数, 0, 0, 2)) Into N_执行状态 From Dual; 
    
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      if n_登记数次>0 Then
        Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
        If v_Count > 0 Then
          n_单次数次 := n_发送数次 / v_Count;
          --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
          v_Count := ceil((n_登记数次 ) / n_单次数次);
          --获取执行截至要求时间 
          Select 要求时间 Into d_要求时间
          From (Select 要求时间, Rownum As 次数
                 From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
          Where 次数 = v_Count;
          
          If Not d_要求时间 Is Null Then
            --先检查是否已经退费
            Select Max(NVL(执行状态,0)) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间;
            If v_Count = 2 Then
              v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。'; 
              Raise Err_Custom; 
            End If;
            --更新截至要求时间之前(含)的记录执行状态；
            Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
            Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 > d_要求时间 And NVL(执行状态,0) <> 2;
          End If;
        End If;
      else
        Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And NVL(执行状态,0) <> 2;
      end if;
    End If;
    
    --如果执行情况删除了就更新执行状态 
    If Nvl(单独执行_In, 0) = 1 Then 
      Update 病人医嘱发送 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 执行状态 = 3 And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
    Else 
      Update 病人医嘱发送 A 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 执行状态 = 3 And 发送号 + 0 = 发送号_In And 
            医嘱id In (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别) And Not Exists 
       (Select 1 From 病人医嘱执行 Where 发送号 + 0 = 发送号_In And 医嘱id = A.医嘱id); 
    End If; 
    --更新对应的费用执行状态为未执行 
    --不应该处理药品和跟踪在用的卫材 
    If V_费用性质 = 2 Then 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    Else 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    End If; 
    --检验采集自动取消采集人采集时间 
    If V_诊疗类别 = 'E' And V_操作类型 = '6' Then 
      Update 病人医嘱发送 A  
      Set A.采样人 = Null, A.采样时间 = Null  
      Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id)) And 发送号 = 发送号_In; 
    End If; 
   
    --已完成执行的，执行数次减少之后自动取消执行完成为正在执行或未执行(主要用于PDA自动执行) 
    If Nvl(自动取消_In, 0) = 1 Then 
      Begin 
        Select Decode(Sign(Nvl(Sum(B.本次数次), 0) - A.发送数次), -1, 1, 0), Decode(Sign(Nvl(Sum(B.本次数次), 0)), 0, 0, 3) 
        Into V_自动取消, V_执行状态 
        From 病人医嘱发送 A, 病人医嘱执行 B 
        Where A.医嘱id = B.医嘱id(+) And A.发送号 = B.发送号(+) And A.执行状态 = 1 And A.医嘱id = 医嘱id_In And A.发送号 = 发送号_In 
        Group By A.发送数次; 
      Exception 
        When Others Then 
          Null; 
      End; 
     
      If Nvl(V_自动取消, 0) = 1 Then 
        Zl_病人医嘱执行_Cancel(医嘱id_In, 发送号_In, Null, 单独执行_In, 执行部门id_In); 
       
        If V_执行状态 = 3 Then 
          Select Nvl(相关id, ID), 诊疗类别 Into V_组id, V_诊疗类别 From 病人医嘱记录 Where ID = 医嘱id_In; 
          Update 病人医嘱发送 
          Set 执行状态 = 3, 完成人 = Null, 完成时间 = Null 
          Where 发送号 + 0 = 发送号_In And 
                医嘱id In (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别); 
        End If; 
       
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱执行_Delete;
/

--99758:梁唐彬,2016-10-09,费用部分退费问题
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Update
( 
  原执行时间_In 病人医嘱执行.执行时间%Type, 
  医嘱id_In     病人医嘱执行.医嘱id%Type, 
  发送号_In     病人医嘱执行.发送号%Type, 
  要求时间_In   病人医嘱执行.要求时间%Type, 
  本次数次_In   病人医嘱执行.本次数次%Type, 
  执行摘要_In   病人医嘱执行.执行摘要%Type, 
  执行人_In     病人医嘱执行.执行人%Type, 
  执行时间_In   病人医嘱执行.执行时间%Type, 
  执行结果_In   病人医嘱执行.执行结果%Type := 1, 
  未执行原因_In 病人医嘱执行.说明%Type := Null, 
  单独执行_In   Number := 0, 
  操作员编号_In 人员表.编号%Type := Null, 
  操作员姓名_In 人员表.姓名%Type := Null, 
  执行部门id_In 门诊费用记录.执行部门id%Type := 0 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
) Is 
  --除了要执行的主记录,还包含了附加手术,检查部位的记录 
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同 
  V_Temp     Varchar2(255); 
  V_人员编号 人员表.编号%Type; 
  V_人员姓名 人员表.姓名%Type; 
 
  V_组id        病人医嘱记录.Id%Type; 
  V_诊疗类别    病人医嘱记录.诊疗类别%Type; 
  V_执行结果old 病人医嘱执行.执行结果%Type; 
  N_本次数次old 病人医嘱执行.本次数次%Type; 
 
  V_病人来源 病人医嘱记录.病人来源%Type; 
  V_费用性质 病人医嘱发送.记录性质%Type; 
 
  N_执行次数 Number; 
  N_剩余次数 Number; 
  N_执行状态 Number; 
  n_发送数次 Number;
  n_单次数次 Number;
  v_Count    Number;
  n_登记数次 Number;
  d_要求时间 date;
  
  D_登记时间 病人医嘱执行.登记时间%Type; 
  N_取消执行 Number; 
  N_Diffday  Number(18, 3); 
 
  V_Date  Date; 
  V_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    V_人员编号 := 操作员编号_In; 
    V_人员姓名 := 操作员姓名_In; 
  Else 
    V_Temp     := Zl_Identity; 
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ';') + 1); 
    V_Temp     := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
    V_人员编号 := Substr(V_Temp, 1, Instr(V_Temp, ',') - 1); 
    V_人员姓名 := Substr(V_Temp, Instr(V_Temp, ',') + 1); 
  End If; 
 
  Select Sysdate Into V_Date From Dual; 
  Select Nvl(执行结果, 1), Nvl(本次数次, 0), 登记时间 
  Into V_执行结果old, N_本次数次old, D_登记时间 
  From 病人医嘱执行 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 原执行时间_In; 
  -----取消执行有效天数限制 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(220), '999')) Into N_取消执行 From Dual; 
  Select V_Date - D_登记时间 Into N_Diffday From Dual; 
  --登记时间超过取消执行天数的记录，不允许修改医嘱执行情况 
  If N_Diffday > N_取消执行 Then 
    V_Error := '医嘱执行登记时间超过了取消执行有效天数，不能修改医嘱执行情况！'; 
    Raise Err_Custom; 
  End If; 
  --病人医嘱执行 
  Update 病人医嘱执行 
  Set 要求时间 = 要求时间_In, 本次数次 = 本次数次_In, 执行摘要 = 执行摘要_In, 执行人 = 执行人_In, 执行时间 = 执行时间_In, 登记时间 = V_Date, 登记人 = V_人员姓名, 
      执行结果 = 执行结果_In, 说明 = 未执行原因_In 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 原执行时间_In; 
  --本次执行次数或这执行结果修改后需要更新单据的执行状态 
  If V_执行结果old <> 执行结果_In Or N_本次数次old <> 本次数次_In Then 
    Select 病人来源, Nvl(相关id, ID), 诊疗类别 
    Into V_病人来源, V_组id, V_诊疗类别 
    From 病人医嘱记录 
    Where ID = 医嘱id_In; 
 
    If v_病人来源 = 2 Then 
      Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2)) 
      Into v_费用性质 
      From 病人医嘱发送 
      Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
    Else 
      v_费用性质 := 1; 
    End If; 
   
    Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数) ,A.发送数次,C.登记次数
    Into n_执行次数, n_剩余次数 ,n_发送数次,n_登记数次
    From 病人医嘱发送 A, 
         (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
           From 病人医嘱执行 B 
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C 
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
   
    --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
    Select Decode(N_剩余次数, 0, 1, Decode(N_执行次数, 0, 0, 2)) Into N_执行状态 From Dual; 
    
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
      If v_Count > 0 Then
        n_单次数次 := n_发送数次 / v_Count;
        --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
        v_Count := ceil((n_登记数次 ) / n_单次数次);
        --获取执行截至要求时间 
        Select 要求时间 Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
        Where 次数 = v_Count;
        
        If Not d_要求时间 Is Null Then
          --先检查是否已经退费
          Select Max(NVL(执行状态,0)) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间;
          If v_Count = 2 Then
            v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。'; 
            Raise Err_Custom; 
          End If;
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
          Update 医嘱执行计价 Set 执行状态 = 0 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 > d_要求时间 And NVL(执行状态,0) <> 2;
        End If;
      End If;
    End If;
 
    --执行次数不为0就标记为正在执行 
    If Nvl(单独执行_In, 0) = 1 Then 
      Update 病人医嘱发送 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
    Else 
      Update 病人医嘱发送 
      Set 执行状态 = Decode(N_执行次数, 0, 0, 3), 完成人 = Null, 完成时间 = Null 
      Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And 
            医嘱id In (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别); 
    End If; 
 
    If V_费用性质 = 2 Then 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 住院费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    Else 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 门诊费用记录 A 
        Set 执行状态 = N_执行状态, 执行人 = Decode(N_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(N_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or A.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = A.收费细目id And 跟踪在用 = 1) And A.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(N_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In 
                     (Select ID From 病人医嘱记录 Where (ID = V_组id Or 相关id = V_组id) And 诊疗类别 = V_诊疗类别)); 
      End If; 
    End If; 
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || V_Error || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人医嘱执行_Update;
/

--99572:冉俊明,2016-09-30,异常单据并发处理。
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_记录状态 病人预交记录.记录状态%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数 

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  v_Msg      Varchar2(5000);
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10), n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数 
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
               Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                1
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3, n_会话号
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 In (1, 3)) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 In (1, 3) And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id   := 冲销id_In;
    n_记录状态 := 2;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id   := n_重结id;
      n_记录状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, n_记录状态, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
         Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null, n_会话号);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, Null, Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, 卡号,
                   交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(b.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
                   Null, 卡号, 交易流水号, 交易说明, Null, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      For c_冲预交 In (Select *
                    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
                           From 病人预交记录 A,
                                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                                  From 病人预交记录 A
                                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = 病人id_In And 预交类别 = 1
                                  Group By NO
                                  Having Sum(Nvl(a.金额, 0)) <> 0) B
                           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = 病人id_In And a.预交类别 = 1
                           Union All
                           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                           From 病人预交记录
                           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = 病人id_In And
                                 预交类别 = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                           Group By 记录状态, NO)
                    Order By ID, NO) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.Id <> 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3, 会话号 = n_会话号
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质, 会话号)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3, n_会话号);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3, n_会话号);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = n_重结id;
  End If;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--101136:冉俊明,2016-09-30,门诊异常单据收费，出现同一个单据不同的操作员。
Create Or Replace Procedure Zl_门诊异常收费_更新操作员
(
  病人id_In     门诊费用记录.病人id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  结算序号_In   病人预交记录.结算序号%Type
) As
  n_组id 病人预交记录.缴款组id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  For v_预交 In (Select Distinct 结帐id
               From 病人预交记录
               Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结算序号 = 结算序号_In) Loop
    Update 门诊费用记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
    Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结帐id = v_预交.结帐id;
  
    Update 病人预交记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
    Where 结帐id = v_预交.结帐id And Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0);
  
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊异常收费_更新操作员;
/

--100895:廖思奇,2016-09-29,增加修改时 程序集字段的修改
Create Or Replace Procedure Zl_影像插件挂接_Update
(
  Id_In       In 影像插件挂接.Id%Type,
  名称_In     In 影像插件挂接.名称%Type,
  版本_In     In 影像插件挂接.版本%Type,
  路径_In     In 影像插件挂接.路径%Type,
  程序集_In   In 影像插件挂接.程序集%Type,
  执行类型_In In 影像插件挂接.执行类型%Type,
  是否启用_In In 影像插件挂接.是否启用%Type,
  所属模块_In In 影像插件挂接.所属模块%Type
) Is

Begin
  Update 影像插件挂接
  Set 名称 = 名称_In, 版本 = 版本_In, 路径 = 路径_In, 程序集 = 程序集_In, 执行类型 = 执行类型_In, 是否启用 = 是否启用_In, 所属模块 = 所属模块_In
  Where ID = Id_In;

  If Sql%RowCount = 0 Then
    Insert Into 影像插件挂接
      (ID, 名称, 版本, 路径, 程序集, 执行类型, 是否启用, 所属模块)
    Values
      (Id_In, 名称_In, 版本_In, 路径_In, 程序集_In, 执行类型_In, 是否启用_In, 所属模块_In);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像插件挂接_Update;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
--100837:刘尔旋,2016-12-07,挂号附加费处理
Create Or Replace Procedure Zl_病人挂号记录_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费 3-退附加费 4-退挂号与病历 5-退挂号与附加
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.序号 = 1 And a.记录状态 = v_状态 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = 单据号_In And
          Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney(n_Id 病人预交记录.结帐id%Type) Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 病人预交记录 B
    Where b.结帐id = n_Id And b.记录性质 = 4 And b.记录状态 = 2 And Nvl(b.冲预交, 0) <> 0;

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
  v_Temp           Varchar2(500);
  v_附加ids        Varchar2(500);
  n_就诊病人id     病人信息.病人id%Type;
  d_就诊时间       就诊登记记录.就诊时间%Type;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  Begin
    Select Zl_Fun_Regcustomname Into v_Temp From Dual;
    If v_Temp Is Not Null Then
      v_附加ids := Substr(v_Temp, Instr(v_Temp, '|') + 1);
    End If;
  Exception
    When Others Then
      v_附加ids := Null;
  End;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  
    --更新挂号序号状态
    Delete 挂号序号状态
    Where 状态 = 2 And
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, Trunc(发生时间)
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In) Or
          (号码, 序号, 日期) = (Select 计算单位, 发药窗口, 发生时间
                          From 门诊费用记录
                          Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And Rownum = 1 And NO = 单据号_In);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  
    --Update 病人挂号记录 set 摘要=nvl(摘要_IN,摘要) where NO=单据号_IN;
    --删除门诊费用记录
    Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Delete 挂号序号状态
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    Else
      Update 挂号序号状态
      Set 状态 = 4
      Where 状态 = 1 And
            (号码, 序号, 日期) = (Select 号别, 号序, Trunc(发生时间) From 病人挂号记录 Where NO = 单据号_In And Rownum = 1) Or
            (号码, 序号, 日期) = (Select 号别, 号序, 发生时间 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1);
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) Not In (2, 3) Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  If Nvl(退费类型_In, 0) = 0 Or Nvl(退费类型_In, 0) = 2 Then
    --全退,退病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 1 Or Nvl(退费类型_In, 0) = 4 Then
    --退挂号费,退挂号与病历费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') = 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 3 Then
    --退附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Instr(',' || v_附加ids || ',', ',' || 收费细目id || ',') > 0 And
            Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
    End If;
  Elsif Nvl(退费类型_In, 0) = 5 Then
    --退挂号与附加费
    --门诊费用记录，冲销记录
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
       数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
       结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
             收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
             操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
             Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
             Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
  
    --原始记录
    If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
      Update 门诊费用记录
      Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    Else
      Update 门诊费用记录
      Set 记录状态 = 3
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And Nvl(附加标志, 0) <> 1;
    End If;
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum < 2;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 非原样退结算_In Is Not Null Then
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select -1 * Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id;
        
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
        Begin
          Select 冲预交
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
      
        --a.允许的结算方式
      
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        If n_退费金额 = 0 Then
          --b.不允许的退现金
          If n_退款金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
              Exception
                When Others Then
                  v_退指定结算方式 := '现金';
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退款金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --a.允许的结算方式原样退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
      
        --b.不允许的退现金
        Begin
          Select Sum(冲预交)
          Into n_退费金额
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
        Exception
          When Others Then
            n_退费金额 := 0;
        End;
        If n_退费金额 <> 0 Then
          If v_退指定结算方式 Is Null Then
            --退给现金
            Begin
              Select 结算方式
              Into v_退指定结算方式
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
            
            Exception
              When Others Then
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
            End;
          End If;
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * n_退费金额)
          Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                     操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录 A
              Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
          End If;
        End If;
      End If;
    Else
      --退款金额获取
      If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
        --如果是单独退病历费,或者只退挂号费,先获取退费金额
        Begin
          --获取本次退款金额
          Select -1 * Sum(Nvl(实收金额, 0)) As 收款金额
          Into n_退款金额
          From 门诊费用记录
          Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id;
        Exception
          When Others Then
            v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                           When 1 Then
                            '挂号费用'
                           When 2 Then
                            '病历费'
                         End || '可能由于并发原因已经进行了退费或者单据不存在!';
            Raise Err_Item;
        End;
      End If;
      If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
        --首次全退
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交,
                 n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
      Else
        --二次退费,或者本次单退一部分
        --二次退费时,记录状态=3 ,首次部分退,记录状态为1
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
           结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                 -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And 冲预交 = n_退款金额 And
                Rownum < 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And Rownum < 2;
        End If;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
          If Sql%RowCount = 0 Then
            --部分退费,并且全部使用预交款缴费时才存在此种情况
            n_预交金额 := n_退款金额;
          End If;
        End If;
      
      End If;
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If Nvl(退费类型_In, 0) Not In (2, 3) Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    Open c_Registinfo(3);
    Fetch c_Registinfo
      Into r_Registrow;
  
    If c_Registinfo%RowCount = 0 Then
      --只收病历费时无号别,不处理
      Close c_Registinfo;
    Else
    
      --需要确定是否预约挂号
      --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
      --2.如果是正常挂号,则只减已挂数
    
      Begin
        Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
      Exception
        When Others Then
          n_预约挂号 := 0;
      End;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号, -1 * n_预约挂号);
      End If;
    
      Close c_Registinfo;
    End If;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney(n_销帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) Not In (2, 3) Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Begin
      Select 病人id, 发生时间 Into n_就诊病人id, d_就诊时间 From 病人挂号记录 Where NO = 单据号_In;
      Delete From 就诊登记记录 Where 病人id = n_就诊病人id And 就诊时间 = d_就诊时间 And 主页id Is Null;
    Exception
      When Others Then
        Null;
    End;
  
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Delete;
/

Create Or Replace Procedure Zl_Third_Getregfeedetail
(
  Xml_In  In Xmltype,
  Xml_Out In Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取挂号费用明细
  --入参:Xml_In:
  --<IN>
  --  <BRID></BRID> //病人ID
  --  <SFYY></SFYY> //是否仅预约不支付,1-仅预约不支付,0-挂号,预约支付,预约接收，默认为0
  --  <GHDH></GHDH> //挂号单号,预约接收时传入
  --  <GHHM></GHHM> //挂号安排号码,挂号和预约时传入
  --  <XMID></XMID> //挂号安排的项目ID,挂号和预约时传入
  --  <FB></FB>     //病人费别
  --  <ZD></ZD>     //站点
  --</IN>
  --出参:Xml_Out
  -- <OUTPUT>
  --  <ZJE></ZJE>   //总实收金额
  --  <XMMX>        //项目明细
  --    <XM>
  --      <DJH></DJH>       //单据号
  --      <MC></MC>   //项目名称
  --      <ID></ID>   //项目ID
  --      <SL></SL>   //数量，数次*付数
  --      <YSJE></YSJE>   //应收金额
  --      <SSJE></SSJE>   //实收金额
  --      <SJFM></SJFM>       //收据费目
  --    </XM>
  --    <XM>
  --    ...
  --    </XM>
  --  </XMMX>
  -- </OUTPUT>

  --------------------------------------------------------------------------------------------------
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  v_Temp       Varchar2(4000);
  n_项目id     挂号安排.项目id%Type;
  v_No         门诊费用记录.No%Type;
  n_预约       Number(3);
  n_病人id     病人信息.病人id%Type;
  v_费别       病人信息.费别%Type;
  v_站点       部门表.站点%Type;
  v_号码       挂号安排.号码%Type;
  n_总金额     门诊费用记录.实收金额%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_实收       Varchar(500);
  v_附加项目id Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/XMID'), Extractvalue(Value(A), 'IN/GHHM'),
         Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/ZD'), Extractvalue(Value(A), 'IN/SFYY'),
         Extractvalue(Value(A), 'IN/GHDH')
  Into n_病人id, n_项目id, v_号码, v_费别, v_站点, n_预约, v_No
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_总金额 := 0;
  If v_No Is Null Then
    --挂号或者预约
    For c_挂号项目 In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = n_项目id And
                         Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
      v_实收     := Zl_Actualmoney(v_费别, c_挂号项目.项目id, c_挂号项目.收入项目id, c_挂号项目.数次 * c_挂号项目.单价);
      n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
      v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id || '</ID>' ||
                    '<SL>' || c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.数次 * c_挂号项目.单价 || '</YSJE>' || '<SSJE>' ||
                    n_实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  Else
    --预约接收
    For c_挂号项目 In (Select a.收费细目id As 项目id, a.应收金额, a.实收金额, a.计算单位, a.收据费目, b.名称 As 项目名称, a.No, Nvl(a.付数, 1) As 付数, a.数次
                   From 门诊费用记录 A, 收费项目目录 B
                   Where a.收费细目id = b.Id And a.No = v_No And a.记录性质 = 4 And a.记录状态 = 0) Loop
      n_总金额 := n_总金额 + Nvl(c_挂号项目.实收金额, 0);
      v_号码   := c_挂号项目.计算单位;
      v_Temp   := v_Temp || '<XM><DJH>' || c_挂号项目.No || '</DJH><MC>' || c_挂号项目.项目名称 || '</MC>' || '<ID>' || c_挂号项目.项目id ||
                  '</ID>' || '<SL>' || c_挂号项目.付数 * c_挂号项目.数次 || '</SL>' || '<YSJE>' || c_挂号项目.应收金额 || '</YSJE>' ||
                  '<SSJE>' || c_挂号项目.实收金额 || '</SSJE>' || '<SJFM>' || c_挂号项目.收据费目 || '</SJFM></XM>';
    End Loop;
  End If;

  If Nvl(n_预约, 0) = 0 Then
    Begin
      Select Zl_Fun_Customregexpenses(n_病人id, 0, v_号码) Into v_附加项目id From Dual;
    Exception
      When Others Then
        v_附加项目id := Null;
    End;
    If v_附加项目id Is Not Null Then
      For c_附加项目 In (Select /*+cardinality(D,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, Table(f_Str2list(v_附加项目id)) D
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.Column_Value And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                     Union All
                     Select /*+cardinality(E,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D, Table(f_Str2list(v_附加项目id)) E
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = e.Column_Value And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
        v_实收     := Zl_Actualmoney(v_费别, c_附加项目.项目id, c_附加项目.收入项目id, c_附加项目.数次 * c_附加项目.单价);
        n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
        n_总金额   := n_总金额 + Nvl(n_实收金额, 0);
        v_Temp     := v_Temp || '<XM><DJH></DJH><MC>' || c_附加项目.项目名称 || '</MC>' || '<ID>' || c_附加项目.项目id || '</ID>' ||
                      '<SL>' || c_附加项目.数次 || '</SL>' || '<YSJE>' || c_附加项目.数次 * c_附加项目.单价 || '</YSJE>' || '<SSJE>' ||
                      n_实收金额 || '</SSJE>' || '<SJFM>' || c_附加项目.收据费目 || '</SJFM></XM>';
      End Loop;
    End If;
  End If;

  v_Temp := '<XMMX>' || v_Temp || '</XMMX>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  v_Temp := '<ZJE>' || n_总金额 || '</ZJE>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregfeedetail;
/

--100837:刘尔旋,2016-09-29,挂号附加费处理
Create Or Replace Function Zl_Fun_Customregexpenses
(
  病人id_In In 病人信息.病人id%Type,
  险类_In   In 病人信息.险类%Type,
  号码_In   In 挂号安排.号码%Type
) Return Varchar2
  --    功能：挂号附加费处理项目用户自定义函数
  --    参数：
  --        病人ID_In：病人信息.病人ID
  --        险类_In：病人信息.险类
  --        号码_In: 挂号安排.号码
  --    返回: 收费细目ID,多个用逗号分隔,返回NULL时，不处理
 Is
Begin
  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Customregexpenses;
/

--100837:刘尔旋,2016-09-29,挂号附加费处理
Create Or Replace Function Zl_Fun_Regcustomname Return Varchar2
  --    功能：挂号附加费名称用户自定义函数
  --    返回: 格式:功能名称|收费细目ID1,收费细目ID2...返回NULL不加载菜单
 Is
Begin
  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Regcustomname;
/

--100272:刘尔旋,2016-09-26,预交分类别轧帐
Create Or Replace Function Zl_Rollingcurtain_Lastdate
(
  收款员_In 人员收缴记录.收款员%Type,
  类别_In   人员收缴记录.类别%Type
) Return Date Is
  d_规零时间 Date;
  d_终止时间 Date;

Begin
  --------------------------------------------------------------------------------
  --功能:获取指定用户的最后一次有效的轧帐时间
  --入参:类别_In:0-所有类别(按全额轧帐),1-收费,2-预交,3-结帐,4-挂号,5-就诊卡
  --     收款员_IN:具体的收费人员
  --获取规则:
  --    1.如果当前按指定类别轧帐时,则按下规则处理(以终止时间为准):
  --      1) 如果存在有效的轧帐记录时
  --          a)如果当前轧帐人员不存在所有类别的轧帐记录的,则以最后一次轧帐时间为准
  --          b)如果当前轧帐人员存在所有类别的轧帐记录且最后一次轧帐记录的终止时间>当前类别的最后一次轧帐记录的终卡时间的,则以所有类别的最后一次轧帐记录的终止时间为准
  --          c)如果当前轧帐人员存在所有类别的轧帐记录且最后一次轧帐记录的终止时间<当前类别的最后一次轧帐记录的终卡时间的,则以当前类别的最后一次轧帐记录的终卡时间为准
  --      2)如果不存在有效轧帐记录时
  --          a)如果当前轧帐人员存在按所有类别轧帐的有效记录时,则以最后一次轧帐记录的终止时间为准
  --          b)如果不存在按所有类别轧帐的有效记录时,按下面的3以下规则处理
  --    2.如果当前按所有类别轧帐时,则按以下规则处理
  --          a)如果存在按所有类别轧帐的有效记录时,则以最后一次轧帐记录的终止时间为准
  --          b)如果不存在按所有类别轧帐的有效记录时,按下面的3以下规则处理
  --    3.如果存在轧帐规零记录,则以轧帐规零记录的登记时间为准
  --    4.未轧过的,缺省为领取备用金时间
  --    5.如果未领用备用金的,返回NULL,由界面处理(缺省时间为当前时间-1个月的且允许更改上次转帐时间)
  --------------------------------------------------------------------------------
  If 类别_In = 22 Or 类别_In = 21 Then
    Select Max(Decode(记录性质, 6, 登记时间, Null)), Max(Decode(记录性质, 1, 终止时间, Null))
    Into d_规零时间, d_终止时间
    From 人员收缴记录 A
    Where 收款员 = 收款员_In And 作废时间 Is Null And
          (记录性质 = 6 Or ((a.记录性质 = 1 And Nvl(类别, 0) = 2) Or (a.记录性质 = 1 And Nvl(类别, 0) = 0) Or
          (a.记录性质 = 1 And Nvl(类别, 0) = Nvl(类别_In, 0))));
  Else
    Select Max(Decode(记录性质, 6, 登记时间, Null)), Max(Decode(记录性质, 1, 终止时间, Null))
    Into d_规零时间, d_终止时间
    From 人员收缴记录 A
    Where 收款员 = 收款员_In And 作废时间 Is Null And
          (记录性质 = 6 Or ((a.记录性质 = 1 And Nvl(类别, 0) = 0) Or (a.记录性质 = 1 And Nvl(类别, 0) = Nvl(类别_In, 0))));
  End If;

  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;
  If d_规零时间 Is Not Null Then
    Return d_规零时间;
  End If;

  --取备用金的时间
  Select Min(领用时间)
  Into d_终止时间
  From 人员暂存记录
  Where 收款员 = 收款员_In And (记录性质 = 1 Or 记录性质 = 11) And 收回时间 Is Null;
  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;

  --当前时间减少1个月
  If d_终止时间 Is Not Null Then
    Return d_终止时间;
  End If;

  Return Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Rollingcurtain_Lastdate;
/

--99758:梁唐彬,2016-10-09,费用部分退费
CREATE OR REPLACE Procedure Zl_医嘱执行计价_修正
(
  医嘱id_In   病人医嘱执行.医嘱id%Type,
  No_In       病人医嘱发送.No%Type,
  记录性质_In 病人医嘱发送.记录性质%Type
) Is
  n_发送数次 Number;
  n_登记数次 Number;
  n_单次数次 Number;
  d_要求时间 Date;
  d_发送号   病人医嘱发送.发送号%Type;
  v_Count    Number;
Begin
  Select Count(1) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 执行状态 Is Null;
  If v_Count > 0 Then
    Select a.发送号, a.发送数次
    Into d_发送号, n_发送数次
    From 病人医嘱发送 A
    Where a.医嘱id = 医嘱id_In And a.No = No_In And a.记录性质 = 记录性质_In;
  
    Select Nvl(Sum(b.本次数次), 0)
    Into n_登记数次
    From 病人医嘱执行 B
    Where b.医嘱id = 医嘱id_In And b.发送号 = d_发送号 And Nvl(b.执行结果, 1) <> 0 ;
  
    If n_发送数次 > 0 Then
      If n_登记数次 > 0 Then
        Select Count(Distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 发送号 = d_发送号;
        If v_Count > 0 Then
          n_单次数次 := n_发送数次 / v_Count;
          --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
          v_Count := Ceil(n_登记数次 / n_单次数次);
          --获取执行截至要求时间 
          Select 要求时间
          Into d_要求时间
          From (Select 要求时间, Rownum As 次数
                 From (Select Distinct 要求时间
                        From 医嘱执行计价
                        Where 医嘱id = 医嘱id_In And 发送号 = d_发送号
                        Order By 要求时间))
          Where 次数 = v_Count;
        
          If Not d_要求时间 Is Null Then
            --更新截至要求时间之前(含)的记录执行状态；
            Update 医嘱执行计价
            Set 执行状态 = 1
            Where 医嘱id = 医嘱id_In And 发送号 = d_发送号 And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
            Update 医嘱执行计价
            Set 执行状态 = 0
            Where 医嘱id = 医嘱id_In And 发送号 = d_发送号 And 要求时间 > d_要求时间 And NVL(执行状态,0) <> 2;
          End If;
        End If;
      Else
        Update 医嘱执行计价
          Set 执行状态 = 0
          Where 医嘱id = 医嘱id_In And 发送号 = d_发送号 And NVL(执行状态,0) <> 2;
      End IF;
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医嘱执行计价_修正;
/

--99758:梁唐彬,2016-10-09,费用部分退费问题
CREATE OR REPLACE Procedure Zl_病人医嘱执行_Insert
( 
  医嘱id_In       病人医嘱执行.医嘱id%Type, 
  发送号_In       病人医嘱执行.发送号%Type, 
  要求时间_In     病人医嘱执行.要求时间%Type, 
  本次数次_In     病人医嘱执行.本次数次%Type, 
  执行摘要_In     病人医嘱执行.执行摘要%Type, 
  执行人_In       病人医嘱执行.执行人%Type, 
  执行时间_In     病人医嘱执行.执行时间%Type, 
  单独执行_In     Number := 0, 
  自动完成_In     Number := 0, 
  执行结果_In     病人医嘱执行.执行结果%Type := 1, 
  未执行原因_In   病人医嘱执行.说明%Type := Null, 
  操作员编号_In   人员表.编号%Type := Null, 
  操作员姓名_In   人员表.姓名%Type := Null, 
  执行部门id_In   门诊费用记录.执行部门id%Type := 0, 
  配液检查_In     Number := 0, 
  检验项目记帐_In Number := 0, 
  输液通道_In     病人医嘱执行.输液通道%Type := Null 
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。 
  --      执行结果_In=1- 完成   =0  -未执行 
  --      如果是台式机调用 操作员编号_In 操作员姓名_In 这两个参数必须传入 
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门 
  --配液检查_In=移动工作站调用时，是否检查配液信息。 
  --检验项目记帐_In=如果是检验项目时，需要记帐但不完成医嘱发送状态 
) Is 
  --除了要执行的主记录,还包含了附加手术,检查部位的记录 
  --手术麻醉,中药煎法,采集方法单独控制,检验组合只填写在第一个项目上，但执行状态相同 
  v_组id     病人医嘱记录.Id%Type; 
  v_诊疗类别 病人医嘱记录.诊疗类别%Type; 
  v_自动完成 Number; 
  v_病人来源 病人医嘱记录.病人来源%Type; 
  v_费用性质 病人医嘱发送.记录性质%Type; 
  v_操作类型 诊疗项目目录.操作类型%Type; 
  v_病区id   病案主页.当前病区id%Type; 
  v_配液病区 Varchar2(200); 
  v_Count    Number; 
  v_Temp     Varchar2(255); 
  v_人员编号 人员表.编号%Type; 
  v_人员姓名 人员表.姓名%Type; 
  n_期效     病人医嘱记录.医嘱期效%Type; 
 
  n_执行次数 Number; 
  n_剩余次数 Number; 
  n_执行状态 Number; 
  d_终止时间 Date; 
  d_开始时间 Date; 
  n_发送数次 Number;
  n_登记数次 Number;
  n_单次数次 Number;
  d_要求时间 Date;
 
  v_Date  Date; 
  v_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  --并发查检，防止产生多条执行记录 
  Begin 
    Select (a.发送数次 - c.登记次数) As 剩余数次 ,a.发送数次
    Into v_Count ,n_发送数次
    From 病人医嘱发送 A, 
         (Select 医嘱id_In As 医嘱id, 发送号_In As 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
           From 病人医嘱执行 B 
           Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In) C 
    Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
  Exception 
    When Others Then 
      v_Count := 本次数次_In; 
  End; 
  If 本次数次_In > v_Count Then 
    v_Error := '由于并发操作可能已经被他人登记，请刷新后再试。'; 
    Raise Err_Custom; 
  End If; 
  --当前操作人员 
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then 
    v_人员编号 := 操作员编号_In; 
    v_人员姓名 := 操作员姓名_In; 
  Else 
    Begin 
      Select 姓名, 编号 Into v_人员姓名, v_人员编号 From 人员表 Where 姓名 = 执行人_In; 
    Exception 
      When Others Then 
        v_Temp     := Zl_Identity; 
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1); 
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
    End; 
  End If; 
  --对医嘱终止时间进行检查 
  Select a.执行终止时间, a.开始执行时间, a.医嘱期效 
  Into d_终止时间, d_开始时间, n_期效 
  From 病人医嘱记录 A 
  Where a.Id = 医嘱id_In; 
  If Not d_终止时间 Is Null And n_期效 = 0 Then 
    If 要求时间_In > d_终止时间 Then 
      v_Error := '要求时间超过了医嘱终止时间，请确认医嘱是否提前停止！'; 
      Raise Err_Custom; 
    End If; 
  End If; 
  If Not d_开始时间 Is Null Then 
    If 执行时间_In < d_开始时间 Then 
      v_Error := '执行时间必须大于医嘱的开始执行时间''' || To_Char(d_开始时间, 'yyyy-mm-dd HH24:mi:ss') || '''！'; 
      Raise Err_Custom; 
    End If; 
  End If; 
  Select Sysdate Into v_Date From Dual; 
  Select a.病人来源, 执行科室id, Nvl(a.相关id, a.Id), a.诊疗类别, Nvl(b.操作类型, '0') 操作类型 
  Into v_病人来源, v_病区id, v_组id, v_诊疗类别, v_操作类型 
  From 病人医嘱记录 A, 诊疗项目目录 B 
  Where a.Id = 医嘱id_In And a.诊疗项目id = b.Id; 
 
  If v_病人来源 = 2 Then 
    Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2)) 
    Into v_费用性质 
    From 病人医嘱发送 
    Where 发送号 = 发送号_In And 医嘱id = 医嘱id_In; 
  Else 
    v_费用性质 := 1; 
  End If; 
 
  --移动系统配液检查 
  If 配液检查_In = 1 Then 
    --检查当前病人所属病区是否进行配液登记管理 
    Select Nvl(Zl_Getsysparameter(184), '') Into v_配液病区 From Dual; 
 
    If v_配液病区 Is Not Null And 执行结果_In <> 0 Then 
      If Instr(',' || v_配液病区 || ',', ',' || v_病区id || ',') > 0 Then 
        v_病区id   := 0; 
        v_配液病区 := 'Select 1 From 病区配液记录 where 医嘱ID=:YZID AND 发送号=:FSH AND 要求时间=:YQSJ'; 
        Begin 
          Execute Immediate v_配液病区 
            Into v_病区id 
            Using 医嘱id_In, 发送号_In, 要求时间_In; 
        Exception 
          When Others Then 
            Null; 
        End; 
        If v_病区id = 0 Then 
          v_Error := '当前医嘱还未进行配液，不允许进行执行登记！'; 
          Raise Err_Custom; 
        End If; 
      End If; 
    End If; 
    --检查当前医嘱是否已配液 
  End If; 
 
  --病人医嘱执行 
  Select Count(1) 
  Into v_Count 
  From 病人医嘱执行 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In And 执行时间 = 执行时间_In; 
  If v_Count > 0 Then 
    v_Error := '您指定的执行时间，已经执行过本条医嘱，请更改一个执行时间。'; 
    Raise Err_Custom; 
  End If; 
  Insert Into 病人医嘱执行 
    (医嘱id, 发送号, 要求时间, 本次数次, 执行摘要, 执行人, 执行时间, 登记时间, 登记人, 执行结果, 说明, 输液通道) 
  Values 
    (医嘱id_In, 发送号_In, 要求时间_In, 本次数次_In, 执行摘要_In, 执行人_In, 执行时间_In, v_Date, v_人员姓名, 执行结果_In, 未执行原因_In, 输液通道_In); 
 
  --费用记录的执行状态进行更新 
  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数) ,c.登记次数
  Into n_执行次数, n_剩余次数 ,n_登记数次
  From 病人医嘱发送 A, 
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数 
         From 病人医嘱执行 B 
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C 
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In; 
  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2 
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual; 
 
  --填写了执行状态后就标记为正在执行 
  If Nvl(单独执行_In, 0) = 1 Then 
    Update 病人医嘱发送 
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3) 
    Where 执行状态 In (0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In; 
  Else 
    Update 病人医嘱发送 
    Set 执行状态 = Decode(n_执行次数, 0, 0, 3) 
    Where 执行状态 In (0, 3) And 发送号 + 0 = 发送号_In And 
          医嘱id In (Select ID 
                   From 病人医嘱记录 
                   Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                   Union All 
                   Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别); 
  End If; 
 
  --更新对应的费用执行状态为已执行(无正在执行) 
  --不应该处理药品和跟踪在用的卫材 
  If 执行结果_In = 1 Then 
    If v_费用性质 = 2 Then 
      If Nvl(单独执行_In, 0) = 1 Then 
        Update 住院费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 住院费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In (Select ID 
                              From 病人医嘱记录 
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                              Union All 
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别)); 
      End If; 
    Else 
      If Nvl(单独执行_In, 0) = 1 Then 
        --对于门诊单据n_执行状态可能为0（登记执行情况，选择执行结果为未执行），因此需判断 
        Update 门诊费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In); 
      Else 
        Update 门诊费用记录 A 
        Set 执行状态 = n_执行状态, 执行人 = Decode(n_执行状态, 0, Null, 执行人_In), 执行时间 = Decode(n_执行状态, 0, Null, 执行时间_In) 
        Where 收费类别 Not In ('5', '6', '7') And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In) And Not Exists 
         (Select 1 From 材料特性 Where 材料id = a.收费细目id And 跟踪在用 = 1) And a.记录状态 In (0, 1, 3) And 
              (医嘱序号, NO, 记录性质) In 
              (Select 医嘱id, NO, 记录性质 
               From 病人医嘱发送 
               Where 执行状态 = Decode(n_执行次数, 0, 0, 3) And 发送号 + 0 = 发送号_In And 
                     医嘱id In (Select ID 
                              From 病人医嘱记录 
                              Where ID = v_组id And 诊疗类别 = v_诊疗类别 
                              Union All 
                              Select ID From 病人医嘱记录 Where 相关id = v_组id And 诊疗类别 = v_诊疗类别)); 
      End If; 
    End If; 
    --检验自动完成采集 
    If v_诊疗类别 = 'E' And v_操作类型 = '6' Then 
      Update 病人医嘱发送 A 
      Set a.采样人 = 执行人_In, a.采样时间 = 执行时间_In 
      Where 医嘱id In (Select ID 
                     From 病人医嘱记录 
                     Where ID = v_组id 
                     Union All 
                     Select ID From 病人医嘱记录 Where 相关id = v_组id) And 发送号 = 发送号_In; 
    End If; 
 
    --执行数次达到之后自动完成执行(主要用于PDA自动执行)，如果启用了移动临床，则护士站和PDA一致。 
    v_自动完成 := 自动完成_In; 
    If Nvl(v_自动完成, 0) = 0 And v_病人来源 = 2 And Instr('C,D', v_诊疗类别) = 0 Then 
      Begin 
        Execute Immediate 'Select Count(1) From ZLMBSYSTEMS' 
          Into v_Count; 
      Exception 
        When Others Then 
          Null; 
      End; 
      If v_Count > 0 Then 
        v_自动完成 := 1; 
      End If; 
    End If; 
 
    If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then 
      Begin 
        Select Decode(Sign(Nvl(Sum(b.本次数次), 0) - a.发送数次), 1, 1, 0, 1, 0) 
        Into v_自动完成 
        From 病人医嘱发送 A, 病人医嘱执行 B 
        Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And a.执行状态 In (0, 3) And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In 
        Group By a.发送数次; 
      Exception 
        When Others Then 
          Null; 
      End; 
 
      If Nvl(v_自动完成, 0) = 1 Or 检验项目记帐_In = 1 Then 
        Zl_病人医嘱执行_Finish(医嘱id_In, 发送号_In, Null, 单独执行_In, v_人员编号, v_人员姓名, 执行部门id_In, 检验项目记帐_In); 
      End If; 
    End If; 
    --更新医嘱执行计价.执行状态
    If n_发送数次 > 0 Then
      Select Count(distinct 要求时间) Into v_Count From 医嘱执行计价 Where 医嘱ID = 医嘱ID_IN And 发送号 = 发送号_IN;
      If v_Count > 0 Then
        n_单次数次 := n_发送数次 / v_Count;
        --已执行数量+本次数次 总共能够执行多少个时间点,取最大整数
        v_Count := ceil((n_登记数次) / n_单次数次);
        --获取执行截至要求时间 
        Select 要求时间 Into d_要求时间
        From (Select 要求时间, Rownum As 次数
               From (Select Distinct 要求时间 From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN Order By 要求时间))
        Where 次数 = v_Count;
        
        If Not d_要求时间 Is Null Then
          --先检查是否已经退费
          Select Max(NVL(执行状态,0)) Into v_Count From 医嘱执行计价 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间;
          If v_Count = 2 Then
            v_Error := '您指定的执行时间段的医嘱费用已经被退费，不允许再执行。'; 
            Raise Err_Custom; 
          End If;
          --更新截至要求时间之前(含)的记录执行状态；
          Update 医嘱执行计价 Set 执行状态 = 1 Where 医嘱id = 医嘱ID_IN And 发送号 = 发送号_IN And 要求时间 <= d_要求时间 And NVL(执行状态,0) <> 2;
        End If;
      End If;
    End If;
  End If; 
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_病人医嘱执行_Insert;
/

--99758:梁唐彬,2016-09-22,门诊部分退费增加执行状态判断
Create Or Replace Procedure Zl_医嘱执行计价_Insert
(
  医嘱id_In     医嘱执行计价.医嘱id%Type,
  发送号_In     医嘱执行计价.发送号%Type,
  要求时间_In   医嘱执行计价.要求时间%Type,
  收费细目id_In 医嘱执行计价.收费细目id%Type,
  数量_In       医嘱执行计价.数量%Type,
  费用性质_In   医嘱执行计价.费用性质%Type := 0
) Is
Begin
  Insert Into 医嘱执行计价
    (医嘱id, 发送号, 要求时间, 收费细目id, 数量,费用性质,执行状态)
  Values
    (医嘱id_In, 发送号_In, 要求时间_In, 收费细目id_In, 数量_In,费用性质_In,0);
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_医嘱执行计价_Insert;
/

--96692:廖思奇,2016-09-21,新增及删除病理号码规则
Create Or Replace Procedure Zl_病理号码规则_Insert
(
  Id_In       病理号码规则.Id%Type,
  号码类型_In 病理号码规则.类型%Type,
  号码前缀_In 病理号码规则.前缀%Type,
  使用年_In   病理号码规则.年%Type,
  使用月_In   病理号码规则.月%Type,
  使用日_In   病理号码规则.日%Type,
  序号位数_In 病理号码规则.序号位数%Type,
  年份位数_In 病理号码规则.年份位数%Type,
  起始数_In   病理号码规则.起始数%Type,
  名称_In     病理号码规则.名称%Type
) Is
  v_Count Number(5);
  v_Year  Varchar2(4);
  v_Month Varchar2(2);
  v_Day   Varchar2(2);
Begin
  Begin
    Select Count(1) Into v_Count From 病理号码规则 Where ID = Id_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  --更新号码规则
  If v_Count <= 0 Then
    Insert Into 病理号码规则
      (ID, 类型, 前缀, 年, 月, 日, 年份位数, 序号位数, 起始数, 名称)
    Values
      (Id_In, 号码类型_In, 号码前缀_In, 使用年_In, 使用月_In, 使用日_In, 年份位数_In, 序号位数_In, 起始数_In, 名称_In);
  Else
    Update 病理号码规则
    Set 前缀 = 号码前缀_In, 年 = 使用年_In, 月 = 使用月_In, 日 = 使用日_In, 年份位数 = 年份位数_In, 序号位数 = 序号位数_In, 起始数 = 起始数_In, 名称 = 名称_In
    Where ID = Id_In;
  End If;

  --更新号码记录
  v_Year  := 0;
  v_Month := 0;
  v_Day   := 0;

  If 使用年_In = 1 Then
    Select To_Char(Sysdate, 'yyyy') Into v_Year From Dual;
  End If;

  If 使用月_In = 1 Then
    Select To_Char(Sysdate, 'mm') Into v_Month From Dual;
  End If;

  If 使用日_In = 1 Then
    Select To_Char(Sysdate, 'dd') Into v_Day From Dual;
  End If;

  Delete 病理号码记录 Where 号码规则id = Id_In;

  Insert Into 病理号码记录
    (ID, 类型, 年, 月, 日, 当前序号, 号码规则id)
  Values
    (病理号码记录_Id.Nextval, 号码类型_In, v_Year, v_Month, v_Day, 起始数_In - 1, Id_In);

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码规则_Insert;
/

--96692:廖思奇,2016-09-21,删除病理号码规则
Create Or Replace Procedure Zl_病理号码规则_Delete(Id_In 病理号码规则.Id%Type) Is

Begin
  
  Delete From 病理号码规则 Where ID = Id_In;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码规则_Delete;
/

--96692:廖思奇,2016-09-21,将原参数号码类型改为ID
Create Or Replace Function Zl_病理号码_序号获取(Id_In 病理号码规则.Id%Type) Return Number Is

  Cursor c_Patholnumrule(v_Id 病理号码规则.Id%Type) Is
    Select 年, 月, 日 From 病理号码规则 Where ID = v_Id;
  r_Patholnumrule c_Patholnumrule%RowType;

  v_Curnum Number;

  v_Year  Number;
  v_Month Number;
  v_Day   Number;
  v_Error Varchar(255);
  Err_Custom Exception;
Begin

  Open c_Patholnumrule(Id_In);

  Fetch c_Patholnumrule
    Into r_Patholnumrule;

  If c_Patholnumrule%RowCount = 0 Then
    Close c_Patholnumrule;
    v_Error := '不能读取病理号码生成规则，过程终止。';
    Raise Err_Custom;
  End If;

  v_Year  := 0;
  v_Month := 0;
  v_Day   := 0;

  If r_Patholnumrule.年 = 1 Then
    Select To_Char(Sysdate, 'yyyy') Into v_Year From Dual;
  End If;

  If r_Patholnumrule.月 = 1 Then
    Select To_Char(Sysdate, 'mm') Into v_Month From Dual;
  End If;

  If r_Patholnumrule.日 = 1 Then
    Select To_Char(Sysdate, 'dd') Into v_Day From Dual;
  End If;

  Begin
    Select 当前序号
    Into v_Curnum
    From 病理号码记录
    Where 号码规则id = Id_In And 年 = v_Year And 月 = v_Month And 日 = v_Day;
  Exception
    When Others Then
      v_Curnum := 0;
  End;

  Close c_Patholnumrule;

  Return v_Curnum + 1;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码_序号获取;
/

--96692:廖思奇,2016-09-21,将原来输入参数号码类型改为ID
Create Or Replace Function Zl_病理号码_生成
(
  Id_In       病理号码规则.Id%Type,
  当前序号_In 病理号码记录.当前序号%Type
) Return Varchar2 Is
  Cursor c_Patholnumrule(v_Id 病理号码规则.Id%Type) Is
    Select 年, 月, 日, 类型, 年份位数, 序号位数, 前缀 From 病理号码规则 Where Id = v_Id;
  r_Patholnumrule c_Patholnumrule%Rowtype;

  v_Year   Varchar2(4);
  v_Month  Varchar2(2);
  v_Day    Varchar2(2);
  v_Curnum Varchar2(18);

  v_Error Varchar(255);
  Err_Custom Exception;
Begin

  Open c_Patholnumrule(Id_In);

  Fetch c_Patholnumrule
    Into r_Patholnumrule;

  If c_Patholnumrule%Rowcount = 0 Then
    Close c_Patholnumrule;
    v_Error := '不能读取病理号码生成规则，过程终止。';
    Raise Err_Custom;
  End If;

  v_Year  := '';
  v_Month := '';
  v_Day   := '';

  If r_Patholnumrule.年 = 1 Then
    If r_Patholnumrule.年份位数 = 4 Then
      Select To_Char(Sysdate, 'yyyy') Into v_Year From Dual;
    Else
      Select To_Char(Sysdate, 'yy') Into v_Year From Dual;
    End If;
  End If;

  If r_Patholnumrule.月 = 1 Then
    Select To_Char(Sysdate, 'mm') Into v_Month From Dual;
  End If;

  If r_Patholnumrule.日 = 1 Then
    Select To_Char(Sysdate, 'dd') Into v_Day From Dual;
  End If;

  v_Curnum := 当前序号_In;
  If Length(v_Curnum) < Nvl(r_Patholnumrule.序号位数, 0) Then
    v_Curnum := Lpad('0', r_Patholnumrule.序号位数 - Length(v_Curnum), 0) || v_Curnum;
  End If;

  Return Nvl(r_Patholnumrule.前缀, '') || v_Year || v_Month || v_Day || v_Curnum;

  Close c_Patholnumrule;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病理号码_生成;
/

--96692:廖思奇,2016-09-21,将参数号码类型改为ID
Create Or Replace Procedure Zl_病理号码_序号更新
(
  Id_In       病理号码规则.Id%Type,
  当前序号_In 病理号码记录.当前序号%Type
) Is
  Cursor c_Patholnumrule(v_Id 病理号码规则.Id%Type) Is
    Select 年, 月, 日 From 病理号码规则 Where ID = v_Id;
  r_Patholnumrule c_Patholnumrule%RowType;

  v_Year  Number;
  v_Month Number;
  v_Day   Number;

  v_Error Varchar(255);
  Err_Custom Exception;
Begin

  Open c_Patholnumrule(Id_In);

  Fetch c_Patholnumrule
    Into r_Patholnumrule;

  If c_Patholnumrule%RowCount = 0 Then
    Close c_Patholnumrule;
    v_Error := '不能读取病理号码生成规则，过程终止。';
    Raise Err_Custom;
  End If;

  v_Year  := 0;
  v_Month := 0;
  v_Day   := 0;

  If r_Patholnumrule.年 = 1 Then
    Select To_Char(Sysdate, 'yyyy') Into v_Year From Dual;
  End If;

  If r_Patholnumrule.月 = 1 Then
    Select To_Char(Sysdate, 'mm') Into v_Month From Dual;
  End If;

  If r_Patholnumrule.日 = 1 Then
    Select To_Char(Sysdate, 'dd') Into v_Day From Dual;
  End If;

  Delete 病理号码记录 Where 号码规则id = Id_In And 年 = v_Year And 月 = v_Month And 日 = v_Day;

  Insert Into 病理号码记录
    (ID, 号码规则id, 年, 月, 日, 当前序号)
  Values
    (病理号码记录_Id.Nextval, Id_In, v_Year, v_Month, v_Day, 当前序号_In);

  Close c_Patholnumrule;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理号码_序号更新;
/

--96692:廖思奇,2016-09-21,将原来输入参数有检查类型改为号码规则id
Create Or Replace Procedure Zl_病理报到_号码更新
(
  医嘱id_In 病理检查信息.医嘱id%Type,
  病理号_In 病理检查信息.病理号%Type,
  号码规则id_In 病理号码规则.Id%Type
) Is
  v_Recordcount Number(5) := 0;
  v_类型        病理号码规则.类型%Type;

Begin
  Select 类型 Into v_类型 From 病理号码规则 Where Id = 号码规则id_In;

  Begin
    Select Count(1) Into v_Recordcount From 病理检查信息 Where 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      v_Recordcount := 0;
  End;

  If v_Recordcount <= 0 Then
    --如果在病理检查信息中未找到数据，则新增病理检查信息，用于直接在登记窗口中进行报到 
    Insert Into 病理检查信息
      (病理医嘱id, 医嘱id, 病理号, 检查类型, 报到时间, 号码规则id)
    Values
      (病理检查信息_病理医嘱id.Nextval, 医嘱id_In, 病理号_In, v_类型, Sysdate, 号码规则id_In);
  Else
  
    --更新病理检查信息 
    Update 病理检查信息 Set 病理号 = 病理号_In, 检查类型 = v_类型, 号码规则id = 号码规则id_In Where 医嘱id = 医嘱id_In;
    --由于影像检查记录的检查号为数字型，因此不能存放病理号， 
    --update 影像检查记录 set 检查号=病理号_IN where 医嘱ID=医嘱ID_IN; 
  
    If v_类型 = 0 Or v_类型 = 3 Or v_类型 = 4 Or v_类型 = 5 Then
      --常规,会诊,尸检,快速石蜡 
      Update 病理制片信息
      Set 制片类型 = 0
      Where 病理医嘱id = (Select 病理医嘱id From 病理检查信息 Where 医嘱id = 医嘱id_In);
    Elsif v_类型 = 1 Then
      --冰冻 
      Update 病理制片信息
      Set 制片类型 = 1
      Where 病理医嘱id = (Select 病理医嘱id From 病理检查信息 Where 医嘱id = 医嘱id_In);
    Elsif v_类型 = 2 Then
      --细胞 
      Update 病理制片信息
      Set 制片类型 = 2
      Where 病理医嘱id = (Select 病理医嘱id From 病理检查信息 Where 医嘱id = 医嘱id_In);
    End If;
  End If;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病理报到_号码更新;
/

--96692:廖思奇,2016-09-21,将原来输入参数检查类型改为号码规则ID
Create Or Replace Procedure Zl_病理标本_核收
(
  医嘱id_In     病理检查信息.医嘱id%Type,
  病理号_In     病理检查信息.病理号%Type,
  号码规则id_In 病理检查信息.号码规则id%Type,
  送检单位_In   病理送检信息.送检单位%Type,
  送检科室_In   病理送检信息.送检科室%Type,
  送检人_In     病理送检信息.送检人%Type,
  送检日期_In   病理送检信息.送检日期%Type,
  联系方式_In   病理送检信息.联系方式%Type,
  登记人_In     病理送检信息.登记人%Type
) Is
  v_病理号     病理检查信息.病理号%Type := Null;
  v_病理医嘱id 病理检查信息.病理医嘱id%Type;
  v_检查类型   病理检查信息.检查类型%Type;
  v_送检id     病理送检信息.Id%Type;
  v_Seqnum     病理取材信息.序号%Type;
Begin

  Begin
    Select 病理号, 病理医嘱id Into v_病理号, v_病理医嘱id From 病理检查信息 Where 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      v_病理号     := Null;
      v_病理医嘱id := Null;
  End;

  Select 病理送检信息_Id.Nextval Into v_送检id From Dual;

  If v_病理医嘱id Is Null Then
    Select 病理检查信息_病理医嘱id.Nextval Into v_病理医嘱id From Dual;
  End If;

  --取得当前病理检查类型 
  Select 类型 Into v_检查类型 From 病理号码规则 Where ID = 号码规则id_In;

  If v_病理号 Is Null Then
    --没有找到该医嘱对应的病理检查 
  
    --生成病理号 
    --Select Lpad(病理检查信息_病理号.NEXTVAL, 8, 0) into v_病理号 from dual; 
    v_病理号 := Upper(病理号_In);
  
    --添加病理送检信息 
    Insert Into 病理送检信息
      (ID, 医嘱id, 送检单位, 送检科室, 送检人, 送检日期, 联系方式, 登记人, 核收状态)
    Values
      (v_送检id, 医嘱id_In, 送检单位_In, 送检科室_In, 送检人_In, 送检日期_In, 联系方式_In, 登记人_In, 1);
  
    --添加病理检查信息,核收后，检查进入取材流程 
    Insert Into 病理检查信息
      (病理医嘱id, 病理号, 医嘱id, 检查类型, 取材过程, 号码规则id)
    Values
      (v_病理医嘱id, v_病理号, 医嘱id_In, v_检查类型, Decode(v_检查类型, 3, 0, 1), 号码规则id_In);
  Else
    --当该检查已被核收过时，则只添加送检信息 
    Insert Into 病理送检信息
      (ID, 医嘱id, 送检单位, 送检科室, 送检人, 送检日期, 联系方式, 登记人, 核收状态)
    Values
      (v_送检id, 医嘱id_In, 送检单位_In, 送检科室_In, 送检人_In, 送检日期_In, 联系方式_In, 登记人_In, 1);
  End If;

  --如果是会诊，当检测到未核收的标本是蜡块时，则将蜡块信息写入到取材数据中 
  If v_检查类型 = 3 Then
    Begin
      Select Nvl(Max(序号), 0) Into v_Seqnum From 病理取材信息 Where 病理医嘱id = v_病理医嘱id;
    Exception
      When Others Then
        v_Seqnum := 0;
    End;
  
    Insert Into 病理取材信息
      (材块id, 序号, 病理医嘱id, 标本id, 标本名称, 蜡块数, 确认状态)
      Select 病理取材信息_材块id.Nextval, v_Seqnum + Rownum, v_病理医嘱id, 标本id, 标本名称, 数量, 1
      From 病理标本信息
      Where 医嘱id = 医嘱id_In And Nvl(送检id, 0) <= 0 And 材料类别 = 1;
  End If;

  --更新标本的送检ID，核收后，标本送检ID不能为空 
  Update 病理标本信息 Set 送检id = v_送检id Where 医嘱id = 医嘱id_In And (送检id Is Null Or Nvl(送检id, 0) = 0);

  --更新对应医嘱的执行说明... 
  Update 病人医嘱发送
  Set 执行说明 = 执行说明 || Chr(13) || '标本已被核收 [ 时间:' || 送检日期_In || '    登记人:' || 登记人_In || '] '
  Where 医嘱id = 医嘱id_In;

  --更新检查信息的取材过程为需取材（为会诊的检查核收后，不进行取材操作） 
  Update 病理检查信息
  Set 取材过程 = Decode(v_检查类型, 3, 0, 1), 报到时间 = Decode(报到时间, Null, 送检日期_In, '', 送检日期_In, 报到时间)
  Where 病理医嘱id = v_病理医嘱id;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病理标本_核收;
/

--101247:胡俊勇,2016-09-30,门诊费用异常单据判断
--100775:胡俊勇,2016-09-20,医保患者部分退费
Create Or Replace Procedure Zl_门诊医嘱执行_Finish
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
  --执行部门id_In=仅处理指定执行部门的费用，不传或传入0时不限制执行部门
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;
  n_Cnt      Number;
  v_Error    Varchar2(2000);
  Err_Custom Exception;

  Cursor c_Finish(r_No t_Strlist) Is
    Select a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A, 病人医嘱记录 B,
                (Select /*+cardinality(f,10)*/
                   Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
                   To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No) F) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And
                 a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A,
                (Select /*+cardinality(f,10)*/
                   Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
                   To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No) F) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And a.记录状态 In (0, 1, 3) And a.执行状态 <> 1 And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --执行中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select b.Id, Decode(d.高值材料, 1, a.执行部门id, b.库房id) As 库房id
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C, 材料特性 D,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where d.材料id = a.收费细目id And a.Id = b.费用id And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null And b.库房id Is Not Null And
          a.收费类别 = '4' And a.记录状态 = 1 And a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And b.单据 = 24 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.库房id, b.药品id;

  --未审核的费用行(包含药品和卫材)
  Cursor c_Verify(r_No t_Strlist) Is
    Select Distinct a.No, a.序号
    From 门诊费用记录 A, 病人医嘱记录 C,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 = c.Id And (c.Id = 组id_In Or c.相关id = 组id_In) And
          a.No = n.No And Mod(a.记录性质, 10) = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  Cursor c_Verifyone(r_No t_Strlist) Is
    Select a.No, a.序号
    From 门诊费用记录 A,
         (Select /*+cardinality(f,10)*/
            Substr(f.Column_Value, 1, Instr(f.Column_Value, ':') - 1) As NO,
            To_Number(Substr(f.Column_Value, Instr(f.Column_Value, ':') + 1)) As 记录性质
           From Table(r_No) F) N
    Where a.记帐费用 = 1 And a.记录状态 = 0 And a.价格父号 Is Null And a.医嘱序号 + 0 = 医嘱id_In And a.No = n.No And
          Mod(a.记录性质, 10) = n.记录性质 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By NO, 序号;

  v_No   病人医嘱发送.No%Type;
  v_序号 Varchar2(1000);

  v_发料号  药品收发记录.汇总发药号%Type;
  v_库房id  药品收发记录.库房id%Type;
  v_收发ids Varchar2(4000);
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;
  Select Count(1)
  Into n_Cnt
  From 门诊费用记录 A,
       (Select /*+cardinality(f,10)*/
          To_Number(f.Column_Value) As 费用id
         From Table(r_Finish) F) B
  Where a.Id = b.费用id And a.费用状态 = 1;

  If n_Cnt > 0 Then
    v_Error := '当前执行的医嘱对应的费用单据中存在异常单据。';
    Raise Err_Custom;
  End If;
  Forall I In 1 .. r_Finish.Count
    Update 门诊费用记录 Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 操作员姓名_In Where ID = r_Finish(I);

  --执行时自动审核对应的记帐划价单费用
  --包含医嘱对应的药品及卫材费用，因为医嘱已执行，费用应该生效。
  If Nvl(zl_GetSysParameter(81), '0') = '1' Then
    If Nvl(单独执行_In, 0) = 0 Then
      For r_Verify In c_Verify(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    Else
      For r_Verify In c_Verifyone(r_No) Loop
        If r_Verify.No <> v_No And v_序号 Is Not Null Then
          Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
          v_序号 := Null;
        End If;
        v_No   := r_Verify.No;
        v_序号 := v_序号 || ',' || r_Verify.序号;
      End Loop;
    End If;
    If v_序号 Is Not Null Then
      Zl_门诊记帐记录_Verify(v_No, 操作员编号_In, 操作员姓名_In, Substr(v_序号, 2));
    End If;
  End If;

  --处理跟踪在用卫材自动发料
  If Nvl(zl_GetSysParameter(33), '0') = '1' Then
    For r_Stuff In c_Stuff(r_No_Stuff) Loop
      If v_发料号 Is Null Then
        v_发料号 := Nextno(20);
      End If;
    
      If r_Stuff.库房id <> Nvl(v_库房id, 0) Then
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
        End If;
        v_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱执行_Finish;
/

--100276:刘尔旋,2016-09-19,扫条码记帐
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 上次批号, 可用数量, 实际数量, 实际金额, 上次供应商id, 批准文号, 上次产地, 上次生产日期, 灭菌效期, 效期, 零售价, 商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In,0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  n_领药部门id 药品收发记录.对方部门id%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  d_效期       药品收发记录.效期%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_Aval       药品库存.可用数量%Type;
  v_部门名称   部门表.名称%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_库房id     药品库存.库房id%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_Outmode    Number(1);
  v_Dec        Number;
  v_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库序号       药品收发记录.序号%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

Begin
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In,0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, 操作员姓名_In, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0; --@@@
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
      Open c_Stock(n_Outmode, n_虚拟库房id);
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
        Open c_Stock(n_Outmode, n_修正库房id);
      Else
        n_库房id := 执行部门id_In;
        Open c_Stock(n_Outmode, 执行部门id_In);
      End If;
    End If;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许(包含备货卫材)。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Or (Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4') Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where NO = No_In And 记录状态 = 1 And 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0);
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, n_序号, 执行部门id_In,
         n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号, d_效期, Decode(v_Count, 1, 1, 付数_In),
         Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价,
         Round(n_当前单价 * n_当前数量, v_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期,
         d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And a.单据 = 21 And b.No = No_In And b.记录性质 = 2;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '床号:' || 床号_In || v_Err_Msg || '住院号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1,
                            100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, v_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0) And NO = No_In And
          Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, n_领药部门id,
         执行部门id_In, 登记时间_In, Decode(划价_In, 1, 0, 1), 0);
    End If;
    Zl_Prescription_Type_Zy_Update(No_In, 2, 收费细目id_In, 收费类别_In);
    --可能时价药品的库存金额和数量变化了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          --医嘱摆药时是按病人分次计算并提交数据库,因此不同病人使用相同实价药品没有问题。
          --但同一病人同时使用两笔以上相同实价药品则会有问题。
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--100189:李业庆,2016-09-20,库存不严格控制时库存数量为0允许出库
Create Or Replace Procedure Zl_门诊划价记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  病人来源_In   Number := 1,
  保险编码_In   门诊费用记录.保险编码%Type := Null,
  费用类型_In   门诊费用记录.费用类型%Type := Null,
  保险项目否_In 门诊费用记录.保险项目否%Type := Null,
  保险大类id_In 门诊费用记录.保险大类id%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
  
) As
  --功能：新收一张门诊划价单据
  --参数：
  --   病人来源_IN:1-门诊病人,2-住院病人
  --     主页ID_IN:住院病人划价时用。
  --   药品摘要_IN:修改保存新单据时用。目前仅存放在药品收发记录的摘要中。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In,0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  v_其他出库no 药品收发记录.No%Type;
  v_部门名称   部门表.名称%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  n_Aval       药品库存.可用数量%Type;
  n_修正库房id 药品库存.库房id%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;
  n_单价小数   Number;
  n_Outmode    Number(1);
  n_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库检查   Number(1);
Begin
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In,0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额及单价小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Select Nvl(Max(急诊), 0)
    Into n_急诊
    From 病人挂号记录
    Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 发药窗口,
     加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要, 医嘱序号, 保险项目否, 保险编码,
     保险大类id, 费用类型, 结论, 是否急诊)
  Values
    (v_费用id, 1, No_In, 0, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In), Nvl(病人来源_In, 1),
     Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In, 病人科室id_In, 费别_In, 收费类别_In,
     收费细目id_In, 计算单位_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 0,
     操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, 费用摘要_In, 医嘱序号_In, 保险项目否_In, 保险编码_In, 保险大类id_In,
     费用类型_In, 中药形态_In, Nvl(n_急诊, 0));

  --药品和卫生材料部分
  n_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into n_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
      Else
        n_库房id := 执行部门id_In;
      End If;
    End If;
  
    Open c_Stock(n_Outmode, n_库房id);
    
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
    
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货收费！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货收费！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫行材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) And n_出库检查=2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And b.记录性质 = 1 And Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码,
           v_内部条码);
      
      End If;
      v_Err_Msg := '';
    
      n_总数量 := n_总数量 - n_当前数量;
      n_总金额 := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), 主页id_In, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 0, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
  
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
  
    If 费别_In Is Not Null Then
      Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
    End If;
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Insert;
/


--100189:李业庆,2016-09-20,库存不严格控制时库存数量为0允许出库
Create Or Replace Procedure Zl_门诊记帐记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  婴儿费_In     门诊费用记录.婴儿费%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  划价_In       Number,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  记帐单id_In   门诊费用记录.记帐单id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  门诊标志_In   门诊费用记录.门诊标志%Type := 1,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
) As
  --功能：新收一张门诊记帐单据
  --参数：
  --   药品摘要_IN:修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In,0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock      c_Stock%RowType;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_部门名称   部门表.名称%Type;
  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_Aval       药品库存.可用数量%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_单价小数   Number;

  n_Outmode Number(1);
  n_Dec     Number;
  n_Count   Number;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_发药窗口 药品收发记录.发药窗口%Type;
  n_跟踪在用 材料特性.跟踪在用%Type;
  n_出库检查   Number(1);
Begin
  n_跟踪在用 := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select Nvl(跟踪在用, 0) Into n_跟踪在用 From 材料特性 Where 材料id = 收费细目id_In;
  End If;

  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In,0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  If (收费类别_In In ('5', '6', '7') Or 收费类别_In = '4' And n_跟踪在用 = 1) And Nvl(划价_In, 0) = 0 Then
    --同一张单据,满足同一药房同一窗口
    Begin
      Select 发药窗口
      Into v_发药窗口
      From 门诊费用记录
      Where 收费类别 In ('5', '6', '7', '4') And NO = No_In And 记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And
            Rownum <= 1;
    Exception
      When Others Then
        v_发药窗口 := Null;
    End;
    If v_发药窗口 Is Null Then
      --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
      n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
      If n_Count = 0 Then
        n_Count := 1;
      End If;
    
      Begin
        Select 发药窗口
        Into v_发药窗口
        From (Select 登记时间, 发药窗口
               From 门诊费用记录 A
               Where 收费类别 In ('5', '6', '7', '4') And 病人id = 病人id_In And 登记时间 Between Sysdate - n_Count And Sysdate And
                     记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And Exists
                (Select 1
                      From 未发药品记录
                      Where a.No = NO And 单据 In (9, 26) And 库房id + 0 = 执行部门id_In And 病人id + 0 = 病人id_In) And Exists
                (Select 1
                      From 发药窗口
                      Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = 执行部门id_In)
               Order By 登记时间 Desc)
        Where Rownum <= 1;
      
      Exception
        When Others Then
          v_发药窗口 := Null;
      End;
      If v_发药窗口 Is Null Then
        v_发药窗口 := Zl_Get发药窗口(执行部门id_In);
      End If;
    End If;
  End If;
  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;

  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Select Nvl(Max(急诊), 0)
    Into n_急诊
    From 病人挂号记录
    Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
     附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 操作员编号, 操作员姓名, 婴儿费, 记帐单id,
     摘要, 医嘱序号, 结论, 发药窗口, 是否急诊)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 门诊标志_In, 病人id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In,
     病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 付数_In, 数次_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In,
     实收金额_In, 1, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 婴儿费_In, 记帐单id_In, 费用摘要_In, 医嘱序号_In, 中药形态_In, v_发药窗口, Nvl(n_急诊, 0));

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 门诊标志_In;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 门诊标志_In, 实收金额_In);
    End If;
  
  End If;

  --药品和卫生材料部分

  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_跟踪在用, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
      Else
        n_库房id := 执行部门id_In;
      End If;
    End If;
    Open c_Stock(n_Outmode, n_库房id);
    
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
    
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) And n_出库检查=2  Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
    
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 25, 9) And 记录状态 = 1 And NO = No_In;
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 25, 9), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And 记录性质 = 2 And b.门诊标志 = 门诊标志_In And
                Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 姓名 = 姓名_In, 发药窗口 = v_发药窗口
    Where 单据 = Decode(收费类别_In, '4', 25, 9) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态, 发药窗口)
      Values
        (Decode(收费类别_In, '4', 25, 9), No_In, 病人id_In, 姓名_In, v_优先级, 开单部门id_In, 执行部门id_In, 登记时间_In,
         Decode(划价_In, 1, 0, 1), 0, v_发药窗口);
    End If;
    Zl_Prescription_Type_Update(No_In, 2, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
  
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Insert;
/



--100507:冉俊明,2016-09-08,单据全部退费完后删除医嘱附费记录
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7'))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                      (Select 1
                            From 病人医嘱附费
                            Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_总金额
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额, 1);
        n_返回值 := n_总金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      --性质=1，原因=6为退费打印票据(红票)，不回收
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4')
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--99715:冉俊明,2016-10-09,部分退费非药品准退数计算有误。
--100507:冉俊明,2016-09-08,单据全部退费完后删除医嘱附费记录
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差, Nvl(j.医嘱状态, 0) As 医嘱状态
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_组id     财务缴款分组.Id%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();

  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_启用模式 Number(3);
  v_Para     Varchar2(1000);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱执行计价的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血),已执行的不允许退费
            --: 2.不存在医嘱执行计价的,则以剩余数量为准
            --: 3.医嘱作废了的,则以剩余数量为准(病人医嘱记录.医嘱状态=4表示作废医嘱，会删除"病人医嘱发送",门诊药嘱先作废后退药)
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null And r_Bill.医嘱状态 <> 4 Then
              Select Nvl(Sum(Decode(c.执行状态, 0, 1, 0) * c.数量), 0), Count(1)
              Into n_准退数量, n_Count
              From 病人医嘱发送 B, 医嘱执行计价 C
              Where b.医嘱id = r_Bill.医嘱序号 And b.No = r_Bill.No And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And
                    c.收费细目id + 0 = r_Bill.收费细目id And b.记录性质 = 1;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行，不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              If r_Bill.执行状态 = 2 Then
                --无医嘱执行计价的部分退费无法判断准退数量，不允许退费
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已部分执行，无法判断准退数量，不允许退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          If n_准退数量 < 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --该笔项目第几次退费
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数)
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;
  --标记原费用记录
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --调整医嘱执行计价.执行状态 NULL-历史数据；0-未执行；1-已执行；2-已退费
  For c_费用 In (Select Distinct a.医嘱序号 As 医嘱id, a.收费细目id, b.发送号
               From 门诊费用记录 A, 病人医嘱发送 B
               Where a.医嘱序号 = b.医嘱id And a.No = b.No And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.No = No_In And
                     (Instr(',' || 序号_In || ',', ',' || a.序号 || ',') > 0 Or 序号_In Is Null) And a.价格父号 Is Null And
                     b.记录性质 = 1) Loop
    Update 医嘱执行计价
    Set 执行状态 = 2
    Where 医嘱id = c_费用.医嘱id And 发送号 = c_费用.发送号 And 收费细目id = c_费用.收费细目id And 执行状态 = 0;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--84426:冉俊明,2016-10-25,三方卡历史数据部分退费。
--100507:冉俊明,2016-09-08,单据全部退费完后删除医嘱附费记录
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额)
  --        一卡通结算_In 全退时传入不原样退回的结算方式；医疗卡部分退费时，传入"结算方式|金额"
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式)
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
  n_会话号       病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3, n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录
          n_费用状态 := 0;
          --该笔项目第几次退费
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  ---------------------------------------------------------------------------------
  --处理病人预交记录

  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理)
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对.
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上
      --需要处理误差金额
    Else
      --a.原样退回
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    -------------------------------------------------
    --部分退费
    n_已退金额 := 0;
    --医疗卡部分退费时，传入:结算方式|金额
    If 一卡通结算_In Is Not Null Then
      If Instr(一卡通结算_In, '|') > 0 Then
        v_当前结算 := 一卡通结算_In;
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        n_结算金额 := Nvl(To_Number(v_当前结算), 0);
        If Not Nvl(v_结算方式, 'TMP') = 'TMP' Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '三方接口部分退费', v_结算方式, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, -1 * (n_结算金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 1, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum < 2;
        End If;
        n_已退金额 := n_结算金额;
      End If;
    End If;
    --其它直接退为指定结算方式
    If (n_总金额 - n_已退金额 + Nvl(误差_In, 0)) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
         结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
               操作员姓名_In, -1 * (n_总金额 - n_已退金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Decode(校对标志, 1, 2, 0), n_结算序号, 3, n_会话号
        From 病人预交记录
        Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
    End If;
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 And 一卡通结算_In Is Null Then
      n_预交金额 := n_总金额 - n_已退金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If Nvl(校对标志_In, 0) = 0 Then
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
          n_返回值 := n_总金额 + Nvl(误差_In, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3, n_会话号
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3,
                   n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  ---------------------------------------------------------------------------------
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  --如果是需要校对的,暂不处理人员缴款余额
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--102163:胡俊勇,2016-11-02,医嘱单打印
--94035:胡俊勇,2016-09-08,医嘱单打印
Create Or Replace Procedure Zl_病人医嘱打印_Delete
(
  病人id_In   病人医嘱记录.病人id%Type,
  主页id_In   病人医嘱记录.主页id%Type,
  婴儿_In     病人医嘱记录.婴儿%Type,
  期效_In     病人医嘱记录.医嘱期效%Type,
  起始页号_In 病人医嘱打印.页号%Type := Null,
  医嘱位置_In Varchar2 := Null,
  清除方式_In Number := Null
  --清除方式_In： 1-清除上次打印保留数据，2-清除上次打印删除打印数据，3－清除预打印数据，其它－按指定规则清除打印
) Is
  v_位置   Varchar2(10);
  n_Cnt    Number(8);
  n_End    Number(8);
  n_Begin  Number(8);
  n_重整   Number;
  d_重整   Date;
  n_医嘱id 病人医嘱记录.Id%Type;
Begin
  If 清除方式_In = 3 Then
    Delete From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 Is Null;
  Else
    --医嘱变化时的自动清除和清除指定位置医嘱，删数据方式
    If 期效_In = 1 Then
      d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
    Else
      Select 医嘱重整时间 Into d_重整 From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
      If d_重整 Is Null Then
        d_重整 := To_Date('1900-01-01', 'YYYY-MM-DD');
      End If;
    End If;
  
    If 清除方式_In Is Null Then
      If 医嘱位置_In Is Not Null Then
        v_位置 := 医嘱位置_In;
      End If;
      If v_位置 Is Null Then
        --通过页号来找一个合适的位置
        v_位置 := LPad(起始页号_In, 4, '0') || '001';
      End If;
    Else
      Select Nvl(Min(LPad(页号, 4, '0') || LPad(行号, 3, '0')), '0001001')
      Into v_位置
      From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            打印时间 = (Select Max(打印时间)
                    From 病人医嘱打印
                    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In);
    End If;
    n_重整 := 0;
    n_Cnt  := To_Number(v_位置);
    Select Max(医嘱id)
    Into n_医嘱id
    From 病人医嘱打印
    Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
          To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) = n_Cnt;
  
    --判断重整的情况
    If d_重整 <> To_Date('1900-01-01', 'YYYY-MM-DD') And 期效_In = 0 Then
      --找到数据说明这条医嘱是已经被重整，所以本次清除只能最后一次重整处
      Select Max(n.位置)
      Into n_Cnt
      From (Select To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) As 位置
             From 病人医嘱打印
             Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And 打印时间 < d_重整 And
                   医嘱id = n_医嘱id) N;
      If n_Cnt Is Null Then
        n_Cnt := To_Number(v_位置);
      Else
        n_Cnt  := n_Cnt + 1;
        n_重整 := 1;
      End If;
    End If;
  
    If n_重整 <> 1 Then
      --判断这条医嘱是不是占用了两页，只有药品医嘱才可能会用两页的情况
      For X In (Select Nvl(a.相关id, a.Id) As 组id, a.相关id, a.Id, a.诊疗类别, b.操作类型
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.Id = n_医嘱id) Loop
        If x.诊疗类别 = '5' Or x.诊疗类别 = '6' Or (x.诊疗类别 = 'E' And x.操作类型 = '2') Then
          Select Max(n.位置), Min(n.位置)
          Into n_End, n_Begin
          From (Select To_Number(LPad(b.页号, 4, '0') || LPad(b.行号, 3, '0')) As 位置
                 From 病人医嘱记录 A, 病人医嘱打印 B
                 Where (ID = x.组id Or 相关id = x.组id) And a.Id = b.医嘱id) N;
          If n_End >= n_Cnt And n_Begin < n_Cnt Then
            Update 病人医嘱打印
            Set 打印标记 = Null, 打印人 = Null, 打印时间 = Null
            Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
                  To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) Between n_Cnt And n_End;
            n_Cnt := n_End + 1;
          End If;
        End If;
      End Loop;
    End If;
  
    If n_Cnt Is Not Null Then
      Delete From 病人医嘱打印
      Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(婴儿, 0) = 婴儿_In And 期效 = 期效_In And
            To_Number(LPad(页号, 4, '0') || LPad(行号, 3, '0')) >= n_Cnt;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱打印_Delete;
/

--103209:刘尔旋,2016-12-05,服务窗医保实时结算处理
--100340:刘尔旋,2016-09-07,服务窗退费检查
Create Or Replace Procedure Zl_Third_Charge_Delcheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方退费检查 
  --入参:Xml_In: 
  --<IN>
  --    <BRID>病人ID</BRID>
  --    <JE></JE> //退款总金额
  --    <JSKLB></JSKLB>     //结算卡类别
  --    <TFZY>退费摘要</TFZY>
  --    <JCFP>1</JCFP>      //检查发票,0-不检查;1-检查;为1时，打印了发票的单据不能退费
  --    <XL>险类</XL>         //医保病人险类,空代表普通病人
  --    <FYLIST>
  --        <FY>
  --           <DJH>退款单据号</DJH>
  --           <XH>退款序号(格式:1,2,3..为空代表退剩余数量)</DJH>
  --        <FY>
  --    </FYLIST>
  --    <TKLIST>
  --        <TK>
  --            <TKKLB>退款卡类别</TKKLB>
  --            <TKKH>退款卡号</TKKH>
  --            <TKFS>退款方式</TKFS> //退款方式:现金;支票,如果是三方卡,可以传空
  --            <TKJE>支付金额</TKJE>
  --            <JYLSH>交易流水号</JYLSH>
  --            <TKZY>摘要</TKZY>
  --            <TYJK>退回预交款</TYJK> //允冲预交时,只填JSJE节点:1-冲预交
  --            <SFXFK>是否消费卡</SFXFK>   //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --            <EXPENDLIST>  //扩展交易信息
  --                <EXPEND>
  --                    <JYMC>交易名称</JYMC>
  --                    <JYLR>交易内容</JYLR>
  --                </EXPEND>
  --            </EXPENDLIST>
  --        </TK>
  --    </TKLIST>
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    DD如无下列错误结点则说明通过检查
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  n_退款总额 门诊费用记录.实收金额%Type;

  n_病人id     门诊费用记录.病人id%Type;
  n_单据病人id 门诊费用记录.病人id%Type;
  v_操作员编码 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_原结算序号 病人预交记录.结算序号%Type;
  v_结算卡类别 Varchar2(100);
  v_结算方式   医疗卡类别.结算方式%Type;
  n_卡类别id   医疗卡类别.Id%Type;

  v_摘要     门诊费用记录.摘要%Type;
  n_Count    Number(18);
  n_Temp     Number(18);
  n_检查发票 Number(3);
  n_是否打印 Number(3);
  n_退费模式 Number(3);
  n_状态     Number(3);
  n_险类     病人信息.险类%Type;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  --0.获取入参中的病人ID等信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), To_Number(Extractvalue(Value(A), 'IN/JE')),
         Extractvalue(Value(A), 'IN/TFZY'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         Extractvalue(Value(A), 'IN/JSKLB'), To_Number(Extractvalue(Value(A), 'IN/XL'))
  Into n_病人id, n_退款总额, v_摘要, n_检查发票, v_结算卡类别, n_险类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查
  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许退费操作!';
    Raise Err_Item;
  End If;

  n_退费模式 := zl_GetSysParameter('门诊退费须先申请');

  If v_结算卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_结算卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
      Exception
        When Others Then
          v_Err_Msg := '无法确认传入的结算卡！';
          Raise Err_Item;
      End;
    End If;
  Else
    n_卡类别id := 0;
  End If;

  If Nvl(n_卡类别id, 0) <> 0 Then
    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许退费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;

  --1.退费检查

  n_Count      := 0;
  n_原结算序号 := 0;
  For c_费用 In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号, Extractvalue(b.Column_Value, '/FY/XH') As 退款序号
               From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If c_费用.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费的单据号,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_退费模式, 0) = 1 Then
      Begin
        Select Nvl(状态, 0) Into n_状态 From 病人退费申请 Where NO = c_费用.单据号 And Mod(记录性质, 10) = 1;
      Exception
        When Others Then
          n_状态 := 0;
      End;
      If n_状态 <> 1 Then
        v_Err_Msg := '当前为退费申请模式,退费之前需申请并审核通过该单据!';
        Raise Err_Item;
      End If;
    End If;
  
    Begin
      Select a.结算序号, a.结帐id, a.病人id
      Into n_Temp, n_结帐id, n_单据病人id
      From 病人预交记录 A, 门诊费用记录 B
      Where a.结帐id = b.结帐id And b.No = c_费用.单据号 And b.记录性质 = 1 And Nvl(b.费用状态, 0) = 0 And b.记录状态 In (1, 3) And
            Rownum < 2;
    Exception
      When Others Then
        n_Temp := Null;
    End;
  
    If n_Temp Is Null Then
      v_Err_Msg := '指定的单据号:' || c_费用.单据号 || '未找到,不能退费!';
      Raise Err_Item;
    End If;
  
    If Nvl(n_单据病人id, 0) = 0 Then
      Begin
        Select 病人id
        Into n_单据病人id
        From 门诊费用记录
        Where NO = c_费用.单据号 And 记录性质 = 1 And Nvl(费用状态, 0) = 0 And 记录状态 In (1, 3) And Rownum < 2;
      Exception
        When Others Then
          n_单据病人id := 0;
      End;
    End If;
  
    If Nvl(n_病人id, 0) <> Nvl(n_单据病人id, 0) Then
      v_Err_Msg := '本次退费的收费单:' || c_费用.单据号 || '不是当前病人的收费单,不能退费!';
      Raise Err_Item;
    End If;
  
    If n_原结算序号 <> 0 And n_原结算序号 <> n_Temp Then
      v_Err_Msg := '本次退费的单据号不是一次收费结算,不能退费!';
      Raise Err_Item;
    End If;
    n_原结算序号 := n_Temp;
  
    Select Count(*) Into n_Temp From 费用补充记录 Where 收费结帐id = n_结帐id;
    If Nvl(n_Temp, 0) <> 0 Then
      v_Err_Msg := '本次退费的单据号已经进行了保险补充结算,不能退费!';
      Raise Err_Item;
    End If;
  
    If v_结算卡类别 Is Not Null Then
      If Nvl(n_险类, 0) = 0 Then
        Select Count(*) Into n_Temp From 病人预交记录 Where 结帐id = n_结帐id And 结算方式 <> v_结算方式;
      Else
        Select Count(*)
        Into n_Temp
        From 病人预交记录 A, 结算方式 B
        Where a.结帐id = n_结帐id And a.结算方式 <> v_结算方式 And a.结算方式 = b.名称 And b.性质 Not In (3, 4);
        If n_Temp = 0 Then
          Select Nvl(Max(1), 0)
          Into n_Temp
          From 保险结算记录 A
          Where a.记录id = n_结帐id And 险类 <> n_险类 And Rownum < 2;
        End If;
      End If;
      If Nvl(n_Temp, 0) > 0 Then
        v_Err_Msg := '本次退费的单据包含' || v_结算方式 || '以外的结算方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    If Nvl(n_检查发票, 0) = 1 Then
      Select Max(Decode(a.实际票号, Null, 0, 1))
      Into n_是否打印
      From 门诊费用记录 A
      Where NO = c_费用.单据号 And 记录性质 = 1;
      If Nvl(n_是否打印, 0) = 1 Then
        v_Err_Msg := '本次退费的单据号已开发票,不能退费!';
        Raise Err_Item;
      End If;
    End If;
  
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '未确定本次需要退费的单据,不能退费!';
    Raise Err_Item;
  End If;

  --2.支付方式检查
  n_Count := 0;
  For c_结算方式 In (Select Extractvalue(b.Column_Value, '/TK/TKKLB') As 卡类别, Extractvalue(b.Column_Value, '/TK/TKKH') As 卡号,
                        Extractvalue(b.Column_Value, '/TK/TKFS') As 结算方式,
                        -1 * To_Number(Extractvalue(b.Column_Value, '/TK/TKJE')) As 退款金额,
                        Extractvalue(b.Column_Value, '/TK/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/TK/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/TK/TKZY') As 摘要,
                        Extractvalue(b.Column_Value, '/TK/TYJK') As 是否退预交,
                        Extractvalue(b.Column_Value, '/TK/SFXFK') As 是否消费卡,
                        Extract(b.Column_Value, '/TK/EXPENDLIST') As Expend
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/TKLIST/TK'))) B) Loop
  
    --1.退回三方卡
    If c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
      --1.三方卡结算
      Null;
    Elsif c_结算方式.卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
      --2.消费卡结算
      Null;
    Elsif Nvl(c_结算方式.是否退预交, 0) = 1 Then
      --3.退预交款
      Null;
    Else
      --4.普通结算
      If c_结算方式.结算方式 Is Null Then
        v_Err_Msg := '未指定支付方式,不能退费!';
        Raise Err_Item;
      End If;
    End If;
    n_Count := n_Count + 1;
  End Loop;

  If n_Count = 0 Then
    v_Err_Msg := '不能有效确认当前的支付方式,不能退费!';
    Raise Err_Item;
  End If;

  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delcheck;
/

--100367:张德婷,2016-09-06,静配中心空包药品收费
CREATE OR REPLACE Procedure Zl_输液配药记录_取消发送(配药id_In In Varchar2 --ID串:ID1,ID2....
                                           ) Is
  v_Tansid   Varchar2(20);
  v_Tmp      Varchar2(4000);
  v_操作人员 输液配药记录.操作人员%Type;
  d_操作时间 输液配药记录.操作时间%Type;
  n_打包     number(2);

  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  v_Usercode Varchar2(100);
  Err_Custom Exception;
Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

    --检查当前输液单的状态是否为已发送状态
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态!=5 then
        v_Error := '该数据已被操作，不能进行取消发送操作！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Select 操作人员, 操作时间
    Into v_操作人员, d_操作时间
    From (Select 操作人员, 操作时间 From 输液配药状态 Where 配药id = v_Tansid And 操作类型 = 4 Order By 操作时间 Desc)
    Where Rownum = 1;

    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = v_操作人员, 操作时间 = d_操作时间 Where ID = v_Tansid;
    
    Select 是否打包 Into n_打包 From 输液配药记录 Where ID = v_Tansid;
    If n_打包 <>0 Then
      for r_item in (Select A.NO,B.序号 From 输液配药附费 A,住院费用记录 B Where A.病人ID=B.病人ID and A.NO=B.No and B.记录状态=1 and A.配药id = v_Tansid) loop
        if r_item.NO is not null then
          Zl_住院记帐记录_Delete(r_item.NO,r_item.序号, v_Usercode, Zl_Username);
        end if;
      end loop;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_取消发送;
/

--100367:张德婷,2016-09-07,静配中心空包药品收费
CREATE OR REPLACE Procedure Zl_输液配药记录_发送
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid Varchar2(20);
  v_Tmp    Varchar2(4000);
  v_Error    Varchar2(255);
  n_操作状态 输液配药记录.操作状态%Type;
  n_People  number(2);
  v_No       Varchar2(20);
  n_项目id   number(18);
  v_收费项目id varchar2(200);
  n_row      number(2);
  n_Out number(10);
  n_OutNum number(10);
  n_count number(18);
  n_packet number(2);
  v_Usercode Varchar2(100);
  Err_Custom Exception;
  
  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id,f.配药类型,c.执行时间 
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And Nvl(c.是否打包, 0) <> 0 And c.Id = v_Tansid;
Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People:=Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out:=Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);
  n_packet:=Nvl(zl_GetSysParameter('打包药品在发送环节收取配置费', 1345), 0);
  
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');

     Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;

      if n_操作状态>4 then
        v_Error := '该数据已被操作，不能进行发送操作！';
        Raise Err_Custom;
      end if;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;

    Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间,操作说明) Values (v_Tansid, 5, 操作人员_In, 操作时间_In,操作说明_In);
    Update 输液配药记录 Set 操作状态 = 5, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    
    --打包药品收费
    if n_packet=1 then
      n_count:=0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select count(病人id) into n_OutNum From 病案主页 where 主页ID=r_Bill.主页id And 病人ID=r_Bill.病人id  And (Nvl(状态,0)=3 Or 出院日期 Is Not NULL);
        select count(项目id) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
        if n_项目id<>0 then
          n_row:=0;
          select nvl(项目id,0) into n_项目id from 配置收费方案 where 配药类型=substr(r_Bill.配药类型,INSTR(r_Bill.配药类型,'-',1,1)+1);
          if n_People=1 then
            select count(配药id) into n_row from 输液配药附费 A,住院费用记录 B,输液配药记录 C where A.No=b.no and A.配药ID=C.id and b.病人id=r_Bill.病人id And B.记录状态=1 and B.收费细目id=n_项目id and r_Bill.执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间+1) - 1 / 24 / 60 / 60;
          end if;
        else
          n_row:=1;
        end if;

        if n_row=0 and (n_OutNum=0 or n_out=0) then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.id=n_项目id and
                               b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            if n_count=0 then
              Insert Into 输液配药附费 (配药id, NO,病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            end if;

            n_count:=n_count+1;
            Zl_住院记帐记录_Insert(v_No, n_count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄, r_Bill.床号,
                             r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id, 操作人员_In, Null,
                             r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null, r_Bill.库房id, Null,
                             r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null, Sysdate, Sysdate, Null, Null,
                             v_Usercode, 操作人员_In);
          End Loop;
        end if;

        if n_People<>1 and n_row=0 then
          Exit;
        end if;
      end loop;
    end if;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_发送;
/

--100246:冉俊明,2016-09-06,医保退费返回退费结算方式，病人预交记录记录状态填的是1.
Create Or Replace Procedure Zl_门诊收费结算_Update
(
  结帐id_In       门诊费用记录.结帐id%Type,
  收费结算_In     Varchar2,
  冲预交额_In     病人预交记录.冲预交%Type,
  保险结算_In     Varchar2,
  误差_In         门诊费用记录.实收金额%Type,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  是否退费结算_In Number := 0
) As
  --功能:处理收费时和医保正式结算后,相关结算信息的调整
  --     因为预结算后,生成的医保结算金额总额及分摊可能会与正式结算时有差异,所以提供了校对功能,
  --   操作员在结算校对时,可以调整非医保结算方式的各种结算金额及方式,重新生成结算串,并且可能产生误差金额.
  --是否退费结算_In:是否退费结算调用

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And 预交类别 = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.No = b.No And a.病人id = v_病人id And a.预交类别 = 1
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And 预交类别 = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  --过程变量
  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;

  v_费用id 门诊费用记录.Id%Type;
  v_序号   门诊费用记录.序号%Type;

  v_收费类别   门诊费用记录.收费类别%Type;
  v_收费细目id 门诊费用记录.收费细目id%Type;
  v_计算单位   门诊费用记录.计算单位%Type;
  v_收入项目id 门诊费用记录.收入项目id%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  v_执行部门id 门诊费用记录.执行部门id%Type;
  v_Temp       Varchar2(500);
  n_返回值     人员缴款余额.余额%Type;
  v_No         病人预交记录.No%Type;
  v_病人id     病人预交记录.病人id%Type;
  v_收款时间   病人预交记录.收款时间%Type;
  v_操作员编号 病人预交记录.操作员编号%Type;
  v_操作员姓名 病人预交记录.操作员姓名%Type;

  v_预交金额 病人预交记录.冲预交%Type;
  n_组id     财务缴款分组.Id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
  n_费用状态 门诊费用记录.费用状态%Type;
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin

  --1.取预交记录需要的相关信息
  Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
  Into v_No, v_病人id, v_收款时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
  From 门诊费用记录
  Where 结帐id = 结帐id_In And Rownum = 1 And 记录性质 = 1;
  --误差相关信息
  Begin
    Select a.类别, a.Id, a.计算单位, c.Id, c.收据费目
    Into v_收费类别, v_收费细目id, v_计算单位, v_收入项目id, v_收据费目
    From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
    Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And Sysdate Between b.执行日期 And
          Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
  Exception
    When Others Then
      Begin
        v_Error := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
        Raise Err_Custom;
      End;
  End;

  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  If Nvl(n_费用状态, 0) <> 1 Then
    --2.删除旧的记录,回退汇总数据
    --回退人员缴款余额,病人余额,
    --人员缴款余额中不包含未较对的,未较对的直接删除
    For c_Del In (Select 冲预交, 操作员姓名, 结算方式
                  From 病人预交记录
                  Where 结帐id = 结帐id_In And 记录性质 = 3 And Nvl(校对标志, 0) = 0) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - Nvl(c_Del.冲预交, 0)
      Where 结算方式 = c_Del.结算方式 And 收款员 = v_操作员姓名 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (v_操作员姓名, c_Del.结算方式, 1, -1 * c_Del.冲预交);
        n_返回值 := -1 * c_Del.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 性质 = 1 And 收款员 = v_操作员姓名 And 结算方式 = c_Del.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If v_病人id > 0 Then
    For v_预交 In (Select 预交类别, Nvl(Sum(冲预交), 0) As 预交金额
                 From 病人预交记录
                 Where 结帐id = 结帐id_In And 记录性质 In (1, 11)
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = v_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2);
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, Nvl(v_预交.预交类别, 2), v_预交金额, 1);
      End If;
    
    End Loop;
  End If;

  --回退汇总表
  --只可能产生误差金额的变化,其它的不会变,并且只可能存在一行,仅为了变量处理方便而用游标

  --删除收费结算,保险结算记录
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 3;
  --第一次冲预交的,清空冲减额
  Update 病人预交记录 Set 冲预交 = Null, 结帐id = Null, 结算性质 = Null Where 结帐id = 结帐id_In And 记录性质 = 1;
  --删除冲余款
  Delete 病人预交记录 Where 结帐id = 结帐id_In And 记录性质 = 11;
  --删除误差记录
  Delete 门诊费用记录 Where 结帐id = 结帐id_In And 附加标志 = 9;

  --3.产生门诊费用记录的误差记录
  If 误差_In <> 0 Then
    Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
    Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In And 记录性质 = 1;
    v_Temp       := Zl_Identity;
    v_执行部门id := To_Number(Substr(v_Temp, 1, Instr(v_Temp, ',') - 1));
  
    Insert Into 门诊费用记录
      (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
       发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 费用状态,
       结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
      Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, v_收费类别,
             v_收费细目id, v_计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, 误差_In, 误差_In, 误差_In, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
             登记时间, v_执行部门id, 执行状态, 费用状态, 结帐id, 误差_In, 操作员编号, 操作员姓名, 1, 缴款组id
      From 门诊费用记录
      Where 记录性质 = 1 And 结帐id = 结帐id_In And Rownum = 1;
  End If;

  --4.重新生成病人预交记录相关数据
  --4.1.收费结算
  If 收费结算_In Is Not Null Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算号码 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, Decode(是否退费结算_In, 1, 2, 1), v_病人id, Null, Decode(是否退费结算_In, 1, '退费结算', '收费结算'),
           v_结算方式, v_结算号码, v_收款时间, v_操作员编号, v_操作员姓名, v_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
           Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.2.保险结算
  If 保险结算_In Is Not Null Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
        Values
          (病人预交记录_Id.Nextval, 3, v_No, Decode(是否退费结算_In, 1, 2, 1), v_病人id, Null, '保险结算', v_结算方式, v_收款时间, v_操作员编号,
           v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, 3);
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4.3.预交结算
  If Nvl(冲预交额_In, 0) <> 0 Then
    If Nvl(v_病人id, 0) = 0 Then
      v_Error := '不能确定病人的病人ID,收费不能使用预交款结算,结算操作失败！';
      Raise Err_Custom;
    End If;
  
    v_预交金额 := 冲预交额_In;
    For r_Deposit In c_Deposit(v_病人id) Loop
      If r_Deposit.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, v_收款时间,
               v_操作员姓名, v_操作员编号, Decode(Sign(r_Deposit.金额 - v_预交金额), -1, r_Deposit.金额, v_预交金额), 结帐id_In, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --检查是否已经处理完
      If r_Deposit.金额 < v_预交金额 Then
        v_预交金额 := v_预交金额 - r_Deposit.金额;
      Else
        v_预交金额 := 0;
      End If;
      If v_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If v_预交金额 > 0 Then
      v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
      Raise Err_Custom;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交额_In
    Where 病人id = v_病人id And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (v_病人id, 1, -1 * 冲预交额_In, 1);
      n_返回值 := -1 * 冲预交额_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  End If;

  --5.相关汇总表的处理
  --汇总人员缴款余额
  --收费结算
  If 收费结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --各个保险结算

  If 保险结算_In Is Not Null And Nvl(n_费用状态, 0) <> 1 Then
    v_结算内容 := 保险结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      If Nvl(v_结算金额, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_结算方式, 1, Nvl(v_结算金额, 0));
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --汇总表,只需重汇误差行,因为其它项不会变
  --6.医保相关表的处理
  --Delete 医保核对表 Where 结帐Id=结帐Id_IN;
  Update 保险结算明细 Set 标志 = 2 Where 结帐id = 结帐id_In;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_Update;
/

--103209:刘尔旋,2016-12-12,服务窗医保实时结算处理
--99884:刘尔旋,2016-09-06,服务窗接口预约当天号
Create Or Replace Procedure Zl_Third_Regist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号
  --入参:Xml_In:
  --<IN>
  --   <CZFS>3</CZFS>    //操作方式
  --   <CZJLID>1</CZJLID>    //出诊记录ID
  --   <HM>号码</HM>    //号码
  --   <HX>号序</HX>     //号序
  --   <JKFS>0</JKFS>  //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --   <YYSJ>2014-10-21 </YYSJ>    //预约日期 YYYY-MM-DD,分时段非序号控制需要传入时间
  --   <JE>金额</JE>     //金额
  --   <JSLIST>
  --     <JS>            //结算信息，挂号非医保结算目前仅支持一个，结构与收费一致
  --       <JSKLB>结算卡类别</JSKLB>    //结算卡类别
  --       <JSKH>支付宝帐号</JSKH>           //结算卡号(支付宝帐号)
  --       <JYSM>交易说明</JYSM>            //说明，固定传支付宝
  --       <JYLSH>流水号</JYLSH>           //流水号，传订单号
  --       <JSFS>结算方式</JSFS>            //结算方式:现金、支票，如果是三方卡,可以传空
  --       <JSJE>结算金额</JSJE>            //结算金额
  --       <ZY>摘要</ZY>                  //摘要
  --       <SFCYJ></SFCYJ>              //是否冲预交，挂号目前不传
  --       <SFXFK></SFXFK>              //是否消费卡,挂号目前不传
  --       <EXPENDLIST>                 //扩展信息
  --         <EXPEND>
  --           <JYMC>交易名称</JYMC>        //交易名称
  --           <JYLR>交易内容<JYLR>         //交易内容
  --         </EXPEND>
  --         <EXPEND>
  --           ...
  --         </EXPEND>
  --       </EXPENDLIST>
  --     </JS>
  --   </JSLIST>
  --   <HZDW>合作单位</HZDW>        //合作单位名称
  --   <YYFS>支付宝<YYFS>    //预约方式,如自助机，支付宝
  --   <BRID>病人ID</BRID>     //病人ID
  --   <BRLX></BRLX>             //医保病人类型
  --   <FB>普通</FB>               //病人费别，可以不传
  --   <JQM>机器名</JQM>            //机器名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <GHDH>挂号单号</GHDH>          //挂号单号
  -- <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  -- <JZID>结帐ID</JZID>          //本次结帐ID
  -- <ERROR><MSG>错误信息</MSG></ERROR>  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码     挂号安排.号码%Type;
  d_发生时间 Date;
  d_原始时间 Date;
  d_登记时间 Date;
  v_金额     Varchar2(200);

  n_应收金额   门诊费用记录.应收金额%Type;
  v_流水号     病人预交记录.交易流水号%Type;
  v_说明       门诊费用记录.摘要%Type;
  n_病人id     病人信息.病人id%Type;
  v_预约方式   预约方式.名称%Type;
  v_卡类别名称 医疗卡类别.名称%Type;
  v_结算卡号   病人预交记录.卡号%Type;
  n_门诊号     门诊费用记录.标识号%Type;
  v_姓名       门诊费用记录.姓名%Type;
  v_性别       门诊费用记录.性别%Type;
  v_年龄       门诊费用记录.年龄%Type;
  v_付款方式   门诊费用记录.付款方式%Type;
  v_费别       门诊费用记录.费别%Type;
  v_No         病人挂号记录.No%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  v_收费类别   门诊费用记录.收费类别%Type;
  n_收费细目id 门诊费用记录.收费细目id%Type;
  n_标准单价   门诊费用记录.标准单价%Type;
  n_收入项目id 门诊费用记录.收入项目id%Type;
  n_屏蔽费别   收费项目目录.屏蔽费别%Type;
  v_收据费目   门诊费用记录.收据费目%Type;
  n_病人科室id 门诊费用记录.病人科室id%Type;
  n_开单部门id 门诊费用记录.开单部门id%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_医生姓名   挂号安排.医生姓名%Type;
  n_医生id     挂号安排.医生id%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_卡类别id   医疗卡类别.Id%Type;
  v_排班       挂号安排.周日%Type;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_号序       挂号序号状态.序号%Type;
  v_星期       挂号安排限制.限制项目%Type;
  v_病人类型   病人信息.病人类型%Type;
  n_存在       Number(3);
  v_现金       结算方式.名称%Type;
  n_分时段     Number(3);
  v_结算内容   Varchar2(3000);
  v_合作单位   病人挂号记录.合作单位%Type;
  v_机器名     挂号序号状态.机器名%Type;
  n_缴款方式   Number(3);
  n_挂号模式   Number(3);
  n_普通结算   Number(3);
  n_Exists     Number(3);
  v_保险结算   Varchar2(1000);
  n_记录id     临床出诊记录.Id%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  d_启用时间   Date;
  v_Para       Varchar2(2000);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/HX'),
         To_Date(Extractvalue(Value(A), 'IN/YYSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/JE'),
         Extractvalue(Value(A), 'IN/YYFS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/BRID'),
         Extractvalue(Value(A), 'IN/BRLX'), Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/JQM'),
         Extractvalue(Value(A), 'IN/JKFS'), Extractvalue(Value(A), 'IN/CZJLID')
  Into v_号码, n_号序, d_原始时间, n_应收金额, v_预约方式, v_合作单位, n_病人id, v_病人类型, v_费别, v_机器名, n_缴款方式, n_记录id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(d_原始时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_记录id Is Null Then
      Begin
        Select a.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_原始时间, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  d_登记时间 := Sysdate;
  d_发生时间 := Trunc(d_原始时间);
  If v_病人类型 Is Not Null Then
    Begin
      Select 1 Into n_存在 From 病人类型 Where 名称 = v_病人类型;
    Exception
      When Others Then
        v_Err_Msg := '没有发现为(' || v_病人类型 || ')的病人类型';
        Raise Err_Item;
    End;
    Update 病人信息 Set 病人类型 = Nvl(病人类型, v_病人类型) Where 病人id = n_病人id;
  End If;

  Select a.门诊号, a.姓名, a.性别, a.年龄, Nvl(b.编码, c.编码)
  Into n_门诊号, v_姓名, v_性别, v_年龄, v_付款方式
  From 病人信息 A, 医疗付款方式 B, (Select 编码 From 医疗付款方式 Where 缺省标志 = '1' And Rownum < 2) C
  Where a.病人id = n_病人id And a.医疗付款方式 = b.名称(+);
  v_No   := Nextno(12);
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  v_Temp := Zl_Identity(2);
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into n_开单部门id From Dual;

  If n_记录id Is Null Then
    n_普通结算 := 0;
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
      Else
        Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = r_结算.结算方式 And 性质 In (3, 4);
        If n_Exists = 1 Then
          v_保险结算 := v_保险结算 || '||' || r_结算.结算方式 || '|' || r_结算.结算金额;
        Else
          If v_结算方式 Is Null Then
            v_结算方式 := r_结算.结算方式;
          Else
            v_Err_Msg := '目前计划排班挂号不支持非医保外的多种结算方式,请检查!';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      End If;
    End Loop;
    If v_保险结算 Is Not Null Then
      v_保险结算 := Substr(v_保险结算, 3);
    End If;
  
    Select Decode(To_Char(d_原始时间, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   Null)
    Into v_星期
    From Dual;
    Begin
      Select ID
      Into n_计划id
      From (Select ID
             From 挂号安排计划
             Where 号码 = v_号码 And d_原始时间 Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select ID Into n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      --从计划读取信息
      Select a.项目id, b.科室id, a.医生姓名, a.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                     Null), Nvl(a.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排计划 A, 挂号安排 B
      Where a.Id = n_计划id And b.Id = a.安排id;
      Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位计划控制 Where 计划id = n_计划id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号计划时段
          Where 计划id = n_计划id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号计划时段
              Where 计划id = n_计划id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    Else
      --从安排读取信息
      Select b.项目id, b.科室id, b.医生姓名, b.医生id,
             Decode(To_Char(d_发生时间, 'D'), '1', b.周日, '2', b.周一, '3', b.周二, '4', b.周三, '5', b.周四, '6', b.周五, '7', b.周六,
                     Null), Nvl(b.序号控制, 0)
      Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, v_排班, n_序号控制
      From 挂号安排 B
      Where b.Id = n_安排id;
      Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
      --合作单位检查
      If v_合作单位 Is Not Null Then
        Begin
          Select 1 Into n_存在 From 合作单位安排控制 Where 安排id = n_安排id And 数量 = 0 And 合作单位 = v_合作单位;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;
      If n_存在 = 1 Then
        v_Err_Msg := '传入的合作单位在此号码上被禁用！';
        Raise Err_Item;
      End If;
      If n_分时段 = 1 And n_序号控制 = 0 Then
        d_发生时间 := d_原始时间;
        Select 序号
        Into n_号序
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi:ss') = To_Char(d_发生时间, 'hh24:mi:ss');
      Else
        Begin
          Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
          Into d_发生时间
          From 挂号安排时段
          Where 安排id = n_安排id And 星期 = v_星期 And 序号 = Nvl(n_号序, 0);
        Exception
          When Others Then
            If n_分时段 = 1 And n_序号控制 = 1 Then
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(Max(结束时间), 'hh24:mi:ss'),
                              'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 挂号安排时段
              Where 安排id = n_安排id And 星期 = v_星期;
            Else
              Select To_Date(To_Char(d_发生时间, 'yyyy-mm-dd') || '' || To_Char(开始时间, 'hh24:mi:ss'), 'YYYY-MM-DD hh24:mi:ss')
              Into d_发生时间
              From 时间段
              Where 时间段 = v_排班;
            End If;
            If d_发生时间 < d_登记时间 Then
              d_发生时间 := d_登记时间;
            End If;
        End;
      End If;
    End If;
  
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算方式, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, Null, Null, v_结算卡号, 1, v_费别, v_机器名, 1);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    For r_结算 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                        Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
      If r_结算.结算方式 Is Null Then
        Begin
          Select b.结算方式, b.Id
          Into v_结算方式, n_卡类别id
          From 医疗卡类别 B
          Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '没有发现该结算卡的相关信息';
            Raise Err_Item;
        End;
        v_结算内容 := v_结算内容 || '|' || v_结算方式 || ',' || r_结算.结算金额 || ',,';
      Else
        v_结算内容 := v_结算内容 || '|' || r_结算.结算方式 || ',' || r_结算.结算金额 || ',,';
      End If;
      If r_结算.结算卡类别 Is Not Null Then
        v_结算内容   := v_结算内容 || '1';
        v_卡类别名称 := r_结算.结算卡类别;
        v_结算卡号   := r_结算.结算卡号;
        v_流水号     := r_结算.交易流水号;
        v_说明       := r_结算.交易说明;
        If n_卡类别id Is Null Then
          Begin
            Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = r_结算.结算卡类别 And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '没有发现该结算卡的相关信息';
              Raise Err_Item;
          End;
        End If;
      Else
        v_结算内容 := v_结算内容 || '0';
      End If;
    End Loop;
    If v_结算内容 Is Not Null Then
      v_结算内容 := Substr(v_结算内容, 2);
    Else
      Begin
        Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
      Exception
        When Others Then
          v_现金 := '现金';
      End;
      v_结算内容 := v_现金 || ',' || 0 || ',,0';
    End If;
    Select 项目id, 科室id, 医生姓名, 医生id, 是否序号控制, 是否分时段
    Into n_收费细目id, n_病人科室id, v_医生姓名, n_医生id, n_序号控制, n_分时段
    From 临床出诊记录
    Where ID = n_记录id;
  
    Begin
      Select 开始时间 Into d_发生时间 From 临床出诊序号控制 Where 记录id = n_记录id And 序号 = n_号序;
    Exception
      When Others Then
        d_发生时间 := d_原始时间;
    End;
  
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
  
    If Trunc(d_发生时间) <> Trunc(Sysdate) Then
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(3, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, v_机器名,
                         1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, v_机器名,
                         1, 0, n_记录id);
      End If;
    Else
      If Nvl(n_缴款方式, 0) = 0 Then
        Zl_三方机构挂号_Insert(1, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, v_机器名,
                         1, 0, n_记录id);
      Else
        Zl_三方机构挂号_Insert(2, n_病人id, v_号码, n_号序, v_No, Null, v_结算内容, Null, d_发生时间, d_登记时间, v_合作单位, n_应收金额, Null, Null,
                         v_流水号, v_说明, v_预约方式, n_预交id, n_卡类别id, Null, 1, n_结帐id, 0, v_保险结算, Null, v_结算卡号, 1, v_费别, v_机器名,
                         1, 0, n_记录id);
      End If;
    End If;
  
    For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                          Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
    End Loop;
  
    v_Temp := '<GHDH>' || v_No || '</GHDH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    v_Temp := '<JZID>' || n_结帐id || '</JZID>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Regist;
/

--100429:刘尔旋,2016-09-06,结帐三方卡处理
Create Or Replace Procedure Zl_结帐预交记录_三方退款
(
  Id_In         病人预交记录.Id%Type,
  No_In         病人预交记录.No%Type,
  是否退现_In   Number,
  冲预交_In     病人预交记录.冲预交%Type,
  结帐id_In     病人结帐记录.Id%Type,
  病人id_In     病人预交记录.病人id%Type,
  操作员编号_In 病人预交记录.操作员编号%Type := Null,
  操作员姓名_In 病人预交记录.操作员姓名%Type := Null,
  收款时间_In   病人预交记录.收款时间%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  误差金额_In   病人预交记录.冲预交%Type := Null
) As
  -----------------------------------------------------------
  --功能：处理一行病人结帐时的冲预交记录
  --     冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
  --说明：ID_IN=空：表示冲历史余额预交记录
  -----------------------------------------------------------

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  n_返回值   病人余额.预交余额%Type;
  n_类别     病人预交记录.预交类别%Type;
  n_病人id   病人预交记录.病人id%Type;
  n_缴款组id 病人预交记录.缴款组id%Type;
  v_现金     结算方式.名称%Type;
  v_误差费   结算方式.名称%Type;

  Cursor c_Balance_Record Is
    Select Max(m.病人id) As 病人id, Max(NO) As NO, Max(实际票号) As 实际票号, Max(Nvl(收款时间_In, m.收费时间)) As 收款时间,
           Max(Nvl(操作员编号_In, m.操作员编号)) As 操作员编号, Max(Nvl(m.操作员姓名, 操作员姓名_In)) As 操作员姓名,
           Max(Nvl(n_缴款组id, m.缴款组id)) As 缴款组id, Max(结帐类型) As 结帐类型
    From 病人结帐记录 M
    Where m.Id = 结帐id_In;
  r_Balance_Record c_Balance_Record%RowType;

Begin
  If 操作员姓名_In Is Null Then
    n_缴款组id := Null;
  Else
    n_缴款组id := Zl_Get组id(操作员姓名_In);
  End If;

  Open c_Balance_Record;

  Fetch c_Balance_Record
    Into r_Balance_Record;

  If c_Balance_Record%RowCount = 0 Then
    v_Err_Msg := '未找到结帐记录,可能因为并发原因删除了结帐数据,无法继续退款!';
    Raise Err_Item;
  End If;

  If Id_In <> 0 Then
    --第一次冲预交
    Update 病人预交记录
    Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 2
    Where ID = Id_In
    Returning 预交类别 Into n_类别;
    If Nvl(n_类别, 0) = 0 Then
      n_类别 := 2;
    End If;
  End If;

  If 是否退现_In = 1 Then
    --冲上次剩余额
    Select 名称
    Into v_现金
    From (Select 名称 From 结算方式 Where 性质 = 1 Order By Nvl(缺省标志, 0) Desc, 编码)
    Where Rownum < 2;
  
    Begin
      Select 名称
      Into v_误差费
      From (Select 名称 From 结算方式 Where 性质 = 9 Order By Nvl(缺省标志, 0) Desc, 编码)
      Where Rownum < 2;
    Exception
      When Others Then
        v_误差费 := Null;
    End;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 冲预交_In
    Where 结算方式 = 结算方式_In And NO = No_In And 结帐id = 结帐id_In And 记录性质 = 11;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, 冲预交_In, 结帐id_In,
               r_Balance_Record.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 + (-1 * 冲预交_In) - Nvl(误差金额_In, 0)
    Where 结算方式 = v_现金 And 结帐id = 结帐id_In And Mod(记录性质, 10) = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, Null, v_现金, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, -1 * 冲预交_In - Nvl(误差金额_In, 0),
               结帐id_In, r_Balance_Record.缴款组id, 预交类别, Null, Null, Null, Null, 交易说明, 合作单位, 2
        From 病人预交记录
        Where 结帐id = 结帐id_In And Mod(记录性质, 10) = 2 And Rownum < 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, r_Balance_Record.No, r_Balance_Record.实际票号, 2, 1, 病人id, 主页id, 科室id, Null, v_现金, 结算号码,
                 摘要, 缴款单位, 单位开户行, 单位帐号, r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号,
                 -1 * 冲预交_In - Nvl(误差金额_In, 0), 结帐id_In, r_Balance_Record.缴款组id, Null, Null, Null, Null, Null, Null,
                 合作单位, 2
          From 病人预交记录
          Where 结帐id = 结帐id_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
      End If;
    End If;
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + (-1 * 冲预交_In) - Nvl(误差金额_In, 0)
    Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_现金 And 性质 = 1
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (r_Balance_Record.操作员姓名, v_现金, 1, -1 * 冲预交_In);
      n_返回值 := 冲预交_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_现金 And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  
    Begin
      Select 预交类别, 病人id
      Into n_类别, n_病人id
      From 病人预交记录
      Where NO = No_In And 记录性质 In (1, 11) And Rownum < 2;
    Exception
      When Others Then
        n_类别 := 2;
    End;
    n_病人id := Nvl(n_病人id, 病人id_In);
  
    --病人余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (n_病人id, 1, Nvl(n_类别, 2), -1 * 冲预交_In, 0);
      n_返回值 := -1 * 冲预交_In;
    End If;
  
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  
    If 误差金额_In Is Not Null And v_误差费 Is Not Null Then
      Update 病人预交记录
      Set 冲预交 = 冲预交 + Nvl(误差金额_In, 0)
      Where 结算方式 = v_误差费 And 结帐id = 结帐id_In And Mod(记录性质, 10) = 2;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, Null, v_误差费, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, Nvl(误差金额_In, 0), 结帐id_In,
                 r_Balance_Record.缴款组id, 预交类别, Null, Null, Null, Null, 交易说明, 合作单位, 2
          From 病人预交记录
          Where 结帐id = 结帐id_In And Mod(记录性质, 10) = 2 And Rownum < 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, r_Balance_Record.No, r_Balance_Record.实际票号, 2, 1, 病人id, 主页id, 科室id, Null, v_误差费,
                   结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号,
                   Nvl(误差金额_In, 0), 结帐id_In, r_Balance_Record.缴款组id, Null, Null, Null, Null, Null, Null, 合作单位, 2
            From 病人预交记录
            Where 结帐id = 结帐id_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
        End If;
      End If;
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(误差金额_In, 0)
      Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_误差费 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (r_Balance_Record.操作员姓名, v_误差费, 1, Nvl(误差金额_In, 0));
        n_返回值 := 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = r_Balance_Record.操作员姓名 And 结算方式 = v_误差费 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End If;
  Else
    --原样退
    Update 病人预交记录
    Set 冲预交 = 冲预交 + 冲预交_In
    Where 结算方式 = 结算方式_In And NO = No_In And 结帐id = 结帐id_In And 记录性质 = 11;
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 1, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, 冲预交_In, 结帐id_In,
               r_Balance_Record.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = 冲预交 - 冲预交_In
    Where 结算方式 = 结算方式_In And 结帐id = 结帐id_In And Mod(记录性质, 10) = 2;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, r_Balance_Record.No, r_Balance_Record.实际票号, 2, 1, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码,
               摘要, 缴款单位, 单位开户行, 单位帐号, r_Balance_Record.收款时间, r_Balance_Record.操作员姓名, r_Balance_Record.操作员编号, -1 * 冲预交_In,
               结帐id_In, r_Balance_Record.缴款组id, Null, 卡类别id, 结算卡序号, Null, Null, Null, 合作单位, 2
        From 病人预交记录
        Where NO = No_In And Substr(记录性质, Length(记录性质), 1) = 1 And Rownum < 2;
    End If;
    Begin
      Select 预交类别, 病人id
      Into n_类别, n_病人id
      From 病人预交记录
      Where NO = No_In And 记录性质 In (1, 11) And Rownum < 2;
    Exception
      When Others Then
        n_类别 := 2;
    End;
    n_病人id := Nvl(n_病人id, 病人id_In);
  
    --病人余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
    Where 病人id = n_病人id And 性质 = 1 And 类型 = n_类别
    Returning 预交余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额
        (病人id, 性质, 类型, 预交余额, 费用余额)
      Values
        (n_病人id, 1, Nvl(n_类别, 2), -1 * 冲预交_In, 0);
      n_返回值 := -1 * 冲预交_In;
    End If;
  
    If Nvl(n_返回值, 0) = 0 Then
      Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
    End If;
  End If;
  Close c_Balance_Record;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_结帐预交记录_三方退款;
/

--100191:梁经伙,2016-09-05,对 疾病阳性记录 表做数据转出处理
Create Or Replace Procedure Zl_Retu_Clinic
(
  n_Patiid In Number,
  v_Times  In Varchar2,
  n_Flag   In Number
) As
  --------------------------------------------
  --参数:n_Patiid,病人id
  --     v_Times,挂号单号或住院主页id（体检时，挂号单是体检单号）
  --     n_Flag,门诊或住院标志:0-门诊,1-住院,2-体检（此时，只有n_Patiid参数无效）
  --------------------------------------------
  Err_Item Exception;
  v_Err_Msg    Varchar2(100);
  n_System     Number(5);
  n_Opersystem Number(5);
  n_只读       Number(2);

  v_Table    Varchar2(100);
  v_Subtable Varchar2(100);
  v_Field    Varchar2(100);
  v_Subfield Varchar2(100);
  v_Sql      Varchar2(4000);
  v_Sqlchild Varchar2(4000);
  v_Fields   Varchar2(4000);

  --功能：获取表的字段字符串
  Function Getfields(v_Table In Varchar2) Return Varchar2 As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    Return v_Colstr;
  End Getfields;

  --------------------------------------------
  --返回指定病人ID和主页的相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Other
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  
  Begin
  
    For R In (Select Column_Value From Table(f_Str2list('病人过敏记录,病人诊断记录,病人手麻记录'))) Loop
      v_Table  := r.Column_Value;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    
      v_Sql := 'Delete From H' || v_Table || ' Where 病人id = :1 And 主页id = :2';
      Execute Immediate v_Sql
        Using n_Pati_Id, n_Page_Id;
    End Loop;
  End Zl_Retu_Other;

  --------------------------------------------
  --返回指定病人ID和主页的临床路径相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Path
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
    v_Table  := '病人临床路径';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    --病人路径医嘱，在病人医嘱记录转出之后执行
    For P In (Select ID As 路径记录id From H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人路径执行,病人合并路径,病人路径评估,病人路径变异,病人路径指标,病人合并路径评估,病人出径记录'))) Loop
        v_Table := r.Column_Value;
        If v_Table = '病人合并路径' Then
          v_Field := '首要路径记录id';
        Else
          v_Field := '路径记录id';
        End If;
      
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      
        v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
        Execute Immediate v_Sql
          Using p.路径记录id;
      End Loop;
    End Loop;
  
    Delete H病人临床路径 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Path;

  --------------------------------------------
  --返回指定病人ID和主页的护理相关表的子过程
  --------------------------------------------
  Procedure Zl_Retu_Tend
  (
    n_Pati_Id 病案主页.病人id%Type,
    n_Page_Id 病案主页.主页id%Type
  ) As
  Begin
  
    v_Table  := '病人护理文件';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID As 文件id From H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      For R In (Select Column_Value
                From Table(f_Str2list('病人护理数据,病人护理打印,病人护理活动项目,病人护理要素内容,产程要素内容'))) Loop
        v_Table  := r.Column_Value;
        v_Fields := Getfields(v_Table);
        v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                    Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      
        If v_Table = '病人护理数据' Then
          v_Fields := Getfields('病人护理明细');
          v_Sql    := 'Insert Into 病人护理明细(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                      ' From H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        
          v_Sql := 'Delete H病人护理明细 Where 记录id In (Select ID From H病人护理数据 Where 文件id = :1)';
          Execute Immediate v_Sql
            Using p.文件id;
        End If;
      
        v_Sql := 'Delete H' || v_Table || ' Where 文件id = :1';
        Execute Immediate v_Sql
          Using p.文件id;
      End Loop;
    End Loop;
  
    Delete H病人护理文件 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  
    --老版护理系统数据
    ------------------------------------------------------------------------
    v_Table  := '病人护理记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where 病人id = :1 And 主页id = :2 ';
    Execute Immediate v_Sql
      Using n_Pati_Id, n_Page_Id;
  
    For P In (Select ID From H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id) Loop
      v_Table  := '病人护理内容';
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    
      v_Sql := 'Delete H' || v_Table || ' Where 记录ID = :1';
      Execute Immediate v_Sql
        Using p.Id;
    End Loop;
  
    Delete H病人护理记录 Where 病人id = n_Pati_Id And 主页id = n_Page_Id;
  End Zl_Retu_Tend;

  --------------------------------------------
  --返回指定ID的病人新版电子病历记录子过程
  --------------------------------------------
  Procedure Zl_Retu_Epr(n_Rec_Id H电子病历记录.Id%Type) As
    v_Field Varchar(100);
  Begin
    v_Table  := '电子病历记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --病人诊断记录在Zl_Retu_Other中已转回（无病历ID外键）
    --影像报告驳回,病人医嘱报告,报告查阅记录,这几张表的数据在Zl_Retu_Order中转回医嘱后再处理
    For R In (Select Column_Value
              From Table(f_Str2list('电子病历附件,电子病历格式,电子病历内容,疾病申报记录,疾病报告反馈,疾病申报反馈'))) Loop
      v_Table := r.Column_Value;
      If v_Table = '电子病历附件' Then
        v_Field := '病历id';
      Else
        v_Field := '文件id';
      End If;
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    
      If v_Table = '电子病历内容' Then
        v_Fields := Getfields('电子病历图形');
        v_Sql    := 'Insert Into 电子病历图形(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = :1 And 对象类型 = 5)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H电子病历图形 Where 对象id In (Select ID From H电子病历内容 Where 文件id = n_Rec_Id And 对象类型 = 5);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    Delete H电子病历记录 Where ID = n_Rec_Id;
  End Zl_Retu_Epr;
  --------------------------------------------
  --返回指定ID的病人医嘱记录子过程，必须在病历、临床路径转出之后执行(病人医嘱报告,影像报告驳回，病人路径医嘱)
  --在Zl_Retu_Other中已转回了"病人诊断记录",转回"病人诊断医嘱"时不用再转
  --------------------------------------------
  Procedure Zl_Retu_Order(n_Rec_Id H病人医嘱记录.Id%Type) As
  Begin
    v_Table  := '病人医嘱记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where id = :1';
    Execute Immediate v_Sql
      Using n_Rec_Id;
  
    --以"医嘱ID,发送号"为外键的，都按医嘱ID直接转回，只需要排在"病人医嘱发送"之后即可
    --由于外键关系，"报告查阅记录"须在"病人医嘱报告"后面
    For P In (Select Column_Value
              From Table(f_Str2list('病人医嘱计价,病人医嘱状态,病人医嘱发送,病人医嘱附费,病人医嘱附件,病人医嘱执行,病人医嘱打印,输血申请记录,输血检验结果,' ||
                                     '医嘱执行打印,医嘱执行时间,医嘱执行计价,执行打印记录,病人诊断医嘱,病人路径医嘱,病人医嘱报告,报告查阅记录,' ||
                                     '影像报告驳回,影像报告记录,影像报告操作记录,影像检查记录,影像申请单图像,影像收藏内容,影像危急值记录,检验标本记录,检验试剂记录,检验拒收记录,疾病阳性记录'))) Loop
      v_Table := p.Column_Value;
      If Instr('病人路径医嘱', v_Table) > 0 Then
        v_Field := '病人医嘱ID';
      Else
        v_Field := '医嘱ID';
      End If;
    
      v_Fields := Getfields(v_Table);
      v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' ||
                  Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Table || ' Where ' || v_Field || ' = :1';
      If v_Table = '病人医嘱状态' Then
        v_Sqlchild := v_Sql;
      Else
        Execute Immediate v_Sql
          Using n_Rec_Id;
      End If;
    
      If v_Table = '病人医嘱状态' Then
        v_Fields := Getfields('医嘱签名记录');
        v_Sql    := 'Insert Into 医嘱签名记录(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H医嘱签名记录 Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = :1 And 签名id Is Not Null)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H医嘱签名记录
        Where ID In (Select 签名id From H病人医嘱状态 Where 医嘱id = n_Rec_Id And 签名id Is Not Null);
      
        Execute Immediate v_Sqlchild
          Using n_Rec_Id;
      
      Elsif v_Table = '病人医嘱发送' Then
        v_Fields := Getfields('诊疗单据打印');
        v_Sql    := 'Insert Into 诊疗单据打印(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
        Delete H诊疗单据打印 Where (NO, 记录性质) In (Select NO, 记录性质 From H病人医嘱发送 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '影像检查记录' Then
        v_Fields := Getfields('影像检查序列');
        v_Sql    := 'Insert Into 影像检查序列(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('影像检查图象');
        v_Sql    := 'Insert Into 影像检查图象(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H影像检查图象 Where 序列uid In (Select b.序列uid From H影像检查记录 A, H影像检查序列 B Where a.医嘱id = :1 And a.检查uid = b.检查uid)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H影像检查图象
        Where 序列uid In (Select b.序列uid
                        From H影像检查记录 A, H影像检查序列 B
                        Where a.医嘱id = n_Rec_Id And a.检查uid = b.检查uid);
        Delete H影像检查序列 Where 检查uid In (Select 检查uid From H影像检查记录 Where 医嘱id = n_Rec_Id);
      
      Elsif v_Table = '检验标本记录' Then
        For R In (Select Column_Value
                  From Table(f_Str2list('检验申请项目,检验分析记录,检验项目分布,检验质控记录,检验操作记录,检验签名记录,检验图像结果'))) Loop
          v_Subtable := r.Column_Value;
          If v_Subtable = '检验签名记录' Then
            v_Subfield := '检验标本ID';
          Else
            v_Subfield := '标本ID';
          End If;
          v_Fields := Getfields(v_Subtable);
          v_Sql    := 'Insert Into ' || v_Subtable || '(' || v_Fields || ') Select ' ||
                      Replace(v_Fields, '待转出', 'Null as 待转出') || ' From H' || v_Subtable || ' Where ' || v_Subfield ||
                      ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        
          v_Sql := 'Delete H' || v_Subtable || ' Where ' || v_Subfield ||
                   ' In (Select ID From H检验标本记录 Where 医嘱id = :1)';
          Execute Immediate v_Sql
            Using n_Rec_Id;
        End Loop;
      
        v_Fields := Getfields('检验普通结果');
        v_Sql    := 'Insert Into 检验普通结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1)';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验药敏结果');
        v_Sql    := 'Insert Into 检验药敏结果(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验药敏结果 Where 细菌结果id In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        v_Fields := Getfields('检验质控报告');
        v_Sql    := 'Insert Into 检验质控报告(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                    ' From H检验质控报告 Where 结果ID In (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = :1))';
        Execute Immediate v_Sql
          Using n_Rec_Id;
      
        Delete H检验药敏结果
        Where 细菌结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
        Delete H检验质控报告
        Where 结果id In
              (Select ID From H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id));
      
        Delete H检验普通结果 Where 检验标本id In (Select ID From H检验标本记录 Where 医嘱id = n_Rec_Id);
      End If;
    
      v_Sql := 'Delete H' || v_Table || ' Where ' || v_Field || ' = :1';
      Execute Immediate v_Sql
        Using n_Rec_Id;
    End Loop;
  
    --手麻数据
    If n_Opersystem > 0 Then
      Execute Immediate 'Call zl24_Retu_Oper(:1)'
        Using n_Rec_Id;
    End If;
  
    Delete H病人医嘱记录 Where ID = n_Rec_Id;
  End Zl_Retu_Order;

  --------------------------------------------
  --以下为主程序体
  --------------------------------------------
Begin
  ----------------------------------------------------------------------------------------------------------
  --对基于视图的转储方案进行了只读判断.
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '1%';
  Begin
    Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_System And 当前 = 1;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]当前没有可用的历史数据空间,不能继续![ZLSOFT]';
      Raise Err_Item;
  End;
  If n_只读 = 1 Then
    v_Err_Msg := '[ZLSOFT]历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
    Raise Err_Item;
  End If;

  --对基于视图的转储方案进行了只读判断.
  n_Opersystem := 0;
  Select 编号 Into n_Opersystem From zlSystems Where Upper(所有者) = Zl_Owner And 编号 Like '24%';
  If n_Opersystem > 0 Then
    Begin
      Select Nvl(只读, 0) Into n_只读 From zlBakSpaces Where 系统 = n_Opersystem And 当前 = 1;
    Exception
      When Others Then
        v_Err_Msg := '[ZLSOFT]当前没有可用的手麻子系统历史数据空间,不能继续![ZLSOFT]';
        Raise Err_Item;
    End;
    If n_只读 = 1 Then
      v_Err_Msg := '[ZLSOFT]手麻子系统历史数据空间目前的状态为只读,不能继续![ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --1.门诊病人，按挂号单抽回
  If n_Flag = 0 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid, 8);
  
    v_Table  := '病人挂号记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1 ';
    Execute Immediate v_Sql
      Using v_Times;
  
    For r_Other In (Select ID, 病人id From H病人挂号记录 Where NO = v_Times) Loop
      Zl_Retu_Other(r_Other.病人id, r_Other.Id);
    End Loop;
  
    For r_Epr In (Select /*+ Rule*/
                   b.Id
                  From H病人挂号记录 A, H电子病历记录 B
                  Where a.No = v_Times And a.病人id = n_Patiid And b.病人id = a.病人id And b.主页id = a.Id) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人来源 <> 4 And 病人id = n_Patiid And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
  
    --转诊记录
    v_Table  := '病人转诊记录';
    v_Fields := Getfields(v_Table);
    v_Sql    := 'Insert Into ' || v_Table || '(' || v_Fields || ') Select ' || Replace(v_Fields, '待转出', 'Null as 待转出') ||
                ' From H' || v_Table || ' Where NO =:1';
    Execute Immediate v_Sql
      Using v_Times;
  
    Delete H病人转诊记录 Where NO = v_Times;
    Delete H病人挂号记录 Where NO = v_Times;
  
    --2.住院病人，按病人ID和主页ID抽回
  Elsif n_Flag = 1 Then
    --抽回未结记帐费用
    Zl_Retu_Exes(n_Patiid || ',' || v_Times, 8);
  
    Zl_Retu_Other(n_Patiid, To_Number(v_Times));
    Zl_Retu_Path(n_Patiid, To_Number(v_Times));
  
    --先转病历，再转医嘱（影像报告驳回，病人医嘱报告这类又有病历又有医嘱的子表，在医嘱转回后处理）
    For r_Epr In (Select ID From H电子病历记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Epr(r_Epr.Id);
    End Loop;
  
    Zl_Retu_Tend(n_Patiid, To_Number(v_Times));
  
    For r_Order In (Select ID From H病人医嘱记录 Where 病人id = n_Patiid And 主页id = To_Number(v_Times)) Loop
      Zl_Retu_Order(r_Order.Id);
    End Loop;
    Update 病案主页 Set 数据转出 = 0 Where 病人id = n_Patiid And 主页id = To_Number(v_Times);
  
    --3.体检病人
  Elsif n_Flag = 2 Then
    Zl_Retu_Other(n_Patiid, v_Times);
  
    For r_Cpr In (Select ID From H病人医嘱记录 Where 病人来源 = 4 And 挂号单 = v_Times) Loop
      Zl_Retu_Order(r_Cpr.Id);
    End Loop;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM || ':' || v_Sql);
End Zl_Retu_Clinic;
/

--99778:刘尔旋,2016-09-02,销帐申请可申请数量计算问题
Create Or Replace Procedure Zl_病人费用销帐_Insert
(
  Id_In         病人费用销帐.费用id%Type,
  收费细目id_In 病人费用销帐.收费细目id%Type,
  申请部门id_In 病人费用销帐.申请部门id%Type,
  数量_In       病人费用销帐.数量%Type,
  申请人_In     病人费用销帐.申请人%Type,
  申请时间_In   病人费用销帐.申请时间%Type,
  申请类别_In   病人费用销帐.申请类别%Type, --对药品和卫材有效:0-未发药(料);1-已发药(料);其他为0
  删除标志_In   Integer := 0, --删除病人费用销帐时的条件:1-删除时不管申请类别,0-删除时,根据申请类别来进行删除(因为可能出现在申请销帐时,存在已执行和未执行两种状态)
  配药id_In     Integer := 0
) As
  n_审核部门id   病人费用销帐.审核部门id%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  n_开单科室病区 病人费用销帐.审核部门id%Type;
  n_执行科室病区 病人费用销帐.审核部门id%Type;
  n_跟踪在用     材料特性.跟踪在用%Type;
  n_执行状态     住院费用记录.执行状态%Type;
  v_收费类别     住院费用记录.收费类别%Type;
  n_实际数量     药品收发记录.实际数量%Type;
  n_医嘱id       住院费用记录.Id%Type;
  n_主页id       住院费用记录.Id%Type;
  v_No           住院费用记录.No%Type;
  n_病人id       住院费用记录.病人id%Type;
  n_病人科室id   住院费用记录.病人科室id%Type;
  n_Icu科室id    住院费用记录.病人科室id%Type;
  n_已申请数量   药品收发记录.实际数量%Type;
  n_序号         住院费用记录.序号%Type;

  n_Temp    Number;
  n_Icu     Number;
  n_Cnt     Number;
  v_Err_Msg Varchar2(500);
  Err_Item Exception;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

Begin
  Begin
    Select Count(1)
    Into n_Cnt
    From 住院费用记录 A, 住院费用记录 B
    Where a.No = b.No And Mod(a.记录性质, 10) = Mod(b.记录性质, 10) And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And b.Id = Id_In
    Group By a.No, Mod(a.记录性质, 10), Nvl(a.价格父号, a.序号)
    Having Nvl(Sum(a.结帐金额), 0) <> 0;
  Exception
    When Others Then
      n_Cnt := 0;
  End;
  If n_Cnt > 0 Then
    v_Err_Msg := '申请销帐的记录已被他人结帐';
    Raise Err_Item;
  End If;

  Select a.收费类别, a.No, Nvl(b.跟踪在用, 0), Decode(Nvl(申请类别_In, 0), 0, a.病人病区id, a.执行部门id), 医嘱序号, 病人id, Nvl(主页id, 0), 序号
  Into v_收费类别, v_No, n_跟踪在用, n_审核部门id, n_医嘱id, n_病人id, n_主页id, n_序号
  From 住院费用记录 A, 材料特性 B
  Where a.收费细目id = b.材料id(+) And a.Id = Id_In;

  If Nvl(n_主页id, 0) <> 0 Then
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(n_主页id, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
  End If;

  Select 出院科室id
  Into n_病人科室id
  From 病人信息 A, 病案主页 B
  Where a.病人id = b.病人id And a.主页ID = b.主页id And a.病人id = n_病人id;

  Select Decode(Count(*), 0, 0, 1) Into n_Icu From 部门性质说明 B Where b.部门id = n_病人科室id And b.工作性质 = 'ICU';
  If n_Icu = 1 Then
    --检查是否是当前操作员属性于ICU
    Select Decode(Count(Distinct a.用户名), 0, 0, 1)
    Into n_Icu
    From 上机人员表 A, 部门性质说明 B, 部门人员 C
    Where a.用户名 = User And a.人员id = c.人员id And c.部门id = b.部门id And b.工作性质 = 'ICU';
  End If;

  If n_Icu = 1 Then
    n_Icu科室id := n_病人科室id;
    If Nvl(申请类别_In, 0) = 0 Then
      n_审核部门id := n_病人科室id;
    End If;
  End If;

  If Instr(',5,6,7', ',' || v_收费类别) > 0 Or v_收费类别 = '4' And Nvl(n_跟踪在用, 0) = 1 Then
    n_申请类别 := 申请类别_In;
  Else
    n_申请类别 := 0;
  End If;

  --取消以前申请的重新生成(按批次申请时，不能取消，因为费用id相同，每个批次可分别申请)
  If 配药id_In = 0 Then
    If Nvl(删除标志_In, 0) = 1 Then
      Delete 病人费用销帐 Where 费用id = Id_In And 状态 = 0;
    Else
      Delete 病人费用销帐 Where 费用id = Id_In And 申请类别 = n_申请类别 And 状态 = 0;
    End If;
  End If;
  If 数量_In <> 0 Then
    --审核科室
    --1.药品费用或跟踪在用的卫材:
    --    a. 如果未执行,则按病人病区作为审核部门;
    --    b. 如果已执行,则按执行部门ID作为审核部门
    --2.医技科室开单的费用(即开单科室<>病人科室)，销帐审核科室为开单科室,
    --  如果开单科室是属于病区的临床科室,则销帐科室为所属病区(即护士记病人在其它科室发生的费用)
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --3.病区产生的费用,没有经过划价审核的,销帐审核科室为病人病区(如果已经被执行，则为执行部门,否则为病人病区)
    --  经过划价审核的,销帐审核科室为执行科室。
    --  如果执行科室是属于病区的临床科室，则销帐审核科室为所属病区
    --  (如果执行科室x属于a、b两病区，则a、b两病区都可以作为销帐确认科室,取第一个，如果a病区同时是病人病区，则只有a病区能确认)。
    --4.如果当前操作员是属于ICU,并且病人当前科室也为ICU以及未执行的项目,由ICU科室来来进行审核.
  
    If Nvl(n_跟踪在用, 0) = 1 Then
      If Nvl(申请类别_In, 0) = 0 Then
        --要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And instr( ',8,9,10,21,24,25,26,',','||单据||',')>0;
      
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中卫材料为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')大于了待发料数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    Else
      --a.执行科室或其所属病区:：0:未执行;1:完全执行;2:部份执行
      Select Decode(b.病区id, Null, a.执行部门id, Nvl(c.病区id, b.病区id)), Decode(a.执行状态, 1, 1, 2, 1, 0)
      Into n_执行科室病区, n_执行状态
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.执行部门id = b.科室id(+) And a.执行部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      --b.开单科室或其所属病区
      Select Decode(b.病区id, Null, a.开单部门id, Nvl(c.病区id, b.病区id))
      Into n_开单科室病区
      From 住院费用记录 A, 病区科室对应 B, 病区科室对应 C
      Where a.Id = Id_In And a.开单部门id = b.科室id(+) And a.开单部门id = c.科室id(+) And a.病人病区id = c.病区id(+) And Rownum < 2;
    
      For v_费用 In (Select 收费类别, Nvl(执行状态, 0) As 执行状态, 病人病区id, 执行部门id, 开单部门id, 病人科室id, 划价人, 操作员姓名
                   From 住院费用记录
                   Where ID = Id_In) Loop
        If Instr('567', v_费用.收费类别, 1) > 0 Then
          n_Temp       := Case
                            When 申请类别_In Is Null Then
                             Nvl(v_费用.执行状态, 0)
                            Else
                             申请类别_In
                          End;
          n_审核部门id := Case
                        When n_Temp = 0 Then
                         v_费用.病人病区id
                        Else
                         v_费用.执行部门id
                      End;
          If n_Temp = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        Else
          If v_费用.开单部门id = v_费用.病人科室id Then
            --临床产生的费用
            If Nvl(v_费用.划价人, '-') = v_费用.操作员姓名 Or v_费用.划价人 Is Null Then
              --划价审核
              n_审核部门id := Case
                            When n_执行状态 = 1 Then
                             v_费用.执行部门id
                            Else
                             v_费用.病人病区id
                          End;
            Else
              n_审核部门id := n_执行科室病区;
            End If;
          Else
            n_审核部门id := n_执行科室病区;
          End If;
          If n_执行状态 = 0 And n_Icu = 1 Then
            --ICU为ICU科室
            n_审核部门id := n_Icu科室id;
          End If;
        End If;
      End Loop;
    
      If Instr(',5,6,7', ',' || v_收费类别) > 0 And Nvl(申请类别_In, Nvl(n_执行状态, 0)) = 0 Then
        --需要检查未执行的数量必须大于等于申请数量,才会通过
        Select Sum(Nvl(付数, 0) * Nvl(实际数量, 0))
        Into n_实际数量
        From 药品收发记录
        Where 审核日期 Is Null And 费用id = Id_In And instr( ',8,9,10,21,24,25,26,',','||单据||',')>0;
        If Nvl(n_实际数量, 0) < Nvl(数量_In, 0) Then
          Select '在单据号<<' || v_No || '>>中药品为:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
                  LTrim(To_Char(数量_In, '9999999990.99')) || ')不能大于待发药数量(' ||
                  LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
          Into v_Err_Msg
          From 收费项目目录
          Where ID = 收费细目id_In;
          Raise Err_Item;
        End If;
      End If;
    End If;
    --解决并发问题:当前申请数量+已经申请数量不能大于某笔申请数量
    Select Sum(Nvl(数量, 0)) Into n_已申请数量 From 病人费用销帐 Where 费用id = Id_In And Nvl(状态,0) <> 2;
    Select Sum(Nvl(付数, 1) * Nvl(数次, 0))
    Into n_实际数量
    From 住院费用记录
    Where NO = v_No And 序号 = n_序号 And Nvl(价格父号, 0) = 0 And 记录状态 In (0,1, 3) And
          记录性质 In (Select 记录性质 From 住院费用记录 Where ID = Id_In);
    If Nvl(n_实际数量, 0) < Nvl(n_已申请数量, 0) + Nvl(数量_In, 0) Then
      Select '在单据号<<' || v_No || '>>收费项目:' || Chr(13) || 编码 || '-' || 名称 || Chr(13) || '的申请数量(' ||
              LTrim(To_Char(Nvl(n_已申请数量, 0) + Nvl(数量_In, 0), '9999999990.99')) || ')不能大于记帐数量(' ||
              LTrim(To_Char(Nvl(n_实际数量, 0), '9999999990.99')) || '),不能进行申请销帐!'
      Into v_Err_Msg
      From 收费项目目录
      Where ID = 收费细目id_In;
      Raise Err_Item;
    End If;
  
    If n_医嘱id <> 0 And 配药id_In <> 0 Then
      --如果是输液配药中心的，则更新相关表字段
      select count(1) into n_Temp from 输液配药状态 where 配药ID=配药id_In and 操作类型=9 and 操作时间=申请时间_In;
      if n_Temp=0 then
         Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (配药id_In, 9, 申请人_In, 申请时间_In);
      end if;
      Update 输液配药记录
      Set 操作人员 = 申请人_In, 操作时间 = 申请时间_In,操作状态=9
      Where ID = 配药id_In
      Returning 部门id Into n_审核部门id;
    End If;
    Insert Into 病人费用销帐
      (费用id, 申请类别, 收费细目id, 审核部门id, 申请部门id, 数量, 申请人, 申请时间, 状态)
    Values
      (Id_In, n_申请类别, 收费细目id_In, n_审核部门id, 申请部门id_In, 数量_In, 申请人_In, 申请时间_In, 0);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人费用销帐_Insert;
/

--100306:冉俊明,2016-09-02,调整单据号按年顺序编号补全规则
Create Or Replace Function Fullno
(
  序号_In     In 号码控制表.项目序号%Type,
  No_In       In 号码控制表.最大号码%Type,
  科室id_In   In 部门表.Id%Type := Null,
  Tag_In      In Varchar2 := Null,
  号码个数_In In Integer := 1
) Return Varchar2
--    功能：根据特定规则和输入号码补全号码,规则如下：
  --    一、项目序号：
  --       1   病人ID         数字
  --       2   住院号         数字
  --       3   门诊号         数字
  --       10  医嘱发送号     数字
  --       x   其它单据号     字符
  --    二、No：
  --       输入序号码
  --    三、年度位确定原则：
  --       以1990为基数，随年度增长，按“0～9/A～Z”顺序作为年度编码
  --
  --    说明：1、参数类型和意义按NextNo函数中定义，使其保持一致
  --          2、输入No号长度大于号码组成规则中顺序号的长度则不处理，直接返回
  --
  --    返回：补全后的号码
 Is
  v_No     号码控制表.最大号码%Type;
  n_Mod    号码控制表.编号规则%Type;
  v_Tmp    Varchar2(10);
  v_Year   Varchar2(1);
  v_Deptno Varchar2(20);

  v_Error Varchar2(255);
  Err_Custom Exception;

  --按特定日期格式串构造字符编码
  Function Getdateno
  (
    No_In    In 号码控制表.最大号码%Type,
    Type_In  In Varchar2,
    Count_In In Integer
  ) Return Varchar2
  --
    -- Type_In  日期格式串
    -- Count_In 输入编码格式位数
   Is
    v_Tmp Varchar2(10);
  Begin
    v_Tmp := To_Char(Sysdate, Type_In);
    Return v_Tmp || LPad(No_In, Count_In, '0');
  End Getdateno;
Begin
  --数据检查
  Begin
    Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
  Exception
    When Others Then
      v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码！';
      Raise Err_Custom;
  End;

  --1.病人ID
  If 序号_In = 1 Then
    v_No := No_In;
  
    --2.住院号
  Elsif 序号_In = 2 Then
    If n_Mod = 0 Then
      --0.顺序编号
      v_No := No_In;
    Elsif n_Mod = 1 Then
      --1.年月+顺序号:YYMM0000
      If Length(No_In) > 8 Then
        v_No := No_In;
      Elsif Length(No_In) > 6 Then
        v_No := Substr(To_Char(Sysdate, 'YY'), 1, 8 - Length(No_In)) || No_In;
      Elsif Length(No_In) > 4 Then
        v_No := Getdateno(No_In, 'YY', 6);
      Else
        v_No := Getdateno(No_In, 'YYMM', 4);
      End If;
    Elsif n_Mod = 2 Then
      --2.年+顺序号:YYYY00000
      If Length(No_In) > 9 Then
        v_No := No_In;
      Elsif Length(No_In) > 5 Then
        v_No := Substr(To_Char(Sysdate, 'YYYY'), 1, 9 - Length(No_In)) || No_In;
      Else
        v_No := Getdateno(No_In, 'YYYY', 5);
      End If;
    End If;
  
    --3.门诊号
  Elsif 序号_In = 3 Then
    --处理规则用户自定义
    v_No := Zl1_Clinicno_Full(No_In, n_Mod);
  
    --10.医嘱发送号
  Elsif 序号_In = 10 Then
    v_No := No_In;
  
    --汇总发药号
  Elsif 序号_In = 20 Then
    --年月日+5位顺序号:YYYYMMDD00000
    If Length(No_In) > 13 Then
      v_No := No_In;
    Elsif Length(No_In) > 9 Then
      v_No := Substr(To_Char(Sysdate, 'YYYY'), 1, 13 - Length(No_In)) || No_In;
    Elsif Length(No_In) > 7 Then
      v_No := Getdateno(No_In, 'YYYY', 9);
    Elsif Length(No_In) > 5 Then
      v_No := Getdateno(No_In, 'YYYYMM', 7);
    Else
      v_No := Getdateno(No_In, 'YYYYMMDD', 5);
    End If;
  
    --影像检查号
  Elsif 序号_In = 123 Then
    v_No := No_In;
  
  Elsif 序号_In = 124 Then
    v_No := No_In;
  
    --检验条码
  Elsif 序号_In = 125 Then
    v_No := No_In;
  
    --卫材条码序号
  Elsif 序号_In = 126 Then
    --12位顺序号:000000000000
    If Length(No_In) > 12 Then
      v_No := No_In;
    Else
      v_No := LPad(No_In, 12, '0');
    End If;
  
    --药品卫材调价
  Elsif 序号_In = 135 Then
    --1.年月+顺序号:YYYYMM0000
    If Length(No_In) > 10 Then
      v_No := No_In;
    Elsif Length(No_In) > 6 Then
      v_No := Substr(To_Char(Sysdate, 'YYYY'), 1, 10 - Length(No_In)) || No_In;
    Elsif Length(No_In) > 4 Then
      v_No := Getdateno(No_In, 'YYYY', 6);
    Else
      v_No := Getdateno(No_In, 'YYYYMM', 4);
    End If;
  
    --瓶签号
  Elsif 序号_In = 136 Then
    --YYMMDD+5位顺序号:YYMMDD00000
    If Length(No_In) > 11 Then
      v_No := No_In;
    Elsif Length(No_In) > 9 Then
      v_No := Substr(To_Char(Sysdate, 'YY'), 1, 11 - Length(No_In)) || No_In;
    Elsif Length(No_In) > 7 Then
      v_No := Getdateno(No_In, 'YY', 9);
    Elsif Length(No_In) > 5 Then
      v_No := Getdateno(No_In, 'YYMM', 7);
    Else
      v_No := Getdateno(No_In, 'YYMMDD', 5);
    End If;
  
  Elsif 序号_In = 131 Then
    --体检报到号
    v_No := No_In;
  
    --其它单据号
  Else
    --如果规则是按科室编号顺序产生，但又未设置科室编码，则采取按年顺序编号
    If n_Mod = 2 And 序号_In <> 122 Then
      Begin
        Select 编号 Into v_Deptno From 科室号码表 Where 科室id = 科室id_In And 项目序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      If v_Deptno Is Null Then
        n_Mod := 0;
      End If;
    End If;
    --获得年编码
    Select Decode(Sign(Intyear - 10), -1, To_Char(Intyear, '9'), Chr(55 + Intyear))
    Into v_Year
    From (Select To_Number(To_Char(Sysdate, 'yyyy'), '9999') - 1990 As Intyear From Dual);
  
    If n_Mod = 0 Then
      --0.按年顺序编号
      --补全规则如下:
      --1.如果传入的号码长度大于等于8位，则原样返回
      --2.如果传入的号码长度小于8位，则
      --2.1.如果号码第一位为非数字，则在字符和数字之间补0，使其达到8位长度，如：传入D1，则返回D0000001；传入D323，则返回D0000323
      --2.2.其它，则从号码控制表中的最大号码中取前(8-传入号码长度)位补到传入号码前面，如：最大号码为Q7863409，传入256，则返回Q7863256
      If Length(No_In) >= 8 Then
        v_No := No_In;
      Else
        If Instr('0123456789', Substr(No_In, 1, 1)) = 0 Then
          v_No := Substr(No_In, 1, 1) || LPad(Substr(No_In, 2), 7, '0');
        Else
          Select Nvl(最大号码, '1') Into v_No From 号码控制表 Where 项目序号 = 序号_In;
          v_No := Substr(v_No, 1, 8 - Length(No_In)) || No_In;
        End If;
      End If;
    Elsif n_Mod = 1 Then
      --1.按年+日顺序编号:YDDD0000
      If Length(No_In) > 8 Then
        v_No := No_In;
      Elsif Length(No_In) > 4 Then
        v_No := v_Year || LPad(No_In, 7, '0');
      Else
        v_No := v_Year || LPad(Trunc(Sysdate - Trunc(Sysdate, 'YYYY') + 1, 0), 3, '0') || LPad(No_In, 4, '0');
      End If;
    Elsif n_Mod = 2 Then
      If 序号_In = 122 Then
        --2.按科室编码+YYMMDD+3位顺序号:2201090728001
        Select 编码 Into v_Deptno From 部门表 Where ID = 科室id_In;
        If Length(No_In) > 9 Then
          v_No := No_In;
        Elsif Length(No_In) > 7 Then
          v_No := v_Deptno || LPad(No_In, 9, '0');
        Elsif Length(No_In) > 5 Then
          v_No := v_Deptno || Getdateno(No_In, 'YY', 7);
        Elsif Length(No_In) > 3 Then
          v_No := v_Deptno || Getdateno(No_In, 'YYMM', 5);
        Else
          v_No := v_Deptno || Getdateno(No_In, 'YYMMDD', 3);
        End If;
      Else
        --2.按年+科室编号+月+顺序号:YKDD0000
        Begin
          Select 编号 Into v_Deptno From 科室号码表 Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0);
        Exception
          When Others Then
            Null;
        End;
        If v_Deptno Is Null Then
          v_Error := '科室未设置编号，无法补全号码！';
          Raise Err_Custom;
        Else
          If Length(No_In) > 7 Then
            v_No := No_In;
          Elsif Length(No_In) > 6 Then
            v_No := v_Year || LPad(No_In, 7, '0');
          Elsif Length(No_In) > 4 Then
            v_No := v_Year || v_Deptno || LPad(No_In, 6, '0');
          Else
            v_Tmp := To_Char(Sysdate, 'MM');
            v_No  := v_Year || v_Deptno || v_Tmp || LPad(No_In, 4, '0');
          End If;
        End If;
      End If;
    Elsif n_Mod = 3 Then
      --按年月日+顺序号:YYMMDD000000
      If Length(No_In) > 12 Then
        v_No := No_In;
      Elsif Length(No_In) > 10 Then
        v_No := Substr(To_Char(Sysdate, 'YY'), 1, 12 - Length(No_In)) || No_In;
      Elsif Length(No_In) > 8 Then
        v_No := Getdateno(No_In, 'YY', 10);
      Elsif Length(No_In) > 6 Then
        v_No := Getdateno(No_In, 'YYMM', 8);
      Else
        v_No := Getdateno(No_In, 'YYMMDD', 6);
      End If;
    Elsif n_Mod = 5 Then
      --1.年月(YYYYMM)+顺序号:YYYYMM000000
      If Length(No_In) > 12 Then
        v_No := No_In;
      Elsif Length(No_In) > 8 Then
        v_No := Substr(To_Char(Sysdate, 'YYYY'), 1, 12 - Length(No_In)) || No_In;
      Elsif Length(No_In) > 6 Then
        v_No := Getdateno(No_In, 'YYYY', 8);
      Else
        v_No := Getdateno(No_In, 'YYYYMM', 6);
      End If;
    Else
      v_Error := '序号为' || 序号_In || '的号码,其规则值:' || n_Mod || ',当前系统不支持！';
      Raise Err_Custom;
    End If;
  End If;
  Return v_No;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Fullno;
/

--100173:刘尔旋,2016-09-01,门诊转住院费用执行时间问题
Create Or Replace Procedure Zl_门诊费用转住院_Insert
(
  No_In         住院费用记录.No%Type,
  住院号_In     住院费用记录.标识号%Type, --医保入院补充登记时才传入
  主页id_In     住院费用记录.主页id%Type, --医保入院补充登记时才传入
  入院时间_In   住院费用记录.发生时间%Type,
  入院科室id_In 病人预交记录.科室id%Type,
  退费时间_In   住院费用记录.登记时间%Type, --多张单据退费时,每张单据的退费时间相同,都是系统当前时间
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  入院病区id_In 住院费用记录.病人病区id%Type := Null,
  单据_In       Number := 1,
  结帐id_In     住院费用记录.结帐id%Type := Null,
  原结帐id_In   住院费用记录.结帐id%Type := Null
) As
  --单据_In:1-门诊收费单;2-记帐单
  v_Billno   住院费用记录.No%Type;
  n_实收合计 住院费用记录.实收金额%Type;
  n_返回值   病人余额.预交余额%Type;

  n_病区id     住院费用记录.病人病区id%Type;
  v_床号       住院费用记录.床号%Type;
  n_医疗小组id 住院费用记录.医疗小组id%Type;

  n_开单部门id     部门表.Id%Type;
  n_操作员编号     门诊费用记录.操作员编号%Type;
  v_操作员姓名     门诊费用记录.操作员姓名%Type;
  v_开单人         人员表.姓名%Type;
  n_病人id         病人信息.病人id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_立即销帐       Number(2);
  v_Nos            Varchar2(3000);
  n_结帐id         门诊费用记录.结帐id%Type;
  v_Err_Msg        Varchar2(255);
  n_组id           财务缴款分组.Id%Type;
  Err_Item Exception;
  n_Count Number(18);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  If Nvl(主页id_In, 0) <> 0 Then
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 病人id
        Into n_病人id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And Rownum = 1;
      Exception
        When Others Then
          n_病人id := 0;
      End;
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(n_病人id, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  -- n_门诊转住院先审核 := Zl_To_Number(Zl_Getsysparameter('门诊转住院先审核', 1143));
  n_立即销帐 := Zl_To_Number(zl_GetSysParameter('费用转出立即退费', 1131));

  If 原结帐id_In Is Null Then
    If Nvl(n_立即销帐, 0) = 1 Then
      If Mod(单据_In, 10) = 1 Then
        --转收费单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In,门诊退费_In(0-门诊转住院立即销帐;1-门诊退费模式),入院科室id_In,主页id_In
        Zl_门诊转住院_收费转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id);
      Else
        --转记帐单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In
        Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
      End If;
    End If;
    --规则
    -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
    -- 2.主页id_In<>0 :
    If Nvl(入院病区id_In, 0) <> 0 Then
      n_病区id := 入院病区id_In;
    Elsif Nvl(主页id_In, 0) <> 0 Then
      Begin
        Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
        Into n_病区id, v_床号
        From 病人信息 A, 病案主页 B
        Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
      Exception
        When Others Then
          n_病区id := Null;
      End;
    End If;
  
    If Nvl(n_病区id, 0) = 0 Then
      --以入院科室为准
      n_病区id := Nvl(入院科室id_In, 0);
    End If;
  
    --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
    --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
    Select 病人id, 开单部门id, 开单人
    Into n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;
  
    --5.产生记帐单
    --需要检查是否已经转出
    Select Count(*)
    Into n_Count
    From 门诊费用记录 A
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
     (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
    If n_Count >= 1 Then
      v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
      Raise Err_Item;
    End If;
    If Mod(单据_In, 10) = 1 Then
      --收费按照结算序号查出包含NO号进行处理
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
      v_Billno     := Nextno(14);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
                              保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价,
                              Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                              Max(执行人) As 执行人, 划价人, Max(记帐单id) As 记帐单id, Max(是否急诊) As 是否急诊, 发生时间, Min(实际票号) As 实际票号,
                              Max(执行状态) As 执行状态, Max(执行时间) As 执行时间
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And
                             Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态, 执行时间)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态, r_Clinic.执行时间);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态, 执行时间)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '',
             r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1, 1, r_Clinic.执行时间);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In
              (Select ID
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In
              (Select ID
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
    Else
      --记账按照单据NO进行处理
      v_Billno     := Nextno(14);
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人,
                              Max(记帐单id) As 记帐单id, 发生时间, 实际票号, Max(执行状态) As 执行状态, Max(执行时间) As 执行时间

                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id,
                                保险编码, 费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间,
                                实际票号
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态, 执行时间)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态, r_Clinic.执行时间);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态, 执行时间)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id,
             n_结帐id, -1 * r_Clinic.实收金额, 1, r_Clinic.执行时间);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In (Select ID
                         From 门诊费用记录
                         Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
    End If;
  Else
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
    If Nvl(n_立即销帐, 0) = 1 Then
      If Mod(单据_In, 10) = 1 Then
        Zl_门诊转住院_收费转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In, 0, 入院科室id_In, 主页id_In, Null, n_结帐id, 原结帐id_In);
      Else
        --转记帐单
        --No_In;操作员编号_In,操作员姓名_In,退费时间_In
        Zl_门诊转住院_记帐转出(No_In, 操作员编号_In, 操作员姓名_In, 退费时间_In);
      End If;
    End If;
    --规则
    -- 1.入院病区ID_IN<>NULL 就为:入院病区ID_IN
    -- 2.主页id_In<>0 :
    If Nvl(入院病区id_In, 0) <> 0 Then
      n_病区id := 入院病区id_In;
    Elsif Nvl(主页id_In, 0) <> 0 Then
      Begin
        Select Nvl(b.当前病区id, a.当前病区id), Nvl(b.出院病床, a.当前床号)
        Into n_病区id, v_床号
        From 病人信息 A, 病案主页 B
        Where a.病人id = b.病人id(+) And a.病人id = n_病人id And b.主页id(+) = 主页id_In;
      Exception
        When Others Then
          n_病区id := Null;
      End;
    End If;
  
    If Nvl(n_病区id, 0) = 0 Then
      --以入院科室为准
      n_病区id := Nvl(入院科室id_In, 0);
    End If;
  
    --入院登记之前,主页ID还没有产生,病人预交记录,病人未结费用,未发药品记录,门诊费用记录
    --建有病人ID,主页ID的外键,只有入院登记后再调用Zl_门诊费用转住院_Update填写
    Select 病人id, 开单部门id, 开单人
    Into n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Rownum = 1;
  
    --5.产生记帐单
    --需要检查是否已经转出
    Select Count(*)
    Into n_Count
    From 门诊费用记录 A
    Where NO = No_In And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And Exists
     (Select 1 From 费用审核记录 Where a.Id = 费用id And 转出id Is Not Null) And Rownum <= 1;
    If n_Count >= 1 Then
      v_Err_Msg := '可能因并发原因,该费用已经被他人转出,不能继续操作!';
      Raise Err_Item;
    End If;
    If Mod(单据_In, 10) = 1 Then
      --收费按照结算序号查出包含NO号进行处理
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
      For r_Nos In (Select Distinct c.No
                    From 门诊费用记录 A, 门诊费用记录 C
                    Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In And c.No = a.No And
                          Mod(c.记录性质, 10) = 1 And c.记录状态 In (1, 3)) Loop
        v_Billno := Nextno(14);
      
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
           记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id,
           医疗小组id)
          Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
                 Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
                 执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
          From 门诊费用记录
          Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
      
        If Nvl(n_立即销帐, 0) = 1 Then
          Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) In (1, 2) And 记录状态 = 1;
        End If;
      
        For r_Clinic In (Select Min(记录性质) As 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
                                保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价,
                                Sum(应收金额) As 应收金额, Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id,
                                Max(执行人) As 执行人, 划价人, Max(记帐单id) As 记帐单id, Max(是否急诊) As 是否急诊, 发生时间, Min(实际票号) As 实际票号,
                                Max(执行状态) As 执行状态, Max(执行时间) As 执行时间
                         From 门诊费用记录
                         Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (2, 3) And
                               Nvl(附加标志, 0) Not In (8, 9)
                         Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                  费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间
                         Having Sum(数次) <> 0) Loop
          Select 操作员编号, 操作员姓名
          Into n_操作员编号, v_操作员姓名
          From 门诊费用记录
          Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 = 3 And Rownum < 2;
          Insert Into 住院费用记录
            (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
             收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
             记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 医疗小组id, 执行状态, 执行时间)
          Values
            (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
             住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
             r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否,
             r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志,
             r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额,
             1, r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
             v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', r_Clinic.是否急诊, n_组id, n_医疗小组id, r_Clinic.执行状态, r_Clinic.执行时间);
          If Nvl(n_立即销帐, 0) = 1 Then
            Insert Into 门诊费用记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
               保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
               开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态, 执行时间)
            Values
              (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Nos.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
               1, r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别,
               r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码,
               r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
               r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额,
               0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In,
               操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id, -1 * r_Clinic.实收金额, -1, 1, r_Clinic.执行时间);
          End If;
        End Loop;
      
        --8-工本费，9-误差费
        --病人余额
        Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
        Update 病人余额
        Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
        Returning 费用余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
          n_返回值 := n_实收合计;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      
        --病人未结费用
        For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                      From 住院费用记录
                      Where NO = v_Billno And 记录性质 = 2
                      Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
          Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
                Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
                Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
          End If;
        End Loop;
      
        --6.药品相关数据处理
        For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                      From 住院费用记录 A, 材料特性 B
                      Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
          Update 药品收发记录
          Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
          Where NO = r_Nos.No And 单据 In (8, 9, 24, 25) And
                费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
          If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
            --更新备货材料
            Update 药品收发记录
            Set 费用id = r_Fee.Id
            Where 单据 = 21 And 费用id In (Select ID
                                       From 门诊费用记录
                                       Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And
                                             序号 = r_Fee.序号);
          End If;
          --更新费用审核记录
          Update 费用审核记录
          Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
          Where 费用id In
                (Select ID
                 From 门诊费用记录
                 Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And
                性质 = 1;
          If Sql%NotFound Then
            --未找到数据时，要强制进行对应.
            Insert Into 费用审核记录
              (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
              Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
              From 门诊费用记录
              Where NO = r_Nos.No And Mod(记录性质, 10) = Mod(单据_In, 10) And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
          End If;
        End Loop;
        Update 未发药品记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 主页id = 主页id_In, NO = v_Billno
        Where NO = No_In And 单据 In (8, 24) And 病人id = n_病人id;
      End Loop;
    Else
      --记账按照单据NO进行处理
      v_Billno     := Nextno(14);
      n_医疗小组id := Zl_医疗小组_Get(n_开单部门id, v_开单人, n_病人id, 主页id_In, 入院时间_In);
    
      Insert Into 住院费用记录
        (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
         收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额,
         记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 缴款组id, 医疗小组id)
        Select 病人费用记录_Id.Nextval, 2, v_Billno, 1, 序号, 从属父号, 价格父号, 0, 2, 病人id, 主页id_In, 住院号_In, 姓名, 性别, 年龄, v_床号,
               Decode(n_病区id, Null, Null, 0, Null, n_病区id), 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
               发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 1, 开单部门id, 开单人, 入院时间_In, 退费时间_In,
               执行部门id, 执行人, 执行状态, 执行时间, 划价人, 操作员编号, 操作员姓名, 记帐单id, '门诊费用转入', 是否急诊, 医嘱序号, n_组id, n_医疗小组id
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 1 And Nvl(附加标志, 0) Not In (8, 9);
    
      If Nvl(n_立即销帐, 0) = 1 Then
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 In (1, 2) And 记录状态 = 1;
      End If;
    
      For r_Clinic In (Select 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                              费用类型, 发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, Max(执行人) As 执行人, 划价人,
                              Max(记帐单id) As 记帐单id, 发生时间, 实际票号, Max(执行状态) As 执行状态, Max(执行时间) As 执行时间

                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 记录性质, 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id,
                                保险编码, 费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间,
                                实际票号
                       Having Sum(数次) <> 0) Loop
        Select 操作员编号, 操作员姓名
        Into n_操作员编号, v_操作员姓名
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 单据_In And 记录状态 = 3 And Rownum < 2;
        Insert Into 住院费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
           收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用,
           开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 医疗小组id, 执行状态, 执行时间)
        Values
          (病人费用记录_Id.Nextval, 2, v_Billno, 1, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 0, 2, r_Clinic.病人id, 主页id_In,
           住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, v_床号, Decode(n_病区id, Null, Null, 0, Null, n_病区id),
           r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id,
           r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数, r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志,
           r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价, r_Clinic.应收金额, r_Clinic.实收金额, r_Clinic.统筹金额, 1,
           r_Clinic.开单部门id, r_Clinic.开单人, 入院时间_In, 退费时间_In, r_Clinic.执行部门id, r_Clinic.执行人, r_Clinic.划价人, n_操作员编号,
           v_操作员姓名, r_Clinic.记帐单id, '门诊费用转入', n_组id, n_医疗小组id, r_Clinic.执行状态, r_Clinic.执行时间);
        If Nvl(n_立即销帐, 0) = 1 Then
          Insert Into 门诊费用记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位,
             保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
             开单人, 发生时间, 登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态, 执行时间)
          Values
            (病人费用记录_Id.Nextval, r_Clinic.记录性质, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1,
             r_Clinic.病人id, 住院号_In, r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
             r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型,
             r_Clinic.发药窗口, r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目,
             r_Clinic.标准单价, -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 1, r_Clinic.开单部门id, r_Clinic.开单人,
             r_Clinic.发生时间, 退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id,
             n_结帐id, -1 * r_Clinic.实收金额, 1, r_Clinic.执行时间);
        End If;
      End Loop;
    
      --8-工本费，9-误差费
      --病人余额
      Select Nvl(Sum(实收金额), 0) Into n_实收合计 From 住院费用记录 Where NO = v_Billno And 记录性质 = 2;
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + n_实收合计
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 2
      Returning 费用余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (n_病人id, 1, 2, n_实收合计, 0);
        n_返回值 := n_实收合计;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete 病人余额 Where 性质 = 1 And 病人id = n_病人id And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --病人未结费用
      For r_Fee In (Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(实收金额), 0) 实收合计
                    From 住院费用记录
                    Where NO = v_Billno And 记录性质 = 2
                    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id) Loop
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + r_Fee.实收合计
        Where 病人id = n_病人id And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(r_Fee.病人病区id, 0) And
              Nvl(病人科室id, 0) = Nvl(r_Fee.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Fee.开单部门id, 0) And
              Nvl(执行部门id, 0) = Nvl(r_Fee.执行部门id, 0) And 收入项目id + 0 = r_Fee.收入项目id And 来源途径 + 0 = 2;
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (n_病人id, 主页id_In, r_Fee.病人病区id, r_Fee.病人科室id, r_Fee.开单部门id, r_Fee.执行部门id, r_Fee.收入项目id, 2, r_Fee.实收合计);
        End If;
      End Loop;
    
      --6.药品相关数据处理
      For r_Fee In (Select a.Id, a.序号, b.材料id, b.跟踪在用
                    From 住院费用记录 A, 材料特性 B
                    Where a.收费细目id = b.材料id(+) And a.No = v_Billno And a.记录性质 = 2 And a.记录状态 In (1, 3)) Loop
        Update 药品收发记录
        Set 单据 = Decode(单据, 8, 9, 24, 25, 单据), 费用id = r_Fee.Id, NO = v_Billno
        Where NO = No_In And 单据 In (8, 9, 24, 25) And
              费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        If Nvl(r_Fee.材料id, 0) <> 0 And Nvl(r_Fee.跟踪在用, 0) = 1 Then
          --更新备货材料
          Update 药品收发记录
          Set 费用id = r_Fee.Id
          Where 单据 = 21 And
                费用id In (Select ID
                         From 门诊费用记录
                         Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号);
        End If;
        --更新费用审核记录
        Update 费用审核记录
        Set 转出id = r_Fee.Id, 记录状态 = Decode(n_立即销帐, 1, 2, 1), 主页id = 主页id_In, 转出人 = 操作员姓名_In, 转出时间 = 退费时间_In
        Where 费用id In (Select ID
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号) And 性质 = 1;
        If Sql%NotFound Then
          --未找到数据时，要强制进行对应.
          Insert Into 费用审核记录
            (性质, 费用id, 病人id, 主页id, 审核人, 审核日期, 记录状态, 转出id, 转出人, 转出时间)
            Select 1, ID, n_病人id, 主页id_In, 操作员姓名_In, 退费时间_In, Decode(n_立即销帐, 1, 2, 1), r_Fee.Id, 操作员姓名_In, 退费时间_In
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 单据_In And 记录状态 In (1, 3) And 序号 = r_Fee.序号;
        End If;
      End Loop;
      Update 未发药品记录
      Set 主页id = 主页id_In, NO = v_Billno
      Where NO = No_In And 单据 In (9, 25) And 病人id = n_病人id;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊费用转住院_Insert;
/

--100110:张德婷,2016-08-31,修正无法对门诊记账单进行退料的错误
Create Or Replace Procedure Zl_材料收发记录_部门退料
(
  收发id_In   In 药品收发记录.Id%Type,
  审核人_In   In 药品收发记录.审核人%Type,
  审核日期_In In 药品收发记录.审核日期%Type,
  批号_In     In 药品库存.上次批号%Type := Null,
  效期_In     In 药品库存.效期%Type := Null,
  产地_In     In 药品库存.上次产地%Type := Null,
  退料数量_In In 药品收发记录.实际数量%Type := Null,
  自动销帐_In Integer := 0,
  退料人_In   In 药品收发记录.领用人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  v_No      药品收发记录.No%Type;

  n_记录状态   药品收发记录.记录状态%Type;
  n_执行状态   住院费用记录.执行状态%Type;
  n_部分退料   Number;
  n_入出类别id Number(18);
  n_单据       药品收发记录.单据%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_药品id     药品收发记录.药品id%Type;
  n_实际数量   药品收发记录.实际数量%Type;
  n_实际金额   药品收发记录.零售金额%Type;
  n_实际成本   药品收发记录.成本金额%Type;
  n_实际差价   药品收发记录.差价%Type;
  n_费用id     药品收发记录.费用id%Type;
  n_零售价     药品收发记录.零售价%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  --处理退料时，分批核算性质改变后的处理
  n_新批次       药品收发记录.批次%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批         材料特性.在用分批%Type;
  n_小数         Number(2);
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_成本价       药品收发记录.成本价%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_产地         药品收发记录.产地%Type;
  v_费用no       住院费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     人员表.姓名%Type;
  n_主页id       住院费用记录.主页id%Type;
  n_序号         住院费用记录.序号%Type;
  v_病人来源     病人医嘱记录.病人来源%Type;

  v_备货id     药品收发记录.Id%Type;
  v_入库no     药品收发记录.No%Type;
  v_入库序号   Number(5) := 0;
  v_执行时间   药品收发记录.审核日期%Type;
  n_平均成本价 药品库存.平均成本价%Type;
  n_冲销记录id 药品收发记录.Id%Type;
  n_移库       Number(1) := 0;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')) Into n_小数 From Dual;

  If 退料数量_In Is Not Null Then
    If 退料数量_In = 0 Then
      Return;
    End If;
  End If;

  --1、判断当前数据是否是备货卫材
  Begin
    Select 汇总发药号
    Into v_备货id
    From 药品收发记录
    Where 单据 = 21 And 审核日期 Is Not Null And
          汇总发药号 =
          (Select Max(a.Id)
           From 药品收发记录 A, 药品收发记录 B
           Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And b.Id = 收发id_In And (Mod(a.记录状态, 3) = 1 Or a.记录状态 = 1)) And
          Rownum = 1;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  --获取该收发记录的单据、药品ID、库房ID
  Select 单据, NO, 库房id, 药品id, 费用id, 入出类别id, 记录状态, Nvl(批次, 0), 生产日期, 灭菌效期, 批准文号, 供药单位id, 成本价, 产地, 零售价
  Into n_单据, v_No, n_库房id, n_药品id, n_费用id, n_入出类别id, n_记录状态, n_批次, d_上次生产日期, d_灭菌效期, v_批准文号, n_上次供应商id, n_成本价, v_产地,
       n_零售价
  From 药品收发记录
  Where ID = 收发id_In;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into n_实际数量, n_实际金额, n_实际成本, n_实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = v_No And 单据 = n_单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = 收发id_In);

  --如果允许退药数为零，表示已退药
  If n_实际数量 = 0 Then
    v_Err_Msg := '该单据已被其他操作员退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  If Nvl(退料数量_In, 0) > n_实际数量 Then
    v_Err_Msg := '该单据已被其他操作员部分退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  --获取该材料当前是否分批的信息
  Select Nvl(在用分批, 0) Into n_分批 From 材料特性 Where 材料id = n_药品id;

  --如果是部分退料，则重新计算零售金额及差价
  n_部分退料 := 0;
  If Not (退料数量_In Is Null Or Nvl(退料数量_In, 0) = n_实际数量) Then
    n_部分退料 := 1;
  End If;

  If n_部分退料 = 1 Then
    n_实际金额 := Round(n_实际金额 * 退料数量_In / n_实际数量, n_小数);
    n_实际成本 := Round(n_实际成本 * 退料数量_In / n_实际数量, n_小数);
    n_实际差价 := Round(n_实际差价 * 退料数量_In / n_实际数量, n_小数);
    n_实际数量 := 退料数量_In;
  End If;

  --n_分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If n_分批 = 0 And n_批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    n_分批 := 2;
  Elsif n_分批 <> 0 And n_批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    n_分批 := 3;
  Else
    If n_批次 = 0 Then
      n_分批 := 0;
    Else
      n_分批 := 1;
    End If;
  End If;
  If 产地_In Is Not Null Then
    v_产地 := 产地_In;
  End If;
  --记录状态的含义有所变化
  --冲销的记录状态        :iif(n_记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(n_记录状态=1,0,1)+2
  --等待发料的记录状态    :iif(n_记录状态=1,0,1)+3
  Select 药品收发记录_Id.Nextval Into n_冲销记录id From Dual;
  --产生冲销记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 领用人, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_冲销记录id, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 1, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号,
           效期, 灭菌效期, 1, -n_实际数量, -n_实际数量, 成本价, -n_实际成本, 扣率, 零售价, -n_实际金额, -n_实际差价, 摘要, 审核人_In, 审核日期_In, 配药人, 审核人_In,
           审核日期_In, 费用id, 单量, 频次, 用法, 发药窗口, 退料人_In, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发料
  Select 药品收发记录_Id.Nextval Into n_新批次 From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_新批次, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 3, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(n_分批, 1, 批次, 3, n_新批次, Null), Decode(n_分批, 3, 产地_In, 1, 产地, Null), Decode(n_分批, 3, 批号_In, 1, 批号, Null),
           Decode(n_分批, 3, 效期_In, 1, 效期, Null), 灭菌效期, 1, n_实际数量, n_实际数量, 成本价, n_实际成本, 扣率, 零售价, n_实际金额, n_实际差价, 摘要, 填制人,
           填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --更新病人费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into n_执行状态
  From 药品收发记录
  Where 单据 = n_单据 And NO = v_No And 费用id = n_费用id And 审核人 Is Not Null;

  If n_执行状态 = 0 Then
    Update 住院费用记录 Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And (Mod(记录性质, 10) = 1 or Mod(记录性质, 10) = 2)  And
          记录状态 <> 2 And 执行部门id = n_库房id;
  Else
    Update 住院费用记录 Set 执行状态 = n_执行状态 Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And (Mod(记录性质, 10) = 1 or Mod(记录性质, 10) = 2) And
          记录状态 <> 2 And 执行部门id = n_库房id;
  End If;

  --插入未发药品记录
  Begin
    Insert Into 未发药品记录
      (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
      Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
      From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费, b.对方部门id,
                    b.库房id, b.发药窗口, b.填制日期, c.身份
             From 住院费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)
             Union All
             Select b.单据, b.No, a.病人id, Null As 主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费,
                    b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
             From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
      Where b.名称(+) = a.身份;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 2 Where ID = 收发id_In;

  --修改药品库存(反冲库存)
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = n_药品id;

  If n_分批 <> 3 Then
  
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_实际金额, 实际差价 = Nvl(实际差价, 0) + n_实际差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null)
    Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(批次, 0) = n_批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
      Values
        (n_库房id, n_药品id, Decode(n_分批, 2, Null, n_批次), 1, n_实际数量, n_实际金额, n_实际差价, Decode(n_分批, 1, 效期_In, Null), d_灭菌效期,
         n_上次供应商id, n_成本价, Decode(n_分批, 1, 批号_In, Null), d_上次生产日期, v_产地, v_批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_成本价);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价)
    Values
      (n_库房id, n_药品id, n_新批次, 1, n_实际数量, n_实际金额, n_实际差价, 效期_In, d_灭菌效期, n_上次供应商id, n_成本价, 批号_In, d_上次生产日期, v_产地, v_批准文号,
       Decode(n_实价卫材, 1, Decode(Nvl(n_新批次, 0), 0, Null, n_零售价), Null), n_成本价);
  End If;

  Delete 药品库存
  Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  If 自动销帐_In = 1 And n_单据 <> 24 Then
    Begin
      Select 主页id, NO, 序号 Into n_主页id, v_费用no, n_序号 From 住院费用记录 Where ID = n_费用id;
    Exception
      When Others Then
        Begin
          Select Null, NO, 序号 Into n_主页id, v_费用no, n_序号 From 门诊费用记录 Where ID = n_费用id;
        Exception
          When Others Then
            n_主页id := Null;
        End;
    End;
    If n_主页id Is Null Then
      Zl_门诊记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    Else
      Zl_住院记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    End If;
  End If;

  --备货卫材处理
  If v_备货id > 0 Then
    --2、自动冲销已审核的其他出库单据
    Begin
      Select 1
      Into n_移库
      From 药品收发记录
      Where 单据 = 15 And 审核日期 Is Null And
            费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
    Exception
      When Others Then
        n_移库 := 0;
    End;
    If n_移库 <> 0 Then
      For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
      
        Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In, 1);
      End Loop;
    
      --3、产生新的其他出库单据
      If v_入库no Is Null Then
        v_入库no := Nextno(74, n_库房id);
      End If;
      v_入库序号 := v_入库序号 + 1;
    
      For v_入库 In (Select 入出类别id, 库房id, 药品id, 批次, 填写数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 产地, 批号, 效期, 灭菌效期, 摘要, 单量, 发药窗口
                   From 药品收发记录
                   Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
      
        Zl_材料其他出库_Insert(v_入库.入出类别id, v_入库no, v_入库序号, v_入库.库房id, v_入库.药品id, v_入库.批次, v_入库.填写数量, v_入库.成本价, v_入库.成本金额,
                         v_入库.零售价, v_入库.零售金额, v_入库.差价, 审核人_In, 审核日期_In, v_入库.产地, v_入库.批号, v_入库.效期, v_入库.灭菌效期, v_入库.摘要,
                         v_入库.单量, v_入库.发药窗口);
      
        Update 药品收发记录
        Set 费用id = n_费用id, 汇总发药号 = n_新批次
        Where 单据 = 21 And NO = v_入库no And 序号 = v_入库序号;
      End Loop;
    
      --4、删除未审核的外购入库单据（已审核则不管）
      Delete 药品收发记录
      Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
    End If;
  End If;
  --处理调价修正单据
  Zl_材料收发记录_调价修正(n_冲销记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_部门退料;
/

--99975:胡俊勇,2016-08-26,医保病人退费
Create Or Replace Procedure Zl_门诊医嘱执行_Cancel
(
  医嘱id_In     病人医嘱执行.医嘱id%Type,
  发送号_In     病人医嘱执行.发送号%Type,
  单独执行_In   Number,
  操作员编号_In 人员表.编号%Type,
  操作员姓名_In 人员表.姓名%Type,
  组id_In       病人医嘱执行.医嘱id%Type,
  诊疗类别_In   病人医嘱记录.诊疗类别%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type
  --参数：医嘱ID_IN=单独执行的医嘱ID，检验组合为显示的检验项目的ID。
  --      单独执行_In=检验医嘱组合是否采用对每个项目分散单独执行的方式
) Is
  --医嘱相关的费用单据
  Cursor c_No Is
    Select a.No || ':' || a.记录性质
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.发送号 + 0 = 发送号_In And a.医嘱id = b.Id And b.诊疗类别 = 诊疗类别_In And (b.Id = 组id_In Or b.相关id = 组id_In)
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  Cursor c_Noone Is
    Select NO || ':' || 记录性质
    From 病人医嘱附费
    Where 发送号 + 0 = 发送号_In And 医嘱id = 医嘱id_In
    Union
    Select NO || ':' || 记录性质 From 病人医嘱发送 Where 医嘱id = 医嘱id_In And 发送号 + 0 = 发送号_In;

  r_No       t_Strlist;
  r_No_Stuff t_Strlist;
  r_Finish   t_Numlist;

  n_执行次数 Number;
  n_剩余次数 Number;
  n_执行状态 Number;

  --要取消执行的费用行(不包含药品和跟踪在用的卫材)
  Cursor c_Finish(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select Distinct a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A, 病人医嘱记录 B,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = b.Id And (b.Id = 组id_In Or b.相关id = 组id_In) And a.No = n.No And
                 (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And a.记录状态 In (0, 1, 3) And
                 (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  Cursor c_Finishone(r_No t_Strlist) Is
    Select /*+ RULE */
     a.Id
    From (Select a.Id, a.收费类别, a.收费细目id
           From 门诊费用记录 A,
                (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                         To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
                  From Table(r_No)) N
           Where a.医嘱序号 = 医嘱id_In And a.No = n.No And (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And
                 a.记录状态 In (0, 1, 3) And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)) A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And Not a.收费类别 In ('5', '6', '7') And Not (a.收费类别 = '4' And Nvl(b.跟踪在用, 0) = 1);

  --取消执行中包含跟踪在用的发料卫料时，根据参数设置是否自动退料
  --卫生材料医嘱目前不存在单独和组合执行的情况
  Cursor c_Stuff(r_No t_Strlist) Is
    Select /*+ RULE */
     b.Id
    From 门诊费用记录 A, 药品收发记录 B, 病人医嘱记录 C,
         (Select Substr(Column_Value, 1, Instr(Column_Value, ':') - 1) As NO,
                  To_Number(Substr(Column_Value, Instr(Column_Value, ':') + 1)) As 记录性质
           From Table(r_No)) N
    Where a.Id = b.费用id And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And b.审核人 Is Not Null And a.收费类别 = '4' And a.记录状态 = 1 And
          a.医嘱序号 = c.Id And c.诊疗类别 = 诊疗类别_In And (c.Id = 组id_In Or c.相关id = 组id_In) And a.No = n.No And
          (a.记录性质 = n.记录性质 Or a.记录性质 = 11 And n.记录性质 = 1) And b.单据 = 24 And (执行部门id_In = 0 Or a.执行部门id = 执行部门id_In)
    Order By b.药品id;
Begin
  Open c_Noone;
  Fetch c_Noone Bulk Collect
    Into r_No_Stuff;
  Close c_Noone;

  If Nvl(单独执行_In, 0) = 0 Then
    Open c_No;
    Fetch c_No Bulk Collect
      Into r_No;
    Close c_No;
  Else
    r_No := r_No_Stuff;
  End If;

  --主费用可能需要限制医嘱序号
  --不包含药品和跟踪在用的卫材，因为这些都要发放才表示执行
  If Nvl(单独执行_In, 0) = 0 Then
    Open c_Finish(r_No);
    Fetch c_Finish Bulk Collect
      Into r_Finish;
    Close c_Finish;
  Else
    Open c_Finishone(r_No);
    Fetch c_Finishone Bulk Collect
      Into r_Finish;
    Close c_Finishone;
  End If;

  Select Decode(a.执行状态, 1, a.发送数次, c.登记次数), Decode(a.执行状态, 1, 0, a.发送数次 - c.登记次数)
  Into n_执行次数, n_剩余次数
  From 病人医嘱发送 A,
       (Select 医嘱id_In 医嘱id, 发送号_In 发送号, Nvl(Sum(b.本次数次), 0) As 登记次数
         From 病人医嘱执行 B
         Where b.医嘱id = 医嘱id_In And b.发送号 = 发送号_In And Nvl(b.执行结果, 1) <> 0) C
  Where a.医嘱id = c.医嘱id And a.发送号 = c.发送号 And a.医嘱id = 医嘱id_In And a.发送号 = 发送号_In;

  --如果全部执行则状态为1，未执行状态为0，部分执行状态为2
  Select Decode(n_剩余次数, 0, 1, Decode(n_执行次数, 0, 0, 2)) Into n_执行状态 From Dual;

  --对于门诊单据（包含记账与收费）部分执行（2）与完全执行（1）,执行时间为执行完成的执行时间，执行人为执行完成的执行人
  Forall I In 1 .. r_Finish.Count
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行时间 = Decode(n_执行状态, 0, Null, 执行时间), 执行人 = Decode(n_执行状态, 0, Null, 执行人)
    Where ID = r_Finish(I);

  --处理跟踪在用卫材自动发料
  If Nvl(zl_GetSysParameter(33), '0') = '1' Then
    For r_Stuff In c_Stuff(r_No_Stuff) Loop
      Zl_材料收发记录_部门退料(r_Stuff.Id, 操作员姓名_In, Sysdate, Null, Null, Null, Null, 0, 操作员姓名_In);
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊医嘱执行_Cancel;
/

--102400:黄捷,2016-12-08,报告名称自动编号
--103157:黄捷,2016-12-02,RIS分科室启用控制
--102623:黄捷,2016-11-24,RIS打印预约通知
--102400:黄捷,2016-11-08,删除报告时删除病人医嘱报告
--101229:黄捷,2016-10-21,取消登记自动销账
--101715:黄捷,2016-10-19,RIS接口取消完成清空完成人
--100939:黄捷,2016-09-22,RIS接口检查医嘱批量重发
--99972:黄捷,2015-08-25,RIS接口接收RIS状态
CREATE OR REPLACE Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure Receiverisstate(医嘱id_In   病人医嘱发送.医嘱id%Type,
                            Risid_In    病人医嘱报告.Risid%Type,
                            状态_In     Number,
                            操作人员_In 病人医嘱发送.完成人%Type,
                            执行时间_In 病人医嘱发送.完成时间%Type := Null,
                            执行说明_In 病人医嘱发送.执行说明%Type := Null,
                            单独执行_In Number := 0);

  --2、费用确认
  Procedure 影像费用执行(医嘱id_In     影像检查记录.医嘱id%Type,
                   单独执行_In   Number := 0,
                   操作员编号_In 人员表.编号%Type := Null,
                   操作员姓名_In 人员表.姓名%Type := Null,
                   执行部门id_In 门诊费用记录.执行部门id%Type := Null);

  --3、取消费用确认
  Procedure 影像费用执行_Cancel(医嘱id_In     影像检查记录.医嘱id%Type,
                          单独执行_In   Number := 0,
                          操作员编号_In 人员表.编号%Type := Null,
                          操作员姓名_In 人员表.姓名%Type := Null,
                          执行部门id_In 门诊费用记录.执行部门id%Type := Null);

  --4、接收RIS的报告
  Procedure Receivereport(医嘱id_In   病人医嘱发送.医嘱id%Type,
                          Risid_In    病人医嘱报告.Risid%Type,
                          报告所见_In 电子病历内容.内容文本%Type,
                          报告意见_In 电子病历内容.内容文本%Type,
                          报告建议_In 电子病历内容.内容文本%Type,
                          报告医生_In 电子病历记录.创建人%Type);

  --5、修改申请单信息
  Procedure 影像病人信息_修改(医嘱id_In       病人医嘱记录.Id%Type,
                      姓名_In         病人信息.姓名%Type,
                      性别_In         病人信息.性别%Type,
                      年龄_In         病人信息.年龄%Type,
                      费别_In         病人信息.费别%Type,
                      医疗付款方式_In 病人信息.医疗付款方式%Type,
                      民族_In         病人信息.民族%Type,
                      婚姻_In         病人信息.婚姻状况%Type,
                      职业_In         病人信息.职业%Type,
                      身份证号_In     病人信息.身份证号%Type,
                      家庭地址_In     病人信息.家庭地址%Type,
                      家庭电话_In     病人信息.家庭电话%Type,
                      家庭地址邮编_In 病人信息.家庭地址邮编%Type,
                      出生日期_In     病人信息.出生日期%Type := Null);

  --6、取消申请单信息
  Procedure 取消检查申请单(医嘱id_In     病人医嘱执行.医嘱id%Type,
                    操作员编号_In 人员表.编号%Type := Null,
                    操作员姓名_In 人员表.姓名%Type := Null,
                    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
                    拒绝原因_In   病人医嘱发送.执行说明%Type := Null);

  --7、插入医嘱操作失败记录
  Procedure RIS医嘱失败记录_Insert(病人来源_In   In RIS医嘱失败记录.病人来源%Type,
                             病人ID_In     In RIS医嘱失败记录.病人ID%Type,
                             主页ID_In     In RIS医嘱失败记录.主页ID%Type,
                             挂号单号_In   In RIS医嘱失败记录.挂号单号%Type,
                             发送号_In     In RIS医嘱失败记录.发送号%Type,
                             体检任务ID_In In RIS医嘱失败记录.体检任务ID%Type,
                             体检报到号_In In RIS医嘱失败记录.体检报到号%Type,
                             发送类型_In   In RIS医嘱失败记录.发送类型%Type);

  --8、更新医嘱操作失败记录
  Procedure RIS医嘱失败记录_重发(ID_In       In RIS医嘱失败记录.ID%Type,
                         操作类型_In In Number);

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据(医嘱ID_In In 病人医嘱发送.医嘱ID%Type,
                      No_In     In 病人医嘱发送.No%Type,
                      Action_In In number);

  --10、打印RIS检查预约通知单
  Procedure RIS检查预约_打印(医嘱ID_In In RIS检查预约.医嘱ID%Type);

  --11、更新RIS分科室启用参数
  Procedure RIS启用控制_Update(检查类型_In RIS启用控制.检查类型%Type,
                           场合_In     RIS启用控制.场合%Type,
                           部门ids_In  Varchar2,
                           启用类型_In Number);

  --12、删除RIS分科室启用参数
  Procedure RIS启用控制_Delete;

End b_Zlxwinterface;
/

CREATE OR REPLACE Package Body b_Zlxwinterface Is

  --1、接收RIS状态改变
  Procedure Receiverisstate(医嘱id_In   病人医嘱发送.医嘱id%Type,
                            Risid_In    病人医嘱报告.Risid%Type,
                            状态_In     Number,
                            操作人员_In 病人医嘱发送.完成人%Type,
                            执行时间_In 病人医嘱发送.完成时间%Type := Null,
                            执行说明_In 病人医嘱发送.执行说明%Type := Null,
                            单独执行_In Number := 0) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select ID,
             相关id,
             Nvl(相关id, ID) As 组id,
             诊疗类别,
             病人来源,
             执行科室id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
    v_Count    Number;
    v_完成人   病人医嘱发送.完成人%Type;
    v_完成时间 病人医嘱发送.完成时间%Type;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
      v_完成人   := 操作人员_In;
      v_完成时间 := 执行时间_In;
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
       Where ID = (Select 病历id
                     From 病人医嘱报告
                    Where 医嘱id = 医嘱id_In
                      And Risid = Risid_In);
      Delete From 病人医嘱报告
       Where 医嘱id = 医嘱id_In
         And Risid = Risid_In;
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1)
        Into v_Count
        From 病人医嘱报告
       Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --开始执行医嘱
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行
        Update 病人医嘱发送
           Set 执行状态 = v_执行状态,
               执行过程 = v_执行过程,
               执行说明 = 执行说明_In,
               完成人   = v_完成人,
               完成时间 = v_完成时间
         Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
           Set 执行状态 = v_执行状态,
               执行过程 = v_执行过程,
               执行说明 = 执行说明_In,
               完成人   = v_完成人,
               完成时间 = v_完成时间
         Where 医嘱id In
               (Select ID
                  From 病人医嘱记录
                 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行(医嘱id_In     影像检查记录.医嘱id%Type,
                   单独执行_In   Number := 0,
                   操作员编号_In 人员表.编号%Type := Null,
                   操作员姓名_In 人员表.姓名%Type := Null,
                   执行部门id_In 门诊费用记录.执行部门id%Type := Null) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_Count    Number;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    Select 发送号, 执行过程
      Into v_发送号, v_执行过程
      From 病人医嘱发送
     Where 医嘱id = r_Advice.组id;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
      Select Count(*)
        Into v_Count
        From 病人医嘱记录 A, 病案主页 B
       Where a.病人id = b.病人id
         And a.主页id = b.主页id
         And (b.出院日期 Is Not Null Or b.状态 = 3)
         And a.Id = r_Advice.组id;
    
      If v_Count > 0 Then
        v_Error := '住院病人已经出院或者预出院，不能执行费用。';
        Raise Err_Custom;
      End If;
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And
         执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
          Into v_费用性质
          From 病人医嘱发送
         Where 发送号 = v_发送号
           And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In,
                         v_发送号,
                         单独执行_In,
                         v_人员编号,
                         v_人员姓名,
                         r_Advice.组id,
                         r_Advice.诊疗类别,
                         v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In,
                         v_发送号,
                         单独执行_In,
                         v_人员编号,
                         v_人员姓名,
                         r_Advice.组id,
                         r_Advice.诊疗类别,
                         v_部门id);
      End If;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel(医嘱id_In     影像检查记录.医嘱id%Type,
                          单独执行_In   Number := 0,
                          操作员编号_In 人员表.编号%Type := Null,
                          操作员姓名_In 人员表.姓名%Type := Null,
                          执行部门id_In 门诊费用记录.执行部门id%Type := Null) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_发送号 病人医嘱发送.发送号%Type;
    v_Count  Number;
    v_Error  Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
    Select Count(*)
      Into v_Count
      From 病人医嘱记录 A, 病案主页 B
     Where a.病人id = b.病人id
       And a.主页id = b.主页id
       And (b.出院日期 Is Not Null Or b.状态 = 3)
       And a.Id = r_Advice.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，不能取消费用。';
      Raise Err_Custom;
    End If;
  
    Select 发送号
      Into v_发送号
      From 病人医嘱发送
     Where 医嘱id = r_Advice.组id;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In,
                     v_发送号,
                     Null,
                     单独执行_In,
                     执行部门id_In,
                     操作员编号_In,
                     操作员姓名_In);
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport(医嘱id_In   病人医嘱发送.医嘱id%Type,
                          Risid_In    病人医嘱报告.Risid%Type,
                          报告所见_In 电子病历内容.内容文本%Type,
                          报告意见_In 电子病历内容.内容文本%Type,
                          报告建议_In 电子病历内容.内容文本%Type,
                          报告医生_In 电子病历记录.创建人%Type) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice(v_组id Number, v_Risid Number) Is
      Select e.Id,
             e.病人来源,
             e.病人id,
             e.主页id,
             e.婴儿,
             e.病人科室id,
             e.文件id,
             e.病历种类,
             e.病历名称,
             f.病历id,
             e.执行科室id
        From (Select c.Id,
                     c.病人来源,
                     c.病人id,
                     c.主页id,
                     c.婴儿,
                     c.病人科室id,
                     c.文件id,
                     d.种类       病历种类,
                     d.名称       病历名称,
                     c.执行科室id
                From (Select a.Id,
                             a.病人来源,
                             a.病人id,
                             a.主页id,
                             a.婴儿,
                             a.病人科室id,
                             b.病历文件id 文件id,
                             a.执行科室id
                        From 病人医嘱记录 A, 病历单据应用 B
                       Where a.Id = v_组id
                         And a.诊疗项目id = b.诊疗项目id(+)
                         And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                     病历文件列表 D
               Where c.文件id = d.Id(+)) E,
             病人医嘱报告 F
       Where e.Id = f.医嘱id(+)
         And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id,
             a.文件id,
             a.父id,
             a.对象序号,
             a.对象类型,
             a.对象标记,
             a.保留对象,
             a.对象属性,
             a.内容行次,
             a.内容文本,
             a.是否换行,
             a.预制提纲id,
             a.复用提纲,
             a.使用时机,
             a.诊治要素id,
             a.替换域,
             a.要素名称,
             a.要素类型,
             a.要素长度,
             a.要素小数,
             a.要素单位,
             a.要素表示,
             a.输入形态,
             a.要素值域
        From 病历文件结构 A
       Where a.文件id = v_File
       Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
        From 电子病历内容 A, 电子病历内容 B
       Where a.对象类型 = 3
         And a.Id = b.父id
         And b.对象类型 = 2
         And b.终止版 = 0
         And a.文件id = v_电子病历记录id;
  
    Cursor c_Content(v_文件id Number, v_表格id Number) Is
      Select a.Id,
             a.文件id,
             a.父id,
             a.对象序号,
             a.对象类型,
             a.对象标记,
             a.保留对象,
             a.对象属性,
             a.内容行次,
             a.内容文本,
             a.是否换行,
             a.预制提纲id,
             a.复用提纲,
             a.使用时机,
             a.诊治要素id,
             a.替换域,
             a.要素名称,
             a.要素类型,
             a.要素长度,
             a.要素小数,
             a.要素单位,
             a.要素表示,
             a.输入形态,
             a.要素值域
        From 病历文件结构 A
       Where 文件id = v_文件id
         And 父id = v_表格id;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
    n_rptCount Number;
    v_病历名称 电子病历记录.病历名称%Type;
  
    Function GetRptNo(v_医嘱IDIn   病人医嘱发送.医嘱id%Type,
                      v_病历名称In 电子病历记录.病历名称%Type) return varchar as
      v_return number;
      v_No     number;
      v_Count  number;
    begin
      Select count(医嘱id) + 1
        into v_No
        from 病人医嘱报告
       where 医嘱ID = v_医嘱IDIn;
      v_count := 1;
      while v_count = 1 loop
        Select count(id)
          into v_count
          from 病人医嘱报告 a, 电子病历记录 b
         where a.医嘱id = v_医嘱IDIn
           and a.病历id = b.id
           and b.病历名称 = v_病历名称In || v_no;
         if v_count = 1 then  
           v_no := v_no + 1 ;
         end if;
      end loop;
      v_return := v_No;
      return v_return;
    end GetRptNo;
  
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id
      Into v_主医嘱id
      From 病人医嘱记录
     Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容
               Set 内容文本 = 报告所见_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容
               Set 内容文本 = 报告意见_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容
               Set 内容文本 = 报告建议_In || Chr(13) || Chr(13)
             Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
           Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
         Where ID = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%所见%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%意见%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
            Into n_数量
            From 病历文件结构 A, 病历文件结构 B
           Where a.父id = b.Id
             And a.对象类型 = 3
             And b.对象类型 = 1
             And a.内容文本 Like '%建议%'
             And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        n_rptCount := GetRptNo(医嘱id_In, r_Advice.病历名称);
        if n_rptCount > 1 then
          v_病历名称 := r_Advice.病历名称 || n_rptCount;
        else
          v_病历名称 := r_Advice.病历名称;
        end if;
        Insert Into 电子病历记录
          (ID,
           病人来源,
           病人id,
           主页id,
           婴儿,
           科室id,
           病历种类,
           文件id,
           病历名称,
           创建人,
           创建时间,
           完成时间,
           保存人,
           保存时间,
           最后版本,
           签名级别)
        Values
          (v_病历id,
           r_Advice.病人来源,
           r_Advice.病人id,
           r_Advice.主页id,
           r_Advice.婴儿,
           r_Advice.病人科室id,
           r_Advice.病历种类,
           r_Advice.文件id,
           v_病历名称,
           报告医生_In,
           Sysdate,
           Sysdate,
           报告医生_In,
           Sysdate,
           1,
           2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告
          (医嘱id, 病历id, Risid)
        Values
          (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称,
                                               r_Advice.病人id,
                                               r_Advice.主页id,
                                               r_Advice.病人来源,
                                               r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (ID,
               文件id,
               开始版,
               终止版,
               父id,
               对象序号,
               对象类型,
               对象标记,
               保留对象,
               对象属性,
               内容行次,
               内容文本,
               是否换行,
               预制提纲id,
               复用提纲,
               使用时机,
               诊治要素id,
               替换域,
               要素名称,
               要素类型,
               要素长度,
               要素小数,
               要素单位,
               要素表示,
               输入形态,
               要素值域,
               定义提纲id)
            Values
              (v_病历内容id,
               v_病历id,
               1,
               0,
               Decode(v_定义提纲id, 0, v_父id, Null),
               v_对象序号,
               r_File.对象类型,
               r_File.对象标记,
               r_File.保留对象,
               r_File.对象属性,
               Null,
               v_内容文本,
               r_File.是否换行,
               r_File.预制提纲id,
               r_File.复用提纲,
               r_File.使用时机,
               r_File.诊治要素id,
               r_File.替换域,
               r_File.要素名称,
               r_File.要素类型,
               r_File.要素长度,
               r_File.要素小数,
               r_File.要素单位,
               r_File.要素表示,
               r_File.输入形态,
               r_File.要素值域,
               Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval
                Into v_病历内容idnew
                From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (ID,
                 文件id,
                 开始版,
                 终止版,
                 父id,
                 对象序号,
                 对象类型,
                 对象标记,
                 保留对象,
                 对象属性,
                 内容行次,
                 内容文本,
                 是否换行,
                 预制提纲id,
                 复用提纲,
                 使用时机,
                 诊治要素id,
                 替换域,
                 要素名称,
                 要素类型,
                 要素长度,
                 要素小数,
                 要素单位,
                 要素表示,
                 输入形态,
                 要素值域,
                 定义提纲id)
              Values
                (v_病历内容idnew,
                 v_病历id,
                 1,
                 0,
                 v_病历内容id,
                 v_对象序号,
                 2,
                 r_Con.对象标记,
                 r_Con.保留对象,
                 r_Con.对象属性,
                 Null,
                 v_内容文本,
                 r_Con.是否换行,
                 r_Con.预制提纲id,
                 r_Con.复用提纲,
                 r_Con.使用时机,
                 r_Con.诊治要素id,
                 r_Con.替换域,
                 r_Con.要素名称,
                 r_Con.要素类型,
                 r_Con.要素长度,
                 r_Con.要素小数,
                 r_Con.要素单位,
                 r_Con.要素表示,
                 r_Con.输入形态,
                 r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改(医嘱id_In       病人医嘱记录.Id%Type,
                      姓名_In         病人信息.姓名%Type,
                      性别_In         病人信息.性别%Type,
                      年龄_In         病人信息.年龄%Type,
                      费别_In         病人信息.费别%Type,
                      医疗付款方式_In 病人信息.医疗付款方式%Type,
                      民族_In         病人信息.民族%Type,
                      婚姻_In         病人信息.婚姻状况%Type,
                      职业_In         病人信息.职业%Type,
                      身份证号_In     病人信息.身份证号%Type,
                      家庭地址_In     病人信息.家庭地址%Type,
                      家庭电话_In     病人信息.家庭电话%Type,
                      家庭地址邮编_In 病人信息.家庭地址邮编%Type,
                      出生日期_In     病人信息.出生日期%Type := Null) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id
        Into v_病人来源, v_病人id
        From 病人医嘱记录
       Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位,
                      '岁',
                      Add_Months(Sysdate, -12 * v_年龄),
                      '月',
                      Add_Months(Sysdate, -1 * v_年龄),
                      '天',
                      Sysdate - v_年龄)
          Into v_出生日期
          From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
         Set 姓名         = 姓名_In,
             性别         = Nvl(性别_In, 性别),
             年龄         = 年龄_In,
             出生日期     = v_出生日期,
             费别         = Nvl(费别_In, 费别),
             医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式),
             民族         = Nvl(民族_In, 民族),
             婚姻状况     = Nvl(婚姻_In, 婚姻状况),
             职业         = Nvl(职业_In, 职业),
             身份证号     = 身份证号_In,
             家庭地址     = 家庭地址_In,
             家庭电话     = 家庭电话_In,
             家庭地址邮编 = 家庭地址邮编_In
       Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
         Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
       Where ID = 医嘱id_In
          Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
         Set 民族         = Nvl(民族_In, 民族),
             婚姻状况     = Nvl(婚姻_In, 婚姻状况),
             职业         = Nvl(职业_In, 职业),
             家庭地址     = 家庭地址_In,
             家庭电话     = 家庭电话_In,
             家庭地址邮编 = 家庭地址邮编_In
       Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单(医嘱id_In     病人医嘱执行.医嘱id%Type,
                    操作员编号_In 人员表.编号%Type := Null,
                    操作员姓名_In 人员表.姓名%Type := Null,
                    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
                    拒绝原因_In   病人医嘱发送.执行说明%Type := Null) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号
        Into v_发送号
        From 病人医嘱发送
       Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In,
                   v_发送号,
                   操作员编号_In,
                   操作员姓名_In,
                   执行部门id_In,
                   拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;

  --7、插入医嘱操作失败记录
  Procedure RIS医嘱失败记录_Insert(病人来源_In   In RIS医嘱失败记录.病人来源%Type,
                             病人ID_In     In RIS医嘱失败记录.病人ID%Type,
                             主页ID_In     In RIS医嘱失败记录.主页ID%Type,
                             挂号单号_In   In RIS医嘱失败记录.挂号单号%Type,
                             发送号_In     In RIS医嘱失败记录.发送号%Type,
                             体检任务ID_In In RIS医嘱失败记录.体检任务ID%Type,
                             体检报到号_In In RIS医嘱失败记录.体检报到号%Type,
                             发送类型_In   In RIS医嘱失败记录.发送类型%Type) Is
  Begin
    Insert Into RIS医嘱失败记录
      (ID,
       病人来源,
       病人ID,
       主页ID,
       挂号单号,
       发送号,
       体检任务ID,
       体检报到号,
       发送类型,
       发送时间,
       重发次数)
    Values
      (RIS医嘱失败记录_Id.Nextval,
       病人来源_In,
       病人ID_In,
       主页ID_In,
       挂号单号_In,
       发送号_In,
       体检任务ID_In,
       体检报到号_In,
       发送类型_In,
       sysdate,
       0);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS医嘱失败记录_Insert;

  --8、更新医嘱操作失败记录
  Procedure RIS医嘱失败记录_重发(ID_In       In RIS医嘱失败记录.ID%Type,
                         操作类型_In In Number) Is
    v_重发次数 RIS医嘱失败记录.重发次数%Type;
  Begin
    --操作类型_In -- 1 重发成功，删除记录；2--重发失败
  
    if 操作类型_In = 1 then
      delete from RIS医嘱失败记录 where ID = ID_In;
    else
      select 重发次数
        into v_重发次数
        from RIS医嘱失败记录
       where ID = ID_In;
      if v_重发次数 >= 99 then
        v_重发次数 := 99;
      else
        v_重发次数 := v_重发次数 + 1;
      end if;
      update RIS医嘱失败记录
         set 发送时间 = sysdate, 重发次数 = v_重发次数
       where ID = ID_In;
    end if;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS医嘱失败记录_重发;

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据(医嘱ID_In In 病人医嘱发送.医嘱ID%Type,
                      No_In     In 病人医嘱发送.No%Type,
                      Action_In In number) Is
    -- Action_In: 1 重建单据；2 取消重建单据
    v_No 病人医嘱发送.no%Type;
  Begin
    if Action_In = 1 then
      select NextNo(14) into v_No from dual;
    
      update 病人医嘱发送
         set no = v_No, 计费状态 = 0
       where 医嘱ID in (select id
                        from 病人医嘱记录
                       where id = 医嘱ID_In
                          or 相关ID = 医嘱ID_In);
      update 住院费用记录 set 医嘱序号 = null where no = No_In;
    elsif Action_In = 2 then
      update 住院费用记录 set 医嘱序号 = 医嘱ID_In where no = No_In;
      update 病人医嘱发送
         set no = No_In, 计费状态 = 4
       where 医嘱ID in (select id
                        from 病人医嘱记录
                       where id = 医嘱ID_In
                          or 相关ID = 医嘱ID_In);
    end if;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 病人医嘱_重建单据;

  --10、打印RIS检查预约通知单
  Procedure RIS检查预约_打印(医嘱ID_In In RIS检查预约.医嘱ID%Type) Is
  Begin
    Update RIS检查预约 SET 是否打印 = 1 where 医嘱ID = 医嘱ID_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End RIS检查预约_打印;

  --11、更新RIS分科室启用参数
  Procedure RIS启用控制_Update(检查类型_In RIS启用控制.检查类型%Type,
                           场合_In     RIS启用控制.场合%Type,
                           部门ids_In  Varchar2,
                           启用类型_In Number) Is
  
    l_部门id   t_Numlist := t_Numlist();
    v_启用RIS  RIS启用控制.是否启用RIS%Type;
    v_启用预约 RIS启用控制.是否启用预约%Type;
  
    Cursor c_Dept(Dept_In Varchar2) Is
      Select Column_Value From Table(f_Num2list(Dept_In));
  Begin
  
    if 启用类型_In = 1 then
      v_启用RIS  := 1;
      v_启用预约 := null;
      Delete From RIS启用控制
       Where 检查类型 = 检查类型_In
         and 场合 = 场合_In
         and 是否启用RIS = 1;
    else
      v_启用RIS  := null;
      v_启用预约 := 1;
      Delete From RIS启用控制
       Where 检查类型 = 检查类型_In
         and 场合 = 场合_In
         and 是否启用预约 = 1;
    end if;
  
    if 部门ids_In is null then
      Insert Into RIS启用控制
        (ID, 检查类型, 场合, 部门id, 是否启用RIS, 是否启用预约)
      Values
        (ris启用控制_id.nextval,
         检查类型_In,
         场合_In,
         null,
         v_启用RIS,
         v_启用预约);
    else
      Open c_Dept(部门ids_In);
      Fetch c_Dept Bulk Collect
        Into l_部门id;
      Close c_Dept;
    
      Forall I In 1 .. l_部门id.Count
        Insert Into RIS启用控制
          (ID, 检查类型, 场合, 部门id, 是否启用RIS, 是否启用预约)
        Values
          (ris启用控制_id.nextval,
           检查类型_In,
           场合_In,
           l_部门id(I),
           v_启用RIS,
           v_启用预约);
    end if;
  
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End RIS启用控制_Update;

  --12、删除RIS分科室启用参数
  Procedure RIS启用控制_Delete Is
  
  Begin
    Delete From RIS启用控制;
  Exception
    When Others Then
      Zl_Errorcenter(Sqlcode, Sqlerrm);
  End RIS启用控制_Delete;

End b_Zlxwinterface;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查条件_Update
(
  类别_In In 处方审查条件.类别%Type,
  序号_In In Number,
  Ids_In  In Varchar2
) Is

  --v_Err_Msg Varchar2(2000);
  --Err_Item Exception;

Begin

  If 序号_In = 1 Then
    Delete 处方审查条件;
  End If;

  If 类别_In = 1 Then
    --科室
    Insert Into 处方审查条件
      (ID, 类别, 科室id)
      Select 处方审查条件_Id.Nextval, 类别_In, Column_Value From Table(f_Num2list(Ids_In));
  Elsif 类别_In = 2 Then
    --医生
    Insert Into 处方审查条件
      (ID, 类别, 医生id)
      Select 处方审查条件_Id.Nextval, 类别_In, Column_Value From Table(f_Num2list(Ids_In));
  Elsif 类别_In = 3 Then
    --诊断
    Insert Into 处方审查条件
      (ID, 类别, 诊断id)
      Select 处方审查条件_Id.Nextval, 类别_In, Column_Value From Table(f_Num2list(Ids_In));
  Elsif 类别_In = 4 Then
    --疾病
    Insert Into 处方审查条件
      (ID, 类别, 疾病id)
      Select 处方审查条件_Id.Nextval, 类别_In, Column_Value From Table(f_Num2list(Ids_In));
  Elsif 类别_In = 5 Then
    --药名
    Insert Into 处方审查条件
      (ID, 类别, 药名id)
      Select 处方审查条件_Id.Nextval, 类别_In, Column_Value From Table(f_Num2list(Ids_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查条件_Update;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl_处方审查项目_Update
(
  项目id_In       In 处方审查项目.Id%Type,
  类别_In         In 处方审查项目.类别%Type,
  编码_In         In 处方审查项目.编码%Type,
  简称_In         In 处方审查项目.简称%Type,
  内容_In         In 处方审查项目.内容%Type,
  是否门诊启用_In In 处方审查项目.是否门诊启用%Type,
  是否住院启用_In In 处方审查项目.是否住院启用%Type,
  服务对象_In     In 处方审查项目.服务对象%Type,
  Pass结果_In     In 处方审查项目.Pass结果%Type,
  操作人_In       In 处方审查项目.操作人%Type,
  是否作废_In     In Number := Null
) Is

  n_Count Number(18);
  n_Id    Number(18);

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  --检查项目ID是否存在
  Select Count(1) Into n_Count From 处方审查项目 Where ID = 项目id_In;

  If n_Count = 0 Then
    If 类别_In = 4 Then
      --类别“4=自定义”
      If Nvl(项目id_In, 0) <= 0 Then
        --产生ID
        Select 处方审查项目_Id.Nextval Into n_Id From Dual;
      Else
        n_Id := 项目id_In;
      End If;
      Insert Into 处方审查项目
        (ID, 类别, 编码, 简称, 内容, 是否门诊启用, 是否住院启用, 服务对象, Pass结果, 操作人, 操作时间, 作废时间)
      Values
        (n_Id, 类别_In, 编码_In, 简称_In, 内容_In, 是否门诊启用_In, 是否住院启用_In, 服务对象_In, Null, 操作人_In, Sysdate, Null);
    Else
      v_Err_Msg := '未找到项目数据！';
      Raise Err_Item;
    End If;
  Else
    If 类别_In = 1 Then
      --1=处方管理办法7项
      Update 处方审查项目
      Set 是否门诊启用 = 是否门诊启用_In, 是否住院启用 = 是否住院启用_In, 操作人 = 操作人_In, 操作时间 = Sysdate
      Where ID = 项目id_In;
    Elsif 类别_In = 2 Then
      --2=处方点评管理规范28项
      Update 处方审查项目
      Set 是否门诊启用 = 是否门诊启用_In, 是否住院启用 = 是否住院启用_In, 操作人 = 操作人_In, 操作时间 = Sysdate
      Where ID = 项目id_In;
    Elsif 类别_In = 3 Then
      --3=固定
      Update 处方审查项目
      Set 是否门诊启用 = 是否门诊启用_In, 是否住院启用 = 是否住院启用_In, Pass结果 = Pass结果_In, 操作人 = 操作人_In, 操作时间 = Sysdate
      Where ID = 项目id_In;
    Elsif 类别_In = 4 Then
      --4=自定义
      If 是否作废_In = 1 Then
        --检查“处方审查结果”是否使用
        Select Count(1) Into n_Count From 处方审查结果 Where 审查项目id = 项目id_In;
        If n_Count <= 0 Then
          Delete 处方审查项目 Where ID = 项目id_In;
        Else
          Update 处方审查项目 Set 作废时间 = Sysdate Where ID = 项目id_In;
        End If;
      Else
        Update 处方审查项目
        Set 编码 = 编码_In, 简称 = 简称_In, 内容 = 内容_In, 是否门诊启用 = 是否门诊启用_In, 是否住院启用 = 是否住院启用_In, 操作人 = 操作人_In, 操作时间 = Sysdate
        Where ID = 项目id_In;
      End If;
    Else
      v_Err_Msg := '项目的类别不正确！';
      Raise Err_Item;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查项目_Update;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查_Insert
(
  审方id_In     In 处方审查记录.Id%Type,
  病人id_In     In 处方审查记录.病人id%Type,
  挂号id_In     In 处方审查记录.挂号id%Type,
  主页id_In     In 处方审查记录.主页id%Type,
  提交科室id_In In 处方审查记录.提交科室id%Type,
  提交人_In     In 处方审查记录.提交人%Type,
  发药药房id_In In 处方审查记录.发药药房id%Type,
  医嘱id_In     In Varchar2
) Is

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  --插入待审查记录
  If Nvl(挂号id_In, 0) > 0 Then
    Insert Into 处方审查记录
      (ID, 病人id, 挂号id, 提交人, 提交时间, 提交科室id, 发药药房id, 状态)
    Values
      (审方id_In, 病人id_In, 挂号id_In, 提交人_In, Sysdate, 提交科室id_In, 发药药房id_In, 0);
  Else
    Insert Into 处方审查记录
      (ID, 病人id, 主页id, 提交人, 提交时间, 提交科室id, 发药药房id, 状态)
    Values
      (审方id_In, 病人id_In, 主页id_In, 提交人_In, Sysdate, 提交科室id_In, 发药药房id_In, 0);
  End If;

  --插入待审查记录对应的医嘱
  For r_Medical In (Select /*+RULE*/
                     ID
                    From 病人医嘱记录 A, Table(f_Num2list(医嘱id_In, ',')) B
                    Where a.Id = b.Column_Value) Loop
    --先修改旧医嘱id的最后提交
    If r_Medical.Id Is Not Null Then
      Update 处方审查明细 Set 最后提交 = Null Where 医嘱id = r_Medical.Id;
    
      Insert Into 处方审查明细 (审方id, 医嘱id, 最后提交) Values (审方id_In, r_Medical.Id, 1);
    End If;
  
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Insert;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查_Auto
(
  审方id_In         In 处方审查结果.审方id%Type,
  审查项目与医嘱_In In Varchar2
) Is

  n_自动审查结果 Number(1);
  n_审查项目id   处方审查结果.审查项目id%Type;
  v_Err_Msg      Varchar2(255);
  Err_Item Exception;
Begin

  --审查项目与医嘱_In 的格式说明
  --如：1_18,111|....
  --说明：1表示自动审查结果；1-合格；2-不合格；
  --      18表示审查项目id；
  --      111表示医嘱id

  For r_Info In (Select /*+RULE*/
                  C1 审查项目id, To_Number(C2) 医嘱id
                 From Table(f_Str2list2(审查项目与医嘱_In, '|', ','))) Loop
    If Instr(r_Info.审查项目id, '_') > 0 Then
      n_自动审查结果 := To_Number(Substr(r_Info.审查项目id, 1, Instr(r_Info.审查项目id, '_') - 1));
      n_审查项目id   := To_Number(Substr(r_Info.审查项目id, Instr(r_Info.审查项目id, '_') + 1));
    Else
      n_自动审查结果 := 0;
      n_审查项目id   := To_Number(r_Info.审查项目id);
    End If;
    If r_Info.医嘱id Is Not Null Then
      --先修改旧医嘱id的最后提交
      Update 处方审查结果 Set 最后提交 = Null Where 医嘱id = r_Info.医嘱id;
    
      Insert Into 处方审查结果
        (审方id, 医嘱id, 审查项目id, 最后提交, 自动审查)
      Values
        (审方id_In, Decode(r_Info.医嘱id, 0, Null, r_Info.医嘱id), n_审查项目id, 1, n_自动审查结果);
    Else
      Insert Into 处方审查结果
        (审方id, 医嘱id, 审查项目id, 最后提交, 自动审查)
      Values
        (审方id_In, Null, n_审查项目id, 1, n_自动审查结果);
    End If;
  
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Auto;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl_处方审查_Cancel
(
  医嘱id_In  In Varchar2,
  锁定id_Out Out Varchar2
) Is

  n_Param   Number;
  n_Count   Number;
  v_Lockid  Varchar2(4000);
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  --系统参数检查“处方审查”
  n_Param := Nvl(zl_GetSysParameter(241, Null, 1), 0);
  If n_Param < 1 Or n_Param > 3 Then
    Return;
  End If;

  --取医嘱对应的审方ID
  For r_Info In (Select /* +RULE*/
                 Distinct b.Id, b.状态
                 From 处方审查明细 A, 处方审查记录 B, 病人医嘱记录 C, Table(f_Num2list(医嘱id_In, ',')) D
                 Where a.审方id = b.Id And a.医嘱id = c.Id And c.相关id = d.Column_Value And a.最后提交 = 1 And
                       (b.状态 Between 0 And 1 Or b.状态 Is Null) And c.诊疗类别 In ('5', '6', '7') And b.审查结果 Is Null) Loop
  
    Select Count(1) Into n_Count From 处方审查记录 Where ID = r_Info.Id And 锁定用户 Is Not Null;
    If n_Count = 0 Then
      --未锁定
      If Nvl(r_Info.状态, 0) = 0 Then
        --未审查，直接删除记录
        Delete 处方审查记录 Where ID = r_Info.Id And (状态 = 0 Or 状态 Is Null);
      Elsif r_Info.状态 = 1 Then
        --已审查，调整状态
        Update 处方审查记录 Set 状态 = 状态 + 10 Where ID = r_Info.Id And 状态 = 1;
      End If;
    Else
      --被锁定
      Begin
        Select f_List2str(Cast(Collect(Cast(b.相关id As Varchar2(20))) As t_Strlist), ',')
        Into v_Lockid
        From 处方审查明细 A, 病人医嘱记录 B
        Where a.医嘱id = b.Id And a.审方id = r_Info.Id
        Group By b.相关id;
      Exception
        When Others Then
          v_Lockid := Null;
      End;
    
      If v_Lockid Is Not Null Then
        锁定id_Out := 锁定id_Out || ',' || v_Lockid;
      End If;
    End If;
  
  End Loop;

  If Substr(锁定id_Out, 1, 1) = ',' Then
    锁定id_Out := Substr(锁定id_Out, 2, Length(锁定id_Out));
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Cancel;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查_Update
(
  业务类别_In In Number,
  科室id_In   In 部门表.Id%Type,
  审方id_In   In 处方审查记录.Id%Type
) Is
  --功能：按业务类别，更新处方审查记录的状态
  --参数：
  --  业务类别_In：1-门诊业务；2-住院业务
  --  科室id_In：临床科室ID
  --  审议ID_In：略

  n_Param1  Number(10);
  n_Param2  Number(10);
  n_Count   Number(18);
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  Select Nvl(zl_GetSysParameter('门诊审方时机'), '0') Into n_Param1 From Dual;
  Select Nvl(zl_GetSysParameter('门诊药师离岗时长'), '10') Into n_Param2 From Dual;

  If 业务类别_In = 1 Then
    --门诊业务
    Select Count(1)
    Into n_Count
    From (Select Max(最后操作时间) 最后操作时间
           From 处方审查参数
           Where Nvl(服务对象, 0) = 0) -- And ',' || 来源科室 || ',' Like '%,' || 科室id_In || ',%')
    Where 最后操作时间 >= (Sysdate - n_Param2 / 24 / 60);

    If n_Count = 0 Then
      --长时间未审查，标记2-超时免审
      Update 处方审查记录
      Set 状态 = 2, 锁定用户 = Null, 锁定时间 = Null
      Where (状态 = 0 Or 状态 Is Null) And ID = 审方id_In;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Update;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查参数_Save
(
  类别_In         In Number,
  机器名_In       In 处方审查参数.机器名%Type,
  服务对象_In     In 处方审查参数.服务对象%Type,
  是否开启审方_In In 处方审查参数.是否开启审方%Type := Null,
  来源科室_In     In 处方审查参数.来源科室%Type := Null
) Is

  --功能：保存处方审查参数
  --参数：
  --  类别_In：1-保存来源科室；2-保存最后操作时间
  --  服务对象_In：0-门诊；1-住院
  --  是否开启审方_In：类别_In = 2，该参数有用
  --  来源科室_In：类别_In = 1，该参数有有

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  If 类别_In = 1 Then
    --保存来源科室
    Update 处方审查参数 Set 来源科室 = 来源科室_In Where 机器名 = 机器名_In And 服务对象 = 服务对象_In;
  
    If Sql%RowCount = 0 Then
      Insert Into 处方审查参数
        (机器名, 服务对象, 是否开启审方, 最后操作时间, 来源科室)
      Values
        (机器名_In, 服务对象_In, 0, Sysdate, 来源科室_In);
    End If;
  Elsif 类别_In = 2 Then
    --保存是否开启审方、最后操作时间
    Update 处方审查参数
    Set 是否开启审方 = 是否开启审方_In, 最后操作时间 = Sysdate
    Where 机器名 = 机器名_In And 服务对象 = 服务对象_In;
  
    If Sql%RowCount = 0 Then
      Insert Into 处方审查参数
        (机器名, 服务对象, 是否开启审方, 最后操作时间, 来源科室)
      Values
        (机器名_In, 服务对象_In, 是否开启审方_In, Sysdate, Null);
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查参数_Save;
/

--85987:余智勇,2015-07-02,新增处方审查系统
CREATE OR REPLACE Procedure Zl_处方审查常用理由_Update
(
  功能号_In In Number,
  用户名_In In 处方审查常用理由.用户名%Type,
  内容_In   In 处方审查常用理由.内容%Type
) Is

  --功能：新增、删除处方审查常用理由
  --参数：
  --  功能号_In：1-新增；0-删除

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

Begin

  If 功能号_In = 0 Then
    Delete 处方审查常用理由 Where 用户名 = 用户名_In And 内容 = 内容_In;
  Elsif 功能号_In = 1 Then
    Insert Into 处方审查常用理由 (用户名, 内容) Values (用户名_In, 内容_In);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查常用理由_Update;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl_处方审查记录_Lock
(
  Lock_In     In Number,
  机器名_In   In 处方审查参数.机器名%Type,
  服务对象_In In 处方审查参数.服务对象%Type,
  审方id_In   In 处方审查记录.Id%Type := Null
) Is
  --功能：处方审查记录的加锁、解锁切换
  --参数：
  --  Lock_In：0-解锁；1-加锁
  --  服务对象_In：0-门诊；1-住院

  n_Count   Number(2);
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin

  If Lock_In = 1 Then
  
    --先检查
    Select Count(1) Into n_Count From 处方审查记录 Where ID = 审方id_In;
    If n_Count <= 0 Then
      v_Err_Msg := '该处方审查记录已被删除！';
      Raise Err_Item;
    End If;
    
    Select Count(1) Into n_Count From 处方审查记录 Where ID = 审方id_In And 状态 = 0;
    If n_Count <= 0 Then
      v_Err_Msg := '该处方审查记录已被审查！';
      Raise Err_Item;
    End If;

    --加锁
    If Nvl(审方id_In, 0) > 0 Then
      Update 处方审查参数 Set 最后操作时间 = Sysdate Where 机器名 = 机器名_In And 服务对象 = 服务对象_In;
    
      Update 处方审查记录
      Set 锁定用户 = Upper(User), 锁定时间 = Sysdate
      Where ID = 审方id_In And (锁定用户 Is Null Or 锁定用户 = Upper(User));
      If Sql%NotFound Then
        v_Err_Msg := '该处方审查记录已被其他人锁定！';
        Raise Err_Item;
      End If;
    End If;
  
  Else
  
    --解锁
    Update 处方审查参数 Set 最后操作时间 = Sysdate Where 机器名 = 机器名_In And 服务对象 = 服务对象_In;
  
    If Nvl(审方id_In, 0) = 0 Then
      --所有当前用户的锁定记录
      Update 处方审查记录 Set 锁定用户 = Null, 锁定时间 = Null Where 锁定用户 = Upper(User);
    Else
      Update 处方审查记录 Set 锁定用户 = Null, 锁定时间 = Null Where ID = 审方id_In And 锁定用户 = Upper(User);
      If Sql%NotFound Then
        v_Err_Msg := '该处方审查记录已被其他人解锁！';
        Raise Err_Item;
      Else
        --解锁超一小时锁定的记录
        Update 处方审查记录
        Set 锁定用户 = Null, 锁定时间 = Null
        Where 锁定时间 < Sysdate - 1 / 24 And 锁定用户 = Upper(User);
      End If;
    End If;
  
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查记录_Lock;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl_处方审查_Audit
(
  审方id_In   In 处方审查记录.Id%Type,
  审查结果_In In 处方审查记录.审查结果%Type,
  审查人_In   In 处方审查记录.审查人%Type,
  综合理由_In In 处方审查记录.综合理由%Type
) Is
  --功能：提交处方审查记录信息
  n_Count   Number(18);
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin

  --检查审查记录是否被撤销；状态：2-免审；11-撤销
  Select Count(1) Into n_Count From 处方审查记录 Where ID = 审方id_In And 状态 >= 2;
  If n_Count > 0 Then
    v_Err_Msg := '该病人的记录已被撤销或已调整为免审！';
    Raise Err_Item;
  End If;

  --处理审查
  Update 处方审查记录
  Set 审查结果 = 审查结果_In, 审查人 = 审查人_In, 审查时间 = Sysdate, 综合理由 = 综合理由_In, 状态 = 1, 锁定用户 = Null, 锁定时间 = Null
  Where ID = 审方id_In And 审查时间 Is Null;
  If Sql%NotFound Then
    v_Err_Msg := '该病人的记录已被其他人审查！';
    Raise Err_Item;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Audit;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl_处方审查_Audit_Detail
(
  审方id_In     In 处方审查结果.审方id%Type,
  医嘱id_In     In 处方审查结果.医嘱id%Type,
  审查项目id_In In 处方审查结果.审查项目id%Type,
  药师审查_In   In 处方审查结果.药师审查%Type
) Is
  --功能：提交处方审查结果信息(药师审查信息)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin

  --更新旧医嘱ID的“最后提交”
  Update 处方审查结果 Set 最后提交 = Null Where 最后提交 Is Not Null And 医嘱id = 医嘱id_In;

  --更新药师审查信息
  Update 处方审查结果
  Set 最后提交 = Decode(Nvl(医嘱id_In, 0), 0, Null, 1), 药师审查 = 药师审查_In
  Where Nvl(医嘱id, 0) = Nvl(医嘱id_In, 0) And 审查项目id = 审查项目id_In And 审方id = 审方id_In;
  If Sql%NotFound Then
    Insert Into 处方审查结果
      (审方id, 医嘱id, 审查项目id, 最后提交, 药师审查, 自动审查)
    Values
      (审方id_In, 医嘱id_In, 审查项目id_In, Decode(Nvl(医嘱id_In, 0), 0, Null, 1), 药师审查_In, Null);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_处方审查_Audit_Detail;
/

--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Function Zl_Fun_Pati_Calorie
(
  病人id_In In 病人信息.病人id%Type,
  主页id_In In 病人信息.主页id%Type,
  挂号id_In In 病人挂号记录.Id%Type
) Return Varchar2 Is

  --功能：通过病人信息，计算出病人的热量需要量
  v_Return  Varchar2(500);
  n_Sex     Number(1);
  n_Age     Number(5);
  n_Age_Var Number(10, 2);
  n_High    Number(5);
  n_Weight  Number(5);
  n_Calorie Number(10);
  n_Err     Number(1) := 1;
  v_Tmp     Varchar2(500);

  --获取年龄字符串的数值
  Function Get_Age(年龄_In In Varchar2) Return Number Is
    v_Tmp Varchar2(100) := '';
    N     Number(3) := 1;
  Begin
    Loop
      If N > Length(年龄_In) Then
        Exit;
      End If;
      If Regexp_Like(Substr(年龄_In, N, 1), '[0-9]') Then
        v_Tmp := v_Tmp || Substr(年龄_In, N, 1);
      Else
        Exit;
      End If;
      N := N + 1;
    End Loop;
  
    Return v_Tmp;
  End;

Begin

  If 主页id_In Is Null And 挂号id_In Is Null Then
    Return Null;
  End If;

  --性别
  Begin
    Select Decode(性别, '男', 1, '女', 2, Null), 年龄 Into n_Sex, v_Tmp From 病人信息 Where 病人id = 病人id_In;
  Exception
    When Others Then
      Select Null, Null Into n_Sex, v_Tmp From Dual;
  End;

  --年龄
  If v_Tmp Is Null Then
    Select 0, 0, 0 Into n_Age, n_Age_Var, n_Err From Dual;
  Else
    If v_Tmp Like '%岁%' Then
      n_Age     := Get_Age(v_Tmp);
      n_Age_Var := 1;
    Elsif v_Tmp Like '%月%' Then
      n_Age     := Get_Age(v_Tmp);
      n_Age_Var := Round(1 / 12, 2);
    Elsif v_Tmp Like '%天%' Or v_Tmp Like '%日%' Then
      n_Age     := Get_Age(v_Tmp);
      n_Age_Var := Round(1 / 365, 2);
    Elsif v_Tmp Like '%小时%' Or v_Tmp Like '%分%' Then
      n_Age     := 1;
      n_Age_Var := Round(1 / 365, 2);
    Else
      Select 0, 0, 0 Into n_Age, n_Age_Var, n_Err From Dual;
    End If;
  End If;

  If 主页id_In Is Not Null Then
    --住院
  
    --身高
    Begin
      Select 身高, 体重 Into n_High, n_Weight From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
      If Nvl(n_High, 0) = 0 Or Nvl(n_Weight, 0) = 0 Then
        n_Err := 0;
      End If;
    Exception
      When Others Then
        Select 0, 0, 0 Into n_High, n_Weight, n_Err From Dual;
    End;
  
  Else
    --门诊
  
    --身高
    Begin
      Select b.记录内容
      Into n_High
      From 病人护理记录 A, 病人护理内容 B
      Where a.Id = b.记录id And a.病人id = 病人id_In And a.主页id = 挂号id_In And a.病人来源 = 1 And b.项目名称 = '身高';
    Exception
      When Others Then
        Select 0, 0 Into n_High, n_Err From Dual;
    End;
  
    --体重
    Begin
      Select b.记录内容
      Into n_Weight
      From 病人护理记录 A, 病人护理内容 B
      Where a.Id = b.记录id And a.病人id = 病人id_In And a.主页id = 挂号id_In And a.病人来源 = 1 And b.项目名称 = '体重';
    Exception
      When Others Then
        Select 0, 0 Into n_Weight, n_Err From Dual;
    End;
  
  End If;

  --计算需要量
  Select Nvl(n_High, 0), Nvl(n_Weight, 0) Into n_High, n_Weight From Dual;
  If n_Sex = 1 Then
    n_Calorie := 66.5 + 13.8 * n_Weight + 5.0 * n_High - 6.8 * n_Age * n_Age_Var;
    If n_Err = 0 Then
      v_Return := '66.5 + 13.8 * ' || n_Weight || 'KG + 5.0 * ' || n_High || 'CM - 6.8 * ' ||
                  Round(n_Age * n_Age_Var, 2) || '岁 = 异常';
    Else
      v_Return := '66.5 + 13.8 * ' || n_Weight || 'KG + 5.0 * ' || n_High || 'CM - 6.8 * ' ||
                  Round(n_Age * n_Age_Var, 2) || '岁 = ' || n_Calorie;
    End If;
  Else
    n_Calorie := 655.1 + 9.6 * n_Weight + 1.8 * n_High - 4.7 * n_Age * n_Age_Var;
    If n_Err = 0 Then
      v_Return := '655.1 + 9.6 * ' || n_Weight || 'KG + 1.8 * ' || n_High || 'CM - 4.7 * ' ||
                  Round(n_Age * n_Age_Var, 2) || '岁 = 异常';
    Else
      v_Return := '655.1 + 9.6 * ' || n_Weight || 'KG + 1.8 * ' || n_High || 'CM - 4.7 * ' ||
                  Round(n_Age * n_Age_Var, 2) || '岁 = ' || n_Calorie;
    End If;
  End If;

  Return v_Return;

End Zl_Fun_Pati_Calorie;
/

--100191:梁经伙,2016-09-05,对 疾病阳性记录 表做数据转出处理
--85987:余智勇,2015-07-02,新增处方审查系统
--100994:张永康,2016-09-21,玉溪医院历史数据转出测试集中修改
Create Or Replace Procedure Zl1_Datamove_Reb
(
  System_In    In Number,
  Speedmode_In In Number,
  Func_In      In Number,
  Enable_In    In Number := 0,
  Parallel_In  In Number := 0,
  Rebscope_In  In Number := 0
) As
  --功能：在历史数据转出之前，禁用触发器、自动作业、约束、索引，转出之后启用这些对象，以及重建待转出索引，收回标记转出所用索引的空间 
  --参数： 
  --System_In:    应用系统编号,100=标准版 
  --speedmode_in：数据转出模式，0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快已转数据的删除操作） 
  --func_in:      1=触发器，2=自动作业，3=约束，4=索引，5=重建待转出索引，6-收回标记转出所用索引的空间，7-重组表的存储空间（move），并恢复被禁用的约束和索引 ,8-重建标记转出查询所需索引以外的其他索引 
  --Enable_in:    0-禁用，1=启用，对func_in值为1-4有效 
  --rebScope_in:   Func_In=6时，指重建索引的范围(0-经济核算类,1-经济核算类及医嘱类,2-全部)，Func_In=7时指Move表的范围(0-经济核算类，1-全部) 

  v_Sql      Varchar2(4000);
  n_Do       Number(1);
  n_Parallel Number(1);
  v_Tbs      Varchar2(100);
  v_Prompt   Varchar2(100);
  d_Curdate  Date;

  --功能：1.禁用或启用引用转出表主键的他表外键,避免删除主表记录时对子表每行记录执行一次SQL查询或删除 
  --      2.禁用或启用主键或唯一键约束（禁用时会自动删除对应的索引，启用时自动创建），以提高数据删除性能 
  --例如：病人医嘱发送_FK_医嘱ID，如果这些外键所在的表，数据未转出（未在zlbaktables表中定义），执行前会检查并限制转出。 
  Procedure Setconstraintstatus As
    v_Pcol Varchar2(50);
    v_Fcol Varchar2(50);
    v_Del  Varchar2(4000);
  Begin
    --禁用时，先禁用引用转出表主键的他表外键，再禁用转出表的主键 
    If Enable_In = 0 Then
      --1.在线模式转出时，由于有业务产生删除操作，所以，对于级联删除的外键，用触发器来替代对子表数据的删除操作
      If Speedmode_In = 0 Then
        For Rp In (Select Distinct a.Table_Name As Ptable_Name, a.Constraint_Name
                   From User_Constraints A, User_Constraints C, zlBakTables B
                   Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                         c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And
                         c.Delete_Rule = 'CASCADE'
                   Order By a.Table_Name) Loop
        
          Select f_List2str(Cast(Collect(Column_Name Order By Position) As t_Strlist))
          Into v_Pcol
          From User_Cons_Columns
          Where Constraint_Name = Rp.Constraint_Name;
        
          v_Del := '';
          For Rf In (Select b.Table_Name, b.Constraint_Name,
                            f_List2str(Cast(Collect(b.Column_Name Order By b.Position) As t_Strlist)) As r_Col
                     From User_Constraints A, User_Cons_Columns B
                     Where a.r_Constraint_Name = Rp.Constraint_Name And a.Constraint_Name = b.Constraint_Name
                     Group By b.Table_Name, b.Constraint_Name) Loop
            If Instr(v_Pcol, ',') > 0 Then
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where (' || Rf.r_Col ||
                       ') in ((:Old.' || Replace(v_Pcol, ',', ',:Old.') || '));';
            Else
              v_Del := v_Del || Chr(10) || '        Delete ' || Rf.Table_Name || ' Where ' || Rf.r_Col || ' = :Old.' ||
                       v_Pcol || ';';
            End If;
          End Loop;
        
          v_Sql := 'Create Or Replace Trigger ' || Rp.Ptable_Name || '_Cascade_Del' || Chr(10) ||
                   '    After Delete On ' || Rp.Ptable_Name || Chr(10) || '    For Each Row' || Chr(10) || 'Begin' ||
                   Chr(10) || '    If :Old.待转出 Is Null Then ' || v_Del || Chr(10) || '    End If; ' || Chr(10) ||
                   'End ' || Rp.Ptable_Name || '_Cascade_Del;';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.禁用引用转出表主键的他表外键
      For R In (Select c.Table_Name, c.Constraint_Name, a.Table_Name As Ptable_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'ENABLED'
                Order By a.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.禁用主键或唯一键索引(离线转出时)
      If Speedmode_In = 1 Then
        --必须删除索引，否则即使skip_unusable_indexes为true，也无法删除存在Unusable状态的唯一性索引的表中的记录
        --保留转出标记中的SQL查询所需的索引(主键和唯一键对应的索引) 
        For R In (Select a.Table_Name, a.Constraint_Name
                  From User_Constraints A, zlBakTables T, User_Tables B
                  Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'ENABLED' And
                        a.Constraint_Type In ('P', 'U') And a.Table_Name = b.Table_Name And b.Iot_Type Is Null And
                        a.Constraint_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
                  Order By Constraint_Name) Loop
          v_Sql := 'Alter Table ' || r.Table_Name || ' Disable Constraint ' || r.Constraint_Name ||
                   ' Cascade Drop Index';
          Execute Immediate v_Sql;
        End Loop;
      End If;
    Else
      --启用时
      --1.先启用主键和唯一键，再启用引用转出表主键的他表外键 
      If Speedmode_In = 1 Then
        --先重建索引，再启用约束，以便重建索引时利用并行执行缩短时间，并且启用约束时也可以采用novalidate方式 
        For R In (Select d.Table_Name, d.Constraint_Name,
                         f_List2str(Cast(Collect(d.Column_Name Order By d.Position) As t_Strlist)) Colstr
                  From User_Cons_Columns D,
                       (Select a.Table_Name, a.Constraint_Name
                         From User_Constraints A, zlBakTables T
                         Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And a.Status = 'DISABLED' And
                               a.Constraint_Type In ('P', 'U')) A
                  Where a.Constraint_Name = d.Constraint_Name And a.Table_Name = d.Table_Name
                  Group By d.Table_Name, d.Constraint_Name
                  Order By Constraint_Name) Loop
        
          Update zlDataMove Set 说明 = '正在恢复约束:' || r.Constraint_Name Where 系统 = 100 And 组号 = 1;
        
          Select Tablespace_Name Into v_Tbs From User_Indexes Where Table_Name = r.Table_Name And Rownum < 2;
        
          --禁用主键或唯一键时，索引是被删除了的，所以这里要用Create 
          v_Sql := 'Create Unique Index ' || r.Constraint_Name || ' On ' || r.Table_Name || '(' || r.Colstr ||
                   ') Tablespace ' || v_Tbs || ' Nologging';
          Begin
            Execute Immediate v_Sql;
          Exception
            When Others Then
              Null; --可能有些主键或唯一键不是本次转出期间被禁用的，之前就存在不唯一数据，创建唯一索引会出错 
          End;
        
          --会自动建立约束与索引的关联 
          v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    
      --2.启用引用转出表主键的他表外键 
      For R In (Select c.Table_Name, c.Constraint_Name
                From User_Constraints A, User_Constraints C, zlBakTables B
                Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And a.Constraint_Type In ('P', 'U') And
                      c.r_Constraint_Name = a.Constraint_Name And c.Constraint_Type = 'R' And c.Status = 'DISABLED'
                Order By a.Table_Name) Loop
        --为了加快速度，采用novalidate，不验证已有数据 
        --可能引用转出表主键的他表，在zlbaktables中定义了，但没有编写对应的数据转出脚本，未验证的数据可能有违反约束的情况。 
        v_Sql := 'Alter Table ' || r.Table_Name || ' Enable Novalidate Constraint ' || r.Constraint_Name;
        Execute Immediate v_Sql;
      End Loop;
    
      --3.在线模式转出时，删除之前创建的用来替代级联删除外键的触发器
      If Speedmode_In = 0 Then
        For R In (Select a.Trigger_Name
                  From User_Triggers A, zlBakTables B
                  Where a.Table_Name = b.表名 And b.直接转出 = 1 And b.系统 = System_In And
                        Trigger_Name = Table_Name || '_CASCADE_DEL' And Triggering_Event = 'DELETE') Loop
          v_Sql := 'Drop Trigger ' || r.Trigger_Name;
          Execute Immediate v_Sql;
        End Loop;
      End If;
    End If;
  End Setconstraintstatus;

  --功能：高速模式时禁用LOB以外的所有索引，在线模式时仅禁用转出表引用非转出表的外键索引(例如：病人医嘱计价_IX_收费细目ID) 
  --说明：禁用索引是为了提高删除数据的性能 
  Procedure Setindexstatus As
  Begin
    If Speedmode_In = 1 Then
      --保留转出标记中的SQL查询所需的索引 
      For R In (Select /*+ rule*/
                 a.Index_Name
                From User_Indexes A, zlBakTables T
                Where a.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And t.直接转出 = 1 And
                      a.Index_Name <> a.Table_Name || '_IX_待转出' And
                      a.Index_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In) And
                      a.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And a.Index_Type = 'NORMAL' And Not Exists
                 (Select 1
                       From User_Constraints C
                       Where c.Index_Name = a.Index_Name And c.Constraint_Type In ('P', 'U'))
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
          Execute Immediate v_Sql;
        Else
          Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
          Begin
            Execute Immediate v_Sql;
            --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
          
          Exception
            When Others Then
              If SQLErrM Like 'ORA-00054%' Then
                v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
                Execute Immediate v_Sql;
              End If;
          End;
        End If;
      End Loop;
    Else
      For R In (Select a.Index_Name
                From (Select d.Table_Name, d.Index_Name,
                              f_List2str(Cast(Collect(d.Column_Name Order By d.Column_Position) As t_Strlist)) Colstr
                       From User_Ind_Columns D, zlBakTables T, User_Indexes C
                       Where c.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And c.Uniqueness = 'NONUNIQUE' And
                             c.Index_Type = 'NORMAL' And c.Status = Decode(Enable_In, 0, 'VALID', 'UNUSABLE') And
                             c.Index_Name = d.Index_Name And c.Table_Name = d.Table_Name
                       Group By d.Table_Name, d.Index_Name) A,
                     (Select e.Table_Name,
                              f_List2str(Cast(Collect(e.Column_Name Order By e.Position) As t_Strlist)) Colstr
                       From User_Cons_Columns E, User_Constraints F, zlBakTables T, User_Constraints C
                       Where e.Table_Name = t.表名 And t.直接转出 = 1 And t.系统 = System_In And
                             e.Constraint_Name = f.Constraint_Name And f.Constraint_Type = 'R' And
                             c.Constraint_Name = f.r_Constraint_Name And c.Table_Name Not In ('病案主页', '病人信息') And
                             Not Exists
                        (Select 1 From zlBakTables G Where g.表名 = c.Table_Name And g.系统 = System_In)
                       Group By e.Table_Name, e.Constraint_Name) B
                Where a.Table_Name = b.Table_Name And a.Colstr = b.Colstr
                Order By Index_Name) Loop
      
        If Enable_In = 0 Then
          --特殊处理：以下两个索引不禁用，是由于药品目录修改规格，财务缴款需要使用 
          If r.Index_Name Not In ('病人医嘱记录_IX_收费细目ID', '药品收发记录_IX_药品ID', '药品收发记录_IX_价格ID') Then
            v_Sql := 'Alter Index ' || r.Index_Name || ' Unusable';
            Execute Immediate v_Sql;
          End If;
        Else
          Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
        
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        End If;
      End Loop;
    End If;
  End Setindexstatus;

  --功能：转出数据期间，停用转出表上的所有触发器，转出后再恢复 
  Procedure Settriggerstatus As
  Begin
    For R In (Select Distinct a.Table_Name, t.停用触发器
              From User_Triggers A, zlBakTables T
              Where a.Status = Decode(Enable_In, 0, 'ENABLED', 'DISABLED') And a.Table_Name = t.表名 And t.直接转出 = 1 And
                    t.系统 = System_In) Loop
      If Enable_In = 0 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' DISABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = 1 Where 系统 = System_In And 表名 = r.Table_Name;
      Elsif Nvl(r.停用触发器, 0) = 1 Then
        v_Sql := 'Alter Table ' || r.Table_Name || ' ENABLE ALL TRIGGERS';
        Update zlBakTables Set 停用触发器 = Null Where 系统 = System_In And 表名 = r.Table_Name;
      End If;
      Execute Immediate v_Sql;
    End Loop;
    Commit;
  End Settriggerstatus;

  --功能：转出数据期间，停用当前所有者的所有自动作业，转出后再启用 
  Procedure Setjobstatus As
    v_Jobs Varchar2(4000);
  Begin
    --停用 
    If Enable_In = 0 Then
      For R In (Select Job From User_Jobs Where Broken = 'N') Loop
        Dbms_Job.Broken(r.Job, True);
        v_Jobs := v_Jobs || ',' || r.Job;
      End Loop;
    
      If v_Jobs Is Not Null Then
        v_Jobs := Substr(v_Jobs, 2);
        Update zlDataMove Set 停用作业号 = v_Jobs Where 系统 = System_In And 组号 = 1;
      End If;
    Else
      --启用 
      Select 停用作业号 Into v_Jobs From zlDataMove Where 系统 = System_In And 组号 = 1;
      If v_Jobs Is Not Null Then
        For R In (Select Job
                  From User_Jobs
                  Where Broken = 'Y' And Job In (Select Column_Value From Table(f_Num2list(v_Jobs)))) Loop
          Dbms_Job.Broken(r.Job, False);
        End Loop;
        Update zlDataMove Set 停用作业号 = Null Where 系统 = System_In And 组号 = 1;
      End If;
    End If;
    --作业设置后必须提交事务才生效 
    Commit;
  End Setjobstatus;
Begin
  If Parallel_In < 2 Then
    Execute Immediate 'Alter Session DISABLE PARALLEL DDL';
  Else
    If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
      --为重建索引设置并行执行（由于通常受限于IO设备的性能，设置太高的并行度反而会降低性能，如有高性能存储设备，可加大并行度） 
      --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢),在后面取消索引的并行度 
      --恢复在线库的约束和索引时，不管是不是在线模式，都加上并行，否则太慢
      Execute Immediate 'Alter Session FORCE PARALLEL DDL PARALLEL ' || Parallel_In;
      n_Parallel := 1;
    End If;
  End If;

  --提高索引创建速度（缩短40%以上的时间）
  If Func_In In (6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    Execute Immediate 'alter session set workarea_size_policy=MANUAL';
  
    --设置直接路径IO的大小
    Execute Immediate 'alter session set events ''10351 trace name context forever, level 128''';
    Execute Immediate 'alter session SET db_file_multiblock_read_count=128';
    Execute Immediate 'alter session set "_sort_multiblock_read_count"=128';
    Begin
      --由于10G的BUG，sort_area_size需执行两次才会生效
      Execute Immediate 'alter session SET sort_area_size=512000000';
      Execute Immediate 'alter session SET sort_area_size=512000000';
    Exception
      When Others Then
        Null; --如果可用内存不足500M，失败则忽略
    End;
    Execute Immediate 'alter session SET db_block_checking=false';
  End If;

  If Func_In In (5, 6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    d_Curdate := Sysdate;
  End If;

  If Func_In = 1 Then
    --1.设置触发器 
    Settriggerstatus;
  Elsif Func_In = 2 Then
    --2.设置自动作业 
    Setjobstatus;
  Elsif Func_In = 3 Then
    --3.设置约束状态    
    Setconstraintstatus;
    v_Prompt := '恢复禁用的约束';
  Elsif Func_In = 4 Then
    --4.设置索引状态 
    Setindexstatus;
    v_Prompt := '恢复禁用的索引';
  Elsif Func_In = 5 Then
    --5.重建"待转出"索引    
    For R In (Select Index_Name
              From (Select b.Index_Name
                     From zlBakTables A, User_Indexes B
                     Where a.表名 = b.Table_Name And a.直接转出 = 1 And a.系统 = System_In And
                           b.Index_Name = b.Table_Name || '_IX_待转出'
                     Union All
                     Select '病案主页_IX_待转出'
                     From Dual
                     Where System_In = 100)
              Order By 1) Loop
      Update zlDataMove Set 说明 = '正在重建待转出索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
    
      --耗时太短，无须并行DDL 
      --在线转出时如果重建索引会锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
      --在线重建索引太慢，所以，即使在线转出模式也不用在线重建
      v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Begin
        Execute Immediate v_Sql;
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
    v_Prompt := '重建待转出索引';
  
  Elsif Func_In = 6 Then
    --6.重建标记转出查询所用到的索引（测试表明重建后最多可缩短一半的查询时间） 
    --根据业务的启用阶段来决定重建哪些索引，以避免一些不必要的重建耗时    
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.表名 = b.Table_Name And a.系统 = System_In And
                    (b.Table_Name, b.Index_Name) In
                    (Select 表名, Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
              Order By Index_Name) Loop
      n_Do := 0;
      If Rebscope_In = 0 Then
        If r.组号 < 5 Then
          n_Do := 1; --仅经济核算类 
        End If;
      Elsif Rebscope_In = 1 Then
        If r.组号 < 5 Or r.组号 = 8 Then
          n_Do := 1; --仅经济核算类、医嘱类 
        End If;
      Else
        n_Do := 1;
      End If;
    
      If n_Do = 1 Then
        Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
      
        --v_Sql := 'Alter Index ' || r.Index_Name || ' shrink Space'; 
        --使用shrink方式不能并行执行,试验表明速度比rebuild PARALLEL 8 慢6倍 
        If Speedmode_In = 1 Then
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
        Else
          v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
        End If;
        Begin
          Execute Immediate v_Sql;
          --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源 
        
        Exception
          When Others Then
            If SQLErrM Like 'ORA-00054%' Then
              v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
              Execute Immediate v_Sql;
            End If;
        End;
      End If;
    End Loop;
    v_Prompt := '重建标记转出所需索引';
  
    --重组表的数据
  Elsif Func_In = 7 Then
    --rebScope_in=0,只重组组号小于5的经济核算类表（费用、药品、票据），否则全部重组     
    For R In (Select a.表名 As Table_Name
              From zlBakTables A
              Where a.直接转出 = 1 And a.系统 = System_In And (组号 < Decode(Rebscope_In, 0, 5, 100))
              Order By 组号, 序号) Loop
    
      Update zlDataMove Set 说明 = '正在重组表:' || r.Table_Name Where 系统 = 100 And 组号 = 1;
    
      --如果有空闲的空间，最好移到其他表空间，只有这样才能绝对移动文件尾部的数据块，以便进行表空间文件的收缩 
      --在前面设置了会话级的强制并行 
      v_Sql := 'Alter Table ' || r.Table_Name || ' Move Nologging';
      Execute Immediate v_Sql;
    
      --单独移动Lob对象 
      For L In (Select Column_Name, Tablespace_Name From User_Lobs Where Table_Name = r.Table_Name) Loop
        v_Sql := 'Alter Table ' || r.Table_Name || ' Move Lob(' || l.Column_Name || ') Store as (Tablespace ' ||
                 l.Tablespace_Name || ') Nologging';
        Execute Immediate v_Sql;
      End Loop;
    
      v_Sql := 'Alter Table ' || r.Table_Name || ' Noparallel';
      Execute Immediate v_Sql;
    
      --move后，表相关的索引会全部失效，需要全部重建 
      For S In (Select Index_Name
                From User_Indexes
                Where Table_Name = r.Table_Name And Status = 'UNUSABLE'
                Order By Index_Name) Loop
      
        Update zlDataMove Set 说明 = '正在恢复失效索引:' || s.Index_Name Where 系统 = 100 And 组号 = 1;
      
        --在前面设置了会话级的强制并行 
        v_Sql := 'Alter Index ' || s.Index_Name || ' Rebuild Nologging';
        Execute Immediate v_Sql;
      End Loop;
    End Loop;
    v_Prompt := '重组表数据';
  
    --重建转出表上标记转出以外的其他索引（用于转出完成后收回空闲空间）
    --失效的索引不重建，因为转出完后有单独的重建功能
  Elsif Func_In = 8 Then
    For R In (Select b.Index_Name, a.组号
              From User_Indexes B, zlBakTables A
              Where a.表名 = b.Table_Name And a.系统 = System_In And b.Status = 'VALID' And b.Index_Type = 'NORMAL' And
                    b.Index_Name Not Like 'BIN$%' And
                    b.Index_Name Not In (Select Upper(索引名) From Zlbaktableindex Where 系统 = System_In)
              Order By Index_Name) Loop
    
      Update zlDataMove Set 说明 = '正在重建索引:' || r.Index_Name Where 系统 = 100 And 组号 = 1;
    
      If Speedmode_In = 1 Then
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Nologging';
      Else
        v_Sql := 'Alter Index ' || r.Index_Name || ' Rebuild Online Nologging';
      End If;
      Begin
        Execute Immediate v_Sql;
        --在线重建比较慢，不在线重建则需要锁表，如果有其他并发事务，则会出错：ORA-00054: 资源正忙, 但指定以 NOWAIT 方式获取资源    
      Exception
        When Others Then
          If SQLErrM Like 'ORA-00054%' Then
            v_Sql := Replace(v_Sql, 'Rebuild', 'Rebuild Online');
            Execute Immediate v_Sql;
          End If;
      End;
    End Loop;
    v_Prompt := '重建标记转出以外的其他索引';
  End If;

  If Func_In In (5, 6, 7, 8) Or Func_In In (3, 4) And Enable_In = 1 Then
    Update zlDataMove
    Set 说明 = To_Char(Sysdate, 'mm-dd hh24:mi') || v_Prompt || ':' || Trunc((Sysdate - d_Curdate) * 24 * 60) || '分钟'
    Where 系统 = 100 And 组号 = 1;
  End If;

  --执行重建索引后会自动为索引加上并行度属性，如果不取消，会影响相关SQL的执行计划(全表扫描+并行查询，巨慢) 
  --------------------------------------------------------------------------------------------------- 
  If n_Parallel = 1 Then
    Execute Immediate 'ALTER Session DISABLE PARALLEL DDL';
  
    For R In (Select Index_Name From User_Indexes Where Degree Not In ('1', '0')) Loop
      v_Sql := 'Alter Index ' || r.Index_Name || ' Noparallel';
      Execute Immediate v_Sql;
    End Loop;
  End If;

  Commit;
  --本过程不进行错误处理，错误由调用过程处理 
End Zl1_Datamove_Reb;
/

--100994:张永康,2016-09-21,玉溪医院历史数据转出测试集中修改
Create Or Replace Procedure Zl1_Datamove_Merge
(
  v_Keepowner_In  In Varchar2,
  v_Mergeowner_In In Varchar2
) As
  --功能：合并两个历史数据空间 
  --说明：仅将数据从合并空间插入到保留空间，本过程不删除合并空间中的数据，由调用程序通过删除用户和表空间来删除合并空间的数据。
  --      合并之前，界面程序会先禁用保留数据空间上的约束和索引，以提高插入性能。
  --参数：
  --v_Keepowner_In: 保留的历史空间所有者
  --v_Mergeowner_In:合并的历史空间所有者

  Procedure Merge_Data(v_Table In Varchar2) As
    v_Colstr Varchar2(4000);
    v_Sql    Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name
           From All_Tab_Columns
           Where Owner = v_Keepowner_In And Table_Name = v_Table
           Order By Column_Id);
  
    v_Sql := 'Insert Into /*+ append */ ' || v_Keepowner_In || '.' || v_Table || '(' || v_Colstr || ') Select ' ||
             v_Colstr || ' From ' || v_Mergeowner_In || '.' || v_Table;
    Execute Immediate v_Sql;
    --不删除合并表的数据，合并完成后直接删除表空间
  End Merge_Data;

Begin
  For R In (Select 表名, 组号
            From zlBakTables
            Where 系统 In (Select 系统 From zlBakSpaces Where 所有者 = v_Mergeowner_In) And 直接转出 = 1
            Order By 系统, 组号, 序号) Loop
    Merge_Data(r.表名);
    --每张表提交一次，避免Undo过度扩大
    Commit;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Merge;
/

--103500:张永康,2016-12-16,更正门诊预交款是否冲完的判断错误
--100994:张永康,2016-09-21,玉溪医院历史数据转出测试集中修改
--10191:梁经伙,2016-09-05,对 疾病阳性记录 表做数据转出处理
--85987:余智勇,2015-07-02,新增处方审查系统
Create Or Replace Procedure Zl1_Datamove_Tag
(
  d_End    In Date,
  n_批次   In Number,
  n_System In Number
) As
  --功能：标记待转出的数据 
  --说明：为避免Undo表空间膨胀过大，分段提交 

  d_Lastend Date; --最终转出截止时间（d_End为本批转出截止时间）
Begin
  Select 本次最终日期 Into d_Lastend From zlDataMove Where 系统 = n_System And 组号 = 1;
  If d_Lastend Is Null Then
    Return;
  End If;
  --新加子查询注意性能优化，把能够将数据过滤到最小的条件放到最后，Exists类条件放前面

  --1.经济核算（费用,药品,收款和票据等）  
  --冲销业务与原始业务的发生时间相同，登记时间不同，所以要按发生时间来查询.
  --以下情况，可能有多个结帐ID，或涉及多个费用单据，这些数据要一起转出或排除转出，否则影响后续判断是否结清
  --1.一张费用单据的一行费用或多行费用可能分多次结帐（有多个不同的结帐ID）
  --2.结帐作废后也可能分多次结清(一张单据多个不同的结帐ID)
  --3.结帐作废后可能与其他费用单据一起结(一张单据的多个结帐ID，涉及多个费用NO，这些NO可能之前结帐作废过，有其他结帐ID)
  --考虑到这情况的复杂性，为简化逻辑，提升查询性能，按病人ID来排除(该病人的结帐数据都不转出)

  Update /*+ rule*/ 病人预交记录 L
  Set 待转出 = n_批次
  Where 结帐id In
        (Select Distinct a.结帐id --1.门诊收费和挂号的收费结算记录
         From 门诊费用记录 A
         Where a.待转出 Is Null And a.记录性质 In (1, 4) And a.发生时间 < d_End
         Union All
         Select Distinct b.结算id --2.医保补结算(没有发生时间字段,作废记录的登记时间不同，为了把收费和作废的一次性转出，所以要连接B表)
         From 费用补充记录 A, 费用补充记录 B
         Where a.待转出 Is Null And a.No = b.No And a.记录性质 = b.记录性质 And a.登记时间 < d_End
         Union All
         Select Distinct a.结帐id --3.就诊卡的收费结算记录(排除之后退卡费的,一张单据中只要其中一行退了) 
         From 住院费用记录 A
         Where a.待转出 Is Null And a.记帐费用 = 0 And a.记录性质 = 5 And a.发生时间 < d_End
         Union All --4.住院记帐费用的结帐结算记录     
         Select 结帐id
         From (With Settle As (Select Distinct c.结帐id
                               From (Select Distinct b.No, b.序号, Mod(b.记录性质, 10) As 记录性质
                                      From (Select Distinct b.Id
                                             From 病人结帐记录 A, 病人结帐记录 B --作废的结帐单的收费时间可能在指定时间之后，所以要连接B表
                                             Where a.待转出 Is Null And a.No = b.No And (a.结帐类型 = 2 Or Nvl(a.结帐类型, 0) = 0) And
                                                   a.收费时间 < d_End) A, 住院费用记录 B
                                      Where a.Id = b.结帐id) B, 住院费用记录 C --通过C表找到这些费用单据的所有结帐ID一起转(可能在转出时间之后)
                               Where c.No = b.No And Mod(c.记录性质, 10) = b.记录性质 And c.序号 = b.序号)
                Select 结帐id
                From Settle
                Minus
                Select Distinct a.Id
                From 病人结帐记录 A,
                     (Select Distinct c.病人id
                       From 住院费用记录 C, Settle S
                       Where c.结帐id = s.结帐id
                       Group By c.No, Mod(c.记录性质, 10), c.病人id --出院病人没有结清的,如果该病人在最终转出时间之后没有记帐费用，也转走（在需要时再抽回），否则排除的数据量太大
                       Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) And (Exists (Select 1
                                                                                     From 在院病人 F
                                                                                     Where c.病人id = f.病人id) Or Exists (Select 1
                                                                                                                      From 住院费用记录 F
                                                                                                                      Where c.病人id =
                                                                                                                            f.病人id And
                                                                                                                            Mod(f.记录性质,
                                                                                                                                10) In (2,
                                                                                                                                        3) And
                                                                                                                            f.发生时间 >=
                                                                                                                            d_Lastend)) Or Exists (Select 1
                                                                                                                                                  From 住院费用记录 E,
                                                                                                                                                       病人结帐记录 S
                                                                                                                                                  Where e.No = c.No And
                                                                                                                                                        Mod(e.记录性质,
                                                                                                                                                            10) =
                                                                                                                                                        Mod(c.记录性质,
                                                                                                                                                            10) And
                                                                                                                                                        e.结帐id = s.Id And
                                                                                                                                                        s.待转出 Is Null And
                                                                                                                                                        s.收费时间 >=
                                                                                                                                                        d_Lastend)) N --即使是在本批转出时间之后结清，只要不是在最终转出时间之后，就不排除
                Where a.病人id = n.病人id And (a.结帐类型 = 2 Or Nvl(a.结帐类型, 0) = 0))
                Union All --5.门诊记帐费用的结帐结算记录  
                Select 结帐id
                From (With Settle As (Select Distinct c.结帐id
                                      From (Select Distinct b.No, b.序号, Mod(b.记录性质, 10) As 记录性质
                                             From (Select Distinct b.Id
                                                    From 病人结帐记录 A, 病人结帐记录 B
                                                    Where a.待转出 Is Null And a.No = b.No And (a.结帐类型 = 1 Or Nvl(a.结帐类型, 0) = 0) And
                                                          a.收费时间 < d_End) A, 门诊费用记录 B
                                             Where a.Id = b.结帐id) B, 门诊费用记录 C
                                      Where c.No = b.No And Mod(c.记录性质, 10) = b.记录性质 And c.序号 = b.序号)
                       Select 结帐id
                       From Settle
                       Minus
                       Select Distinct a.Id
                       From 病人结帐记录 A,
                            (Select Distinct c.病人id
                              From 门诊费用记录 C, Settle S
                              Where c.结帐id = s.结帐id
                              Group By c.No, Mod(c.记录性质, 10), c.病人id --门诊病人没有结清的，如果该病人在最终转出时间之后没有门诊费用则转走
                              Having Nvl(Sum(c.实收金额), 0) <> Nvl(Sum(c.结帐金额), 0) And Exists (Select 1
                                                                                           From 门诊费用记录 F
                                                                                           Where c.病人id = f.病人id And
                                                                                                 Mod(f.记录性质, 10) = 2 And
                                                                                                 f.发生时间 >= d_Lastend) Or Exists (Select 1
                                                                                                                                From 门诊费用记录 E,
                                                                                                                                     病人结帐记录 S
                                                                                                                                Where e.No = c.No And
                                                                                                                                      Mod(e.记录性质,
                                                                                                                                          10) =
                                                                                                                                      Mod(c.记录性质,
                                                                                                                                          10) And
                                                                                                                                      e.结帐id = s.Id And
                                                                                                                                      s.待转出 Is Null And
                                                                                                                                      s.收费时间 >=
                                                                                                                                      d_Lastend)) N
                       Where a.病人id = n.病人id And (a.结帐类型 = 1 Or Nvl(a.结帐类型, 0) = 0))
                       
         
         
         );

  --排除预交款未冲完的
  --为了降低逻辑的复杂性，不排除在转出时间之后发药或未发药的费用记录对应的结帐ID，将这种情况的结算数据和费用数据强制转走 
  --因为前面的SQL查出的结帐ID可能不全是冲预交的(门诊收费和住院结帐补费等)，所以，需要单独一个SQL来排除 
  --由于可能存在数据异常(住院费用结帐冲预交类别为1的门诊预交)，所以没有加预交类别条件限定  
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = Null
  Where 待转出 = n_批次 And
        结帐id In (Select Distinct d.结帐id --该病人所有冲预交的结帐ID都不转出，不能只管当前预交NO,因为存在一张预交NO被多个结帐ID冲完，这些结帐ID又涉及预交NO、多个费用NO，从而关联到更多的结帐ID
                 From 病人预交记录 D,
                      (Select Distinct l.病人id
                        From (Select l.No, l.病人id, Nvl(Sum(l.金额), 0) As 金额, Nvl(Sum(l.冲预交), 0) As 冲预交,
                                      Sum(Decode(l.待转出, Null, 1, 0)) As 未转出
                               From 病人预交记录 L --可能按结帐ID确认本次待转出的冲的只是剩余款，所以需要连接L表，查原始交预交的单据，以及记录性质为11的可能还有转出时间之后其他冲剩余款的结帐ID 
                               Where l.记录性质 In (1, 11) And l.No In (Select Distinct p.No
                                                        From 病人预交记录 P
                                                        Where p.记录性质 In (1, 11) And p.待转出 = n_批次)
                               Group By l.No, l.病人id) L
                        Where 未转出 > 0 --只要还有未转出的预交或冲预交记录，则不转出，避免转出一部分导致后续判断错误
                              Or l.金额 <> l.冲预交 And (Exists (Select 1
                                                            From 病人预交记录 E --结帐时用负数现金来退款，如果本次转出结帐ID的病人是结清了的（按预交单据来看没有结清），这种就不排除
                                                            Where l.病人id = e.病人id And e.待转出 = n_批次
                                                            Group By e.病人id
                                                            Having Nvl(Sum(l.金额), 0) <> Nvl(Sum(l.冲预交), 0)) Or
                               Exists (Select 1 From 在院病人 E Where l.病人id = e.病人id) Or Exists
                               (Select 1 From 病人未结费用 E Where l.病人id = e.病人id))) N
                 Where d.病人id = n.病人id And d.记录性质 In (1, 11));

  --预交款没有使用就直接退了的记录(结帐ID为空) 
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 记录性质 = 1 And
        NO In (Select a.No
               From 病人预交记录 A
               Where a.结帐id Is Null And a.记录性质 = 1 And a.记录状态 In (2, 3) And a.待转出 Is Null And a.收款时间 < d_End
               Group By a.No
               Having Sum(a.金额) = 0);

  --交预交款后退款的记录（结帐ID为空，记录状态为2）
  Update /*+ rule*/ 病人预交记录
  Set 待转出 = n_批次
  Where 结帐id Is Null And 记录性质 = 1 And 记录状态 = 2 And
        NO In (Select a.No From 病人预交记录 A Where a.待转出 = n_批次 And a.记录性质 = 1 And a.记录状态 = 3);

  Update Zldatamovelog
  Set 当前进度 = '(1/10)结算数据标记完成，正在标记费用数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 病人结帐记录
  Set 待转出 = n_批次
  Where ID In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  --结帐无结算的记录(为了提升性能，不判断费用，只要结了帐且无预交记录就当成是零费用结帐) 
  Update /*+ rule*/ 病人结帐记录 L
  Set 待转出 = n_批次
  Where 收费时间 < d_End And 待转出 Is Null And Not Exists (Select 1 From 病人预交记录 P Where l.Id = p.结帐id);

  Update /*+ rule*/ 病人卡结算对照
  Set 待转出 = n_批次
  Where 预交id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 病人卡结算记录
  Set 待转出 = n_批次
  Where ID In (Select 卡结算id From 病人卡结算对照 Where 待转出 = n_批次);

  Update /*+ rule*/ 三方结算交易
  Set 待转出 = n_批次
  Where 交易id In (Select a.Id From 病人预交记录 A Where 待转出 = n_批次);

  Update /*+ rule*/ 三方退款信息
  Set 待转出 = n_批次
  Where (记录id, 结帐id) In (Select a.Id, a.结帐id From 病人预交记录 A Where 待转出 = n_批次);

  --1.挂号费用异常数据
  --a.结帐ID为空（实收金额可能不为零）
  --b.结帐ID不为空，打折后实收金额为0（应收金额正负冲销）的挂号费用，没有挂号记录，也没有预交记录
  --按发生时间转出，因为收和退的发生时间相同，登记时间不同。
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 待转出 Is Null And 发生时间 < d_End And 记录性质 = 4 And (实收金额 = 0 Or 结帐id Is Null);

  --2.直接收费的和结帐无结算（预交）记录的，Union不加all去掉重复以减少in的数量 
  Update /*+ rule*/ 门诊费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --3.没有结帐id的数据(按发生时间) 
  --a.未结帐的划价记录
  --b.未收费的零费用
  --加条件"待转出 Is Null"是为了处理连续多次标记转出的情况   
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (记录状态 = 0 Or 记录性质 = 1 And 实收金额 = 0 And 结帐金额 = 0) And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --4.没有结帐id的数据(按发生时间) 
  --未结帐的门诊记帐费用(赖账)，该病人没有预交余额，并且病人在最终转出时间之后无未结门诊记帐费用
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where Not Exists (Select 1
         From 病人预交记录 B
         Where b.病人id = a.病人id And b.待转出 Is Null And b.预交类别 = 1 And b.记录性质 In (1, 11) Having
          Nvl(Sum(b.金额), 0) <> Nvl(Sum(b.冲预交), 0)) And Not Exists
   (Select 1
         From 门诊费用记录 B
         Where a.病人id = b.病人id And b.记录性质 = 2 And b.结帐id Is Null And b.待转出 Is Null And b.登记时间 > = d_Lastend) And
        记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --5.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），登记时间可能在当前指定转出时间之后，而原始记帐记录（记录状态为3），登记时间在指定转出时间之前。前后两者的发生时间是相同的。
  --a.未结帐的零记帐费用或打折后实收金额为零的（结帐模块参数没有勾选对零费用结帐）
  --b.结帐作废后，记帐单销帐的记录（结帐ID为空且记录状态为2的），记录状态为3的且有结帐ID的在最前面已转出. 
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (Exists (Select 1
                 From 门诊费用记录 B
                 Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                       b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
          From 门诊费用记录 B
          Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
          Group By b.No, b.记录性质, b.序号
          Having Nvl(Sum(b.实收金额), 0) = 0)) And 记录性质 = 2 And 结帐id Is Null And 待转出 Is Null And 发生时间 < d_End;

  --6.有结帐id的零费用(按发生时间)
  --a.按费别打折后结帐金额为零的收费记录,
  --b.一张单据相同结帐ID的结帐金额之和为0(冲销后为零)
  --即使在转出时间之后发药的，也强制转出（为了减少逻辑复杂性，提高查询性能）
  Update /*+ rule*/ 门诊费用记录 A
  Set 待转出 = n_批次
  Where (结帐金额 = 0 Or Exists
         (Select 1 From 门诊费用记录 C Where a.结帐id = c.结帐id Group By c.结帐id, c.No Having Sum(c.结帐金额) = 0)) And Not Exists
   (Select 1 From 病人预交记录 B Where a.结帐id = b.结帐id And b.待转出 Is Null) And 记录性质 = 1 And 结帐id Is Not Null And
        待转出 Is Null And 发生时间 < d_End;

  Update /*+ rule*/ 医保结算明细
  Set 待转出 = n_批次
  Where 结帐id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 费用补充记录
  Set 待转出 = n_批次
  Where 结算id In (Select 结帐id From 病人预交记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 凭条打印记录
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 门诊费用记录 Where 待转出 = n_批次);

  --1.从预交记录读是为了取就诊卡直接收费的（无结帐ID）,再加结帐记录是为了取结帐无结算（预交）记录的 
  Update /*+ rule*/ 住院费用记录
  Set 待转出 = n_批次
  Where 结帐id In
        (Select 结帐id From 病人预交记录 Where 待转出 = n_批次 Union Select ID From 病人结帐记录 Where 待转出 = n_批次);

  --2.没有结帐id的数据(按发生时间)
  --冲销产生的记帐记录（记录状态为2），原始记录和冲销记录的发生时间是相同的。
  --1)转出结帐作废后，记帐单销帐的记录（记录状态为2，且没有结帐ID，且(记录状态为3的有结帐ID的)在最前面已转出） 
  --2)未结帐的零费用(已冲销的记帐单或打折后实收金额为零) 
  --3)没有结帐ID的划价记录处理为转出
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where ((Exists (Select 1
                  From 住院费用记录 B
                  Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.记录状态 = 3 And b.结帐id Is Not Null And
                        b.待转出 + 0 = n_批次) And 记录状态 = 2 Or Exists
         (Select 1
           From 住院费用记录 B
           Where a.No = b.No And a.记录性质 = b.记录性质 And a.序号 = b.序号 And b.结帐id Is Null
           Group By b.No, b.记录性质, b.序号
           Having Nvl(Sum(b.实收金额), 0) = 0)) And a.记录性质 In (2, 3) Or a.记录状态 = 0) And a.结帐id Is Null And a.待转出 Is Null And
        a.发生时间 < d_End;

  --3.离院未结帐的（赖帐病人），因为是很久以前的这些数据，如果预交已冲完，则处理为要转出 
  Update /*+ rule*/ 住院费用记录 A
  Set 待转出 = n_批次
  Where 待转出 Is Null And 结帐id Is Null And
        (病人id, 主页id) In (Select 病人id, 主页id
                         From 病案主页 C
                         Where 出院日期 < d_End And 待转出 Is Null And 数据转出 Is Null And Not Exists
                          (Select 1
                                From 病人预交记录 B
                                Where b.病人id = c.病人id And b.待转出 Is Null And b.预交类别 = 2 And b.记录性质 In (1, 11) Having
                                 Nvl(Sum(b.金额), 0) <> Nvl(Sum(b.冲预交), 0)));

  Update Zldatamovelog
  Set 当前进度 = '(2/10)费用数据标记完成，正在标记药品数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ Rule*/ 药品收发记录 A
  Set 待转出 = n_批次
  Where Rowid In (Select m.Rowid
                  From 药品收发记录 M, 门诊费用记录 E
                  Where m.费用id = e.Id And (e.记录性质 = 1 And m.单据 In (8, 24) Or e.记录性质 = 2 And m.单据 In (9, 25)) And
                        e.收费类别 In ('4', '5', '6', '7') And e.待转出 = n_批次
                  Union All
                  Select m.Rowid
                  From 药品收发记录 M, 住院费用记录 E
                  Where m.费用id = e.Id And m.单据 In (9, 10, 25, 26) And e.记录性质 = 2 And e.收费类别 In ('4', '5', '6', '7') And
                        e.待转出 = n_批次);

  Update /*+ rule*/ 收发记录补充信息
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输液配药内容
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药记录
  Set 待转出 = n_批次
  Where ID In (Select 记录id From 输液配药内容 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药附费
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 输液配药状态
  Set 待转出 = n_批次
  Where 配药id In (Select ID From 输液配药记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品留存计划
  Set 待转出 = n_批次
  Where 留存id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名明细
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 药品签名明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 药品收发门诊标志 A
  Set 待转出 = n_批次
  Where (a.处方号, a.单据) In (Select b.No, b.单据 From 药品收发记录 B Where b.待转出 = n_批次);

  Update /*+ rule*/ 药品收发住院标志
  Set 待转出 = n_批次
  Where 收发id In (Select ID From 药品收发记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(3/10)药品数据标记完成，正在标记缴款与票据数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 人员借款记录 Set 待转出 = n_批次 Where 待转出 Is Null And 借出时间 < d_End;

  Update /*+ rule*/ 人员收缴记录 Set 待转出 = n_批次 Where 待转出 Is Null And 登记时间 < d_End;

  Update /*+ rule*/ 人员收缴对照
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴明细
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员收缴票据
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录
  Set 待转出 = n_批次
  Where 收缴id In (Select ID From 人员收缴记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 人员暂存记录 Set 待转出 = n_批次 Where 待转出 Is Null And 记录性质 = 1 And 登记时间 < d_End;

  Update /*+ rule*/ 票据领用记录 A
  Set 待转出 = n_批次
  Where Not Exists (Select 1 From 票据使用明细 B Where b.领用id = a.Id And b.使用时间 >= d_Lastend) And 待转出 Is Null And 剩余数量 = 0 And
        登记时间 < d_End;

  Update /*+ rule*/ 票据使用明细
  Set 待转出 = n_批次
  Where 领用id In (Select ID From 票据领用记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 票据打印内容
  Set 待转出 = n_批次
  Where ID In (Select 打印id From 票据使用明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 票据打印明细
  Set 待转出 = n_批次
  Where 使用id In (Select ID From 票据使用明细 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(4/10)缴款与票据数据标记完成，正在标记就诊及诊治数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --2.就诊及诊治数据 
  --不转出的条件：挂号费用未转出的，最终转出时间之后存在医嘱（这些医嘱因为时间没有到，不应转出），医嘱对应的费用未转出的 
  --即使正在就诊(r.执行状态 <> 2 )的也强制转出(医生可能没有使用完成就诊功能)
  Update /*+ rule*/ 病人挂号记录 T
  Set 待转出 = n_批次
  Where Rowid In
        (Select Rowid
         From 病人挂号记录 R
         Where Not Exists (Select 1 From 门诊费用记录 A Where r.No = a.No And a.记录性质 = 4 And a.待转出 Is Null) And Not Exists
          (Select 1
                From 病人医嘱记录 A
                Where a.挂号单 = r.No And a.待转出 Is Null And a.病人来源 <> 4 And Nvl(a.停嘱时间, a.开嘱时间) >= d_Lastend) And
               Not Exists (Select 1
                From 门诊费用记录 E, 病人医嘱记录 A
                Where r.No = a.挂号单 And a.Id = e.医嘱序号 And a.病人来源 <> 4 And e.待转出 Is Null) And
               r.待转出 Is Null And r.发生时间 < d_End);

  --由于有一部分挂号数据未转出，所以，汇总表的数据可能与挂号数据不匹配 
  Update 病人挂号汇总 Set 待转出 = n_批次 Where 待转出 Is Null And 日期 < d_End;
  Update /*+ rule*/ 病人转诊记录 Set 待转出 = n_批次 Where NO In (Select NO From 病人挂号记录 Where 待转出 = n_批次);

  --通过"住院费用记录"来查询，而不是"病人结帐记录",因为离院未结的赖帐病人也转出了费用 
  --出院日期条件仍然需要，因为可能某次结帐转出了，但病人在最终转出截止时间之前并未出院(一次住院多次结帐)。 
  --通过指定索引方式进行特殊优化（缺省采用"病案主页IX_出院日期"索引的效率太低） 
  --不加"数据转出 is null"的条件，因为一次住院多次结帐时，如果跨不同的转出批次(转出截止时间)，该字段将会被更新多次。
  Update /*+ rule*/ 病案主页 P
  Set 待转出 = n_批次
  Where Not Exists
  (Select 1 From 住院费用记录 A Where a.病人id = p.病人id And a.主页id = p.主页id And a.待转出 Is Null) And 待转出 Is Null And
          出院日期 < d_Lastend And (病人id, 主页id) In (Select Distinct 病人id, 主页id From 住院费用记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人过敏记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update /*+ rule*/ 病人手麻记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, ID
                         From 病人挂号记录
                         Where 待转出 = n_批次
                         Union All
                         Select 病人id, 主页id
                         From 病案主页
                         Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(5/10)就诊及诊治数据标记完成，正在标记护理数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --3.护理数据 
  Update /*+ rule*/ 病人护理文件
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理数据
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理明细
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理数据 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人护理打印
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理活动项目
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);
  Update /*+ rule*/ 产程要素内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 病人护理文件 Where 待转出 = n_批次);

  --老版护理系统数据 
  Update /*+ rule*/ 病人护理记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人护理内容
  Set 待转出 = n_批次
  Where 记录id In (Select ID From 病人护理记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(6/10)护理数据标记完成，正在标记病历数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --4.病历数据 
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where 病人来源 <> 4 And (病人id, 主页id) In (Select 病人id, ID
                                       From 病人挂号记录
                                       Where 待转出 = n_批次
                                       Union All
                                       Select 病人id, 主页id
                                       From 病案主页
                                       Where 待转出 = n_批次);

  --自登记类病人(无挂号单号) 
  --病历ID可能重复是因为检验报告之类的，如肝功、肾功共打一张报告，即在病人医嘱报告表中，多个医嘱id对应同一报告ID 
  --为提升性能，不从医嘱发送记录的发送时间查询，不采用精确的时间，因为直接登记的检验医嘱，一般开嘱时间与发送时间相差不大
  Update /*+ rule*/ 电子病历记录
  Set 待转出 = n_批次
  Where ID In (Select c.病历id
               From 病人医嘱记录 B, 病人医嘱报告 C
               Where c.医嘱id = b.Id And Nvl(b.主页id,0) = 0 And b.挂号单 Is Null And
                     b.相关id Is Null And b.待转出 Is Null And b.开嘱时间 < d_End);

  Update /*+ rule*/ 电子病历附件
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 电子病历格式
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历内容
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 电子病历图形
  Set 待转出 = n_批次
  Where 对象id In (Select ID From 电子病历内容 Where 待转出 = n_批次 And 对象类型 = 5);

  Update /*+ rule*/ 病人医嘱报告
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 病历种类 = 7 And 待转出 = n_批次);
  Update /*+ rule*/ 影像报告驳回
  Set 待转出 = n_批次
  Where (医嘱id, 病历id) In (Select 医嘱id, 病历id From 病人医嘱报告 Where 待转出 = n_批次);

  Update /*+ rule*/ 报告查阅记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 病历种类 = 7 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病申报记录
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病报告反馈
  Set 待转出 = n_批次
  Where 文件id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 疾病申报反馈
  Set 待转出 = n_批次
  Where 申报id In (Select ID From 电子病历记录 Where 病历种类 = 5 And 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where 病历id In (Select ID From 电子病历记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(7/10)病历数据标记完成，正在标记临床路径数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --5.临床路径 
  Update /*+ rule*/ 病人临床路径
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径
  Set 待转出 = n_批次
  Where 首要路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人合并路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人出径记录
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人路径执行
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径评估
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径变异
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径指标
  Set 待转出 = n_批次
  Where 路径记录id In (Select ID From 病人临床路径 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人路径医嘱
  Set 待转出 = n_批次
  Where 路径执行id In (Select ID From 病人路径执行 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(8/10)临床路径数据标记完成，正在标记医嘱数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  --6.医嘱，检验，检查 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where 挂号单 In (Select NO From 病人挂号记录 Where 待转出 = n_批次) And 病人来源 <> 4;
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 待转出 = n_批次);

  --自登记类病人(无挂号单)，病人医嘱报告在前面转病历时已转出 
  Update /*+ rule*/ 病人医嘱记录
  Set 待转出 = n_批次
  Where Rowid In (Select b.Rowid
                  From 病人医嘱记录 B, 病人医嘱报告 C
                  Where (b.相关id = c.医嘱id Or b.Id = c.医嘱id) And c.待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱计价
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附费
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱附件
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血申请记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 输血检验结果
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱执行
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人医嘱打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱执行打印
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人诊断医嘱
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 病人诊断记录
  Set 待转出 = n_批次
  Where ID In (Select 诊断id From 病人诊断医嘱 Where 待转出 = n_批次);

  Update /*+ rule*/ 病人医嘱状态
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 医嘱签名记录
  Set 待转出 = n_批次
  Where ID In (Select 签名id From 病人医嘱状态 Where 待转出 = n_批次 And 签名id Is Not Null);

  Update /*+ rule*/ 病人医嘱发送
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 诊疗单据打印
  Set 待转出 = n_批次
  Where (NO, 记录性质) In (Select NO, 记录性质 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行时间
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 医嘱执行计价
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 执行打印记录
  Set 待转出 = n_批次
  Where (医嘱id, 发送号) In (Select 医嘱id, 发送号 From 病人医嘱发送 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查明细
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查记录
  Set 待转出 = n_批次
  Where ID In (Select 审方id From 处方审查明细 Where 待转出 = n_批次);

  Update /*+ rule*/ 处方审查结果
  Set 待转出 = n_批次
  Where 审方id In (Select ID From 处方审查记录 Where 待转出 = n_批次);

  Update /*+ rule*/ Ris检查预约
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 疾病阳性记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(9/10)医嘱数据标记完成，正在标记检查检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 影像检查记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像报告操作记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像检查序列
  Set 待转出 = n_批次
  Where 检查uid In (Select 检查uid From 影像检查记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像检查图象
  Set 待转出 = n_批次
  Where 序列uid In (Select 序列uid From 影像检查序列 Where 待转出 = n_批次);

  Update /*+ rule*/ 影像申请单图像
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像收藏内容
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 影像危急值记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update Zldatamovelog
  Set 当前进度 = '(10/10)影像数据标记完成，正在标记检验数据'
  Where 系统 = n_System And 批次 = n_批次;
  Commit;

  Update /*+ rule*/ 检验标本记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验申请项目
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验项目分布
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验分析记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验操作记录
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验签名记录
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验图像结果
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验试剂记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验拒收记录
  Set 待转出 = n_批次
  Where 医嘱id In (Select ID From 病人医嘱记录 Where 待转出 = n_批次);

  Update /*+ rule*/ 检验普通结果
  Set 待转出 = n_批次
  Where 检验标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验质控报告
  Set 待转出 = n_批次
  Where 结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验药敏结果
  Set 待转出 = n_批次
  Where 细菌结果id In (Select ID From 检验普通结果 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线标本
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);
  Update /*+ rule*/ 检验流水线指标
  Set 待转出 = n_批次
  Where 标本id In (Select ID From 检验标本记录 Where 待转出 = n_批次);

  Commit;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamove_Tag;
/

--100352:冉俊明,2016-09-05,医保病人多单据分单据结算，报销金额大于实收金额时无法结算成功
--99572:冉俊明,2016-08-22,门诊收费历史异常单据处理
Create Or Replace Procedure Zl_门诊收费结算_完成收费
(
  病人id_In     门诊费用记录.病人id%Type,
  结算序号id_In 病人预交记录.结算序号%Type,
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  误差金额_In   门诊费用记录.实收金额%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  预存款_In     病人预交记录.冲预交%Type := Null,
  退支票额_In   病人预交记录.冲预交%Type := Null,
  收费结算_In   Varchar2 := Null
) As
  --功能:完成收费处理
  --入参:结算方式_In-只针对全免费用的数据(即:一张单据中实收金额为零的费用)
  --收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  --预存款_IN:冲预存款
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And 预交类别 = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.预交类别 = 1 And
                 a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And a.病人id = v_病人id
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And 预交类别 = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  Cursor c_Balancedata(n_结帐id 病人预交记录.结帐id%Type) Is
    Select 记录性质, NO, 记录状态, 病人id, 主页id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号


    
    From 病人预交记录
    Where 结帐id = n_结帐id And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  v_误差no     门诊费用记录.No%Type;
  v_Maxno      门诊费用记录.No%Type;
  n_误差结帐id 病人预交记录.结帐id%Type;
  n_Count      Number;
  v_结帐ids    Varchar2(500);
  n_Max结帐id  病人预交记录.结帐id%Type;
  n_执行状态   门诊费用记录.执行状态%Type;
  l_结帐id     t_Numlist := t_Numlist();
  n_病人id     病人预交记录.病人id%Type;
  ------------------------------------------------------------
  --结算方式串
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;

  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算摘要     病人预交记录.摘要%Type;
  n_冲预交       病人预交记录.冲预交%Type;
  n_当前剩余预交 病人预交记录.冲预交%Type;
  --------------------------------------------------------------
  --预存款
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_发送号   病人医嘱发送.发送号%Type;

Begin
  n_Max结帐id  := 0;
  n_误差结帐id := 0;
  v_操作员姓名 := Null;

  For v_结帐 In (Select 结帐id, Max(Decode(结算方式, Null, '-', '')) As 结算方式, Max(Decode(结算方式, Null, 冲预交, 0)) As 冲预交,
                      Max(Decode(记录性质, 1, Null, 11, Null, 操作员姓名)) As 操作员姓名,
                      Max(Decode(记录性质, 1, Null, 11, Null, NO)) As NO
               From 病人预交记录
               Where Nvl(病人id, 0) = Nvl(病人id_In, 0) And (结算序号 = 结算序号id_In Or 结帐id = 结算序号id_In)
               Group By 结帐id
               Order By 结帐id) Loop
  
    If Nvl(n_Max结帐id, 0) < Nvl(v_结帐.结帐id, 0) Then
      n_Max结帐id := Nvl(v_结帐.结帐id, 0);
      v_Maxno     := v_结帐.No;
    End If;
    If v_结帐.操作员姓名 Is Not Null And v_操作员姓名 Is Null Then
      v_操作员姓名 := v_结帐.操作员姓名;
    End If;
  
    If Nvl(v_结帐.结算方式, '-') = '-' And Floor(Abs(v_结帐.冲预交) * 10) <> Abs(v_结帐.冲预交) * 10 Then
      --存在分币小数,则可能需要处理分币,误差放在有小数的单据上
      n_误差结帐id := Nvl(v_结帐.结帐id, 0);
      v_误差no     := v_结帐.No;
    End If;
    l_结帐id.Extend;
    l_结帐id(l_结帐id.Count) := v_结帐.结帐id;
  End Loop;

  If l_结帐id.Count = 0 Or Nvl(n_Max结帐id, 0) = 0 Then
    v_Err_Msg := '未找到相关的结帐数据,不能完成收费,请与系统管员联系！';
    Raise Err_Item;
  End If;
  If Nvl(n_误差结帐id, 0) = 0 Then
    n_误差结帐id := n_Max结帐id;
    v_误差no     := v_Maxno;
  End If;

  n_病人id := Nvl(病人id_In, 0);
  If n_病人id = 0 Then
    n_病人id := Null;
  End If;

  If v_操作员姓名 Is Null Or v_误差no Is Null Or Nvl(n_误差结帐id, 0) = 0 Then
    Begin
      Select NO, 操作员姓名, 结帐id, 病人id
      Into v_误差no, v_操作员姓名, n_误差结帐id, n_病人id
      From 门诊费用记录
      Where 结帐id = Nvl(n_Max结帐id, 0) And Rownum = 1;
    Exception
      When Others Then
        n_误差结帐id := 0;
    End;
  End If;

  Open c_Balancedata(n_Max结帐id);
  Fetch c_Balancedata
    Into r_Balancedata;

  If Nvl(误差金额_In, 0) <> 0 Then
    --：填写门诊收费时所产生的误差费用,以保证与结算金额一致。
    --误差处理规则:放在存在小数结算的最后一张单据
    Zl_门诊收费误差_Insert(v_误差no, 误差金额_In);
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_误差结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      --插入保存数据
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 3, v_误差no, 1, 病人id, 主页id, Null, Null, Null, 收款时间, 操作员编号, 操作员姓名, Nvl(误差金额_In, 0),
               n_误差结帐id, 0, 0, 缴款组id, 结算序号, 3
        From 病人预交记录
        Where 结帐id = n_Max结帐id And Rownum < 2;
    End If;
  End If;

  If Nvl(预存款_In, 0) <> 0 Then
  
    If Nvl(n_病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人的病人ID,收费使用预交款结算失败！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 预存款_In;
    For v_预交 In (Select /*+ rule */
                 Distinct c.结帐id, Max(c.冲预交) As 冲预交, Max(a.No) As NO
                 From 门诊费用记录 A, 病人预交记录 C, Table(l_结帐id) B
                 Where a.结帐id = c.结帐id And a.结帐id = b.Column_Value And c.结算方式 Is Null
                 Group By c.结帐id
                 Order By 结帐id) Loop
      If Nvl(n_预交金额, 0) > Nvl(v_预交.冲预交, 0) Then
        n_冲预交   := Nvl(v_预交.冲预交, 0);
        n_预交金额 := Nvl(n_预交金额, 0) - Nvl(v_预交.冲预交, 0);
      Else
        n_冲预交   := Nvl(n_预交金额, 0);
        n_预交金额 := 0;
      End If;
    
      If n_冲预交 <> 0 Then
        Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
        n_当前剩余预交 := n_冲预交;
        For r_Deposit In c_Deposit(n_病人id) Loop
          If n_当前剩余预交 >= Nvl(r_Deposit.金额, 0) Then
            n_当前剩余预交 := n_当前剩余预交 - Nvl(r_Deposit.金额, 0);
            n_冲预交       := Nvl(r_Deposit.金额, 0);
          Else
            n_冲预交       := Nvl(n_当前剩余预交, 0);
            n_当前剩余预交 := 0;
          End If;
          If n_冲预交 <> 0 Then
          
            If r_Deposit.Id <> 0 Then
              --第一次冲预交(填上结帐ID,金额为0)
              Update 病人预交记录
              Set 冲预交 = 0, 结帐id = v_预交.结帐id, 结算序号 = 结算序号id_In, 结算性质 = 3
              Where ID = r_Deposit.Id;
            End If;
          
            --冲上次剩余额
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                     r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号,
                     Decode(Sign(r_Deposit.金额 - n_冲预交), -1, r_Deposit.金额, n_冲预交), v_预交.结帐id, r_Balancedata.缴款组id, 预交类别,
                     卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号id_In, 3
              From 病人预交记录
              Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
          
          End If;
          If Nvl(n_当前剩余预交, 0) = 0 Then
            Exit;
          End If;
        End Loop;
      
        --检查金额是否足够
        If Nvl(n_当前剩余预交, 0) > 0 Then
          v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_预交金额, 0) = 0 Then
        Exit;
      End If;
    End Loop;
    --检查金额是否足够
    If n_预交金额 > 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  
    --更新病人预交余额
    Update 病人余额
    Set 预交余额 = Nvl(预交余额, 0) - Nvl(预存款_In, 0)
    Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
    Returning 预交余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -预存款_In, 1, 1);
      n_返回值 := -预存款_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
    If n_返回值 < 0 Then
      v_Err_Msg := '病人的当前预交余额不足金额 ' || LTrim(To_Char(预存款_In, '9999999990.00')) || ' ！';
      Raise Err_Item;
    End If;
  End If;

  If 收费结算_In Is Not Null Then
    If Nvl(退支票额_In, 0) <> 0 Then
      Begin
        Select b.名称
        Into v_结算方式
        From 结算方式应用 A, 结算方式 B
        Where a.应用场合 = '收费' And b.名称 = a.结算方式 And Nvl(b.应付款, 0) = 1 And Rownum <= 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        v_Err_Msg := '在结算方式设置中不存在退支票的结算方式,请在结算方式中设置！';
        Raise Err_Item;
      End If;
      --退支票,单独处理
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - 退支票额_In Where 结算方式 Is Null And 结帐id = n_Max结帐id;
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, 3, NO, 1, 病人id, 主页id, Null, v_结算方式, Null, 收款时间, 操作员编号, 操作员姓名, 退支票额_In, 结帐id, 缴款_In,
               找补_In, 缴款组id, 结算序号, 3
        From 病人预交记录 A
        Where 结帐id = n_Max结帐id And 结算方式 Is Null;
    End If;
    --各个收费结算
    v_结算内容 := 收费结算_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      If Nvl(n_结算金额, 0) <> 0 Then
        For v_预交 In (Select /*+ rule */
                     Distinct c.结帐id, Max(c.冲预交) As 冲预交, Max(a.No) As NO
                     From 门诊费用记录 A, 病人预交记录 C, Table(l_结帐id) B
                     Where a.结帐id = c.结帐id And a.结帐id = b.Column_Value And c.结算方式 Is Null
                     Group By c.结帐id
                     Order By 结帐id) Loop
          n_冲预交 := Nvl(n_结算金额, 0);
          If Abs(Nvl(n_结算金额, 0)) > Abs(Nvl(v_预交.冲预交, 0)) Then
            n_冲预交 := Nvl(v_预交.冲预交, 0);
          End If;
          n_结算金额 := Nvl(n_结算金额, 0) - Nvl(n_冲预交, 0);
          If Nvl(n_冲预交, 0) <> 0 Then
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) - n_冲预交
            Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
              Select 病人预交记录_Id.Nextval, 3, v_预交.No, 1, 病人id, 主页id, v_结算摘要, v_结算方式, v_结算号码, 收款时间, 操作员编号, 操作员姓名, n_冲预交,
                     结帐id, 缴款_In, 找补_In, 缴款组id, 结算序号, 3
              From 病人预交记录
              Where 结帐id = v_预交.结帐id And 结算方式 Is Null;
          End If;
          If n_结算金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --如果本次结算中结算方式为空的记录的冲预交之和为0，也表示全部结算
  Begin
    Select Nvl(Sum(冲预交), 0)
    Into n_预交金额
    From 病人预交记录
    Where 结算序号 = 结算序号id_In And 结算方式 Is Null And Nvl(病人id, 0) = Nvl(病人id_In, 0)
    Group By 结算序号;
  Exception
    When Others Then
      n_预交金额 := 0;
  End;

  If Nvl(n_预交金额, 0) = 0 Then
    Begin
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum = 1;
    Exception
      When Others Then
        v_结算方式 := '现金';
    End;

    For v_预交 In (Select Distinct 结帐id, Nvl(冲预交, 0) As 冲预交
                 From 病人预交记录
                 Where 结算序号 = 结算序号id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0) Loop
    
      n_冲预交 := v_预交.冲预交;
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + n_冲预交
      Where 结算方式 = v_结算方式 And 结帐id = v_预交.结帐id;
      If Sql%NotFound Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, 3, NO, 1, 病人id, 主页id, 摘要, v_结算方式, v_结算号码, 收款时间, 操作员编号, 操作员姓名, n_冲预交, 结帐id, 缴款_In,
                 找补_In, 缴款组id, 结算序号, 3
          From 病人预交记录
          Where 结帐id = v_预交.结帐id And 结算方式 Is Null;
      End If;
    
      Update 病人预交记录 Set 冲预交 = Nvl(冲预交, 0) - n_冲预交 Where 结算方式 Is Null And 结帐id = v_预交.结帐id;
    End Loop;
  End If;

  --删除已经分摊完成的记录
  Forall I In 1 .. l_结帐id.Count
    Delete 病人预交记录 Where 结帐id = l_结帐id(I) And 结算方式 Is Null And Nvl(冲预交, 0) = 0;

  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In Where 结算序号 = 结算序号id_In;
  Select Count(*) Into n_Count From 病人预交记录 A Where 结算序号 = 结算序号id_In And 结算方式 Is Null;
  If n_Count <> 0 Then
    v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Raise Err_Item;
  End If;

  Forall I In 1 .. l_结帐id.Count
    Update 病人预交记录 Set 校对标志 = 0 Where 结帐id = l_结帐id(I) And Nvl(病人id, 0) = Nvl(病人id_In, 0);

  Forall I In 1 .. l_结帐id.Count
    Update 门诊费用记录 Set 执行状态 = 0, 费用状态 = 0 Where 结帐id = l_结帐id(I) And Nvl(费用状态, 0) = 1;

  --更新执行状态
  --执行状态含义：0:未执行;1:完全执行;2:部份执行
  --1:非药品和卫材,如果执行人不为空,则执行状态为1,否则为0
  --2.药品和卫材,如果执行人为空,则为零,否则按如下规则处理:
  --  存在数量与药品收发记录中的数量不等时,则为部分执行,填为2,否则为1完全执行
  For v_费用 In (Select /*+ rule */
                Max(Decode(a.价格父号, Null, a.Id, 0)) ID, NO, Nvl(a.价格父号, a.序号) As 序号, a.收费类别, a.收费细目id, a.执行人, Avg(a.付数) 付数,
                Avg(a.数次) 数次, a.医嘱序号, Max(Nvl(m.跟踪在用, 0)) As 跟踪在用, Max(Nvl(j.诊疗类别, '--')) As 诊疗类别
               From 门诊费用记录 A, Table(l_结帐id) B, 材料特性 M, 病人医嘱记录 J
               Where a.结帐id = b.Column_Value And a.记录性质 = 1 And a.收费细目id + 0 = m.材料id(+) And a.执行时间 Is Not Null And
                     a.医嘱序号 + 0 = j.Id(+)
               Group By NO, Nvl(a.价格父号, a.序号), 收费类别, a.收费细目id, 执行人, a.医嘱序号) Loop
    n_执行状态 := 1;
    If Instr(',5,6,7,', ',' || v_费用.收费类别 || ',') > 0 Or (v_费用.跟踪在用 = 1 And v_费用.收费类别 = '4') Then
      --药品卫生材料,需要检查是否存数据
      Begin
        Select Max(2)
        Into n_执行状态
        From 药品收发记录
        Where 单据 In (24, 8) And NO = v_费用.No And 费用id = v_费用.Id And 审核日期 Is Not Null Having
         Sum(Nvl(付数, 1) * Nvl(实际数量, 0)) <> Nvl(v_费用.付数, 1) * Nvl(v_费用.数次, 0);
      Exception
        When Others Then
          Null;
      End;
    Else
      If Nvl(v_费用.医嘱序号, 0) <> 0 Then
        Begin
          --拒绝执行的,表示未执行
          Select Decode(执行状态, 2, 0, 执行状态), 发送号
          Into n_执行状态, n_发送号
          From 病人医嘱发送
          Where NO = v_费用.No And 记录性质 = 1 And 医嘱id = Nvl(v_费用.医嘱序号, 0);
        Exception
          When Others Then
            n_执行状态 := 0;
        End;
        If Nvl(n_执行状态, 0) = 3 Then
          --分两种情况判断(根据医吃执行计价表中有无数据进行检查)
          --1.无数据,就按以前的统计办法来判断是否部分执行(主要是歉容以前数据)
          --2.有数据,按此表数据统计未执行数量来判断是否部分执行
          Select Count(*)
          Into n_Count
          From 医嘱执行计价 A
          Where 医嘱id = Nvl(v_费用.医嘱序号, 0) And a.发送号 = Nvl(n_发送号, 0) And Rownum <= 1;
        
          If Nvl(n_Count, 0) = 0 Then
            --1.无数据,就按以前的统计办法来判断是否部分执行(主要是歉容以前数据)
            If Instr(',C,D,F,G,K,--,', ',' || v_费用.诊疗类别 || ',') = 0 And Nvl(v_费用.医嘱序号, 0) <> 0 Then
              --总执行与未执数相同,为未执行;未执行数为零,完全执行;否则部分执行
              Begin
                Select Decode(剩余数, 执行总次数, 0, 0, 1, 2)
                Into n_执行状态
                From (Select Max(a.发送数次) As 执行总次数,
                              Max(a.发送数次) - Nvl(Sum(Decode(Nvl(b.执行结果, 0), 1, 1, 0) * Nvl(b.本次数次, 0)), 0) As 剩余数
                       From 病人医嘱发送 A, 病人医嘱执行 B
                       Where a.医嘱id = b.医嘱id(+) And a.发送号 = b.发送号(+) And a.医嘱id = Nvl(v_费用.医嘱序号, 0) And
                             a.发送号 = Nvl(n_发送号, 0));
              Exception
                When Others Then
                  n_执行状态 := 1;
              End;
            End If;
          Else
            --2. 有数据,按此表数据统计未执行数量来判断是否部分执行
            Begin
              Select Decode(Sign(Nvl(未执行数量, 0)), 0, 1, 2)
              Into n_执行状态
              From (Select Sum(Decode(Nvl(b.执行结果, 0), 0, 1, 0) * a.数量) As 未执行数量
                     From 医嘱执行计价 A, 病人医嘱执行 B
                     Where a.医嘱id = b.医嘱id(+) And a.发送号 = b.发送号(+) And a.要求时间 = b.要求时间(+) And a.医嘱id = Nvl(v_费用.医嘱序号, 0) And
                           a.发送号 = Nvl(n_发送号, 0));
            Exception
              When Others Then
                n_执行状态 := 0;
            End;
          End If;
        End If;
      End If;
    End If;
    n_执行状态 := Nvl(n_执行状态, 1);
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where 记录性质 = 1 And 记录状态 = 1 And NO = v_费用.No And Nvl(价格父号, 序号) = v_费用.序号 And 收费细目id = v_费用.收费细目id;
  End Loop;

  For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
               From 病人预交记录 A
               Where a.结算序号 = 结算序号id_In And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
               Group By 结算方式) Loop
  
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
    Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
    End If;
  End Loop;
  --收费后产生导引
  For r_结帐 In (Select Distinct a.结帐id From 病人预交记录 A Where 结算序号 = 结算序号id_In) Loop
    v_结帐ids := v_结帐ids || ',' || r_结帐.结帐id;
  End Loop;
  If v_结帐ids Is Not Null Then
    v_结帐ids := Substr(v_结帐ids, 2);
  End If;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 4, v_结帐ids;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_完成收费;
/

--99572:冉俊明,2016-08-22,门诊收费历史异常单据处理
Create Or Replace Procedure Zl_门诊收费结算_完成退费
(
  病人id_In       门诊费用记录.病人id%Type,
  退费结算序号_In 病人预交记录.结算序号%Type,
  冲销ids_In      Varchar2,
  操作员姓名_In   病人预交记录.操作员姓名%Type := Null,
  操作标志_In     Integer := 0,
  异常作废_In     Number := 0
) As
  --功能:完成退费处理
  --NOs_In:可以为多张;No1,No2...Non
  --操作标志_IN:0-更新缴款余额;1-不更新缴款余额(异常单据作废)
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_操作员姓名 病人预交记录.操作员姓名%Type;
  n_Count      Number;
  n_返回值     病人预交记录.冲预交%Type;
  v_Msg        Varchar2(500);
Begin
  v_操作员姓名 := 操作员姓名_In;

  If 冲销ids_In Is Null Then
    Select Count(*)
    Into n_Count
    From 病人预交记录 A
    Where 结算序号 = 退费结算序号_In And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
      Raise Err_Item;
    End If;
    For v_结帐 In (Select Distinct 结帐id From 病人预交记录 Where 结算序号 = 退费结算序号_In) Loop
      If 操作标志_In = 1 Then
      
        Update 病人预交记录 A
        Set 校对标志 = 2
        Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
              (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
               (Select 1 From 结算方式 B Where a.结算方式 = b.名称 And b.性质 In (3, 4))));
        Return;
      End If;
    
      Update 病人预交记录
      Set 校对标志 = 0, 会话号 = Null
      Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
    
      For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数
                   From 门诊费用记录 A, 门诊费用记录 B
                   Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                         b.结帐id = v_结帐.结帐id
                   Group By a.No, Nvl(a.价格父号, a.序号)) Loop
        Update 门诊费用记录 A
        Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 异常作废_In
        Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
      End Loop;
    
      --处理预交记录
    
      If Nvl(操作标志_In, 0) = 0 Then
      
        --处理病人预交余额
        For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 预交类别
                     Having Sum(Nvl(冲预交, 0)) <> 0) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
          Returning 预交余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 类型, 预交余额, 性质)
            Values
              (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
            n_返回值 := Nvl(v_预交.预交金额, 0);
          End If;
          If n_返回值 = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      
        --更新人员缴款余额
        For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                     From 病人预交记录 A
                     Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                     Group By 结算方式) Loop
        
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
          Returning Nvl(余额, 0) Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
            n_返回值 := Nvl(v_缴款.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete 人员缴款余额
            Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
          End If;
        End Loop;
      End If;
    
    End Loop;
    Return;
  End If;

  --按单据号更新
  Select /*+ rule */
   Count(a.Id)
  Into n_Count
  From 病人预交记录 A, Table(f_Num2list(冲销ids_In)) J
  Where a.结帐id = j.Column_Value And Nvl(校对标志, 0) = 1 And (Nvl(卡类别id, 0) <> 0 Or Nvl(结算卡序号, 0) <> 0);
  If n_Count <> 0 Then
    v_Err_Msg := '还存在未退费完成的数据,不能完成退费!';
    Raise Err_Item;
  End If;

  --更新执行状态:在未完成时,都是9
  For v_结帐 In (Select /*+ rule */
                j.Column_Value As 结帐id
               From Table(f_Num2list(冲销ids_In)) J) Loop
  
    If Nvl(操作标志_In, 0) = 1 Then
      Update 病人预交记录 A
      Set 校对标志 = 2
      Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0) And
            (a.结算方式 Is Null Or (Nvl(卡类别id, 0) = 0 And Nvl(结算卡序号, 0) = 0 And Not Exists
             (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4))));
    
    End If;
  
    Update 病人预交记录
    Set 校对标志 = 0, 会话号 = Null
    Where 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0);
  
    For v_费用 In (Select a.No, Nvl(a.价格父号, a.序号) As 序号, Nvl(Max(Abs(Decode(a.执行状态, 9, 0, a.执行状态))), 0) + 1 As 退费次数


                 
                 From 门诊费用记录 A, 门诊费用记录 B
                 Where a.No = b.No And Nvl(a.价格父号, a.序号) = Nvl(b.价格父号, b.序号) And a.记录性质 = b.记录性质 And a.记录状态 = b.记录状态 And
                       b.结帐id = v_结帐.结帐id
                 Group By a.No, Nvl(a.价格父号, a.序号)) Loop
      Update 门诊费用记录 A
      Set 执行状态 = -1 * v_费用.退费次数, 费用状态 = 异常作废_In
      Where 结帐id = v_结帐.结帐id And a.No = v_费用.No And a.记录性质 = 1 And Nvl(a.价格父号, a.序号) = v_费用.序号;
    End Loop;
  
    --处理预交记录
  
    If Nvl(操作标志_In, 0) = 0 Then
    
      --处理病人预交余额
      For v_预交 In (Select 预交类别, -1 * Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = v_结帐.结帐id And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (病人id_In, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := Nvl(v_预交.预交金额, 0);
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    
      --更新人员缴款余额
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = v_结帐.结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning Nvl(余额, 0) Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete 人员缴款余额
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  End Loop;
  --消息推送
  Select 病人id_In || ',' || 冲销ids_In || ',' || 操作标志_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费结算_完成退费;
/

--103221:刘尔旋,2016-12-26,开放停诊号码
--103232:冉俊明,2016-12-15,临床出诊安排，按序号时段开放停诊安排。
--103318:冉俊明,2016-12-06,周出诊表节假日换休有问题。
--102941:冉俊明,2016-11-25,删除号源的同时停用当前时间以后的所有出诊安排。
--101414:冉俊明,2016-10-20,出诊表另存为模板功能调整
--100746:冉俊明,2016-09-20,临床出诊安排加号、减号时，先只删除待挂或待预约的号，然后再根据调整后的序号信息插入或更新数据
--100203:冉俊明,2016-09-12,调整上班时段后修改出诊记录的提前挂号时间和缺省预约时间
--97908:刘尔旋,2016-09-08,挂号冲预交问题
--99884:刘尔旋,2016-09-06,服务窗接口取消预约问题
--68694:刘尔旋,2016-09-09,新挂号安排修改
Create Or Replace Procedure Zl_上班时段_Modify
(
  操作类型_In     Number,
  站点_In         时间段.站点%Type,
  号类_In         时间段.号类%Type,
  时间段_In       时间段.时间段%Type,
  开始时间_In     时间段.开始时间%Type,
  终止时间_In     时间段.终止时间%Type,
  休息时段_In     时间段.休息时段%Type,
  缺省时间_In     时间段.缺省时间%Type,
  提前时间_In     时间段.提前时间%Type,
  出诊预留时间_In 时间段.出诊预留时间%Type,
  原站点_In       时间段.站点%Type := Null,
  原号类_In       时间段.号类%Type := Null,
  原时间段_In     时间段.时间段%Type := Null
) As
  --新增、修改上班时段
  --操作类型_In 0-新增，1-修改
  --原站点_In、原号类_In、原时间段_In 修改时传入
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  l_记录id t_Numlist := t_Numlist();

  n_Count Number;
Begin
  If Nvl(操作类型_In, 0) = 0 Then
    --新增上班时段
    Begin
      Select 1
      Into n_Count
      From 时间段
      Where Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-') And 时间段 = 时间段_In;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前站点已存在相同号类的上班时间段“' || 时间段_In || '”！';
      Raise Err_Item;
    End If;
  
    Insert Into 时间段
      (站点, 号类, 时间段, 开始时间, 终止时间, 休息时段, 缺省时间, 提前时间, 出诊预留时间)
    Values
      (站点_In, 号类_In, 时间段_In, 开始时间_In, 终止时间_In, 休息时段_In, Nvl(缺省时间_In, 开始时间_In), Nvl(提前时间_In, 开始时间_In), 出诊预留时间_In);
    Return;
  End If;

  --修改时，检查原上班时段是否被使用，被使用的不能修改站点、号类、时间段
  --不能删除被使用的范围最广的那一个,被使用的时段只要有一个即可（不同站点，不同号类可能会有多个同名的时间段）

  If Nvl(原站点_In, '-') <> Nvl(站点_In, '-') Or Nvl(原号类_In, '-') <> Nvl(号类_In, '-') Or 原时间段_In <> 时间段_In Then
    --临床出诊号源限制
    Begin
      Select 1
      Into n_Count
      From (Select b.上班时段, c.站点, a.号类, Row_Number() Over(Partition By b.上班时段 Order By b.上班时段, c.站点 Desc, a.号类 Desc) As 组号
             From 临床出诊号源 A, 临床出诊号源限制 B, 部门表 C
             Where a.Id = b.号源id And a.科室id = c.Id)
      Where 组号 = 1 And Nvl(站点, '-') = Nvl(原站点_In, '-') And Nvl(号类, '-') = Nvl(原号类_In, '-') And 上班时段 = 原时间段_In And
            Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    --临床出诊限制(固定规则、模板)
    If Nvl(n_Count, 0) = 0 Then
      Begin
        Select 1
        Into n_Count
        From (Select a.上班时段, c.站点, b.号类,
                      Row_Number() Over(Partition By a.上班时段 Order By a.上班时段, c.站点 Desc, b.号类 Desc) As 组号
               From 临床出诊限制 A, 临床出诊安排 D, 临床出诊号源 B, 部门表 C
               Where a.安排id = d.Id And d.号源id = b.Id And b.科室id = c.Id)
        Where 组号 = 1 And Nvl(站点, '-') = Nvl(原站点_In, '-') And Nvl(号类, '-') = Nvl(原号类_In, '-') And 上班时段 = 原时间段_In And
              Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
    End If;
    --临床出诊记录
    --不检查，因为该表太大，其次上班时段的信息都保存在了这个表中，没有找到上班时段时可由这个表的数据来提取
    If n_Count > 0 Then
      v_Err_Msg := '上班时间段“' || 原时间段_In || '”已被使用，不能修改其站点、号类及时间段名称！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 时间段
      Where Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-') And 时间段 = 时间段_In;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前站点已存在相同号类的上班时间段“' || 时间段_In || '”！';
      Raise Err_Item;
    End If;
  End If;

  Update 时间段
  Set 站点 = 站点_In, 号类 = 号类_In, 时间段 = 时间段_In, 开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 休息时段 = 休息时段_In, 缺省时间 = Nvl(缺省时间_In, 开始时间_In),
      提前时间 = Nvl(提前时间_In, 开始时间_In), 出诊预留时间 = 出诊预留时间_In
  Where Nvl(站点, '-') = Nvl(原站点_In, '-') And Nvl(号类, '-') = Nvl(原号类_In, '-') And 时间段 = 原时间段_In;
  If Sql%NotFound Then
    Insert Into 时间段
      (站点, 号类, 时间段, 开始时间, 终止时间, 休息时段, 缺省时间, 提前时间, 出诊预留时间)
    Values
      (站点_In, 号类_In, 时间段_In, 开始时间_In, 终止时间_In, 休息时段_In, Nvl(缺省时间_In, 开始时间_In), Nvl(提前时间_In, 开始时间_In), 出诊预留时间_In);
  End If;

  --调整已有出诊记录的上班时段的提前挂号时间和缺省预约时间
  For c_记录 In (Select a.Id, b.号类, Nvl(c.站点, '-') As 站点
               From 临床出诊记录 A, 临床出诊号源 B, 部门表 C
               Where a.号源id = b.Id And b.科室id = c.Id And a.出诊日期 >= Trunc(Sysdate) And a.开始时间 > Sysdate And
                     a.上班时段 = 时间段_In) Loop
  
    --确定出诊记录的上班时段是否为当前修改上班时段
    Begin
      Select 1
      Into n_Count
      From (Select 号类, 站点, 缺省时间, 提前时间, Row_Number() Over(Partition By 时间段 Order By 站点 Asc, 号类 Asc) As 组号
             From 时间段
             Where Nvl(站点, c_记录.站点) = c_记录.站点 And Nvl(号类, c_记录.号类) = c_记录.号类 And 时间段 = 时间段_In)
      Where 组号 = 1 And Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-');
    Exception
      When Others Then
        n_Count := 0;
    End;
  
    If Nvl(n_Count, 0) = 1 Then
      l_记录id.Extend();
      l_记录id(l_记录id.Count) := c_记录.Id;
    End If;
  End Loop;

  Forall I In 1 .. l_记录id.Count
    Update 临床出诊记录
    Set 提前挂号时间 = To_Date(To_Char(出诊日期, 'yyyy-mm-dd ') || To_Char(Nvl(提前时间_In, 开始时间), 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss') + Case
                    When 提前时间_In > 开始时间_In Then
                     -1
                    Else
                     0
                  End,
        缺省预约时间 = To_Date(To_Char(出诊日期, 'yyyy-mm-dd ') || To_Char(Nvl(缺省时间_In, 开始时间), 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss') + Case
                    When 缺省时间_In < 开始时间_In Then
                     1
                    Else
                     0
                  End
    Where ID = l_记录id(I);

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_上班时段_Modify;
/

Create Or Replace Procedure Zl_上班时段_Delete
(
  站点_In   时间段.站点%Type,
  号类_In   时间段.号类%Type,
  时间段_In 时间段.时间段%Type
) As
  -- 删除上班时段
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;
Begin
  --数据检查，上班时间段已被使用则不能删除
  --不能删除被使用的范围最广的那一个,被使用的时段只要有一个即可（不同站点，不同号类可能会有多个同名的时间段）

  --临床出诊号源限制
  Begin
    Select 1
    Into n_Count
    From (Select b.上班时段, c.站点, a.号类, Row_Number() Over(Partition By b.上班时段 Order By b.上班时段, c.站点 Desc, a.号类 Desc) As 组号
           From 临床出诊号源 A, 临床出诊号源限制 B, 部门表 C
           Where a.Id = b.号源id And a.科室id = c.Id)
    Where 组号 = 1 And Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-') And 上班时段 = 时间段_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  --临床出诊限制(固定规则、模板)
  If Nvl(n_Count, 0) = 0 Then
    Begin
      Select 1
      Into n_Count
      From (Select a.上班时段, c.站点, b.号类, Row_Number() Over(Partition By a.上班时段 Order By a.上班时段, c.站点 Desc, b.号类 Desc) As 组号
             From 临床出诊限制 A, 临床出诊安排 D, 临床出诊号源 B, 部门表 C
             Where a.安排id = d.Id And d.号源id = b.Id And b.科室id = c.Id)
      Where 组号 = 1 And Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-') And 上班时段 = 时间段_In And
            Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
  End If;
  --临床出诊记录
  --不检查，因为该表太大，其次上班时段的信息都保存在了这个表中，没有找到上班时段时可由这个表的数据来提取

  If n_Count > 0 Then
    v_Err_Msg := '当前上班时间段已被使用，不能删除！';
    Raise Err_Item;
  End If;

  Delete From 时间段
  Where Nvl(站点, '-') = Nvl(站点_In, '-') And Nvl(号类, '-') = Nvl(号类_In, '-') And 时间段 = 时间段_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_上班时段_Delete;
/

Create Or Replace Procedure Zl_法定假日表_Modify
(
  操作类型_In Number,
  年份_In     法定假日表.年份%Type,
  节日名称_In 法定假日表.节日名称%Type,
  开始日期_In 法定假日表.开始日期%Type,
  终止日期_In 法定假日表.终止日期%Type,
  备注_In     法定假日表.备注%Type,
  换休情况_In Varchar2 := Null,
  允许预约_In Varchar2 := Null,
  允许挂号_In Varchar2 := Null
) As
  --新增、修改法定节假日
  --      操作类型_In 0-新增，1-修改
  --      换休情况_In 格式：调休时间1~ 原上班时间1;调休时间2~ 原上班时间2;
  --      允许预约_in 允许预约的日期,格式：yyyy-mm-dd;yyyy-mm-dd;...
  --      允许挂号_in 允许挂号的日期,格式：yyyy-mm-dd;yyyy-mm-dd;...
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;

  v_换休情况 Varchar2(4000);
  v_当前项目 Varchar2(4000);
  d_开始日期 Date;
  d_终止日期 Date;
Begin
  If 操作类型_In = 0 Then
    --新增
    Begin
      Select 1
      Into n_Count
      From 法定假日表
      Where 性质 = 0 And 年份 = 年份_In And 节日名称 = 节日名称_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := 年份_In || '年已存在“' || 节日名称_In || '”！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 临床出诊记录 A
      Where a.出诊日期 >= 开始日期_In And a.上班时段 Is Not Null And Nvl(a.是否发布, 0) = 1 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) <> 0 Then
      v_Err_Msg := '当前节假日开始时间之后已有有效的出诊安排，不能再新增！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 临床出诊记录
      Where 出诊日期 Between 开始日期_In And 终止日期_In And Nvl(是否发布, 0) = 1 And (Nvl(已约数, 0) <> 0 Or Nvl(已挂数, 0) <> 0) And
            Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前节假日的时间范围内已有预约挂号病人，不能设置！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 法定假日表
      Where 性质 = 0 And 终止日期_In > 开始日期 And 开始日期_In < 终止日期 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前节假日的时间范围内已存在其它节假日！';
      Raise Err_Item;
    End If;
  
    Insert Into 法定假日表
      (年份, 节日名称, 性质, 开始日期, 终止日期, 备注, 允许预约, 允许挂号)
    Values
      (年份_In, 节日名称_In, 0, 开始日期_In, 终止日期_In, 备注_In, 允许预约_In, 允许挂号_In);
  
    If 换休情况_In Is Not Null Then
      v_换休情况 := 换休情况_In || ';';
    End If;
    While v_换休情况 Is Not Null Loop
      v_当前项目 := Substr(v_换休情况, 0, Instr(v_换休情况, ';') - 1);
      d_开始日期 := To_Date(Substr(v_当前项目, 0, Instr(v_当前项目, '~') - 1), 'yyyy-mm-dd');
      d_终止日期 := To_Date(Substr(v_当前项目, Instr(v_当前项目, '~') + 1), 'yyyy-mm-dd');
    
      Insert Into 法定假日表
        (年份, 节日名称, 性质, 开始日期, 终止日期, 备注)
      Values
        (年份_In, 节日名称_In, 1, d_开始日期, d_终止日期, Null);
    
      v_换休情况 := Substr(v_换休情况, Instr(v_换休情况, ';') + 1);
    End Loop;
  
  Elsif 操作类型_In = 1 Then
    --修改
    Begin
      Select 开始日期
      Into d_开始日期
      From 法定假日表
      Where 性质 = 0 And 年份 = 年份_In And 节日名称 = 节日名称_In And Rownum < 2;
    Exception
      When Others Then
        d_开始日期 := Null;
    End;
    If d_开始日期 Is Null Then
      v_Err_Msg := 年份_In || '年不存在“' || 节日名称_In || '”！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 临床出诊记录 A
      Where a.出诊日期 >= d_开始日期 And a.上班时段 Is Not Null And Nvl(a.是否发布, 0) = 1 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) <> 0 Then
      v_Err_Msg := '当前节假日开始时间之后已有有效的出诊安排，不能修改！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 临床出诊记录
      Where 出诊日期 Between 开始日期_In And 终止日期_In And Nvl(是否发布, 0) = 1 And (Nvl(已约数, 0) <> 0 Or Nvl(已挂数, 0) <> 0) And
            Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前节假日的时间范围内已有预约挂号病人，不能修改！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1
      Into n_Count
      From 法定假日表
      Where 性质 = 0 And 终止日期_In > 开始日期 And 开始日期_In < 终止日期 And Not (年份 = 年份_In And 节日名称 = 节日名称_In) And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := '当前节假日的时间范围内已存在其它节假日！';
      Raise Err_Item;
    End If;
  
    Update 法定假日表
    Set 开始日期 = 开始日期_In, 终止日期 = 终止日期_In, 备注 = 备注_In, 允许预约 = 允许预约_In, 允许挂号 = 允许挂号_In
    Where 年份 = 年份_In And Nvl(性质, 0) = 0 And 节日名称 = 节日名称_In;
  
    --先删除换休数据
    Delete From 法定假日表 Where 年份 = 年份_In And Nvl(性质, 0) = 1 And 节日名称 = 节日名称_In;
    If 换休情况_In Is Not Null Then
      v_换休情况 := 换休情况_In || ';';
    End If;
    While v_换休情况 Is Not Null Loop
      v_当前项目 := Substr(v_换休情况, 0, Instr(v_换休情况, ';') - 1);
      d_开始日期 := To_Date(Substr(v_当前项目, 0, Instr(v_当前项目, '~') - 1), 'yyyy-mm-dd');
      d_终止日期 := To_Date(Substr(v_当前项目, Instr(v_当前项目, '~') + 1), 'yyyy-mm-dd');
    
      Insert Into 法定假日表
        (年份, 节日名称, 性质, 开始日期, 终止日期, 备注)
      Values
        (年份_In, 节日名称_In, 1, d_开始日期, d_终止日期, Null);
    
      v_换休情况 := Substr(v_换休情况, Instr(v_换休情况, ';') + 1);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_法定假日表_Modify;
/
Create Or Replace Procedure Zl_法定假日表_Delete
(
  年份_In     法定假日表.年份%Type,
  节日名称_In 法定假日表.节日名称%Type
) As
  --删除法定节假日
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  d_开始日期 Date;
  n_Count    Number;
Begin
  Begin
    Select 开始日期
    Into d_开始日期
    From 法定假日表
    Where 性质 = 0 And 年份 = 年份_In And 节日名称 = 节日名称_In And Rownum < 2;
  Exception
    When Others Then
      d_开始日期 := Null;
  End;
  If d_开始日期 Is Null Then
    v_Err_Msg := 年份_In || '年不存在“' || 节日名称_In || '”！';
    Raise Err_Item;
  End If;

  Begin
    Select 1
    Into n_Count
    From 临床出诊记录 A
    Where a.出诊日期 >= d_开始日期 And a.上班时段 Is Not Null And Nvl(a.是否发布, 0) = 1 And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前节假日开始时间之后已有有效的出诊安排，不能删除！';
    Raise Err_Item;
  End If;

  Delete From 法定假日表 Where 年份 = 年份_In And 节日名称 = 节日名称_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_法定假日表_Delete;
/
Create Or Replace Procedure Zl_门诊诊室_Modify
(
  操作类型_In Number,
  Id_In       门诊诊室.Id%Type,
  编码_In     门诊诊室.编码%Type := Null,
  名称_In     门诊诊室.名称%Type := Null,
  简码_In     门诊诊室.简码%Type := Null,
  位置_In     门诊诊室.位置%Type := Null,
  站点_In     门诊诊室.站点%Type := Null,
  适用科室_In Varchar2 := Null
) As
  --新增、修改门诊诊室
  --操作类型_In 0-新增，1-修改
  --适用科室_In 格式：科室ID，格式：科室1;科室2;科室3;...
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Id    门诊诊室.Id%Type;
  n_Count Number;
Begin
  If 操作类型_In = 0 Then
    --新增
    Begin
      Select 1 Into n_Count From 门诊诊室 Where 名称 = 名称_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count > 0 Then
      v_Err_Msg := 名称_In || ' 已存在！';
      Raise Err_Item;
    End If;
  
    Select 门诊诊室_Id.Nextval Into n_Id From Dual;
    Insert Into 门诊诊室 (ID, 编码, 名称, 简码, 位置, 站点) Values (n_Id, 编码_In, 名称_In, 简码_In, 位置_In, 站点_In);
  
    --插入门诊诊室适用科室
    If Not 适用科室_In Is Null Then
      Insert Into 门诊诊室适用科室
        (诊室id, 科室id)
        Select n_Id, Column_Value As 科室id From Table(f_Num2list(适用科室_In, ';'));
    End If;
  
    Return;
  End If;

  --修改
  Begin
    Select 1 Into n_Count From 门诊诊室 Where 名称 = 名称_In And ID <> Id_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count > 0 Then
    v_Err_Msg := 名称_In || ' 已存在！';
    Raise Err_Item;
  End If;

  Update 门诊诊室 Set 编码 = 编码_In, 名称 = 名称_In, 简码 = 简码_In, 位置 = 位置_In, 站点 = 站点_In Where ID = Id_In;

  --先删除
  Delete From 门诊诊室适用科室 Where 诊室id = Id_In;
  --插入门诊诊室适用科室
  If Not 适用科室_In Is Null Then
    Insert Into 门诊诊室适用科室
      (诊室id, 科室id)
      Select Id_In, Column_Value As 科室id From Table(f_Num2list(适用科室_In, ';'));
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊诊室_Modify;
/
Create Or Replace Procedure Zl_门诊诊室_Delete(Id_In 门诊诊室.Id%Type) As
  --删除门诊诊室
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number(2);
Begin
  Begin
    Select 1 Into n_Count From 临床出诊号源诊室 Where 诊室id = Id_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;

  If Nvl(n_Count, 0) = 0 Then
    Begin
      Select 1 Into n_Count From 临床出诊诊室 Where 诊室id = Id_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
  End If;

  If Nvl(n_Count, 0) = 0 Then
    Begin
      Select 1 Into n_Count From 临床出诊诊室记录 Where 诊室id = Id_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
  End If;
  If Nvl(n_Count, 0) > 0 Then
    v_Err_Msg := '当前诊室已被使用，不能删除！';
    Raise Err_Item;
  End If;

  Delete From 门诊诊室适用科室 Where 诊室id = Id_In;
  Delete From 门诊诊室 Where ID = Id_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊诊室_Delete;
/
Create Or Replace Procedure Zl_临床出诊号源_Stopandstart
(
  Id_In   临床出诊号源.Id%Type,
  停用_In Number := 0
) As
  d_开始时间 临床出诊记录.开始时间%Type;
Begin
  If Nvl(停用_In, 0) = 1 Then
    Update 临床出诊号源 Set 撤档时间 = Sysdate Where ID = Id_In;
    --将当前时间以后的所有出诊记录停诊
    For c_记录 In (Select ID, 开始时间, 终止时间
                 From 临床出诊记录
                 Where 号源id = Id_In And 出诊日期 >= Trunc(Sysdate) - 1 And 终止时间 > Sysdate And 上班时段 Is Not Null) Loop
    
      If c_记录.开始时间 < Sysdate Then
        d_开始时间 := Sysdate;
      Else
        d_开始时间 := c_记录.开始时间;
      End If;
      Zl_临床出诊记录_Stopvisit(c_记录.Id, d_开始时间, c_记录.终止时间, '停用号源', Zl_Username, Sysdate, 0, 1);
    End Loop;
  Else
    Update 临床出诊号源 Set 撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'), 是否删除 = 0 Where ID = Id_In;
    --将所有当前时间以后的所有出诊记录取消停诊（终止时间大于当前时间的都取消停诊，但是要排除长期停诊的）
    For c_记录 In (Select ID
                 From 临床出诊记录
                 Where 号源id = Id_In And 出诊日期 >= Trunc(Sysdate) - 1 And 终止时间 > Sysdate And 上班时段 Is Not Null) Loop
    
      Zl_临床出诊记录_Stopvisit(c_记录.Id, Null, Null, Null, Zl_Username, Sysdate, 1, 1);
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源_Stopandstart;
/
Create Or Replace Procedure Zl_临床出诊号源_Modify
(
  操作类型_In     Number,
  Id_In           临床出诊号源.Id%Type,
  号类_In         临床出诊号源.号类%Type := Null,
  号码_In         临床出诊号源.号码%Type := Null,
  科室id_In       临床出诊号源.科室id%Type := 0,
  项目id_In       临床出诊号源.项目id%Type := 0,
  医生id_In       临床出诊号源.医生id%Type := Null,
  医生姓名_In     临床出诊号源.医生姓名%Type := Null,
  是否建病案_In   临床出诊号源.是否建病案%Type := 0,
  预约天数_In     临床出诊号源.预约天数%Type := 0,
  出诊频次_In     临床出诊号源.出诊频次%Type := 0,
  假日控制状态_In 临床出诊号源.假日控制状态%Type := 0,
  是否假日换休_In 临床出诊号源.是否假日换休%Type := 0,
  是否临床排班_In 临床出诊号源.是否临床排班%Type := 0,
  排班方式_In     临床出诊号源.排班方式%Type := 0,
  适用性别_In     临床出诊号源.适用性别%Type := Null,
  适用年龄段_In   临床出诊号源.适用年龄段%Type := Null
) As
  --操作类型_In 0-新增，1-修改，2-删除
  --分诊诊室_In 诊室ID，格式：诊室ID1;诊室ID2;诊室ID13;...
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_号源id 临床出诊号源.Id%Type;
  n_Count  Number;
Begin

  If 操作类型_In = 0 Then
    --增加号源
    n_号源id := Id_In;
  
    If Nvl(n_号源id, 0) = 0 Then
      Select 临床出诊号源_Id.Nextval Into n_号源id From Dual;
    End If;
    Insert Into 临床出诊号源
      (ID, 号类, 号码, 科室id, 项目id, 医生id, 医生姓名, 是否建病案, 预约天数, 出诊频次, 假日控制状态, 是否假日换休, 是否临床排班, 排班方式, 适用性别, 适用年龄段, 是否删除, 建档时间,
       撤档时间)
    Values
      (n_号源id, 号类_In, 号码_In, 科室id_In, 项目id_In, 医生id_In, 医生姓名_In, 是否建病案_In, 预约天数_In, 出诊频次_In, 假日控制状态_In, 是否假日换休_In,
       是否临床排班_In, 排班方式_In, 适用性别_In, 适用年龄段_In, 0, Sysdate, To_Date('3000-01-01', 'yyyy-mm-dd'));
  
    Return;
  End If;

  --修改号源
  Update 临床出诊号源
  Set 号类 = 号类_In, 号码 = 号码_In, 科室id = 科室id_In, 项目id = 项目id_In, 医生id = 医生id_In, 医生姓名 = 医生姓名_In, 是否建病案 = 是否建病案_In,
      预约天数 = 预约天数_In, 出诊频次 = 出诊频次_In, 假日控制状态 = 假日控制状态_In, 是否假日换休 = 是否假日换休_In, 是否临床排班 = 是否临床排班_In, 排班方式 = 排班方式_In,
      适用性别 = 适用性别_In, 适用年龄段 = 适用年龄段_In
  Where ID = Id_In And Nvl(是否删除, 0) = 0 And Nvl(撤档时间, Sysdate) >= Sysdate;
  If Sql%NotFound Then
    v_Err_Msg := '当前号源可能已被他人删除或停用，不能对该号源信息进行修改!';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源_Modify;
/

Create Or Replace Procedure Zl_临床出诊号源_Delete(Id_In 临床出诊号源.Id%Type) As
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number;
  l_限制id   t_Numlist := t_Numlist();
  d_开始时间 临床出诊记录.开始时间%Type;
Begin
  Select Count(1) Into n_Count From 临床出诊安排 Where 号源id = Id_In And Rownum < 2;

  If n_Count = 0 Then
  
    Select ID Bulk Collect Into l_限制id From 临床出诊号源限制 Where 号源id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Delete 临床出诊号源限制 Where 号源id = Id_In;
  
    Delete From 临床出诊号源 Where ID = Id_In;
    If Sql%NotFound Then
      v_Err_Msg := '当前号源可能已被他人删除，不能再删除！';
      Raise Err_Item;
    End If;
    Return;
  End If;

  --假删除
  Update 临床出诊号源 Set 是否删除 = 1, 撤档时间 = Sysdate Where ID = Id_In And Nvl(是否删除, 0) = 0;
  If Sql%NotFound Then
    v_Err_Msg := '当前号源可能已被他人删除，不能再删除！';
    Raise Err_Item;
  End If;

  --将当前时间以后的所有出诊记录停诊
  For c_记录 In (Select ID, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = Id_In And 出诊日期 >= Trunc(Sysdate) - 1 And 终止时间 > Sysdate And 上班时段 Is Not Null) Loop
  
    If c_记录.开始时间 < Sysdate Then
      d_开始时间 := Sysdate;
    Else
      d_开始时间 := c_记录.开始时间;
    End If;
    Zl_临床出诊记录_Stopvisit(c_记录.Id, d_开始时间, c_记录.终止时间, '删除号源', Zl_Username, Sysdate, 0, 1);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源_Delete;
/

Create Or Replace Procedure Zl_临床出诊号源限制_Modify
(
  Id_In           临床出诊号源限制.Id%Type,
  号源id_In       临床出诊号源限制.号源id%Type,
  上班时段_In     临床出诊号源限制.上班时段%Type,
  限号数_In       临床出诊号源限制.限号数%Type,
  限约数_In       临床出诊号源限制.限约数%Type,
  是否序号控制_In 临床出诊号源限制.是否序号控制%Type,
  是否分时段_In   临床出诊号源限制.是否分时段%Type,
  预约控制_In     临床出诊号源限制.预约控制%Type,
  是否独占_In     临床出诊号源限制.是否独占%Type,
  分诊方式_In     临床出诊号源限制.分诊方式%Type,
  诊室id_In       临床出诊号源限制.诊室id%Type,
  号源诊室_In     Varchar2 := Null,
  号源时段_In     Varchar2 := Null,
  号源控制_In     Varchar2 := Null,
  删除号源限制_In Integer := 0
) As
  --号源时段_IN:序号,开始时间(HH:MM:SS),终止时(HH:MM:SS)间,数量,是否预约|...
  --号源诊室_IN:诊室id1,诊室id2,....
  --号源控制_IN:类型,性质,名称,控制方式,序号,数量|
  --删除号源限制_in:1-插入数据前，先删除号源限制,0-不删除数据，直接插入,-1-仅删除号源限制,不插入数据
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  l_限制id   t_Numlist := t_Numlist();
  n_Count    Number;
  v_开始时间 Varchar2(20);
  v_终止时间 Varchar2(20);

  n_序号     临床出诊号源时段.序号%Type;
  d_开始时间 临床出诊号源时段.开始时间%Type;
  d_终止时间 临床出诊号源时段.终止时间%Type;
  n_数量     临床出诊号源时段.限制数量%Type;
  n_是否预约 临床出诊号源时段.是否预约%Type;
  n_类型     临床出诊号源控制.类型%Type;
  n_性质     临床出诊号源控制.性质%Type;
  v_名称     临床出诊号源控制.名称%Type;
  n_控制方式 临床出诊号源控制.控制方式%Type;
  n_限制数量 临床出诊号源控制.数量%Type;
Begin
  If Nvl(删除号源限制_In, 0) = 1 Or Nvl(删除号源限制_In, 0) = -1 Then
    Select ID Bulk Collect Into l_限制id From 临床出诊号源限制 Where 号源id = 号源id_In;
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Delete 临床出诊号源限制 Where 号源id = 号源id_In;
    Delete From 临床出诊号源限制 Where 号源id = 号源id_In;
  
    If Nvl(删除号源限制_In, 0) = -1 Then
      Return;
    End If;
  End If;

  Select Count(1) Into n_Count From 临床出诊号源限制 Where ID = Id_In;
  If n_Count = 0 Then
    Insert Into 临床出诊号源限制
      (ID, 号源id, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id)
    Values
      (Id_In, 号源id_In, 上班时段_In, 限号数_In, 限约数_In, 是否序号控制_In, 是否分时段_In, 预约控制_In, 是否独占_In, 分诊方式_In, 诊室id_In);
  
  End If;

  If 号源时段_In Is Not Null Then
    --插入号源缺省时间段
    For c_时间段集 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(号源时段_In, '|'))) Loop
      n_序号     := Null;
      v_开始时间 := Null;
      v_终止时间 := Null;
      n_数量     := Null;
      n_是否预约 := Null;
      For c_时间段 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(c_时间段集.值)) Order By 序号) Loop
        If c_时间段.序号 = 1 Then
          n_序号 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 2 Then
          v_开始时间 := c_时间段.值;
        End If;
      
        If c_时间段.序号 = 3 Then
          v_终止时间 := c_时间段.值;
        End If;
      
        If c_时间段.序号 = 4 Then
          n_数量 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 5 Then
          n_是否预约 := To_Number(c_时间段.值);
        End If;
      
      End Loop;
      d_开始时间 := To_Date('3000-01-01 ' || Nvl(v_开始时间, ''), 'yyyy-mm-dd hh24:mi:ss');
      d_终止时间 := To_Date('3000-01-01 ' || Nvl(v_终止时间, ''), 'yyyy-mm-dd hh24:mi:ss');
    
      If d_开始时间 >= d_终止时间 Then
        d_终止时间 := d_终止时间 + 1;
      End If;
    
      If Nvl(n_序号, 0) <> 0 Then
        Insert Into 临床出诊号源时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
        Values
          (Id_In, n_序号, d_开始时间, d_终止时间, n_数量, n_是否预约);
      End If;
    End Loop;
  
  End If;

  --插入号源的缺省控制
  --号源控制_IN:类型,性质,名称,控制方式,序号,数量|
  If 号源控制_In Is Not Null Then
    For c_时间段集 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(号源控制_In, '|'))) Loop
      n_类型     := Null;
      n_性质     := Null;
      v_名称     := Null;
      n_序号     := Null;
      n_控制方式 := Null;
      n_限制数量 := Null;
    
      --类型,性质,名称,控制方式,序号,数量|
      For c_时间段 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(c_时间段集.值)) Order By 序号) Loop
        If c_时间段.序号 = 1 Then
          n_类型 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 2 Then
          n_性质 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 3 Then
          v_名称 := c_时间段.值;
        End If;
      
        If c_时间段.序号 = 4 Then
          n_控制方式 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 5 Then
          n_序号 := To_Number(c_时间段.值);
        End If;
      
        If c_时间段.序号 = 6 Then
          n_限制数量 := To_Number(c_时间段.值);
        End If;
      
      End Loop;
    
      If v_名称 Is Not Null Then
        Insert Into 临床出诊号源控制
          (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
        Values
          (Id_In, n_类型, n_性质, v_名称, n_序号, n_控制方式, n_限制数量);
      
      End If;
    End Loop;
  End If;
  --插入号源诊室
  If 号源诊室_In Is Not Null Then
    Insert Into 临床出诊号源诊室
      (限制id, 诊室id)
      Select Id_In As 限制id, Column_Value As 科室id From Table(f_Num2list(号源诊室_In));
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊号源限制_Modify;
/

Create Or Replace Procedure Zl_临床出诊表_导入
(
  号码_In 挂号安排.号码%Type := Null,
  开始_In Number := 1
) As
  -------------------------------------------------------------------------
  --功能说明：导放临床出诊表,主要是根据挂号安排，挂号计划安排等表进行数据导入
  --入参：
  --    开始_In:传入号码时有效，表示第一个
  -------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  l_限制id t_Numlist := t_Numlist();
  n_Count  Number(18);

  v_时间段 Varchar2(4000);

  Procedure Zl_Register_Import(号码_In 挂号安排.号码%Type) As
    n_号源id   临床出诊号源.Id%Type;
    d_建档时间 临床出诊号源.建档时间%Type;
  
    n_出诊id 临床出诊表.Id%Type;
    n_安排id 临床出诊安排.Id%Type;
  
    n_限制id 临床出诊号源限制.Id%Type;
    n_诊室id 门诊诊室.Id%Type;
  
    n_是否导入     Number(2);
    n_是否临时安排 临床出诊安排.是否临时安排%Type;
  
    n_Count  Number(18);
    l_限制id t_Numlist := t_Numlist();
  Begin
    For c_号源 In (Select ID, 号类, 号码, 科室id, 项目id, 医生姓名, Decode(医生id, 0, Null, 医生id) As 医生id, 序号, 周日, 周一, 周二, 周三, 周四, 周五, 周六,
                        病案必须, 分诊方式, 序号控制, 开始时间, 终止时间, 执行时间, 执行计划id, 默认时段间隔, 预约天数, Nvl(是否删除, 0) As 是否删除,
                        Nvl(停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) As 停用日期
                 From 挂号安排 A
                 Where 号码 = 号码_In
                      --科室，项目，医生相同的已经导入了一个号别就不再导入
                       And Not Exists
                  (Select 1
                        From 临床出诊号源
                        Where 科室id = a.科室id And 项目id = a.项目id And 医生姓名 = a.医生姓名 And Nvl(医生id, 0) = Nvl(a.医生id, 0))) Loop
    
      n_是否导入 := 1;
      --对于科室，项目，医生三者都相同的多个号别，首先考虑导入有效号别中的第一个，如果没有，则导入失效号别中的第一个
      Select Count(1)
      Into n_Count
      From 挂号安排
      Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And 医生姓名 = c_号源.医生姓名 And Nvl(医生id, 0) = Nvl(c_号源.医生id, 0);
      If Nvl(n_Count, 0) = 1 Then
        --科室，项目，医生是唯一的
        n_是否导入 := 1;
      Else
        --是否存在未停用且未删除的号别
        Select Count(1)
        Into n_Count
        From 挂号安排
        Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And 医生姓名 = c_号源.医生姓名 And Nvl(医生id, 0) = Nvl(c_号源.医生id, 0) And
              c_号源.是否删除 = 0 And (停用日期 Is Null Or 停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd'));
        If Nvl(n_Count, 0) = 0 Then
          --不存在未停用且未删除的号别，直接导入当前号别，即失效号别中的第一个
          n_是否导入 := 1;
        Elsif Nvl(n_Count, 0) = 1 Then
          --只存在一个未停用且未删除的号别，检查是不是当前号别
          If c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd') Then
            n_是否导入 := 1;
          Else
            n_是否导入 := 0;
          End If;
        Else
          --检查当前号别是否已停用或已删除
          If Not (c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd')) Then
            --已停用或已删除则不导入
            n_是否导入 := 0;
          Else
            --当前号别安排/计划是否有效
            Select Count(1)
            Into n_Count
            From 挂号安排计划
            Where 安排id = c_号源.Id And 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                  Rownum < 2;
            If Nvl(n_Count, 0) = 0 Then
              --无计划
              Select Count(1)
              Into n_Count
              From 挂号安排 A
              Where a.Id = c_号源.Id And Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            Else
              --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
              --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
              --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的


            
              Select Count(1)
              Into n_Count
              From 挂号安排计划 A
              Where a.审核时间 Is Not Null And Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    a.安排id = c_号源.Id And
                    (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                    Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                     (Select 1
                      From 挂号安排计划
                      Where 安排id = a.安排id And 审核时间 Is Not Null And
                            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')))) And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            End If;
          
            If Nvl(n_Count, 0) <> 0 Then
              --当前号别安排有效
              n_是否导入 := 1;
            Else
              --当前号别安排无效
              n_是否导入 := 0;
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(n_是否导入, 0) = 1 Then
        Select 临床出诊号源_Id.Nextval Into n_号源id From Dual;
      
        Select Nvl(Min(开始时间), Sysdate)
        Into d_建档时间
        From (Select Min(开始时间) As 开始时间
               From 挂号安排
               Where ID = c_号源.Id
               Union All
               Select Min(生效时间) As 开始时间
               From 挂号安排计划
               Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And 安排id = c_号源.Id);
      
        --1.处理临床出诊号源
        Insert Into 临床出诊号源
          (ID, 号类, 号码, 科室id, 项目id, 医生id, 医生姓名, 是否建病案, 预约天数, 出诊频次, 假日控制状态, 是否临床排班, 排班方式, 是否删除, 建档时间, 撤档时间)
        Values
          (n_号源id, c_号源.号类, c_号源.号码, c_号源.科室id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, c_号源.病案必须, c_号源.预约天数, c_号源.默认时段间隔, 2,
           0, 0, c_号源.是否删除, d_建档时间, c_号源.停用日期);
      
        --2.处理临床出诊停诊记录
        --一个医生一个停诊计划只导入一个，可能存在一个医生多个号别的情况，他们的停诊计划一样
        Insert Into 临床出诊停诊记录
          (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
          Select 临床出诊停诊记录_Id.Nextval, Null, a.开始停止时间, a.结束停止时间, a.备注, b.医生姓名, a.制订日期, a.制订人, a.制订日期, a.制订人
          From 挂号安排停用状态 A, 挂号安排 B
          Where a.安排id = b.Id And b.Id = c_号源.Id And b.医生id Is Not Null And Not Exists
           (Select 1
                 From 临床出诊停诊记录
                 Where 记录id Is Null And 申请人 = b.医生姓名 And 开始时间 = a.开始停止时间 And 终止时间 = a.结束停止时间);
      
        --3.处理相关的出诊表数据
        --3.1 固定出诊表
        Begin
          Select ID Into n_出诊id From 临床出诊表 Where Nvl(排班方式, 0) = 0 And 发布时间 Is Null;
        Exception
          When Others Then
            Return;
        End;
      
        --3.2导入临床出诊安排
        --失效的安排和计划不导入
        --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
        --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
        --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的


      
        For c_详情 In (
                     --1.无计划的安排
                     Select a.Id As 安排id, -1 * Null As 计划id, a.科室id, a.项目id, a.医生姓名,
                             Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式,
                             a.序号控制, Nvl(a.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                             Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排 A
                     Where a.Id = c_号源.Id And Not Exists (Select 1
                            From 挂号安排计划
                            Where 安排id = a.Id And 审核时间 Is Not Null And
                                  Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) And
                           Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate
                     Union All
                     --有计划的安排,只导入有效的
                     Select a.安排id, a.Id As 计划id, b.科室id, a.项目id, a.医生姓名, Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日,
                            a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                            Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排计划 A, 挂号安排 B
                     Where a.安排id = b.Id And a.审核时间 Is Not Null And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And b.Id = c_号源.Id And
                           (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                            (Select 1
                             From 挂号安排计划
                             Where 安排id = a.安排id And 审核时间 Is Not Null And
                                   Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                                   Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd'))))) Loop
        
          Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
        
          n_诊室id := Null;
          If Nvl(c_详情.分诊方式, 0) = 1 Then
            Begin
              If Nvl(c_详情.计划id, 0) <> 0 Then
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号计划诊室 B
                Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id And Rownum < 2;
              Else
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号安排诊室 B
                Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id And Rownum < 2;
              End If;
            Exception
              When Others Then
                n_诊室id := Null;
            End;
          End If;
        
          --a.临床出诊安排
          n_是否临时安排 := 0;
          Begin
            Select 1 Into n_是否临时安排 From 临床出诊安排 Where 号源id = n_号源id And Rownum < 2;
          Exception
            When Others Then
              n_是否临时安排 := 0;
          End;
          Insert Into 临床出诊安排
            (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间, 是否临时安排)
          Values
            (n_安排id, n_出诊id, n_号源id, c_详情.项目id, c_详情.医生id, c_详情.医生姓名, c_详情.开始时间, c_详情.终止时间, Zl_Username, c_详情.开始时间,
             n_是否临时安排);
        
          --b.临床出诊限制
          --说明：限约数等于0表示禁止预约，限约数为空表示不限制预约
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Select Count(1) Into n_Count From 挂号计划限制 Where 计划id = c_详情.计划id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号计划限制 A, (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+) And 计划id = c_详情.计划id;
            End If;
          Else
            Select Count(1) Into n_Count From 挂号安排限制 Where 安排id = c_详情.安排id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号安排限制 A, (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+) And 安排id = c_详情.安排id;
            End If;
          End If;
        
          --c.临床出诊诊室
          If Nvl(c_详情.分诊方式, 0) > 0 Then
            If Nvl(c_详情.计划id, 0) <> 0 Then
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号计划诊室 B
                       Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id) B
                Where a.安排id = n_安排id;
            Else
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号安排诊室 B
                       Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id) B
                Where a.安排id = n_安排id;
            End If;
          End If;
        
          --D.临床出诊时段
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约


                     
                     From 挂号计划时段
                     Where 计划id = c_详情.计划id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          
          Else
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约


                     
                     From 挂号安排时段
                     Where 安排id = c_详情.安排id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          End If;
        
          --不分时段的序号控制号先生成序号
          --开始时间、终止时间填写时间段的开始时间和结束时间
          For c_限制项目 In (Select ID, 限号数, 上班时段
                         From 临床出诊限制
                         Where 安排id = n_安排id And Nvl(限号数, 0) <> 0 And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 0) Loop
            For I In 1 .. c_限制项目.限号数 Loop
              Insert Into 临床出诊时段
                (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
                Select c_限制项目.Id, I, 开始时间, 终止时间, 1, 1
                From 时间段
                Where 站点 Is Null And 号类 Is Null And 时间段 = c_限制项目.上班时段;
            End Loop;
          End Loop;
        
          --任何一个都不允许预约时表示全部允许预约
          Update 临床出诊时段 A
          Set a.是否预约 = 1
          Where 限制id In (Select ID From 临床出诊限制 Where 安排id = n_安排id) And Not Exists
           (Select 1 From 临床出诊时段 B Where a.限制id = b.限制id And Nvl(b.是否预约, 0) = 1);
        
          --E.合作单位挂号控制
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                               When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                                0
                               When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                                2
                               When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                                3
                               Else
                                4
                             End As 控制方式, 数量
                     From 合作单位计划控制
                     Where 计划id = c_详情.计划id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          Else
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                              When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                               0
                              When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                               2
                              When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                               3
                              Else
                               4
                            End As 控制方式, 数量
                     From 合作单位安排控制
                     Where 安排id = c_详情.安排id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          End If;
        End Loop;
      
        --4.停用没有有效安排的号源，并删除无效的安排
        --主要是处理所有计划已失效或者有效计划只有一个且这个计划周一到周日都没有上班时段的
        Begin
          Select 1
          Into n_Count
          From 临床出诊限制 A, 临床出诊安排 B, 临床出诊号源 C
          Where a.安排id = b.Id And b.号源id = c.Id And c.Id = n_号源id And a.上班时段 Is Not Null And Nvl(c.是否删除, 0) = 0 And
                Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And Rownum < 2;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If Nvl(n_Count, 0) = 0 Then
          --没有有效的安排，停用号源，删除安排
          Select a.Id Bulk Collect
          Into l_限制id
          From 临床出诊限制 A, 临床出诊安排 B
          Where a.安排id = b.Id And b.号源id = n_号源id;
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊时段 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊限制 Where ID = l_限制id(I);
        
          Delete From 临床出诊安排 Where 号源id = n_号源id;
        
          Update 临床出诊号源 Set 撤档时间 = Sysdate Where ID = n_号源id;
        End If;
      
        --5.拷贝一份出诊信息作为号源控制信息
        --说明：上班时段按安排的登记时间倒序取第一个
        For c_限制 In (Select ID, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id
                     From (Select a.Id, a.上班时段, a.限号数, a.限约数, a.是否序号控制, a.是否分时段, a.预约控制, a.是否独占, a.分诊方式, a.诊室id,
                                   Row_Number() Over(Partition By a.上班时段 Order By b.登记时间 Desc) As 组号
                            From 临床出诊限制 A, 临床出诊安排 B
                            Where a.安排id = b.Id And b.号源id = n_号源id)
                     Where 组号 = 1) Loop
          --a.临床出诊号源限制
          Select 临床出诊号源限制_Id.Nextval Into n_限制id From Dual;
          Insert Into 临床出诊号源限制
            (ID, 号源id, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id)
          Values
            (n_限制id, n_号源id, c_限制.上班时段, c_限制.限号数, c_限制.限约数, c_限制.是否序号控制, c_限制.是否分时段, c_限制.预约控制, c_限制.是否独占, c_限制.分诊方式,
             c_限制.诊室id);
          --b.临床出诊号源诊室
          Insert Into 临床出诊号源诊室
            (限制id, 诊室id)
            Select n_限制id, 诊室id From 临床出诊诊室 Where 限制id = c_限制.Id;
          --c.临床出诊号源时段
          Insert Into 临床出诊号源时段
            (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
            Select n_限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约 From 临床出诊时段 Where 限制id = c_限制.Id;
          --d.临床出诊号源控制
          Insert Into 临床出诊号源控制
            (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
            Select n_限制id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制 Where 限制id = c_限制.Id;
        End Loop;
      End If;
    End Loop;
  End;
Begin
  If Nvl(开始_In, 0) = 1 Then
    Select Count(1) Into n_Count From 临床出诊表 A, 临床出诊安排 B Where a.Id = b.出诊id And Rownum < 2;
    If n_Count <> 0 Then
      v_Err_Msg := '当前已经存在临床出诊安排了，请先删除，否则不允许导入！';
      Raise Err_Item;
    End If;
  
    Begin
      Select f_List2str(Cast(Collect(s.时间段) As t_Strlist))
      Into v_时间段
      From (Select 时间段, Row_Number() Over(Partition By 时间段 Order By 时间段) As 组号
             From (Select Decode(b.行号, 1, a.周一, 2, a.周二, 3, a.周三, 4, a.周四, 5, a.周五, 6, a.周六, a.周日) As 时间段
                    From (Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排
                           Union All
                           Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排计划
                           Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) A,
                         (Select Level As 行号 From Dual Connect By Level <= 7) B)
             Where 时间段 Is Not Null) S, 时间段 T
      Where s.时间段 = t.时间段(+) And t.时间段 Is Null And s.组号 = 1;
    Exception
      When Others Then
        v_时间段 := Null;
    End;
  
    If v_时间段 Is Not Null Then
      v_Err_Msg := '原挂号安排中的上班时间段【' || v_时间段 || '】不存在，请先在“基础设置>上班时间管理”中添加！';
      Raise Err_Item;
    End If;
  
    --删除现有所有号源，在调用之前已进行了提示
    Select a.Id Bulk Collect Into l_限制id From 临床出诊号源限制 A, 临床出诊号源 B Where a.号源id = b.Id;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源限制 Where ID = l_限制id(I);
  
    Delete From 临床出诊号源;
  
    --删除所有停诊记录
    Delete From 临床出诊停诊记录;
  End If;

  If Not 号码_In Is Null Then
    Zl_Register_Import(号码_In);
    Return;
  End If;

  For c_号源 In (Select 号码 From 挂号安排 Order By ID Desc) Loop
    --删除以及停用的号源也全部导入
    Zl_Register_Import(c_号源.号码);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_导入;
/

Create Or Replace Procedure Zl_Clinicvisitmodify
(
  号源id_In     In 临床出诊记录.号源id%Type,
  安排id_In     In 临床出诊记录.号源id%Type,
  出诊日期_In   In 临床出诊记录.出诊日期%Type,
  登记人_In     In 临床出诊记录.登记人%Type,
  登记时间_In   In 临床出诊记录.登记时间%Type,
  是否已换休_In In Number := 0
) As
  --功能：根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
  --入参：
  --     是否已换休_In 主要用于换休后进行停诊处理
  --说明：
  --     临床出诊号源.假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
  --     1-停诊，在停诊安排时间范围内
  --     2-停诊，在法定节假日内
  --       2.1临床出诊号源.假日控制状态=0
  --       2.2临床出诊号源.假日控制状态=3，且设置了允许预约/允许挂号，但该上班时段不在设置的允许预约/允许挂号的时间范围内
  --     3-禁止预约，在法定节假日内，
  --       3.1临床出诊号源.假日控制状态=2
  --       3.3临床出诊号源.假日控制状态=3，设置了允许预约/允许挂号，且该上班时段在设置的允许挂号的时间范围内，但不在设置的允许预约时间范围内
  --     else-正常出诊

  n_假日控制状态 临床出诊号源.假日控制状态%Type;
  n_是否假日换休 临床出诊号源.是否假日换休%Type;

  d_原上班日期 临床出诊记录.出诊日期%Type;
  d_调休日期   临床出诊记录.出诊日期%Type;

  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
  v_停诊原因     临床出诊记录.停诊原因%Type;

  d_假日开始日期 法定假日表.开始日期%Type;
  d_假日终止日期 法定假日表.终止日期%Type;
  v_允许预约     法定假日表.允许预约%Type;
  v_允许挂号     法定假日表.允许挂号%Type;

  d_停止预约开始时间 临床出诊记录.停诊开始时间%Type;
  d_停止预约终止时间 临床出诊记录.停诊终止时间%Type;

  n_Count    Number(2);
  n_允许预约 Number(2);
  n_允许挂号 Number(2);

  Procedure Stopbespeak
  (
    记录id_In   In 临床出诊记录.Id%Type,
    开始时间_In In 临床出诊记录.开始时间%Type,
    终止时间_In In 临床出诊记录.终止时间%Type
  ) As
    --功能：禁止预约
    --说明：
    --      分时段且序号控制的，修改"临床出诊序号控制.是否预约"等于1的为0；取消发布时根据"预约顺序号"恢复
    --      分时段且不序号控制的，修改"临床出诊序号控制.是否预约"为0；取消发布时根据恢复为1
    --      不分时段的，提供公共函数在挂号预约时检查预约时间是否在不允许预约的时间范围内
  Begin
    Update 临床出诊序号控制 Set 是否预约 = 0 Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In;
  End Stopbespeak;

  Procedure Stopvisit
  (
    记录id_In       In 临床出诊记录.Id%Type,
    停诊开始时间_In In 临床出诊记录.停诊开始时间%Type,
    停诊终止时间_In In 临床出诊记录.停诊终止时间%Type,
    停诊原因_In     In 临床出诊记录.停诊原因%Type
  ) As
    --功能：停诊
    --说明：
    --     同一条出诊记录可以存在多条停诊记录，临床出诊记录的停诊开始时间为多条停诊记录的最小开始时间，停诊终止时间为多条停诊记录的最大终止时间

  
    d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
    d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
    v_停诊原因     临床出诊记录.停诊原因%Type;
  Begin
    --产生停诊记录
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, ID, 停诊开始时间_In, 停诊终止时间_In, 停诊原因_In, Nvl(医生姓名, 登记人_In), 登记时间_In, 登记人_In, 登记时间_In, 登记人_In
      From 临床出诊记录
      Where ID = 记录id_In;
  
    Begin
      Select Min(a.开始时间), Max(a.终止时间), Max(a.停诊原因)
      Into d_停诊开始时间, d_停诊终止时间, v_停诊原因
      From 临床出诊停诊记录 A
      Where a.记录id = 记录id_In And a.取消时间 Is Null;
    Exception
      When Others Then
        d_停诊开始时间 := Null;
        d_停诊终止时间 := Null;
        v_停诊原因     := Null;
    End;
  
    Update 临床出诊记录
    Set 停诊开始时间 = d_停诊开始时间, 停诊终止时间 = d_停诊终止时间, 停诊原因 = v_停诊原因
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 停诊开始时间_In And 停诊终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  End Stopvisit;

  Procedure Changedaysoff
  (
    号源id_In     In 临床出诊记录.号源id%Type,
    安排id_In     In 临床出诊记录.安排id%Type,
    出诊日期_In   In 临床出诊记录.出诊日期%Type,
    原上班日期_In In 临床出诊记录.出诊日期%Type,
    调休日期_In   In 临床出诊记录.出诊日期%Type
  ) As
    --功能：换休处理
    n_安排id 临床出诊记录.安排id%Type;
    l_记录id t_Numlist := t_Numlist();
    n_Count  Number(2);
  Begin
    --1.前面的安排换到今日
    If 原上班日期_In Is Not Null Then
      --1.1.前面的日期没有安排则不处理
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --[1]删除今日现有的安排
        Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In;
        Zl_临床出诊记录_Batchdelete(l_记录id);
      
        --[2]复制安排
        For c_换休记录 In (Select ID, 是否发布 From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In) Loop
          Zl_临床出诊记录_Copy(c_换休记录.Id, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, c_换休记录.是否发布);
        End Loop;
      
        --[3]重新对今日进行停诊安排和法定节假日调整
        For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
          Zl_Clinicvisitmodify(号源id_In, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, 1);
        End Loop;
      End If;
    End If;
  
    --2.今日的安排换到前面
    If 调休日期_In Is Not Null Then
      --2.1.今日没有安排则不处理
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --2.2.前面那一天的安排已存在预约挂号记录则不替换(有漏洞)
        Select Count(1)
        Into n_Count
        From 临床出诊记录 A, 病人挂号记录 B
        Where a.Id = b.出诊记录id And a.号源id = 号源id_In And a.出诊日期 = 调休日期_In And Rownum < 2;
      
        If Nvl(n_Count, 0) = 0 Then
          --[1]记录前面那一天的原安排ID,没有就不处理
          Begin
            Select ID
            Into n_安排id
            From (Select Rownum As Rn, ID
                   From 临床出诊安排
                   Where 号源id = 号源id_In And 调休日期_In Between 开始时间 And 终止时间 And 审核时间 Is Not Null
                   Order By 登记时间 Desc)
            Where Rn < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        
          If Nvl(n_安排id, 0) <> 0 Then
            --[2]删除前面那一天现有的安排
            Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In;
            Zl_临床出诊记录_Batchdelete(l_记录id);
          
            --[3]复制安排
            For c_换休记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
              --肯定是发布了的
              Zl_临床出诊记录_Copy(c_换休记录.Id, n_安排id, 调休日期_In, 登记人_In, 登记时间_In, 1);
            
            End Loop;
          
            --[4]重新对前面那一天进行停诊安排和法定节假日调整
            For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In) Loop
              Zl_Clinicvisitmodify(号源id_In, 安排id_In, 调休日期_In, 登记人_In, 登记时间_In, 1);
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End Changedaysoff;
Begin
  Begin
    Select Nvl(b.假日控制状态, 0), Nvl(b.是否假日换休, 0)
    Into n_假日控制状态, n_是否假日换休
    From 临床出诊号源 B
    Where b.Id = 号源id_In;
  Exception
    When Others Then
      --没有找到号源，直接退出
      Return;
  End;

  --================================================================================
  --【1】假日换休处理
  --说明：只能用后面的日期向前面检查，因为后面的日期可能还没有制定安排
  --================================================================================
  If Nvl(是否已换休_In, 0) = 0 Then
    --确定法定节假日是否需要换休
    If Nvl(n_是否假日换休, 0) = 1 Then
      --1.前面的安排换到今日
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日)
        Select a.终止日期
        Into d_原上班日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.开始日期 And a.终止日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_原上班日期 := Null;
      End;
    
      --2.今日的安排换到前面
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日)
        Select a.开始日期
        Into d_调休日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.终止日期 And a.开始日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_调休日期 := Null;
      End;
    
      Changedaysoff(号源id_In, 安排id_In, 出诊日期_In, d_原上班日期, d_调休日期);
    End If;
  End If;

  For c_记录 In (Select ID, 出诊日期, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null) Loop
    --================================================================================
    --【2】停诊安排停诊处理
    --================================================================================
    For c_停诊 In (Select a.开始时间, a.终止时间, a.停诊原因
                 From 临床出诊停诊记录 A, 临床出诊记录 B
                 Where a.申请人 = b.医生姓名 And a.记录id Is Null And a.审批时间 Is Not Null And a.取消时间 Is Null And
                       b.医生id Is Not Null And b.Id = c_记录.Id And c_记录.开始时间 < a.终止时间 And c_记录.终止时间 > a.开始时间
                 Order By a.审批时间) Loop
    
      d_停诊开始时间 := c_停诊.开始时间;
      d_停诊终止时间 := c_停诊.终止时间;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, c_停诊.停诊原因);
    End Loop;
  
    --================================================================================
    --【3】法定节假日停诊及禁止预约处理
    --================================================================================
    --1.查找含有上班时段时间的节假日，以第一个为准（开始时间升序排序），一般也只有一个
    Begin
      Select 开始日期, 终止日期, 节日名称, 允许预约, 允许挂号
      Into d_假日开始日期, d_假日终止日期, v_停诊原因, v_允许预约, v_允许挂号
      From (Select a.开始日期, a.终止日期, a.节日名称, a.允许预约, a.允许挂号
             From 法定假日表 A
             Where a.性质 = 0 And c_记录.开始时间 < a.终止日期 And c_记录.终止时间 > a.开始日期
             Order By a.开始日期)
      Where Rownum < 2;
    Exception
      When Others Then
        Return;
    End;
  
    --假日控制状态:0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
    If Nvl(n_假日控制状态, 0) = 0 Then
      --不上班，停诊
      d_停诊开始时间 := d_假日开始日期;
      d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
    Elsif Nvl(n_假日控制状态, 0) = 2 Then
      --允许挂号，但禁止预约
      d_停止预约开始时间 := d_假日开始日期;
      d_停止预约终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
      If d_停止预约开始时间 < c_记录.开始时间 Then
        d_停止预约开始时间 := c_记录.开始时间;
      End If;
      If d_停止预约终止时间 > c_记录.终止时间 Then
        d_停止预约终止时间 := c_记录.终止时间;
      End If;
      Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
    Elsif Nvl(n_假日控制状态, 0) = 3 Then
      --没有"允许挂号"的就一定没有"允许预约"的
      If v_允许挂号 Is Not Null Then
        --2.检查是否有包含上班时段时间的"允许挂号"
        --因为上班时段最多24小时，所以查出的结果最多两天，且这两天一定是连续的
        n_允许挂号 := 0;
        For c_允许挂号 In (With 临时表 As
                          (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                 To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                          From Table(f_Str2list(v_允许挂号, ';'))
                          Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                          Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                         Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                         From 临时表 A, 临时表 B
                         Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
        
          n_允许挂号 := 1;
          n_允许预约 := 0;
          --3.检查是否有包含上班时段时间的"允许预约"
          For c_允许预约 In (With 临时表 As
                            (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                   To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                            From Table(f_Str2list(v_允许预约, ';'))
                            Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                  c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                            Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                           Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                           From 临时表 A, 临时表 B
                           Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
          
            n_允许预约 := 1;
            --在"允许挂号","允许预约"时间范围内的不需要处理
          
            --检查前后是否需要禁止预约
            If c_记录.开始时间 < c_允许预约.开始时间 And c_允许挂号.开始时间 < c_允许预约.开始时间 Then
              If c_记录.开始时间 < c_允许挂号.开始时间 Then
                d_停止预约开始时间 := c_允许挂号.开始时间;
              Else
                d_停止预约开始时间 := c_记录.开始时间;
              End If;
              d_停止预约终止时间 := c_允许预约.开始时间;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          
            If c_记录.终止时间 > c_允许预约.终止时间 And c_允许挂号.终止时间 > c_允许预约.终止时间 Then
              d_停止预约开始时间 := c_允许预约.终止时间;
              If c_记录.终止时间 > c_允许挂号.终止时间 Then
                d_停止预约开始时间 := c_允许挂号.终止时间;
              Else
                d_停止预约开始时间 := c_记录.终止时间;
              End If;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          End Loop;
        
          --允许挂号，但禁止预约
          If Nvl(n_允许预约, 0) = 0 Then
            d_停止预约开始时间 := c_允许挂号.开始时间;
            d_停止预约终止时间 := c_允许挂号.终止时间;
            If d_停止预约开始时间 < c_记录.开始时间 Then
              d_停止预约开始时间 := c_记录.开始时间;
            End If;
            If d_停止预约终止时间 > c_记录.终止时间 Then
              d_停止预约终止时间 := c_记录.终止时间;
            End If;
            Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
          End If;
        
          --检查前后是否需要停诊
          If c_记录.开始时间 < c_允许挂号.开始时间 And d_假日开始日期 < c_允许挂号.开始时间 Then
            If c_记录.开始时间 < d_假日开始日期 Then
              d_停诊开始时间 := d_假日开始日期;
            Else
              d_停诊开始时间 := c_记录.开始时间;
            End If;
            d_停诊终止时间 := c_允许挂号.开始时间;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        
          If c_记录.终止时间 > c_允许挂号.终止时间 And d_假日终止日期 > c_允许挂号.终止时间 Then
            d_停诊开始时间 := c_允许挂号.终止时间;
            If c_记录.终止时间 > d_假日终止日期 Then
              d_停诊终止时间 := d_停诊终止时间;
            Else
              d_停诊终止时间 := c_记录.终止时间;
            End If;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        End Loop;
      
        --不在设置的允许挂号时间范围内，停诊
        If Nvl(n_允许挂号, 0) = 0 Then
          d_停诊开始时间 := d_假日开始日期;
          d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
          If d_停诊开始时间 < c_记录.开始时间 Then
            d_停诊开始时间 := c_记录.开始时间;
          End If;
          If d_停诊终止时间 > c_记录.终止时间 Then
            d_停诊终止时间 := c_记录.终止时间;
          End If;
          Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
        End If;
      Else
        --未设置允许挂号/允许预约，则停诊
        d_停诊开始时间 := d_假日开始日期;
        d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停诊开始时间 < c_记录.开始时间 Then
          d_停诊开始时间 := c_记录.开始时间;
        End If;
        If d_停诊终止时间 > c_记录.终止时间 Then
          d_停诊终止时间 := c_记录.终止时间;
        End If;
        Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
      End If;
    End If;
  End Loop;
End Zl_Clinicvisitmodify;
/
Create Or Replace Procedure Zl1_Auto_Buildingregisterplan
(
  挂号时间_In In Date := Null,
  号源id_In   临床出诊号源.Id%Type := Null
) As
  -------------------------------------------------------------------------
  --功能说明：自动生成临床出诊记录
  --          1、根据号源自动生成预约数内的临床出诊记录;
  --          2、预约天数的确定:号源预约天数-->预约方式的天数（取最大)-->系统预约天数
  --入参:挂号时间_IN:NULL时，自动生成;否则只检查指定日期是否生成了出诊记录没有
  --    号源id_In:NULL时处理所有号源，否则只处理指定号源
  -------------------------------------------------------------------------
  n_缺省预约天数 临床出诊号源.预约天数%Type;
  v_操作员姓名   临床出诊安排.操作员姓名%Type;
  d_登记日期     临床出诊安排.登记时间%Type;
  n_安排id       临床出诊安排.Id%Type;

  n_记录id   临床出诊记录.Id%Type;
  d_当前日期 临床出诊记录.出诊日期%Type;

  n_是否出诊 Number(2);
  l_固定时段 t_Strlist := t_Strlist();
  n_Count    Number(18);
Begin

  Select Max(预约天数) Into n_缺省预约天数 From 预约方式;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := To_Number(Nvl(zl_GetSysParameter('挂号允许预约天数'), '0'));
  End If;
  If Nvl(n_缺省预约天数, 0) = 0 Then
    n_缺省预约天数 := 7;
  End If;

  d_当前日期   := Trunc(Nvl(挂号时间_In, Sysdate));
  d_登记日期   := Sysdate;
  v_操作员姓名 := Zl_Username;

  --第一层循环，号源信息
  For c_号源 In (Select c.Id, c.号类, c.号码, c.科室id, c.医生姓名, Decode(Nvl(c.预约天数, 0), 0, n_缺省预约天数, c.预约天数) As 预约天数,
                      Nvl(b.站点, '-') As 站点, Nvl(c.是否假日换休, 0) As 是否假日换休, Nvl(c.假日控制状态, 0) As 假日控制状态,
                      Nvl(c.排班方式, 0) As 排班方式
               From 临床出诊号源 C, 部门表 B
               Where c.科室id = b.Id And Nvl(c.是否删除, 0) = 0 And
                     (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     (号源id_In Is Null Or c.Id = 号源id_In)
                    --
                     And Exists (Select 1
                      From 临床出诊安排 M, 临床出诊表 N
                      Where m.出诊id = n.Id And m.号源id = c.Id And Nvl(n.排班方式, 0) = 0 And n.发布时间 Is Not Null And
                            m.审核时间 Is Not Null And d_当前日期 <= m.终止时间)) Loop
  
    --第二层循环，出诊日期
    --从头一天开始生成，避免如全日(8:00-7:59)在0:00-7:59没有出诊记录
    For c_日期 In (Select m.日期,
                        Decode(To_Char(m.日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                                '周六', Null) As 星期
                 From (Select Trunc(d_当前日期) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 1)
                        Where 号源id_In Is Not Null
                        Union All
                        Select Trunc(d_当前日期 - 1) + 天数 As 日期
                        From (Select Level - 1 As 天数 From Dual Connect By Level <= c_号源.预约天数 + 2)
                        Where 号源id_In Is Null) M) Loop
    
      l_固定时段 := t_Strlist();
      --检查当日是否在月/周出诊表中,若在，则不生成出诊记录
      Select Count(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊表 B
      Where a.出诊id = b.Id And a.号源id = c_号源.Id And c_日期.日期 Between Trunc(a.开始时间) And Trunc(a.终止时间) And
            Nvl(b.排班方式, 0) In (1, 2) And Rownum < 2;
    
      --当前号源为按月/周排班，且当前日期之前已有按月/周排班的出诊记录就不再按固定安排生成出诊记录了
      If Nvl(n_Count, 0) = 0 And Nvl(c_号源.排班方式, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 临床出诊安排 A, 临床出诊表 B
        Where a.出诊id = b.Id And Nvl(b.排班方式, 0) In (1, 2) And a.号源id = c_号源.Id And a.开始时间 < c_日期.日期 And Rownum < 2;
      End If;
    
      If Nvl(n_Count, 0) = 0 Then
        If 号源id_In Is Null Then
          --出诊安排,取最后登记的一个
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null And c_日期.日期 Between a.开始时间 And a.终止时间
                   Order By a.登记时间 Desc)
            Where Rownum < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        Else
          --如果指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录，最后登记的一个肯定是本次新增的，
          --只需要处理这个安排即可，不在这个安排有效时间范围内的就不处理
          Begin
            Select 安排id
            Into n_安排id
            From (Select a.Id As 安排id, a.开始时间, a.终止时间, Row_Number() Over(Order By a.登记时间 Desc) As 行号
                   From 临床出诊安排 A, 临床出诊表 B
                   Where a.号源id = c_号源.Id And a.出诊id = b.Id And Nvl(b.排班方式, 0) = 0 And b.发布时间 Is Not Null And
                         a.审核时间 Is Not Null)
            Where 行号 = 1 And c_日期.日期 Between 开始时间 And 终止时间;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        End If;
      
        If Nvl(n_安排id, 0) <> 0 Then
          If 号源id_In Is Null Then
            --确定当日是否有出诊记录
            Select Count(1)
            Into n_Count
            From 临床出诊记录 A
            Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期 And Rownum < 2;
          
            --1.未指定号源ID，则是正常生成出诊记录，有出诊记录的日期将不再处理
            If Nvl(n_Count, 0) = 0 Then
              --1.1无出诊记录，正常生成
              n_是否出诊 := 1;
            Else
              --1.2有出诊记录，不再处理
              n_是否出诊 := 0;
            End If;
          Else
            --2.指定了号源ID，肯定是发布后新增了临时安排重新生成出诊记录
            n_是否出诊 := 1;
            --当日有出诊记录，需要做如下处理
            For c_记录 In (Select a.安排id, a.Id As 记录id, a.出诊日期, a.上班时段, a.是否分时段, a.是否序号控制
                         From 临床出诊记录 A
                         Where a.号源id = c_号源.Id And a.出诊日期 = c_日期.日期) Loop
            
              Select Count(1) Into n_Count From 病人挂号记录 Where 出诊记录id = c_记录.记录id;
              If Nvl(n_Count, 0) = 0 Then
                --2.2.1如果时段不存在预约挂号数据，则删除重新生成
                Zl_临床出诊上班时段_Delete(c_记录.安排id, To_Char(c_记录.出诊日期, 'yyyy-mm-dd'), 1, c_记录.上班时段);
              Else
                --2.2.2如果时段存在预约挂号数据，则只需调整出诊记录的安排ID即可
                Update 临床出诊记录 Set 安排id = n_安排id Where ID = c_记录.记录id;
                l_固定时段.Extend();
                l_固定时段(l_固定时段.Count) := c_记录.上班时段;
              End If;
            End Loop;
          End If;
        
          --检查这天是否出诊
          If n_是否出诊 = 1 Then
            Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = n_安排id And 限制项目 = c_日期.星期;
            If Nvl(n_Count, 0) = 0 Then
              n_是否出诊 := 0;
            End If;
          End If;
        
          If Nvl(n_是否出诊, 0) = 0 Then
            --如果不存在临床出诊记录，则增加临床出诊记录(时间段为NULL 的空记录)
            Insert Into 临床出诊记录
              (ID, 安排id, 号源id, 出诊日期, 登记人, 登记时间)
              Select 临床出诊记录_Id.Nextval, n_安排id, a.Id As ID, c_日期.日期, v_操作员姓名, d_登记日期 As 登记时间
              From 临床出诊号源 A, 临床出诊安排 B
              Where a.Id = b.号源id And b.Id = n_安排id
                   --
                    And Not Exists (Select 1 From 临床出诊记录 Where 号源id = a.Id And 出诊日期 = c_日期.日期);
          Else
            For c_记录 In (With c_时间段 As
                            (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                            From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                          Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                                   From 时间段
                                   Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                            Where 组号 = 1)
                           Select n_安排id As 安排id, B1.号源id, c_日期.日期 As 出诊日期, m.上班时段, m.Id As 限制id,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                           'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.终止时间 <= j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 终止时间, Null As 停诊开始时间, Null As 停诊终止时间, Null As 停诊原因,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.缺省时间 < j.开始时间 Then
                                     1
                                    Else
                                     0
                                  End As 缺省预约时间,
                                  To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                          'yyyy-mm-dd hh24:mi:ss') + Case
                                    When j.开始时间 < j.提前时间 Then
                                     -1
                                    Else
                                     0
                                  End As 提前挂号时间, m.限号数, 0 As 已挂数, m.限约数, 0 As 已约数, 0 As 其中已接收, m.是否序号控制, m.是否分时段, m.预约控制,
                                  m.是否独占, B1.项目id, B1.医生id, B1.医生姓名, Null As 替诊医生id, Null As 替诊医生姓名, m.分诊方式, m.诊室id,
                                  0 As 是否锁定, 0 As 是否临时出诊, v_操作员姓名 As 操作员姓名, d_登记日期 As 登记时间, c_日期.星期 As 限制项目
                           From 临床出诊安排 B1, 临床出诊限制 M, c_时间段 J
                           Where B1.Id = n_安排id And B1.Id = m.安排id And m.限制项目 = c_日期.星期 And m.上班时段 = j.时间段 And
                                 To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                         'yyyy-mm-dd hh24:mi:ss') >= B1.开始时间) Loop
              Begin
                Select 1 Into n_Count From Table(l_固定时段) Where Column_Value = c_记录.上班时段;
              Exception
                When Others Then
                  n_Count := 0;
              End;
            
              If Nvl(n_Count, 0) = 0 Then
                Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
                Insert Into 临床出诊记录
                  (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 停诊开始时间, 停诊终止时间, 停诊原因, 缺省预约时间, 提前挂号时间, 限号数, 已挂数, 限约数, 已约数,
                   其中已接收, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 分诊方式, 诊室id, 是否锁定, 是否临时出诊,
                   登记人, 登记时间, 是否发布)
                Values
                  (n_记录id, c_记录.安排id, c_记录.号源id, c_记录.出诊日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.停诊开始时间, c_记录.停诊终止时间,
                   c_记录.停诊原因, c_记录.缺省预约时间, c_记录.提前挂号时间, c_记录.限号数, c_记录.已挂数, c_记录.限约数, c_记录.已约数, c_记录.其中已接收, c_记录.是否序号控制,
                   c_记录.是否分时段, c_记录.预约控制, c_记录.是否独占, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名, c_记录.替诊医生id,
                   c_记录.替诊医生姓名, c_记录.分诊方式, c_记录.诊室id, c_记录.是否锁定, c_记录.是否临时出诊, c_记录.操作员姓名, d_登记日期, 1);
              
                --插入临床出诊序号控制
                If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
                  --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss') + Case
                              When 终止时间 <= 开始时间 Then
                               1
                              Else
                               0
                            End, 限制数量, 是否预约, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                Else
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
                    Select n_记录id, 序号,
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                                    'yyyy-mm-dd hh24:mi:ss'),
                           To_Date(To_Char(c_记录.出诊日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                                   'yyyy-mm-dd hh24:mi:ss') + Case
                             When 终止时间 <= 开始时间 Then
                              1
                             Else
                              0
                           End, 限制数量, 是否预约
                    From 临床出诊时段
                    Where 限制id = c_记录.限制id;
                End If;
              
                --插入合作单位挂号控制记录
                Insert Into 临床出诊挂号控制记录
                  (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
                  Select 类型, 性质, 名称, n_记录id, 序号, 控制方式, 数量
                  From 临床出诊挂号控制
                  Where 限制id = c_记录.限制id;
              
                --插入临床出诊诊室记录
                Insert Into 临床出诊诊室记录
                  (记录id, 诊室id)
                  Select n_记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
              End If;
            End Loop;
          
            --根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
            Zl_Clinicvisitmodify(c_号源.Id, n_安排id, c_日期.日期, v_操作员姓名, d_登记日期);
          End If;
        End If;
      End If;
      --一天一提交
      Commit;
    End Loop;
  End Loop;
End Zl1_Auto_Buildingregisterplan;
/
Create Or Replace Procedure Zl_临床出诊临时安排_Verify
(
  安排id_In   In 临床出诊安排.Id%Type,
  审核人_In   In 临床出诊安排.审核人%Type,
  审核时间_In In 临床出诊安排.审核时间%Type
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_Count    Number(1);
  n_号源id   临床出诊安排.号源id%Type;
  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;
  d_登记时间 临床出诊安排.登记时间%Type;
Begin
  Begin
    Select 号源id, 开始时间, 终止时间, 登记时间
    Into n_号源id, d_开始时间, d_终止时间, d_登记时间
    From 临床出诊安排
    Where ID = 安排id_In And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '当前安排已被他人删除，不能再审核！！';
      Raise Err_Item;
  End;

  Select 1 Into n_Count From 临床出诊限制 A Where a.安排id = 安排id_In And a.限制项目 Is Not Null And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前安排中无任何有效安排，不能审核！';
    Raise Err_Item;
  End If;

  Begin
    Select 1
    Into n_Count
    From 临床出诊安排 A, 临床出诊安排 B, 临床出诊表 C
    Where a.号源id = b.号源id And a.出诊id = c.Id And c.排班方式 = 0 And a.Id <> b.Id And b.Id = 安排id_In And a.登记时间 < b.登记时间 And
          a.审核时间 Is Null And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '该号源在当前安排之前还存在未审核的安排，你不能审核当前安排！';
    Raise Err_Item;
  End If;

  Begin
    Select 1
    Into n_Count
    From (Select Decode(To_Char(a.出诊日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                          Null) As 限制项目, a.上班时段
           From 临床出诊记录 A, 病人挂号记录 B
           Where a.Id = b.出诊记录id And a.上班时段 Is Not Null And a.号源id = n_号源id And a.出诊日期 Between d_开始时间 And d_终止时间 And
                 b.登记时间 > d_登记时间
           Minus
           Select Decode(To_Char(a.出诊日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                          Null) As 限制项目, a.上班时段
           From 临床出诊记录 A, 病人挂号记录 B
           Where a.Id = b.出诊记录id And a.上班时段 Is Not Null And a.号源id = n_号源id And a.出诊日期 Between d_开始时间 And d_终止时间 And
                 b.登记时间 <= d_登记时间)
    Where Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '在当前选择的有效时间范围内，当前号源自上次新增或修改到现在这段时间范围内有不在该安排中的上班时段产生了新的预约挂号记录(这些上班时段必须包含在新的安排中)，需要重新调整安排，你不能审核！';
    Raise Err_Item;
  End If;

  Update 临床出诊安排 Set 审核人 = 审核人_In, 审核时间 = 审核时间_In Where ID = 安排id_In And 审核时间 Is Null;
  If Sql%NotFound Then
    v_Err_Msg := '当前安排已被他人审核或删除，不能再审核！';
    Raise Err_Item;
  End If;

  --新增号源安排审核，同时将临时安排也一并审核了
  For c_安排 In (Select a.Id
               From 临床出诊安排 A, 临床出诊安排 B
               Where a.出诊id = b.出诊id And a.号源id = b.号源id And b.Id = 安排id_In And Nvl(b.是否临时安排, 0) = 0 And
                     Nvl(a.是否临时安排, 0) = 1 And a.审核时间 Is Null) Loop
    Update 临床出诊安排 Set 审核人 = 审核人_In, 审核时间 = 审核时间_In Where ID = c_安排.Id;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊临时安排_Verify;
/
Create Or Replace Procedure Zl_临床出诊临时安排_Cancel(安排id_In In 临床出诊安排.Id%Type) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(500);

  n_Count Number(2);
Begin
  Begin
    Select 1
    Into n_Count
    From 临床出诊记录 A, 病人挂号记录 B
    Where a.Id = b.出诊记录id And a.安排id = 安排id_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前安排已存在预约挂号数据，不能取消审核！';
    Raise Err_Item;
  End If;

  Begin
    Select 1
    Into n_Count
    From 临床出诊安排 A, 临床出诊安排 B, 临床出诊表 C
    Where a.号源id = b.号源id And a.出诊id = c.Id And c.排班方式 = 0 And a.Id <> b.Id And b.Id = 安排id_In And a.登记时间 > b.登记时间 And
          a.审核时间 Is Not Null And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '该号源在当前安排之后还存在已审核的安排，你不能取消审核当前安排！';
    Raise Err_Item;
  End If;

  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where ID = 安排id_In And 审核时间 Is Not Null;
  If Sql%NotFound Then
    v_Err_Msg := '当前安排已被他人取消审核或删除，不能再取消审核！';
    Raise Err_Item;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊临时安排_Cancel;
/
Create Or Replace Procedure Zl_临床出诊表_Add
(
  操作类型_In Number,
  出诊id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  站点_In     部门表.站点%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  开始时间_In 临床出诊安排.开始时间%Type := Null,
  终止时间_In 临床出诊安排.终止时间%Type := Null,
  年份_In     临床出诊表.年份%Type := Null,
  月份_In     临床出诊表.月份%Type := Null,
  周数_In     临床出诊表.周数%Type := Null,
  应用范围_In 临床出诊表.应用范围%Type := Null,
  科室id_In   临床出诊表.科室id%Type := Null,
  备注_In     临床出诊表.备注%Type := Null,
  人员id_In   人员表.Id%Type := Null,
  删除安排_In Number := 0,
  模板类型_In 临床出诊表.模板类型%Type := Null
) As
  --功能：增加出诊表或模板
  --参数：
  --        操作类型_In 1-模板，2-固定安排, 3-月安排，4-周安排
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_出诊id 临床出诊表.Id%Type;
  l_记录id t_Numlist := t_Numlist();

Begin
  n_出诊id := 出诊id_In;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板
  --============================================================================================================================================
  --1.模板
  If Nvl(操作类型_In, 0) = 1 Then
    Begin
      Select 1 Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) > 0 Then
      v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的模板！';
      Raise Err_Item;
    End If;
  
    --检查是否有可操作的有效号源
    Begin
      Select 1
      Into n_Count
      From 临床出诊号源 A, 部门表 D
      Where a.科室id = d.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
            (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
           --当前人员可操作的号源
            And (Nvl(人员id_In, 0) = 0 Or
            (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
           --站点
            And (d.站点 Is Null Or d.站点 = 站点_In) And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) = 0 Then
      If Nvl(模板类型_In, 0) = 0 Then
        v_Err_Msg := '当前无可按周排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Else
        v_Err_Msg := '当前无可按月排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      End If;
      Raise Err_Item;
    End If;
  
    --模板，肯定是新出诊表
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型)
    Values
      (n_出诊id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, 模板类型_In);
  
    --临床出诊安排
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D
                 Where a.科室id = d.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In)) Loop
    
      If Nvl(模板类型_In, 0) = 2 Then
        --2-按天排班的月排班模板，排班规则缺省为6-特定日期
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 6, 操作员_In, 操作时间_In);
      Else
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 1, 操作员_In, 操作时间_In);
      End If;
    End Loop;
    Return;
  End If;

  --============================================================================================================================================
  --2.固定排班
  If Nvl(操作类型_In, 0) = 2 Then
    Begin
      Select 1 Into n_Count From 临床出诊表 Where 出诊表名 = 出诊表名_In And 排班方式 = 0 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) > 0 Then
      v_Err_Msg := '当前已存在名为“' || 出诊表名_In || '”的固定出诊表！';
      Raise Err_Item;
    End If;
  
    --检查是否有有效号源
    Begin
      Select 1
      Into n_Count
      From 临床出诊号源 A, 部门表 D
      Where a.科室id = d.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
            (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
           --站点
            And (d.站点 Is Null Or d.站点 = 站点_In) And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) = 0 Then
      v_Err_Msg := '当前无可按固定排班的号源，不能新增固定安排，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Raise Err_Item;
    End If;
  
    --固定安排，肯定是新出诊表,只有有"所有科室"权限的人才能新增
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份)
    Values
      (n_出诊id, 0, 出诊表名_In, To_Number(To_Char(开始时间_In, 'yyyy')));
  
    --缺省加入上一次有效的出诊安排
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名
                 From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名,
                               Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                        From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D
                        Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id
                             --号源限制
                              And b.排班方式 = 0 And Nvl(b.是否删除, 0) = 0 And
                              (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                             --上一次出诊安排限制
                              And c.发布人 Is Not Null And c.排班方式 = 0 And (d.站点 Is Null Or d.站点 = 站点_In)) M
                 Where 组号 = 1) Loop
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
    
      --复制出诊安排
      For c_限制 In (Select ID From 临床出诊限制 Where 安排id = c_号源.原安排id) Loop
        Zl_临床出诊限制_Copy(c_限制.Id, c_号源.安排id);
      End Loop;
    End Loop;
  
    --加入无上一次有效出诊安排的号源
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D
                 Where a.科室id = d.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In)
                      
                       And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
    End Loop;
    Return;
  End If;

  --============================================================================================================================================
  --月排班、周排班
  --检查是否有有效号源
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id
         --有效号源
          And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          (
          --月排班
           Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
          --周排班
           Or Nvl(操作类型_In, 0) = 4 And
           (
           --当前出诊表所在时间范围内不能有月排班
            a.排班方式 = 2 And Not Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
           --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
            Or a.排班方式 = 1 And Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
         --号源在该出诊表时间范围内无出诊记录
          And Not Exists
     (Select 1
           From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
           Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
                 (q.排班方式 In (1, 2)
                 --原来为固定出诊安排
                 Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                  (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    If Nvl(操作类型_In, 0) = 3 Then
      v_Err_Msg := '当前无可按月排班的号源，不能新增月出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    Else
      v_Err_Msg := '当前无可按周排班的号源，不能新增周出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    End If;
    Raise Err_Item;
  End If;

  --出诊表存在，则不再新增出诊表，直接向该出诊表添加上次有效号源安排即可
  --涉及到临床排班，当前操作员可能只能操作某一部分号源
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = n_出诊id;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数)
    Values
      (n_出诊id,
       Case
          When Nvl(操作类型_In, 0) = 3 Then
           1
          Else
           2
        End, 出诊表名_In, 年份_In, 月份_In, 周数_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，程序中已询问

  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D
                 Where b.出诊id = c.Id And b.号源id = d.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --缺省加入上一次有效的出诊安排
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名
               From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名,
                             Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                      From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D
                      Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id
                           --有效号源
                            And Nvl(b.是否删除, 0) = 0 And
                            Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            (
                            --月排班
                             Nvl(操作类型_In, 0) = 3 And b.排班方式 = 1
                            --周排班
                             Or
                             Nvl(操作类型_In, 0) = 4 And
                             (
                             --当前出诊表所在时间范围内不能有月排班
                              b.排班方式 = 2 And Not Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                             --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                              Or b.排班方式 = 1 And Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                           --上一次有效出诊安排
                            And c.发布人 Is Not Null And c.排班方式 = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                           --号源在该出诊表时间范围内无出诊记录
                            And Not Exists (Select 1
                             From 临床出诊记录 P
                             Where p.号源id = b.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                           --当前人员可操作的号源
                            And (Nvl(人员id_In, 0) = 0 Or
                            (Nvl(b.是否临床排班, 0) = 1 And Exists
                             (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)))
                           --站点
                            And (d.站点 Is Null Or d.站点 = 站点_In))
               Where 组号 = 1) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  
    --复制出诊安排
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班
                       And (Nvl(操作类型_In, 0) = 3 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班
                       Or Nvl(操作类型_In, 0) = 4 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_号源.安排id, c_记录.日期, 操作员_In, 操作时间_In);
    End Loop;
  End Loop;

  --加入无上一次有效出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     (
                     --月排班
                      Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
                     --周排班
                      Or Nvl(操作类型_In, 0) = 4 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Add;
/
Create Or Replace Procedure Zl_临床出诊限制_Copy
(
  原限制id_In 临床出诊限制.Id%Type,
  安排id_In   临床出诊限制.安排id%Type
) As
  --复制临床出诊限制
  n_限制id 临床出诊限制.Id%Type;
Begin
  Select 临床出诊限制_Id.Nextval Into n_限制id From Dual;

  Insert Into 临床出诊限制
    (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id, 是否独占)
    Select n_限制id, 安排id_In, a.限制项目, a.上班时段, a.限号数, a.限约数, a.是否序号控制, a.是否分时段, a.预约控制, a.分诊方式, a.诊室id, a.是否独占
    From 临床出诊限制 A
    Where a.Id = 原限制id_In;

  Insert Into 临床出诊诊室
    (限制id, 诊室id)
    Select n_限制id, 诊室id From 临床出诊诊室 Where 限制id = 原限制id_In;

  Insert Into 临床出诊时段
    (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
    Select n_限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约 From 临床出诊时段 Where 限制id = 原限制id_In;

  Insert Into 临床出诊挂号控制
    (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
    Select n_限制id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制 Where 限制id = 原限制id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊限制_Copy;
/
Create Or Replace Procedure Zl_临床出诊记录_Copy
(
  原记录id_In   临床出诊记录.Id%Type,
  安排id_In     临床出诊限制.安排id%Type,
  出诊日期_In   临床出诊记录.出诊日期%Type,
  操作员姓名_In 临床出诊记录.登记人%Type,
  登记时间_In   临床出诊记录.登记时间%Type,
  是否发布_In   临床出诊记录.是否发布%Type := 0,
  相关id_In     临床出诊记录.相关id%Type := Null
) As
  --复制临床出诊记录
  n_记录id 临床出诊记录.Id%Type;

  d_开始时间     临床出诊记录.开始时间%Type;
  n_是否分时段   临床出诊记录.是否分时段%Type;
  n_是否序号控制 临床出诊记录.是否序号控制%Type;
Begin
  Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
  Begin
    Select a.开始时间, a.是否分时段, a.是否序号控制
    Into d_开始时间, n_是否分时段, n_是否序号控制
    From 临床出诊记录 A
    Where a.Id = 原记录id_In;
  Exception
    When Others Then
      Return;
  End;

  Insert Into 临床出诊记录
    (ID, 相关id, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 停诊开始时间, 停诊终止时间, 停诊原因, 缺省预约时间, 提前挂号时间, 限号数, 已挂数, 限约数, 已约数, 其中已接收,
     是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 分诊方式, 诊室id, 是否锁定, 是否临时出诊, 登记人, 登记时间, 是否发布)
    Select n_记录id, 相关id_In, 安排id_In, a.号源id, 出诊日期_In, a.上班时段,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(终止时间) > Trunc(d_开始时间) Then
              1
             Else
              0
           End, Null As 停诊开始时间, Null As 停诊终止时间, Null As 停诊原因,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.缺省预约时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(缺省预约时间) > Trunc(d_开始时间) Then
              1
             Else
              0
           End,
           To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(a.提前挂号时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
             When Trunc(提前挂号时间) < Trunc(d_开始时间) Then
              -1
             Else
              0
           End, a.限号数, 0 As 已挂数, a.限约数, 0 As 已约数, 0 As 其中已接收, a.是否序号控制, a.是否分时段, a.预约控制, a.是否独占, a.项目id, a.科室id, a.医生id,
           a.医生姓名, Null As 替诊医生id, Null As 替诊医生姓名, a.分诊方式, a.诊室id, 0 As 是否锁定, 0 As 是否临时出诊, 操作员姓名_In, 登记时间_In, 是否发布_In
    From 临床出诊记录 A
    Where a.Id = 原记录id_In;

  Insert Into 临床出诊诊室记录
    (记录id, 诊室id)
    Select n_记录id, 诊室id From 临床出诊诊室记录 Where 记录id = 原记录id_In;

  --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号
  If Nvl(n_是否分时段, 0) = 1 And Nvl(n_是否序号控制, 0) = 1 Then
    --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
    Insert Into 临床出诊序号控制
      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
      Select n_记录id, 序号,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                When Trunc(开始时间) > Trunc(d_开始时间) Then
                 1
                Else
                 0
              End,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                When Trunc(终止时间) > Trunc(d_开始时间) Then
                 1
                Else
                 0
              End, 数量, 是否预约, 是否预约
      From 临床出诊序号控制
      Where 记录id = 原记录id_In And (开始时间 <> 终止时间 Or 开始时间 Is Null And 终止时间 Is Null);
    --排除加号权限加的（开始时间=终止时间）
  Else
    Insert Into 临床出诊序号控制
      (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
      Select n_记录id, 序号,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
               When Trunc(开始时间) > Trunc(d_开始时间) Then
                1
               Else
                0
             End,
             To_Date(To_Char(出诊日期_In, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
               When Trunc(终止时间) > Trunc(d_开始时间) Then
                1
               Else
                0
             End, 数量, 是否预约
      From 临床出诊序号控制
      Where 预约顺序号 Is Null And 记录id = 原记录id_In;
  End If;

  Insert Into 临床出诊挂号控制记录
    (记录id, 类型, 性质, 名称, 序号, 控制方式, 数量)
    Select n_记录id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制记录 Where 记录id = 原记录id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Copy;
/
Create Or Replace Procedure Zl_临床出诊记录_Batchdelete(记录id_In t_Numlist) As
  --删除临床出诊记录
Begin
  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊变动明细 Where 变动id In (Select ID From 临床出诊变动记录 Where 记录id = 记录id_In(I));

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊变动记录 Where 记录id = 记录id_In(I);

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊停诊记录 Where 记录id = 记录id_In(I);

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊序号控制 Where 记录id = 记录id_In(I);

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊诊室记录 Where 记录id = 记录id_In(I);

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊挂号控制记录 Where 记录id = 记录id_In(I);

  Forall I In 1 .. 记录id_In.Count
    Delete From 临床出诊记录 Where ID = 记录id_In(I);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Batchdelete;
/
Create Or Replace Procedure Zl_Buildregisterfixedrule
(
  Id_In         临床出诊表.Id%Type,
  Newid_In      临床出诊表.Id%Type,
  出诊表名_In   临床出诊表.出诊表名%Type,
  开始时间_In   临床出诊安排.开始时间%Type,
  终止时间_In   临床出诊安排.终止时间%Type,
  操作员姓名_In 临床出诊安排.操作员姓名%Type := Null,
  登记时间_In   临床出诊安排.登记时间%Type := Null,
  站点_In       部门表.站点%Type
) As
  -------------------------------------------------------------------------
  --功能：根据现有固定出诊表规则生成成新的固定出诊表
  -------------------------------------------------------------------------
  n_Count Number;

  n_出诊id 临床出诊表.Id%Type;

  v_操作员   临床出诊安排.操作员姓名%Type;
  d_登记时间 Date;
  v_Err_Msg  Varchar2(255);
  Err_Item Exception;
Begin
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    v_Err_Msg := '未发现原出诊表信息！';
    Raise Err_Item;
  End If;

  --检查是否有有效号源
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
          (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前出诊表中已无可按固定排班的号源，不能生成新的固定安排！';
    Raise Err_Item;
  End If;

  n_出诊id := Newid_In;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
  End If;

  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 年份)
  Values
    (n_出诊id, 0, 出诊表名_In, To_Number(To_Char(开始时间_In, 'yyyy')));

  d_登记时间 := Nvl(登记时间_In, Sysdate);
  v_操作员   := Nvl(操作员姓名_In, Zl_Username);

  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名
               From (Select b.Id As 原安排id, b.号源id, c.项目id, c.医生id, c.医生姓名,
                             Row_Number() Over(Partition By c.Id Order By b.开始时间 Desc) As 组号
                      From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
                      Where b.号源id = c.Id And c.科室id = d.Id And b.出诊id = Id_In
                           --号源限制
                            And c.排班方式 = 0 And Nvl(c.是否删除, 0) = 0 And
                            (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null)
                           --站点
                            And (d.站点 Is Null Or d.站点 = 站点_In)) M
               Where 组号 = 1) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, v_操作员, d_登记时间);
  
    --出诊限制
    For c_限制 In (Select ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id, 是否独占
                 From 临床出诊限制
                 Where 安排id = c_号源.原安排id) Loop
    
      Zl_临床出诊限制_Copy(c_限制.Id, c_号源.安排id);
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id And a.排班方式 = 0 And Nvl(a.是否删除, 0) = 0 And
                     (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd'))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, v_操作员, d_登记时间);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Buildregisterfixedrule;
/
Create Or Replace Procedure Zl_Buildregisterplanbyrecord
(
  原出诊id_In   临床出诊表.Id%Type,
  新出诊id_In   临床出诊表.Id%Type,
  排班方式_In   临床出诊表.排班方式%Type,
  出诊表名_In   临床出诊表.出诊表名%Type,
  年份_In       临床出诊表.年份%Type,
  月份_In       临床出诊表.月份%Type,
  周数_In       临床出诊表.周数%Type,
  开始时间_In   临床出诊安排.开始时间%Type,
  终止时间_In   临床出诊安排.终止时间%Type,
  操作员姓名_In 临床出诊安排.操作员姓名%Type,
  登记时间_In   临床出诊安排.登记时间%Type,
  站点_In       部门表.站点%Type,
  人员id_In     人员表.Id%Type := Null,
  删除安排_In   Number := 0
) As
  -------------------------------------------------------------------------
  --功能：根据出诊记录生成新的出诊记录（月安排/周安排）
  --参数：
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  -------------------------------------------------------------------------
  n_Count Number;

  l_记录id t_Numlist := t_Numlist();

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id
         --有效号源
          And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          (
          --月排班
           Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
          --周排班
           Or Nvl(排班方式_In, 0) = 2 And
           (
           --当前出诊表所在时间范围内不能有月排班
            a.排班方式 = 2 And Not Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
           --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
            Or a.排班方式 = 1 And Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
         --号源在该出诊表时间范围内无出诊记录
          And Not Exists
     (Select 1
           From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
           Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
                 (q.排班方式 In (1, 2)
                 --原来为固定出诊安排
                 Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                  (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = 新出诊id_In;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数)
    Values
      (新出诊id_In, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，
  --并修改固定安排的终止时间，程序中已询问
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D
                 Where b.出诊id = c.Id And b.号源id = d.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 新出诊id_In As 出诊id, b.Id As 原安排id, b.号源id, c.项目id, c.医生id, c.医生姓名
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
               Where b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 原出诊id_In
                    --有效号源
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
  
    --出诊记录
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班
                       And (Nvl(排班方式_In, 0) = 1 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班
                       Or Nvl(排班方式_In, 0) = 2 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_号源.安排id, c_记录.日期, 操作员姓名_In, 登记时间_In);
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 新出诊id_In As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = 新出诊id_In And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Buildregisterplanbyrecord;
/
Create Or Replace Procedure Zl_Buildregisterplanbytemplet
(
  模板id_In   临床出诊表.Id%Type,
  人员id_In   人员表.Id%Type,
  出诊id_In   临床出诊表.Id%Type,
  排班方式_In 临床出诊表.排班方式%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  年份_In     临床出诊表.年份%Type,
  月份_In     临床出诊表.月份%Type,
  周数_In     临床出诊表.周数%Type,
  开始时间_In 临床出诊安排.开始时间%Type,
  终止时间_In 临床出诊安排.终止时间%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  登记时间_In 临床出诊安排.登记时间%Type,
  站点_In     部门表.站点%Type,
  删除安排_In Number := 0
) As
  -------------------------------------------------------------------------
  --功能说明：根据模板自动生成临床出诊记录
  --参数：
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录
  --说明：
  -------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  n_Count   Number(18);

  d_轮询日期 Date;
  n_轮询天数 Number;
  v_限制项目 临床出诊限制.限制项目%Type;

  n_是否出诊 Number(2);

  l_记录id t_Numlist := t_Numlist();

  Procedure Isvisit
  (
    安排id_In       临床出诊安排.Id%Type,
    排班规则_In     临床出诊安排.排班规则%Type,
    出诊日期_In     临床出诊记录.出诊日期%Type,
    轮询开始时间_In 临床出诊安排.开始时间%Type,
    限制项目_In     Out 临床出诊限制.限制项目%Type,
    是否出诊_In     Out Number
  ) As
    --判断是否出诊，并获取出诊项目
    d_轮询日期 Date;
    n_轮询天数 Number;
  Begin
    是否出诊_In := 1;
    --检查这天是否出诊
    If 排班规则_In = 1 Then
      --星期排班
      Select Decode(To_Char(出诊日期_In, 'D'),
                     '1',
                     '周日',
                     '2',
                     '周一',
                     '3',
                     '周二',
                     '4',
                     '周三',
                     '5',
                     '周四',
                     '6',
                     '周五',
                     '7',
                     '周六',
                     Null)
      Into 限制项目_In
      From Dual;
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 2 Then
      --单日排班
      限制项目_In := '单日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 1 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 3 Then
      --双日排班
      限制项目_In := '双日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 4 Or 排班规则_In = 5 Then
      --4-月内轮循,5-轮循不限制
      If 排班规则_In = 4 Then
        d_轮询日期 := To_Date(To_Char(出诊日期_In, 'yyyy-mm') || To_Char(轮询开始时间_In, '-dd'), 'yyyy-mm-dd');
      Else
        d_轮询日期 := 轮询开始时间_In;
      End If;
      Begin
        Select To_Number(Substr(限制项目, 1, Instr(限制项目, '天') - 1))
        Into n_轮询天数
        From 临床出诊限制
        Where 安排id = 安排id_In And Rownum < 2;
      Exception
        When Others Then
          n_轮询天数 := 0;
      End;
      If Nvl(n_轮询天数, 0) > 0 Then
        限制项目_In := n_轮询天数 || '天';
        If Mod(Trunc(出诊日期_In) - Trunc(d_轮询日期), n_轮询天数 + 1) <> 0 Then
          是否出诊_In := 0;
        End If;
      End If;
    Elsif 排班规则_In = 6 Then
      --特定日期
      限制项目_In := To_Number(To_Char(出诊日期_In, 'dd')) || '日';
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    End If;
  End;
Begin
  Begin
    Select 1
    Into n_Count
    From 临床出诊号源 A, 部门表 B
    Where a.科室id = b.Id
         --有效号源
          And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          (
          --月排班
           Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
          --周排班
           Or Nvl(排班方式_In, 0) = 2 And
           (
           --当前出诊表所在时间范围内不能有月排班
            a.排班方式 = 2 And Not Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
           --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
            Or a.排班方式 = 1 And Exists
            (Select 1
                From 临床出诊安排 P, 临床出诊表 Q
                Where p.出诊id = q.Id And p.号源id = a.Id And
                      Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
         --号源在该出诊表时间范围内无出诊记录
          And Not Exists
     (Select 1
           From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
           Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
                 (q.排班方式 In (1, 2)
                 --原来为固定出诊安排
                 Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                  (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
         --当前人员可操作的号源
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点
          And (b.站点 Is Null Or b.站点 = 站点_In) And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在
  Begin
    Select 1 Into n_Count From 临床出诊表 Where ID = 出诊id_In;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If Nvl(n_Count, 0) = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数)
    Values
      (出诊id_In, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In);
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，
  --并修改固定安排的终止时间，程序中已询问
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D
                 Where b.出诊id = c.Id And b.号源id = d.Id
                      --号源
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  End If;

  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 出诊id_In As 出诊id, b.Id As 原安排id, b.号源id, c.科室id, c.项目id, c.医生id, c.医生姓名,
                      b.排班规则, b.是否周六出诊, b.是否周日出诊, b.开始时间, c.号类, Nvl(d.站点, '-') As 站点
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
               Where b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 模板id_In
                    --有效号源
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  
    --临床出诊记录
    For c_日期 In (Select Trunc(开始时间_In) + Level - 1 As 日期,
                        Decode(To_Char(Trunc(开始时间_In) + Level - 1, 'D'),
                                '1',
                                '周日',
                                '2',
                                '周一',
                                '3',
                                '周二',
                                '4',
                                '周三',
                                '5',
                                '周四',
                                '6',
                                '周五',
                                '7',
                                '周六',
                                Null) As 星期
                 From Dual
                 Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) Loop
    
      Isvisit(c_号源.原安排id, c_号源.排班规则, c_日期.日期, c_号源.开始时间, v_限制项目, n_是否出诊);
    
      --是否周六、周日不出诊
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期
      If Instr(',2,3,4,5,', c_号源.排班规则) > 0 And
         (Nvl(c_号源.是否周六出诊, 0) = 0 And c_日期.星期 = '周六' Or Nvl(c_号源.是否周日出诊, 0) = 0 And c_日期.星期 = '周日') Then
        n_是否出诊 := 0;
      End If;
    
      If Nvl(n_是否出诊, 0) = 1 Then
        For c_记录 In (With c_时间段 As
                        (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                        From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                      Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                               From 时间段
                               Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                        Where 组号 = 1)
                       Select 临床出诊记录_Id.Nextval As 记录id, m.Id As 限制id, m.上班时段,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.终止时间 <= j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 终止时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') ||
                                       To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.缺省时间 < j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 缺省预约时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') ||
                                       To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.开始时间 < j.提前时间 Then
                                  -1
                                 Else
                                  0
                               End As 提前挂号时间, m.限号数, m.限约数, m.是否序号控制, m.是否分时段, m.预约控制, a.项目id, a.医生id, a.医生姓名, m.分诊方式,
                              m.诊室id, m.是否独占
                       From 临床出诊安排 A, 临床出诊限制 M, c_时间段 J
                       Where a.Id = m.安排id And m.上班时段 = j.时间段 And a.Id = c_号源.原安排id And m.限制项目 = v_限制项目) Loop
        
          Insert Into 临床出诊记录
            (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 项目id, 科室id, 医生id,
             医生姓名, 分诊方式, 诊室id, 登记人, 登记时间, 是否独占)
          Values
            (c_记录.记录id, c_号源.安排id, c_号源.号源id, c_日期.日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.缺省预约时间, c_记录.提前挂号时间,
             c_记录.限号数, c_记录.限约数, c_记录.是否序号控制, c_记录.是否分时段, c_记录.预约控制, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名,
             c_记录.分诊方式, c_记录.诊室id, 操作员_In, 登记时间_In, c_记录.是否独占);
        
          --插入临床出诊序号控制
          If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
            --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                              'yyyy-mm-dd hh24:mi:ss'),
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                              'yyyy-mm-dd hh24:mi:ss') + Case
                        When 终止时间 <= 开始时间 Then
                         1
                        Else
                         0
                      End, 限制数量, 是否预约, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          Else
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'),
                              'yyyy-mm-dd hh24:mi:ss'),
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'),
                             'yyyy-mm-dd hh24:mi:ss') + Case
                       When 终止时间 <= 开始时间 Then
                        1
                       Else
                        0
                     End, 限制数量, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          End If;
        
          --插入合作单位挂号控制记录
          Insert Into 临床出诊挂号控制记录
            (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
            Select 类型, 性质, 名称, c_记录.记录id, 序号, 控制方式, 数量
            From 临床出诊挂号控制
            Where 限制id = c_记录.限制id;
        
          --插入临床出诊诊室记录
          Insert Into 临床出诊诊室记录
            (记录id, 诊室id)
            Select c_记录.记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
        End Loop;
      End If;
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, 出诊id_In As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D
               Where a.科室id = d.Id
                    --有效号源
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     (
                     --月排班
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点
                     And (d.站点 Is Null Or d.站点 = 站点_In)
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = 出诊id_In And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Buildregisterplanbytemplet;
/

Create Or Replace Procedure Zl_临床出诊表_Delete
(
  Id_In     临床出诊表.Id%Type,
  人员id_In 人员表.Id%Type := Null,
  站点_In   部门表.站点%Type
) As
  --功能：删除临床出诊表
  --参数：
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在删除
  n_Count    Number;
  n_排班方式 临床出诊表.排班方式%Type;
  n_出诊id   临床出诊表.Id%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  l_记录id t_Numlist := t_Numlist();
  l_限制id t_Numlist := t_Numlist();
Begin
  Begin
    Select 1 Into n_Count From 临床出诊表 Where 排班方式 <> 3 And 发布人 Is Not Null And ID = Id_In;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不能删除！';
    Raise Err_Item;
  End If;

  Begin
    Select 排班方式 Into n_排班方式 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  --按天排班的月模板数据保存在出诊记录中的
  If Nvl(n_排班方式, 0) In (0, 3) Then
    --固定安排/模板
    --删除临床出诊限制
    Select b.Id Bulk Collect
    Into l_限制id
    From 临床出诊安排 A, 临床出诊限制 B
    Where a.Id = b.安排id And a.出诊id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊限制 Where ID = l_限制id(I);
  
    --删除临床出诊安排
    Delete From 临床出诊安排 Where 出诊id = Id_In;
  
    --删除临床出诊表
    Delete 临床出诊表 Where ID = Id_In;
  
    Return;
  End If;

  --========================================================================================================
  --月出诊表/周出诊表
  --月出诊表/周出诊表只能从最后一个开始删除
  Begin
    Select ID
    Into n_出诊id
    From (Select a.Id
           From 临床出诊表 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
           Where a.排班方式 = n_排班方式 And a.Id = b.出诊id(+) And b.号源id = c.Id(+) And c.科室id = d.Id(+)
                --当前人员可操作的号源
                 And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                  (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                --站点
                 And (d.站点 Is Null Or d.站点 = 站点_In)
           Order By a.年份 Desc, a.月份 Desc, a.周数 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      n_出诊id := 0;
  End;
  If Nvl(n_出诊id, 0) <> 0 And Nvl(n_出诊id, 0) <> Id_In Then
    v_Err_Msg := '必须从最后一个出诊表开始删除！';
    Raise Err_Item;
  End If;

  --删除临床出诊记录
  Select a.Id Bulk Collect
  Into l_记录id
  From 临床出诊记录 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
  Where a.安排id = b.Id And a.号源id = c.Id And c.科室id = d.Id And b.出诊id = Id_In
       --当前人员可操作的号源
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(c.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where c.科室id = 部门id And 人员id = 人员id_In)))
       --站点
        And (d.站点 Is Null Or d.站点 = 站点_In);

  Zl_临床出诊记录_Batchdelete(l_记录id);

  --删除临床出诊安排
  Delete From 临床出诊安排 A
  Where a.出诊id = Id_In And Exists
   (Select 1
         From 临床出诊号源 B, 部门表 D
         Where a.号源id = b.Id And b.科室id = d.Id
              --当前人员可操作的号源
               And (Nvl(人员id_In, 0) = 0 Or (Nvl(b.是否临床排班, 0) = 1 And Exists
                (Select 1 From 部门人员 Where b.科室id = 部门id And 人员id = 人员id_In)))
              --站点
               And (d.站点 Is Null Or d.站点 = 站点_In));

  --删除临床出诊表
  Delete 临床出诊表 A
  Where a.Id = Id_In And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = a.Id And 号源id Is Not Null);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Delete;
/

Create Or Replace Procedure Zl_临床出诊安排_Applyto
(
  应用类型_In     Number,
  原id_In         临床出诊安排.Id%Type,
  原项目_In       Varchar2,
  新id_In         临床出诊安排.Id%Type,
  新项目_In       Varchar2,
  是否临时出诊_In Number := 0
) As
  -------------------------------------------------------------------------
  --功能：将某个日期的安排应用于其他日期
  --参数：
  --     原Id_In 被应用的安排ID
  --     原项目_in 被应用的项目
  --           1.模板或固定出诊表，限制项目，如"周三"
  --           2.出诊记录，出诊日期，如"2016-01-02"
  --     新id_In 应用于的安排ID
  --     新项目_In 应用于的项目（多个用"|"分隔）
  --           1.模板或固定出诊表，限制项目：项目1|项目2|...，如"周三|周五"
  --           2.出诊记录，出诊日期：日期1|日期2|...，如"2016-01-02|2016-01-05"
  --     应用类型_In 0-模板或固定出诊表,1-出诊记录
  --说明：
  -------------------------------------------------------------------------
  n_Count    Number;
  n_限制id   临床出诊限制.Id%Type;
  n_记录id   临床出诊记录.Id%Type;
  d_出诊日期 临床出诊记录.出诊日期%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  --检查被应用的安排是否有效
  If Nvl(应用类型_In, 0) = 0 Then
    Select Count(1)
    Into n_Count
    From 临床出诊安排 A, 临床出诊限制 B
    Where a.Id = b.安排id And a.Id = 原id_In And b.限制项目 = 原项目_In;
  Else
    Select Count(1)
    Into n_Count
    From 临床出诊安排 A, 临床出诊记录 B
    Where a.Id = b.安排id And a.Id = 原id_In And b.出诊日期 = To_Date(原项目_In, 'yyyy-mm-dd');
  End If;
  If n_Count = 0 Then
    v_Err_Msg := '被应用的安排未设置有效的上班时段，不能应用于其它安排！';
    Raise Err_Item;
  End If;

  Select Count(1) Into n_Count From 临床出诊安排 Where ID = 新id_In;
  If n_Count = 0 Then
    v_Err_Msg := '未发现你将要应用于的临床出诊安排记录！';
    Raise Err_Item;
  End If;
  If 新项目_In Is Null Then
    v_Err_Msg := '无应用于的项目！';
    Raise Err_Item;
  End If;

  If Nvl(应用类型_In, 0) = 0 Then
    --模板或固定出诊表
    For c_限制项目 In (Select Column_Value As 项目 From Table(f_Str2list(新项目_In, '|'))) Loop
      --先删除已有时段
      Zl_临床出诊上班时段_Delete(新id_In, c_限制项目.项目, 0);
    
      For c_时段 In (Select ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id, 是否独占
                   From 临床出诊限制
                   Where 安排id = 原id_In And 限制项目 = 原项目_In) Loop
      
        Select 临床出诊限制_Id.Nextval Into n_限制id From Dual;
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id, 是否独占)
        Values
          (n_限制id, 新id_In, c_限制项目.项目, c_时段.上班时段, c_时段.限号数, c_时段.限约数, c_时段.是否序号控制, c_时段.是否分时段, c_时段.预约控制, c_时段.分诊方式,
           c_时段.诊室id, c_时段.是否独占);
      
        Insert Into 临床出诊诊室
          (限制id, 诊室id)
          Select n_限制id, 诊室id From 临床出诊诊室 Where 限制id = c_时段.Id;
      
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select n_限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约 From 临床出诊时段 Where 限制id = c_时段.Id;
      
        Insert Into 临床出诊挂号控制
          (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
          Select n_限制id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制 Where 限制id = c_时段.Id;
      End Loop;
    End Loop;
  Else
    --出诊记录
    For c_出诊日期 In (Select Column_Value As 日期 From Table(f_Str2list(新项目_In, '|'))) Loop
      d_出诊日期 := To_Date(c_出诊日期.日期, 'yyyy-mm-dd');
      --不能对历史的安排进行出诊安排操作
      --If Trunc(Sysdate + 1) > d_出诊日期 Then
      --  v_Err_Msg := '不能对当前日期及以前的日期进行出诊安排！';
      --  Raise Err_Item;
      --End If;
    
      --检查当前日期是否已由其它出诊表生成
      --一个号源某一天的安排只能由一个出诊表设置
      Begin
        Select 1
        Into n_Count
        From 临床出诊记录 A, 临床出诊安排 B, 临床出诊安排 C
        Where a.安排id = b.Id And a.号源id = c.号源id And a.出诊日期 = d_出诊日期 And c.Id = 新id_In And b.Id <> 新id_In And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If Nvl(n_Count, 0) = 1 Then
        v_Err_Msg := '日期(' || To_Char(d_出诊日期, 'yyyy-mm-dd') || ')已在其它出诊表中进行了安排，不能重复安排！';
        Raise Err_Item;
      End If;
    
      --先删除已有时段
      Zl_临床出诊上班时段_Delete(新id_In, To_Char(d_出诊日期, 'yyyy-mm-dd'), 1);
    
      For c_时段 In (Select ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占,
                          项目id, 科室id, 医生id, 医生姓名, 分诊方式, 诊室id
                   From 临床出诊记录
                   Where 安排id = 原id_In And 出诊日期 = To_Date(原项目_In, 'yyyy-mm-dd')) Loop
      
        Select 临床出诊记录_Id.Nextval Into n_记录id From Dual;
        Insert Into 临床出诊记录
          (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id,
           医生id, 医生姓名, 分诊方式, 诊室id, 是否临时出诊, 登记人, 登记时间)
          Select n_记录id, a.Id, a.号源id, d_出诊日期, c_时段.上班时段,
                 To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(c_时段.开始时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss'),
                 To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(c_时段.终止时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss'),
                 To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(c_时段.缺省预约时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss'),
                 To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(c_时段.提前挂号时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss'), c_时段.限号数, c_时段.限约数, c_时段.是否序号控制, c_时段.是否分时段, c_时段.预约控制, c_时段.是否独占,
                 a.项目id, b.科室id, a.医生id, a.医生姓名, c_时段.分诊方式, c_时段.诊室id, Nvl(是否临时出诊_In, 0), Zl_Username, Sysdate
          From 临床出诊安排 A, 临床出诊号源 B
          Where a.Id = 新id_In And a.号源id = b.Id;
      
        Insert Into 临床出诊诊室记录
          (记录id, 诊室id)
          Select n_记录id, 诊室id From 临床出诊诊室记录 Where 记录id = c_时段.Id;
      
        If Nvl(c_时段.是否分时段, 0) = 1 And Nvl(c_时段.是否序号控制, 0) = 1 Then
          --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
          Insert Into 临床出诊序号控制
            (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
            Select n_记录id, 序号,
                   To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   数量, 是否预约, 是否预约
            From 临床出诊序号控制
            Where 记录id = c_时段.Id;
        Else
          Insert Into 临床出诊序号控制
            (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
            Select n_记录id, 序号,
                   To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   To_Date(To_Char(d_出诊日期, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                   数量, 是否预约
            From 临床出诊序号控制
            Where 预约顺序号 Is Null And 记录id = c_时段.Id;
        End If;
        Insert Into 临床出诊挂号控制记录
          (记录id, 类型, 性质, 名称, 序号, 控制方式, 数量)
          Select n_记录id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制记录 Where 记录id = c_时段.Id;
      
      End Loop;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Applyto;
/

Create Or Replace Procedure Zl_临床出诊安排_Batchdelete
(
  出诊id_In   临床出诊表.Id%Type,
  人员id_In   人员表.Id%Type := 0,
  站点_In     部门表.站点%Type := Null,
  号源id_In   临床出诊安排.号源id%Type := 0,
  安排id_In   临床出诊安排.Id%Type := 0,
  临时安排_In 临床出诊安排.是否临时安排%Type := 0
) As
  --功能：批量删除临床出诊安排
  --参数：
  --      人员id_In 不等于0则删除人员所在科室的所有号源安排
  --      号源id_In 不等于0则删除该号源的所有安排
  --      安排ID_in 不等于0则删除该号源的当前安排(一般是临时安排)
  --说明：如果人员id_In=0且号源id_In=0 则删除该出诊表的所有号源的所有安排
  n_Count    Number(8);
  n_出诊记录 Number(1);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_限制id t_Numlist := t_Numlist();
  l_记录id t_Numlist := t_Numlist();
Begin
  If Nvl(临时安排_In, 0) = 0 Then
    Begin
      Select 1
      Into n_Count
      From 临床出诊表 A
      Where a.Id = 出诊id_In And a.发布人 Is Not Null And a.排班方式 <> 3 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count <> 0 Then
      v_Err_Msg := '当前出诊表已发布，不允许修改安排！';
      Raise Err_Item;
    End If;
  End If;

  Begin
    Select 1 Into n_出诊记录 From 临床出诊表 A Where a.Id = 出诊id_In And a.排班方式 In (1, 2) And Rownum < 2;
  Exception
    When Others Then
      n_出诊记录 := 0;
  End;

  If Nvl(n_出诊记录, 0) = 0 Then
    --删除临床出诊规则/模板
    Select a.Id Bulk Collect
    Into l_限制id
    From 临床出诊限制 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
    Where a.安排id = b.Id And b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 出诊id_In And
          (
          --删除该出诊表的所有号源的所有安排
           (Nvl(号源id_In, 0) = 0 And Nvl(人员id_In, 0) = 0)
          --删除该号源的所有安排
           Or (Nvl(号源id_In, 0) <> 0 And b.号源id = 号源id_In And Nvl(安排id_In, 0) = 0)
          --删除该号源的选择安排
           Or (Nvl(安排id_In, 0) <> 0 And b.Id = 安排id_In)
          --删除人员所在科室的所有号源安排
           Or (Nvl(人员id_In, 0) <> 0 And Exists (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
         --站点
          And (d.站点 Is Null Or d.站点 = 站点_In);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊限制 Where ID = l_限制id(I);
  
    --删除临床出诊安排
    For c_安排 In (Select b.Id
                 From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
                 Where b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 出诊id_In And
                       (
                       --删除该出诊表的所有号源的所有安排
                        (Nvl(号源id_In, 0) = 0 And Nvl(人员id_In, 0) = 0)
                       --删除该号源的所有安排
                        Or (Nvl(号源id_In, 0) <> 0 And b.号源id = 号源id_In And Nvl(安排id_In, 0) = 0)
                       --删除该号源的选择安排
                        Or (Nvl(安排id_In, 0) <> 0 And b.Id = 安排id_In)
                       --删除人员所在科室的所有号源安排
                        Or (Nvl(人员id_In, 0) <> 0 And Exists
                         (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In) And Not Exists
                  (Select 1 From 临床出诊限制 Where 安排id = b.Id)) Loop
      Zl_临床出诊安排_Delete(c_安排.Id);
    End Loop;
  Else
    --删除临床出诊记录
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
    Where a.安排id = b.Id And b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 出诊id_In And
          (
          --删除该出诊表的所有号源的所有安排
           (Nvl(号源id_In, 0) = 0 And Nvl(人员id_In, 0) = 0)
          --删除该号源的所有安排
           Or (Nvl(号源id_In, 0) <> 0 And b.号源id = 号源id_In And Nvl(安排id_In, 0) = 0)
          --删除该号源的选择安排
           Or (Nvl(安排id_In, 0) <> 0 And b.Id = 安排id_In)
          --删除人员所在科室的所有号源安排
           Or (Nvl(人员id_In, 0) <> 0 And Exists (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
         --站点
          And (d.站点 Is Null Or d.站点 = 站点_In);
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
    --删除临床出诊安排
    For c_安排 In (Select b.Id
                 From 临床出诊安排 B, 临床出诊号源 C, 部门表 D
                 Where b.号源id = c.Id And c.科室id = d.Id And b.出诊id = 出诊id_In And
                       (
                       --删除该出诊表的所有号源的所有安排
                        (Nvl(号源id_In, 0) = 0 And Nvl(人员id_In, 0) = 0)
                       --删除该号源的所有安排
                        Or (Nvl(号源id_In, 0) <> 0 And b.号源id = 号源id_In And Nvl(安排id_In, 0) = 0)
                       --删除该号源的选择安排
                        Or (Nvl(安排id_In, 0) <> 0 And b.Id = 安排id_In)
                       --删除人员所在科室的所有号源安排
                        Or (Nvl(人员id_In, 0) <> 0 And Exists
                         (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                      --站点
                       And (d.站点 Is Null Or d.站点 = 站点_In) And Not Exists
                  (Select 1 From 临床出诊记录 Where 安排id = b.Id)) Loop
      Zl_临床出诊安排_Delete(c_安排.Id);
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Batchdelete;
/

Create Or Replace Procedure Zl_临床出诊安排_Publish
(
  Id_In       临床出诊表.Id%Type,
  发布人_In   临床出诊表.发布人%Type := Null,
  发布时间_In 临床出诊表.发布时间%Type := Null,
  取消发布_In Number := 0
) As
  --发布和取消发布安排
  --参数：
  --        取消发布_In 是否取消发布
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(2);
  n_排班方式 临床出诊表.排班方式%Type;
  l_记录id   t_Numlist := t_Numlist();

  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;
Begin
  Begin
    Select Nvl(排班方式, 0) Into n_排班方式 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(取消发布_In, 0) = 0 Then
    --发布安排
    If Nvl(n_排班方式, 0) = 0 Then
      Begin
        Select 1
        Into n_Count
        From 临床出诊安排 A, 临床出诊限制 B, 临床出诊表 C
        Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 = 0 And c.Id = Id_In And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    Else
      Begin
        Select 1
        Into n_Count
        From 临床出诊安排 A, 临床出诊记录 B, 临床出诊表 C
        Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 In (1, 2) And c.Id = Id_In And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    
      Begin
        Select 1
        Into n_Count
        From 临床出诊记录 A, 临床出诊安排 B
        Where a.号源id = b.号源id And a.出诊日期 Between b.开始时间 And b.终止时间 And a.安排id <> b.Id And b.出诊id = Id_In And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count <> 0 Then
        v_Err_Msg := '当前出诊表中的部分号源在当前出诊表的生效时间范围内已经存在有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    End If;
  
    --如果存在多个未发布的安排表，则不允许发布后面日期的安排，必须按最小有效时间进行发布
    Begin
      Select 1
      Into n_Count
      From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
             From 临床出诊表
             Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Null) A,
           (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
      Where a.日期 < b.日期 And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count <> 0 Then
      If Nvl(n_排班方式, 0) = 0 Then
        v_Err_Msg := '当前出诊表前面还有未发布的固定出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 1 Then
        v_Err_Msg := '当前出诊表前面还有未发布的月出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 2 Then
        v_Err_Msg := '当前出诊表前面还有未发布的周出诊表，必须先将其发布或删除后才能发布该出诊表！';
      End If;
      Raise Err_Item;
    End If;
  
    Update 临床出诊表 Set 发布人 = 发布人_In, 发布时间 = 发布时间_In Where ID = Id_In;
    Update 临床出诊安排 Set 审核人 = 发布人_In, 审核时间 = 发布时间_In Where 出诊id = Id_In;
  
    --删除发布时有安排，但是号源已被停用的记录
    For c_安排 In (Select a.Id
                 From 临床出诊安排 A, 临床出诊号源 B
                 Where a.号源id = b.Id And a.出诊id = Id_In And
                       Not (Nvl(b.是否删除, 0) = 0 And (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')))) Loop
      Zl_临床出诊安排_Delete(c_安排.Id, Nvl(n_排班方式, 0));
    End Loop;
  
    If Nvl(n_排班方式, 0) <> 0 Then
      --月安排/周安排根据停诊安排和法定节假日调整出诊记录的出诊/预约情况
      Select 开始时间, 终止时间 Into d_开始时间, d_终止时间 From 临床出诊安排 Where 出诊id = Id_In And Rownum < 2;
      For c_安排 In (Select a.Id, a.号源id, b.日期
                   From 临床出诊安排 A,
                        (Select Trunc(d_开始时间) + Level - 1 As 日期
                          From Dual
                          Connect By Level <= Trunc(d_终止时间) - Trunc(d_开始时间) + 1) B
                   Where a.出诊id = Id_In
                   Order By 号源id, 日期) Loop
      
        Zl_Clinicvisitmodify(c_安排.号源id, c_安排.Id, c_安排.日期, 发布人_In, 发布时间_In);
      End Loop;
    
      --修改临床出诊记录中的"是否发布"
      Select a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.安排id = b.Id And b.出诊id = Id_In;
    
      Forall I In 1 .. l_记录id.Count
        Update 临床出诊记录 Set 是否发布 = 1 Where ID = l_记录id(I);
    End If;
    Return;
  End If;

  --==================================================================================================================
  --取消发布
  Begin
    Select 1
    Into n_Count
    From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
           From 临床出诊表
           Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And 发布人 Is Not Null) A,
         (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
    Where a.日期 > b.日期 And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count <> 0 Then
    If Nvl(n_排班方式, 0) = 0 Then
      v_Err_Msg := '当前出诊后面还有已发布的固定出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 1 Then
      v_Err_Msg := '当前出诊后面还有已发布的月出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 2 Then
      v_Err_Msg := '当前出诊后面还有已发布的周出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    End If;
    Raise Err_Item;
  End If;

  Begin
    Select 1
    Into n_Count
    From 病人挂号记录 C, 临床出诊记录 A, 临床出诊安排 B
    Where c.出诊记录id = a.Id And a.安排id = b.Id And b.出诊id = Id_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表的安排已被使用，不允许取消发布！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 发布人 = Null, 发布时间 = Null Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;
  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where 出诊id = Id_In;

  --固定安排取消发布时删除出诊记录
  If Nvl(n_排班方式, 0) = 0 Then
    --删除出诊记录
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  Else
    --月安排/周安排清除停诊信息，并修改是否发布
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Delete From 临床出诊停诊记录 Where 记录id = l_记录id(I);
  
    --修改临床出诊记录中的"是否发布"
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Update 临床出诊记录
      Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null, 是否发布 = 0
      Where ID = l_记录id(I);
  
    --恢复临床出诊序号控制的"是否预约"
    For c_记录 In (Select a.Id, a.是否分时段, a.是否序号控制
                 From 临床出诊记录 A, 临床出诊安排 B
                 Where a.安排id = b.Id And b.出诊id = Id_In) Loop
      If Nvl(c_记录.是否分时段, 0) = 1 Then
        If Nvl(c_记录.是否序号控制, 0) = 0 Then
          Update 临床出诊序号控制 Set 是否预约 = 1 Where 记录id = c_记录.Id;
        Else
          Update 临床出诊序号控制 Set 是否预约 = Nvl(预约顺序号, 0) Where 记录id = c_记录.Id;
        End If;
      End If;
    End Loop;
  
    --换休的不再恢复
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Publish;
/


Create Or Replace Function Zl_Fun_Get临床出诊预约状态
(
  记录id_In   In 临床出诊记录.Id%Type,
  预约时间_In In 病人挂号记录.预约时间%Type,
  序号_In     临床出诊序号控制.序号%Type := Null,
  预约方式_In 预约方式.名称%Type := Null,
  合作单位_In 挂号合作单位.名称%Type := Null,
  收费预约_In Number := 0
) Return Varchar2 As
  --功能：判断出诊记录在预约时间是否可预约
  --入参：
  --返回：
  --     格式：预约状态|提示信息，如："1|预约时间不在当前上班时段时间范围内。"
  --     预约状态：
  --         0-可预约
  --         ======================================================
  --         1-不可预约，预约时间不在当前上班时段时间范围内
  --         2-不可预约，当前上班时段禁止预约
  --         3-不可预约，当前上班时段在预约时间时已停诊
  --         4-不可预约，当前上班时段剩余可预约数为零
  --         ======================================================
  --         5-不可预约，当前预约时间在法定节假日时间范围内，不上班
  --         6-不可预约，当前预约时间在法定节假日时间范围内，禁止预约
  --         7-不可预约，当前预约时间在法定节假日不允许预约的时间范围内
  --         8-不可预约，当前预约时间在法定节假日不允许挂号的时间范围内
  --         9-不可预约，当前预约时间在法定节假日时间范围内，已停诊
  --         ======================================================
  --         10-不可预约，当前预约方式禁止预约
  --         11-不可预约，当前预约方式可预约数不足
  --         ======================================================
  --         12-不可预约，当前合作单位禁止预约
  --         13-不可预约，当前合作单位可预约数不足
  --         ======================================================
  --         14-不可预约，当前序号禁止预约
  --         15-不可预约，当前序号已经被使用
  --         16-不可预约，当前序号不可用
  --
  n_号源id         临床出诊记录.号源id%Type;
  n_是否分时段     临床出诊记录.是否分时段%Type;
  n_预约控制       临床出诊记录.预约控制%Type;
  d_停诊开始时间   临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间   临床出诊记录.停诊终止时间%Type;
  v_停诊原因       临床出诊记录.停诊原因%Type;
  n_限约数         临床出诊记录.限约数%Type;
  n_已约数         临床出诊记录.已约数%Type;
  n_独占           临床出诊记录.是否独占%Type;
  n_控制方式       临床出诊挂号控制记录.控制方式%Type;
  n_数量           临床出诊挂号控制记录.数量%Type;
  n_数量限制       临床出诊挂号控制记录.数量%Type;
  n_序号控制       临床出诊记录.是否序号控制%Type;
  v_预约方式       临床出诊挂号控制记录.名称%Type;
  n_类型           临床出诊挂号控制记录.类型%Type;
  n_预约方式限约数 临床出诊记录.限约数%Type;
  n_预约方式已约数 临床出诊记录.已约数%Type;
  n_挂号状态       临床出诊序号控制.挂号状态%Type;
  n_是否预约       临床出诊序号控制.是否预约%Type;

  n_假日控制状态 临床出诊号源.假日控制状态%Type;

  v_允许预约 法定假日表.允许预约%Type;
  v_允许挂号 法定假日表.允许挂号%Type;
  n_Count    Number(2);
  n_已使用   Number(5);
Begin
  Begin
    Select a.号源id, a.是否分时段, a.预约控制, a.停诊开始时间, a.停诊终止时间, a.停诊原因, Nvl(限约数, 限号数), 已约数, 是否独占, 是否序号控制
    Into n_号源id, n_是否分时段, n_预约控制, d_停诊开始时间, d_停诊终止时间, v_停诊原因, n_限约数, n_已约数, n_独占, n_序号控制
    From 临床出诊记录 A
    Where a.Id = 记录id_In And 预约时间_In Between 开始时间 And 终止时间;
  Exception
    When Others Then
      Return '1|预约时间不在当前上班时段时间范围内。';
  End;

  --预约方式检查
  If 预约方式_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And 名称 = 预约方式_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '10|当前预约方式禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 2 And 性质 = 1 And 名称 = 预约方式_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 预约方式 = 预约方式_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          If 收费预约_In = 0 Then
            For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 病人挂号记录
                Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              End If;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          Else
            For r_限制 In (Select 数量, 名称, 类型
                         From 临床出诊挂号控制记录
                         Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In) Loop
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
              If n_控制方式 = 1 Then
                n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
              Else
                n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
              End If;
            End Loop;
            Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
            If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
              Null;
            Else
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        If 收费预约_In = 0 Then
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Or n_类型 = 1 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        Else
          Begin
            Select 数量, 名称, 类型
            Into n_预约方式限约数, v_预约方式, n_类型
            From 临床出诊挂号控制记录
            Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In;
          Exception
            When Others Then
              n_预约方式限约数 := Null;
          End;
          If n_预约方式限约数 Is Not Null Then
            If v_预约方式 <> 预约方式_In Then
              Return '11|当前预约方式可预约数不足。';
            End If;
            Select Nvl(Max(1), 0)
            Into n_预约方式已约数
            From 病人挂号记录
            Where 出诊记录id = 记录id_In And 号序 = 序号_In;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '11|当前预约方式可预约数不足。';
            End If;
          End If;
        End If;
      Else
        If 收费预约_In = 0 Then
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Or r_限制.类型 = 1 Then
              If r_限制.类型 = 1 Then
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.合作单位 = r_限制.名称 And b.记录状态 = 1;
              Else
                Select Count(1)
                Into n_已使用
                From 临床出诊序号控制 A, 病人挂号记录 B
                Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                      b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              End If;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型
                       From 临床出诊挂号控制记录
                       Where 性质 = 1 And 类型 = 2 And 记录id = 记录id_In And 序号 = 序号_In) Loop
            If r_限制.名称 <> 预约方式_In Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            Else
              Select Count(1)
              Into n_预约方式已约数
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = 预约方式_In And b.记录状态 = 1;
              If n_预约方式已约数 >= n_预约方式限约数 Then
                Return '11|当前预约方式可预约数不足。';
              End If;
            End If;
          End Loop;
          Select Count(1)
          Into n_已使用
          From 临床出诊序号控制 A
          Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
          Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '11|当前预约方式可预约数不足。';
          End If;
        End If;
      End If;
    End If;
  End If;

  --合作单位检查
  If 合作单位_In Is Not Null Then
    Begin
      Select 控制方式
      Into n_控制方式
      From 临床出诊挂号控制记录
      Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And 名称 = 合作单位_In And Rownum < 2;
    Exception
      When Others Then
        Begin
          Select 控制方式
          Into n_控制方式
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 记录id = 记录id_In And Rownum < 2;
        Exception
          When Others Then
            Null;
        End;
    End;
    If n_控制方式 = 0 Then
      Return '12|当前合作单位禁止预约。';
    End If;
    If n_控制方式 = 1 Or n_控制方式 = 2 Then
      Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
      If n_独占 = 0 Then
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        --限数量独占
        Begin
          Select 数量
          Into n_数量
          From 临床出诊挂号控制记录
          Where 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 记录id = 记录id_In;
        Exception
          When Others Then
            n_数量 := Null;
        End;
        If n_数量 Is Not Null Then
          If n_控制方式 = 1 Then
            n_预约方式限约数 := Round(n_预约方式限约数 * n_数量 / 100);
          Else
            n_预约方式限约数 := n_数量;
          End If;
          Select Count(1)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 记录状态 = 1 And 合作单位 = 合作单位_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        Else
          For r_限制 In (Select 数量, 名称, 类型 From 临床出诊挂号控制记录 Where 性质 = 1 And 记录id = 记录id_In) Loop
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 合作单位 = r_限制.名称 And 记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 病人挂号记录
              Where 出诊记录id = 记录id_In And 预约方式 = r_限制.名称 And 记录状态 = 1;
            End If;
            If n_控制方式 = 1 Then
              n_数量限制 := Nvl(n_数量限制, 0) + Round(r_限制.数量 * n_预约方式限约数 / 100) - Nvl(n_已使用, 0);
            Else
              n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
            End If;
          End Loop;
          Select Count(1) Into n_已使用 From 病人挂号记录 Where 出诊记录id = 记录id_In And 记录状态 = 1;
          If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
            Null;
          Else
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      End If;
    End If;
    If n_控制方式 = 3 Then
      If n_序号控制 = 1 Then
        Begin
          Select 数量, 名称, 类型
          Into n_预约方式限约数, v_预约方式, n_类型
          From 临床出诊挂号控制记录
          Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In;
        Exception
          When Others Then
            n_预约方式限约数 := Null;
        End;
        If n_预约方式限约数 Is Not Null Then
          If v_预约方式 <> 合作单位_In Or n_类型 = 1 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
          Select Nvl(Max(1), 0)
          Into n_预约方式已约数
          From 病人挂号记录
          Where 出诊记录id = 记录id_In And 号序 = 序号_In;
          If n_预约方式已约数 >= n_预约方式限约数 Then
            Return '13|当前合作单位可预约数不足。';
          End If;
        End If;
      Else
        For r_限制 In (Select 数量, 名称, 类型
                     From 临床出诊挂号控制记录
                     Where 性质 = 1 And 记录id = 记录id_In And 序号 = 序号_In) Loop
          If r_限制.名称 <> 合作单位_In Or r_限制.类型 = 1 Then
            If r_限制.类型 = 1 Then
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.合作单位 = r_限制.名称 And b.记录状态 = 1;
            Else
              Select Count(1)
              Into n_已使用
              From 临床出诊序号控制 A, 病人挂号记录 B
              Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And
                    b.预约方式 = r_限制.名称 And b.记录状态 = 1;
            End If;
            n_数量限制 := Nvl(n_数量限制, 0) + r_限制.数量 - Nvl(n_已使用, 0);
          Else
            Select Count(1)
            Into n_预约方式已约数
            From 临床出诊序号控制 A, 病人挂号记录 B
            Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And a.备注 = b.号序 And b.合作单位 = 合作单位_In And
                  b.记录状态 = 1;
            If n_预约方式已约数 >= n_预约方式限约数 Then
              Return '13|当前合作单位可预约数不足。';
            End If;
          End If;
        End Loop;
        Select Count(1)
        Into n_已使用
        From 临床出诊序号控制 A
        Where a.记录id = 记录id_In And a.预约顺序号 Is Not Null And Nvl(a.挂号状态, 0) <> 0 And 序号 = 序号_In;
        Select Nvl(限约数, 限号数) Into n_预约方式限约数 From 临床出诊记录 Where ID = 记录id_In;
        If n_预约方式限约数 - n_数量限制 - n_已使用 > 0 Then
          Null;
        Else
          Return '13|当前合作单位可预约数不足。';
        End If;
      End If;
    End If;
  End If;

  --0-不作预约限制;1-该号别禁止预约;2-仅禁止三方机构平台的预约
  If Nvl(n_预约控制, 0) = 1 Then
    Return '2|当前上班时段禁止预约。';
  End If;

  If d_停诊开始时间 Is Not Null And Not (Nvl(n_序号控制, 0) = 1 And Nvl(n_是否分时段, 0) = 1) Then
    If 预约时间_In >= d_停诊开始时间 And 预约时间_In <= d_停诊终止时间 Then
      Return '3|当前上班时段在预约时间时已停诊，不能预约！';
    End If;
  End If;

  If Nvl(n_限约数, 0) > 0 Then
    If Nvl(n_限约数, 0) - Nvl(n_已约数, 0) <= 0 Then
      Return '4|当前上班时段剩余可预约数为零，不能继续预约！';
    End If;
  End If;

  If Nvl(n_是否分时段, 0) = 0 Then
    --不分时段
    Begin
      Select Nvl(b.假日控制状态, 0) Into n_假日控制状态 From 临床出诊号源 B Where b.Id = n_号源id;
    Exception
      When Others Then
        n_假日控制状态 := 0;
    End;
  
    --1.查找包含预约时间的节假日
    Begin
      Select 允许预约, 允许挂号
      Into v_允许预约, v_允许挂号
      From 法定假日表 A
      Where a.性质 = 0 And 预约时间_In Between a.开始日期 And a.终止日期 + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
    Exception
      When Others Then
        Return '0|正常预约。';
    End;
  
    --假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制
    If Nvl(n_假日控制状态, 0) = 0 Then
      --不上班的肯定是不能预约的
      Return '5|当前预约时间在法定节假日时间范围内，不上班。';
    Elsif Nvl(n_假日控制状态, 0) = 1 Then
      Return '0|正常预约。';
    Elsif Nvl(n_假日控制状态, 0) = 2 Then
      --在节假日时间范围内，则不能预约
      Return '6|当前预约时间在法定节假日时间范围内，禁止预约。';
    Elsif Nvl(n_假日控制状态, 0) = 3 Then
      --没有"允许挂号"就一定没有"允许预约"
      If v_允许挂号 Is Not Null Then
        --2.检查是否有包含预约时间的"允许挂号"
        Select Max(1)
        Into n_Count
        From Table(f_Str2list(v_允许挂号, ';'))
        Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
              To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
      
        If Nvl(n_Count, 0) <> 0 Then
          --3.检查是否有包含预约时间的"允许预约"
          Select Max(1)
          Into n_Count
          From Table(f_Str2list(v_允许预约, ';'))
          Where 预约时间_In Between To_Date(Column_Value, 'yyyy-mm-dd') And
                To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And Rownum < 2;
        
          If Nvl(n_Count, 0) = 0 Then
            --不在"允许预约"时间范围内，则不能预约
            Return '7|当前预约时间在法定节假日不允许预约的时间范围内，不能预约。';
          Else
            Return '0|正常预约。';
          End If;
        Else
          Return '8|当前预约时间在法定节假日不允许挂号的时间范围内，不能预约。';
        End If;
      Else
        --没有设置"允许挂号"/"允许预约"表示停诊，肯定不能预约
        Return '9|当前预约时间在法定节假日时间范围内，已停诊，不能预约。';
      End If;
    End If;
  Else
    --分时段
    If Nvl(序号_In, 0) <> 0 Then
      Begin
        Select Nvl(是否预约, 0), Nvl(挂号状态, 0)
        Into n_是否预约, n_挂号状态
        From 临床出诊序号控制
        Where 记录id = 记录id_In And 序号 = 序号_In;
      Exception
        When Others Then
          Return '16|当前选择的序号不可用。';
      End;
      If n_是否预约 = 0 Then
        Return '14|当前选择的序号禁止预约。';
      End If;
      If n_挂号状态 <> 0 Then
        Return '15|当前选择的序号已经被使用。';
      End If;
    End If;
    Return '0|正常预约。';
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Get临床出诊预约状态;
/


Create Or Replace Procedure Zl_临床出诊表_Update
(
  操作类型_In Number,
  Id_In       临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type := Null,
  开始时间_In 临床出诊安排.开始时间%Type := Null,
  终止时间_In 临床出诊安排.终止时间%Type := Null,
  应用范围_In 临床出诊表.应用范围%Type := Null,
  科室id_In   临床出诊表.科室id%Type := Null,
  备注_In     临床出诊表.备注%Type := Null
) As
  --调整出诊表信息，针对模板和固定安排
  --操作类型_In 1-模板，2-固定安排
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;
Begin
  --模板
  If Nvl(操作类型_In, 0) = 1 Then
    Update 临床出诊表
    Set 出诊表名 = 出诊表名_In, 应用范围 = 应用范围_In, 科室id = 科室id_In, 备注 = 备注_In
    Where ID = Id_In;
    If Sql%NotFound Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
    End If;
    Return;
  End If;

  --固定安排
  Begin
    Select 1 Into n_Count From 临床出诊表 Where 发布人 Is Not Null And ID = Id_In And Rownum < 2;
  Exception
    When Others Then
      n_Count := 0;
  End;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不允许进行调整！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 出诊表名 = 出诊表名_In Where ID = Id_In;
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;

  Update 临床出诊安排
  Set 开始时间 = Nvl(开始时间_In, 开始时间), 终止时间 = Nvl(终止时间_In, 终止时间), 操作员姓名 = Nvl(操作员姓名, Zl_Username), 登记时间 = Nvl(登记时间, Sysdate)
  Where 出诊id = Id_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Update;
/
Create Or Replace Procedure Zl_临床出诊安排_Delete
(
  Id_In       临床出诊安排.Id%Type,
  出诊记录_In Number := 0
) As
  --功能：删除临床出诊安排
  --参数：

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_限制id t_Numlist := t_Numlist();
  l_记录id t_Numlist := t_Numlist();
Begin

  If Nvl(出诊记录_In, 0) = 0 Then
    --删除临床出诊规则/模板
    Select ID Bulk Collect Into l_限制id From 临床出诊限制 Where 安排id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
  
    Delete From 临床出诊限制 Where 安排id = Id_In;
  Else
    --删除临床出诊记录
    Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 安排id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  End If;
  Delete From 临床出诊安排 Where ID = Id_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Delete;
/
Create Or Replace Procedure Zl_临床出诊安排_序号控制
(
  出诊id_In   临床出诊表.Id%Type,
  序号控制_In 临床出诊限制.是否序号控制%Type,
  站点_In     部门表.站点%Type := Null,
  人员id_In   人员表.Id%Type := 0
) As
  --全部启用序号控制或者全部取消序号控制
  --参数：
  --      人员id_In 不等于0则修改人员所在科室的所有号源安排，否则修改所有号源的安排
  n_Count    Number(2);
  n_出诊记录 Number(2);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_安排id t_Numlist := t_Numlist();

  --该游标用于读取所有临床出诊安排的ID
  Cursor c_安排
  (
    出诊id_In 临床出诊表.Id%Type,
    人员id_In 人员表.Id%Type := 0
  ) Is
    Select b.Id
    From 临床出诊安排 B, 临床出诊号源 C
    Where b.号源id = c.Id And b.出诊id = 出诊id_In And
          (Nvl(人员id_In, 0) = 0 Or
          (Nvl(人员id_In, 0) <> 0 And Exists (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In))) And Exists
     (Select 1 From 部门表 Where ID = c.科室id And (站点_In Is Null Or (站点 Is Null Or 站点 = 站点_In)));
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊表 A
  Where a.Id = 出诊id_In And a.发布人 Is Not Null And a.排班方式 <> 3 And Rownum < 2;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不允许修改！';
    Raise Err_Item;
  End If;

  Select Count(1) Into n_Count From 临床出诊表 A Where a.Id = 出诊id_In And a.排班方式 In (1, 2) And Rownum < 2;
  If n_Count <> 0 Then
    n_出诊记录 := 1;
  End If;

  Open c_安排(出诊id_In, 人员id_In);
  Fetch c_安排 Bulk Collect
    Into l_安排id;
  Close c_安排;

  If Nvl(n_出诊记录, 0) = 0 Then
    --临床出诊限制或模板
    Forall I In 1 .. l_安排id.Count
      Update 临床出诊限制
      Set 是否序号控制 = 序号控制_In
      Where (限号数 Is Not Null Or 限约数 Is Not Null) And 安排id = l_安排id(I);
  
  Else
    --临床出诊记录
    Forall I In 1 .. l_安排id.Count
      Update 临床出诊记录
      Set 是否序号控制 = 序号控制_In
      Where (限号数 Is Not Null Or 限约数 Is Not Null) And 安排id = l_安排id(I);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_序号控制;
/
CREATE OR REPLACE Procedure Zl_临床出诊上班时段_Delete
(
  安排id_In       临床出诊限制.安排id%Type,
  项目_In         临床出诊限制.限制项目%Type,
  出诊记录_In     Number := 0,
  上班时段_In     临床出诊限制.上班时段%Type := Null,
  删除出诊安排_In Number := 0
) As
  --功能：删除临床出诊规则/记录
  --参数：
  --      出诊记录_In:是否是对出诊记录进行删除
  --      删除出诊安排_In:删除出诊时段时是否删除安排记录
  l_限制id t_Numlist := t_Numlist();
  l_记录id t_Numlist := t_Numlist();

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  If Nvl(出诊记录_In, 0) = 0 Then
    --删除临床出诊规则/模板
    Select ID Bulk Collect
    Into l_限制id
    From 临床出诊限制
    Where 安排id = 安排id_In And 限制项目 = 项目_In And (上班时段_In Is Null Or 上班时段 = 上班时段_In);

    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);

    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);

    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);

    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊限制 Where ID = l_限制id(I);

    If Nvl(删除出诊安排_In, 0) = 1 Then
      Delete 临床出诊安排 A Where a.Id = 安排id_In And Not Exists (Select 1 From 临床出诊限制 Where 安排id = a.Id);
    End If;
  Else
    --删除临床出诊记录
    Select ID Bulk Collect
    Into l_记录id
    From 临床出诊记录
    Where 安排id = 安排id_In And 出诊日期 = To_Date(项目_In, 'yyyy-mm-dd') And (上班时段_In Is Null Or 上班时段 = 上班时段_In);

    Zl_临床出诊记录_Batchdelete(l_记录id);

    If Nvl(删除出诊安排_In, 0) = 1 Then
      Delete 临床出诊安排 A Where a.Id = 安排id_In And Not Exists (Select 1 From 临床出诊记录 Where 安排id = a.Id);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊上班时段_Delete;
/
Create Or Replace Procedure Zl_临床出诊安排_Insert
(
  Id_In           临床出诊安排.Id%Type,
  出诊id_In       临床出诊安排.出诊id%Type,
  号源id_In       临床出诊安排.号源id%Type,
  项目id_In       临床出诊安排.项目id%Type,
  医生id_In       临床出诊安排.医生id%Type,
  医生姓名_In     临床出诊安排.医生姓名%Type,
  排班规则_In     临床出诊安排.排班规则%Type,
  是否周六出诊_In 临床出诊安排.是否周六出诊%Type,
  是否周日出诊_In 临床出诊安排.是否周日出诊%Type,
  开始时间_In     临床出诊安排.开始时间%Type,
  终止时间_In     临床出诊安排.终止时间%Type,
  操作员姓名_In   临床出诊安排.操作员姓名%Type,
  登记时间_In     临床出诊安排.登记时间%Type,
  是否审核_In     Number := 0,
  是否临时安排_In 临床出诊安排.是否临时安排%Type := 0
) As
  --功能：插入或更新临床出诊安排
  --参数：

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin

  Update 临床出诊安排
  Set 出诊id = 出诊id_In, 号源id = 号源id_In, 项目id = 项目id_In, 医生id = 医生id_In, 医生姓名 = 医生姓名_In, 排班规则 = 排班规则_In, 是否周六出诊 = 是否周六出诊_In,
      是否周日出诊 = 是否周日出诊_In, 开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 操作员姓名 = 操作员姓名_In, 登记时间 = 登记时间_In, 是否临时安排 = 是否临时安排_In
  Where ID = Id_In;
  If Sql% NotFound Then
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 是否周六出诊, 是否周日出诊, 开始时间, 终止时间, 操作员姓名, 登记时间, 是否临时安排)
    Values
      (Id_In, 出诊id_In, 号源id_In, 项目id_In, 医生id_In, 医生姓名_In, 排班规则_In, 是否周六出诊_In, 是否周日出诊_In, 开始时间_In, 终止时间_In, 操作员姓名_In,
       登记时间_In, 是否临时安排_In);
  
    --月安排/周安排，出诊表发布后新增号源直接审核
    If Nvl(是否审核_In, 0) = 1 Then
      Update 临床出诊安排 Set 审核人 = 操作员姓名_In, 审核时间 = 登记时间_In Where ID = Id_In;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Insert;
/
Create Or Replace Procedure Zl_临床出诊限制_Insert
(
  Id_In           临床出诊限制.Id%Type,
  安排id_In       临床出诊限制.安排id%Type,
  限制项目_In     临床出诊限制.限制项目%Type,
  上班时段_In     临床出诊限制.上班时段%Type,
  限号数_In       临床出诊限制.限号数%Type,
  限约数_In       临床出诊限制.限约数%Type,
  是否分时段_In   临床出诊限制.是否分时段%Type,
  是否序号控制_In 临床出诊限制.是否序号控制%Type,
  预约控制_In     临床出诊限制.预约控制%Type,
  是否独占_In     临床出诊限制.是否独占%Type,
  分诊方式_In     临床出诊限制.分诊方式%Type := Null,
  诊室_In         Varchar2 := Null,
  时段_In         Varchar2 := Null,
  删除序号_In     Number := 0
) As
  --功能：插入或更新临床出诊限制
  --参数：
  --     诊室_In:诊室1,诊室2,...
  --     时段_In:序号,开始时间,终止时间,限制数量,预约标志|...
  --     删除序号_In:是否删除现有序号时段
  v_诊室 Varchar2(100);
  n_诊室 临床出诊诊室.诊室id%Type;

  v_时段     Varchar2(5000);
  n_序号     临床出诊时段.序号%Type;
  d_开始时间 临床出诊时段.开始时间%Type;
  d_终止时间 临床出诊时段.终止时间%Type;
  n_限制数量 临床出诊时段.限制数量%Type;
  n_是否预约 临床出诊时段.是否预约%Type;
  v_当前序号 Varchar2(100);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin

  Update 临床出诊限制
  Set 限号数 = 限号数_In, 限约数 = 限约数_In, 是否分时段 = 是否分时段_In, 是否序号控制 = 是否序号控制_In, 预约控制 = 预约控制_In, 是否独占 = 是否独占_In, 分诊方式 = 分诊方式_In,
      诊室id = Null
  Where ID = Id_In;
  If Sql% NotFound Then
    Insert Into 临床出诊限制
      (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
    Values
      (Id_In, 安排id_In, 限制项目_In, 上班时段_In, 限号数_In, 限约数_In, 是否分时段_In, 是否序号控制_In, 预约控制_In, 是否独占_In, 分诊方式_In);
  End If;

  Delete From 临床出诊诊室 Where 限制id = Id_In;
  --出诊诊室
  If 诊室_In Is Not Null Then
    v_诊室 := 诊室_In || ',';
  End If;
  While v_诊室 Is Not Null Loop
    n_诊室 := To_Number(Substr(v_诊室, 1, Instr(v_诊室, ',') - 1));
    If Nvl(分诊方式_In, 0) = 1 Then
      Update 临床出诊限制 Set 诊室id = n_诊室 Where ID = Id_In;
    End If;
    Insert Into 临床出诊诊室 (限制id, 诊室id) Values (Id_In, n_诊室);
    v_诊室 := Substr(v_诊室, Instr(v_诊室, ',') + 1);
  End Loop;

  --出诊时段
  If Nvl(删除序号_In, 0) = 1 Then
    --删除现有序号时段
    Delete 临床出诊时段 Where 限制id = Id_In;
  End If;
  If 时段_In Is Not Null Then
    v_时段 := 时段_In || '|';
  End If;
  While v_时段 Is Not Null Loop
    v_当前序号 := Substr(v_时段, 1, Instr(v_时段, '|') - 1);
    n_序号     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_开始时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_终止时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_限制数量 := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_是否预约 := To_Number(v_当前序号);
    If Nvl(n_序号, 0) <> 0 Then
      Insert Into 临床出诊时段
        (限制id, 序号, 开始时间, 终止时间, 是否预约, 限制数量)
      Values
        (Id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_限制数量);
    End If;
    v_时段 := Substr(v_时段, Instr(v_时段, '|') + 1);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊限制_Insert;
/
Create Or Replace Procedure Zl_临床出诊挂号控制_Insert
(
  限制id_In   临床出诊挂号控制.限制id%Type,
  类型_In     临床出诊挂号控制.类型%Type,
  性质_In     临床出诊挂号控制.性质%Type,
  名称_In     临床出诊挂号控制.名称%Type,
  控制方式_In 临床出诊挂号控制.控制方式%Type,
  是否独占_In 临床出诊限制.是否独占%Type,
  安排控制_In Varchar2,
  删除_In     Number := 0
) As
  --功能:插入或更新临床出诊挂号控制
  --参数:
  --    类型_In:1-三方机构;2-预约方式
  --    安排控制_in:序号1,数量|序号2,数量|...
  --    删除_in:是否删除现有的
  v_序号     Varchar2(5000);
  v_当前项目 Varchar2(5000);
  n_序号     临床出诊挂号控制.序号%Type;
  n_数量     临床出诊挂号控制.数量%Type;
  n_Count    Number;

  Err_Item Exception;
  v_Err_Msg Varchar2(100);
Begin
  If Nvl(类型_In, 0) = 1 Then
    --合作单位
    Select Count(1) Into n_Count From 挂号合作单位 Where 名称 = 名称_In;
    If n_Count = 0 Then
      --合作单位已不存在
      If Nvl(删除_In, 0) = 1 Then
        --删除已有的
        Delete From 临床出诊挂号控制 Where 限制id = 限制id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
      End If;
      Return;
    End If;
  Elsif Nvl(类型_In, 0) = 2 Then
    --预约方式
    Select Count(1) Into n_Count From 预约方式 Where 名称 = 名称_In;
    If n_Count = 0 Then
      --预约方式已不存在
      If Nvl(删除_In, 0) = 1 Then
        --删除已有的
        Delete From 临床出诊挂号控制 Where 限制id = 限制id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
      End If;
      Return;
    End If;
  End If;

  Update 临床出诊限制 Set 是否独占 = 是否独占_In Where ID = 限制id_In;

  If Nvl(删除_In, 0) = 1 Then
    --删除已有的
    Delete From 临床出诊挂号控制 Where 限制id = 限制id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
  End If;

  v_序号 := 安排控制_In || '|';
  While v_序号 Is Not Null Loop
    v_当前项目 := Substr(v_序号, 1, Instr(v_序号, '|') - 1);
    n_序号     := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_数量     := To_Number(v_当前项目);
    If Nvl(n_数量, 0) <> 0 Then
      Insert Into 临床出诊挂号控制
        (限制id, 类型, 性质, 名称, 序号, 数量, 控制方式)
      Values
        (限制id_In, 类型_In, 性质_In, 名称_In, n_序号, n_数量, 控制方式_In);
    End If;
    v_序号 := Substr(v_序号, Instr(v_序号, '|') + 1);
  End Loop;

  --每一个合作单位或者预约方式至少得有一条记录
  Select Count(1)
  Into n_Count
  From 临床出诊挂号控制
  Where 限制id = 限制id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
  If n_Count = 0 Then
    Insert Into 临床出诊挂号控制
      (限制id, 类型, 性质, 名称, 序号, 数量, 控制方式)
    Values
      (限制id_In, 类型_In, 性质_In, 名称_In, 0, 0, 控制方式_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊挂号控制_Insert;
/
Create Or Replace Procedure Zl_临床出诊记录_Insert
(
  Id_In           临床出诊记录.Id%Type,
  安排id_In       临床出诊记录.安排id%Type,
  号源id_In       临床出诊记录.号源id%Type,
  出诊日期_In     临床出诊记录.出诊日期%Type,
  上班时段_In     临床出诊记录.上班时段%Type,
  开始时间_In     临床出诊记录.开始时间%Type,
  终止时间_In     临床出诊记录.终止时间%Type,
  缺省预约时间_In 临床出诊记录.缺省预约时间%Type,
  提前挂号时间_In 临床出诊记录.提前挂号时间%Type,
  限号数_In       临床出诊记录.限号数%Type,
  限约数_In       临床出诊记录.限约数%Type,
  是否序号控制_In 临床出诊记录.是否序号控制%Type,
  是否分时段_In   临床出诊记录.是否分时段%Type,
  预约控制_In     临床出诊记录.预约控制%Type,
  是否独占_In     临床出诊记录.是否独占%Type,
  项目id_In       临床出诊记录.项目id%Type,
  科室id_In       临床出诊记录.科室id%Type,
  医生id_In       临床出诊记录.医生id%Type,
  医生姓名_In     临床出诊记录.医生姓名%Type,
  分诊方式_In     临床出诊记录.分诊方式%Type,
  是否临时出诊_In 临床出诊记录.是否临时出诊%Type,
  登记人_In       临床出诊记录.登记人%Type,
  登记时间_In     临床出诊记录.登记时间%Type,
  是否发布_In     临床出诊记录.是否发布%Type,
  诊室_In         Varchar2 := Null,
  时段_In         Varchar2 := Null,
  删除序号_In     Number := 0
) As
  --功能：插入或更新临床出诊记录
  --参数：
  --     诊室_In:诊室1,诊室2,...
  --     时段_In:序号,开始时间,终止时间,限制数量,预约标志|...
  --     删除序号_In:是否删除现有序号时段
  v_时段     Varchar2(5000);
  n_序号     临床出诊序号控制.序号%Type;
  d_开始时间 临床出诊序号控制.开始时间%Type;
  d_终止时间 临床出诊序号控制.终止时间%Type;
  n_数量     临床出诊序号控制.数量%Type;
  n_是否预约 临床出诊序号控制.是否预约%Type;
  v_当前序号 Varchar2(100);

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Update 临床出诊记录
  Set 安排id = 安排id_In, 号源id = 号源id_In, 出诊日期 = 出诊日期_In, 上班时段 = 上班时段_In, 开始时间 = 开始时间_In, 终止时间 = 终止时间_In, 缺省预约时间 = 缺省预约时间_In,
      提前挂号时间 = 提前挂号时间_In, 限号数 = 限号数_In, 限约数 = 限约数_In, 是否序号控制 = 是否序号控制_In, 是否分时段 = 是否分时段_In, 预约控制 = 预约控制_In,
      是否独占 = 是否独占_In, 项目id = 项目id_In, 科室id = 科室id_In, 医生id = 医生id_In, 医生姓名 = 医生姓名_In, 分诊方式 = 分诊方式_In, 是否临时出诊 = 是否临时出诊_In,
      登记人 = 登记人_In, 登记时间 = 登记时间_In, 诊室id = Null, 是否发布 = 是否发布_In
  Where ID = Id_In;
  If Sql% NotFound Then
    Insert Into 临床出诊记录
      (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 项目id, 科室id, 医生id,
       医生姓名, 分诊方式, 是否临时出诊, 登记人, 登记时间, 是否发布)
    Values
      (Id_In, 安排id_In, 号源id_In, 出诊日期_In, 上班时段_In, 开始时间_In, 终止时间_In, 缺省预约时间_In, 提前挂号时间_In, 限号数_In, 限约数_In, 是否序号控制_In,
       是否分时段_In, 预约控制_In, 是否独占_In, 项目id_In, 科室id_In, 医生id_In, 医生姓名_In, 分诊方式_In, 是否临时出诊_In, 登记人_In, 登记时间_In, 是否发布_In);
  End If;

  --删除上班时段为空的
  Delete From 临床出诊记录
  Where 安排id = 安排id_In And 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Null And Exists
   (Select 1
         From 临床出诊记录
         Where 安排id = 安排id_In And 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null);

  Delete From 临床出诊诊室记录 Where 记录id = Id_In;
  --出诊诊室
  If 诊室_In Is Not Null Then
    Insert Into 临床出诊诊室记录
      (记录id, 诊室id)
      Select Id_In, Column_Value From Table(f_Str2list(诊室_In));
  
    If Nvl(分诊方式_In, 0) = 1 Then
      Update 临床出诊记录 Set 诊室id = To_Number(诊室_In) Where ID = Id_In;
    End If;
  End If;

  --出诊时段
  If Nvl(删除序号_In, 0) = 1 Then
    --删除现有序号时段
    Delete 临床出诊序号控制 Where 记录id = Id_In;
  End If;
  If 时段_In Is Not Null Then
    v_时段 := 时段_In || '|';
  End If;
  While v_时段 Is Not Null Loop
    v_当前序号 := Substr(v_时段, 1, Instr(v_时段, '|') - 1);
    n_序号     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_开始时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    d_终止时间 := To_Date(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1), 'yyyy-mm-dd hh24:mi:ss');
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_数量     := To_Number(Substr(v_当前序号, 1, Instr(v_当前序号, ',') - 1));
    v_当前序号 := Substr(v_当前序号, Instr(v_当前序号, ',') + 1);
    n_是否预约 := To_Number(v_当前序号);
    If Nvl(n_序号, 0) > 0 Then
      If Nvl(是否分时段_In, 0) = 1 And Nvl(是否序号控制_In, 0) = 1 Then
        --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
        Insert Into 临床出诊序号控制
          (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量, 预约顺序号)
        Values
          (Id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量, n_是否预约);
      Else
        Insert Into 临床出诊序号控制
          (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量)
        Values
          (Id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量);
      End If;
    End If;
    v_时段 := Substr(v_时段, Instr(v_时段, '|') + 1);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Insert;
/
Create Or Replace Procedure Zl_临床出诊挂号控制记录_Insert
(
  记录id_In   临床出诊挂号控制记录.记录id%Type,
  类型_In     临床出诊挂号控制记录.类型%Type,
  性质_In     临床出诊挂号控制记录.性质%Type,
  名称_In     临床出诊挂号控制记录.名称%Type,
  控制方式_In 临床出诊挂号控制记录.控制方式%Type,
  是否独占_In 临床出诊记录.是否独占%Type,
  安排控制_In Varchar2,
  删除_In     Number := 0
) As
  --功能:插入或更新临床出诊挂号控制记录
  --参数:
  --    类型_In:1-三方机构;2-预约方式
  --    安排控制_in:序号1,数量|序号2,数量|...
  --    删除_in:是否删除现有的
  v_序号     Varchar2(5000);
  v_当前项目 Varchar2(5000);
  n_序号     临床出诊挂号控制记录.序号%Type;
  n_数量     临床出诊挂号控制记录.数量%Type;
  n_Count    Number;

  Err_Item Exception;
  v_Err_Msg Varchar2(100);
Begin
  If Nvl(类型_In, 0) = 1 Then
    --合作单位
    Select Count(1) Into n_Count From 挂号合作单位 Where 名称 = 名称_In;
    If n_Count = 0 Then
      --合作单位已不存在
      If Nvl(删除_In, 0) = 1 Then
        --删除已有的
        Delete From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
      End If;
      Return;
    End If;
  Elsif Nvl(类型_In, 0) = 2 Then
    --预约方式
    Select Count(1) Into n_Count From 预约方式 Where 名称 = 名称_In;
    If n_Count = 0 Then
      --预约方式已不存在
      If Nvl(删除_In, 0) = 1 Then
        --删除已有的
        Delete From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
      End If;
      Return;
    End If;
  End If;

  Update 临床出诊记录 Set 是否独占 = 是否独占_In Where ID = 记录id_In;

  If Nvl(删除_In, 0) = 1 Then
    --删除已有的
    Delete From 临床出诊挂号控制记录 Where 记录id = 记录id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
  End If;

  v_序号 := 安排控制_In || '|';
  While v_序号 Is Not Null Loop
    v_当前项目 := Substr(v_序号, 1, Instr(v_序号, '|') - 1);
    n_序号     := To_Number(Substr(v_当前项目, 1, Instr(v_当前项目, ',') - 1));
    v_当前项目 := Substr(v_当前项目, Instr(v_当前项目, ',') + 1);
    n_数量     := To_Number(v_当前项目);
    If Nvl(n_数量, 0) <> 0 Then
      Insert Into 临床出诊挂号控制记录
        (记录id, 类型, 性质, 名称, 序号, 数量, 控制方式)
      Values
        (记录id_In, 类型_In, 性质_In, 名称_In, n_序号, n_数量, 控制方式_In);
    End If;
    v_序号 := Substr(v_序号, Instr(v_序号, '|') + 1);
  End Loop;

  --每一个合作单位或者预约方式至少得有一条记录
  Select Count(1)
  Into n_Count
  From 临床出诊挂号控制记录
  Where 记录id = 记录id_In And 类型 = 类型_In And 性质 = 性质_In And 名称 = 名称_In;
  If n_Count = 0 Then
    Insert Into 临床出诊挂号控制记录
      (记录id, 类型, 性质, 名称, 序号, 数量, 控制方式)
    Values
      (记录id_In, 类型_In, 性质_In, 名称_In, 0, 0, 控制方式_In);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊挂号控制记录_Insert;
/
Create Or Replace Procedure Zl_临床出诊诊室_Update
(
  Id_In       临床出诊限制.Id%Type,
  分诊方式_In 临床出诊限制.分诊方式%Type := Null,
  诊室_In     Varchar2 := Null,
  出诊记录_In Number := 0
) As
  --功能：更新临床出诊诊室
  --参数：
  --     诊室_In:诊室1,诊室2,...
  --     出诊记录_In:是否是对出诊记录进行删除
  n_Count  Number;
  n_变动id 临床出诊变动记录.Id%Type;
  v_诊室   临床出诊变动记录.现门诊诊室%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  If Nvl(出诊记录_In, 0) = 0 Then
    Update 临床出诊限制 Set 分诊方式 = 分诊方式_In Where ID = Id_In;
  
    Delete From 临床出诊诊室 Where 限制id = Id_In;
    --出诊诊室
    If 诊室_In Is Not Null Then
    
      Insert Into 临床出诊诊室
        (限制id, 诊室id)
        Select Id_In, Column_Value From Table(f_Str2list(诊室_In, ','));
    
      If Nvl(分诊方式_In, 0) = 1 Then
        Update 临床出诊限制 Set 诊室id = To_Number(诊室_In) Where ID = Id_In;
      End If;
    End If;
    Return;
  End If;

  --临床出诊变动信息
  Select Count(1)
  Into n_Count
  From 临床出诊表 A, 临床出诊安排 B, 临床出诊记录 C
  Where a.Id = b.出诊id And b.Id = c.安排id And a.发布人 Is Not Null And c.Id = Id_In;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '出诊记录不存在！';
    Raise Err_Item;
  End If;

  Select 临床出诊变动记录_Id.Nextval Into n_变动id From Dual;
  Insert Into 临床出诊变动记录
    (ID, 记录id, 变动类型, 原分诊方式, 原诊室id, 原门诊诊室, 现分诊方式, 操作员姓名, 登记时间)
    Select n_变动id, a.Id, 3, a.分诊方式, a.诊室id, b.名称, 分诊方式_In, Zl_Username, Sysdate
    From 临床出诊记录 A, 门诊诊室 B
    Where a.诊室id = b.Id(+) And a.Id = Id_In;

  Insert Into 临床出诊变动明细
    (变动id, 变动性质, 序号, 诊室id, 门诊诊室, 名称)
    Select n_变动id, 1, 序号, 诊室id, 名称, '-'
    From (Select Rownum As 序号, a.诊室id, b.名称
           From 临床出诊诊室记录 A, 门诊诊室 B
           Where a.诊室id = b.Id(+) And a.记录id = Id_In);

  --保存原始临床出诊记录
  Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = Id_In;
  If Nvl(n_Count, 0) = 0 Then
    For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                 From 临床出诊记录
                 Where ID = Id_In) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
    End Loop;
  End If;

  Update 临床出诊记录 Set 分诊方式 = 分诊方式_In Where ID = Id_In;
  Delete From 临床出诊诊室记录 Where 记录id = Id_In;

  --临床出诊变动后信息
  If 诊室_In Is Not Null Then
    Insert Into 临床出诊诊室记录
      (记录id, 诊室id)
      Select Id_In, Column_Value From Table(f_Str2list(诊室_In, ','));
  
    Insert Into 临床出诊变动明细
      (变动id, 变动性质, 序号, 诊室id, 门诊诊室, 名称)
      Select n_变动id, 2, Rownum, a.Id, a.名称, '-'
      From 门诊诊室 A, (Select Column_Value As 诊室id From Table(f_Str2list(诊室_In, ','))) B
      Where a.Id = b.诊室id;
  
    If Nvl(分诊方式_In, 0) = 1 Then
      Update 临床出诊记录 Set 诊室id = To_Number(诊室_In) Where ID = Id_In;
    
      Update 临床出诊变动记录
      Set 现诊室id = To_Number(诊室_In),
          现门诊诊室 =
           (Select 名称 From 门诊诊室 Where ID = To_Number(诊室_In))
      Where ID = n_变动id
      Returning 现门诊诊室 Into v_诊室;
      --病人挂号记录
      Update 病人挂号记录 Set 诊室 = v_诊室 Where 出诊记录id = Id_In;
      --门诊费用记录
      Update 门诊费用记录
      Set 发药窗口 = v_诊室
      Where 记录性质 = 4 And NO In (Select NO From 病人挂号记录 Where 出诊记录id = Id_In);
    End If;
  
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊诊室_Update;
/
Create Or Replace Procedure Zl_临床出诊记录_Batchlock
(
  Ids_In      Varchar2,
  取消锁定_In Number := 0
) As
  -- Ids_In 批量加锁或解锁，多个用逗号分隔
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;
Begin
  If Nvl(取消锁定_In, 0) = 1 Then
    Update 临床出诊记录 Set 是否锁定 = 0 Where ID In (Select Column_Value From Table(f_Str2list(Ids_In, ',')));
  Else
    Update 临床出诊记录 Set 是否锁定 = 1 Where ID In (Select Column_Value From Table(f_Str2list(Ids_In, ',')));
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Batchlock;
/

Create Or Replace Procedure Zl_临床出诊记录_Stopvisit
(
  记录id_In     临床出诊停诊记录.记录id%Type,
  开始时间_In   临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In   临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In   临床出诊停诊记录.停诊原因%Type := Null,
  操作员_In     临床出诊停诊记录.申请人%Type := Null,
  操作时间_In   临床出诊停诊记录.申请时间%Type := Null,
  取消停诊_In   Number := 0,
  是否不检查_In Number := 0
) As
  --功能：停诊或者取消停诊
  --入参：
  --       是否不检查_in 主要用于停用/启用号源时使用
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count Number;
  d_Cur   Date;

  v_号码 临床出诊号源.号码%Type;
Begin
  If Nvl(取消停诊_In, 0) = 0 Then
    --停诊
    If Nvl(是否不检查_In, 0) = 0 Then
      Select Count(1) Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 停诊开始时间 Is Not Null;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前安排已被他人进行了停诊，请刷新数据后查看！';
        Raise Err_Item;
      End If;
    
      If 开始时间_In <= Sysdate Then
        v_Err_Msg := '停诊时间的开始时间小于了当前时间，不能进行停诊操作！';
        Raise Err_Item;
      End If;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, 记录id_In, 开始时间_In, 终止时间_In, 停诊原因_In, Nvl(a.医生姓名, 操作员_In), 操作时间_In, 操作员_In, 操作时间_In,
             操作员_In
      From 临床出诊记录 A
      Where ID = 记录id_In;
  
    --保存原始临床出诊记录
    Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = 记录id_In;
    If Nvl(n_Count, 0) = 0 Then
      For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                   From 临床出诊记录
                   Where ID = 记录id_In) Loop
        Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
      End Loop;
    End If;
  
    Update 临床出诊记录
    Set 停诊开始时间 = 开始时间_In, 停诊终止时间 = 终止时间_In, 停诊原因 = 停诊原因_In
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  
    Insert Into 病人服务信息记录
      (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间, 通知原因)
      Select 病人服务信息记录_Id.Nextval, 1, 记录id_In, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 操作员_In, 操作时间_In,
             '医生' || 停诊原因_In || '，已停诊'
      From (Select b.Id As 挂号id, c.Id As 号源id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id
             From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
             Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = 记录id_In And
                   (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
                   b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间));
  
    --消息推送
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 1 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  Else
    --取消停诊
    --数据检查
    Select Count(1) Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 停诊开始时间 Is Null;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(是否不检查_In, 0) = 1 Then
        Return;
      End If;
      v_Err_Msg := '当前安排已被他人取消停诊，请刷新数据后查看！';
      Raise Err_Item;
    End If;
  
    If Nvl(是否不检查_In, 0) = 0 Then
      Select 停诊终止时间 Into d_Cur From 临床出诊记录 Where ID = 记录id_In And 停诊开始时间 Is Not Null;
      If d_Cur <= Sysdate Then
        v_Err_Msg := '停诊时间的终止时间小于了当前时间，不能进行取消停诊操作！';
        Raise Err_Item;
      End If;
      Select Count(1)
      Into n_Count
      From 病人服务信息记录
      Where 记录id = 记录id_In And 通知类型 = 1 And 处理人 Is Not Null;
      If n_Count <> 0 Then
        v_Err_Msg := '该出诊记录存在病人服务信息记录，且已被处理，不允许取消停诊操作！';
        Raise Err_Item;
      End If;
    End If;
  
    With 出诊记录 As
     (Select a.开始时间, a.终止时间, a.停诊开始时间, a.停诊终止时间
      From 临床出诊记录 A, 临床出诊记录 B
      Where a.号源id = b.号源id And a.出诊日期 = b.出诊日期 And b.Id = 记录id_In And a.Id <> b.Id),
    有效时间段 As
     (Select 开始时间, 停诊开始时间 As 终止时间
      From 出诊记录
      Where 开始时间 < 停诊开始时间 And 终止时间 = 停诊终止时间
      Union All
      Select 停诊终止时间 As 开始时间, 终止时间
      From 出诊记录
      Where 开始时间 = 停诊开始时间 And 终止时间 > 停诊终止时间
      Union All
      Select 开始时间, 停诊开始时间 As 终止时间
      From 出诊记录
      Where 开始时间 < 停诊开始时间 And 终止时间 > 停诊终止时间
      Union All
      Select 停诊终止时间 As 开始时间, 终止时间 From 出诊记录 Where 开始时间 < 停诊开始时间 And 终止时间 > 停诊终止时间)
    Select Count(1)
    Into n_Count
    From 有效时间段 M, 临床出诊记录 N
    Where m.开始时间 < n.终止时间 And m.终止时间 > n.开始时间 And n.Id = 记录id_In And Rownum < 2;
    If n_Count <> 0 Then
      If Nvl(是否不检查_In, 0) = 1 Then
        Return;
      End If;
      v_Err_Msg := '当前上班时段的时间范围与该号源今日目前有效的上班时段的时间范围有交叉，你不能取消停诊！';
      Raise Err_Item;
    End If;
  
    Update 临床出诊停诊记录
    Set 取消人 = 操作员_In, 取消时间 = 操作时间_In
    Where 记录id = 记录id_In And 替诊医生姓名 Is Null And 取消人 Is Null;
  
    Update 临床出诊记录
    Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null
    Where ID = 记录id_In And 停诊开始时间 Is Not Null;
  
    --调整"临床出诊序号控制.是否停诊"为0
    Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = 记录id_In And Nvl(是否停诊, 0) = 1;
  
    Delete 病人服务信息记录 Where 记录id = 记录id_In And 通知类型 = 1 And 处理人 Is Null;
  
    --消息推送
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Stopvisit;
/

Create Or Replace Function Zl1_Ex_Isdoctorsamelevel
(
  甲医生id_In   In 人员表.Id%Type,
  甲医生姓名_In In 人员表.姓名%Type,
  乙医生id_In   In 人员表.Id%Type,
  乙医生姓名_In In 人员表.姓名%Type
) Return Number
--功能说明：比较两个医生的职务大小。
  --适用说明：挂号安排替诊时调用，检查替诊医生的职务是否大于等于原医生职务。
  --入参说明：
  --     甲医生ID：人员ID,院外医生传入NULL
  --     甲医生姓名：人员姓名
  --     乙医生ID：人员ID,院外医生传入NULL
  --     乙医生姓名：人员姓名
  --函数返回：
  --     -1 - 甲医生的职务大于乙医生的职务
  --     0 - 甲医生的职务等于乙医生的职务
  --     1 - 甲医生的职务小于乙医生的职务
  --说明：根据“专业技术职务”来判断,编码小的表示职务越大,没有设置专业技术职务的医生表示职务最低
 Is
  n_a Number;
  n_b Number;
Begin
  If Nvl(甲医生id_In, 0) = 0 Then
    --院外医生
    n_a := -1;
  Else
    Begin
      Select To_Number(Nvl(b.编码, -1))
      Into n_a
      From 人员表 A, 专业技术职务 B
      Where a.专业技术职务 = b.名称(+) And a.Id = 甲医生id_In;
    Exception
      When Others Then
        n_a := -1;
    End;
  End If;
  If Nvl(乙医生id_In, 0) = 0 Then
    --院外医生
    n_b := -1;
  Else
    Begin
      Select To_Number(Nvl(b.编码, -1))
      Into n_b
      From 人员表 A, 专业技术职务 B
      Where a.专业技术职务 = b.名称(+) And a.Id = 乙医生id_In;
    Exception
      When Others Then
        n_b := -1;
    End;
  End If;

  If n_a = -1 And n_b = -1 Then
    Return 0;
  Elsif n_a = -1 Then
    Return 1;
  Elsif n_b = -1 Then
    Return - 1;
  Else
    If n_a = n_b Then
      Return 0;
    Elsif n_a > n_b Then
      Return 1;
    Else
      Return - 1;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Ex_Isdoctorsamelevel;
/

Create Or Replace Procedure Zl_临床出诊记录_Replacedoctor
(
  记录id_In       临床出诊停诊记录.记录id%Type,
  开始时间_In     临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In     临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In     临床出诊停诊记录.停诊原因%Type := Null,
  替诊医生id_In   临床出诊停诊记录.替诊医生id%Type := Null,
  替诊医生姓名_In 临床出诊停诊记录.替诊医生姓名%Type := Null,
  操作员姓名_In   临床出诊停诊记录.申请人%Type := Null,
  操作员编号_In   人员表.编号%Type := Null,
  操作时间_In     临床出诊停诊记录.申请时间%Type := Null,
  取消替诊_In     Number := 0
) As
  --功能：替诊或者取消替诊
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count        Number;
  d_Cur          Date;
  n_Updatedoctor Number(2);
  v_号码         临床出诊号源.号码%Type;
Begin
  If Nvl(取消替诊_In, 0) = 0 Then
    --替诊
    Begin
      Select 1 Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 停诊开始时间 Is Not Null;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) <> 0 Then
      v_Err_Msg := '当前出诊记录已被停诊，不允许替诊！';
      Raise Err_Item;
    End If;
  
    Begin
      Select 1 Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 替诊开始时间 Is Not Null;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) <> 0 Then
      v_Err_Msg := '当前安排已被他人进行了替诊，请刷新数据后查看！';
      Raise Err_Item;
    End If;
  
    If 开始时间_In <= Sysdate Then
      v_Err_Msg := '替诊时间的开始时间小于了当前时间，不能进行替诊操作！';
      Raise Err_Item;
    End If;
  
    If Nvl(替诊医生id_In, 0) <> 0 Then
      Begin
        Select 1
        Into n_Count
        From 临床出诊记录 A
        Where ID = 记录id_In And Nvl(医生id, 替诊医生id) = 替诊医生id_In And Rownum < 2;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '替诊医生不能为原安排医生，请选择其它医生！';
        Raise Err_Item;
      End If;
    End If;
  
    --在该时段内，替诊医生不能存在其他的出诊安排
    --若A[A1,A2],B[B1,B2],且B为空或完全包含于A中(A1<=B1,A2>=B2).那么X[X1,X2]与A-B有交集，则
    --(X1>=A1 And X1<=NVL(B1,A2)) Or (X2>=A1 And X2<=NVL(B1,A2)) Or (X1>=NVL(B2,A1) And X1<=A2) Or (X2>=NVL(B2,A1) And X2<=A2)
    If Nvl(替诊医生id_In, 0) = 0 Then
      Select Count(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊记录 B
      Where a.出诊日期 = b.出诊日期 And Nvl(a.替诊医生姓名, a.医生姓名) = 替诊医生姓名_In And Nvl(a.替诊医生id, a.医生id) Is Null And b.Id = 记录id_In And
            ((开始时间_In Between a.开始时间 And Nvl(a.停诊开始时间, a.终止时间)) Or (终止时间_In Between a.开始时间 And Nvl(a.停诊开始时间, a.终止时间)) Or
            (开始时间_In Between Nvl(a.停诊终止时间, a.开始时间) And a.终止时间) Or (终止时间_In Between Nvl(a.停诊终止时间, a.开始时间) And a.终止时间)) And
            开始时间_In < Nvl(a.替诊终止时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            终止时间_In > Nvl(a.替诊开始时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    Else
      Select Count(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊记录 B
      Where a.出诊日期 = b.出诊日期 And Nvl(a.替诊医生id, a.医生id) = 替诊医生id_In And b.Id = 记录id_In And
            ((开始时间_In Between a.开始时间 And Nvl(a.停诊开始时间, a.终止时间)) Or (终止时间_In Between a.开始时间 And Nvl(a.停诊开始时间, a.终止时间)) Or
            (开始时间_In Between Nvl(a.停诊终止时间, a.开始时间) And a.终止时间) Or (终止时间_In Between Nvl(a.停诊终止时间, a.开始时间) And a.终止时间)) And
            开始时间_In < Nvl(a.替诊终止时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            终止时间_In > Nvl(a.替诊开始时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    End If;
    If n_Count <> 0 Then
      v_Err_Msg := '替诊医生在替诊时间范围内已存在其它出诊安排，请选择其它医生！';
      Raise Err_Item;
    End If;
    --医生级别检查
    n_Updatedoctor := To_Number(Nvl(zl_GetSysParameter('替诊医生级别检查', 1114), '1'));
    If Nvl(n_Updatedoctor, 0) = 1 Then
      Select Zl1_Ex_Isdoctorsamelevel(a.医生id, a.医生姓名, 替诊医生id_In, 替诊医生姓名_In)
      Into n_Count
      From 临床出诊记录 A
      Where ID = 记录id_In;
      If n_Count = -1 Then
        v_Err_Msg := '替诊医生的级别小于了原出诊医生的级别，不允许替诊，请选择其它医生！';
        Raise Err_Item;
      End If;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 替诊医生id, 替诊医生姓名, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, 记录id_In, 开始时间_In, 终止时间_In, 停诊原因_In, 替诊医生id_In, 替诊医生姓名_In, Nvl(a.医生姓名, 操作员姓名_In),
             操作时间_In, 操作员姓名_In, 操作时间_In, 操作员姓名_In
      From 临床出诊记录 A
      Where ID = 记录id_In;
  
    --保存原始临床出诊记录
    Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = 记录id_In;
    If Nvl(n_Count, 0) = 0 Then
      For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                   From 临床出诊记录
                   Where ID = 记录id_In) Loop
        Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
      End Loop;
    End If;
  
    Update 临床出诊记录
    Set 停诊原因 = 停诊原因_In, 替诊开始时间 = 开始时间_In, 替诊终止时间 = 终止时间_In, 替诊医生id = 替诊医生id_In, 替诊医生姓名 = 替诊医生姓名_In
    Where ID = 记录id_In;
  
    Insert Into 病人服务信息记录
      (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间, 通知原因)
      Select 病人服务信息记录_Id.Nextval, 2, 记录id_In, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 操作员姓名_In, 操作时间_In,
             '医生' || 停诊原因_In || '，已替诊'
      From (Select b.Id As 挂号id, c.Id As 号源id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id
             From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
             Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And Nvl(b.执行状态, 0) = 0 And a.Id = 记录id_In And
                   (b.记录性质 = 1 And b.发生时间 Between a.替诊开始时间 And a.替诊终止时间 Or
                   b.记录性质 = 2 And b.预约时间 Between a.替诊开始时间 And a.替诊终止时间));
  
    --消息推送
    -- 替诊类型(1-替诊,2-取消替诊),出诊记录ID,替诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 18, 1 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  
    --按替诊医生同步更新预约挂号单
    n_Updatedoctor := To_Number(Nvl(zl_GetSysParameter('按替诊医生同步更新预约挂号单', 1114), '0'));
    If Nvl(n_Updatedoctor, 0) = 1 Then
      For c_记录 In (Select a.Id, b.No
                   From 病人服务信息记录 A, 病人挂号记录 B
                   Where a.挂号id = b.Id And a.记录id = 记录id_In And a.通知类型 = 2 And b.记录性质 In (1, 2) And b.记录状态 = 1) Loop
        Zl_患者服务中心_替诊(c_记录.Id, c_记录.No, '按替诊医生同步更新预约挂号单', 操作员姓名_In, 操作员编号_In);
      End Loop;
    End If;
  Else
    --数据检查
    Begin
      Select 1 Into n_Count From 临床出诊记录 A Where ID = 记录id_In And 替诊开始时间 Is Null;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) <> 0 Then
      v_Err_Msg := '当前安排已被他人取消替诊，请刷新数据后查看！';
      Raise Err_Item;
    End If;
  
    Select 终止时间
    Into d_Cur
    From 临床出诊记录
    Where ID = 记录id_In And 替诊医生姓名 Is Not Null And 停诊开始时间 Is Null;
    If d_Cur <= Sysdate Then
      v_Err_Msg := '终止时间已小于了当前时间，不能进行取消替诊操作！';
      Raise Err_Item;
    End If;
    Select Count(1)
    Into n_Count
    From 病人服务信息记录
    Where 记录id = 记录id_In And 通知类型 = 2 And 处理人 Is Not Null;
    If n_Count <> 0 Then
      v_Err_Msg := '该出诊记录存在病人服务信息记录，且已被处理，不允许取消替诊操作！';
      Raise Err_Item;
    End If;
  
    Update 临床出诊停诊记录
    Set 取消人 = 操作员姓名_In, 取消时间 = 操作时间_In
    Where 记录id = 记录id_In And 替诊医生姓名 Is Not Null And 取消人 Is Null;
  
    Update 临床出诊记录
    Set 停诊原因 = Null, 替诊开始时间 = Null, 替诊终止时间 = Null, 替诊医生id = Null, 替诊医生姓名 = Null
    Where ID = 记录id_In And 替诊医生姓名 Is Not Null And 停诊开始时间 Is Null;
  
    Delete 病人服务信息记录 Where 记录id = 记录id_In And 通知类型 = 2 And 处理人 Is Null;
  
    --消息推送
    -- 替诊类型(1-替诊,2-取消替诊),出诊记录ID,替诊号码
    Begin
      Select b.号码 Into v_号码 From 临床出诊记录 A, 临床出诊号源 B Where a.号源id = b.Id And a.Id = 记录id_In;
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 18, 2 || ',' || 记录id_In || ',' || v_号码;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊记录_Replacedoctor;
/
Create Or Replace Procedure Zl_临床出诊停诊_Apply
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  开始时间_In 临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In 临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In 临床出诊停诊记录.停诊原因%Type := Null,
  申请人_In   临床出诊停诊记录.申请人%Type := Null,
  申请时间_In 临床出诊停诊记录.申请时间%Type := Null,
  登记人_In   临床出诊停诊记录.登记人%Type := Null
) As
  --功能：退费申请以及取消申请
  --参数：
  --        操作类型_In：0-申请，else-取消申请
  --说明：
  n_Id    临床出诊停诊记录.Id%Type;
  n_Count Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 操作类型_In = 0 Then
    --申请
    Begin
      Select 1
      Into n_Count
      From 临床出诊停诊记录
      Where 记录id Is Null And Not (开始时间 > 终止时间_In Or 终止时间 < 开始时间_In) And 申请人 = 申请人_In And Rownum < 2;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If Nvl(n_Count, 0) > 0 Then
      v_Error := '医生 ' || 申请人_In || ' 在当前停诊时间范围内已存在停诊安排，不能重复申请！';
      Raise Err_Custom;
    End If;
  
    If Nvl(Id_In, 0) = 0 Then
      Select 临床出诊停诊记录_Id.Nextval Into n_Id From Dual;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 登记人)
    Values
      (n_Id, 开始时间_In, 终止时间_In, 停诊原因_In, 申请人_In, 申请时间_In, 登记人_In);
  Else
    --取消申请
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被取消申请，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    --审核通过，不允许取消申请
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And (审批人 Is Null Or 取消人 Is Not Null);
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被审核，不能取消申请。';
      Raise Err_Custom;
    End If;
  
    Delete 临床出诊停诊记录 Where ID = Id_In;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Apply;
/
Create Or Replace Procedure Zl_临床出诊停诊_Audit
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  审批人_In   临床出诊停诊记录.审批人%Type := Null,
  审批时间_In 临床出诊停诊记录.审批时间%Type := Null
) As
  --功能：审核停诊安排
  --参数：
  --       状态_In：1-审核，2-取消审核
  n_Count Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(操作类型_In, 0) = 1 Then
    --审核
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被取消申请，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Null;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '该申请已被审核，不能再次审核！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = 审批人_In, 审批时间 = 审批时间_In Where ID = Id_In;
  
    --对出诊记录进行停诊标记
    For c_记录 In (Select a.Id,
                        Case
                          When a.开始时间 < b.开始时间 Then
                           b.开始时间
                          Else
                           a.开始时间
                        End As 停诊开始时间,
                        Case
                          When a.终止时间 > b.终止时间 Then
                           b.终止时间
                          Else
                           a.终止时间
                        End As 停诊终止时间, b.停诊原因, c.号码
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And Not (a.开始时间 > b.终止时间 Or a.终止时间 < b.开始时间)
                      --只处理已发布了的
                       And Exists (Select 1
                        From 临床出诊安排 C, 临床出诊表 D
                        Where c.出诊id = d.Id And c.Id = a.安排id And d.发布时间 Is Not Null)) Loop
    
      Update 临床出诊记录
      Set 停诊开始时间 = c_记录.停诊开始时间, 停诊终止时间 = c_记录.停诊终止时间, 停诊原因 = c_记录.停诊原因
      Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为1
      Update 临床出诊序号控制 A
      Set 是否停诊 = 1
      Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间 And Exists
       (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
    
      Insert Into 病人服务信息记录
        (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间)
        Select 病人服务信息记录_Id.Nextval, 1, a.Id, b.Id, c.Id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id, 审批人_In, 审批时间_In
        From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
        Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = c_记录.Id And
              (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
              b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间);
    
      --消息推送
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 1 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
  Else
    --取消审核
    Select Count(1)
    Into n_Count
    From 临床出诊停诊记录
    Where ID = Id_In And 审批人 Is Not Null And 取消人 Is Null And 记录id Is Not Null;
    If Nvl(n_Count, 0) <> 0 Then
      v_Error := '当前停诊记录是对出诊记录进行停诊产生的，不能取消审批，只能通过选择出诊记录做取消停诊处理！';
      Raise Err_Custom;
    End If;
  
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null And 取消人 Is Null;
    If Nvl(n_Count, 0) = 0 Then
      v_Error := '原审核记录未找到，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into n_Count
    From 病人服务信息记录
    Where 记录id In (Select a.Id
                   From 临床出诊记录 A, 临床出诊停诊记录 B
                   Where Nvl(a.替诊医生姓名, a.医生姓名) = b.申请人 And b.Id = Id_In And
                         (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间)) And 处理人 Is Not Null;
    If Nvl(n_Count, 0) <> 0 Then
      v_Error := '该停诊安排的部分停诊信息已被处理，不能取消审批！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = Null, 审批时间 = Null Where ID = Id_In;
  
    For c_记录 In (Select a.Id, c.号码
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                       Exists (Select 1
                        From 临床出诊安排 C, 临床出诊表 D
                        Where c.出诊id = d.Id And c.Id = a.安排id And d.发布时间 Is Not Null)) Loop
    
      Update 临床出诊记录 Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为0
      Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1;
    
      Delete 病人服务信息记录 Where 记录id = c_记录.Id And 通知类型 = 1 And 处理人 Is Null;
    
      --消息推送
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Audit;
/

Create Or Replace Procedure Zl_临床出诊预约控制变动
(
  变动性质_In   临床出诊变动明细.变动性质%Type,
  Id_In         临床出诊变动记录.Id%Type,
  记录id_In     临床出诊变动记录.记录id%Type,
  现预约控制_In 临床出诊变动记录.现预约控制%Type := Null
) As
  --功能:修改预约控制时，插入临床出诊变动记录/明细
  --参数:
  --     变动性质_In  1-变动前;2-变动后
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  n_Count Number(8);
Begin
  If Nvl(变动性质_In, 0) = 1 Then
    --变动前
    --保存原始临床出诊记录
    Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = 记录id_In;
    If Nvl(n_Count, 0) = 0 Then
      For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                   From 临床出诊记录
                   Where ID = 记录id_In) Loop
        Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
      End Loop;
    End If;
  
    Insert Into 临床出诊变动记录
      (ID, 记录id, 变动类型, 原预约控制, 现预约控制, 操作员姓名, 登记时间)
      Select Id_In, 记录id_In, 4, 预约控制, Nvl(现预约控制_In, 预约控制), Zl_Username, Sysdate
      From 临床出诊记录
      Where ID = 记录id_In;
  
    Insert Into 临床出诊变动明细
      (变动id, 变动性质, 类型, 名称, 序号, 控制方式, 数量)
      Select Id_In, 1, 类型, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制记录 Where 记录id = 记录id_In;
  Else
    --变动后
    Insert Into 临床出诊变动明细
      (变动id, 变动性质, 类型, 名称, 序号, 控制方式, 数量)
      Select Id_In, 2, 类型, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制记录 Where 记录id = 记录id_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊预约控制变动;
/

Create Or Replace Procedure Zl_临床出诊序号控制变动
(
  记录id_In     临床出诊变动记录.记录id%Type,
  限号数_In     临床出诊记录.限号数%Type,
  限约数_In     临床出诊记录.限约数%Type,
  原已挂数_In   临床出诊记录.已挂数%Type,
  原已约数_In   临床出诊记录.已约数%Type,
  操作员姓名_In 临床出诊变动记录.操作员姓名%Type := Null,
  登记时间_In   临床出诊变动记录.登记时间%Type := Null
) As
  --功能:修改临床出诊序号控制时，插入临床出诊变动记录/明细
  --参数:
  --     原已挂数_In、原已约数_In:在进行加号/减号操作前的预约挂号情况，用于并发检查
  n_原限号数 临床出诊记录.限号数%Type;
  n_原限约数 临床出诊记录.限约数%Type;
  n_已挂数   临床出诊记录.已挂数%Type;
  n_已约数   临床出诊记录.已约数%Type;

  v_操作员姓名 临床出诊变动记录.操作员姓名%Type := Null;
  d_登记时间   临床出诊变动记录.登记时间%Type := Null;

  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  n_Count Number(8);
Begin
  Begin
    Select 限号数, 限约数, 已挂数, 已约数
    Into n_原限号数, n_原限约数, n_已挂数, n_已约数
    From 临床出诊记录
    Where ID = 记录id_In;
  Exception
    When Others Then
      v_Err_Msg := '未发现出诊记录！';
      Raise Err_Item;
  End;

  --并发检查
  If Nvl(原已挂数_In, 0) = 0 And Nvl(原已约数_In, 0) = 0 Then
    --在操作前无预约挂号
    If Nvl(n_已挂数, 0) > 0 Or Nvl(n_已约数, 0) > 0 Then
      --在操作过程中新产生了预约挂号
      v_Err_Msg := '该出诊安排在当前操作过程中有了新的挂号或预约，保存失败，请退出后重新操作！';
      Raise Err_Item;
    End If;
  Else
    --在操作前有预约挂号，只有减号才会有影响，其它对之后的都无影响
    If Nvl(n_原限号数, 0) > Nvl(限号数_In, 0) Then
      --减限号数
      If Nvl(n_已挂数, 0) > Nvl(原已挂数_In, 0) Or Nvl(n_已约数, 0) > Nvl(原已约数_In, 0) Then
        --在操作过程中新产生了预约挂号
        v_Err_Msg := '该出诊安排在当前操作过程中有了新的挂号或预约，保存失败，请退出后重新操作！';
        Raise Err_Item;
      End If;
    Elsif Nvl(n_原限约数, 0) > Nvl(限约数_In, 0) Then
      If Nvl(n_已约数, 0) > Nvl(原已约数_In, 0) Then
        --在操作过程中新产生了预约挂号
        v_Err_Msg := '该出诊安排在当前操作过程中有了新的预约，保存失败，请退出后重新操作！';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --保存原始临床出诊记录
  Select Count(1) Into n_Count From 临床出诊记录 Where 相关id = 记录id_In;
  If Nvl(n_Count, 0) = 0 Then
    For c_记录 In (Select ID, 安排id, To_Date('1900-01-01', 'yyyy-mm-dd') As 出诊日期, 登记人, 登记时间, 是否发布
                 From 临床出诊记录
                 Where ID = 记录id_In) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_记录.安排id, c_记录.出诊日期, c_记录.登记人, c_记录.登记时间, c_记录.是否发布, c_记录.Id);
    End Loop;
  End If;

  --调整限约，限号数，且限约数为零表示禁止预约
  Update 临床出诊记录
  Set 限约数 = 限约数_In, 限号数 = 限号数_In, 预约控制 = Decode(Nvl(限约数_In, 0), 0, 1, 预约控制)
  Where ID = 记录id_In;

  v_操作员姓名 := Nvl(操作员姓名_In, Zl_Username);
  d_登记时间   := Nvl(登记时间_In, Sysdate);
  If Nvl(n_原限号数, 0) <> Nvl(限号数_In, 0) Then
    Insert Into 临床出诊变动记录
      (ID, 记录id, 变动类型, 原数量, 现数量, 操作员姓名, 登记时间)
    Values
      (临床出诊变动记录_Id.Nextval, 记录id_In, 1, n_原限号数, 限号数_In, v_操作员姓名, d_登记时间);
  End If;
  If Nvl(n_原限约数, 0) <> Nvl(限约数_In, 0) Then
    Insert Into 临床出诊变动记录
      (ID, 记录id, 变动类型, 原数量, 现数量, 操作员姓名, 登记时间)
    Values
      (临床出诊变动记录_Id.Nextval, 记录id_In, 2, n_原限约数, 限约数_In, v_操作员姓名, d_登记时间);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊序号控制变动;
/
Create Or Replace Procedure Zl_临床出诊序号控制_Update
(
  记录id_In   临床出诊记录.Id%Type,
  时段_In     Varchar2 := Null,
  删除序号_In Number := 0
) As
  --功能：更新临床出诊序号
  --参数：
  --     时段_In:序号,开始时间,终止时间,限制数量,预约标志|...
  --     删除序号_In:是否删除现有序号时段
  n_序号     临床出诊序号控制.序号%Type;
  d_开始时间 临床出诊序号控制.开始时间%Type;
  d_终止时间 临床出诊序号控制.终止时间%Type;
  n_数量     临床出诊序号控制.数量%Type;
  n_是否预约 临床出诊序号控制.是否预约%Type;

  n_是否分时段   临床出诊记录.是否分时段%Type;
  n_是否序号控制 临床出诊记录.是否序号控制%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  Begin
    Select 是否分时段, 是否序号控制 Into n_是否分时段, n_是否序号控制 From 临床出诊记录 Where ID = 记录id_In;
  Exception
    When Others Then
      Null;
  End;

  If Nvl(删除序号_In, 0) = 1 Then
    --删除挂号状态为0(待挂或待预约的号)的序号
    Delete 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
  End If;

  If 时段_In Is Not Null Then
    For c_时段集 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(时段_In, '|'))) Loop
      --序号,开始时间,终止时间,限制数量,预约标志
      For c_时段 In (Select Rownum As 序号, Column_Value As 值 From Table(f_Str2list(c_时段集.值))) Loop
        If c_时段.序号 = 1 Then
          n_序号 := To_Number(c_时段.值);
        End If;
      
        If c_时段.序号 = 2 Then
          d_开始时间 := To_Date(c_时段.值, 'yyyy-mm-dd hh24:mi:ss');
        End If;
      
        If c_时段.序号 = 3 Then
          d_终止时间 := To_Date(c_时段.值, 'yyyy-mm-dd hh24:mi:ss');
        End If;
      
        If c_时段.序号 = 4 Then
          n_数量 := To_Number(c_时段.值);
        End If;
      
        If c_时段.序号 = 5 Then
          n_是否预约 := To_Number(c_时段.值);
        End If;
      End Loop;
    
      If Nvl(n_序号, 0) <> 0 Then
        If Nvl(n_是否分时段, 0) = 1 And Nvl(n_是否序号控制, 0) = 1 Then
          --分时段且启用序号控制，使用"预约顺序号"记录"是否预约"
          Update 临床出诊序号控制
          Set 开始时间 = d_开始时间, 终止时间 = d_终止时间, 是否预约 = n_是否预约, 数量 = n_数量, 预约顺序号 = n_是否预约
          Where 记录id = 记录id_In And 序号 = n_序号;
          If Sql%NotFound Then
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量, 预约顺序号)
            Values
              (记录id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量, n_是否预约);
          End If;
        Else
          Update 临床出诊序号控制
          Set 开始时间 = d_开始时间, 终止时间 = d_终止时间, 是否预约 = n_是否预约, 数量 = n_数量
          Where 记录id = 记录id_In And 序号 = n_序号;
          If Sql%NotFound Then
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 是否预约, 数量)
            Values
              (记录id_In, n_序号, d_开始时间, d_终止时间, n_是否预约, n_数量);
          End If;
        End If;
      End If;
    End Loop;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊序号控制_Update;
/

Create Or Replace Procedure Zl_就诊变动记录_Insert
(
  挂号单号_In   In 病人挂号记录.No%Type,
  操作类别_In   In 就诊变动记录.类别%Type,
  变动原因_In   In 就诊变动记录.变动原因%Type,
  操作员姓名_In In 就诊变动记录.操作员姓名%Type,
  操作员编号_In In 就诊变动记录.操作员编号%Type,
  号码_In       In 就诊变动记录.现号码%Type := Null,
  科室id_In     In 就诊变动记录.现科室id%Type := Null,
  项目id_In     In 就诊变动记录.现项目id%Type := Null,
  医生id_In     In 就诊变动记录.现医生id%Type := Null,
  医生姓名_In   In 就诊变动记录.现医生姓名%Type := Null,
  诊室_In       In 就诊变动记录.现诊室%Type := Null,
  号序_In       In 就诊变动记录.现号序%Type := Null,
  预约时间_In   In 就诊变动记录.现预约时间%Type := Null,
  变动id_In     In 就诊变动记录.Id%Type := Null
) Is
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_变动id 就诊变动记录.Id%Type;
  -----------------------------------------------------------
  --说明：挂号换号前调用，记录换号变动，号码_IN以后的值若不传则代表无变动
  --      操作类别_IN = 1-批量换号;2-分诊换号;3-强制续诊换号
  -----------------------------------------------------------
Begin
  If 变动id_In Is Null Then
    Select 就诊变动记录_Id.Nextval Into n_变动id From Dual;
  Else
    n_变动id := 变动id_In;
  End If;
  Insert Into 就诊变动记录
    (ID, 类别, 挂号单, 病人id, 变动原因, 原号码, 现号码, 原科室id, 现科室id, 原项目id, 现项目id, 原医生id, 现医生id, 原医生姓名, 现医生姓名, 原诊室, 现诊室, 原号序, 现号序,
     原预约时间, 现预约时间, 登记时间, 操作员姓名, 操作员编号)
    Select n_变动id, 操作类别_In, 挂号单号_In, a.病人id, 变动原因_In, a.号别, Nvl(号码_In, a.号别), a.执行部门id, Nvl(科室id_In, a.执行部门id), b.收费细目id,
           Nvl(项目id_In, b.收费细目id), c.Id, 医生id_In, a.执行人, 医生姓名_In, a.诊室, 诊室_In, a.号序, Nvl(号序_In, a.号序), a.预约时间,
           Nvl(预约时间_In, a.预约时间), Sysdate, 操作员姓名_In, 操作员编号_In
    From 病人挂号记录 A, 门诊费用记录 B, 人员表 C
    Where a.No = 挂号单号_In And a.记录状态 = 1 And a.执行人 = c.姓名(+) And b.No = a.No And b.记录性质 = 4 And b.序号 = 1 And Rownum < 2;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_就诊变动记录_Insert;
/

Create Or Replace Procedure Zl_患者服务中心_替诊
(
  消息id_In     病人服务信息记录.Id%Type,
  No_In         病人挂号记录.No%Type,
  处理说明_In   病人服务信息记录.处理说明%Type,
  操作员姓名_In 病人服务信息记录.处理人%Type,
  操作员编号_In 病人挂号记录.操作员编号%Type
) As
  v_原执行人   病人挂号记录.执行人%Type;
  v_执行人     病人挂号记录.执行人%Type;
  n_原执行人id 临床出诊记录.医生id%Type;
  n_执行人id   临床出诊记录.替诊医生id%Type;
  d_出诊日期   临床出诊记录.出诊日期%Type;
  n_换诊序号   病人挂号记录.号序%Type;
  n_项目id     临床出诊记录.项目id%Type;
  n_科室id     临床出诊号源.科室id%Type;
  n_挂号状态   Number(3); --1=挂号,2=预约未收款,3=预约已收款
  v_号码       临床出诊号源.号码%Type;
  n_变动id     就诊变动记录.Id%Type;
  n_病人id     病人信息.病人id%Type;	
  v_Err_Msg    Varchar2(500);
  Err_Item Exception;
Begin
  --获取替诊医生
  Select b.替诊医生姓名, b.医生姓名, b.医生id, b.替诊医生id, 出诊日期, b.项目id, c.科室id, c.号码, a.病人id
  Into v_执行人, v_原执行人, n_原执行人id, n_执行人id, d_出诊日期, n_项目id, n_科室id, v_号码, n_病人id
  From 病人服务信息记录 A, 临床出诊记录 B, 临床出诊号源 C
  Where a.Id = 消息id_In And a.记录id = b.Id And b.号源id = c.Id;

  Select Decode(Nvl(预约, 0), 0, 1, Decode(接收时间, Null, 2, 3)), 号序
  Into n_挂号状态, n_换诊序号
  From 病人挂号记录
  Where NO = No_In And 记录状态 = 1;

  --就诊变动记录
  Select 就诊变动记录_Id.Nextval Into n_变动id From Dual;
  Zl_就诊变动记录_Insert(No_In, 5, '患者服务中心替诊', 操作员姓名_In, 操作员编号_In, v_号码, n_科室id, n_项目id, n_执行人id, v_执行人, Null, n_换诊序号,
                   Sysdate, n_变动id);

  --更新病人挂号记录
  Update 病人挂号记录 Set 执行人 = v_执行人 Where NO = No_In And 记录状态 = 1;
  --更新门诊费用记录
  Update 门诊费用记录 Set 执行人 = v_执行人 Where NO = No_In And 记录性质 = 4;
  --更新患者服务记录
  Update 病人服务信息记录 Set 处理人 = 操作员姓名_In, 处理时间 = Sysdate, 处理说明 = 处理说明_In Where ID = 消息id_In;
  --更新病人挂号汇总
  If n_挂号状态 = 1 Then
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_原执行人, '-') And Nvl(医生id, 0) = Nvl(n_原执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_执行人, '-') And Nvl(医生id, 0) = Nvl(n_执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
      Values
        (Trunc(d_出诊日期), n_科室id, n_项目id, v_执行人, Decode(n_执行人id, 0, Null, n_执行人id), v_号码, 1, 0, 0);
    End If;
  End If;
  If n_挂号状态 = 2 Then
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_原执行人, '-') And Nvl(医生id, 0) = Nvl(n_原执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) + 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_执行人, '-') And Nvl(医生id, 0) = Nvl(n_执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
      Values
        (Trunc(d_出诊日期), n_科室id, n_项目id, v_执行人, Decode(n_执行人id, 0, Null, n_执行人id), v_号码, 0, 1, 0);
    End If;
  End If;
  If n_挂号状态 = 3 Then
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1, 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_原执行人, '-') And Nvl(医生id, 0) = Nvl(n_原执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) + 1, 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
    Where 日期 = Trunc(d_出诊日期) And Nvl(医生姓名, '-') = Nvl(v_执行人, '-') And Nvl(医生id, 0) = Nvl(n_执行人id, 0) And
          Nvl(科室id, 0) = Nvl(n_科室id, 0) And Nvl(项目id, 0) = Nvl(n_项目id, 0) And (号码 = v_号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
      Values
        (Trunc(d_出诊日期), n_科室id, n_项目id, v_执行人, Decode(n_执行人id, 0, Null, n_执行人id), v_号码, 1, 1, 1);
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 19, n_变动id || ',' || n_病人id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_患者服务中心_替诊;
/

Create Or Replace Procedure Zl_患者服务中心_换诊
(
  消息id_In     病人服务信息记录.Id%Type,
  No_In         病人挂号记录.No%Type,
  换诊序号_In   病人挂号记录.号序%Type,
  换诊时间_In   病人挂号记录.预约时间%Type,
  换诊id_In     临床出诊记录.Id%Type,
  处理说明_In   病人服务信息记录.处理说明%Type,
  操作员姓名_In 病人服务信息记录.处理人%Type,
  操作员编号_In 病人挂号记录.操作员编号%Type
) As
  Cursor c_Registinfo Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码, c.号序
    From 门诊费用记录 A, 挂号安排 B, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = No_In And Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow    c_Registinfo%RowType;
  v_号别         病人挂号记录.号别%Type;
  n_执行部门id   病人挂号记录.执行部门id%Type;
  n_项目id       临床出诊记录.项目id%Type;
  v_执行人       病人挂号记录.执行人%Type;
  n_执行人id     人员表.Id%Type;
  n_病历费       Number(2);
  n_收费         Number(2);
  n_Exists       Number(3);
  v_Temp         Varchar2(500);
  v_收费项目ids  Varchar2(500);
  v_Err_Msg      Varchar2(500);
  n_病历费id     收费项目目录.Id%Type;
  n_序号         门诊费用记录.序号%Type;
  n_预约         病人挂号记录.预约%Type;
  n_实收金额     门诊费用记录.实收金额%Type;
  n_应收金额     门诊费用记录.应收金额%Type;
  v_费别         门诊费用记录.费别%Type;
  n_病人id       病人挂号记录.病人id%Type;
  n_已用         临床出诊记录.已挂数%Type;
  n_限制         临床出诊记录.限号数%Type;
  n_原号序       病人挂号记录.号序%Type;
  n_原记录id     临床出诊记录.Id%Type;
  n_原挂号状态   临床出诊序号控制.挂号状态%Type;
  v_原操作员     临床出诊序号控制.操作员姓名%Type;
  v_原备注       临床出诊序号控制.备注%Type;
  n_序号控制     临床出诊记录.是否序号控制%Type;
  n_预约顺序号   临床出诊序号控制.预约顺序号%Type;
  n_实际序号     临床出诊序号控制.序号%Type;
  n_变动id       就诊变动记录.Id%Type;
  d_替诊开始时间 临床出诊记录.替诊开始时间%Type;
  d_替诊终止时间 临床出诊记录.替诊终止时间%Type;
  Err_Item Exception;
Begin
  Begin
    Select 1, 病人id Into n_Exists, n_病人id From 病人挂号记录 Where NO = No_In And 记录状态 = 1;
  Exception
    When Others Then
      v_Err_Msg := '单据号为' || No_In || '的预约记录不存在,无法换诊!';
      Raise Err_Item;
  End;
  Begin
    Select 费别 Into v_费别 From 门诊费用记录 Where NO = No_In And 记录性质 = 4;
  Exception
    When Others Then
      Begin
        Select 费别 Into v_费别 From 病人信息 Where 病人id = n_病人id;
      Exception
        When Others Then
          v_费别 := Null;
      End;
  End;
  Begin
    Select 替诊开始时间, 替诊终止时间 Into d_替诊开始时间, d_替诊终止时间 From 临床出诊记录 Where ID = 换诊id_In;
  Exception
    When Others Then
      d_替诊开始时间 := Null;
      d_替诊终止时间 := Null;
  End;

  If d_替诊开始时间 Is Not Null Then
    Select b.号码, b.科室id, Nvl(c.姓名, a.医生姓名), a.项目id, c.Id, Nvl(a.是否序号控制, 0)
    Into v_号别, n_执行部门id, v_执行人, n_项目id, n_执行人id, n_序号控制
    From 临床出诊记录 A, 临床出诊号源 B, 人员表 C
    Where a.Id = 换诊id_In And a.号源id = b.Id And a.医生id = c.Id(+);
  Else
    If 换诊时间_In >= d_替诊开始时间 And 换诊时间_In <= d_替诊终止时间 Then
      Select b.号码, b.科室id, Nvl(c.姓名, a.替诊医生姓名), a.项目id, c.Id, Nvl(a.是否序号控制, 0)
      Into v_号别, n_执行部门id, v_执行人, n_项目id, n_执行人id, n_序号控制
      From 临床出诊记录 A, 临床出诊号源 B, 人员表 C
      Where a.Id = 换诊id_In And a.号源id = b.Id And a.替诊医生id = c.Id(+);
    Else
      Select b.号码, b.科室id, Nvl(c.姓名, a.医生姓名), a.项目id, c.Id, Nvl(a.是否序号控制, 0)
      Into v_号别, n_执行部门id, v_执行人, n_项目id, n_执行人id, n_序号控制
      From 临床出诊记录 A, 临床出诊号源 B, 人员表 C
      Where a.Id = 换诊id_In And a.号源id = b.Id And a.医生id = c.Id(+);
    End If;
  End If;

  Select Max(1) Into n_收费 From 门诊费用记录 Where NO = No_In And 记录性质 = 4 And 结帐金额 Is Not Null;
  Select Max(1)
  Into n_病历费
  From 门诊费用记录 A, 收费特定项目 B
  Where a.No = No_In And a.记录性质 = 4 And a.收费细目id = b.收费细目id And b.特定项目 = '病历费';

  --就诊变动记录
  Select 就诊变动记录_Id.Nextval Into n_变动id From Dual;
  Zl_就诊变动记录_Insert(No_In, 4, '患者服务中心换诊', 操作员姓名_In, 操作员编号_In, v_号别, n_执行部门id, n_项目id, n_执行人id, v_执行人, Null, 换诊序号_In,
                   换诊时间_In, n_变动id);

  --更新患者服务记录
  Update 病人服务信息记录 Set 处理人 = 操作员姓名_In, 处理时间 = Sysdate, 处理说明 = 处理说明_In Where ID = 消息id_In;

  --更新病人挂号汇总(减少)
  Select 预约, 出诊记录id Into n_预约, n_原记录id From 病人挂号记录 Where NO = No_In And 记录状态 = 1;

  --检查换诊记录是否数量足够
  If n_预约 = 0 Then
    Select 已挂数, 限号数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
    If Not n_限制 Is Null Then
      If Nvl(n_已用, 0) >= n_限制 Then
        v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
        Raise Err_Item;
      End If;
    End If;
  Else
    If n_收费 = 1 Then
      Select 已挂数, 限号数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
      If Not n_限制 Is Null Then
        If Nvl(n_已用, 0) >= n_限制 Then
          v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
          Raise Err_Item;
        End If;
      End If;
    Else
      Select 已约数, 限约数 Into n_已用, n_限制 From 临床出诊记录 Where ID = 换诊id_In;
      If Not n_限制 Is Null Then
        If Nvl(n_已用, 0) >= n_限制 Then
          v_Err_Msg := '要换诊的记录已经超过最大限制数量' || n_限制 || ',无法换诊!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If n_预约 = 0 Then
    Open c_Registinfo;
    Fetch c_Registinfo
      Into r_Registrow;
  
    n_原号序 := r_Registrow.号序;
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) - 1 Where ID = n_原记录id;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
          Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
          Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
    Close c_Registinfo;
  Else
    If n_收费 = 1 Then
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      n_原号序 := r_Registrow.号序;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - 1, 已挂数 = Nvl(已挂数, 0) - 1
      Where ID = n_原记录id;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - 1, 已挂数 = Nvl(已挂数, 0) - 1
      Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
            Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 其中已接收, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1, -1);
      End If;
      Close c_Registinfo;
    Else
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      n_原号序 := r_Registrow.号序;
    
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = n_原记录id;
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1
      Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
            Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
      End If;
      Close c_Registinfo;
    End If;
  End If;

  If n_序号控制 = 0 And Nvl(换诊序号_In, 0) <> 0 Then
    Select Max(预约顺序号)
    Into n_预约顺序号
    From 临床出诊序号控制
    Where 记录id = 换诊id_In And 序号 = 换诊序号_In And 预约顺序号 Is Not Null;
    If n_预约顺序号 Is Null Then
      n_预约顺序号 := 1;
    Else
      n_预约顺序号 := n_预约顺序号 + 1;
    End If;
    n_实际序号 := To_Number(换诊序号_In || n_预约顺序号);
  Else
    n_实际序号 := 换诊序号_In;
  End If;
  --更新病人挂号记录
  Update 病人挂号记录
  Set 号别 = v_号别, 执行部门id = n_执行部门id, 执行人 = v_执行人, 号序 = n_实际序号, 发生时间 = 换诊时间_In, 预约时间 = 换诊时间_In, 出诊记录id = 换诊id_In
  Where NO = No_In And 记录状态 = 1;

  --更新门诊费用记录
  If n_病历费 = 1 Then
    Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
    v_收费项目ids := n_项目id || ',' || n_病历费id;
  Else
    v_收费项目ids := n_项目id;
  End If;
  Update 门诊费用记录
  Set 病人科室id = n_执行部门id, 计算单位 = v_号别, 发药窗口 = n_实际序号, 执行部门id = n_执行部门id, 执行人 = v_执行人, 发生时间 = 换诊时间_In
  Where NO = No_In And 记录性质 = 4;
  n_序号 := 1;
  For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                        c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Union All
                 Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                        c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                 From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                 Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                       d.主项id In (Select Column_Value From Table(f_Str2list(n_项目id))) And Sysdate Between b.执行日期 And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                 Order By 性质, 项目编码, 收入编码) Loop
    n_应收金额 := c_Item.单价 * c_Item.数次;
  
    If Nvl(c_Item.屏蔽费别, 0) <> 1 Then
      --打折:
      v_Temp     := Zl_Actualmoney(v_费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
      n_实收金额 := Zl_To_Number(v_Temp);
    Else
      n_实收金额 := n_应收金额;
    End If;
  
    If n_收费 = 1 Then
      Update 门诊费用记录
      Set 收费类别 = c_Item.类别, 收费细目id = c_Item.项目id, 收入项目id = c_Item.收入项目id, 收据费目 = c_Item.收据费目, 数次 = c_Item.数次,
          标准单价 = c_Item.单价, 应收金额 = n_应收金额, 实收金额 = n_实收金额, 结帐金额 = n_实收金额
      Where 序号 = n_序号 And 记录性质 = 4 And NO = No_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 4, 记录状态, n_序号, Null, Null, NO, 实际票号, 门诊标志, Null, Null, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别,
                 年龄, 费别, 病人科室id, c_Item.类别, 计算单位, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
                 n_应收金额, n_实收金额, n_实收金额, 结帐id, 0, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否,
                 保险编码, 统筹金额, 摘要, 结论, 缴款组id
          From 门诊费用记录
          Where 记录性质 = 4 And NO = No_In And 序号 = 1;
      End If;
    Else
      Update 门诊费用记录
      Set 收费细目id = c_Item.项目id, 收入项目id = c_Item.收入项目id, 收据费目 = c_Item.收据费目, 标准单价 = c_Item.单价, 应收金额 = c_Item.单价,
          实收金额 = c_Item.单价
      Where 序号 = n_序号 And 记录性质 = 4 And NO = No_In;
      If Sql%RowCount = 0 Then
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 4, 记录状态, n_序号, Null, Null, NO, 实际票号, 门诊标志, Null, Null, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别,
                 年龄, 费别, 病人科室id, c_Item.类别, 计算单位, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次, c_Item.单价,
                 n_应收金额, n_实收金额, Null, 结帐id, 0, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否,
                 保险编码, 统筹金额, 摘要, 结论, 缴款组id
          From 门诊费用记录
          Where 记录性质 = 4 And NO = No_In And 序号 = 1;
      End If;
    End If;
    n_序号 := n_序号 + 1;
  End Loop;

  --更新病人挂号汇总(增加)
  If n_预约 = 0 Then
    Open c_Registinfo;
    Fetch c_Registinfo
      Into r_Registrow;
  
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) + 1 Where ID = 换诊id_In;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
          Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
          Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1);
    End If;
    Close c_Registinfo;
  Else
    If n_收费 = 1 Then
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1, 已挂数 = Nvl(已挂数, 0) + 1
      Where ID = 换诊id_In;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1, 已挂数 = Nvl(已挂数, 0) + 1
      Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
            Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 其中已接收, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1, 1, 1);
      End If;
      Close c_Registinfo;
    Else
      Open c_Registinfo;
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) + 1 Where ID = 换诊id_In;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And Nvl(科室id, 0) = Nvl(r_Registrow.科室id, 0) And
            Nvl(项目id, 0) = Nvl(r_Registrow.项目id, 0) And (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, 1);
      End If;
      Close c_Registinfo;
    End If;
  End If;
  --更新序号
  Begin
    Select 挂号状态, 操作员姓名, 备注
    Into n_原挂号状态, v_原操作员, v_原备注
    From 临床出诊序号控制
    Where 记录id = n_原记录id And (序号 = n_原号序 Or 备注 = To_Char(n_原号序));
  
    If n_序号控制 = 0 And Nvl(换诊序号_In, 0) <> 0 Then
      Insert Into 临床出诊序号控制
        (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 操作员姓名, 备注)
        Select 记录id, 序号, n_预约顺序号, 开始时间, 终止时间, 1, 是否预约, n_原挂号状态, v_原操作员, n_实际序号
        From 临床出诊序号控制
        Where 记录id = 换诊id_In And 序号 = 换诊序号_In And 预约顺序号 Is Null;
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = n_原挂号状态, 操作员姓名 = v_原操作员, 备注 = v_原备注
      Where 记录id = 换诊id_In And 序号 = 换诊序号_In;
    End If;
  
    Update 临床出诊序号控制
    Set 挂号状态 = Null, 操作员姓名 = Null, 备注 = Null
    Where 记录id = n_原记录id And (序号 = n_原号序 Or 备注 = To_Char(n_原号序));
  Exception
    When Others Then
      Null;
  End;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 20, n_变动id || ',' || n_病人id;
  Exception
    When Others Then
      Null;
  End;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_患者服务中心_换诊;
/


Create Or Replace Procedure Zl_患者服务中心_更新
(
  消息id_In     病人服务信息记录.Id%Type,
  处理说明_In   病人服务信息记录.处理说明%Type,
  操作员姓名_In 病人服务信息记录.处理人%Type,
  操作员编号_In 病人挂号记录.操作员编号%Type,
  挂号id_In     病人挂号记录.Id%Type := Null,
  操作方式_In   Number := 0
) As
  --操作方式_IN:0-正常更新,1-取消预约登记
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
Begin
  --更新患者服务记录
  If 操作方式_In = 0 Then
    If 挂号id_In Is Null Then
      Update 病人服务信息记录
      Set 处理人 = 操作员姓名_In, 处理时间 = Sysdate, 处理说明 = 处理说明_In
      Where ID = 消息id_In;
    Else
      Update 病人服务信息记录
      Set 处理人 = 操作员姓名_In, 处理时间 = Sysdate, 处理说明 = 处理说明_In, 挂号id = 挂号id_In
      Where ID = 消息id_In;
    End If;
  Else
    Delete From 病人服务信息记录 Where ID = 消息id_In;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_患者服务中心_更新;
/

Create Or Replace Procedure Zl_病人挂号汇总_Update
(
  医生姓名_In   挂号安排.医生姓名%Type,
  医生id_In     挂号安排.医生id%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  预约标志_In   Number := 0, --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
  号码_In       挂号安排.号码%Type := Null,
  三方调用_In   Number := 0, --是否接口调用
  出诊记录id_In 临床出诊记录.Id%Type := Null
) As
  --发生时间_In:预约时,为预约时间;否则为登记时间
  v_Date    Date;
  n_预约数  病人挂号汇总.已约数%Type;
  n_时段    Number := 0;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_接收模式 Number := 0;
  n_号源id   临床出诊记录.号源id%Type;
Begin
  If 出诊记录id_In Is Null Then
    Begin
      Select 1
      Into n_时段
      From Dual
      Where Exists (Select 1
             From 挂号安排时段 A, 挂号安排 B
             Where a.安排id = b.Id And b.号码 = 号码_In And Rownum <= 1
             Union All
             Select 1
             From 挂号计划时段 C, 挂号安排计划 D 　
             Where c.计划id = d.Id And d.号码 = 号码_In And d.生效时间 > Sysdate And Rownum <= 1);
    Exception
      When Others Then
        n_时段 := 0;
    End;
    n_接收模式 := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
    --分时段的号别，只能当天接收
    If n_时段 = 1 And Nvl(预约标志_In, 0) = 2 And 三方调用_In = 0 And n_接收模式 = 0 Then
      If Trunc(发生时间_In) <> Trunc(Sysdate) Then
        v_Err_Msg := '分时段的预约挂号单只能当天接收！';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(预约标志_In, 0) <> 2 Or 三方调用_In = 1 Then
      v_Date := Trunc(发生时间_In);
    Else
      If n_接收模式 = 0 Then
        v_Date := Trunc(Sysdate);
      Else
        v_Date := Trunc(发生时间_In);
      End If;
    End If;
  
    n_预约数 := 0;
    If Nvl(预约标志_In, 0) <> 1 Then
      --非预约挂号;或预约接收
      If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
        --1.减去预约日期的预约数;
        --2-加上当前预约日期的挂号数;
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
              (号码 = 号码_In Or 号码 Is Null)
        Returning 已约数 Into n_预约数;
      
        If n_预约数 < 0 Then
          Update 病人挂号汇总
          Set 已约数 = 0
          Where 日期 = Trunc(发生时间_In) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And
                (号码 = 号码_In Or 号码 Is Null)
          Returning 已约数 Into n_预约数;
        End If;
        n_预约数 := 1;
      Elsif Nvl(预约标志_In, 0) = 3 Then
        n_预约数 := 1;
      End If;
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
      Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
            Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
        Values
          (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
           Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
      End If;
    Else
      --预约挂号
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(v_Date) And Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(v_Date), 执行部门id_In, 收费细目id_In, 医生姓名_In, Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1);
      End If;
    End If;
  Else
    --出诊表排班模式
    Begin
      Select Nvl(是否分时段, 0) Into n_时段 From 临床出诊记录 Where ID = 出诊记录id_In;
    Exception
      When Others Then
        n_时段 := 0;
    End;
    Select 号源id Into n_号源id From 临床出诊记录 Where ID = 出诊记录id_In;
    n_接收模式 := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
    --分时段的号别，只能当天接收
    If n_时段 = 1 And Nvl(预约标志_In, 0) = 2 And 三方调用_In = 0 And n_接收模式 = 0 Then
      If Trunc(发生时间_In) <> Trunc(Sysdate) Then
        v_Err_Msg := '分时段的预约挂号单只能当天接收！';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(预约标志_In, 0) <> 2 Or 三方调用_In = 1 Then
      v_Date := Trunc(发生时间_In);
    Else
      If n_接收模式 = 0 Then
        v_Date := Trunc(Sysdate);
      Else
        v_Date := Trunc(发生时间_In);
      End If;
    End If;
  
    n_预约数 := 0;
    If Nvl(预约标志_In, 0) <> 1 Then
      --非预约挂号;或预约接收
      If Nvl(预约标志_In, 0) = 2 And v_Date <> Trunc(发生时间_In) Then
        --1.减去预约日期的预约数;
        --2-加上当前预约日期的挂号数;
        Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = 出诊记录id_In Returning 已约数 Into n_预约数;
        If n_预约数 < 0 Then
          Update 临床出诊记录 Set 已约数 = 0 Where ID = 出诊记录id_In Returning 已约数 Into n_预约数;
        End If;
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(发生时间_In) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
              Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null)
        Returning 已约数 Into n_预约数;
        If n_预约数 < 0 Then
          Update 病人挂号汇总
          Set 已约数 = 0
          Where 日期 = Trunc(发生时间_In) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
                Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null)
          Returning 已约数 Into n_预约数;
        End If;
        n_预约数 := 1;
      Elsif Nvl(预约标志_In, 0) = 3 Then
        n_预约数 := 1;
      End If;
    
      Update 临床出诊记录
      Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
      Where ID = 出诊记录id_In;
    
      Update 病人挂号汇总
      Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + Decode(预约标志_In, 0, 0, 1), 已约数 = Nvl(已约数, 0) + Nvl(n_预约数, 0)
      Where 日期 = Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)) And Nvl(科室id, 0) = 执行部门id_In And
            Nvl(项目id, 0) = 收费细目id_In And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
            (号码 = 号码_In Or 号码 Is Null);
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
        Values
          (Decode(预约标志_In, 2, Trunc(v_Date), Trunc(发生时间_In)), 执行部门id_In, 收费细目id_In, 医生姓名_In,
           Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1, Nvl(n_预约数, 0), Decode(预约标志_In, 0, 0, 1));
      End If;
    Else
      --预约挂号
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) + 1 Where ID = 出诊记录id_In;
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) + 1
      Where 日期 = Trunc(v_Date) And Nvl(医生id, 0) = Nvl(医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(医生姓名_In, '-') And
            Nvl(科室id, 0) = 执行部门id_In And Nvl(项目id, 0) = 收费细目id_In And (号码 = 号码_In Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(v_Date), 执行部门id_In, 收费细目id_In, 医生姓名_In, Decode(医生id_In, 0, Null, 医生id_In), 号码_In, 1);
      End If;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号汇总_Update;
/

Create Or Replace Procedure Zl_病人预约挂号_接收
(
  No_In         病人挂号记录.No%Type,
  诊室_In       病人挂号记录.诊室%Type,
  结帐id_In     门诊费用记录.结帐id%Type := Null,
  卡类别id_In   病人预交记录.卡类别id%Type := Null,
  卡号_In       病人预交记录.卡号%Type := Null,
  交易流水号_In 病人预交记录.交易流水号%Type := Null,
  交易说明_In   病人预交记录.交易说明%Type := Null,
  接收时间_In   病人挂号记录.接收时间%Type := Null
  --该过程用于直接完成预约挂号接收、就诊；主要是医生站使用。
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(n_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = n_病人id And Nvl(预交类别, 2) = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And
                 a.No = b.No And a.病人id = n_病人id And Nvl(a.预交类别, 2) = 1
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = n_病人id And
                 Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  --号别信息
  Cursor c_Regist Is
    Select b.科室id, b.项目id, b.医生id, b.医生姓名, b.号码
    From 门诊费用记录 A, 挂号安排 B
    Where a.记录性质 = 4 And a.记录状态 = 1 And a.No = No_In And a.序号 = 1 And a.计算单位 = b.号码;
  r_Regist c_Regist%RowType;

  Cursor c_Registnew Is
    Select b.科室id, b.项目id, b.医生id, b.医生姓名, c.号码
    From 病人挂号记录 A, 临床出诊记录 B, 临床出诊号源 C
    Where a.记录性质 = 1 And a.记录状态 = 1 And a.No = No_In And a.出诊记录id = b.Id And b.号源id = c.Id;
  r_Registnew c_Registnew%RowType;

  v_划价no       门诊费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     门诊费用记录.操作员编号%Type;
  v_人员姓名     门诊费用记录.操作员姓名%Type;
  v_挂号生成队列 Varchar2(2);
  v_排队号码     排队叫号队列.排队号码%Type;
  v_预约方式     病人挂号记录.预约方式%Type;

  n_病人id   病人挂号记录.病人id%Type;
  n_门诊号   病人挂号记录.门诊号%Type;
  n_挂号金额 门诊费用记录.实收金额%Type;
  n_剩余金额 病人余额.预交余额%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_返回值   病人预交记录.金额%Type;

  d_Date     Date;
  n_当天排队 Number(18);
  n_排队     Number(18);
  v_结算方式 病人预交记录.结算方式%Type;
  v_三方名称 医疗卡类别.名称%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
  n_组id       财务缴款分组.Id%Type;
  v_排队序号   排队叫号队列.排队序号%Type;
  n_结算模式   病人信息.结算模式%Type;
  v_付款方式   病人挂号记录.医疗付款方式%Type;
  n_出诊记录id 临床出诊记录.Id%Type;
Begin
  Begin
    Select a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0) As 余额, Sum(a.实收金额) As n_挂号金额, Substr(a.结论, 1, 10)
    Into n_病人id, n_门诊号, n_剩余金额, n_挂号金额, v_预约方式
    From 门诊费用记录 A, 病人余额 B
    Where a.病人id = b.病人id(+) And b.性质(+) = 1 And b.类型(+) = 1 And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0
    Group By a.病人id, a.标识号, Nvl(b.预交余额, 0) - Nvl(b.费用余额, 0), a.结论;
  Exception
    When Others Then
      v_Error := '预约挂号信息不存在，可能该预约挂号已被接收。';
      Raise Err_Custom;
  End;
  If 接收时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 接收时间_In;
  End If;
  Begin
    Select 出诊记录id Into n_出诊记录id From 病人挂号记录 Where NO = No_In;
  Exception
    When Others Then
      n_出诊记录id := Null;
  End;
  --当前操作人员
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  n_组id     := Zl_Get组id(v_人员姓名);
  n_结算模式 := 0;
  If Nvl(n_病人id, 0) <> 0 Then
    Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = n_病人id;
  End If;
  If n_结算模式 = 0 Then
    If Nvl(结帐id_In, 0) = 0 Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  End If;

  --病人信息的产生
  If n_门诊号 Is Null Then
    Select To_Number(Nextno(3)) Into n_门诊号 From Dual;
  End If;

  If n_病人id Is Null Then
    Select To_Number(Nextno(1)) Into n_病人id From Dual;
    Insert Into 病人信息
      (病人id, 门诊号, 姓名, 性别, 年龄, 费别, 医疗付款方式, 登记时间)
      Select n_病人id, n_门诊号, a.姓名, a.性别, a.年龄, a.费别, b.名称, d_Date
      From 门诊费用记录 A, 医疗付款方式 B
      Where a.付款方式 = b.编码(+) And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 0 And a.序号 = 1;
  End If;

  --更新病人信息，含就诊信息
  Update 病人信息 Set 就诊时间 = d_Date, 就诊状态 = 2, 就诊诊室 = 诊室_In Where 病人id = n_病人id;

  --更新门诊费用记录，含就诊信息
  Update 门诊费用记录
  Set 记录状态 = 1, 结帐id = Decode(n_结算模式, 1, Null, n_结帐id), 结帐金额 = Decode(n_结算模式, 1, Null, 实收金额), 发药窗口 = 诊室_In, 执行人 = v_人员姓名,
      执行状态 = 2, 执行时间 = d_Date, 病人id = Decode(病人id, Null, n_病人id, 病人id), 标识号 = Decode(标识号, Null, n_门诊号, 标识号),
      登记时间 = d_Date, 操作员编号 = v_人员编号, 操作员姓名 = v_人员姓名, 缴款组id = n_组id, 记帐费用 = Decode(n_结算模式, 1, 1, 0)
  Where NO = No_In And 记录性质 = 4 And 记录状态 = 0;

  Update 病人挂号记录
  Set 记录性质 = 1, 接收人 = v_人员姓名, 接收时间 = d_Date, 诊室 = 诊室_In, 执行人 = v_人员姓名, 执行时间 = d_Date, 执行状态 = 2,
      病人id = Decode(病人id, Null, n_病人id, 病人id), 门诊号 = Decode(门诊号, Null, n_门诊号, 门诊号)
  Where NO = No_In And 记录状态 = 1 And 记录性质 = 2;

  If Sql%NotFound Then
    --产生病人挂号记录，含就诊信息
    Begin
      Select a.名称
      Into v_付款方式
      From 医疗付款方式 A, 门诊费用记录 B
      Where b.No = No_In And b.记录性质 = 4 And b.记录状态 = 1 And b.序号 = 1 And a.编码 = b.付款方式 And Rownum < 2;
      Insert Into 病人挂号记录
        (ID, NO, 病人id, 记录性质, 记录状态, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 发生时间, 登记时间, 操作员编号, 操作员姓名,
         预约, 预约方式, 接收时间, 接收人, 预约时间, 医疗付款方式, 出诊记录id)
        Select 病人挂号记录_Id.Nextval, No_In, 病人id, 1, 1, 标识号, 姓名, 性别, 年龄, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, v_人员姓名, 2, d_Date,
               发生时间, 登记时间, 操作员编号, 操作员姓名, 1, Substr(结论, 1, 10) As 预约方式, d_Date, v_人员姓名, 发生时间, v_付款方式, n_出诊记录id
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    Exception
      When Others Then
        v_Error := '该预约挂号已被接收。';
        Raise Err_Custom;
    End;
  End If;

  v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
  If v_挂号生成队列 <> 0 Then
    For c_挂号 In (Select ID, 执行部门id, 姓名, 诊室_In As 诊室, 登记时间, 执行人 As 执行人, 病人id, 号别, 号序
                 From 病人挂号记录
                 Where NO = No_In And Rownum = 1) Loop
      Begin
        Select 1,
               Case
                 When 排队时间 < Trunc(Sysdate) Then
                  1
                 Else
                  0
               End
        Into n_排队, n_当天排队
        From 排队叫号队列
        Where 业务类型 = 0 And 业务id = c_挂号.Id And Rownum <= 1;
      Exception
        When Others Then
          n_排队 := 0;
      End;
    
      If n_排队 = 0 Then
        --新增排队
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 0);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, v_排队号码, Null, c_挂号.姓名, c_挂号.病人id, c_挂号.诊室, c_挂号.执行人,
                         Sysdate, v_预约方式, Null, v_排队序号);
      Elsif Nvl(n_当天排队, 0) = 1 Then
        --更新队列号
        v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
        v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 1);
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人, v_排队号码, v_排队序号);
      
      Else
        --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
        Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人);
      End If;
      --接收后,变成弃号
      Update 排队叫号队列 Set 排队状态 = 2 Where 业务类型 = 0 And 业务id = c_挂号.Id;
    End Loop;
  End If;

  --挂号费用结算
  If Nvl(n_挂号金额, 0) <> 0 Then
  
    If Nvl(n_剩余金额, 0) >= Nvl(n_挂号金额, 0) And Nvl(卡类别id_In, 0) = 0 And n_结算模式 = 0 Then
      --冲预交方式结算
      n_预交金额 := n_挂号金额;
      For r_Deposit In c_Deposit(n_病人id) Loop
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
                 v_人员姓名, v_人员编号, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, r_Deposit.金额, n_预交金额), n_结帐id, n_组id, 卡类别id,
                 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      If n_预交金额 = 0 Then
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_挂号金额
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      Else
        v_Error := '病人门诊预存帐户不足,请立即充值。';
        Raise Err_Custom;
      End If;
    Elsif Nvl(卡类别id_In, 0) > 0 And n_结算模式 = 0 Then
    
      Begin
        Select 结算方式, 名称 Into v_结算方式, v_三方名称 From 医疗卡类别 Where ID = 卡类别id_In;
      Exception
        When Others Then
          v_三方名称 := Null;
      End;
      If v_三方名称 Is Null Then
        v_Error := '未找到三方接口,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      If v_结算方式 Is Null Then
        v_Error := v_三方名称 || '未设置对应的结算方式,请在医疗卡类别中设置.';
        Raise Err_Custom;
      End If;
      --第三方接口支付
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
         缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, Null, 4, 1, 病人id, 病人科室id, Null, v_结算方式, Null, '医生站挂号接收', Null, Null, Null, 登记时间,
               操作员姓名, 操作员编号, n_挂号金额, 结帐id, 缴款组id, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_三方名称, Null, 结帐id, 4
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1 And 序号 = 1;
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + n_挂号金额
      Where 收款员 = v_人员姓名 And 性质 = 1 And 结算方式 = v_结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (v_人员姓名, v_结算方式, 1, n_挂号金额);
      End If;
    Else
      If n_结算模式 = 1 Then
        --记帐
        For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                     From 门诊费用记录
                     Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
          --病人余额
          Update 病人余额
          Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 性质, 类型, 费用余额, 预交余额)
            Values
              (n_病人id, 1, 1, Nvl(c_费用.实收金额, 0), 0);
          End If;
        
          --病人未结费用
          Update 病人未结费用
          Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
          Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
                Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And
                收入项目id + 0 = c_费用.收入项目id And 来源途径 + 0 = 1;
        
          If Sql%RowCount = 0 Then
            Insert Into 病人未结费用
              (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
            Values
              (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
          End If;
        End Loop;
      
      Else
      
        --生成划价单收费(允许的情况下)
        v_Temp := zl_GetSysParameter('允许挂号划价单', 1260);
        If Nvl(v_Temp, '0') <> '1' Then
          v_Error := '病人剩余款额' || To_Char(Nvl(n_剩余金额, 0), '0.00') || ' 不足挂号金额' || To_Char(Nvl(n_挂号金额, 0), '0.00') ||
                     '，不能完成预约接收。';
          Raise Err_Custom;
        End If;
      
        Select Nextno(13) Into v_划价no From Dual;
      
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数,
           数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要,
           结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, 1, v_划价no, 0, a.序号, a.从属父号, a.价格父号, a.门诊标志, a.病人id, a.标识号, a.付款方式, a.姓名, a.性别, a.年龄,
                 a.病人科室id, a.费别, a.收费类别, a.收费细目id, b.计算单位, a.付数, a.数次, Null, Null, Null, a.收入项目id, a.收据费目, a.标准单价,
                 a.应收金额, a.实收金额, 0, v_人员姓名, a.执行部门id, v_人员姓名, d_Date, d_Date, a.执行部门id, 0, '挂号:' || No_In, a.结论, n_组id
          From 门诊费用记录 A, 收费项目目录 B
          Where a.收费细目id = b.Id And a.No = No_In And a.记录性质 = 4 And a.记录状态 = 1;
      
        --挂号本身不收费
        Update 门诊费用记录
        Set 应收金额 = 0, 实收金额 = 0, 结帐金额 = 0
        Where NO = No_In And 记录性质 = 4 And 记录状态 = 1;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If n_出诊记录id Is Null Then
    Open c_Regist;
    Fetch c_Regist
      Into r_Regist;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
    Where 日期 = Trunc(d_Date) And Nvl(科室id, 0) = Nvl(r_Regist.科室id, 0) And Nvl(项目id, 0) = Nvl(r_Regist.项目id, 0) And
          Nvl(医生姓名, '医生') = Nvl(r_Regist.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Regist.医生id, 0) And
          (号码 = r_Regist.号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(d_Date), r_Regist.科室id, r_Regist.项目id, r_Regist.医生姓名, r_Regist.医生id, r_Regist.号码, 1);
    End If;
    Close c_Regist;
  Else
    Open c_Registnew;
    Fetch c_Registnew
      Into r_Registnew;
    Update 临床出诊记录 Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1 Where ID = n_出诊记录id;
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + 1
    Where 日期 = Trunc(d_Date) And Nvl(科室id, 0) = Nvl(r_Registnew.科室id, 0) And Nvl(项目id, 0) = Nvl(r_Registnew.项目id, 0) And
          Nvl(医生姓名, '医生') = Nvl(r_Registnew.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registnew.医生id, 0) And
          (号码 = r_Registnew.号码 Or 号码 Is Null);
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数)
      Values
        (Trunc(d_Date), r_Registnew.科室id, r_Registnew.项目id, r_Registnew.医生姓名, r_Registnew.医生id, r_Registnew.号码, 1);
    End If;
    Close c_Registnew;
  End If;

  --病人担保信息
  If n_病人id Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = n_病人id And Exists (Select 1
           From 病人担保记录
           Where 病人id = n_病人id And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = n_病人id));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = n_病人id And 主页id Is Not Null And Nvl(到期时间, d_Date) > d_Date;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约挂号_接收;
/

--102791:刘尔旋,2016-12-08,预约排队按时点显示
--99652:李南春,2016-09-14,自助挂号调整病人年龄
Create Or Replace Procedure Zl_病人挂号记录_Insert
(
  病人id_In       门诊费用记录.病人id%Type,
  门诊号_In       门诊费用记录.标识号%Type,
  姓名_In         门诊费用记录.姓名%Type,
  性别_In         门诊费用记录.性别%Type,
  年龄_In         门诊费用记录.年龄%Type,
  付款方式_In     门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In         门诊费用记录.费别%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  序号_In         门诊费用记录.序号%Type,
  价格父号_In     门诊费用记录.价格父号%Type,
  从属父号_In     门诊费用记录.从属父号%Type,
  收费类别_In     门诊费用记录.收费类别%Type,
  收费细目id_In   门诊费用记录.收费细目id%Type,
  数次_In         门诊费用记录.数次%Type,
  标准单价_In     门诊费用记录.标准单价%Type,
  收入项目id_In   门诊费用记录.收入项目id%Type,
  收据费目_In     门诊费用记录.收据费目%Type,
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称
  应收金额_In     门诊费用记录.应收金额%Type,
  实收金额_In     门诊费用记录.实收金额%Type,
  病人科室id_In   门诊费用记录.病人科室id%Type,
  开单部门id_In   门诊费用记录.开单部门id%Type,
  执行部门id_In   门诊费用记录.执行部门id%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  医生姓名_In     挂号安排.医生姓名%Type,
  医生id_In       挂号安排.医生id%Type,
  病历费_In       Number, --该条记录是否病历工本费
  急诊_In         Number,
  号别_In         挂号安排.号码%Type,
  诊室_In         门诊费用记录.发药窗口%Type,
  结帐id_In       门诊费用记录.结帐id%Type,
  领用id_In       票据使用明细.领用id%Type,
  预交支付_In     病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In     病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In     病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In   门诊费用记录.保险大类id%Type,
  保险项目否_In   门诊费用记录.保险项目否%Type,
  统筹金额_In     门诊费用记录.统筹金额%Type,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In     Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In     Number := 0, --挂号是否使用收费票据
  保险编码_In     门诊费用记录.保险编码%Type,
  复诊_In         病人挂号记录.复诊%Type := 0,
  号序_In         挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In         病人挂号记录.社区%Type := Null,
  预约接收_In     Number := 0,
  预约方式_In     预约方式.名称%Type := Null,
  生成队列_In     Number := 0,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  操作类型_In     Number := 0,
  险类_In         病人挂号记录.险类%Type := Null,
  结算模式_In     Number := 0,
  记帐费用_In     Number := 0,
  退号重用_In     Number := 1,
  修正病人费别_In Number := 0,
  更新交款余额_In Number := 0, --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
  修正病人年龄_In Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO
    Order By 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;

  n_挂出的最大序号 Number(4) := 0;
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  v_Temp           Varchar2(3000);
  n_分时点显示     Number(3);
  d_启用时间       Date;
Begin
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);
  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  Begin
    Delete From 挂号序号状态
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;
  v_Temp := zl_GetSysParameter(256);
  If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
    Null;
  Else
    Begin
      d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    If d_启用时间 Is Not Null Then
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  --挂号获取安排
  Begin
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0)
    Into n_安排id, n_序号控制, n_限号数, n_限约数
    From 挂号安排 A, 挂号安排限制 B
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In;
  
  Exception
    When Others Then
      n_安排id := -1;
  End;

  --如果是病历费或者号别为空时不检查
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then
    If n_安排id = -1 Then
      v_Err_Msg := '不存在相应的挂号安排数据,请检查';
      Raise Err_Item;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 1 Then
    --首先获取计划
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    
    Exception
      When Others Then
        n_计划id := 0;
    End;
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        --获取计划的限制
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数
        Into n_计划id, n_序号控制, n_限号数, n_限约数
        From 挂号安排计划 A, 挂号计划限制 B
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期;
      Exception
        When Others Then
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查';
          Raise Err_Item;
      End;
    End If;
  End If;

  --获取是否分时段
  If Nvl(n_计划id, 0) = 0 Then
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1;
  Else
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0;
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
    Begin
      Select Nvl(序号, 0),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
      From 挂号安排时段
      Where 安排id = n_安排id And 星期 = v_星期 And
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期
                               From 挂号安排时段
                               Where 安排id = n_安排id And 星期 = v_星期 And
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'),
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) =
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
                               Group By 安排id, 星期);
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then
    --预约号,取计划
    Begin
      If Nvl(n_计划id, 0) = 0 Then
        --没计划生效,取安排的数据
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号安排时段 C
        Where 安排id = n_安排id And 星期 = v_星期 And
              (序号, 安排id, 星期) In
              (Select Nvl(Max(c.序号), -1), 安排id, 星期
               From 挂号安排时段 C
               Where 安排id = n_安排id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 安排id, 星期);
      Else
        --有计划生效取计划
        --没生效，代表是从挂号计划时段查询      
        Select Nvl(序号, -1),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间,
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 挂号计划时段 C
        Where 计划id = n_计划id And 星期 = v_星期 And
              (序号, 计划id, 星期) In
              (Select Nvl(Max(c.序号), -1), 计划id, 星期
               From 挂号计划时段 C
               Where 计划id = n_计划id And c.星期 = v_星期 And
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'),
                            To_Char(发生时间_In, 'hh24:mi')) =
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')
               Group By 计划id, 星期);
      End If;
    Exception
      When Others Then
        n_时段序号 := -1;
        n_分时段   := 0;
        d_时段时间 := 发生时间_In;
        n_时段限号 := 0;
        n_时段限约 := 0;
    End;
  End If;

  If 序号_In = 1 Then
  
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>     
      Begin
        --最大序号
        If 退号重用_In = 1 Then
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0))
          Into n_已用序号, n_已用数量, n_已约数
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
      End;
      If n_序号 Is Null Then
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查       
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 挂号序号状态 A
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And
                状态 Not In (4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量  
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 挂号序号状态 A
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5;
      End If;
    
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1;
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        If 退号重用_In = 1 Then
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5);
        Else
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0))
          Into n_已用序号, n_已挂数, n_已用数量
          From 挂号序号状态
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5;
        End If;
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0))
            Into n_失效数
            From 挂号序号状态
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数
        Into n_已用数量, n_已约数
        From 病人挂号汇总
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      Select 操作员姓名, 机器名
      Into v_序号操作员, v_序号机器名
      From 挂号序号状态
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      Update 挂号序号状态
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          Elsif Nvl(n_分时段, 0) > 0 Then
            --分时段后专家号 失约的预约号允许挂号
            Update 挂号序号状态
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2;
            If Sql%NotFound Then
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
              Values
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate);
            End If;
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        Update 挂号序号状态
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名;
        If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
          Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号;
        End If;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
  
    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In,
         操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    
      If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
      
        n_消费卡id := Null;
        Begin
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
        Exception
          When Others Then
            n_Count := 0;
        End;
        If n_Count = 0 Then
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
          Raise Err_Item;
        End If;
        If n_自制卡 = 1 Then
          Select ID
          Into n_消费卡id
          From 消费卡目录
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
        End If;
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
      End If;
    
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In, 0) = 0 Then
      If Nvl(现金支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 现金支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
          n_返回值 := 现金支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End If;
    
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式);
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_Insert;
/

Create Or Replace Procedure Zl_病人挂号记录_出诊_Delete
(
  单据号_In       门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  摘要_In         门诊费用记录.摘要%Type := Null, --预约取消时 填写 存放预约取消原因
  删除门诊号_In   Number := 0,
  非原样退结算_In Varchar2 := Null,
  退费类型_In     In Number := 0, --0-全退 1-退挂号费 2-退病历费
  退指定结算_In   病人预交记录.结算方式%Type := Null,
  退号重用_In     Number := 1,
  结算方式_In     Varchar2 := Null,
  退预交_In       病人预交记录.冲预交%Type := Null
) As
  --退费类型_In,在一下几种情况下不准进行部分退费
  --    2.三方接口,暂时不支持
  -- 挂号费病历费分开退,规则
  --    普通结算方式:原结算方式退部分费用
  --    预交款:预交款,退部分
  --    预交款与普通结算方式混合:退款按照普通结算方式部分退
  --    消费卡:原样将费用部分退入消费卡
  --非原样退结算_In:指不能退还给原样结算方式(如医保的个人账户,三方账户的退现等),多个用逗分离
  --退指定结算_IN:指非原样退结算部分,应该退给哪种结算方式,为空时缺省退给现金,否则退给指定的结算方式

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select a.发生时间, a.登记时间, c.接收时间, a.收费细目id As 项目id, c.执行部门id As 科室id, c.执行人 As 医生姓名, d.Id As 医生id, c.号别 As 号码
    From 门诊费用记录 A, 病人挂号记录 C, 人员表 D
    Where a.记录性质 = 4 And a.记录状态 = v_状态 And c.No = a.No And c.执行人 = d.姓名(+) And a.No = 单据号_In And
          Nvl(a.计算单位, '号别') = c.号别 And Rownum < 2;
  r_Registrow c_Registinfo%RowType;

  --该游标用于判断记录是否存在,及费用汇总表处理
  Cursor c_Moneyinfo(v_状态 门诊费用记录.记录状态%Type) Is
    Select 病人科室id, 开单部门id, 执行部门id, 收入项目id, Nvl(Sum(应收金额), 0) As 应收, Nvl(Sum(实收金额), 0) As 实收, Nvl(Sum(结帐金额), 0) As 结帐
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = v_状态 And NO = 单据号_In
    Group By 病人科室id, 开单部门id, 执行部门id, 收入项目id;
  r_Moneyrow c_Moneyinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, -1 * Nvl(b.冲预交, 0) As 冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 2 And b.记录性质 = 4 And b.记录状态 = 2 And
          Nvl(b.冲预交, 0) <> 0 And
          Nvl(a.附加标志, 0) =
          Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(a.附加标志, 0), 1, -1, Nvl(a.附加标志, 0)), Nvl(a.附加标志, 0));

  v_Err_Msg Varchar(255);
  Err_Item Exception;

  n_结帐id 病人预交记录.结帐id%Type;
  n_销帐id 门诊费用记录.结帐id%Type;

  v_退指定结算方式 病人预交记录.结算方式%Type;
  n_退款金额       病人预交记录.冲预交%Type;
  n_打印id         票据打印内容.Id%Type;
  n_病人id         病人信息.病人id%Type;
  n_退费金额       病人预交记录.冲预交%Type;
  n_预交金额       病人预交记录.冲预交%Type; --原记录 预交缴款金额
  n_返回值         病人余额.预交余额%Type;
  n_挂号id         病人挂号记录.Id%Type;
  n_组id           财务缴款分组.Id%Type;

  n_二次退费       Number; --记录是否是此单据的第二次退费
  n_分诊台签到排队 Number;
  n_预约生成队列   Number;
  n_预约挂号       Number;
  n_挂号生成队列   Number;
  d_Date           Date;
  n_记帐           门诊费用记录.记帐费用%Type;
  n_病人id1        病人信息.病人id%Type;
  n_返回额         门诊费用记录.实收金额%Type;
  n_已结帐         Number;
  n_序号           病人挂号记录.号序%Type;
  n_就诊病人id     病人信息.病人id%Type;
  d_就诊时间       就诊登记记录.就诊时间%Type;
  n_出诊记录id     临床出诊记录.Id%Type;
  v_结算内容       Varchar2(5000);
  v_当前结算       Varchar2(1000);
  v_结算方式       病人预交记录.结算方式%Type;
  n_三方卡标志     Number;
  n_结算金额       病人预交记录.冲预交%Type;
  n_检查数         Number;
Begin
  n_组id           := Zl_Get组id(操作员姓名_In);
  v_退指定结算方式 := 退指定结算_In;

  Select 出诊记录id, 号序 Into n_出诊记录id, n_序号 From 病人挂号记录 Where NO = 单据号_In And Rownum < 2;

  --首先判断要退号/取消预约的记录是否存在
  Open c_Moneyinfo(1);
  Fetch c_Moneyinfo
    Into r_Moneyrow;
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Open c_Moneyinfo(0);
    Fetch c_Moneyinfo
      Into r_Moneyrow;
    If c_Moneyinfo%RowCount = 0 Then
      v_Err_Msg := '要处理的单据不存在。';
      Raise Err_Item;
    End If;
    n_预约挂号 := 1;
  End If;
  Close c_Moneyinfo;

  --1.预约处理
  If Nvl(n_预约挂号, 0) = 1 Then
    --减少已约数
    Open c_Registinfo(0);
    Fetch c_Registinfo
      Into r_Registrow;
  
    n_检查数 := Null;
    Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = n_出诊记录id Returning 已约数 Into n_检查数;
    If Nvl(n_检查数, 0) < 0 Then
      Update 临床出诊记录 Set 已约数 = 0 Where ID = n_出诊记录id;
    End If;
  
    Update 病人挂号汇总
    Set 已约数 = Nvl(已约数, 0) - 1
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1);
    End If;
  
    Close c_Registinfo;
  
    --更新挂号序号状态
    Update 临床出诊序号控制
    Set 挂号状态 = 0, 操作员姓名 = Null
    Where 挂号状态 = 2 And 记录id = n_出诊记录id And 序号 = n_序号;
  
    Update 临床出诊序号控制
    Set 挂号状态 = 4, 操作员姓名 = Null
    Where 挂号状态 = 2 And 记录id = n_出诊记录id And 备注 = To_Char(n_序号);
  
    --添加病人挂号记录的 冲销记录
    Select 病人挂号记录_Id.Nextval, Sysdate Into n_挂号id, d_Date From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1 And 记录性质 = 2;
    If Sql%NotFound Then
      v_Err_Msg := '预约单【' || 单据号_In || '】不存在或由于并发原因已经被取消预约';
      Raise Err_Item;
    End If;
  
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 出诊记录id, 预约操作员, 预约操作员编号)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式,
             n_出诊记录id, 预约操作员, 预约操作员编号
      From 病人挂号记录
      Where NO = 单据号_In;
  
    --如果预约生成队列时需要清除队列
  
    n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    If Nvl(n_预约生成队列, 0) = 1 Then
      --要删除队列
      For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
        Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
      End Loop;
    End If;
    Return;
  End If;

  Select Nvl(记帐费用, 0), 病人id, Decode(Sign(Nvl(结帐id, 0)), 0, 0, 1)
  Into n_记帐, n_病人id, n_已结帐
  From 门诊费用记录
  Where 记录性质 = 4 And NO = 单据号_In And 记录状态 In (1, 3) And Rownum < 2;

  --2.挂号处理
  n_已结帐 := Nvl(n_已结帐, 0);

  If n_已结帐 = 1 And n_记帐 = 1 Then
    Select Sysdate, Null Into d_Date, n_销帐id From Dual;
  Else
    Select Sysdate, 病人结帐记录_Id.Nextval Into d_Date, n_销帐id From Dual;
  End If;

  ----0-全退 1-退挂号费 2-退病历费
  If Nvl(退费类型_In, 0) <> 2 Then
    --不是光退病历费时处理
    --更新挂号序号状态
    If 退号重用_In = 1 Then
      Update 临床出诊序号控制
      Set 挂号状态 = 0, 操作员姓名 = Null
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And 序号 = n_序号;
    
      Update 临床出诊序号控制
      Set 挂号状态 = 4, 操作员姓名 = Null
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And 备注 = To_Char(n_序号);
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = 4, 操作员姓名 = 操作员姓名_In
      Where 挂号状态 = 1 And 记录id = n_出诊记录id And (序号 = n_序号 Or 备注 = To_Char(n_序号));
    End If;
  
    --病人就诊状态
    If n_病人id Is Not Null Then
      Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
    
      --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      If 删除门诊号_In = 1 Then
        Delete 门诊病案记录 Where 病人id = n_病人id;
        Update 病人信息 Set 门诊号 = Null Where 病人id = n_病人id;
        --费用记录包括挂号及病案、就诊卡费用,以及病人交费后退费或销帐的费用,挂号记录在最后处理
        Update 门诊费用记录 Set 标识号 = Null Where 门诊标志 = 1 And 病人id = n_病人id;
      End If;
    End If;
  
    --如果挂时收了就诊卡费,退费时清除就诊卡号,在非光退病历费时
    n_病人id1 := Null;
    Begin
      Select 病人id
      Into n_病人id1
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 附加标志 = 2 And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If n_病人id1 Is Not Null And Nvl(退费类型_In, 0) <> 2 Then
      Update 病人信息
      Set 就诊卡号 = Null, 卡验证码 = Null, Ic卡号 = Decode(Ic卡号, 就诊卡号, Null, Ic卡号)
      Where 病人id = n_病人id1;
    End If;
  
  End If;

  --检查前面是否已经部分退过费用
  Begin
    Select 1 Into n_二次退费 From 门诊费用记录 Where 记录性质 = 4 And NO = 单据号_In And 记录状态 = 3 And Rownum < 2;
  Exception
    When Others Then
      n_二次退费 := 0;
  End;

  --门诊费用记录
  --冲销记录
  Insert Into 门诊费用记录
    (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位, 付数,
     数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间, 登记时间,
     结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
    Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
           收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
           操作员编号_In, 操作员姓名_In, 发生时间, d_Date, n_销帐id,
           Decode(n_记帐, 1, Decode(Nvl(n_已结帐, 0), 0, -1 * 实收金额, Null), -1 * 结帐金额), 保险项目否, 保险大类id, -1 * 统筹金额,
           Nvl(摘要_In, 摘要) As 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));

  --原始记录
  If n_记帐 = 1 And Nvl(n_已结帐, 0) = 0 Then
    Update 门诊费用记录
    Set 记录状态 = 3, 结帐id = n_销帐id, 结帐金额 = 实收金额
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  Else
    Update 门诊费用记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
  End If;

  n_结帐id := 0;
  If n_记帐 = 0 Then
    --获取结帐ID
    Select Nvl(结帐id, 0)
    Into n_结帐id
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
          Nvl(附加标志, 0) = Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
          Rownum = 1;
  End If;

  If n_记帐 = 1 Then
    --记帐
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And
                       Nvl(附加标志, 0) =
                       Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0)) And
                       Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1
      Returning 费用余额 Into n_返回额;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (n_病人id, 1, 1, -1 * Nvl(c_费用.实收金额, 0), 0);
        n_返回额 := Nvl(c_费用.实收金额, 0);
      End If;
      If Nvl(n_返回额, 0) = 0 Then
        Delete 病人余额
        Where 病人id = Nvl(n_病人id, 0) And 性质 = 1 And 类型 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(c_费用.实收金额, 0)
      Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (n_病人id, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, -1 * Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
    Delete 病人未结费用
    Where 病人id = n_病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(金额, 0) = 0 And 来源途径 + 0 = 1;
  End If;

  If n_记帐 = 0 Then
    --1.退费
    --病人挂号结算:现金和个人帐户部份
    If 结算方式_In Is Null Then
      If 非原样退结算_In Is Not Null Then
        --退款金额获取
        If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
          --如果是单独退病历费,或者只退挂号费,先获取退费金额
          Begin
            --获取本次退款金额
            Select Sum(Nvl(实收金额, 0)) As 收款金额
            Into n_退款金额
            From 门诊费用记录
            Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                  Nvl(附加标志, 0) =
                  Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
          
          Exception
            When Others Then
              v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                             When 1 Then
                              '挂号费用'
                             When 2 Then
                              '病历费'
                           End || '可能由于并发原因已经进行了退费或者单据不存在!';
              Raise Err_Item;
          End;
          Begin
            Select 冲预交
            Into n_退费金额
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
          Exception
            When Others Then
              n_退费金额 := 0;
          End;
        
          --a.允许的结算方式
        
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -n_退款金额,
                   n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        
          If n_退费金额 = 0 Then
            --b.不允许的退现金
            If n_退款金额 <> 0 Then
              If v_退指定结算方式 Is Null Then
                --退给现金
                Begin
                  Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                Exception
                  When Others Then
                    v_退指定结算方式 := '现金';
                End;
              End If;
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_退款金额)
              Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                   卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                  Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                         操作员编号_In, 操作员姓名_In, -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                  From 病人预交记录 A
                  Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
              End If;
            End If;
          End If;
        Else
          --a.允许的结算方式原样退
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In, -冲预交,
                   n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
        
          --b.不允许的退现金
          Begin
            Select Sum(冲预交)
            Into n_退费金额
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') > 0;
          Exception
            When Others Then
              n_退费金额 := 0;
          End;
          If n_退费金额 <> 0 Then
            If v_退指定结算方式 Is Null Then
              --退给现金
              Begin
                Select 结算方式
                Into v_退指定结算方式
                From 病人预交记录
                Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id And
                      Instr(',' || 非原样退结算_In || ',', ',' || 结算方式 || ',') = 0;
              
              Exception
                When Others Then
                  Begin
                    Select 名称 Into v_退指定结算方式 From 结算方式 Where 性质 = 1;
                  Exception
                    When Others Then
                      v_退指定结算方式 := '现金';
                  End;
              End;
            End If;
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * n_退费金额)
            Where 记录性质 = 4 And 记录状态 = 2 And 结帐id = n_销帐id And 结算方式 = v_退指定结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
                Select 病人预交记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.病人id, a.主页id, a.科室id, a.摘要, v_退指定结算方式, d_Date,
                       操作员编号_In, 操作员姓名_In, -1 * n_退费金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
                From 病人预交记录 A
                Where a.记录性质 = 4 And a.记录状态 = 1 And a.结帐id = n_结帐id And Rownum < 2;
            End If;
          End If;
        End If;
      Else
        --退款金额获取
        If Nvl(退费类型_In, 0) <> 0 Or Nvl(n_二次退费, 0) <> 0 Then
          --如果是单独退病历费,或者只退挂号费,先获取退费金额
          Begin
            --获取本次退款金额
            Select Sum(Nvl(实收金额, 0)) As 收款金额
            Into n_退款金额
            From 门诊费用记录
            Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 3 And
                  Nvl(附加标志, 0) =
                  Decode(Nvl(退费类型_In, 0), 2, 1, 1, Decode(Nvl(附加标志, 0), 1, -1, Nvl(附加标志, 0)), Nvl(附加标志, 0));
          Exception
            When Others Then
              v_Err_Msg := '单据【' || 单据号_In || '】的' || Case Nvl(退费类型_In, 0)
                             When 1 Then
                              '挂号费用'
                             When 2 Then
                              '病历费'
                           End || '可能由于并发原因已经进行了退费或者单据不存在!';
              Raise Err_Item;
          End;
        End If;
        If Nvl(n_二次退费, 0) = 0 And Nvl(退费类型_In, 0) = 0 Then
          --首次全退
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * 冲预交, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_结帐id;
        Else
          --二次退费,或者本次单退一部分
          --二次退费时,记录状态=3 ,首次部分退,记录状态为1
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 摘要 = '医保挂号' And
                  冲预交 = n_退款金额 And Rownum < 2;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                     -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And 冲预交 = n_退款金额 And
                    Rownum < 2;
          End If;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
              Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                     -1 * n_退款金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
              From 病人预交记录
              Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
            If Sql%RowCount = 0 Then
              --部分退费,并且全部使用预交款缴费时才存在此种情况
              n_预交金额 := n_退款金额;
            End If;
          End If;
        
        End If;
      End If;
    Else
      --按结算方式退
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 结算号码)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, v_结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_结算金额, n_销帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, 合作单位, 4, 结算号码
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And Rownum < 2;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质, 结算号码)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, v_结算方式, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * n_结算金额, n_销帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4, 结算号码

            
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id And
                  (卡类别id Is Not Null Or 结算卡序号 Is Not Null) And Rownum < 2;
        End If;
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
      n_预交金额 := Nvl(退预交_In, 0);
    End If;
    --首次退费时,记录状态便调整为了3
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_二次退费, 0), 0, 1, 3) And 结帐id = n_结帐id;
  
    --冲预交 1-全退 2-部分退,部分退时当全部使用预交进行缴款
    If Nvl(退费类型_In, 0) = 0 Or (Nvl(退费类型_In, 0) <> 0 And n_预交金额 <> 0) Then
      --病人挂号结算:冲预交款部份
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
               操作员姓名_In, 操作员编号_In, -1 * Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, 冲预交, n_预交金额), n_销帐id, n_组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
        From 病人预交记录
        Where 记录性质 In (1, 11) And 结帐id = n_结帐id And Nvl(冲预交, 0) <> 0 And
              Rownum = Decode(Nvl(退费类型_In, 0) + Nvl(n_二次退费, 0), 0, Rownum, 1);
    End If;
  
    --处理病人预交余额
    For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_销帐id
                 Group By 病人id, 预交类别) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
      Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 预交余额, 性质, 类型)
        Values
          (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
        n_返回值 := Nvl(c_预交.冲预交, 0);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    If Nvl(退费类型_In, 0) <> 2 Then
      --光退挂号费,不回收票据
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    End If;
  End If;

  --单独退病历费用,不处理汇总记录
  --相关汇总表的处理

  --病人挂号汇总
  Open c_Registinfo(3);
  Fetch c_Registinfo
    Into r_Registrow;

  If c_Registinfo%RowCount = 0 Then
    --只收病历费时无号别,不处理
    Close c_Registinfo;
  Else
  
    --需要确定是否预约挂号
    --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
    --2.如果是正常挂号,则只减已挂数
  
    Begin
      Select Decode(预约, Null, 0, 0, 0, 1) Into n_预约挂号 From 病人挂号记录 Where NO = 单据号_In And Rownum = 1;
    Exception
      When Others Then
        n_预约挂号 := 0;
    End;
    n_检查数 := Null;
    Update 临床出诊记录
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where ID = n_出诊记录id
    Returning 已挂数 Into n_检查数;
  
    If Nvl(n_检查数, 0) < 0 Then
      Update 临床出诊记录 Set 已挂数 = 0 Where ID = n_出诊记录id;
    End If;
  
    Update 病人挂号汇总
    Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约挂号, 已约数 = Nvl(已约数, 0) - n_预约挂号
    Where 日期 = Trunc(r_Registrow.发生时间) And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
          Nvl(医生姓名, '-') = Nvl(r_Registrow.医生姓名, '-') And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
          (号码 = r_Registrow.号码 Or 号码 Is Null);
  
    If Sql%RowCount = 0 Then
      Insert Into 病人挂号汇总
        (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收, 已约数)
      Values
        (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
         Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号, -1 * n_预约挂号);
    End If;
  
    Close c_Registinfo;
  End If;

  If n_记帐 = 0 Then
    --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
    For r_Opermoney In c_Opermoney Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
      Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
        n_返回值 := r_Opermoney.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;
  If Nvl(退费类型_In, 0) <> 2 Then
    n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If n_挂号生成队列 <> 0 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Then
      
        --要删除队列
        For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
          Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
        End Loop;
      End If;
    End If;
  
    --医保产生的就诊登记记录
    Begin
      Select 病人id, 发生时间 Into n_就诊病人id, d_就诊时间 From 病人挂号记录 Where NO = 单据号_In;
      Delete From 就诊登记记录 Where 病人id = n_就诊病人id And 就诊时间 = d_就诊时间 And 主页id Is Null;
    Exception
      When Others Then
        Null;
    End;
  
    --病人挂号记录
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
  
    Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录性质 = 1 And 记录状态 = 1;
    If Sql%NotFound Then
      v_Err_Msg := '挂号单【' || 单据号_In || '】不存在或由于并发原因已经被退号';
      Raise Err_Item;
    End If;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
       复诊, 号序, 社区, 预约, 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式, 出诊记录id)
      Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_Date, 发生时间,
             操作员编号_In, 操作员姓名_In, 复诊, 号序, 社区, 预约, Nvl(摘要_In, 摘要) As 摘要, 预约方式, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 险类, 医疗付款方式,
             n_出诊记录id
      From 病人挂号记录
      Where NO = 单据号_In;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 2, 单据号_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Delete;
/


Create Or Replace Procedure Zl_出诊表挂号_Turn(启用日期_In In Date) Is
  ------------------------------------------------ 
  --功能：将出诊表排班模式启用时间之后的计划排班挂号记录转换为出诊表排班模式挂号记录
  --返回：转换记录条数
  ------------------------------------------------ 
  v_Error Varchar2(255);
  Err_Custom Exception;
  n_处理数量   Number(10);
  v_Para       Varchar2(500);
  n_挂号模式   Number(3);
  d_启用时间   Date;
  n_安排id     挂号安排.Id%Type;
  n_计划id     挂号安排计划.Id%Type;
  v_时间段     时间段.时间段%Type;
  n_分时段     Number(3);
  n_分时段序号 临床出诊序号控制.序号%Type;
  n_序号控制   挂号安排.序号控制%Type;
  n_出诊记录id 临床出诊记录.Id%Type;
  n_未处理数量 Number(10);
Begin
  Begin
    d_启用时间 := 启用日期_In;
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  For r_挂号 In (Select ID, NO, 号别, 执行部门id, 执行人, 记录性质, 预约, 号序, 病人id, 发生时间, 操作员姓名
               From 病人挂号记录
               Where 记录状态 = 1 And 发生时间 >= Trunc(d_启用时间) And 出诊记录id Is Null) Loop
    v_时间段 := Null;
    Begin
      Select ID, 序号控制
      Into n_计划id, n_序号控制
      From (Select a.Id, a.序号控制
             From 挂号安排计划 A, 挂号安排 B
             Where a.安排id = b.Id And a.审核时间 Is Not Null And b.号码 = r_挂号.号别 And r_挂号.发生时间 Between 生效时间 And 失效时间
             Order By 生效时间 Desc)
      Where Rownum < 2;
      Select Decode(To_Char(r_挂号.发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7', a.周六,
                     Null)
      Into v_时间段
      From 挂号安排计划 A
      Where a.Id = n_计划id;
    Exception
      When Others Then
        n_计划id := Null;
        Select ID, 序号控制 Into n_安排id, n_序号控制 From 挂号安排 Where 号码 = r_挂号.号别;
        Select Decode(To_Char(r_挂号.发生时间, 'D'), '1', a.周日, '2', a.周一, '3', a.周二, '4', a.周三, '5', a.周四, '6', a.周五, '7',
                       a.周六, Null)
        Into v_时间段
        From 挂号安排 A
        Where a.Id = n_安排id;
    End;
    If v_时间段 Is Not Null Then
      Begin
        If Nvl(n_计划id, 0) = 0 Then
          Select 1 Into n_分时段 From 挂号安排时段 Where 安排id = n_安排id And Rownum < 2;
        Else
          Select 1 Into n_分时段 From 挂号计划时段 Where 计划id = n_计划id And Rownum < 2;
        End If;
      Exception
        When Others Then
          n_分时段 := 0;
      End;
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = r_挂号.号别 And r_挂号.发生时间 Between a.开始时间 And a.终止时间 And 上班时段 = v_时间段;
      Exception
        When Others Then
          n_出诊记录id := Null;
      End;
      If n_出诊记录id Is Null Then
        v_Error := '已经挂号的记录存在无法对应的出诊记录,立即启用失败!';
        Raise Err_Custom;
      End If;
      If Nvl(n_序号控制, 0) = 0 Then
        If n_分时段 = 0 Then
          If r_挂号.记录性质 = 1 Then
            If Nvl(r_挂号.预约, 0) = 1 Then
              Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
              Update 临床出诊记录
              Set 已挂数 = 已挂数 + 1, 已约数 = 已约数 + 1, 其中已接收 = 其中已接收 + 1
              Where ID = n_出诊记录id;
            Else
              Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
              Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
            End If;
          Else
            Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
            Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
          End If;
          n_处理数量 := n_处理数量 + 1;
        Else
          --非序号控制分时段,特殊处理
          Select 序号 Into n_分时段序号 From 临床出诊序号控制 Where 预约顺序号 Is Null And 开始时间 = r_挂号.发生时间;
          If r_挂号.记录性质 = 1 Then
            If Nvl(r_挂号.预约, 0) = 1 Then
              Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
              Update 临床出诊记录
              Set 已挂数 = 已挂数 + 1, 已约数 = 已约数 + 1, 其中已接收 = 其中已接收 + 1
              Where ID = n_出诊记录id;
            Else
              Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
              Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
            End If;
            Insert Into 临床出诊序号控制
              (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 操作员姓名, 备注)
              Select 记录id, n_分时段序号, r_挂号.号序, 开始时间, 终止时间, 1, 是否预约, 1, r_挂号.操作员姓名, r_挂号.号序
              From 临床出诊序号控制
              Where 记录id = n_出诊记录id And 序号 = n_分时段序号 And 预约顺序号 Is Null;
          Else
            Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
            Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
            Insert Into 临床出诊序号控制
              (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 操作员姓名, 备注)
              Select 记录id, n_分时段序号, r_挂号.号序, 开始时间, 终止时间, 1, 是否预约, 2, r_挂号.操作员姓名, r_挂号.号序
              From 临床出诊序号控制
              Where 记录id = n_出诊记录id And 序号 = n_分时段序号 And 预约顺序号 Is Null;
          End If;
          n_处理数量 := n_处理数量 + 1;
        End If;
      Else
        If r_挂号.记录性质 = 1 Then
          If Nvl(r_挂号.预约, 0) = 1 Then
            Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
            Update 临床出诊记录
            Set 已挂数 = 已挂数 + 1, 已约数 = 已约数 + 1, 其中已接收 = 其中已接收 + 1
            Where ID = n_出诊记录id;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = r_挂号.操作员姓名
            Where 记录id = n_出诊记录id And 序号 = r_挂号.号序;
            If Sql%RowCount = 0 Then
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 挂号状态, 操作员姓名, 备注)
              Values
                (n_出诊记录id, r_挂号.号序, r_挂号.发生时间, r_挂号.发生时间, 1, 1, r_挂号.操作员姓名, '自动转换产生序号');
            End If;
          Else
            Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
            Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = r_挂号.操作员姓名
            Where 记录id = n_出诊记录id And 序号 = r_挂号.号序;
            If Sql%RowCount = 0 Then
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 挂号状态, 操作员姓名, 备注)
              Values
                (n_出诊记录id, r_挂号.号序, r_挂号.发生时间, r_挂号.发生时间, 1, 1, r_挂号.操作员姓名, '自动转换产生序号');
            End If;
          End If;
        Else
          Update 病人挂号记录 Set 出诊记录id = n_出诊记录id Where ID = r_挂号.Id;
          Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
          Update 临床出诊序号控制
          Set 挂号状态 = 2, 操作员姓名 = r_挂号.操作员姓名
          Where 记录id = n_出诊记录id And 序号 = r_挂号.号序;
          If Sql%RowCount = 0 Then
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 挂号状态, 操作员姓名, 备注)
            Values
              (n_出诊记录id, r_挂号.号序, r_挂号.发生时间, r_挂号.发生时间, 1, 2, r_挂号.操作员姓名, '自动转换产生序号');
          End If;
        End If;
        n_处理数量 := n_处理数量 + 1;
      End If;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_出诊表挂号_Turn;
/

--102791:刘尔旋,2016-12-08,预约排队时按时点显示
--103209:刘尔旋,2016-12-20,服务窗医保实时结算
--102689:刘尔旋,2016-12-01,分时段不序号控制号别预约问题
--102760:刘尔旋,2016-11-23,支付宝并发错误提示更改
--101446:刘尔旋,2016-10-21,失约号处理
--99652:李南春,2016-09-14,自助挂号调整病人年龄
Create Or Replace Procedure Zl_病人挂号记录_出诊_Insert
(
  出诊记录id_In    临床出诊记录.Id%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      Varchar2,
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  更新交款余额_In  Number := 0, --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
  预约顺序号_In    临床出诊序号控制.预约顺序号%Type := Null,
  修正病人年龄_In  Number := 0
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO
    Order By 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_原始分时段   Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  v_结算方式记录   Varchar2(1000);
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  v_结算方式       结算方式.名称%Type;
  v_结算内容       Varchar2(1000);
  v_当前结算       Varchar2(200);
  v_结算号码       病人预交记录.结算号码%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_三方卡标志     Number(2);
  n_安排id         挂号安排.Id%Type;
  n_预约顺序号     临床出诊序号控制.预约顺序号%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;
  n_Exists         Number;
  n_挂出的最大序号 Number(4) := 0;
  n_分时点显示     Number(3);
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  n_状态           临床出诊序号控制.挂号状态%Type;
Begin
  --记录锁定判断
  If 出诊记录id_In Is Not Null Then
    Begin
      Select 1
      Into n_Exists
      From 临床出诊记录
      Where ID = 出诊记录id_In And Nvl(是否发布, 0) = 1 And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        v_Err_Msg := '无法确定出诊记录，请检查出诊记录是否存在或被锁定！';
        Raise Err_Item;
    End;
  End If;

  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);

  If 费别_In Is Null Then
    Begin
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
        Raise Err_Item;
    End;
  Else
    v_费别 := 费别_In;
    If Nvl(修正病人费别_In, 0) = 1 Then
      Begin
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '没有找到对应的病人！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If Nvl(修正病人年龄_In, 0) = 1 Then
    Begin
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    Exception
      When Others Then
        v_Err_Msg := '没有找到对应的病人！';
        Raise Err_Item;
    End;
  End If;

  Begin
    Update 临床出诊序号控制
    Set 挂号状态 = 0
    Where 记录id = 出诊记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
  Exception
    When Others Then
      Null;
  End;

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;

  --获取是否分时段
  Begin
    Select Nvl(是否分时段, 0), Nvl(是否序号控制, 0), 限号数, 限约数
    Into n_分时段, n_序号控制, n_限号数, n_限约数
    From 临床出诊记录
    Where ID = 出诊记录id_In;
    n_原始分时段 := n_分时段;
  Exception
    When Others Then
      n_分时段     := 0;
      n_原始分时段 := n_分时段;
      n_序号控制   := 0;
      n_限号数     := Null;
      n_限约数     := Null;
  End;

  If n_序号 Is Null And n_分时段 = 1 And n_序号控制 = 0 Then
    Begin
      Select 序号
      Into n_序号
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And 开始时间 = 发生时间_In And Rownum < 2;
    Exception
      When Others Then
        n_序号 := Null;
    End;
  End If;

  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then
    Begin
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'))
      Into d_最大序号时间
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And Nvl(数量, 0) <> 0;
    
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                 When -1 Then
                  0
                 Else
                  1
               End;
    Exception
      When Others Then
        n_追加号 := 0;
    End;
  End If;
  d_时段时间 := 发生时间_In;

  If 序号_In = 1 And n_分时段 > 0 Then
    If Nvl(n_序号控制, 0) = 1 Then
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    Else
      --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 Is Null;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    End If;
  End If;

  If 序号_In = 1 Then
    --获取当前未使用的序号
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>
      Begin
        --最大序号
        Select Count(1) Into n_已用数量 From 病人挂号记录 Where 出诊记录id = 出诊记录id_In And 记录状态 = 1;
      Exception
        When Others Then
          n_已用数量 := 0;
      End;
      Begin
        Select Sum(Nvl(数量, 0))
        Into n_已约数
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 2;
      Exception
        When Others Then
          n_已约数 := 0;
      End;
      If n_原始分时段 = 0 Then
        Begin
          Select Min(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 0;
          If n_序号 Is Null Then
            n_序号 := Nvl(n_已用序号, 0);
          End If;
        Exception
          When Others Then
            Select Max(序号)
            Into n_已用序号
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) <> 0;
            If Nvl(n_序号, 0) = 0 Then
              n_序号 := Nvl(n_已用序号, 0) + 1;
            End If;
        End;
        If Nvl(n_序号, 0) = 0 Then
          Select Max(序号)
          Into n_已用序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) <> 0;
          n_序号 := Nvl(n_已用序号, 0) + 1;
        End If;
      Else
        Select Max(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
        If n_序号 Is Null Then
          n_序号 := Nvl(n_已用序号, 0) + 1;
        End If;
      End If;
    
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end>
    
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已用数量 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 Then
        --<正常预约挂号-->
        Begin
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.开始时间 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
          Into n_已挂数, n_已约数
          From 临床出诊序号控制 A
          Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
        Exception
          When Others Then
            n_已挂数 := 0;
            n_已约数 := 0;
        End;
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
        If n_限号数 <= n_已挂数 Then
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
          Raise Err_Item;
        End If;
      End If;
    
      --没有达到时段的限号数 号码在当前时段往后追加
    
      --获取当天挂出的最大号序
      Select Nvl(Max(序号), 0)
      Into n_挂出的最大序号
      From 临床出诊序号控制 A
      Where 记录id = 出诊记录id_In And 预约顺序号 Is Null And 挂号状态 Not In (0, 5);
      If 预约顺序号_In Is Not Null Then
        n_预约顺序号 := 预约顺序号_In;
      Else
        Begin
          Select Nvl(Max(预约顺序号), 0) + 1
          Into n_预约顺序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Not Null;
        Exception
          When Others Then
            n_预约顺序号 := Null;
        End;
      End If;
      --设置序号
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_预约顺序号;
      If n_预约顺序号 Is Null Then
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
      End If;
    
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(开始时间 - d_时段时间), 0, 1, 0))
        Into n_已用序号, n_已挂数, n_已用数量
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
      Exception
        When Others Then
          n_已用序号 := 0;
          n_已用数量 := 0;
          n_已挂数   := 0;
      End;
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111));
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111));
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
          Begin
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 开始时间), 1, 1, 0))
            Into n_失效数
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And 开始时间 Between Trunc(Sysdate) And Sysdate And Nvl(挂号状态, 0) = 2;
          Exception
            When Others Then
              n_失效数 := 0;
          End;
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        
        Else
          --挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      Begin
        Select 已挂数, 已约数 Into n_已用数量, n_已约数 From 临床出诊记录 Where ID = 出诊记录id_In;
      Exception
        When Others Then
          n_已用数量 := 0;
          n_已约数   := 0;
      End;
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  End If;

  --更新挂号序号状态
  If 序号_In = 1 And Not n_序号 Is Null Then
    If n_分时段 = 1 Then
      d_序号时间 := 发生时间_In;
    Else
      d_序号时间 := Trunc(发生时间_In);
    End If;
    --锁定序号的处理
    Begin
      If n_预约顺序号 Is Null Then
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_序号;
      Else
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号;
      End If;
      n_锁定 := 1;
    Exception
      When Others Then
        v_序号操作员 := Null;
        v_序号机器名 := Null;
        n_锁定       := 0;
    End;
    If n_锁定 = 0 Then
      If n_预约顺序号 Is Null Then
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
        Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
      End If;
      If Sql%RowCount = 0 Then
        Begin
          If Nvl(n_分时段, 0) > 0 Then
            If Nvl(n_序号控制, 0) = 1 Then
              --分时段后专家号 失约的预约号允许挂号
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) In (0, 2);
              If Sql%NotFound Then
                Begin
                  Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                Exception
                  When Others Then
                    n_状态 := 0;
                End;
                If n_状态 = 1 Or n_状态 = 4 Or n_状态 = 5 Then
                  v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                  Raise Err_Item;
                End If;
              
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                  Select 出诊记录id_In, n_序号, d_序号时间, d_序号时间, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1), Null,
                         Null, Null, 操作员姓名_In, '追加号'
                  From Dual;
              End If;
            Else
              If Nvl(预约接收_In, 0) = 1 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注, 预约顺序号)
                  Select 记录id, 序号, 开始时间, 终止时间, 1, 1, Decode(预约挂号_In, 1, 2, 1), Null, Null, Null, 操作员姓名_In, n_序号, n_预约顺序号
                  From 临床出诊序号控制
                  Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Null;
              End If;
            End If;
          Else
            If Nvl(n_序号控制, 0) = 1 Then
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
              Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 0;
            
              If Sql%RowCount = 0 Then
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                  Select 出诊记录id_In, n_序号, 发生时间_In, 发生时间_In, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1), Null,
                         Null, Null, 操作员姓名_In, '追加号'
                  From Dual;
              End If;
            End If;
          End If;
        Exception
          When Others Then
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
            Raise Err_Item;
        End;
      End If;
    Else
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
        Raise Err_Item;
      Else
        If n_预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And 工作站名称 = v_机器名;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And
                工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  End If;

  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      v_结算方式记录 := '';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
          v_Err_Msg := '使用了重复的结算方式,请检查!';
          Raise Err_Item;
        Else
          v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
        End If;
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4,
             v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 卡号_In, Null, 登记时间_In, Null, 结帐id_In,
                              n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 0) = 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In, 0) = 0 Then
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    If Nvl(记帐费用_In, 0) = 0 Then
      --处理票据使用情况
      If 序号_In = 1 And 票据号_In Is Not Null Then
        Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
      
        --发出票据
        Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
      
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Values
          (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, 登记时间_In, 操作员姓名_In);
      
        --状态改动
        Update 票据领用记录
        Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
        Where ID = Nvl(领用id_In, 0);
      End If;
    End If;
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 出诊记录id)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 出诊记录id_In);
  
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Insert;
/


Create Or Replace Procedure Zl_病人挂号记录_更新诊室
(
  No_In       病人挂号记录.No%Type := Null,
  病人id_In   病人挂号记录.病人id%Type := Null,
  诊室_In     病人挂号记录.诊室%Type := Null,
  医生_In     病人挂号记录.执行人%Type := Null,
  分诊时间_In 病人挂号记录.分诊时间%Type := Null,
  更新诊室_In Integer := 1,
  预约方式_In 预约方式.名称%Type := Null
) As
  v_Id           门诊费用记录.Id%Type := Null;
  v_挂号生成队列 Varchar2(2);
  v_排队号码     排队叫号队列.排队号码%Type;
  v_排队序号     排队叫号队列.排队序号%Type;
  n_当天排队     Number(18);
  n_单据性质     病人挂号记录.记录性质%Type;
  n_诊室id       门诊诊室.Id%Type;
  n_排队         Number(18);
  v_Error        Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(更新诊室_In, 0) = 2 Then
    Begin
      Select ID Into v_Id From 病人挂号记录 Where NO = No_In;
      Update 排队叫号队列 Set 诊室 = 诊室_In, 医生姓名 = 医生_In Where 业务id = v_Id;
    Exception
      When Others Then
        Null;
    End;
  Else
    Begin
      Select ID, 记录性质 Into v_Id, n_单据性质 From 病人挂号记录 Where NO = No_In And Nvl(执行状态, 0) = 0;
      Select ID Into n_诊室id From 门诊诊室 Where 名称 = 诊室_In;
    Exception
      When Others Then
        Null;
    End;
    If v_Id Is Null Then
      v_Error := '病人已经接诊或已经退号，不能再分诊。';
      Raise Err_Custom;
    End If;
    If Nvl(更新诊室_In, 0) = 1 Then
      If Nvl(病人id_In, 0) <> 0 Then
        --更新病人信息
        Update 病人信息 Set 就诊诊室 = 诊室_In Where 病人id = 病人id_In And 就诊状态 = 1;
      End If;
    
      --更新费用记录
      Update 门诊费用记录
      Set 发药窗口 = 诊室_In, 执行人 = 医生_In
      Where 记录性质 = 4 And 记录状态 = Decode(Nvl(n_单据性质, 0), 2, 0, 1) And NO = No_In;
      --更新病人挂号记录
      Update 病人挂号记录
      Set 诊室 = 诊室_In, 执行人 = 医生_In, 分诊时间 = Decode(分诊时间_In, Null, 分诊时间, 分诊时间_In)
      Where NO = No_In;
    End If;
    v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
    If v_挂号生成队列 <> 0 Then
      For c_挂号 In (Select ID, 执行部门id, 姓名, 诊室_In As 诊室, 登记时间, 医生_In As 执行人, 病人id, 号别, 号序
                   From 病人挂号记录
                   Where NO = No_In And Rownum = 1) Loop
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = c_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
      
        If n_排队 = 0 Then
          --新增排队
          --产生队列
          --.按”执行部门” 的方式生成队列
          v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 0);
          --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
          Zl_排队叫号队列_Insert(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, v_排队号码, Null, c_挂号.姓名, c_挂号.病人id, c_挂号.诊室, c_挂号.执行人,
                           Nvl(分诊时间_In, Sysdate), 预约方式_In, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(c_挂号.执行部门id, c_挂号.Id, c_挂号.号别 || '|' || Nvl(c_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, c_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(c_挂号.执行部门id, 0, c_挂号.Id, c_挂号.执行部门id, c_挂号.姓名, c_挂号.诊室, c_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_更新诊室;
/

Create Or Replace Procedure Zl_病人挂号记录_换号
(
  No_In         病人挂号记录.No%Type,
  号别_In       病人挂号记录.号别%Type,
  诊室_In       病人挂号记录.诊室%Type,
  科室id_In     病人挂号记录.执行部门id%Type,
  原医生_In     病人挂号记录.执行人%Type,
  原医生id_In   病人挂号汇总.医生id%Type,
  新医生_In     病人挂号记录.执行人%Type,
  新医生id_In   病人挂号汇总.医生id%Type,
  出诊记录id_In 临床出诊记录.Id%Type := Null
  --功能：完成病人换号功能，在挂号项目ID相同的情况下。
) As
  Cursor c_Bill Is
    Select ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别,
           收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In
    Order By 序号;

  v_病人id       门诊费用记录.Id%Type;
  v_现队列名称   排队叫号队列.队列名称%Type;
  v_挂号生成队列 Varchar2(2);
  v_预约挂号     Number(2);
  n_业务id       病人挂号记录.Id%Type;
  v_排队号码     排队叫号队列.排队号码%Type;
  v_号别         病人挂号记录.号别%Type;
  n_号序         病人挂号记录.号序%Type;
  v_排队序号     排队叫号队列.排队序号%Type;
  v_Temp         Varchar2(500);
  v_操作员编号   就诊变动记录.操作员编号%Type;
  v_操作员姓名   就诊变动记录.操作员姓名%Type;
  n_医生id       人员表.Id%Type;
  n_诊室id       门诊诊室.Id%Type;
  n_原出诊记录id 临床出诊记录.Id%Type;
  v_Error        Varchar2(255);
  Err_Custom Exception;
Begin
  v_病人id := 0;
  If 出诊记录id_In Is Null Then
    Begin
      Select 病人id Into v_病人id From 病人挂号记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    Exception
      When Others Then
        Null;
    End;
    If v_病人id = 0 Then
      v_Error := '没有找到病人的挂号信息。';
      Raise Err_Custom;
    Elsif v_病人id Is Null Then
      v_Error := '没有找到病人信息。';
      Raise Err_Custom;
    End If;
  
    ---先更新病人信息的就诊诊室和状态
    Update 病人信息 Set 就诊诊室 = 诊室_In, 就诊状态 = 1 Where 病人id = v_病人id And 就诊状态 In (1, 2);
  
    For r_Bill In c_Bill Loop
      If r_Bill.序号 = 1 Then
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1) Into v_预约挂号 From 病人挂号记录 Where NO = r_Bill.No And Rownum = 1;
        Exception
          When Others Then
            v_预约挂号 := 0;
        End;
      
        --恢复以前的挂号汇总
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - v_预约挂号, 已约数 = Nvl(已约数, 0) - v_预约挂号
        Where 日期 = Trunc(r_Bill.登记时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
              (号码 = r_Bill.计算单位 Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Trunc(r_Bill.登记时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生_In, Decode(原医生id_In, 0, Null, 原医生id_In), r_Bill.计算单位,
             -1, -1 * v_预约挂号, -1 * v_预约挂号);
        End If;
      
        ----然后再更新挂号汇总
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + v_预约挂号, 已约数 = Nvl(已约数, 0) + v_预约挂号
        Where 日期 = Trunc(r_Bill.登记时间) And Nvl(科室id, 0) = 科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
              (号码 = 号别_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Trunc(r_Bill.登记时间), 科室id_In, r_Bill.收费细目id, 新医生_In, Decode(新医生id_In, 0, Null, 新医生id_In), 号别_In, 1, v_预约挂号,
             v_预约挂号);
        End If;
      End If;
    
      ---更新挂号记录
      Update 门诊费用记录
      Set 执行部门id = 科室id_In, 病人科室id = 科室id_In, 计算单位 = 号别_In, 发药窗口 = 诊室_In,
          --病人病区id = 科室id_In,
          执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null
      Where ID = r_Bill.Id;
    
      --更新病人挂号记录
      If r_Bill.序号 = 1 Then
        v_Temp := Zl_Identity(1);
        Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
        Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
        Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
        Begin
          Select ID Into n_医生id From 人员表 Where 姓名 = 新医生_In And Rownum < 2;
        Exception
          When Others Then
            n_医生id := Null;
        End;
        Zl_就诊变动记录_Insert(r_Bill.No, 2, '分诊换号', v_操作员姓名, v_操作员编号, 号别_In, 科室id_In, Null, n_医生id, 新医生_In, 诊室_In, n_号序,
                         Null);
        v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If v_挂号生成队列 <> 0 Then
          v_现队列名称 := 科室id_In;
          Select ID, 号别, Nvl(号序, 0)
          Into n_业务id, v_号别, n_号序
          From 病人挂号记录
          Where NO = r_Bill.No And Rownum = 1;
          --Zlgetnextqueue(执行部门id_In Number,业务id_In     Number := Null)
          v_排队号码 := Zlgetnextqueue(科室id_In, n_业务id, v_号别 || '|' || n_号序);
          v_排队序号 := Zlgetsequencenum(0, n_业务id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In
          Zl_排队叫号队列_Update(v_现队列名称, 0, n_业务id, 科室id_In, r_Bill.姓名, 诊室_In, 新医生_In, v_排队号码, v_排队序号);
        End If;
        Update 病人挂号记录
        Set 执行部门id = 科室id_In, 号别 = 号别_In, 诊室 = 诊室_In, 执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null
        Where NO = r_Bill.No;
      End If;
    End Loop;
  Else
    --出诊表排班模式
    Begin
      Select 病人id, 出诊记录id
      Into v_病人id, n_原出诊记录id
      From 病人挂号记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      Select ID Into n_诊室id From 门诊诊室 Where 名称 = 诊室_In;
    Exception
      When Others Then
        Null;
    End;
    If v_病人id = 0 Then
      v_Error := '没有找到病人的挂号信息。';
      Raise Err_Custom;
    Elsif v_病人id Is Null Then
      v_Error := '没有找到病人信息。';
      Raise Err_Custom;
    End If;
  
    ---先更新病人信息的就诊诊室和状态
    Update 病人信息 Set 就诊诊室 = 诊室_In, 就诊状态 = 1 Where 病人id = v_病人id And 就诊状态 In (1, 2);
  
    For r_Bill In c_Bill Loop
      If r_Bill.序号 = 1 Then
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1) Into v_预约挂号 From 病人挂号记录 Where NO = r_Bill.No And Rownum = 1;
        Exception
          When Others Then
            v_预约挂号 := 0;
        End;
      
        --恢复以前的挂号汇总
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - v_预约挂号, 已约数 = Nvl(已约数, 0) - v_预约挂号
        Where 日期 = Trunc(r_Bill.登记时间) And Nvl(医生id, 0) = Nvl(原医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(原医生_In, '-') And
              Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
              (号码 = r_Bill.计算单位 Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Trunc(r_Bill.登记时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生_In, Decode(原医生id_In, 0, Null, 原医生id_In), r_Bill.计算单位,
             -1, -1 * v_预约挂号, -1 * v_预约挂号);
        End If;
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - v_预约挂号, 已约数 = Nvl(已约数, 0) - v_预约挂号
        Where ID = n_原出诊记录id;
      
        ----然后再更新挂号汇总
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + v_预约挂号, 已约数 = Nvl(已约数, 0) + v_预约挂号
        Where 日期 = Trunc(r_Bill.登记时间) And Nvl(科室id, 0) = 科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
              (号码 = 号别_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
          Values
            (Trunc(r_Bill.登记时间), 科室id_In, r_Bill.收费细目id, 新医生_In, Decode(新医生id_In, 0, Null, 新医生id_In), 号别_In, 1, v_预约挂号,
             v_预约挂号);
        End If;
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) + 1, 其中已接收 = Nvl(其中已接收, 0) + v_预约挂号, 已约数 = Nvl(已约数, 0) + v_预约挂号
        Where ID = 出诊记录id_In;
      End If;
    
      ---更新挂号记录
      Update 门诊费用记录
      Set 执行部门id = 科室id_In, 病人科室id = 科室id_In, 计算单位 = 号别_In, 发药窗口 = 诊室_In,
          --病人病区id = 科室id_In,
          执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null
      Where ID = r_Bill.Id;
    
      --更新病人挂号记录
      If r_Bill.序号 = 1 Then
        v_Temp := Zl_Identity(1);
        Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
        Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
        Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
        Begin
          Select ID Into n_医生id From 人员表 Where 姓名 = 新医生_In And Rownum < 2;
        Exception
          When Others Then
            n_医生id := Null;
        End;
        Zl_就诊变动记录_Insert(r_Bill.No, 2, '分诊换号', v_操作员姓名, v_操作员编号, 号别_In, 科室id_In, Null, n_医生id, 新医生_In, 诊室_In, n_号序,
                         Null);
        v_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If v_挂号生成队列 <> 0 Then
          v_现队列名称 := 科室id_In;
          Select ID, 号别, Nvl(号序, 0)
          Into n_业务id, v_号别, n_号序
          From 病人挂号记录
          Where NO = r_Bill.No And Rownum = 1;
          --Zlgetnextqueue(执行部门id_In Number,业务id_In     Number := Null)
          v_排队号码 := Zlgetnextqueue(科室id_In, n_业务id, v_号别 || '|' || n_号序);
          v_排队序号 := Zlgetsequencenum(0, n_业务id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In , 医生姓名_In
          Zl_排队叫号队列_Update(v_现队列名称, 0, n_业务id, 科室id_In, r_Bill.姓名, 诊室_In, 新医生_In, v_排队号码, v_排队序号);
        End If;
        Update 病人挂号记录
        Set 执行部门id = 科室id_In, 号别 = 号别_In, 诊室 = 诊室_In, 执行人 = 新医生_In, 执行状态 = 0, 执行时间 = Null, 出诊记录id = 出诊记录id_In
        Where NO = r_Bill.No;
      End If;
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_换号;
/


Create Or Replace Procedure Zl_病人挂号记录_批量换号
(
  Nos_In        In Varchar2 := Null,
  新号别_In     In 病人挂号记录.号别%Type := Null,
  新医生姓名_In In 挂号安排.医生姓名%Type := Null,
  新医生id_In   In 挂号安排.医生id%Type := Null,
  新科室id_In   In 挂号安排.科室id%Type := Null,
  原医生姓名_In In 挂号安排.医生姓名%Type := Null,
  原医生id_In   In 挂号安排.医生id%Type := Null,
  原号别_In     In 病人挂号记录.号别%Type := Null,
  操作员姓名_In In 挂号序号状态.操作员姓名%Type := Null,
  原出诊id_In   In 临床出诊记录.Id%Type := Null,
  新出诊id_In   In 临床出诊记录.Id%Type := Null
  --功能: 完成病人批量换号功能,在挂号项目相同,限号数相同,限约数相同,科室相同的情况下。
  --参数说明:  Nos_In :需要跟换排班的病人挂号记录单据集:格式: M000001|M000002|..........
) As
  --获取对应挂号记录的门诊费用记录信息
  Cursor c_Bill(c_No 病人挂号记录.No%Type) Is
    Select ID, 序号, NO, 发生时间, 执行部门id, 收费细目id, 计算单位
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (0, 1) And NO = c_No
    Order By 序号;
  --获取相应排班的分诊诊室
  Cursor c_平均分诊(c_指定分诊号表id 挂号安排.Id%Type) Is
    Select 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = c_指定分诊号表id;
  Cursor c_出诊平均分诊 Is
    Select 记录id, 诊室id, 当前分配 From 临床出诊诊室记录 Where 记录id = 新出诊id_In;

  --变量定义
  r_平均分诊         挂号安排诊室%RowType;
  r_出诊平均分诊     临床出诊诊室记录%RowType;
  r_Bill             c_Bill%RowType;
  v_Nos              Varchar(2000);
  v_No               病人挂号记录.No%Type;
  n_病人id           病人挂号记录.病人id%Type;
  n_原序号           病人挂号记录.号序%Type;
  d_原就诊日期       病人挂号记录.预约时间%Type;
  n_是否已被挂出     Number(1);
  n_记录性质         Number(1);
  n_预约             Number(1);
  n_挂号状态         Number(1); --0-正常挂号:1-预约挂号;2-预约挂号接收
  v_新就诊诊室       病人信息.就诊诊室%Type;
  n_分诊方式         Number(1); --0-不分诊:1-指定分诊:2-动态分诊:3-平均分诊
  n_指定分诊号表id   Number(10);
  n_分诊诊室数量     Number(3);
  n_是否找到分诊诊室 Number(1); --0:未找到:1-找到但分配标识未更改:2-修改第一条数据标识
  n_Index            Number(1); --当前记录集的索引值
  v_现队列名称       排队叫号队列.队列名称%Type;
  n_挂号生成队列     Number;
  n_预约生成队列     Number;
  v_排队号码         排队叫号队列.排队号码%Type;
  n_业务id           病人挂号记录.Id%Type;
  v_Temp             Varchar2(500);
  v_操作员编号       就诊变动记录.操作员编号%Type;
  v_操作员姓名       就诊变动记录.操作员姓名%Type;
  n_医生id           人员表.Id%Type;
  v_Error            Varchar2(255);
  n_出诊记录id       临床出诊记录.Id%Type;
  Err_Custom Exception;
Begin
  If 原出诊id_In Is Null Then
    --计划排班模式
    --检查是否存在该挂号记录
    If Nos_In Is Not Null Then
      v_Nos := Nos_In || '|';
      While v_Nos Is Not Null Loop
        --初始化变量
        n_病人id           := 0;
        n_原序号           := 0;
        d_原就诊日期       := Null;
        n_是否已被挂出     := 0;
        n_记录性质         := 0;
        n_预约             := 0;
        n_挂号状态         := 0;
        v_新就诊诊室       := '';
        n_分诊方式         := 0;
        n_指定分诊号表id   := 0;
        v_现队列名称       := '';
        v_排队号码         := '';
        n_业务id           := 0;
        n_分诊诊室数量     := 0;
        n_挂号生成队列     := 0;
        n_预约生成队列     := 0;
        n_是否找到分诊诊室 := 0;
        n_Index            := 0;
      
        v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
        v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
        --检查是否存在该挂号记录
        Begin
          Select a.Id, a.病人id, a.号序, Nvl(b.日期, Nvl(a.预约时间, a.发生时间)), a.记录性质, Nvl(a.预约, 0)
          Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约
          From 病人挂号记录 A, 挂号序号状态 B
          Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1 And a.号别 = b.号码(+) And
                Trunc(Nvl(预约时间, 发生时间)) = Trunc(b.日期(+)) And a.号序 = b.序号(+);
        Exception
          When Others Then
            Null;
        End;
        If n_病人id = 0 Then
          v_Error := '没有找到病人的挂号信息';
          Raise Err_Custom;
        End If;
        --判断当前挂号状态
        n_挂号状态 := 0; --正常挂号
        If n_记录性质 = 1 And n_预约 = 1 Then
          n_挂号状态 := 2; --预约接收
        End If;
        If n_记录性质 = 2 And n_预约 = 1 Then
          n_挂号状态 := 1; --预约
        End If;
      
        --检查换号的新号别是否已被挂出
        Begin
          Select a.状态
          Into n_是否已被挂出
          From 挂号序号状态 A
          Where a.日期 = d_原就诊日期 And a.号码 = 新号别_In And a.序号 = n_原序号;
        Exception
          When Others Then
            n_是否已被挂出 := 0;
        End;
        If n_是否已被挂出 > 0 Then
          v_Error := '要换的号别已被挂出';
          Raise Err_Custom;
        End If;
        --预约接收的情况下进行分诊诊室的获取
        If n_挂号状态 = 2 Then
          --获取新号别诊室
          --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
          --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
          --获取分诊方式
          Begin
            Select ID, Nvl(分诊方式, 0) Into n_指定分诊号表id, n_分诊方式 From 挂号安排 Where 号码 = 新号别_In;
          Exception
            When Others Then
              n_分诊方式       := 0;
              n_指定分诊号表id := 0;
          End;
        
          Begin
            If n_分诊方式 = 0 Then
              --不分诊
              v_新就诊诊室 := '';
            End If;
            If n_分诊方式 = 1 Then
              --指定分诊
              Select 门诊诊室 Into v_新就诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
            End If;
            If n_分诊方式 = 2 Then
              --动态分诊
              Select 门诊诊室
              Into v_新就诊诊室
              From (Select 门诊诊室, Sum(Num) As Num
                     From (Select 门诊诊室, 0 As Num
                            From 挂号安排诊室
                            Where 号表id = n_指定分诊号表id
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                  号别 = 新号别_In And 诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_指定分诊号表id)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num)
              Where Rownum = 1;
            End If;
            If n_分诊方式 = 3 Then
              --平均分诊
              --获取当前安排下的诊室数量
              Select Count(1) Into n_分诊诊室数量 From 挂号安排诊室 Where 号表id = n_指定分诊号表id;
            
              Open c_平均分诊(n_指定分诊号表id);
              Loop
                Fetch c_平均分诊
                  Into r_平均分诊;
                Exit When c_平均分诊%NotFound;
                n_Index := n_Index + 1;
                --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
                If n_是否找到分诊诊室 = 1 Then
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End If;
              
                If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                  Update 挂号安排诊室
                  Set 当前分配 = 0
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  n_是否找到分诊诊室 := 1;
                End If;
              
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              End Loop;
              Close c_平均分诊;
              --重置索引值
              n_Index := 0;
              --第一次分诊
              If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
                Open c_平均分诊(n_指定分诊号表id);
                Loop
                  Fetch c_平均分诊
                    Into r_平均分诊;
                  Exit When c_平均分诊%NotFound;
                  n_Index := n_Index + 1;
                
                  If n_是否找到分诊诊室 = 1 Then
                    Update 挂号安排诊室
                    Set 当前分配 = 1
                    Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                    Exit;
                  End If;
                
                  Update 挂号安排诊室
                  Set 当前分配 = 0
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                
                  n_是否找到分诊诊室 := 1;
                  If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                
                  If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                    --游标已经到了最后,所以需从第一条数据开始修改标识
                    If n_Index >= n_分诊诊室数量 Then
                      n_是否找到分诊诊室 := 2;
                      Exit;
                    End If;
                  End If;
                
                End Loop;
                Close c_平均分诊;
              End If;
            
              If n_是否找到分诊诊室 = 2 Then
                Open c_平均分诊(n_指定分诊号表id);
                Loop
                  Fetch c_平均分诊
                    Into r_平均分诊;
                  Exit When c_平均分诊%NotFound;
                  Update 挂号安排诊室
                  Set 当前分配 = 1
                  Where 号表id = r_平均分诊.号表id And 门诊诊室 = r_平均分诊.门诊诊室;
                  Exit;
                End Loop;
                Close c_平均分诊;
              End If;
            End If;
          Exception
            When Others Then
              v_新就诊诊室 := '';
          End;
        End If;
      
        --更新病人信息的就诊诊室和状态
        Update 病人信息 Set 就诊诊室 = v_新就诊诊室, 就诊状态 = 1 Where 病人id = n_病人id And 就诊状态 In (1, 2);
      
        --打开游标
        Open c_Bill(v_No);
        Loop
          Fetch c_Bill
            Into r_Bill;
          Exit When c_Bill%NotFound;
          If r_Bill.序号 = 1 Then
            --需要确定是否预约挂号
            --1.如果是预约挂号产生的挂号记录,则需要减已约数
            --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
            --3.如果是正常挂号,则只减已挂数
            --恢复以前的挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And
                  Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And (号码 = r_Bill.计算单位 Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
                 r_Bill.计算单位, 0, 0, 0);
            End If;
          
            ----然后再更新挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
                 
                  (号码 = 新号别_In Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
                 Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
            End If;
          End If;
        
          ---更新挂号记录
          If n_挂号状态 = 1 Then
            --预约
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          Else
            --挂号或接收
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          End If;
        
          --更新病人挂号记录
          If r_Bill.序号 = 1 Then
            v_Temp := Zl_Identity(1);
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
            Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
            Begin
              Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
            Exception
              When Others Then
                n_医生id := Null;
            End;
            Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                             n_原序号, Null);
            --修改队列信息
            Update 排队叫号队列
            Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
            Where 业务id = n_业务id And 业务类型 = 0;
          
            Update 病人挂号记录
            Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号
            Where NO = r_Bill.No;
            --修改挂号序号状态
            If n_原序号 Is Not Null Then
              --1.恢复以前挂号序号状态
              Delete 挂号序号状态 Where 日期 = d_原就诊日期 And 序号 = n_原序号 And 号码 = 原号别_In;
              --2.新增换号后挂号序号状态
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 操作员姓名, 状态, 预约, 登记时间)
              Values
                (新号别_In, d_原就诊日期, n_原序号, 操作员姓名_In, Decode(n_挂号状态, 1, 2, 1), Decode(n_挂号状态, 0, 0, 1), Sysdate);
            End If;
          End If;
        End Loop;
        Close c_Bill;
      End Loop;
    End If;
  Else
    --出诊表排班模式
    --检查是否存在该挂号记录
    If Nos_In Is Not Null Then
      v_Nos := Nos_In || '|';
      While v_Nos Is Not Null Loop
        --初始化变量
        n_病人id           := 0;
        n_原序号           := 0;
        d_原就诊日期       := Null;
        n_是否已被挂出     := 0;
        n_记录性质         := 0;
        n_预约             := 0;
        n_挂号状态         := 0;
        v_新就诊诊室       := '';
        n_分诊方式         := 0;
        n_指定分诊号表id   := 0;
        v_现队列名称       := '';
        v_排队号码         := '';
        n_业务id           := 0;
        n_分诊诊室数量     := 0;
        n_挂号生成队列     := 0;
        n_预约生成队列     := 0;
        n_是否找到分诊诊室 := 0;
        n_Index            := 0;
      
        v_No  := Substr(v_Nos, 1, Instr(v_Nos, '|') - 1);
        v_Nos := Substr(v_Nos, Instr(v_Nos, '|') + 1);
        --检查是否存在该挂号记录
        Begin
          Select a.Id, a.病人id, a.号序, Nvl(b.开始时间, Nvl(a.预约时间, a.发生时间)), a.记录性质, Nvl(a.预约, 0), a.出诊记录id
          Into n_业务id, n_病人id, n_原序号, d_原就诊日期, n_记录性质, n_预约, n_出诊记录id
          From 病人挂号记录 A, 临床出诊序号控制 B
          Where NO = v_No And 记录性质 In (1, 2) And 记录状态 = 1 And a.号序 = b.序号(+) And a.出诊记录id = b.记录id(+);
        Exception
          When Others Then
            Null;
        End;
        If n_病人id = 0 Then
          v_Error := '没有找到病人的挂号信息';
          Raise Err_Custom;
        End If;
        --判断当前挂号状态
        n_挂号状态 := 0; --正常挂号
        If n_记录性质 = 1 And n_预约 = 1 Then
          n_挂号状态 := 2; --预约接收
        End If;
        If n_记录性质 = 2 And n_预约 = 1 Then
          n_挂号状态 := 1; --预约
        End If;
      
        --检查换号的新号别是否已被挂出
        Begin
          Select a.挂号状态
          Into n_是否已被挂出
          From 临床出诊序号控制 A
          Where a.记录id = 新出诊id_In And a.序号 = n_原序号;
        Exception
          When Others Then
            n_是否已被挂出 := 0;
        End;
        If n_是否已被挂出 > 0 Then
          v_Error := '要换的号别已被挂出';
          Raise Err_Custom;
        End If;
        --预约接收的情况下进行分诊诊室的获取
        If n_挂号状态 = 2 Then
          --获取新号别诊室
          --说明:预约的情况下，不需要分诊，因此不用获取就诊诊室
          --     接收的情况下,需要进行分诊,因此需要获取接诊诊室
          --获取分诊方式
          Begin
            Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 新出诊id_In;
          Exception
            When Others Then
              n_分诊方式 := 0;
          End;
        
          Begin
            If n_分诊方式 = 0 Then
              --不分诊
              v_新就诊诊室 := '';
            End If;
            If n_分诊方式 = 1 Then
              --指定分诊
              Select b.名称
              Into v_新就诊诊室
              From 临床出诊诊室记录 A, 门诊诊室 B
              Where a.诊室id = b.Id And a.记录id = 新出诊id_In;
            End If;
            If n_分诊方式 = 2 Then
              --动态分诊
              Select 门诊诊室
              Into v_新就诊诊室
              From (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.记录id = 新出诊id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 记录性质 = 1 And 记录状态 = 1 And 发生时间 Between Trunc(Sysdate) And Sysdate And
                                  号别 = 新号别_In And 诊室 In (Select b.名称
                                                         From 临床出诊诊室记录 A, 门诊诊室 B
                                                         Where a.诊室id = b.Id And a.记录id = 新出诊id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num)
              Where Rownum = 1;
            End If;
            If n_分诊方式 = 3 Then
              --平均分诊
              --获取当前安排下的诊室数量
              Select Count(1) Into n_分诊诊室数量 From 临床出诊诊室记录 Where 记录id = 新出诊id_In;
            
              Open c_出诊平均分诊;
              Loop
                Fetch c_出诊平均分诊
                  Into r_出诊平均分诊;
                Exit When c_出诊平均分诊%NotFound;
                n_Index := n_Index + 1;
                --找到了对应的分诊诊室,需要修改下一个诊室的当前分配为1(代表该诊室是下一次的分诊诊室)
                If n_是否找到分诊诊室 = 1 Then
                  Update 临床出诊诊室记录
                  Set 当前分配 = 1
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  Exit;
                End If;
              
                If Nvl(r_平均分诊.当前分配, 0) = 1 Then
                  v_新就诊诊室 := r_平均分诊.门诊诊室;
                  Update 临床出诊诊室记录
                  Set 当前分配 = 0
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  n_是否找到分诊诊室 := 1;
                End If;
              
                If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                  n_是否找到分诊诊室 := 2;
                  Exit;
                End If;
                If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                  --游标已经到了最后,所以需从第一条数据开始修改标识
                  If n_Index >= n_分诊诊室数量 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                End If;
              End Loop;
              Close c_出诊平均分诊;
              --重置索引值
              n_Index := 0;
              --第一次分诊
              If Nvl(v_新就诊诊室, ' ') = ' ' Or v_新就诊诊室 Is Null Then
                Open c_出诊平均分诊;
                Loop
                  Fetch c_出诊平均分诊
                    Into r_出诊平均分诊;
                  Exit When c_出诊平均分诊%NotFound;
                  n_Index := n_Index + 1;
                
                  If n_是否找到分诊诊室 = 1 Then
                    Update 临床出诊诊室记录
                    Set 当前分配 = 1
                    Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                    Exit;
                  End If;
                
                  Update 临床出诊诊室记录
                  Set 当前分配 = 0
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  v_新就诊诊室 := r_出诊平均分诊.诊室id;
                
                  n_是否找到分诊诊室 := 1;
                  If n_分诊诊室数量 = 1 And n_是否找到分诊诊室 = 1 Then
                    n_是否找到分诊诊室 := 2;
                    Exit;
                  End If;
                
                  If n_分诊诊室数量 > 1 And n_是否找到分诊诊室 = 1 Then
                    --游标已经到了最后,所以需从第一条数据开始修改标识
                    If n_Index >= n_分诊诊室数量 Then
                      n_是否找到分诊诊室 := 2;
                      Exit;
                    End If;
                  End If;
                
                End Loop;
                Close c_出诊平均分诊;
              End If;
            
              If n_是否找到分诊诊室 = 2 Then
                Open c_出诊平均分诊;
                Loop
                  Fetch c_出诊平均分诊
                    Into r_出诊平均分诊;
                  Exit When c_出诊平均分诊%NotFound;
                  Update 临床出诊诊室记录
                  Set 当前分配 = 1
                  Where 记录id = r_出诊平均分诊.记录id And 诊室id = r_出诊平均分诊.诊室id;
                  Exit;
                End Loop;
                Close c_出诊平均分诊;
              End If;
            End If;
          Exception
            When Others Then
              v_新就诊诊室 := '';
          End;
        End If;
      
        --更新病人信息的就诊诊室和状态
        Update 病人信息
        Set 就诊诊室 =
             (Select 名称 From 门诊诊室 Where ID = v_新就诊诊室), 就诊状态 = 1
        Where 病人id = n_病人id And 就诊状态 In (1, 2);
      
        --打开游标
        Open c_Bill(v_No);
        Loop
          Fetch c_Bill
            Into r_Bill;
          Exit When c_Bill%NotFound;
          If r_Bill.序号 = 1 Then
            --需要确定是否预约挂号
            --1.如果是预约挂号产生的挂号记录,则需要减已约数
            --2.如果是预约挂号为接收的挂号记录,则需要减已挂数和其中已接收数
            --3.如果是正常挂号,则只减已挂数
            --恢复以前的挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(医生id, 0) = Nvl(原医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(原医生姓名_In, '-') And
                  Nvl(科室id, 0) = Nvl(r_Bill.执行部门id, 0) And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And
                  (号码 = r_Bill.计算单位 Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), r_Bill.执行部门id, r_Bill.收费细目id, 原医生姓名_In, Decode(原医生id_In, 0, Null, 原医生id_In),
                 r_Bill.计算单位, 0, 0, 0);
            End If;
          
            Update 临床出诊记录
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, -1, 2, -1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, -1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, -1)
            Where ID = 原出诊id_In;
          
            ----然后再更新挂号汇总
            Update 病人挂号汇总
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where 日期 = Trunc(r_Bill.发生时间) And Nvl(医生id, 0) = Nvl(新医生id_In, 0) And Nvl(医生姓名, '-') = Nvl(新医生姓名_In, '-') And
                  Nvl(科室id, 0) = 新科室id_In And Nvl(项目id, 0) = Nvl(r_Bill.收费细目id, 0) And (号码 = 新号别_In Or 号码 Is Null);
            If Sql%RowCount = 0 Then
              Insert Into 病人挂号汇总
                (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 已约数, 其中已接收)
              Values
                (Trunc(r_Bill.发生时间), 新科室id_In, r_Bill.收费细目id, 新医生姓名_In, Decode(新医生id_In, 0, Null, 新医生id_In), 新号别_In,
                 Decode(n_挂号状态, 0, 1, 2, 1, 0), Decode(n_挂号状态, 0, 0, 1), Decode(n_挂号状态, 2, 1, 0));
            End If;
            Update 临床出诊记录
            Set 已挂数 = Nvl(已挂数, 0) + Decode(n_挂号状态, 0, 1, 2, 1, 0), 其中已接收 = Nvl(其中已接收, 0) + Decode(n_挂号状态, 2, 1, 0),
                已约数 = Nvl(已约数, 0) + Decode(n_挂号状态, 0, 0, 1)
            Where ID = 新出诊id_In;
          End If;
        
          ---更新挂号记录
          If n_挂号状态 = 1 Then
            --预约
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = n_原序号,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          Else
            --挂号或接收
            Update 门诊费用记录
            Set 执行部门id = 新科室id_In, 病人科室id = 新科室id_In, 计算单位 = 新号别_In, 发药窗口 = v_新就诊诊室,
                --病人病区id = 科室id_In,
                执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null
            Where ID = r_Bill.Id;
          End If;
        
          --更新病人挂号记录
          If r_Bill.序号 = 1 Then
            v_Temp := Zl_Identity(1);
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
            Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
            Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
            Begin
              Select ID Into n_医生id From 人员表 Where 姓名 = 新医生姓名_In And Rownum < 2;
            Exception
              When Others Then
                n_医生id := Null;
            End;
            Zl_就诊变动记录_Insert(r_Bill.No, 1, '批量换号', v_操作员姓名, v_操作员编号, 新号别_In, 新科室id_In, Null, n_医生id, 新医生姓名_In, v_新就诊诊室,
                             n_原序号, Null);
            --修改队列信息
            Update 排队叫号队列
            Set 医生姓名 = 新医生姓名_In, 诊室 = v_新就诊诊室
            Where 业务id = n_业务id And 业务类型 = 0;
          
            Update 病人挂号记录
            Set 执行部门id = 新科室id_In, 号别 = 新号别_In, 诊室 = v_新就诊诊室, 执行人 = 新医生姓名_In, 执行状态 = 0, 执行时间 = Null, 号序 = n_原序号,
                出诊记录id = 新出诊id_In
            Where NO = r_Bill.No;
            --修改挂号序号状态
            If n_原序号 Is Not Null Then
              --1.恢复以前挂号序号状态
              Update 临床出诊序号控制
              Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
              Where 记录id = 原出诊id_In And 序号 = n_原序号;
              --2.新增换号后挂号序号状态
              Update 临床出诊序号控制
              Set 挂号状态 = Decode(n_挂号状态, 1, 2, 1), 操作员姓名 = v_操作员姓名, 工作站ip = Null, 工作站名称 = Null
              Where 记录id = 新出诊id_In And 序号 = n_原序号;
            End If;
          End If;
        End Loop;
        Close c_Bill;
      End Loop;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_批量换号;
/


Create Or Replace Procedure Zl_病人接诊完成
(
  病人id_In 病人信息.病人id%Type,
  No_In     病人挂号记录.No%Type,
  诊室_In   病人挂号记录.诊室%Type := Null,
  执行人_In 病人挂号记录.执行人%Type := Null,
  摘要_In   病人挂号记录.摘要%Type := Null,
  护士_In   病人挂号记录.附加标志%Type := Null
) As
  v_挂号id     病人挂号记录.Id%Type;
  v_执行部门id 病人挂号记录.执行部门id%Type;
  v_接诊时间   病人挂号记录.执行时间%Type;
  v_完成时间   病人挂号记录.执行时间%Type;
  v_类别       Varchar2(100);
  n_诊室id     门诊诊室.Id%Type;
Begin
  v_完成时间 := Sysdate;

  Update 病人信息 Set 就诊状态 = 0 Where 病人id = 病人id_In And 就诊状态 In (1, 2); --1-等待就诊,2-正在就诊;
  Begin
    Select ID Into n_诊室id From 门诊诊室 Where 名称 = 诊室_In;
  Exception
    When Others Then
      Null;
  End;
  --执行时间保持了挂号记录一致
  Update 门诊费用记录
  Set 执行人 = Decode(执行人_In, Null, 执行人, 执行人_In), 执行状态 = 1, 发药窗口 = 诊室_In, 结论 = Decode(摘要_In, Null, 结论, 摘要_In), 婴儿费 = 护士_In
  Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3) And Nvl(执行状态, 0) In (0, 2);

  --病人挂号记录
  Update 病人挂号记录
  Set 执行人 = Decode(执行人_In, Null, 执行人, 执行人_In), 执行状态 = 1, 诊室 = 诊室_In, 完成时间 = v_完成时间, 摘要 = Decode(摘要_In, Null, 摘要, 摘要_In),
      附加标志 = 护士_In
  Where NO = No_In And Nvl(执行状态, 0) In (0, 2) And 记录状态 = 1 And 记录性质 = 1
  Returning ID, 执行部门id, 执行时间, Decode(复诊, 1, '复诊', Decode(急诊, 1, '急诊', '门诊')) Into v_挂号id, v_执行部门id, v_接诊时间, v_类别;

  If v_挂号id Is Not Null Then
    --并发操作时，可能本次调用没有进行Update操作，就没有返回值
    --接诊后,排队叫号更新为完成
    Update 排队叫号队列 Set 排队状态 = 4 Where 业务类型 = 0 And 业务id = v_挂号id;
  
    --病历时机处理
    Zl_电子病历时机_Insert(病人id_In, v_挂号id, 1, v_类别, v_执行部门id, 执行人_In, v_接诊时间, v_完成时间);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊完成;
/


Create Or Replace Procedure Zl_病人预约挂号_Clear As
  v_预约天数     Number;
  v_操作员姓名   人员表.姓名 %Type;
  v_操作员编号   人员表.编号%Type;
  n_挂号id       病人挂号记录.Id%Type;
  n_挂号排班模式 Number(3);
  n_出诊记录id   临床出诊记录.Id%Type;
  Cursor c_Clear Is
    Select a.No, a.发生时间, b.科室id, b.项目id, b.医生姓名, b.医生id, b.号码
    From 门诊费用记录 A, 挂号安排 B
    Where a.计算单位 = b.号码 And a.记录性质 = 4 And a.记录状态 = 0 And a.序号 = 1 And 登记时间 >= Sysdate - v_预约天数 And
          发生时间 < Trunc(Sysdate);
  Cursor c_出诊clear Is
    Select b.Id, a.No, a.发生时间, d.科室id, b.项目id, b.医生姓名, b.医生id, d.号码, c.号序
    From 门诊费用记录 A, 临床出诊记录 B, 病人挂号记录 C, 临床出诊号源 D
    Where a.No = c.No And c.出诊记录id = b.Id And b.号源id = d.Id And a.记录性质 = 4 And a.记录状态 = 0 And a.序号 = 1 And
          a.登记时间 >= Sysdate - v_预约天数 And a.发生时间 < Trunc(Sysdate);
Begin
  Select Zl_To_Number(Nvl(zl_GetSysParameter(66), '15')) Into v_预约天数 From Dual;
  Begin
    Select b.姓名, b.编号
    Into v_操作员姓名, v_操作员编号
    From 上机人员表 A, 人员表 B
    Where a.人员id = b.Id And a.用户名 = Upper(User);
  Exception
    When Others Then
      Null;
  End;
  n_挂号排班模式 := To_Number(Substr(Nvl(zl_GetSysParameter(253), 0), 1, 1));
  If n_挂号排班模式 = 0 Then
    For r_Clear In c_Clear Loop
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1
      Where 日期 = Trunc(r_Clear.发生时间) And 科室id = r_Clear.科室id And 项目id = r_Clear.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Clear.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Clear.医生id, 0) And
            (号码 = r_Clear.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_Clear.发生时间), r_Clear.科室id, r_Clear.项目id, r_Clear.医生姓名, Decode(r_Clear.医生id, 0, Null, r_Clear.医生id),
           r_Clear.号码, -1);
      End If;
      --删除门诊费用记录
      Delete From 门诊费用记录 Where NO = r_Clear.No And 记录性质 = 4 And 记录状态 = 0;
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = r_Clear.No;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 预约时间, 登记时间, 发生时间, 操作员编号,
         操作员姓名, 复诊, 号序, 社区, 预约, 摘要, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
        Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 预约时间, 登记时间, 发生时间,
               v_操作员编号, v_操作员姓名, 复诊, 号序, 社区, 预约, 摘要, 交易流水号, 交易说明, 合作单位, 医疗付款方式
        From 病人挂号记录
        Where NO = r_Clear.No And 记录状态 = 3;
    End Loop;
  Else
    --出诊表排班模式
    For r_出诊clear In c_出诊clear Loop
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - 1
      Where 日期 = Trunc(r_出诊clear.发生时间) And 科室id = r_出诊clear.科室id And 项目id = r_出诊clear.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_出诊clear.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_出诊clear.医生id, 0) And
            (号码 = r_出诊clear.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
        Values
          (Trunc(r_出诊clear.发生时间), r_出诊clear.科室id, r_出诊clear.项目id, r_出诊clear.医生姓名,
           Decode(r_出诊clear.医生id, 0, Null, r_出诊clear.医生id), r_出诊clear.号码, -1);
      End If;
      Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = r_出诊clear.Id;
      Update 临床出诊序号控制
      Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
      Where 记录id = r_出诊clear.Id And (序号 = r_出诊clear.号序 Or 备注 = r_出诊clear.号序);
      --门诊费用记录
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_出诊clear.No And 记录性质 = 4 And 记录状态 = 0;
      Insert Into 门诊费用记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号, 付款方式, 病人科室id, 费别,
         收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
         执行部门id, 执行人, 执行状态, 执行时间, 结论, 操作员编号, 操作员姓名, 结帐id, 结帐金额, 保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 缴款组id,
         费用状态, 待转出)
        Select 病人费用记录_Id.Nextval, 记录性质, NO, 实际票号, 2, 序号, 从属父号, 价格父号, 记帐单id, 病人id, 医嘱序号, 门诊标志, 记帐费用, 姓名, 性别, 年龄, 标识号,
               付款方式, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, -1 * 应收金额,
               -1 * 实收金额, 划价人, 开单部门id, 开单人, 发生时间, Sysdate, 执行部门id, 执行人, -1, 执行时间, 结论, v_操作员编号, v_操作员姓名, Null, Null,
               保险大类id, 保险项目否, 保险编码, 费用类型, 统筹金额, 是否上传, 摘要, 是否急诊, 缴款组id, 费用状态, 待转出
        From 门诊费用记录
        Where NO = r_出诊clear.No And 记录性质 = 4 And 记录状态 = 3;
    
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = r_出诊clear.No;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 预约时间, 登记时间, 发生时间, 操作员编号,
         操作员姓名, 复诊, 号序, 社区, 预约, 摘要, 交易流水号, 交易说明, 合作单位, 医疗付款方式)
        Select n_挂号id, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 预约时间, 登记时间, 发生时间,
               v_操作员编号, v_操作员姓名, 复诊, 号序, 社区, 预约, 摘要, 交易流水号, 交易说明, 合作单位, 医疗付款方式
        From 病人挂号记录
        Where NO = r_出诊clear.No And 记录状态 = 3;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约挂号_Clear;
/


Create Or Replace Procedure Zl_病人预约挂号_Defer
(
  号别_In       门诊费用记录.发药窗口%Type,
  预约日期_In   门诊费用记录.发生时间%Type,
  延期日期_In   门诊费用记录.发生时间%Type,
  操作员姓名_In 挂号序号状态.操作员姓名%Type,
  记录id_In     临床出诊记录.Id%Type := Null
) As
  v_Do     Number(1);
  v_医生   挂号安排.医生姓名%Type;
  v_医生id 挂号安排.医生id%Type;
  v_天数   Number;
  n_记录id 临床出诊记录.Id%Type;
Begin
  If 记录id_In Is Null Then
    v_天数 := Trunc(延期日期_In) - Trunc(预约日期_In);
    For c_Fee In (Select Distinct NO, 发药窗口 号序, 执行部门id, 收费细目id
                  From 门诊费用记录
                  Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And 计算单位 = 号别_In And 发生时间 Between Trunc(预约日期_In) And
                        Trunc(预约日期_In + 1) - 1 / 24 / 60 / 60) Loop
      v_Do := 1;
      --挂号序号状态
      If Not c_Fee.号序 Is Null Then
        Begin
          Update 挂号序号状态
          Set 日期 = 日期 + v_天数, 登记时间 = Sysdate
          Where 号码 = 号别_In And Trunc(日期) = Trunc(预约日期_In) And 序号 = c_Fee.号序 And 状态 = 2 And 操作员姓名 = 操作员姓名_In;
        Exception
          --如果延期那天的序号已使用,则该预约挂号不延期
          When Others Then
            --如果有预留的,则允许直接使用
            Update 挂号序号状态
            Set 状态 = 2, 登记时间 = Sysdate
            Where 号码 = 号别_In And Trunc(日期) = Trunc(延期日期_In) And 序号 = c_Fee.号序 And 状态 = 3 And 操作员姓名 = 操作员姓名_In;
            If Sql%RowCount = 0 Then
              v_Do := 0;
            Else
              Delete 挂号序号状态
              Where 号码 = 号别_In And Trunc(日期) = Trunc(预约日期_In) And 序号 = c_Fee.号序 And 状态 = 2 And 操作员姓名 = 操作员姓名_In;
            End If;
        End;
      End If;
    
      If v_Do = 1 Then
        --预约记录
        Update 门诊费用记录
        Set 发生时间 = To_Date(To_Char(延期日期_In, 'yyyy-mm-dd') || To_Char(发生时间, ' hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
        Where 记录性质 = 4 And 记录状态 = 0 And NO = c_Fee.No;
        Update 病人挂号记录
        Set 发生时间 = To_Date(To_Char(延期日期_In, 'yyyy-mm-dd') || To_Char(发生时间, ' hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
        Where 记录性质 = 2 And 记录状态 = 1 And NO = c_Fee.No;
        --病人挂号汇总
        Begin
          Select 医生姓名, 医生id Into v_医生, v_医生id From 挂号安排 Where 号码 = 号别_In;
        Exception
          When Others Then
            Null;
        End;
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(预约日期_In) And Nvl(科室id, 0) = c_Fee.执行部门id And Nvl(项目id, 0) = c_Fee.收费细目id And
              Nvl(医生姓名, '医生') = Nvl(v_医生, '医生') And Nvl(医生id, 0) = Nvl(v_医生id, 0) And (号码 = 号别_In Or 号码 Is Null);
      
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) + 1
        Where 日期 = Trunc(延期日期_In) And Nvl(科室id, 0) = c_Fee.执行部门id And Nvl(项目id, 0) = c_Fee.收费细目id And
              Nvl(医生姓名, '医生') = Nvl(v_医生, '医生') And Nvl(医生id, 0) = Nvl(v_医生id, 0) And (号码 = 号别_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
          Values
            (Trunc(延期日期_In), c_Fee.执行部门id, c_Fee.收费细目id, v_医生, Decode(v_医生id, 0, Null, v_医生id), 号别_In, 1);
        End If;
      End If;
    End Loop;
  Else
    --出诊表排班模式
    v_天数 := Trunc(延期日期_In) - Trunc(预约日期_In);
    For c_Fee In (Select Distinct NO, 发药窗口 号序, 执行部门id, 收费细目id
                  From 门诊费用记录
                  Where 记录性质 = 4 And 记录状态 = 0 And 序号 = 1 And 计算单位 = 号别_In And 发生时间 Between Trunc(预约日期_In) And
                        Trunc(预约日期_In + 1) - 1 / 24 / 60 / 60) Loop
      v_Do := 1;
      --挂号序号状态
      If Not c_Fee.号序 Is Null Then
        Select c.Id
        Into n_记录id
        From 临床出诊记录 A, 临床出诊号源 B, 临床出诊记录 C
        Where a.Id = 记录id_In And a.号源id = b.Id And b.Id = c.号源id And c.出诊日期 = a.出诊日期 + v_天数;
      
        Update 临床出诊序号控制
        Set 挂号状态 = 2, 操作员姓名 = 操作员姓名_In
        Where 记录id = n_记录id And (序号 = c_Fee.号序 Or 备注 = c_Fee.号序) And 挂号状态 = 0;
      
        If Sql%RowCount = 0 Then
          --如果有预留的,则允许直接使用
          Update 临床出诊序号控制
          Set 挂号状态 = 2, 操作员姓名 = 操作员姓名_In
          Where 记录id = n_记录id And (序号 = c_Fee.号序 Or 备注 = c_Fee.号序) And 挂号状态 = 3 And 操作员姓名 = 操作员姓名_In;
          If Sql%RowCount = 0 Then
            v_Do := 0;
          End If;
        End If;
      
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
        Where 记录id = 记录id_In And (序号 = c_Fee.号序 Or 备注 = c_Fee.号序);
      End If;
    
      If v_Do = 1 Then
        --预约记录
        Update 门诊费用记录
        Set 发生时间 = To_Date(To_Char(延期日期_In, 'yyyy-mm-dd') || To_Char(发生时间, ' hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
        Where 记录性质 = 4 And 记录状态 = 0 And NO = c_Fee.No;
        Update 病人挂号记录
        Set 发生时间 = To_Date(To_Char(延期日期_In, 'yyyy-mm-dd') || To_Char(发生时间, ' hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
        Where 记录性质 = 2 And 记录状态 = 1 And NO = c_Fee.No;
        --病人挂号汇总
        Begin
          Select 医生姓名, 医生id Into v_医生, v_医生id From 临床出诊记录 Where ID = 记录id_In;
        Exception
          When Others Then
            Null;
        End;
        Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) - 1 Where ID = 记录id_In;
        Update 临床出诊记录 Set 已约数 = Nvl(已约数, 0) + 1 Where ID = n_记录id;
      
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) - 1
        Where 日期 = Trunc(预约日期_In) And Nvl(科室id, 0) = c_Fee.执行部门id And Nvl(项目id, 0) = c_Fee.收费细目id And
              Nvl(医生姓名, '医生') = Nvl(v_医生, '医生') And Nvl(医生id, 0) = Nvl(v_医生id, 0) And (号码 = 号别_In Or 号码 Is Null);
      
        Update 病人挂号汇总
        Set 已约数 = Nvl(已约数, 0) + 1
        Where 日期 = Trunc(延期日期_In) And Nvl(科室id, 0) = c_Fee.执行部门id And Nvl(项目id, 0) = c_Fee.收费细目id And
              Nvl(医生姓名, '医生') = Nvl(v_医生, '医生') And Nvl(医生id, 0) = Nvl(v_医生id, 0) And (号码 = 号别_In Or 号码 Is Null);
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数)
          Values
            (Trunc(延期日期_In), c_Fee.执行部门id, c_Fee.收费细目id, v_医生, Decode(v_医生id, 0, Null, v_医生id), 号别_In, 1);
        End If;
      End If;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约挂号_Defer;
/


Create Or Replace Function Zl_临床出诊限制_Check
(
  记录id_In 临床出诊记录.Id%Type,
  性别_In   病人信息.性别%Type,
  年龄_In   病人信息.年龄%Type
) Return Varchar2 Is
  --功能:检查挂号的临床出诊记录是否适用病人
  --返回:0-检查通过
  --     1|挂号号码不适用该病人性别
  --     2|挂号号码不适用该病人年龄
  --     3|其他异常错误
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  v_性别限制 临床出诊号源.适用性别%Type;
  v_年龄限制 临床出诊号源.适用年龄段%Type;
  v_最小年龄 Varchar2(500);
  v_最大年龄 Varchar2(500);
  n_最小天数 Number(5);
  n_最大天数 Number(5);
  n_年龄天数 Number(5);
  Function Zl_年龄(Age_In Varchar2) Return Number As
    n_计算天数 Number(5);
  Begin
    If Age_In Like '%岁%月' Then
      n_计算天数 := 365 * To_Number(Substr(Age_In, 1, Instr(Age_In, '岁') - 1)) +
                30 * To_Number(Replace(Substr(Age_In, Instr(Age_In, '岁') + 1), '月', ''));
      Return n_计算天数;
    End If;
    If Age_In Like '%岁%个月' Then
      n_计算天数 := 365 * To_Number(Substr(Age_In, 1, Instr(Age_In, '岁') - 1)) +
                30 * To_Number(Replace(Substr(Age_In, Instr(Age_In, '岁') + 1), '个月', ''));
      Return n_计算天数;
    End If;
    If Age_In Like '%月%天' Then
      n_计算天数 := 30 * To_Number(Substr(Age_In, 1, Instr(Age_In, '月') - 1)) +
                To_Number(Replace(Substr(Age_In, Instr(Age_In, '月') + 1), '天', ''));
      Return n_计算天数;
    End If;
    If Age_In Like '%个月%天' Then
      n_计算天数 := 30 * To_Number(Substr(Age_In, 1, Instr(Age_In, '个') - 1)) +
                To_Number(Replace(Substr(Age_In, Instr(Age_In, '个') + 1), '天', ''));
      Return n_计算天数;
    End If;
    If Age_In Like '%岁' Then
      n_计算天数 := 365 * To_Number(Substr(Age_In, 1, Instr(Age_In, '岁') - 1));
      Return n_计算天数;
    End If;
    If Age_In Like '%月' Then
      n_计算天数 := 30 * To_Number(Substr(Age_In, 1, Instr(Age_In, '月') - 1));
      Return n_计算天数;
    End If;
    If Age_In Like '%个月' Then
      n_计算天数 := 30 * To_Number(Substr(Age_In, 1, Instr(Age_In, '个') - 1));
      Return n_计算天数;
    End If;
    If Age_In Like '%天' Then
      n_计算天数 := To_Number(Substr(Age_In, 1, Instr(Age_In, '天') - 1));
      Return n_计算天数;
    End If;
    Begin
      n_计算天数 := 365 * To_Number(Age_In);
      Return n_计算天数;
    Exception
      When Others Then
        Return Null;
    End;
  End;

Begin
  Begin
    Select b.适用性别, b.适用年龄段
    Into v_性别限制, v_年龄限制
    From 临床出诊记录 A, 临床出诊号源 B
    Where a.Id = 记录id_In And a.号源id = b.Id;
  Exception
    When Others Then
      v_性别限制 := Null;
      v_年龄限制 := Null;
  End;

  If v_性别限制 Is Not Null Then
    If 性别_In <> v_性别限制 Then
      Return '1|挂号号码不适用该病人性别';
    End If;
  End If;

  If v_年龄限制 Is Not Null Then
    v_最小年龄 := Substr(v_年龄限制, 1, Instr(v_年龄限制, '~') - 1);
    v_最大年龄 := Substr(v_年龄限制, Instr(v_年龄限制, '~') + 1);
    n_年龄天数 := Zl_年龄(年龄_In);
    If v_最小年龄 Is Not Null Then
      n_最小天数 := Zl_年龄(v_最小年龄);
    Else
      n_最小天数 := 0;
    End If;
    If v_最大年龄 Is Not Null Then
      n_最大天数 := Zl_年龄(v_最大年龄);
    Else
      n_最大天数 := 0;
    End If;
    If n_年龄天数 < n_最小天数 And n_最小天数 <> 0 Then
      Return '2|挂号号码不适用该病人年龄';
    End If;
    If n_年龄天数 > n_最大天数 And n_最大天数 <> 0 Then
      Return '2|挂号号码不适用该病人年龄';
    End If;
  End If;
  Return 0;
Exception
  When Err_Item Then
    Return '3|限制检查异常';
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊限制_Check;
/



Create Or Replace Procedure Zl_挂号序号状态_Update
(
  号码_In       挂号序号状态.号码%Type,
  日期_In       挂号序号状态.日期%Type,
  序号_In       挂号序号状态.序号%Type,
  状态_In       挂号序号状态.状态%Type,
  操作员姓名_In 挂号序号状态.操作员姓名%Type,
  操作_In       Number, --1-新增,0-删除
  备注_In       挂号序号状态.备注%Type := Null,
  出诊id_In     临床出诊记录.Id%Type := Null,
  预约顺序号_In 临床出诊序号控制.预约顺序号%Type := Null
) As

  v_姓名  挂号序号状态.操作员姓名%Type;
  v_状态  挂号序号状态.状态%Type;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 出诊id_In Is Null Then
    If 操作_In = 1 Then
      --新增挂号序号状态
      Begin
        Select 操作员姓名, 状态
        Into v_姓名, v_状态
        From 挂号序号状态
        Where 号码 = 号码_In And 日期 = 日期_In And 序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
    
      If v_姓名 Is Null Then
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间)
        Values
          (号码_In, 日期_In, 序号_In, 状态_In, 操作员姓名_In, 备注_In, Sysdate);
      Else
        v_Error := '序号' || 序号_In || '已被操作员' || v_姓名;
        If v_状态 = 1 Then
          v_Error := v_Error || '使用';
        Elsif v_状态 = 2 Then
          v_Error := v_Error || '预约';
        Elsif v_状态 = 3 Then
          v_Error := v_Error || '预留';
        End If;
        Raise Err_Custom;
      End If;
    Else
      Begin
        Select 操作员姓名, 状态
        Into v_姓名, v_状态
        From 挂号序号状态
        Where 号码 = 号码_In And 日期 = 日期_In And 序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
    
      If v_姓名 <> 操作员姓名_In And v_状态 = 3 Then
        --取消预留序号
        v_Error := '序号' || 序号_In || '是由操作员' || v_姓名 || '预留的,不允许取消!';
        Raise Err_Custom;
      Else
        Delete 挂号序号状态 Where 号码 = 号码_In And 日期 = 日期_In And 序号 = 序号_In;
      End If;
    End If;
  Else
    --出诊表排班模式
    If 操作_In = 1 Then
      --新增挂号序号状态
      Begin
        If 预约顺序号_In Is Null Then
          Select 操作员姓名, 挂号状态
          Into v_姓名, v_状态
          From 临床出诊序号控制
          Where 记录id = 出诊id_In And 序号 = 序号_In;
        Else
          Select 操作员姓名, 挂号状态
          Into v_姓名, v_状态
          From 临床出诊序号控制
          Where 记录id = 出诊id_In And 序号 = 序号_In And 预约顺序号 = 预约顺序号_In;
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      If v_姓名 Is Null Then
        If 预约顺序号_In Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = 状态_In, 操作员姓名 = 操作员姓名_In
          Where 记录id = 出诊id_In And 序号 = 序号_In;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = 状态_In, 操作员姓名 = 操作员姓名_In
          Where 记录id = 出诊id_In And 序号 = 序号_In And 预约顺序号 = 预约顺序号_In;
        End If;
      Else
        v_Error := '序号' || 序号_In || '已被操作员' || v_姓名;
        If v_状态 = 1 Then
          v_Error := v_Error || '使用';
        Elsif v_状态 = 2 Then
          v_Error := v_Error || '预约';
        Elsif v_状态 = 3 Then
          v_Error := v_Error || '预留';
        End If;
        Raise Err_Custom;
      End If;
    Else
      Begin
        If 预约顺序号_In Is Null Then
          Select 操作员姓名, 挂号状态
          Into v_姓名, v_状态
          From 临床出诊序号控制
          Where 记录id = 出诊id_In And 序号 = 序号_In;
        Else
          Select 操作员姓名, 挂号状态
          Into v_姓名, v_状态
          From 临床出诊序号控制
          Where 记录id = 出诊id_In And 序号 = 序号_In And 预约顺序号 = 预约顺序号_In;
        End If;
      Exception
        When Others Then
          Null;
      End;
    
      If v_姓名 <> 操作员姓名_In And v_状态 = 3 Then
        --取消预留序号
        v_Error := '序号' || 序号_In || '是由操作员' || v_姓名 || '预留的,不允许取消!';
        Raise Err_Custom;
      Else
        If 预约顺序号_In Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
          Where 记录id = 出诊id_In And 序号 = 序号_In;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null
          Where 记录id = 出诊id_In And 序号 = 序号_In And 预约顺序号 = 预约顺序号_In;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号序号状态_Update;
/

Create Or Replace Procedure Zl_预约挂号接收_出诊_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      Varchar2, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;
  v_操作员姓名 病人挂号记录.接收人%Type;
  v_现金       结算方式.名称%Type;
  v_个人帐户   结算方式.名称%Type;
  v_队列名称   排队叫号队列.队列名称%Type;
  v_号别       门诊费用记录.计算单位%Type;
  v_号序       门诊费用记录.发药窗口%Type;
  v_排队号码   排队叫号队列.排队号码 %Type;
  v_预约方式   病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date         Date;
  d_预约时间     门诊费用记录.发生时间%Type;
  d_发生时间     Date;
  d_排队时间     Date;
  n_时段         Number := 0;
  n_存在         Number := 0;
  v_结算内容     Varchar2(2000);
  v_当前结算     Varchar2(500);
  n_结算金额     病人预交记录.冲预交%Type;
  v_结算号码     病人预交记录.结算号码%Type;
  v_结算方式     病人预交记录.结算方式%Type;
  n_三方卡标志   Number(3);
  v_排队序号     排队叫号队列.排队序号%Type;
  n_结算模式     病人信息.结算模式%Type;
  n_票种         票据使用明细.票种%Type;
  v_付款方式     病人挂号记录.医疗付款方式%Type;
  n_接收模式     Number := 0;
  n_出诊记录id   病人挂号记录.出诊记录id%Type;
  n_新出诊记录id 病人挂号记录.出诊记录id%Type;
  n_号源id       临床出诊记录.号源id%Type;
  n_预约顺序号   临床出诊序号控制.预约顺序号%Type;
  n_旧分时段     临床出诊记录.是否分时段%Type;
  n_旧序号控制   临床出诊记录.是否序号控制%Type;
  n_旧科室id     临床出诊记录.科室id%Type;
  n_旧项目id     临床出诊记录.项目id%Type;
  n_旧医生id     临床出诊记录.医生id%Type;
  n_挂号模式     Number(3);
  d_启用时间     Date;
  v_Paratemp     Varchar2(500);
  v_Registtemp   Varchar2(500);
  n_检查         Number(3);
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  v_Paratemp      := Nvl(zl_GetSysParameter('挂号排班模式'), 0);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);
  n_挂号模式      := To_Number(Substr(v_Paratemp, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Paratemp, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式, 出诊记录id
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式, n_出诊记录id
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Select Nvl(是否分时段, 0), 号源id Into n_时段, n_号源id From 临床出诊记录 Where ID = n_出诊记录id;

  If n_时段 = 1 And 三方调用_In = 0 And n_接收模式 = 0 Then
    If Trunc(发生时间_In) <> Trunc(Sysdate) Then
      v_Err_Msg := '分时段的预约挂号单只能当天接收！';
      Raise Err_Item;
    End If;
  End If;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;

  If d_启用时间 Is Not Null Then
    If d_发生时间 < d_启用时间 Then
      v_Err_Msg := '当前预约挂号单属于出诊表排班模式安排，不能在' || To_Char(d_启用时间, 'yyyy-mm-dd hh24:mi:ss') || '之前接收!';
      Raise Err_Item;
    End If;
  End If;

  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Update 临床出诊序号控制 Set 挂号状态 = 0 Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Update 临床出诊序号控制 Set 挂号状态 = 0 Where 序号 = v_号序 And 记录id = n_出诊记录id;
        
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                  项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
        
          Begin
            Select 1
            Into n_存在
            From 临床出诊序号控制
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Exception
            When Others Then
              n_存在 := 0;
          End;
        
          If n_存在 = 0 Then
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          Else
            --号码已被使用的情况
            Select Min(序号) Into v_号序 From 临床出诊序号控制 Where 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
            If v_号序 Is Null Then
              v_Err_Msg := '接收当天没有可用序号,无法接收!';
              Raise Err_Item;
            End If;
            Update 临床出诊序号控制
            Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
            Where 记录id = n_新出诊记录id And 序号 = v_号序 And Nvl(挂号状态, 0) = 0;
          End If;
        Else
          Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
          Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
          From 临床出诊记录
          Where ID = n_出诊记录id;
          Begin
            Select ID
            Into n_新出诊记录id
            From 临床出诊记录
            Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                  项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
          Exception
            When Others Then
              v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
              Raise Err_Item;
          End;
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
          Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
          Returning 预约顺序号 Into n_预约顺序号;
        
          Update 临床出诊序号控制
          Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
          Where 序号 = v_号序 And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
          If Sql% RowCount = 0 Then
            v_Err_Msg := '接收当天序号' || v_号序 || '已被其它人使用,无法接收.';
            Raise Err_Item;
          End If;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = v_号序 Or 备注 = v_号序) And 记录id = n_出诊记录id;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
        Select 是否分时段, 是否序号控制, 科室id, 医生id, 项目id
        Into n_旧分时段, n_旧序号控制, n_旧科室id, n_旧医生id, n_旧项目id
        From 临床出诊记录
        Where ID = n_出诊记录id;
        Begin
          Select ID
          Into n_新出诊记录id
          From 临床出诊记录
          Where 号源id = n_号源id And 是否分时段 = n_旧分时段 And 是否序号控制 = n_旧序号控制 And 科室id = n_旧科室id And 医生id = n_旧医生id And
                项目id = n_旧项目id And Nvl(是否发布, 0) = 1 And 出诊日期 = Trunc(Sysdate) And Rownum < 2;
        Exception
          When Others Then
            v_Err_Msg := '接收当天没有对应的出诊安排,无法接收!';
            Raise Err_Item;
        End;
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id And Nvl(挂号状态, 0) = 2
        Returning 预约顺序号 Into n_预约顺序号;
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In, 预约顺序号 = n_预约顺序号
        Where 序号 = 号序_In And 记录id = n_新出诊记录id And Nvl(挂号状态, 0) = 0;
        If Sql%RowCount = 0 Then
          v_Err_Msg := '接收当天序号' || 号序_In || '已被其它人使用,无法接收.';
          Raise Err_Item;
        End If;
      Else
        Update 临床出诊序号控制
        Set 挂号状态 = 1, 操作员姓名 = 操作员姓名_In
        Where (序号 = 号序_In Or 备注 = 号序_In) And 记录id = n_出诊记录id;
      
      End If;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  v_Registtemp := zl_GetSysParameter('挂号排班模式');
  If Substr(v_Registtemp, 1, 1) = 1 Then
    Begin
      If To_Date(Substr(v_Registtemp, 3), 'yyyy-mm-dd hh24:mi:ss') > d_发生时间 Then
        v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '未启用出诊表排班模式,目前无法接收!';
        Raise Err_Item;
      End If;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select 1
      Into n_检查
      From 临床出诊记录
      Where ID = Nvl(n_新出诊记录id, n_出诊记录id) And d_发生时间 Between 停诊开始时间 And 停诊终止时间;
    Exception
      When Others Then
        n_检查 := 0;
    End;
    If n_检查 = 1 Then
      v_Err_Msg := '接收时间' || To_Char(d_发生时间, 'yyyy-mm-dd hh24:mi:ss') || '的安排已经被停诊,无法接收!';
      Raise Err_Item;
    End If;
  End If;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In,
      出诊记录id = Nvl(n_新出诊记录id, n_出诊记录id)
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式, 出诊记录id)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, Nvl(n_新出诊记录id, n_出诊记录id)
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 Then
      v_结算内容 := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, Null, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, No_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, Null, 4, v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, v_结算方式, n_结算金额, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 0) = 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_出诊_Insert;
/

Create Or Replace Procedure Zl_病人预约登记_Insert
(
  病人id_In     病人信息.病人id%Type,
  号源id_In     临床出诊号源.Id%Type,
  复诊方式_In   病人服务信息记录.复诊方式%Type,
  数量_In       病人服务信息记录.数量%Type,
  说明_In       病人服务信息记录.通知原因%Type,
  提醒时间_In   病人服务信息记录.开始时间%Type,
  提醒天数_In   Number,
  操作员姓名_In 病人挂号记录.操作员姓名%Type,
  操作员编号_In 病人挂号记录.操作员编号%Type
) As
  d_开始时间 病人服务信息记录.开始时间%Type;
  d_结束时间 病人服务信息记录.终止时间%Type;
  v_号码     病人服务信息记录.号码%Type;
  n_科室id   病人服务信息记录.科室id%Type;
  n_项目id   病人服务信息记录.项目id%Type;
  n_医生id   病人服务信息记录.医生id%Type;
  v_医生姓名 病人服务信息记录.医生姓名%Type;
  n_消息id   病人服务信息记录.Id%Type;
  v_Err_Msg  Varchar2(200);
  Err_Item Exception;
Begin
  Begin
    Select 号码, 科室id, 项目id, 医生id, 医生姓名
    Into v_号码, n_科室id, n_项目id, n_医生id, v_医生姓名
    From 临床出诊号源
    Where ID = 号源id_In;
  Exception
    When Others Then
      v_Err_Msg := '没有找到号源信息,预约登记失败';
      Raise Err_Item;
  End;
  d_开始时间 := Trunc(提醒时间_In);
  d_结束时间 := d_开始时间 + Nvl(提醒天数_In, 1);
  Select 病人服务信息记录_Id.Nextval Into n_消息id From Dual;
  Insert Into 病人服务信息记录
    (ID, 通知类型, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 复诊方式, 数量, 开始时间, 终止时间, 通知原因, 登记人, 登记时间)
  Values
    (n_消息id, 3, 号源id_In, v_号码, n_科室id, n_项目id, n_医生id, v_医生姓名, 病人id_In, 复诊方式_In, 数量_In, d_开始时间, d_结束时间, 说明_In, 操作员姓名_In,
     Sysdate);

  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 21, n_消息id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预约登记_Insert;
/


Create Or Replace Procedure Zl_三方机构挂号_Delete
(
  单据号_In     门诊费用记录.No%Type,
  交易流水号_In 病人预交记录.交易流水号%Type,
  交易说明_In   病人预交记录.交易说明%Type,
  退号时间_In   门诊费用记录.登记时间%Type := Null,
  预交id_In     病人预交记录.Id%Type := Null
) As
  v_Error Varchar(255);
  Err_Custom Exception;

  --该游标用于判断是否单独收病历费,及挂号汇总表处理
  Cursor c_Registinfo
  (
    v_状态     病人挂号记录.记录状态%Type,
    v_性质     病人挂号记录.记录性质%Type,
    v_无效单据 Number := 0
  ) Is
    Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.号码
    From 病人挂号记录 A, 挂号安排 B
    Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.号别 = b.号码 And Rownum = 1;

  r_Registrow c_Registinfo%RowType;

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Opermoney Is
    Select Distinct b.结算方式, b.冲预交
    From 门诊费用记录 A, 病人预交记录 B
    Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
          Nvl(b.冲预交, 0) <> 0;

  n_执行状态       病人挂号记录.执行状态%Type;
  n_打印id         票据打印内容.Id%Type;
  n_结帐id         门诊费用记录.结帐id%Type;
  n_原结帐id       病人预交记录.结帐id%Type;
  n_病人id         病人信息.病人id%Type;
  n_返回值         病人余额.预交余额%Type;
  n_分诊台签到排队 Number;
  n_预交id         病人预交记录.Id%Type;
  n_预约挂号       Number;
  n_无效单据       Number; --无效单据没有产生费用单据
  n_挂号生成队列   Number;
  n_Count          Number;
  n_组id           财务缴款分组.Id%Type;
  d_退号时间       Date;
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_合作单位       合作单位挂号汇总.合作单位%Type;
  n_预约状态       病人挂号记录.预约%Type;
  v_Temp           Varchar2(100);
  d_登记时间       病人挂号记录.登记时间%Type;
  v_号别           病人挂号记录.号别%Type;
  n_号序           病人挂号记录.号序%Type;
  n_启用分时段     Number;
  d_预约时间       病人挂号记录.预约时间%Type;
  n_合作单位限制   Number(18);
  n_预约生成队列   Number;
  n_记录性质       Number;
  n_状态           Number;
  n_退号重用       Number(3);
  n_挂号排班模式   Number;
  n_预交支付       Number(3);
  n_正常支付       Number(3);
  n_安排id         挂号安排.Id%Type;
  n_计划id         挂号安排计划.Id%Type;
  v_时间段         时间段.时间段%Type;
  d_检查开始时间   Date;
  d_检查结束时间   Date;
  d_启用时间       Date;
  n_出诊记录id     Number(18);
  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Delete
  (
    单据号_In     门诊费用记录.No%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    退号时间_In   门诊费用记录.登记时间%Type := Null,
    预交id_In     病人预交记录.Id%Type := Null
  ) As
    v_Error Varchar(255);
    Err_Custom Exception;
  
    --该游标用于判断是否单独收病历费,及挂号汇总表处理
    Cursor c_Registinfo
    (
      v_状态     病人挂号记录.记录状态%Type,
      v_性质     病人挂号记录.记录性质%Type,
      v_无效单据 Number := 0
    ) Is
      Select a.发生时间, a.登记时间, b.项目id, b.科室id, b.医生姓名, b.医生id, b.Id As 记录id, a.号别 As 号码
      From 病人挂号记录 A, 临床出诊记录 B
      Where a.记录性质 = Decode(v_无效单据, 0, v_性质, a.记录性质) And a.记录状态 = v_状态 And a.No = 单据号_In And a.出诊记录id = b.Id And
            Rownum < 2;
  
    r_Registrow c_Registinfo%RowType;
  
    --该光标用于处理人员缴款余额中退的不同结算方式的金额
    Cursor c_Opermoney Is
      Select Distinct b.结算方式, b.冲预交
      From 门诊费用记录 A, 病人预交记录 B
      Where a.结帐id = b.结帐id And a.No = 单据号_In And a.记录性质 = 4 And a.记录状态 = 3 And b.记录性质 = 4 And b.记录状态 = 3 And
            Nvl(b.冲预交, 0) <> 0;
  
    n_执行状态       病人挂号记录.执行状态%Type;
    n_打印id         票据打印内容.Id%Type;
    n_结帐id         门诊费用记录.结帐id%Type;
    n_原结帐id       病人预交记录.结帐id%Type;
    n_病人id         病人信息.病人id%Type;
    n_返回值         病人余额.预交余额%Type;
    n_分诊台签到排队 Number;
    n_预交id         病人预交记录.Id%Type;
    n_预约挂号       Number;
    n_无效单据       Number; --无效单据没有产生费用单据
    n_挂号生成队列   Number;
    n_Count          Number;
    n_组id           财务缴款分组.Id%Type;
    d_退号时间       Date;
    v_操作员编号     人员表.编号%Type;
    v_操作员姓名     人员表.姓名%Type;
    v_合作单位       合作单位挂号汇总.合作单位%Type;
    n_预约状态       病人挂号记录.预约%Type;
    v_Temp           Varchar2(100);
    d_登记时间       病人挂号记录.登记时间%Type;
    v_号别           病人挂号记录.号别%Type;
    n_号序           病人挂号记录.号序%Type;
    n_启用分时段     Number;
    d_预约时间       病人挂号记录.预约时间%Type;
    n_合作单位限制   Number(18);
    n_预约生成队列   Number;
    n_记录性质       Number;
    n_状态           Number;
    n_退号重用       Number(3);
    n_记录id         临床出诊记录.Id%Type;
    n_预交支付       Number(3);
    n_正常支付       Number(3);
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  Begin
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Custom;
    End If;
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
  
    n_组id := Zl_Get组id(v_操作员姓名);
  
    d_退号时间 := 退号时间_In;
    If d_退号时间 Is Null Then
      d_退号时间 := Sysdate;
    End If;
  
    --首先判断要退号/取消预约的记录是否存在
    Begin
      Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0),
             Decode(记录状态, 0, 1, 0), 出诊记录id
      Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据, n_记录id
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum < 2;
    Exception
      When Others Then
        n_预约挂号 := -1;
    End;
  
    If n_预约挂号 = -1 Then
      v_Error := '单据可能已经被退号或单据输入错误!';
      Raise Err_Custom;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0) Into n_启用分时段 From 临床出诊记录 Where ID = n_记录id And Rownum < 2;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Select Count(0) Into n_合作单位限制 From 临床出诊挂号控制记录 Where 类型 = 1 And 性质 = 1 And Rownum < 2;
    --更新挂号序号状态
    n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
    If n_退号重用 = 0 Then
      Update 临床出诊序号控制 Set 挂号状态 = 4 Where 记录id = n_记录id And (序号 = n_号序 Or 备注 = To_Char(n_号序));
    Else
      Update 临床出诊序号控制
      Set 挂号状态 = 0, 类型 = Null, 名称 = Null, 操作员姓名 = Null, 工作站名称 = Null
      Where 记录id = n_记录id And (序号 = n_号序 Or 备注 = To_Char(n_号序));
    End If;
    If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
      If Nvl(n_无效单据, 0) = 0 Then
        --N天内不能取消预约号
        n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
        If n_Count <> 0 Then
          If Trunc(Sysdate - n_Count) < d_登记时间 Then
            v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      n_状态 := Case n_无效单据
                When 1 Then
                 0
                Else
                 1
              End;
      --减少已约数
      Open c_Registinfo(n_状态, 2, n_无效单据);
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
      End If;
    
      Update 临床出诊记录
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where ID = n_记录id;
      Close c_Registinfo;
    
      If Nvl(n_无效单据, 0) = 0 Then
        --删除门诊费用记录
        Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
        --如果预约生成队列时需要清除队列
        n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If Nvl(n_挂号生成队列, 0) = 1 Then
          n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
          If Nvl(n_预约生成队列, 0) = 1 Then
            --要删除队列
            For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
              Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
            End Loop;
          End If;
        End If;
      End If;
    Else
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    
      --更新挂号序号状态
    
      --病人就诊状态
      Select 病人id
      Into n_病人id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
    
      If n_病人id Is Not Null Then
        Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
        --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      End If;
    
      --门诊费用记录
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位,
         付数, 数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间,
         登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
               收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
               v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
               Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    
      Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
      Select 结帐id
      Into n_原结帐id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
    
      Begin
        Select 1
        Into n_预交支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_预交支付 := 0;
      End;
      Begin
        Select 1
        Into n_正常支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_正常支付 := 0;
      End;
      If n_预交支付 = 1 And n_正常支付 = 1 Then
        v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
        Raise Err_Custom;
      End If;
      If n_预交支付 = 1 Then
        --原样退回预交
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   d_退号时间, v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 预交id_In, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间,
                   v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        End If;
        --处理病人预交余额 
        For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                     Group By 病人id, 预交类别) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
          Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 预交余额, 性质, 类型)
            Values
              (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
            n_返回值 := Nvl(c_预交.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交,
                   n_结帐id, n_组id, 交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 预交id_In, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
                   交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        End If;
        Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
      End If;
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    
      --相关汇总表的处理
    
      --病人挂号汇总
      Open c_Registinfo(1, 1);
      Fetch c_Registinfo
        Into r_Registrow;
    
      If c_Registinfo%RowCount = 0 Then
        --只收病历费时无号别,不处理
        Close c_Registinfo;
      Else
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
          Into n_预约挂号, n_执行状态
          From 病人挂号记录
          Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
        Exception
          When Others Then
            n_预约挂号 := 0;
        End;
        --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
        If n_执行状态 > 0 Then
          If n_执行状态 = 1 Then
            v_Error := '该病人已经完成就诊,不能再退号!';
          Else
            v_Error := '该病人正在就诊, 不能退号!';
          End If;
          Raise Err_Custom;
        End If;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
              Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
              (号码 = r_Registrow.号码 Or 号码 Is Null);
      
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
             Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
        End If;
      
        Update 临床出诊记录
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where ID = n_记录id;
        Close c_Registinfo;
      End If;
    
      --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
      For r_Opermoney In c_Opermoney Loop
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
          n_返回值 := r_Opermoney.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If n_挂号生成队列 <> 0 Then
        n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    
      --医保产生的就诊登记记录
      Delete From 就诊登记记录
      Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    End If;
  
    If Nvl(n_无效单据, 0) = 0 Then
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
      If Sql%NotFound Then
        v_Error := '未找到挂号单据,请检查!';
        Raise Err_Custom;
      End If;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 出诊记录id)
        Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
               发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位, 出诊记录id
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 3;
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 2, 单据号_In;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_挂号排班模式 := To_Number(Substr(Nvl(zl_GetSysParameter('挂号排班模式'), 0), 1, 1));
  If n_挂号排班模式 = 1 Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Delete(单据号_In, 交易流水号_In, 交易说明_In, 退号时间_In, 预交id_In);
  Else
    v_Temp := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          d_启用时间 := Null;
      End;
    End If;
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Error := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Custom;
    End If;
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
  
    n_组id := Zl_Get组id(v_操作员姓名);
  
    d_退号时间 := 退号时间_In;
    If d_退号时间 Is Null Then
      d_退号时间 := Sysdate;
    End If;
  
    --首先判断要退号/取消预约的记录是否存在
    Begin
      Select Decode(记录性质, 2, 1, 0), 记录性质, 登记时间, 号别, 号序, Nvl(预约时间, 发生时间), Nvl(合作单位, ''), Nvl(预约, 0),
             Decode(记录状态, 0, 1, 0)
      Into n_预约挂号, n_记录性质, d_登记时间, v_号别, n_号序, d_预约时间, v_合作单位, n_预约状态, n_无效单据
      From 病人挂号记录
      Where NO = 单据号_In And 记录状态 In (0, 1) And Rownum <= 1;
    Exception
      When Others Then
        n_预约挂号 := -1;
    End;
  
    If n_预约挂号 = -1 Then
      v_Error := '单据可能已经被退号或单据输入错误!';
      Raise Err_Custom;
    End If;
  
    Begin
      Select a.Id Into n_安排id From 挂号安排 A Where a.号码 = v_号别;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    Begin
      Select ID
      Into n_计划id
      From 挂号安排计划
      Where 安排id = n_安排id And 审核时间 Is Not Null And
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
            (Select Max(a.生效时间) As 生效
             From 挂号安排计划 A
             Where a.审核时间 Is Not Null And d_预约时间 Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And
            d_预约时间 Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'));
    Exception
      When Others Then
        n_计划id := 0;
    End;
  
    If Nvl(n_计划id, 0) = 0 Then
      Select Decode(To_Char(d_预约时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排
      Where ID = n_安排id;
    Else
      Select Decode(To_Char(d_预约时间, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
      Into v_时间段
      From 挂号安排计划
      Where ID = n_计划id;
    End If;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(d_预约时间, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(d_预约时间, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = v_号别 And 上班时段 = v_时间段 And d_预约时间 Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    Begin
      Select 1
      Into n_启用分时段
      From 挂号安排 A, 挂号安排时段 B
      Where a.号码 = v_号别 And a.Id = b.安排id And Rownum <= 1;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    --预约检查是否添加合作单位控制
    --如果设置了合作单位控制 则
    Select Count(0) Into n_合作单位限制 From 合作单位安排控制 Where Rownum = 1;
    --更新挂号序号状态
    n_退号重用 := Zl_To_Number(zl_GetSysParameter('已退序号允许挂号', 1111));
    If n_退号重用 = 0 Then
      Update 挂号序号状态
      Set 状态 = 4
      Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
    Else
      Delete 挂号序号状态
      Where 号码 = v_号别 And 序号 = n_号序 And 日期 Between Trunc(d_预约时间) And Trunc(d_预约时间 + 1) - 1 / 24 / 60 / 60;
    End If;
    If Nvl(n_预约挂号, 0) = 1 Or Nvl(n_无效单据, 0) = 1 Then
      If Nvl(n_无效单据, 0) = 0 Then
        --N天内不能取消预约号
        n_Count := Zl_To_Number(zl_GetSysParameter('N天内不能取消预约号', 1111));
        If n_Count <> 0 Then
          If Trunc(Sysdate - n_Count) < d_登记时间 Then
            v_Error := '不能退掉预约在' || To_Char(Trunc(Sysdate - n_Count), 'yyyy-mm-dd') || '以前的预约单!';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      n_状态 := Case n_无效单据
                When 1 Then
                 0
                Else
                 1
              End;
      --减少已约数
      Open c_Registinfo(n_状态, 2, n_无效单据);
      Fetch c_Registinfo
        Into r_Registrow;
    
      Update 病人挂号汇总
      Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
      Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
            Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
            (号码 = r_Registrow.号码 Or 号码 Is Null);
    
      If Sql%RowCount = 0 Then
        Insert Into 病人挂号汇总
          (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已约数, 已挂数)
        Values
          (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
           Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -n_预约状态, Decode(n_预约状态, 0, 1, 0));
      End If;
    
      If n_出诊记录id Is Not Null Then
        Update 临床出诊记录
        Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已挂数 = Nvl(已挂数, 0) - Decode(n_预约状态, 0, 1, 0)
        Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
        Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_号序;
      End If;
      If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
        Update 合作单位挂号汇总
        Set 已约数 = Nvl(已约数, 0) - n_预约状态, 已接数 = Nvl(已接数, 0) - Decode(n_预约状态, 0, 1, 0)
        Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
              序号 = Nvl(n_号序, 0);
        If Sql%RowCount = 0 Then
          Insert Into 合作单位挂号汇总
            (日期, 号码, 已约数, 合作单位, 序号, 已接数)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.号码, -n_预约状态, v_合作单位, Nvl(n_号序, 0), -decode(n_预约状态, 0, 1, 0));
        End If;
      End If;
      Close c_Registinfo;
    
      If Nvl(n_无效单据, 0) = 0 Then
        --删除门诊费用记录
        Delete From 门诊费用记录 Where NO = 单据号_In And 记录性质 = 4 And 记录状态 = 0;
        --如果预约生成队列时需要清除队列
        n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
        If Nvl(n_挂号生成队列, 0) = 1 Then
          n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
          If Nvl(n_预约生成队列, 0) = 1 Then
            --要删除队列
            For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
              Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
            End Loop;
          End If;
        End If;
      End If;
    Else
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    
      --更新挂号序号状态
    
      --病人就诊状态
      Select 病人id
      Into n_病人id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In And 序号 = 1;
    
      If n_病人id Is Not Null Then
        Update 病人信息 Set 就诊状态 = 0, 就诊诊室 = Null Where 病人id = n_病人id;
        --删除门诊号相关处理,只有当只有一条挂号记录并且病人建档日期与挂号日期近似时才会处理
      End If;
    
      --门诊费用记录
      Insert Into 门诊费用记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别, 收费细目id, 计算单位,
         付数, 数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 发生时间,
         登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id)
        Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 价格父号, 从属父号, 病人id, 病人科室id, 门诊标志, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 收费类别,
               收费细目id, 计算单位, 付数, -数次, 加班标志, 附加标志, 发药窗口, 收入项目id, 收据费目, 记帐费用, 标准单价, -应收金额, -实收金额, 开单部门id, 开单人, 执行部门id, 执行人,
               v_操作员编号, v_操作员姓名, 发生时间, d_退号时间, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, -1 * 统筹金额, 摘要,
               Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
    
      Update 门诊费用记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And NO = 单据号_In;
      Select 结帐id
      Into n_原结帐id
      From 门诊费用记录
      Where 记录性质 = 4 And 记录状态 = 3 And NO = 单据号_In And Rownum = 1;
    
      Begin
        Select 1
        Into n_预交支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 1 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_预交支付 := 0;
      End;
    
      Begin
        Select 1
        Into n_正常支付
        From 病人预交记录
        Where Mod(记录性质, 10) = 4 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum < 2;
      Exception
        When Others Then
          n_正常支付 := 0;
      End;
    
      If n_预交支付 = 1 And n_正常支付 = 1 Then
        v_Error := '不能处理多种结算方式,请检查传入的退号单据是否正确!';
        Raise Err_Custom;
      End If;
    
      If n_预交支付 = 1 Then
        --原样退回预交
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   d_退号时间, v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
            Select 预交id_In, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_退号时间,
                   v_操作员姓名, v_操作员编号, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
            From 病人预交记录
            Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
        End If;
        --处理病人预交余额 
        For c_预交 In (Select 病人id, 预交类别, -1 * Sum(Nvl(冲预交, 0)) As 冲预交
                     From 病人预交记录
                     Where 记录性质 In (1, 11) And 结帐id = n_结帐id
                     Group By 病人id, 预交类别) Loop
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(c_预交.冲预交, 0)
          Where 病人id = c_预交.病人id And 类型 = Nvl(c_预交.预交类别, 2) And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额
              (病人id, 预交余额, 性质, 类型)
            Values
              (c_预交.病人id, Nvl(c_预交.冲预交, 0), 1, Nvl(c_预交.预交类别, 2));
            n_返回值 := Nvl(c_预交.冲预交, 0);
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = c_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        If Nvl(预交id_In, 0) = 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交,
                   n_结帐id, n_组id, 交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        Else
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 交易流水号, 交易说明,
             合作单位, 结算序号, 卡类别id, 结算性质)
            Select 预交id_In, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要, 结算方式, d_退号时间, v_操作员编号, v_操作员姓名, -冲预交, n_结帐id, n_组id,
                   交易流水号_In, 交易说明_In, 合作单位, n_结帐id, 卡类别id, 结算性质
            From 病人预交记录
            Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
        End If;
      
        Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 4 And 记录状态 = 1 And 结帐id = n_原结帐id;
      End If;
    
      --退卡收回票据(可能上次挂号使用票据,不能收回)
      Begin
        --从最后一次的打印内容中取
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 4 And b.No = 单据号_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      If n_打印id Is Not Null Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_退号时间, v_操作员姓名
          From 票据使用明细
          Where 打印id = n_打印id And 性质 = 1;
      End If;
    
      --相关汇总表的处理
    
      --病人挂号汇总
      Open c_Registinfo(1, 1);
      Fetch c_Registinfo
        Into r_Registrow;
    
      If c_Registinfo%RowCount = 0 Then
        --只收病历费时无号别,不处理
        Close c_Registinfo;
      Else
      
        --需要确定是否预约挂号
        --1.如果是退预约挂号产生的挂号记录,则需要减已挂数和其中已接数
        --2.如果是正常挂号,则只减已挂数
        Begin
          Select Decode(预约, Null, 0, 0, 0, 1), 执行状态
          Into n_预约挂号, n_执行状态
          From 病人挂号记录
          Where NO = 单据号_In And 记录状态 = 1 And Rownum = 1;
        Exception
          When Others Then
            n_预约挂号 := 0;
        End;
        --0-等待接诊,1-完成就诊,2-正在就诊,-1标记为不就诊
        If n_执行状态 > 0 Then
          If n_执行状态 = 1 Then
            v_Error := '该病人已经完成就诊,不能再退号!';
          Else
            v_Error := '该病人正在就诊, 不能退号!';
          End If;
          Raise Err_Custom;
        End If;
      
        Update 病人挂号汇总
        Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
        Where 日期 = Trunc(r_Registrow.发生时间) And 科室id = r_Registrow.科室id And 项目id = r_Registrow.项目id And
              Nvl(医生姓名, '医生') = Nvl(r_Registrow.医生姓名, '医生') And Nvl(医生id, 0) = Nvl(r_Registrow.医生id, 0) And
              (号码 = r_Registrow.号码 Or 号码 Is Null);
      
        If Sql%RowCount = 0 Then
          Insert Into 病人挂号汇总
            (日期, 科室id, 项目id, 医生姓名, 医生id, 号码, 已挂数, 其中已接收)
          Values
            (Trunc(r_Registrow.发生时间), r_Registrow.科室id, r_Registrow.项目id, r_Registrow.医生姓名,
             Decode(r_Registrow.医生id, 0, Null, r_Registrow.医生id), r_Registrow.号码, -1, -1 * n_预约挂号);
        End If;
        If n_出诊记录id Is Not Null Then
          Update 临床出诊记录
          Set 已挂数 = Nvl(已挂数, 0) - 1, 其中已接收 = Nvl(其中已接收, 0) - n_预约状态, 已约数 = Nvl(已约数, 0) - n_预约状态
          Where ID = n_出诊记录id And Nvl(已约数, 0) > 0;
          Update 临床出诊序号控制 Set 挂号状态 = Null, 操作员姓名 = Null Where 记录id = n_出诊记录id And 序号 = n_号序;
        End If;
        If Nvl(n_合作单位限制, 0) <> 0 And Nvl(v_合作单位, '') <> '' And Nvl(n_预约状态, 0) <> 0 Then
          Update 合作单位挂号汇总
          Set 已接数 = Nvl(已接数, 0) - 1, 已约数 = Nvl(已约数, 0) - n_预约挂号
          Where 日期 = Trunc(r_Registrow.发生时间) And (号码 = r_Registrow.号码 Or 号码 Is Null) And 合作单位 = Nvl(v_合作单位, '') And
                序号 = Nvl(n_号序, 0);
          If Sql%RowCount = 0 Then
            Insert Into 合作单位挂号汇总
              (日期, 号码, 已约数, 合作单位, 已接数)
            Values
              (Trunc(r_Registrow.发生时间), r_Registrow.号码, -1, v_合作单位, -1 * n_预约挂号);
          End If;
        End If;
        Close c_Registinfo;
      End If;
    
      --人员缴款余额(包括个人帐户等的结算金额,不含退冲预交款)
      For r_Opermoney In c_Opermoney Loop
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + (-1 * r_Opermoney.冲预交)
        Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Opermoney.结算方式, 1, -1 * r_Opermoney.冲预交);
          n_返回值 := r_Opermoney.冲预交;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = r_Opermoney.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    
      n_挂号生成队列 := Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113));
      If n_挂号生成队列 <> 0 Then
        n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
        If Nvl(n_分诊台签到排队, 0) = 0 Then
          --要删除队列
          For v_挂号 In (Select ID, 诊室, 执行部门id, 执行人 From 病人挂号记录 Where NO = 单据号_In) Loop
            Zl_排队叫号队列_Delete(v_挂号.执行部门id, v_挂号.Id);
          End Loop;
        End If;
      End If;
    
      --医保产生的就诊登记记录
      Delete From 就诊登记记录
      Where (病人id, 主页id, 就诊时间) In (Select 病人id, 主页id, 发生时间 From 病人挂号记录 Where NO = 单据号_In);
    End If;
  
    If Nvl(n_无效单据, 0) = 0 Then
      Update 病人挂号记录 Set 记录状态 = 3 Where NO = 单据号_In And 记录状态 = 1;
      If Sql%NotFound Then
        v_Error := '未找到挂号单据,请检查!';
        Raise Err_Custom;
      End If;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位)
        Select 病人挂号记录_Id.Nextval, NO, 记录性质, 2, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, d_退号时间,
               发生时间, v_操作员编号, v_操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号_In, 交易说明_In, 合作单位
        From 病人挂号记录
        Where NO = 单据号_In And 记录状态 = 3;
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 2, 单据号_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Error || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Delete;
/


Create Or Replace Procedure Zl_挂号序号状态_出诊_Delete(记录id_In 临床出诊记录.Id%Type := Null) As
  n_预约有效时间 Number(5);
  n_失约用于挂号 Number(2);
  n_挂号有效天数 Number(5);
Begin
  --清除失约号
  n_预约有效时间 := Nvl(zl_GetSysParameter('预约有效时间', 1111), 0);
  n_失约用于挂号 := Nvl(zl_GetSysParameter('失约用于挂号', 1111), 0);
  If n_失约用于挂号 <> 0 Then
    If 记录id_In Is Null Then
      For c_失效预约 In (Select b.记录id, b.序号, b.预约顺序号
                     From 病人挂号记录 A, 临床出诊序号控制 B
                     Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Trunc(Sysdate) And a.记录性质 = 2 And
                           a.出诊记录id = b.记录id And (a.号序 = b.序号 Or a.号序 = b.备注) And Nvl(b.挂号状态, 0) = 2) Loop
        Update 临床出诊序号控制
        Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null, 备注 = Null
        Where 记录id = c_失效预约.记录id And 序号 = c_失效预约.序号 And 预约顺序号 = c_失效预约.预约顺序号;
      End Loop;
    Else
      For c_失效预约 In (Select b.记录id, b.序号, b.预约顺序号
                     From 病人挂号记录 A, 临床出诊序号控制 B
                     Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Trunc(Sysdate) And a.记录性质 = 2 And
                           a.出诊记录id = b.记录id And (a.号序 = b.序号 Or a.号序 = b.备注) And b.记录id = 记录id_In And
                           Nvl(b.挂号状态, 0) = 2) Loop
        If c_失效预约.预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null, 备注 = Null
          Where 记录id = c_失效预约.记录id And 序号 = c_失效预约.序号;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = 0, 操作员姓名 = Null, 工作站ip = Null, 工作站名称 = Null, 备注 = Null
          Where 记录id = c_失效预约.记录id And 序号 = c_失效预约.序号 And 预约顺序号 = c_失效预约.预约顺序号;
        End If;
      End Loop;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号序号状态_出诊_Delete;
/

CREATE OR REPLACE Procedure Zl_挂号序号状态_Lock
(
  操作_In       Number, --1-锁定,2-清除锁定
  操作员姓名_In 挂号序号状态.操作员姓名%Type,
  号码_In       挂号序号状态.号码%Type := Null,
  日期_In       挂号序号状态.日期%Type := Null,
  序号_In       挂号序号状态.序号%Type := Null,
  出诊记录ID_In 临床出诊记录.ID%type := Null
) As

  v_姓名       挂号序号状态.操作员姓名%Type;
  v_状态       挂号序号状态.状态%Type;
  v_机器名     挂号序号状态.机器名%Type;
  v_验证机器名 挂号序号状态.机器名%Type;
  v_工作站IP   临床出诊序号控制.工作站IP%Type;
  v_Error      Varchar2(255);
  Err_Custom Exception;
Begin
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  Select SYS_CONTEXT('USERENV','IP_ADDRESS') Into v_工作站IP from dual;
  If 操作_In = 1 Then
    --锁定挂号序号状态
    If 出诊记录ID_In is Null then
      Begin
        Select 操作员姓名, 状态, 机器名
        Into v_姓名, v_状态, v_验证机器名
        From 挂号序号状态
        Where 号码 = 号码_In And 日期 = 日期_In And 序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      If v_姓名 Is Null Then
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (号码_In, 日期_In, 序号_In, 5, 操作员姓名_In, '自助机锁号', Sysdate, v_机器名);
      Else
        v_Error := '序号' || 序号_In || '已被操作员' || v_姓名;
        If v_状态 = 1 Then
          v_Error := v_Error || '使用';
        Elsif v_状态 = 2 Then
          v_Error := v_Error || '预约';
        Elsif v_状态 = 3 Then
          v_Error := v_Error || '预留';
        Elsif v_状态 = 4 Then
          v_Error := v_Error || '退号';
        Elsif v_状态 = 5 Then
          v_Error := v_Error || '(' || v_验证机器名 || ')锁定';
        End If;
        Raise Err_Custom;
      End If;
    Else
      Begin
        Select 操作员姓名, 挂号状态, 工作站名称
        Into v_姓名, v_状态, v_验证机器名
        From 临床出诊序号控制
        Where 记录ID = 出诊记录ID_In And 序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      
      If Nvl(v_状态,0) = 0 Then
        Update 临床出诊序号控制 set 挂号状态=5,锁号时间=Sysdate,操作员姓名=操作员姓名_In,工作站IP=v_工作站IP,工作站名称=v_机器名,备注='自助机锁号'
        Where 记录ID=出诊记录ID_In  And 序号=序号_In;
      Else
        v_Error := '序号' || 序号_In || '已被操作员' || v_姓名;
        If v_状态 = 1 Then
          v_Error := v_Error || '使用';
        Elsif v_状态 = 2 Then
          v_Error := v_Error || '预约';
        Elsif v_状态 = 3 Then
          v_Error := v_Error || '预留';
        Elsif v_状态 = 4 Then
          v_Error := v_Error || '退号';
        Elsif v_状态 = 5 Then
          v_Error := v_Error || '(' || v_验证机器名 || ')锁定';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  Elsif 操作_In = 2 Then
    If 出诊记录ID_In is Null then
       Delete 挂号序号状态 Where 机器名 = v_机器名 And 操作员姓名 = 操作员姓名_In And 状态 = 5;
    Else
      Update 临床出诊序号控制 A set A.挂号状态=0,A.锁号时间=NULL,A.操作员姓名=NULL,A.工作站IP=NULL,A.工作站名称=NULL,A.类型=NULL,A.名称=NULL,A.备注=NULL
      Where A.工作站名称 =v_机器名 And A.工作站IP=v_工作站IP And A.操作员姓名 = 操作员姓名_In And A.挂号状态 = 5 And A.锁号时间 > Sysdate -1
        And Exists (Select 1 From 临床出诊记录 B Where A.记录ID=B.ID And B.是否序号控制 = 1);
      
      Update 临床出诊序号控制 A set A.挂号状态=4,A.锁号时间=NULL,A.操作员姓名=NULL,A.工作站IP=NULL,A.工作站名称=NULL,A.类型=NULL,A.名称=NULL,A.备注=NULL
      Where A.工作站名称 =v_机器名 And A.工作站IP=v_工作站IP And A.操作员姓名 = 操作员姓名_In And A.挂号状态 = 5 And A.锁号时间 > Sysdate -1
        And Exists (Select 1 From 临床出诊记录 B Where A.记录ID=B.ID And B.是否序号控制 = 0);
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号序号状态_Lock;
/

Create Or Replace Function Nextreservationnum
(
  记录id_In     In 临床出诊序号控制.记录id%Type,
  序号_In       In 临床出诊序号控制.序号%Type,
  操作员姓名_In In 临床出诊序号控制.操作员姓名%Type
) Return Varchar2
--获取最大预约顺序号，只针对预约普通分时段
 Is
  Pragma Autonomous_Transaction;
  v_机器名   临床出诊序号控制.工作站名称%Type;
  v_工作站ip 临床出诊序号控制.工作站ip%Type;
  n_数量     临床出诊序号控制.数量%Type;
  n_已约数   临床出诊序号控制.数量%Type;
  n_Maxno    Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  Select Sys_Context('USERENV', 'IP_ADDRESS') Into v_工作站ip From Dual;
  Begin
    Select a.数量, b.已约数
    Into n_数量, n_已约数
    From 临床出诊序号控制 A,
         (Select 记录id, 序号, Count(1) As 已约数
           From 临床出诊序号控制
           Where 记录id = 记录id_In And 序号 = 序号_In And 挂号状态 <> 0 And 挂号状态 <> 4 And 预约顺序号 Is Not Null
           Group By 记录id, 序号) B
    Where a.记录id = b.记录id(+) And a.序号 = b.序号(+) And a.记录id = 记录id_In And a.序号 = 序号_In And a.预约顺序号 Is Null;
  Exception
    When Others Then
      v_Error := '没找到对应的出诊安排记录';
      Raise Err_Custom;
  End;

  If Nvl(n_已约数, 0) < Nvl(n_数量, 0) Then
    Select Nvl(Max(预约顺序号), 0) Into n_Maxno From 临床出诊序号控制 Where 记录id = 记录id_In And 序号 = 序号_In;
    --If n_挂号序号=0 then
    n_Maxno := n_Maxno + 1;
    Insert Into 临床出诊序号控制
      (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 工作站ip, 工作站名称, 备注)
      Select 记录id, 序号, n_Maxno, 开始时间, 终止时间, 1, 是否预约, 5, Sysdate, 类型, 名称, 操作员姓名_In, v_工作站ip, v_机器名, '自助机锁号'
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = 序号_In And 预约顺序号 Is Null;
  Else
    v_Error := '当前时段预约已超过最大限约数';
    Raise Err_Custom;
  End If;
  Commit;
  Return n_Maxno;
Exception
  When Err_Custom Then
    Rollback;
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Rollback;
    zl_ErrorCenter(SQLCode, SQLErrM);
End Nextreservationnum;
/

--103209:刘尔旋,2016-12-20,服务窗医保实时结算
--102791:刘尔旋,2016-12-08,预约排队时按时点显示
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In     Integer,
  病人id_In       门诊费用记录.病人id%Type,
  号码_In         挂号安排.号码%Type,
  号序_In         挂号序号状态.序号%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  结算方式_In     Varchar2,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  合作单位_In     挂号合作单位.名称%Type,
  挂号金额合计_In 门诊费用记录.实收金额%Type,
  领用id_In       票据使用明细.领用id%Type,
  收费票据_In     Number := 0, --挂号是否使用收费票据
  交易流水号_In   病人预交记录.交易流水号%Type,
  交易说明_In     病人预交记录.交易说明%Type,
  预约方式_In     预约方式.名称%Type := Null,
  预交id_In       病人预交记录.Id%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  加入序号状态_In Number := 0,
  是否自助设备_In Number := 0,
  结帐id_In       门诊费用记录.结帐id%Type := Null,
  锁定类型_In     Number := 0,
  保险结算_In     Varchar2 := Null,
  冲预交_In       Number := Null,
  支付卡号_In     病人预交记录.卡号%Type := Null,
  退号重用_In     Number := 1,
  费别_In         门诊费用记录.费别%Type := Null,
  机器名_In       挂号序号状态.机器名%Type := Null,
  更新年龄_In     Number := 0,
  购买病历_In     Number := 0,
  出诊记录id_In   临床出诊记录.Id%Type := Null
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      结算方式_IN:支持多种结算方式,多种结算方式时，传入格式如下:结算方式名称1,金额,结算号码,三方卡标志|结算方式名称2,金额,结算号码,三方卡标志|...
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  Err_Item Exception;
  Err_Special Exception;
  v_Err_Msg  Varchar2(255);
  n_打印id   票据打印内容.Id%Type;
  n_返回值   病人预交记录.金额%Type;
  v_排队号码 Varchar2(20);
  v_队列名称 排队叫号队列.队列名称%Type;
  n_预交id   病人预交记录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);

  v_结算方式       病人预交记录.结算方式%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_结算合计       Number(16, 5);
  n_预交金额       病人预交记录.冲预交%Type;
  n_组id           财务缴款分组.Id%Type;
  d_排队时间       Date;
  n_锁定           Number;
  n_病人预约科室数 Number(18);
  n_已约科室       Number(18);

  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  d_时段开始时间       Date;
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;
  n_出诊记录id         临床出诊记录.Id%Type;
  n_挂号模式           Number(3);
  n_同科限号数         Number;
  n_同科限约数         Number;
  n_病人挂号科室数     Number;
  n_分时点显示         Number;
  d_启用时间           Date;
  n_Exists             Number;
  v_Para               Varchar2(2000);
  n_专家号挂号限制     Number;
  n_专家号预约限制     Number;
  v_时间段             时间段.时间段%Type;
  d_检查开始时间       时间段.开始时间%Type;
  d_检查结束时间       时间段.终止时间%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO
    Order By 结帐id, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Insert
  (
    记录id_In       临床出诊记录.Id%Type,
    操作方式_In     Integer,
    病人id_In       门诊费用记录.病人id%Type,
    号码_In         挂号安排.号码%Type,
    号序_In         挂号序号状态.序号%Type,
    单据号_In       门诊费用记录.No%Type,
    票据号_In       门诊费用记录.实际票号%Type,
    结算方式_In     Varchar2,
    摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
    发生时间_In     门诊费用记录.发生时间%Type,
    登记时间_In     门诊费用记录.登记时间%Type,
    合作单位_In     挂号合作单位.名称%Type,
    挂号金额合计_In 门诊费用记录.实收金额%Type,
    领用id_In       票据使用明细.领用id%Type,
    收费票据_In     Number := 0, --挂号是否使用收费票据
    交易流水号_In   病人预交记录.交易流水号%Type,
    交易说明_In     病人预交记录.交易说明%Type,
    预约方式_In     预约方式.名称%Type := Null,
    预交id_In       病人预交记录.Id%Type := Null,
    卡类别id_In     病人预交记录.卡类别id%Type := Null,
    加入序号状态_In Number := 0,
    是否自助设备_In Number := 0,
    结帐id_In       门诊费用记录.结帐id%Type := Null,
    锁定类型_In     Number := 0,
    保险结算_In     Varchar2 := Null,
    冲预交_In       Number := Null,
    支付卡号_In     病人预交记录.卡号%Type := Null,
    退号重用_In     Number := 1,
    费别_In         门诊费用记录.费别%Type := Null,
    机器名_In       挂号序号状态.机器名%Type := Null,
    更新年龄_In     Number := 0,
    购买病历_In     Number := 0
  ) As
    --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款),出诊表排班模式下使用
    --入参: 操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
    --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
    --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
    --      保险结算_IN:格式="结算方式|结算金额||....."
    --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
    Err_Item Exception;
    Err_Special Exception;
    v_Err_Msg  Varchar2(255);
    n_打印id   票据打印内容.Id%Type;
    n_返回值   病人预交记录.金额%Type;
    v_排队号码 Varchar2(20);
    v_队列名称 排队叫号队列.队列名称%Type;
    n_预交id   病人预交记录.Id%Type;
    n_挂号id   病人挂号记录.Id%Type;
    v_结算内容 Varchar2(3000);
    v_当前结算 Varchar2(150);
  
    v_结算方式       病人预交记录.结算方式%Type;
    n_结算金额       病人预交记录.冲预交%Type;
    n_结算合计       Number(16, 5);
    n_预交金额       病人预交记录.冲预交%Type;
    n_组id           财务缴款分组.Id%Type;
    d_排队时间       Date;
    n_锁定           Number;
    n_病人预约科室数 Number(18);
    n_已约科室       Number(18);
  
    n_合作单位限制       Number(18);
    n_是否开放           Number(1);
    n_Count              Number(18);
    n_行号               Number(18);
    n_序号               病人挂号记录.号序%Type;
    n_费用id             门诊费用记录.Id%Type;
    n_价格父号           Number(18);
    n_原项目id           收费项目目录.Id%Type;
    n_原收入项目id       收费项目目录.Id%Type;
    v_诊室               病人挂号记录.诊室%Type;
    n_实收金额合计       门诊费用记录.实收金额%Type;
    n_开单部门id         门诊费用记录.开单部门id%Type;
    n_实收金额           门诊费用记录.实收金额%Type;
    n_应收金额           门诊费用记录.实收金额%Type;
    n_结帐id             病人结帐记录.Id%Type;
    v_Temp               Varchar2(500);
    v_结算方式记录       Varchar2(1000);
    n_预约时段序号       Number;
    n_序号控制           临床出诊记录.是否序号控制%Type;
    n_限约数             临床出诊记录.限约数%Type;
    n_项目id             临床出诊记录.项目id%Type;
    n_科室id             临床出诊记录.科室id%Type;
    d_终止时间           临床出诊记录.终止时间%Type;
    v_医生姓名           临床出诊记录.医生姓名%Type;
    n_医生id             临床出诊记录.医生id%Type;
    n_预约顺序号         临床出诊序号控制.预约顺序号%Type;
    n_预约总数           Number;
    d_时段开始时间       Date;
    d_时段终止时间       Date;
    v_收费项目ids        Varchar2(300);
    n_三方卡标志         Number;
    n_号序               病人挂号记录.号序%Type;
    d_登记时间           Date;
    n_单笔金额           病人预交记录.冲预交%Type;
    v_结算号码           病人预交记录.结算号码%Type;
    v_操作员编号         人员表.编号%Type;
    v_操作员姓名         人员表.姓名%Type;
    n_预约               Integer;
    v_现金               病人预交记录.结算方式%Type;
    n_启用分时段         Integer;
    n_已挂数             病人挂号汇总.已挂数%Type;
    n_已约数             病人挂号汇总.已约数%Type;
    n_其中已接收         病人挂号汇总.已约数%Type;
    n_预约生成队列       Number;
    n_限号数             临床出诊记录.限号数%Type;
    d_Date               Date;
    n_挂号序号           Number;
    v_排队序号           排队叫号队列.排队序号%Type;
    v_机器名             挂号序号状态.机器名%Type;
    v_序号操作员         挂号序号状态.操作员姓名%Type;
    v_序号机器名         挂号序号状态.机器名%Type;
    n_序号锁定           Number := 0;
    n_病历费id           收费特定项目.收费细目id%Type;
    v_付款方式           病人挂号记录.医疗付款方式%Type;
    v_费别               门诊费用记录.费别%Type;
    n_屏蔽费别           Number(3) := 0;
    v_年龄               病人信息.年龄%Type;
    n_合作单位限数量模式 Number;
    n_同科限号数         Number;
    n_分时点显示         Number;
    n_同科限约数         Number;
    n_病人挂号科室数     Number;
    n_Exists             Number(5);
    n_替诊医生id         临床出诊记录.替诊医生id%Type;
    v_替诊医生姓名       临床出诊记录.替诊医生姓名%Type;
    d_替诊开始时间       临床出诊记录.替诊开始时间%Type;
    d_替诊终止时间       临床出诊记录.替诊终止时间%Type;
    n_专家号挂号限制     Number;
    n_专家号预约限制     Number;
  
    Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
      Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
      From 病人信息 A, 医疗付款方式 C
      Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);
  
    r_Pati c_Pati%RowType;
  
    --该游标用于收费冲预交的可用预交列表
    --以ID排序，优先冲上次未冲完的。
    Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
      Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
             Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
      From 病人预交记录
      Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
      Group By NO
      Order By 结帐id, NO;
  
    Function Zl_诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
      n_分诊方式 临床出诊记录.分诊方式%Type;
      v_诊室     病人挂号记录.诊室%Type;
      v_Rowid    Varchar2(500);
      n_Next     Integer;
      n_First    Integer;
    Begin
    
      If 锁定类型_In = 2 Then
        --对单据进行解锁,首先检查是否存在锁定
        Select Count(Rowid)
        Into n_锁定
        From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
        If n_锁定 = 0 Then
          v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
          Raise Err_Item;
        End If;
        Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      End If;
    
      Begin
        Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
      Exception
        When Others Then
          v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
          Raise Err_Item;
      End;
    
      --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
      v_诊室 := Null;
      If n_分诊方式 = 1 Then
        --1-指定诊室
        Begin
          Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
        Exception
          When Others Then
            v_诊室 := Null;
        End;
      End If;
      If n_分诊方式 = 2 Then
        --2-动态分诊:该个号别当天挂号未诊数最少的诊室
        For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.诊室id = b.Id And a.记录id = 记录id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                  诊室 In (Select d.名称
                                         From 临床出诊诊室记录 C, 门诊诊室 D
                                         Where c.诊室id = d.Id And c.记录id = 记录id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num) Loop
          v_诊室 := c_诊室.门诊诊室;
          Exit;
        End Loop;
      End If;
      If n_分诊方式 = 3 Then
        --平均分诊：当前分配=1表示下次应取的当前诊室
        n_Next  := 0;
        n_First := 1;
        For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                     From 临床出诊诊室记录 A, 门诊诊室 B
                     Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
          If n_First = 1 Then
            v_Rowid := c_诊室.Rid;
          End If;
          If n_Next = 1 Then
            v_诊室 := c_诊室.门诊诊室;
            Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
            Exit;
          End If;
          If Nvl(c_诊室.当前分配, 0) = 1 Then
            Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
            n_Next := 1;
          End If;
        End Loop;
        If v_诊室 Is Null Then
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
          Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
        End If;
      End If;
      Return v_诊室;
    End;
  
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  
  Begin
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
  
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
  
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 出诊记录id = 记录id_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
  
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(记录id_In, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select 1
        Into n_合作单位限制
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 1 And 性质 = 1 And 控制方式 <> 4 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限制 := 0;
      End;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(记录id_In);
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0), 限号数, 已挂数, 其中已接收, 已约数, 是否序号控制, 限约数, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 替诊开始时间, 替诊终止时间
      Into n_启用分时段, n_限号数, n_已挂数, n_其中已接收, n_已约数, n_序号控制, n_限约数, n_项目id, n_科室id, n_医生id, v_医生姓名, n_替诊医生id, v_替诊医生姓名,
           d_替诊开始时间, d_替诊终止时间
      From 临床出诊记录
      Where ID = 记录id_In And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    If 发生时间_In Between Nvl(d_替诊开始时间, Sysdate) And Nvl(d_替诊终止时间, Sysdate - 1) And v_替诊医生姓名 Is Not Null Then
      n_医生id   := n_替诊医生id;
      v_医生姓名 := v_替诊医生姓名;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(n_限号数, 0) >= 0 Or n_限号数 Is Null Then
      If n_启用分时段 = 1 Then
        If Nvl(n_序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0);
          
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
        
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 终止时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间, 数量, 是否预约
                         From 临床出诊序号控制
                         Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.终止时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          For v_时段 In (Select 序号, 开始时间, 终止时间, 数量, 是否预约
                       From 临床出诊序号控制
                       Where 记录id = 记录id_In And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
            d_时段终止时间 := v_时段.终止时间;
          
            Select Count(*), Max(序号), Max(预约顺序号) + 1
            Into n_Count, n_预约总数, n_预约顺序号
            From 临床出诊序号控制
            Where 记录id = 记录id_In And Nvl(挂号状态, 0) Not In (0, 4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.终止时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(n_限号数, 0) And n_限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(n_限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(n_限约数, 0) And Nvl(n_限约数, 0) <> 0 And n_限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(n_限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
      If 预约方式_In Is Not Null Then
        Select To_Number(Substr(Zl_Fun_Get临床出诊预约状态(记录id_In, 发生时间_In, 号序_In, 预约方式_In), 1, 1))
        Into n_Exists
        From Dual;
        If n_Exists <> 0 Then
          v_Err_Msg := '传入的预约方式' || 预约方式_In || '不可用,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
      If Nvl(n_序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(n_序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位控制模式
      Select Nvl(控制方式, 0)
      Into n_合作单位限数量模式
      From 临床出诊挂号控制记录
      Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
    
      If n_合作单位限数量模式 = 0 Then
        v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '未开放' || 合作单位_In || '的预约,不能继续。';
        Raise Err_Item;
      End If;
      If n_合作单位限数量模式 = 1 Or n_合作单位限数量模式 = 2 Then
        Select 数量
        Into n_Count
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1;
        If n_合作单位限数量模式 = 1 Then
          n_Count := Round(Nvl(n_限约数, n_限号数) * n_Count / 100);
        End If;
        Select Count(1)
        Into n_Exists
        From 病人挂号记录
        Where 记录状态 = 1 And 出诊记录id = 记录id_In And 合作单位 = 合作单位_In;
        If n_Exists >= n_Count Then
          v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
          Raise Err_Item;
        End If;
      End If;
      --开放序号检查
      If n_合作单位限数量模式 = 3 Then
        For c_合作单位 In (Select 序号, 数量
                       From 临床出诊挂号控制记录
                       Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And 序号 = 号序_In) Loop
          If n_序号控制 = 1 Then
            Begin
              Select 1
              Into n_Count
              From 临床出诊序号控制
              Where 记录id = 记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 0;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 1 Then
              n_是否开放 := 1;
            Else
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            End If;
          Else
            Select Count(1)
            Into n_Count
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = 号序_In And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
            If n_Count >= c_合作单位.数量 Then
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            Else
              n_是否开放 := 1;
            End If;
          End If;
        End Loop;
      
        If Nvl(n_是否开放, 0) = 0 Then
          v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, n_科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), n_科室id, v_医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
           摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = n_号序 And Nvl(挂号状态, 0) Not In (0, 5);
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(n_序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
  
    If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      Select Nvl(Min(序号), 0)
      Into n_号序
      From 临床出诊序号控制
      Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
      If n_号序 = 0 Then
        Select Nvl(Min(序号), 0) Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
        If n_号序 = 0 Then
          Select Nvl(Max(序号), 0) + 1 Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In;
        End If;
      End If;
    End If;
  
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
      If 操作方式_In > 1 And Nvl(n_序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(n_限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(n_序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where 挂号状态 = 5 And 记录id = 记录id_In And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        If n_启用分时段 = 1 And n_序号控制 = 0 Then
          Insert Into 临床出诊序号控制
            (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名, 备注)
            Select 记录id_In, n_预约时段序号, n_预约顺序号, d_时段开始时间, d_时段终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1),
                   1, 合作单位_In, v_操作员姓名, n_号序
            From Dual;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
          Where 记录id = 记录id_In And 序号 = n_号序;
        End If;
        If Sql%RowCount = 0 Then
          Begin
            If n_启用分时段 = 1 Then
              --分时段
              If n_序号控制 = 1 Then
                --序号控制
                Select Max(终止时间) Into d_终止时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
                If Sysdate > d_终止时间 Then
                  d_终止时间 := Sysdate;
                End If;
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                  Select 记录id_In, n_号序, d_终止时间, d_终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1,
                         合作单位_In, v_操作员姓名
                  From Dual;
              Else
                --分时段,非序号控制
                Null;
              End If;
            Else
              --不分时段
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                Select 记录id_In, n_号序, 开始时间, 终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1, 合作单位_In,
                       v_操作员姓名
                From 临床出诊序号控制
                Where 记录id = 记录id_In And 序号 = 1;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被机器' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 锁号时间 = Null
          Where 记录id = 记录id_In And 序号 = n_号序 And 挂号状态 = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
        If Instr(结算方式_In, ',') = 0 Then
          --只传入一种结算方式的
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
        Else
          v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
          n_Exists       := 0;
          v_结算方式记录 := '';
          While v_结算内容 Is Not Null Loop
            v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
            v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_单笔金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_三方卡标志 := To_Number(v_当前结算);
          
            If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
              v_Err_Msg := '使用了重复的结算方式,请检查!';
              Raise Err_Item;
            Else
              v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
            End If;
          
            If n_三方卡标志 = 0 Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
            Else
              If n_Exists = 1 Then
                v_Err_Msg := '目前挂号仅支持一种三方结算方式,不能继续操作！';
                Raise Err_Item;
              End If;
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
              n_Exists := 1;
            End If;
          
            v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
          End Loop;
        End If;
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = v_缴款.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号)), 出诊记录id = 记录id_In
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号, 出诊记录id)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, n_科室id, v_医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号), 记录id_In);
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := n_科室id;
            v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, v_医生姓名, d_排队时间,
                             预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, 发生时间_In, n_预约, 号码_In, 0, 记录id_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Err_Special Then
      Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_出诊记录id := 出诊记录id_In;
  v_Para       := zl_GetSysParameter(256);
  n_挂号模式   := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(发生时间_In, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Insert(n_出诊记录id, 操作方式_In, 病人id_In, 号码_In, 号序_In, 单据号_In, 票据号_In, 结算方式_In, 摘要_In, 发生时间_In, 登记时间_In,
                        合作单位_In, 挂号金额合计_In, 领用id_In, 收费票据_In, 交易流水号_In, 交易说明_In, 预约方式_In, 预交id_In, 卡类别id_In, 加入序号状态_In,
                        是否自助设备_In, 结帐id_In, 锁定类型_In, 保险结算_In, 冲预交_In, 支付卡号_In, 退号重用_In, 费别_In, 机器名_In, 更新年龄_In, 购买病历_In);
  Else
    v_Temp := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          Null;
      End;
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
    --Begin
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(n_出诊记录id, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select ID
        Into n_计划id
        From 挂号安排计划
        Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
              Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
        Order By 生效时间 Desc;
      Exception
        When Others Then
          Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
      End;
      If Nvl(n_计划id, 0) <> 0 Then
        Select Count(0)
        Into n_合作单位限制
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
      Else
        Select Count(0)
        Into n_合作单位限制
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
      End If;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(号码_In);
    End If;
    If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
      --检查结算方式是否完备
      Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
      If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
        Select Count(1)
        Into n_Count
        From 医疗卡类别
        Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
      End If;
      If n_Count = 0 Then
        v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
        Raise Err_Item;
      End If;
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Open c_安排(号码_In, 发生时间_In);
    Begin
      Fetch c_安排
        Into r_安排;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   '周日')
    Into v_星期
    From Dual;
    Begin
      If r_安排.计划id Is Null Then
        Select Max(1) Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排
        Where ID = r_安排.Id;
      Else
        Select Max(1)
        Into n_启用分时段
        From 挂号计划时段
        Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排计划
        Where ID = r_安排.计划id;
      End If;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
    
      Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
      Into n_已挂数, n_其中已接收, n_已约数
      From 挂号安排 A, 病人挂号汇总 B
      Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
            Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
    
      If n_启用分时段 = 1 Then
        If Nvl(r_安排.序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            If r_安排.计划id Is Null Then
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号安排时段
              Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            Else
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号计划时段
              Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            End If;
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            If r_安排.计划id Is Null Then
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号安排时段
                           Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            Else
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号计划时段
                           Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            End If;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          If r_安排.计划id Is Null Then
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          Else
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
    
      If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位限数量模式
      Begin
        If Nvl(n_计划id, 0) <> 0 Then
          Select 0
          Into n_序号
          From 合作单位计划控制
          Where 合作单位 = 合作单位_In And 计划id = n_计划id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        Else
          Select 0
          Into n_序号
          From 合作单位安排控制
          Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        End If;
        n_合作单位限数量模式 := 1;
      Exception
        When Others Then
          n_合作单位限数量模式 := 0;
      End;
      --开放序号检查
      For c_合作单位 In (Select c.序号, 数量
                     From 挂号安排 A, 合作单位安排控制 C
                     Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                           c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                      (Select 1
                            From 挂号安排计划 D
                            Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Union All
                     Select c.序号, 数量
                     From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                          (Select Max(a.生效时间) As 生效, 安排id
                            From 挂号安排计划 A, 挂号安排 B
                            Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                            Group By 安排id) E
                     Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                           Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                           发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      
        If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
          n_是否开放 := 1;
          Exit;
        Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
          Begin
            Select Nvl(已约数, 0)
            Into n_预约数量
            From 合作单位挂号汇总
            Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
          Exception
            When Others Then
              n_预约数量 := 0;
          End;
          If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
            v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
            Raise Err_Item;
          End If;
          n_是否开放 := 1;
          Exit;
        End If;
      
      End Loop;
    
      If Nvl(n_是否开放, 0) = 0 Then
        v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
        Raise Err_Item;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := r_安排.项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := r_安排.项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And Sysdate Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null,
           Null, 摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 挂号序号状态
      Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
      End If;
    End If;
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
    
      If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(r_安排.限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 机器名
        Into v_序号操作员, v_序号机器名
        From 挂号序号状态
        Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
          
            If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
              Update 合作单位挂号汇总
              Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
              Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
              If Sql%NotFound Then
                Insert Into 合作单位挂号汇总
                  (号码, 日期, 序号, 合作单位, 已约数, 已接数)
                Values
                  (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 挂号序号状态
          Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
          Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
        End If;
      End If;
    End If;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊序号控制
      Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
      Where 记录id = n_出诊记录id And 序号 = n_序号;
      If 操作方式_In = 2 Then
        Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
      Else
        If 操作方式_In <> 1 Then
          Update 临床出诊记录
          Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
          Where ID = n_出诊记录id;
        Else
          Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
      
        Insert Into 病人预交记录
          (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
           结算性质)
        Values
          (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id,
           合作单位_In || '缴款', n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
      End Loop;
    
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := r_安排.科室id;
            v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                             d_排队时间, 预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

Create Or Replace Procedure Zl_Third_Getregistalter
(
  Xml_In  Xmltype,
  Xml_Out Out Xmltype
) Is
  -----------------------------------------------
  --功能：获取当天操作的停换诊安排
  --入参：XML_IN
  --<IN>
  --  <JSKLB>结算卡类别</JSKLB>
  --  <RQ>日期</RQ>
  --</IN>
  --出参:XML_OUT
  --<OUTPUT>
  --  <TZLISTS>          //停诊列表
  --    <ITEM>
  --      <HM>号码</HM>
  --      <YSID>医生ID</YSID>
  --      <YS>医生姓名</YS>
  --      <KSSJ>停诊开始时间</KSSJ>
  --      <JSSJ>停诊结束时间</JSSJ>
  --      <BRLIST>
  --        <INFO>
  --          <YYNO>预约单据号</YYNO>
  --          <BRID>病人ID</BRID>
  --          <YYSJ>预约时间</YYSJ>
  --          <CZSJ>操作时间</CZSJ>
  --          <YYKS>预约科室</YYKS>
  --          <GHLX>号类</GHLX>
  --          <YSXM>医生姓名</YSXM>
  --        </INFO>
  --      </BRLIST>
  --    </ITEM>
  --  </TZLISTS>
  --  <HZLISTS>          //换诊列表
  --    <ITEM>
  --      <BRID>病人ID</BRID>
  --      <YYSJ>预约的操作时间</YYSJ>
  --      <YSJ>原预约时间</YSJ>
  --      <YHM>原号码</YHM>
  --      <YYS>原医生</YYS>
  --      <YZC>原医生的职称</YZC>
  --      <XSJ>现预约时间</XSJ>
  --      <XHM>现号码</XHM>
  --      <XYS>现医生</XYS>
  --      <XZC>现医生的职称</XZC>
  --    </ITEM>
  --  </HZLIST>
  --</OUTPUT>
  -----------------------------------------------------

  d_Date     Date;
  v_Jsklb    Varchar2(100);
  n_卡类别id 医疗卡类别.Id%Type;
  n_Cnt      Number(3);
  v_Temp     Clob;
  v_Brinfo   Varchar2(4000);
  d_启用时间 Date;
  v_Para     Varchar2(2000);
  n_Exists   Number(3);
  n_挂号模式 Number(3);
  x_Templet  Xmltype;
Begin
  Select Extractvalue(Value(A), 'IN/JSKLB') Into v_Jsklb From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'yyyy-mm-dd')
  Into d_Date
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select b.Id Into n_卡类别id From 医疗卡类别 B Where b.名称 = v_Jsklb And Rownum < 2;
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  If n_挂号模式 = 1 And Nvl(d_Date, Sysdate) > Nvl(d_启用时间, Sysdate - 30) Then
    --出诊表排班模式
    --获取停诊安排
    For r_停诊 In (Select a.Id As 记录id, b.号码, a.医生id, a.医生姓名, a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 临床出诊停诊记录 C
                 Where a.Id = c.记录id And a.号源id = b.Id And a.停诊开始时间 Is Not Null And c.审批时间 Between d_Date And
                       d_Date + 1 - 1 / 24 / 60 / 60) Loop
      v_Temp := v_Temp || '<ITEM><HM>' || r_停诊.号码 || '</HM><YSID>' || r_停诊.医生id || '</YSID><YS>' || r_停诊.医生姓名 ||
                '</YS><KSSJ>' || r_停诊.停诊开始时间 || '</KSSJ><JSSJ>' || r_停诊.停诊终止时间 || '</JSSJ>';
      For r_停诊病人 In (Select a.记录性质, a.No, a.病人id, To_Char(a.发生时间, 'yyyy-mm-dd') As 发生时间,
                            To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.名称, d.号类, c.医生姓名 As 医生姓名
                     From 病人挂号记录 A, 部门表 B, 临床出诊记录 C, 临床出诊号源 D
                     Where a.执行部门id = b.Id And a.出诊记录id = c.Id And c.号源id = d.Id And 记录状态 = 1 And
                           发生时间 Between r_停诊.停诊开始时间 And r_停诊.停诊终止时间 And a.出诊记录id = r_停诊.记录id And Not Exists
                      (Select 1 From 就诊变动记录 Where 挂号单 = a.No)) Loop
        --停诊病人列表，不包含已经换诊和取消了的病人
        If r_停诊病人.记录性质 = 2 Then
          v_Brinfo := v_Brinfo || '<INFO><YYNO>' || r_停诊病人.No || '</YYNO><BRID>' || r_停诊病人.病人id || '</BRID><YYSJ>' ||
                      r_停诊病人.发生时间 || '</YYSJ><CZSJ>' || r_停诊病人.登记时间 || '</CZSJ>' || '<YYKS>' || r_停诊病人.名称 ||
                      '</YYKS><GHLX>' || r_停诊病人.号类 || '</GHLX><YSXM>' || r_停诊病人.医生姓名 || '</YSXM></INFO>';
        Else
          Begin
            Select 1
            Into n_Exists
            From 病人预交记录
            Where NO = r_停诊病人.No And 记录性质 = 4 And 卡类别id = n_卡类别id;
          Exception
            When Others Then
              n_Exists := 0;
          End;
          If n_Exists = 1 Then
            v_Brinfo := v_Brinfo || '<INFO><YYNO>' || r_停诊病人.No || '</YYNO><BRID>' || r_停诊病人.病人id || '</BRID><YYSJ>' ||
                        r_停诊病人.发生时间 || '</YYSJ><CZSJ>' || r_停诊病人.登记时间 || '</CZSJ>' || '<YYKS>' || r_停诊病人.名称 ||
                        '</YYKS><GHLX>' || r_停诊病人.号类 || '</GHLX><YSXM>' || r_停诊病人.医生姓名 || '</YSXM></INFO>';
          End If;
        End If;
      End Loop;
      v_Temp   := v_Temp || '<BRLIST>' || v_Brinfo || '</BRLIST></ITEM>';
      v_Brinfo := '';
    End Loop;
    v_Temp := '<TZLISTS>' || v_Temp || '</TZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    --换取换诊列表
    v_Temp := '';
    For r_换诊 In (Select d.记录性质, d.No, a.病人id, To_Char(d.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                        To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, a.原号码, a.原医生姓名, b.专业技术职务 As 原职务, a.现号码, a.现医生姓名,
                        c.专业技术职务 As 现职务
                 From 就诊变动记录 A, 人员表 B, 人员表 C, 病人挂号记录 D
                 Where a.登记时间 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60 And a.原医生id = b.Id And a.现医生id = c.Id And
                       a.挂号单 = d.No) Loop
      --只返回该卡类别挂号的病人         
      If r_换诊.记录性质 = 2 Then
        v_Temp := v_Temp || '<ITEM><BRID>' || r_换诊.病人id || '</BRID><YYSJ>' || r_换诊.登记时间 || '</YYSJ>';
        v_Temp := v_Temp || '<YSJ>' || r_换诊.预约时间 || '</YSJ><YHM>' || r_换诊.原号码 || '</YHM><YYS>' || r_换诊.原医生姓名 ||
                  '</YYS><YZC>' || r_换诊.原职务 || '</YZC>';
        v_Temp := v_Temp || '<XSJ>' || r_换诊.预约时间 || '</XSJ><XHM>' || r_换诊.现号码 || '</XHM><XYS>' || r_换诊.现医生姓名 ||
                  '</XYS><XZC>' || r_换诊.现职务 || '</XZC></ITEM>';
      Else
        Begin
          Select 1 Into n_Exists From 病人预交记录 Where NO = r_换诊.No And 记录性质 = 4 And 卡类别id = n_卡类别id;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists = 1 Then
          v_Temp := v_Temp || '<ITEM><BRID>' || r_换诊.病人id || '</BRID><YYSJ>' || r_换诊.登记时间 || '</YYSJ>';
          v_Temp := v_Temp || '<YSJ>' || r_换诊.预约时间 || '</YSJ><YHM>' || r_换诊.原号码 || '</YHM><YYS>' || r_换诊.原医生姓名 ||
                    '</YYS><YZC>' || r_换诊.原职务 || '</YZC>';
          v_Temp := v_Temp || '<XSJ>' || r_换诊.预约时间 || '</XSJ><XHM>' || r_换诊.现号码 || '</XHM><XYS>' || r_换诊.现医生姓名 ||
                    '</XYS><XZC>' || r_换诊.现职务 || '</XZC></ITEM>';
        End If;
      End If;
    End Loop;
    v_Temp := '<HZLISTS>' || v_Temp || '</HZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --计划排班模式
    --获取停诊安排
    For Rs In (Select b.号码, b.医生id, b.医生姓名, To_Char(a.开始停止时间, 'yyyy-mm-dd hh24:mi:ss') As 开始停止时间,
                      To_Char(a.结束停止时间, 'yyyy-mm-dd hh24:mi:ss') As 结束停止时间
               From 挂号安排停用状态 A, 挂号安排 B
               Where a.安排id = b.Id And a.制订日期 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60) Loop
      v_Temp := v_Temp || '<ITEM><HM>' || Rs.号码 || '</HM><YSID>' || Rs.医生id || '</YSID><YS>' || Rs.医生姓名 ||
                '</YS><KSSJ>' || Rs.开始停止时间 || '</KSSJ><JSSJ>' || Rs.结束停止时间 || '</JSSJ>';
      ----2015/7/28
      For Rs_Br In (Select a.No, a.病人id, To_Char(a.发生时间, 'yyyy-mm-dd') As 发生时间,
                           To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.名称, c.号类, a.执行人 As 医生姓名
                    From 病人挂号记录 A, 部门表 B, 挂号安排 C
                    Where a.号别 = Rs.号码 And a.执行状态 = 0 And a.执行部门id = b.Id And b.Id = c.科室id And a.号别 = c.号码 And
                          Trunc(发生时间) Between Trunc(To_Date(Rs.开始停止时间, 'yyyy-mm-dd hh24:mi:ss')) And
                          Trunc(To_Date(Rs.结束停止时间, 'yyyy-mm-dd hh24:mi:ss'))) Loop
        --只返回该卡类别挂号的病人
        Select Count(*)
        Into n_Cnt
        From (Select 1
               From 病人预交记录 A
               Where a.No = Rs_Br.No AND A.记录性质=4 AND a.记录状态 = 1 And a.病人id = Rs_Br.病人id And 卡类别id = n_卡类别id
               Union All
               Select 1 From 病人挂号记录 Where NO = Rs_Br.No And 记录状态 = 1 And 交易说明 = v_Jsklb);
        If n_Cnt > 0 Then
          v_Brinfo := v_Brinfo || '<INFO><YYNO>' || Rs_Br.No || '</YYNO><BRID>' || Rs_Br.病人id || '</BRID><YYSJ>' ||
                      Rs_Br.发生时间 || '</YYSJ><CZSJ>' || Rs_Br.登记时间 || '</CZSJ>' || '<YYKS>' || Rs_Br.名称 ||
                      '</YYKS><GHLX>' || Rs_Br.号类 || '</GHLX><YSXM>' || Rs_Br.医生姓名 || '</YSXM></INFO>';
        End If;
      End Loop;
      v_Temp   := v_Temp || '<BRLIST>' || v_Brinfo || '</BRLIST></ITEM>';
      v_Brinfo := '';
    End Loop;
    v_Temp := '<TZLISTS>' || v_Temp || '</TZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  
    --获取换诊记录
    v_Temp := '';
    For Rs In (Select d.No, a.病人id, To_Char(d.发生时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, a.原号码, a.原医生姓名, b.专业技术职务 As 原职务, a.现号码, a.现医生姓名,
                      c.专业技术职务 As 现职务
               From 就诊变动记录 A, 人员表 B, 人员表 C, 病人挂号记录 D
               Where a.登记时间 Between d_Date And d_Date + 1 - 1 / 24 / 60 / 60 And a.原医生id = b.Id And a.现医生id = c.Id And
                     a.挂号单 = d.No) Loop
      --只返回该卡类别挂号的病人         
      Select Count(*)
      Into n_Cnt
      From (Select 1
             From 病人预交记录 A
             Where a.No = Rs.No And a.记录性质 = 4 And a.记录状态 = 1 And a.病人id = Rs.病人id And 卡类别id = n_卡类别id
             Union All
             Select 1 From 病人挂号记录 Where NO = Rs.No AND 记录状态 = 1 And 交易说明 = v_Jsklb);
      If n_Cnt > 0 Then
        v_Temp := v_Temp || '<ITEM><BRID>' || Rs.病人id || '</BRID><YYSJ>' || Rs.登记时间 || '</YYSJ>';
        v_Temp := v_Temp || '<YSJ>' || Rs.预约时间 || '</YSJ><YHM>' || Rs.原号码 || '</YHM><YYS>' || Rs.原医生姓名 || '</YYS><YZC>' ||
                  Rs.原职务 || '</YZC>';
        v_Temp := v_Temp || '<XSJ>' || Rs.预约时间 || '</XSJ><XHM>' || Rs.现号码 || '</XHM><XYS>' || Rs.现医生姓名 || '</XYS><XZC>' ||
                  Rs.现职务 || '</XZC></ITEM>';
      End If;
    End Loop;
    v_Temp := '<HZLISTS>' || v_Temp || '</HZLISTS>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getregistalter;
/

Create Or Replace Procedure Zl_预约挂号接收_Insert
(
  No_In            门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  领用id_In        票据使用明细.领用id%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  结算方式_In      病人预交记录.结算方式%Type, --现金的结算名称
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额
  预交支付_In      病人预交记录.冲预交%Type, --挂号时使用的预交金额
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额
  发生时间_In      门诊费用记录.发生时间%Type,
  号序_In          挂号序号状态.序号%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  生成队列_In      Number := 0,
  登记时间_In      门诊费用记录.登记时间%Type := Null,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  冲预交病人ids_In Varchar2 := Null,
  三方调用_In      Number := 0,
  更新交款余额_In  Number := 0 --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
) As
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit
  (
    v_病人id        病人信息.病人id%Type,
    v_冲预交病人ids Varchar2
  ) Is
    Select 病人id, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id In (Select Column_Value From Table(f_Num2list(v_冲预交病人ids))) And Nvl(预交类别, 2) = 1
     Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO, 病人id
    Order By Decode(病人id, Nvl(v_病人id, 0), 0, 1), 结帐id, NO;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  Err_Special Exception;

  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;
  v_号别     门诊费用记录.计算单位%Type;
  v_号序     门诊费用记录.发药窗口%Type;
  v_排队号码 排队叫号队列.排队号码 %Type;
  v_预约方式 病人挂号记录.预约方式 %Type;

  n_打印id        票据打印内容.Id%Type;
  n_预交金额      病人预交记录.金额%Type;
  n_返回值        病人预交记录.金额%Type;
  v_冲预交病人ids Varchar2(4000);

  n_挂号id         病人挂号记录.Id%Type;
  n_分诊台签到排队 Number;
  n_组id           财务缴款分组.Id%Type;
  n_Count          Number(18);
  n_排队           Number;
  n_当天排队       Number;
  n_当前金额       病人预交记录.金额%Type;
  n_预交id         病人预交记录.Id%Type;
  n_消费卡id       消费卡目录.Id%Type;
  n_自制卡         Number;

  d_Date       Date;
  d_预约时间   门诊费用记录.发生时间%Type;
  d_发生时间   Date;
  d_排队时间   Date;
  n_时段       Number := 0;
  n_存在       Number := 0;
  v_排队序号   排队叫号队列.排队序号%Type;
  n_结算模式   病人信息.结算模式%Type;
  n_票种       票据使用明细.票种%Type;
  v_付款方式   病人挂号记录.医疗付款方式%Type;
  v_操作员姓名 病人挂号记录.接收人%Type;
  n_接收模式   Number := 0;
Begin
  n_组id          := Zl_Get组id(操作员姓名_In);
  v_冲预交病人ids := Nvl(冲预交病人ids_In, 病人id_In);
  n_接收模式      := Nvl(zl_GetSysParameter('预约接收模式', 1111), 0);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;
  If 登记时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 登记时间_In;
  End If;

  --更新挂号序号状态
  Begin
    Select 号别, 号序, Trunc(发生时间), 发生时间, 预约方式
    Into v_号别, v_号序, d_预约时间, d_发生时间, v_预约方式
    From 病人挂号记录
    Where 记录性质 = 2 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
  Exception
    When Others Then
      Select Max(接收人) Into v_操作员姓名 From 病人挂号记录 Where 记录性质 = 2 And 记录状态 In (1, 3) And NO = No_In;
      If v_操作员姓名 Is Null Then
        v_Err_Msg := '当前预约挂号单已被取消';
        Raise Err_Item;
      Else
        If v_操作员姓名 = 操作员姓名_In Then
          v_Err_Msg := '当前预约挂号单已被接收';
          Raise Err_Special;
        Else
          v_Err_Msg := '当前预约挂号单已被其它人接收';
          Raise Err_Item;
        End If;
      End If;
  End;

  --判断是否分时段
  Begin
    Select 1
    Into n_时段
    From Dual
    Where Exists (Select 1
           From 挂号安排时段 A, 挂号安排 B
           Where a.安排id = b.Id And b.号码 = v_号别 And Rownum < 2
           Union All
           Select 1
           From 挂号计划时段 C, 挂号安排计划 D 　
           Where c.计划id = d.Id And d.号码 = v_号别 And d.生效时间 > Sysdate And Rownum < 2);
  Exception
    When Others Then
      n_时段 := 0;
  End;

  If n_时段 = 0 And 三方调用_In = 0 Then
    If n_接收模式 = 0 Then
      If Trunc(发生时间_In) = Trunc(Sysdate) Then
        d_发生时间 := 发生时间_In;
      Else
        d_发生时间 := Sysdate;
      End If;
    Else
      d_发生时间 := 发生时间_In;
    End If;
  Else
    If Not 发生时间_In Is Null Then
      d_发生时间 := 发生时间_In;
    End If;
  End If;
  If Not v_号序 Is Null Then
    If 号序_In Is Null Then
      Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
    Else
      If Trunc(d_预约时间) <> Trunc(Sysdate) And n_接收模式 = 0 Then
      
        If n_时段 = 0 And 三方调用_In = 0 Then
          --提前接收或延迟接收
          Delete 挂号序号状态 Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
          Begin
            Select 1 Into n_存在 From 挂号序号状态 Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And 序号 = v_号序;
          Exception
            When Others Then
              n_存在 := 0;
          End;
          If n_存在 = 0 Then
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
          Else
            --号码已被使用的情况
            Begin
              v_号序 := 1;
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                Select Min(序号 + 1)
                Into v_号序
                From 挂号序号状态 A
                Where 号码 = v_号别 And 日期 = Trunc(Sysdate) And Not Exists
                 (Select 1 From 挂号序号状态 Where 号码 = a.号码 And 日期 = a.日期 And 序号 = a.序号 + 1);
                Insert Into 挂号序号状态
                  (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
                Values
                  (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            End;
          End If;
        Else
          Update 挂号序号状态
          Set 状态 = 1, 登记时间 = Sysdate
          Where Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序 And 号码 = v_号别 And 状态 = 2;
          If Sql% NotFound Then
            Begin
              Insert Into 挂号序号状态
                (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
              Values
                (v_号别, Trunc(Sysdate), v_号序, 1, 操作员姓名_In, Sysdate);
            Exception
              When Others Then
                v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
                Raise Err_Item;
            End;
          End If;
        
        End If;
      
      Else
        Update 挂号序号状态
        Set 序号 = 号序_In, 状态 = 1, 登记时间 = Sysdate
        Where 号码 = v_号别 And Trunc(日期) = Trunc(d_预约时间) And 序号 = v_号序;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
            Values
              (v_号别, Trunc(d_发生时间), v_号序, 1, 操作员姓名_In, Sysdate);
          Exception
            When Others Then
              v_Err_Msg := '序号' || v_号序 || '已被其它人使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      End If;
    End If;
  Else
    If Not 号序_In Is Null Then
      Begin
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 登记时间)
        Values
          (v_号别, Trunc(Sysdate), 号序_In, 1, 操作员姓名_In, Sysdate);
      Exception
        When Others Then
          v_Err_Msg := '序号' || 号序_In || '已被其它人使用,请重新选择一个序号.';
          Raise Err_Item;
      End;
      v_号序 := 号序_In;
    Else
      v_号序 := Null;
    End If;
  End If;

  --更新门诊费用记录
  Update 门诊费用记录
  Set 记录状态 = 1, 实际票号 = Decode(Nvl(记帐费用_In, 0), 1, Null, 票据号_In), 结帐id = Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In),
      结帐金额 = Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额), 发药窗口 = 诊室_In, 病人id = 病人id_In, 标识号 = 门诊号_In, 姓名 = 姓名_In, 年龄 = 年龄_In,
      性别 = 性别_In, 付款方式 = 付款方式_In, 费别 = 费别_In, 发生时间 = d_发生时间, 登记时间 = d_Date, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In,
      缴款组id = n_组id, 记帐费用 = Decode(Nvl(记帐费用_In, 0), 1, 1, 0)
  Where 记录性质 = 4 And 记录状态 = 0 And NO = No_In;

  --病人挂号记录
  Update 病人挂号记录
  Set 接收人 = 操作员姓名_In, 接收时间 = d_Date, 记录性质 = 1, 病人id = 病人id_In, 门诊号 = 门诊号_In, 发生时间 = d_发生时间, 姓名 = 姓名_In, 性别 = 性别_In,
      年龄 = 年龄_In, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 险类 = Decode(Nvl(险类_In, 0), 0, Null, 险类_In), 号序 = v_号序, 诊室 = 诊室_In
  Where 记录状态 = 1 And NO = No_In And 记录性质 = 2
  Returning ID Into n_挂号id;
  If Sql%NotFound Then
    Begin
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 操作员编号, 操作员姓名,
         摘要, 号序, 预约, 预约方式, 接收人, 接收时间, 预约时间, 险类, 医疗付款方式)
        Select n_挂号id, No_In, 1, 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 计算单位, 加班标志, 诊室_In, Null, 执行部门id, 执行人, 0, Null,
               登记时间, 发生时间, 操作员编号, 操作员姓名, 摘要, v_号序, 1, Substr(结论, 1, 10) As 预约方式, 操作员姓名_In, Nvl(登记时间_In, Sysdate), 发生时间,
               Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式
        From 门诊费用记录
        Where 记录性质 = 4 And 记录状态 = 1 And Rownum = 1 And NO = No_In;
    Exception
      When Others Then
        v_Err_Msg := '由于并发原因,单据号为【' || No_In || '】的病人' || 姓名_In || '已经被接收';
        Raise Err_Item;
    End;
  End If;

  --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
  If Nvl(生成队列_In, 0) <> 0 Then
    n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
    If Nvl(n_分诊台签到排队, 0) = 0 Then
      For v_挂号 In (Select ID, 姓名, 诊室, 执行人, 执行部门id, 发生时间, 号别, 号序 From 病人挂号记录 Where NO = No_In) Loop
      
        Begin
          Select 1,
                 Case
                   When 排队时间 < Trunc(Sysdate) Then
                    1
                   Else
                    0
                 End
          Into n_排队, n_当天排队
          From 排队叫号队列
          Where 业务类型 = 0 And 业务id = v_挂号.Id And Rownum <= 1;
        Exception
          When Others Then
            n_排队 := 0;
        End;
        If n_排队 = 0 Then
          --产生队列
          --按”执行部门”产生队列
          n_挂号id   := v_挂号.Id;
          v_队列名称 := v_挂号.执行部门id;
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, n_挂号id, v_挂号.号别 || '|' || v_挂号.号序);
          v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        
          --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
          d_排队时间 := Zl_Get_Queuedate(n_挂号id, v_挂号.号别, v_挂号.号序, v_挂号.发生时间);
          --   队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In,
          Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, v_挂号.执行部门id, v_排队号码, Null, 姓名_In, 病人id_In, v_挂号.诊室, v_挂号.执行人, d_排队时间,
                           v_预约方式, Null, v_排队序号);
        Elsif Nvl(n_当天排队, 0) = 1 Then
          --更新队列号
          v_排队号码 := Zlgetnextqueue(v_挂号.执行部门id, v_挂号.Id, v_挂号.号别 || '|' || Nvl(v_挂号.号序, 0));
          v_排队序号 := Zlgetsequencenum(0, v_挂号.Id, 1);
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人, v_排队号码, v_排队序号);
        
        Else
          --新队列名称_IN, 业务类型_In, 业务id_In , 科室id_In , 患者姓名_In , 诊室_In, 医生姓名_In ,排队号码_In
          Zl_排队叫号队列_Update(v_挂号.执行部门id, 0, v_挂号.Id, v_挂号.执行部门id, v_挂号.姓名, v_挂号.诊室, v_挂号.执行人);
        End If;
        --预约接收时，改变记录标志
        Update 病人挂号记录 Set 记录标志 = 1 Where ID = n_挂号id;
      End Loop;
    End If;
  End If;

  --汇总结算到病人预交记录
  If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And
     Nvl(记帐费用_In, 0) = 0 Then
    Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算序号,
       结算性质)
    Values
      (n_预交id, 4, 1, No_In, 病人id_In, Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
       n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 结帐id_In, 4);
  
    If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
    
      n_消费卡id := Null;
      Begin
        Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count = 0 Then
        v_Err_Msg := '[ZLSOFT]没有发现原结算卡的相应类别,不能继续操作！[ZLSOFT]';
        Raise Err_Item;
      End If;
      If n_自制卡 = 1 Then
        Select ID
        Into n_消费卡id
        From 消费卡目录
        Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
              序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
      End If;
      Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id);
    End If;
  
  End If;

  --对于就诊卡通过预交金挂号
  If Nvl(预交支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    n_预交金额 := 预交支付_In;
    For r_Deposit In c_Deposit(病人id_In, v_冲预交病人ids) Loop
      n_当前金额 := Case
                  When r_Deposit.金额 - n_预交金额 < 0 Then
                   r_Deposit.金额
                  Else
                   n_预交金额
                End;
      If r_Deposit.结帐id = 0 Then
        --第一次冲预交(填上结帐ID,金额为0)
        Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
         结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 登记时间_In,
               操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结帐id_In, 4
        From 病人预交记录
        Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = r_Deposit.病人id And 性质 = 1 And 类型 = Nvl(1, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (r_Deposit.病人id, Nvl(1, 2), -1 * n_当前金额, 1);
        n_返回值 := -1 * n_当前金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Deposit.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --检查是否已经处理完
      If r_Deposit.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - r_Deposit.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
  End If;

  --对于医保挂号
  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 Then
    Insert Into 病人预交记录
      (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
       预交类别, 结算序号, 结算性质)
    Values
      (病人预交记录_Id.Nextval, 4, 1, No_In, 病人id_In, v_个人帐户, 个帐支付_In, d_Date, 操作员编号_In, 操作员姓名_In, 结帐id_In, '医保挂号', n_组id,
       Null, Null, Null, Null, Null, Null, Null, 结帐id_In, 4);
  End If;

  --相关汇总表的处理
  --人员缴款余额
  If Nvl(现金支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 现金支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金)
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In);
      n_返回值 := 现金支付_In;
    
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Nvl(结算方式_In, v_现金) And Nvl(余额, 0) = 0;
    End If;
  End If;

  If Nvl(个帐支付_In, 0) <> 0 And Nvl(记帐费用_In, 0) = 0 And Nvl(更新交款余额_In, 0) = 0 Then
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + 个帐支付_In
    Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
    Returning 余额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
      n_返回值 := 个帐支付_In;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 收款员 = 操作员姓名_In And 性质 = 1 And Nvl(余额, 0) = 0;
    End If;
  End If;

  --处理票据使用情况
  If 票据号_In Is Not Null And Nvl(记帐费用_In, 0) = 0 Then
    Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
  
    --当前票据的票种
    Select 票种 Into n_票种 From 票据领用记录 Where ID = Nvl(领用id_In, 0);
    --发出票据
    Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, No_In);
  
    Insert Into 票据使用明细
      (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
    Values
      (票据使用明细_Id.Nextval, n_票种, 票据号_In, 1, 1, 领用id_In, n_打印id, d_Date, 操作员姓名_In);
  
    --状态改动
    Update 票据领用记录
    Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = d_Date
    Where ID = Nvl(领用id_In, 0);
  End If;

  If Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
    For c_费用 In (Select 实收金额, 病人科室id, 开单部门id, 执行部门id, 收入项目id
                 From 门诊费用记录
                 Where 记录性质 = 4 And 记录状态 = 1 And NO = No_In And Nvl(记帐费用, 0) = 1) Loop
      --病人余额
      Update 病人余额
      Set 费用余额 = Nvl(费用余额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 费用余额, 预交余额)
        Values
          (病人id_In, 1, 1, Nvl(c_费用.实收金额, 0), 0);
      End If;
    
      --病人未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) + Nvl(c_费用.实收金额, 0)
      Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(c_费用.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(c_费用.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(c_费用.执行部门id, 0) And 收入项目id + 0 = c_费用.收入项目id And
            来源途径 + 0 = 1;
    
      If Sql%RowCount = 0 Then
        Insert Into 病人未结费用
          (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
        Values
          (病人id_In, Null, Null, c_费用.病人科室id, c_费用.开单部门id, c_费用.执行部门id, c_费用.收入项目id, 1, Nvl(c_费用.实收金额, 0));
      End If;
    End Loop;
  End If;
  If Nvl(病人id_In, 0) <> 0 Then
    n_结算模式 := 0;
    Update 病人信息
    Set 就诊时间 = d_发生时间, 就诊状态 = 1, 就诊诊室 = 诊室_In
    Where 病人id = 病人id_In
    Returning Nvl(结算模式, 0) Into n_结算模式;
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  End If;

  --病人担保信息
  If 病人id_In Is Not Null Then
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = d_Date
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, d_Date) >= d_Date;
    End If;
  End If;
  --消息推送
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 1, n_挂号id;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_预约挂号接收_Insert;
/

Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    <JZID>结帐ID</JZID>          //本次结帐ID
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);
  v_Para             Varchar2(500);
  n_挂号模式         Number(3);
  d_启用时间         Date;
  v_临时结算方式     病人预交记录.结算方式%Type;
  n_出诊记录id       临床出诊记录.Id%Type;
  n_序号             门诊费用记录.序号%Type;
  v_附加项目id       Varchar2(500);
  n_实收金额         门诊费用记录.实收金额%Type;
  v_实收             Varchar2(500);
  n_从属父号         门诊费用记录.从属父号%Type;
  n_病人科室id       门诊费用记录.病人科室id%Type;
  n_执行部门id       门诊费用记录.执行部门id%Type;
  v_No               门诊费用记录.No%Type;
  n_医保支付         病人预交记录.冲预交%Type;
  n_Exists           Number;

  v_Temp    Varchar2(32767); --临时XML 
  x_Templet Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Err_Special Exception;
  n_Count    Number(18);
  v_操作员   门诊费用记录.操作员姓名%Type;
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;

  Function Zl_出诊诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
    n_分诊方式 临床出诊记录.分诊方式%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
    Begin
      Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
    Exception
      When Others Then
        v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
        Raise Err_Item;
    End;
  
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select b.名称 As 门诊诊室, 0 As Num
                          From 临床出诊诊室记录 A, 门诊诊室 B
                          Where a.诊室id = b.Id And a.记录id = 记录id_In
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 出诊记录id = 记录id_In And
                                诊室 In (Select d.名称
                                       From 临床出诊诊室记录 C, 门诊诊室 D
                                       Where c.诊室id = d.Id And c.记录id = 记录id_In)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                   From 临床出诊诊室记录 A, 门诊诊室 B
                   Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
        Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
      End If;
    End If;
    Return v_诊室;
  End;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH'))
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;
  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_结帐金额, 0) - Nvl(n_收费总额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    v_Para     := zl_GetSysParameter(256);
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收费类别, b.收入项目id, b.附加标志,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And
                       b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位, b.附加标志
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, c_费用.附加标志, Null, Null, Null, Null, c_费用.病人科室id, c_费用.执行部门id);
      n_结帐金额   := n_结帐金额 + c_费用.实收金额;
      n_序号       := c_费用.序号;
      n_病人科室id := c_费用.病人科室id;
      n_执行部门id := c_费用.执行部门id;
      v_No         := c_费用.No;
    End Loop;
  
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序, b.出诊记录id
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序, n_出诊记录id
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
  
    Begin
      Select Zl_Fun_Customregexpenses(n_病人id, 0, v_号码) Into v_附加项目id From Dual;
    Exception
      When Others Then
        v_附加项目id := Null;
    End;
    If v_附加项目id Is Not Null Then
      For c_附加项目 In (Select /*+cardinality(D,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, Table(f_Str2list(v_附加项目id)) D
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.Column_Value And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                     Union All
                     Select /*+cardinality(E,10)*/
                      6 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D, Table(f_Str2list(v_附加项目id)) E
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = e.Column_Value And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
        n_序号 := n_序号 + 1;
        If c_附加项目.性质 = 5 Then
          n_从属父号 := n_序号;
        End If;
      
        v_实收     := Zl_Actualmoney(v_费别, c_附加项目.项目id, c_附加项目.收入项目id, c_附加项目.数次 * c_附加项目.单价);
        n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      
        If c_附加项目.性质 = 5 Then
          Zl_病人预约挂号记录_Update(v_No, n_序号, Null, Null, c_附加项目.类别, c_附加项目.项目id, c_附加项目.数次, c_附加项目.单价, c_附加项目.收入项目id,
                             c_附加项目.收据费目, c_附加项目.数次 * c_附加项目.单价, n_实收金额, Null, Null, Null, Null, Null, n_病人科室id,
                             n_执行部门id);
        Else
          Zl_病人预约挂号记录_Update(v_No, n_序号, Null, n_从属父号, c_附加项目.类别, c_附加项目.项目id, c_附加项目.数次, c_附加项目.单价, c_附加项目.收入项目id,
                             c_附加项目.收据费目, c_附加项目.数次 * c_附加项目.单价, n_实收金额, Null, Null, Null, Null, Null, n_病人科室id,
                             n_执行部门id);
        End If;
        n_结帐金额 := n_结帐金额 + n_实收金额;
      
      End Loop;
    End If;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_收费总额, 0) - Nvl(n_结帐金额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) + Nvl(n_误差额, 0) <> Nvl(n_收费总额, 0) Then
      Select Max(操作员姓名) Into v_操作员 From 门诊费用记录 Where 记录性质 = 4 And NO = v_Nos;
      If v_操作员 = v_操作员姓名 Then
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Special;
      Else
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Item;
      End If;
    End If;
  
    --预约接收
    If n_挂号模式 = 1 Then
      If d_启用时间 > d_发生时间 And n_出诊记录id Is Null Then
        n_挂号模式 := 0;
      End If;
    End If;
  
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
    If n_挂号模式 = 0 Then
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          If c_结算方式.结算方式 Is Not Null Then
            Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = c_结算方式.结算方式 And 性质 In (3, 4);
            If n_Exists = 1 Then
              n_医保支付 := c_结算方式.结算金额;
            Else
              If Nvl(n_普通支付, 0) = 0 Then
                n_普通支付 := c_结算方式.结算金额;
                v_结算方式 := c_结算方式.结算方式;
                If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                  Begin
                    n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_结算卡序号 := 0;
                  End;
                  If n_结算卡序号 = 0 Then
                    Begin
                      Select 编号
                      Into n_结算卡序号
                      From 卡消费接口目录
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的消费卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                  End If;
                Else
                  Begin
                    n_卡类别id := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_卡类别id := 0;
                  End;
                  If n_卡类别id = 0 Then
                    Begin
                      Select ID
                      Into n_卡类别id
                      From 医疗卡类别
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的医疗卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                  End If;
                End If;
                v_结算卡号   := c_结算方式.结算卡号;
                v_交易流水号 := c_结算方式.交易流水号;
                v_交易说明   := c_结算方式.交易说明;
                v_摘要       := c_结算方式.摘要;
              Else
                v_Err_Msg := '挂号结算暂不支持多种结算方式!';
                Raise Err_Item;
              End If;
            End If;
          Else
            If Nvl(n_普通支付, 0) = 0 Then
              n_普通支付 := c_结算方式.结算金额;
              v_结算方式 := c_结算方式.结算方式;
              If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                Begin
                  n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_结算卡序号 := 0;
                End;
                If n_结算卡序号 = 0 Then
                  Begin
                    Select 编号
                    Into n_结算卡序号
                    From 卡消费接口目录
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的消费卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                End If;
              Else
                Begin
                  n_卡类别id := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_卡类别id := 0;
                End;
                If n_卡类别id = 0 Then
                  Begin
                    Select ID
                    Into n_卡类别id
                    From 医疗卡类别
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的医疗卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                End If;
              End If;
              v_结算卡号   := c_结算方式.结算卡号;
              v_交易流水号 := c_结算方式.交易流水号;
              v_交易说明   := c_结算方式.交易说明;
              v_摘要       := c_结算方式.摘要;
            Else
              v_Err_Msg := '挂号结算暂不支持多种结算方式!';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End Loop;
      Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别,
                       v_结算方式, n_普通支付, n_预交支付, n_医保支付, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号,
                       v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    Else
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          n_普通支付 := Nvl(n_普通支付, 0) + c_结算方式.结算金额;
          If c_结算方式.结算方式 Is Null Then
            --三方卡结算方式
            If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
              Begin
                n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_结算卡序号 := 0;
              End;
              If n_结算卡序号 = 0 Then
                Begin
                  Select 编号
                  Into n_结算卡序号
                  From 卡消费接口目录
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的消费卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            Else
              Begin
                n_卡类别id := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_卡类别id := 0;
              End;
              If n_卡类别id = 0 Then
                Begin
                  Select ID
                  Into n_卡类别id
                  From 医疗卡类别
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的医疗卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
            v_结算卡号   := c_结算方式.结算卡号;
            v_交易流水号 := c_结算方式.交易流水号;
            v_交易说明   := c_结算方式.交易说明;
            v_摘要       := c_结算方式.摘要;
            v_结算方式   := v_结算方式 || '|' || v_临时结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          Else
            --其他结算方式
            v_结算方式 := v_结算方式 || '|' || c_结算方式.结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          End If;
        End If;
      End Loop;
      If v_结算方式 Is Not Null Then
        v_结算方式 := Substr(v_结算方式, 2);
      End If;
      Zl_预约挂号接收_出诊_Insert(v_Nos, Null, Null, n_结帐id, Zl_出诊诊室(n_出诊记录id), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码,
                          v_费别, v_结算方式, n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id,
                          n_结算卡序号, v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    End If;
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1, n_出诊记录id);
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_收费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JZID>' || n_结帐id || '</JZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/



Create Or Replace Procedure Zl_Third_Registdel
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS退号
  --入参:Xml_In:
  --<IN>
  --  <GHDH>A000001</GHDH>    //挂号单号
  --  <JSKLB>支付宝</JSKLB>      //结算卡类别
  --  <JCFP>1</JCFP>            //检查发票
  --  <GHJE>20</GHJE>            //挂号金额
  --  <LSH>34563</LSH>           //交易流水号
  --  <JKFS>0</JKFS>             //缴款方式,0-挂号或预约缴款;1-预约不缴款
  --  <YYFS></YYFS>              //缴款方式=1时传入，预约的预约方式
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  -- <YJZID>原结帐ID</YJZID>
  -- <CXID>冲销ID</CXID>
  -- <ERROR><MSG></MSG></ERROR> //为空表示取消挂号成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_卡类别     Varchar2(100);
  v_No         病人挂号记录.No%Type;
  n_挂号金额   门诊费用记录.实收金额%Type;
  v_操作员编号 门诊费用记录.操作员编号%Type;
  v_操作员姓名 门诊费用记录.操作员姓名%Type;
  v_结算方式   医疗卡类别.结算方式%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  v_交易流水号 病人预交记录.交易流水号%Type;
  n_存在       Number(3);
  v_Type       Varchar2(50);
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  v_Err_Msg    Varchar2(200);
  n_已开医嘱   Number(2);
  n_检查发票   Number(3);
  n_是否打印   Number(3);
  n_缴款方式   Number(3);
  n_结帐id     门诊费用记录.结帐id%Type;
  n_冲销id     门诊费用记录.结帐id%Type;
  d_登记时间   Date;
  v_预约方式   病人挂号记录.预约方式%Type;
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/GHJE'),
         Extractvalue(Value(A), 'IN/LSH'), To_Number(Extractvalue(Value(A), 'IN/JCFP')),
         To_Number(Extractvalue(Value(A), 'IN/JKFS')), Extractvalue(Value(A), 'IN/YYFS')
  Into v_No, v_卡类别, n_挂号金额, v_交易流水号, n_检查发票, n_缴款方式, v_预约方式
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  n_缴款方式 := Nvl(n_缴款方式, 0);

  If n_缴款方式 = 1 Then
    Begin
      Select 1 Into n_存在 From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 结帐id Is Not Null And Rownum < 2;
    Exception
      When Others Then
        n_存在 := 0;
    End;
    If n_存在 = 1 Then
      v_Err_Msg := '传入的挂号单据不是预约挂号单,无法取消预约!';
      Raise Err_Item;
    End If;
    Begin
      Select 1 Into n_存在 From 病人挂号记录 A Where a.No = v_No And a.预约方式 = v_预约方式 And Rownum < 2;
    Exception
      When Others Then
        n_存在 := 0;
    End;
    If n_存在 = 0 Then
      v_Err_Msg := '传入的挂号单据不是' || v_预约方式 || '预约的,无法取消预约!';
      Raise Err_Item;
    End If;
  End If;

  If v_卡类别 Is Not Null And n_缴款方式 = 0 Then
    Select Nvl2(Translate(v_卡类别, '\1234567890', '\'), 'Char', 'Num') Into v_Type From Dual;
    If v_Type = 'Num' Then
      --传入的是卡类别ID
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = To_Number(v_卡类别);
    Else
      --传入的是卡类别名称
      Select 结算方式 Into v_结算方式 From 医疗卡类别 Where 名称 = v_卡类别;
    End If;
  
    Select Sum(实收金额) Into n_实收金额 From 门诊费用记录 Where NO = v_No And 记录性质 = 4;
  
    If Nvl(n_缴款方式, 0) = 0 Then
      --要退的单据不是以该结算卡结算的，则禁止退号
      Begin
        Select 1
        Into n_存在
        From 病人预交记录 A,
             (Select Distinct 结帐id
               From 门诊费用记录
               Where NO = v_No And 记录性质 = 4
               Union
               Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
        Where a.结帐id = b.结帐id And 结算方式 = v_结算方式 And Rownum < 2;
      Exception
        When Others Then
          n_存在 := 0;
      End;
      If n_存在 = 0 Then
        v_Err_Msg := '传入的挂号单据不是' || v_结算方式 || '结算的,无法退号!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --补充结算检查，已存在补结算数据的，不能退号
  Begin
    Select 1
    Into n_存在
    From 费用补充记录 A,
         (Select Distinct 结帐id
           From 门诊费用记录
           Where NO = v_No And 记录性质 = 4
           Union
           Select Distinct 结帐id From 住院费用记录 Where NO = v_No And 记录性质 = 5) B
    Where a.收费结帐id = b.结帐id And a.记录性质 = 1 And a.附加标志 = 1 And Nvl(a.费用状态, 0) <> 2 And Rownum < 2;
  Exception
    When Others Then
      n_存在 := 0;
  End;
  If n_存在 = 1 Then
    v_Err_Msg := '传入的挂号单据已经进行了二次结算,无法退号!';
    Raise Err_Item;
  End If;
  --医嘱检查，已经开过医嘱的，不能退号
  Begin
    Select Distinct 1 Into n_已开医嘱 From 病人医嘱记录 Where 挂号单 = v_No;
  Exception
    When Others Then
      n_已开医嘱 := 0;
  End;
  If n_已开医嘱 = 1 Then
    v_Err_Msg := '传入的挂号单据已经开过医嘱,无法退号!';
    Raise Err_Item;
  End If;
  If Nvl(n_检查发票, 0) = 1 Then
    Select Max(Decode(a.实际票号, Null, 0, 1)) Into n_是否打印 From 门诊费用记录 A Where NO = v_No And 记录性质 = 4;
    If Nvl(n_是否打印, 0) = 1 Then
      v_Err_Msg := '本次退号的单据已开发票,不能退费!';
      Raise Err_Item;
    End If;
  End If;
  --获取操作员信息
  v_Temp := Zl_Identity(1);
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_Temp From Dual;
  Select Substr(v_Temp, 0, Instr(v_Temp, ',') - 1) Into v_操作员编号 From Dual;
  Select Substr(v_Temp, Instr(v_Temp, ',') + 1) Into v_操作员姓名 From Dual;
  d_登记时间 := Sysdate;

  Zl_三方机构挂号_Delete(v_No, v_交易流水号, '移动平台退号', d_登记时间);

  Select Max(结帐id) Into n_结帐id From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 记录状态 = 3;
  Select Max(结帐id) Into n_冲销id From 门诊费用记录 Where NO = v_No And 记录性质 = 4 And 记录状态 = 2;

  v_Temp := '<CZSJ>' || To_Char(d_登记时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YJZID>' || n_结帐id || '</YJZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<CXID>' || n_冲销id || '</CXID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registdel;
/

--103209:刘尔旋,2016-12-15,服务窗医保实时结算
--99656:刘尔旋,2016-08-16,挂号医保接口误差费处理
Create Or Replace Procedure Zl_病人结算记录_Update
(
  结帐id_In       病人预交记录.结帐id%Type,
  保险结算_In     Varchar2, --"结算方式|结算金额||....."
  结帐_In         Number := 0,
  缺省结算方式_In Varchar2 := Null,
  缺省冲预交_In   Number := 0, --0-用现金缴款,1:剩于款项用冲预交支付(门诊预交),2-剩于款项用冲预交支付(住院预交)
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  合作单位_In     病人预交记录.合作单位%Type := Null,
  仅修正医保_In   Number := 0
) As
  --该游标为要删除的由费用记录产生的结算记录

  Cursor c_Del Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And a.结帐id = 结帐id_In;

  Cursor c_Del_医保 Is
    Select a.Id, a.记录性质, a.冲预交, a.结算方式, b.性质, a.预交类别
    From 病人预交记录 A, 结算方式 B
    Where a.结算方式 = b.名称 And b.性质 In (3, 4) And a.结帐id = 结帐id_In;

  --相关信息
  v_No         病人预交记录.No%Type;
  v_病人id     住院费用记录.病人id%Type;
  v_主页id     住院费用记录.主页id%Type;
  v_发生时间   住院费用记录.发生时间%Type;
  v_登记时间   住院费用记录.登记时间%Type;
  v_操作员编号 住院费用记录.操作员编号%Type;
  v_操作员姓名 住院费用记录.操作员姓名%Type;

  --本次结算变量
  v_金额合计 病人预交记录.冲预交%Type;

  --保险结算
  v_保险结算 Varchar2(255);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;

  v_记录性质 病人预交记录.记录性质%Type;
  v_缺省     病人预交记录.结算方式%Type;

  --分币处理及误差变量
  v_现金金额   病人预交记录.冲预交%Type;
  v_Cashcented 病人预交记录.冲预交%Type;
  v_误差金额   病人预交记录.冲预交%Type;
  v_费用id     住院费用记录.Id%Type;
  v_序号       住院费用记录.序号%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  v_收费细目id 住院费用记录.收费细目id%Type;
  v_收入项目id 住院费用记录.收入项目id%Type;
  v_收据费目   住院费用记录.收据费目%Type;
  n_Noexists   Number(3);
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_结算序号   病人预交记录.结算序号%Type;
  n_费用状态   门诊费用记录.费用状态%Type;
  n_预交金额   病人预交记录.金额%Type;
  n_当前金额   病人预交记录.金额%Type;
  v_误差项     结算方式.名称%Type;

  --临时变量
  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_执行状态 门诊费用记录.执行状态%Type;
Begin
  --如果缺省结算方式为空，则取现金结算方式
  If 缺省结算方式_In Is Null Then
    Begin
      Select 名称 Into v_缺省 From 结算方式 Where 性质 = 1 And Rownum < 2;
    Exception
      When Others Then
        v_缺省 := '现金';
    End;
  Else
    v_缺省 := 缺省结算方式_In;
  End If;

  --取得本次结算的相关信息
  If Nvl(结帐_In, 0) = 1 Then
    Select NO, 病人id, 收费时间, 操作员编号, 操作员姓名, 缴款组id, 0
    Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态
    From 病人结帐记录
    Where ID = 结帐id_In;
  Else
    Begin
      n_Noexists := 0;
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 执行状态, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_执行状态, n_费用状态
      From 门诊费用记录
      Where 结帐id = 结帐id_In And Rownum < 2;
    Exception
      When Others Then
        n_Noexists := 1;
    End;
    If n_Noexists = 1 Then
      --费用记录不存在，从补充记录中找
      Select NO, 病人id, 登记时间, 操作员编号, 操作员姓名, 缴款组id, 费用状态
      Into v_No, v_病人id, v_登记时间, v_操作员编号, v_操作员姓名, n_组id, n_费用状态
      From 费用补充记录
      Where 结算id = 结帐id_In And Rownum < 2;
    End If;
    If Nvl(n_费用状态, 0) = 1 Then
      --异常单据为空:
      v_缺省 := Null;
    End If;
  
    Begin
      --20051027 陈东
      Select 记录性质
      Into v_记录性质
      From 病人预交记录
      Where 结帐id = 结帐id_In And Rownum = 1 And Mod(记录性质, 10) <> 1;
    Exception
      When Others Then
        v_记录性质 := -1;
    End;
    If v_记录性质 = -1 Then
      Begin
        Select Decode(记录性质, 1, 3, 11, 3, 4, 4, 记录性质)
        Into v_记录性质
        From 门诊费用记录
        Where 结帐id = 结帐id_In And Rownum = 1;
      Exception
        When Others Then
          --可能是卡费
          Select 记录性质 Into v_记录性质 From 住院费用记录 Where 结帐id = 结帐id_In And Rownum = 1;
      End;
    End If;
  End If;

  If Nvl(v_病人id, 0) <> 0 And Nvl(结帐_In, 0) = 1 Then
    Select 主页id Into v_主页id From 病人信息 Where 病人id = v_病人id;
  End If;
  Select 结算序号 Into n_结算序号 From 病人预交记录 Where 结帐id = 结帐id_In And Rownum = 1;

  ----回退缴款,预交不动,因为没有改冲预交的
  --收费未最未最终完成的,代表按异常单据修正,不处理人员缴款余额
  v_金额合计 := 0;
  If Nvl(仅修正医保_In, 0) = 0 Then
    For r_Del In c_Del Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  Else
    For r_Del In c_Del_医保 Loop
      If r_Del.记录性质 Not In (1, 11) Then
        If Nvl(n_费用状态, 0) <> 1 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) - r_Del.冲预交
          Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (v_操作员姓名, r_Del.结算方式, 1, -1 * r_Del.冲预交);
          End If;
        End If;
        v_金额合计 := v_金额合计 + r_Del.冲预交;
        Delete From 病人预交记录 Where ID = r_Del.Id;
      Else
        --检查是否冲预交
        If Nvl(缺省冲预交_In, 0) <> 0 Then
          v_金额合计 := v_金额合计 + r_Del.冲预交;
          If Nvl(n_费用状态, 0) <> 1 Then
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Del.冲预交, 0)
            Where 病人id = v_病人id And 类型 = Nvl(r_Del.预交类别, 2);
            If Sql%NotFound Then
              Insert Into 病人余额
                (病人id, 性质, 预交余额, 费用余额, 类型)
              Values
                (v_病人id, 1, Nvl(r_Del.冲预交, 0), 0, Nvl(r_Del.预交类别, 2));
            End If;
          End If;
          If r_Del.记录性质 = 1 Then
            Update 病人预交记录 Set 冲预交 = 0 Where ID = r_Del.Id;
          Else
            Delete 病人预交记录 Where ID = r_Del.Id;
          End If;
        End If;
      End If;
    End Loop;
  End If;

  --------------------------------------------------------------------------------------------------------------
  --------------------------------------------------------------------------------------------------------------
  --产生医保支付结算
  If 保险结算_In Is Not Null Then
    --各个保险结算
    v_保险结算 := 保险结算_In || '||';
    While v_保险结算 Is Not Null Loop
      v_当前结算 := Substr(v_保险结算, 1, Instr(v_保险结算, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险部份', v_结算方式, v_登记时间, v_操作员编号,
         v_操作员姓名, v_结算金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    
      v_金额合计 := v_金额合计 - v_结算金额;
    
      v_保险结算 := Substr(v_保险结算, Instr(v_保险结算, '||') + 2);
    End Loop;
  End If;
  --剩余部分用预交
  If Nvl(缺省冲预交_In, 0) <> 0 And v_金额合计 <> 0 Then
  
    n_预交金额 := v_金额合计;
    For c_预交 In (Select *
                 From (Select a.Id, a.记录状态, a.预交类别, a.No, Nvl(a.金额, 0) As 金额
                        From 病人预交记录 A,
                             (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                               From 病人预交记录 A
                               Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 缺省冲预交_In
                               Group By NO
                               Having Sum(Nvl(a.金额, 0)) <> 0) B
                        Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And
                              a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And a.病人id = v_病人id And
                              Nvl(a.预交类别, 2) = 缺省冲预交_In
                        Union All
                        Select 0 As ID, 记录状态, 预交类别, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
                        From 病人预交记录
                        Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And
                              Nvl(预交类别, 2) = 缺省冲预交_In Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
                        Group By 记录状态, NO, 预交类别)
                 Order By ID, NO) Loop
    
      n_当前金额 := Case
                  When c_预交.金额 - n_预交金额 < 0 Then
                   c_预交.金额
                  Else
                   n_预交金额
                End;
    
      If c_预交.Id <> 0 Then
        --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
        Update 病人预交记录
        Set 冲预交 = 0, 结帐id = 结帐id_In, 结算序号 = n_结算序号, 结算性质 = Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        Where ID = c_预交.Id;
      End If;
      --冲上次剩余额
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
         冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
        Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
               v_登记时间, v_操作员姓名, v_操作员编号, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号,
               Mod(Decode(结帐_In, 1, 2, v_记录性质), 10)
        From 病人预交记录
        Where NO = c_预交.No And 记录状态 = c_预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
      Where 病人id = v_病人id And 性质 = 1 And 类型 = Nvl(c_预交.预交类别, 2);
      --检查是否已经处理完
      If c_预交.金额 < n_预交金额 Then
        n_预交金额 := n_预交金额 - c_预交.金额;
      Else
        n_预交金额 := 0;
      End If;
    
      If n_预交金额 = 0 Then
        Exit;
      End If;
    End Loop;
    If n_预交金额 <> 0 Then
      v_Err_Msg := '[ZLSOFT]预交余不够支付本次支付金额,不能继续操作！[ZLSOFT]';
      Raise Err_Item;
    End If;
    Delete From 病人余额 Where 病人id = v_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    v_金额合计 := n_预交金额;
  End If;

  --剩余部份全部用缺省结算方式结算，(小于零也不进行额外处理)
  If v_金额合计 <> 0 Then
    Update 病人预交记录
    Set 冲预交 = 冲预交 + v_金额合计, 卡类别id = 卡类别id_In, 结算卡序号 = 结算卡序号_In, 卡号 = 卡号_In, 交易流水号 = 交易流水号_In, 交易说明 = 交易说明_In,
        合作单位 = 合作单位_In, 结算序号 = n_结算序号
    
    Where 结帐id = 结帐id_In And Nvl(结算方式, 'LXH_Test') = Nvl(v_缺省, 'LXH_Test') And 记录性质 = Decode(结帐_In, 1, 2, v_记录性质);
    If Sql%RowCount = 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 卡类别id, 结算卡序号, 卡号, 交易流水号,
         交易说明, 合作单位, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '保险结算修正', v_缺省, v_登记时间, v_操作员编号,
         v_操作员姓名, v_金额合计, 结帐id_In, n_组id, n_结算序号, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In,
         Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
    End If;
  
    --挂号结算,分币处理(由于挂号界面没有预结算,所以在此过程中根据分币处理规则来修正)
    If v_记录性质 = 4 Then
    
      Begin
        Select a.冲预交
        Into v_现金金额
        From 病人预交记录 A, 结算方式 B
        Where a.结算方式 = b.名称 And b.性质 = 1 And a.结帐id = 结帐id_In;
      Exception
        When Others Then
          v_现金金额 := 0;
      End;
      If Floor(Abs(v_现金金额) * 10) <> Abs(v_现金金额) * 10 Then
        --误差处理
        v_Cashcented := Zl_Cent_Money(v_现金金额);
        v_误差金额   := v_Cashcented - v_现金金额;
        If v_误差金额 <> 0 Then
          Begin
            Select 名称 Into v_误差项 From 结算方式 Where 性质 = 9;
          Exception
            When Others Then
              v_误差项 := Null;
          End;
          If v_误差项 Is Not Null Then
            --10.34之后误差数据
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (病人预交记录_Id.Nextval, Decode(结帐_In, 1, 2, v_记录性质), v_No, 1, v_病人id, v_主页id, '误差费', v_误差项, v_登记时间, v_操作员编号,
               v_操作员姓名, v_误差金额, 结帐id_In, n_组id, n_结算序号, Mod(Decode(结帐_In, 1, 2, v_记录性质), 10));
          Else
            --1.更新预交记录(一定存在记录)
            Update 病人预交记录
            Set 冲预交 = v_Cashcented
            Where 结算方式 = (Select 名称 From 结算方式 Where 性质 = 1 And Rownum = 1) And 结帐id = 结帐id_In;
          
            --2.生成误差费用记录(注:计算单位记录的是号别,所以不取误差项的)
            Begin
              Select a.类别, a.Id, c.Id, c.收据费目
              Into v_收费类别, v_收费细目id, v_收入项目id, v_收据费目
              From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费特定项目 D
              Where d.特定项目 = '误差项' And d.收费细目id = a.Id And a.Id = b.收费细目id And b.收入项目id = c.Id And
                    Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
            Exception
              When Others Then
                v_Err_Msg := '不能正确读取收费误差项的信息，请先检查该项目是否设置正确。';
                Raise Err_Item;
            End;
            If Nvl(结帐_In, 0) = 1 Then
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1, Max(发生时间) Into v_序号, v_发生时间 From 住院费用记录 Where 结帐id = 结帐id_In;
              n_医疗小组id := Zl_医疗小组_Get(0, v_操作员姓名, v_病人id, v_主页id, v_发生时间);
            
              Insert Into 住院费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id, 费别, 收费类别,
                 收费细目id, 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间,
                 登记时间, 执行部门id, 执行人, 执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id, 医疗小组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 床号, 姓名, 性别, 年龄, 病人病区id, 病人科室id,
                       费别, v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用,
                       划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id,
                       Decode(n_医疗小组id, Null, 医疗小组id, n_医疗小组id)
                From 住院费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            Else
              Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
              Select Max(序号) + 1 Into v_序号 From 门诊费用记录 Where 结帐id = 结帐id_In;
              Insert Into 门诊费用记录
                (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id,
                 计算单位, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间,
                 执行部门id, 执行人, 执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 是否上传, 缴款组id)
                Select v_费用id, 记录性质, NO, 实际票号, 记录状态, v_序号, Null, Null, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别,
                       v_收费类别, v_收费细目id, 计算单位, 发药窗口, 1, 1, 加班标志, 9, v_收入项目id, v_收据费目, v_误差金额, v_误差金额, v_误差金额, 记帐费用, 划价人,
                       开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行人, 执行状态, 费用状态, 结帐id_In, v_误差金额, 操作员编号, 操作员姓名, 1, 缴款组id
                From 门诊费用记录
                Where 结帐id = 结帐id_In And Rownum = 1;
            End If;
          End If;
          --3.更新汇总表
          --只可能产生误差金额的变化.仅为了变量处理方便而用游标
        End If;
      End If;
    End If;
  End If;

  --最后再处理"人员缴款余额"(没有动冲预交那部分,所以"病人余额"的预交余额不用更新)
  For r_Del In c_Del Loop
    If r_Del.记录性质 Not In (1, 11) Then
      If Nvl(n_费用状态, 0) <> 1 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + r_Del.冲预交
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = r_Del.结算方式;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, r_Del.结算方式, 1, r_Del.冲预交);
        End If;
      End If;
    End If;
  End Loop;
  Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = v_操作员姓名 And Nvl(余额, 0) = 0;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人结算记录_Update;
/


--101125:李小东,2016-10-09,避免死锁问题处理
--97628:蔡青松,2016-08-16,添加采样人,采样时间等要素
Create Or Replace Procedure Zl_检验报告单_Apply
(
  v_Strval      In Varchar2,
  n_Type        In Number,
  n_Begin       In Number := 0, --开始为0
  v_Lisiteminto In Varchar2 := Null
  --功能           把检验结果回写入HIS病历中,
  --               v_Lisiteminto     采样人<S>采样时间<S>样本条码<S>标本序号<S>标本类型<S>核收人<S>核收时间<S>检验人<S>检验时间<S>审核人<S>审核时间<S>检验评语<S>检验备注
  --参数           v_Strval 专入的标本结果内容，单条申请结果
  --               格式:
  --               类型(1=普通)<split2>申请ID<split2>病人来源<split2>报告时间<split2>报告人<split2>审核人<split2>审核时间<split2>检项目名称<split2>标本类型<split2>婴儿序号<split2> 
  --                   指标1<split4>检验结果1<split4>单位1<split4>结果标志1<split4>结果参数1<split4>排列序号1<split4>隐私项目1<split4>指标代码1<split3>
  --                   指标2<split4>检验结果2<split4>单位2<split4>结果标志2<split4>结果参数2<split4>排列序号2<split4>隐私项目2<split4>指标代码2<split3>
  --                   指标3<split4>检验结果3<split4>单位3<split4>结果标志3<split4>结果参数3<split4>排列序号3<split4>隐私项目3<split4>指标代码3<split2>
  
  --
  --               类型(2=微生物)<split2>申请ID<split2>病人来源<split2>报告时间<split2>报告人<split2>审核人<split2>审核时间<split2>检项目名称<split2>标本类型<split2>婴儿序号
  --               <split2> 采样人<S>采样时间<S>样本条码<S>标本序号<S>标本类型<S>核收人<S>核收时间<S>检验人<S>检验时间<S>审核人<S>审核时间<S>检验评语<S>检验备注<split2>
  --               细菌名1<split3>描述1<split3>耐药机制1<split3>
  --                   抗生素1<split4>抗生素结果1<split4>耐药性1<split4>药敏方法1<split4>用法用量11<split4>用法用量21<split4>血药浓度11<split4>血药浓度21<split4>尿药浓度11<split4>尿药浓度21<split3>
  --                   抗生素2<split4>抗生素结果2<split4>耐药性2<split4>药敏方法2<split4>用法用量12<split4>用法用量22<split4>血药浓度12<split4>血药浓度22<split4>尿药浓度12<split4>尿药浓度22<split2>
  --               细菌名2<split3>描述2<split3>耐药机制2<split3>
  --                   抗生素1<split4>抗生素结果1<split4>耐药性1<split4>药敏方法1<split4>用法用量11<split4>用法用量21<split4>血药浓度11<split4>血药浓度21<split4>尿药浓度11<split4>尿药浓度21<split3>
  --                   抗生素2<split4>抗生素结果2<split4>耐药性2<split4>药敏方法2<split4>用法用量12<split4>用法用量22<split4>血药浓度12<split4>血药浓度22<split4>尿药浓度12<split4>尿药浓度22
  --               intType 0=审核 1=取消审核
) Is
  n_Patiid     病人医嘱记录.病人id%Type;
  n_Pageid     电子病历记录.主页id%Type;
  n_Orderid    病人医嘱记录.Id%Type;
  n_Deptid     病人医嘱记录.开嘱科室id%Type;
  n_Patifrom   病人医嘱记录.病人来源%Type;
  n_Babytag    病人医嘱记录.婴儿%Type;
  v_Creator    电子病历记录.创建人%Type;
  d_Creator    电子病历记录.创建时间%Type;
  v_Speaker    电子病历记录.保存人%Type;
  d_Speaker    电子病历记录.完成时间%Type;
  n_Fileid     病历文件列表.Id%Type;
  v_Filename   病历文件列表.名称%Type;
  n_父id       电子病历内容.父id%Type;
  n_Recordid   电子病历内容.文件id%Type;
  n_Nextid     电子病历内容.Id%Type;
  n_l          Number := 0;
  n_No         Number := 0;
  v_Content    电子病历内容.内容文本%Type;
  v_Reporttag  Number;
  n_Reporttype Number;
  v_Stritems   Varchar2(4000);
  v_List       Varchar2(4000);
  n_i          Number;
  v_Listtype   Varchar2(6);
  v_Lisitem    Varchar2(4000);
  v_Newlis     Varchar2(4000);
  Cursor v_Source Is
    Select ID, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 替换域, 要素名称
    From 病历文件结构
    Where 文件id = n_Fileid
    Order By 对象序号;
  Function v_Split
  (
    p_String    Varchar2,
    p_Separator Varchar2,
    p_Element   Integer
  ) Return Varchar2 As
    --实现VB的Split功能
    --返回在p_String中以p_Separator为分隔的第p_Element个元素串
    --第N个是从第一个开始计
    v_String Varchar2(32767);
  Begin
    v_String := p_String || p_Separator;
    For I In 1 .. p_Element - 1 Loop
      v_String := Substr(v_String, Instr(v_String, p_Separator) + Length(p_Separator));
    End Loop;
    Return Substr(v_String, 1, Instr(v_String, p_Separator) - 1);
  Exception
    When Others Then
      Return Null;
  End v_Split;
Begin

  v_Lisitem := '采样人,采样时间,样本条码,标本序号,标本类型,核收人,核收时间,检验人,检验时间,审核人,审核时间,检验评语,检验备注,单位名称';
  --               类型(1=普通)<split2>申请ID<split2>病人来源<split2>报告时间<split2>报告人<split2>审核人<split2>审核时间<split2>检项目名称<split2>标本类型<split2>婴儿序号
  --                   <split2> 采样人<S>采样时间<S>样本条码<S>标本序号<S>标本类型<S>核收人<S>核收时间<S>检验人<S>检验时间<S>审核人<S>审核时间<S>检验评语<S>检验备注<split2>
  --类型(2=微生物)<split2>申请ID<split2>病人来源<split2>报告时间<split2>报告人<split2>审核人<split2>审核时间<split2>检项目名称<split2>标本类型
  n_Reporttype := v_Split(v_Strval, '<split2>', 1);
  n_Orderid    := v_Split(v_Strval, '<split2>', 2);
  n_Patifrom   := v_Split(v_Strval, '<split2>', 3);
  v_Creator    := v_Split(v_Strval, '<split2>', 5);
  v_Speaker    := v_Split(v_Strval, '<split2>', 6);
  d_Creator    := To_Date(v_Split(v_Strval, '<split2>', 4), 'yyyy-mm-dd HH24:mi:ss');
  d_Speaker    := To_Date(v_Split(v_Strval, '<split2>', 7), 'yyyy-mm-dd HH24:mi:ss');
  --读取病人相关信息
  Select Nvl(主页id, 0), Nvl(病人id, 0), Nvl(开嘱科室id, 0), Nvl(婴儿, 0)
  Into n_Pageid, n_Patiid, n_Deptid, n_Babytag
  From 病人医嘱记录
  Where ID = n_Orderid;
  If n_Patifrom = 1 Then
    --主页ID： 门诊病人填挂号ID
    Select Nvl(b.Id, 0)
    Into n_Pageid
    From 病人挂号记录 B, 病人医嘱记录 A
    Where a.挂号单 = b.No(+) And a.Id = n_Orderid;
  End If;

  Begin
    Select 病历文件id, c.名称
    Into n_Fileid, v_Filename
    From 病人医嘱记录 A, 病历单据应用 B, 病历文件列表 C
    Where a.诊疗项目id = b.诊疗项目id And b.病历文件id = c.Id And a.相关id = n_Orderid And b.应用场合 = n_Patifrom And Rownum <= 1;
  Exception
    When Others Then
      Return;
  End;

  --删除以前的报告记录
  --删除以前的报告记录
  Select Nvl(Max(病历id), 0) Into n_Recordid From 病人医嘱报告 Where 医嘱id = n_Orderid;

  If n_Begin = 0 Then
    If n_Recordid > 0 Then
      Delete 报告查阅记录 Where 医嘱id = n_Orderid;
      Delete 病人医嘱报告 Where 医嘱id = n_Orderid;
      Delete 电子病历记录 Where ID = n_Recordid;
      Delete 电子病历内容 Where 文件id = n_Recordid;
    End If;
  Else
    For r_Source In v_Source Loop
    
      v_Reporttag := 0;
    
      If r_Source.对象类型 = 1 And r_Source.内容文本 = '检验结果' Then
        Select ID
        Into n_Nextid
        From 电子病历内容
        Where 文件id = n_Recordid And 内容文本 = '检验结果' And 对象标记 = r_Source.对象标记 And 对象类型 = r_Source.对象类型;
      
        Select Max(对象序号) Into n_No From 电子病历内容 Where 文件id = n_Recordid;
      
        v_Reporttag := 1;
      
      End If;
    
      If v_Reporttag = 1 Then
        --在 '检验结果' 提纲下插入检验结果
        n_父id := n_Nextid;
        If n_Reporttype = 1 Then
          --取出每组指标集,直到为空时退出循环
          v_Stritems := v_Split(v_Strval, '<split2>', 11);
          For n_l In 1 .. 999 Loop
            v_List := v_Split(v_Stritems, '<split3>', n_l);
            Exit When v_List Is Null;
            n_No := n_No + 1;
            Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
            v_Content := RPad(Nvl(v_Split(v_List, '<split4>', 1), ' '), 35) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 2), ' '), 10) ||
                         LPad(Nvl(v_Split(v_List, '<split4>', 3), ' '), 8) ||
                         LPad(Nvl(v_Split(v_List, '<split4>', 4), ' '), 10) ||
                         LPad(Nvl(v_Split(v_List, '<split4>', 5), ' '), 13);
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
            Values
              (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
          End Loop;
        Else
          --微生物标本
          n_父id := n_Nextid;
        
          --取得每组细菌指标结果集,直到为空时退出循环,位于第10个开始
          For n_i In 10 .. 999 Loop
            v_Stritems := v_Split(v_Strval, '<split2>', n_i);
            Exit When v_Stritems Is Null;
            --取出每组抗生素指标结果串,直到为空时退出循环,位于第4个开始
            For n_l In 4 .. 999 Loop
              v_List := v_Split(v_Stritems, '<split3>', n_l);
              Exit When v_List Is Null;
              n_No      := n_No + 1;
              v_Content := RPad(Nvl(v_Split(v_List, '<split4>', 1), ' '), 20) ||
                           RPad(Nvl(v_Split(v_List, '<split4>', 2), ' '), 5) ||
                           RPad(Nvl(v_Split(v_List, '<split4>', 3), ' '), 12) ||
                           RPad(Nvl(v_Split(v_List, '<split4>', 5), ' '), 12) ||
                           RPad(Nvl(v_Split(v_List, '<split4>', 7), ' '), 7) ||
                           RPad(Nvl(v_Split(v_List, '<split4>', 9), ' '), 7);
              Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
              Insert Into 电子病历内容
                (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
              Values
                (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
            End Loop;
          End Loop;
        End If;
      End If;
    End Loop;
  End If;

  If n_Type = 1 Or n_Begin > 0 Then
    --取消审核
    Return;
  End If;

  ----生成新电子病历记录、医嘱报告关联
  Select 电子病历记录_Id.Nextval Into n_Recordid From Dual;
  Insert Into 电子病历记录
    (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
  Values
    (n_Recordid, n_Patifrom, n_Patiid, n_Pageid, n_Babytag, n_Deptid, 7, n_Fileid, v_Filename, v_Creator, d_Creator,
     d_Speaker, v_Speaker, Sysdate, 1, 0);
  Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (n_Orderid, n_Recordid);

  For r_Source In v_Source Loop
    n_No := n_No + 1;
    Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
    v_Reporttag := 0;
  
    If r_Source.对象类型 = 4 And Instr(v_Lisitem, r_Source.要素名称) > 0 Then
      If r_Source.要素名称 = '采样人' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 1);
      Elsif r_Source.要素名称 = '采样时间' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 2);
      Elsif r_Source.要素名称 = '样本条码' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 3);
      Elsif r_Source.要素名称 = '标本序号' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 4);
      Elsif r_Source.要素名称 = '标本类型' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 5);
      Elsif r_Source.要素名称 = '核收人' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 6);
      Elsif r_Source.要素名称 = '核收时间' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 7);
      Elsif r_Source.要素名称 = '检验人' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 8);
      Elsif r_Source.要素名称 = '检验时间' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 9);
      Elsif r_Source.要素名称 = '审核人' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 10);
      Elsif r_Source.要素名称 = '审核时间' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 11);
      Elsif r_Source.要素名称 = '检验评语' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 12);
      Elsif r_Source.要素名称 = '检验备注' Then
        v_Newlis := v_Split(v_Lisiteminto, '<S>', 13);
      Else
        v_Newlis := Null;
      End If;
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (n_Nextid, n_Recordid, 1, 0, Null, n_No, 2, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性, r_Source.内容行次,
         v_Newlis, r_Source.是否换行);
    
    Elsif r_Source.对象类型 = 4 And r_Source.替换域 = 1 Then
      Select Zl_Replace_Element_Value(r_Source.要素名称, n_Patiid, n_Pageid, n_Patifrom, n_Orderid)
      Into v_Content
      From Dual;
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (n_Nextid, n_Recordid, 1, 0, Null, n_No, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, v_Content, r_Source.是否换行);
    
    Elsif r_Source.对象类型 = 1 And r_Source.内容文本 = '检验结果' Then
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (n_Nextid, n_Recordid, 1, 0, Null, n_No, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, r_Source.内容文本, r_Source.是否换行);
      v_Reporttag := 1;
    Else
      Insert Into 电子病历内容
        (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
      Values
        (n_Nextid, n_Recordid, 1, 0, Null, n_No, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象, r_Source.对象属性,
         r_Source.内容行次, r_Source.内容文本, r_Source.是否换行);
    End If;
  
    If v_Reporttag = 1 Then
      --在 '检验结果' 提纲下插入检验结果
      n_父id := n_Nextid;
      If n_Reporttype = 1 Then
        --普通标本
        n_No := n_No + 1;
        Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
        v_Content := RPad('检验项目', 35) || RPad('检验结果', 10) || LPad('单位', 8) || LPad('结果标志', 10) || LPad('结果参考', 13);
        Insert Into 电子病历内容
          (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
        Values
          (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
        --取出每组指标集,直到为空时退出循环
        v_Stritems := v_Split(v_Strval, '<split2>', 11);
        For n_l In 1 .. 999 Loop
          v_List := v_Split(v_Stritems, '<split3>', n_l);
          Exit When v_List Is Null;
          n_No := n_No + 1;
          Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
          v_Content := RPad(Nvl(v_Split(v_List, '<split4>', 1), ' '), 35) ||
                       RPad(Nvl(v_Split(v_List, '<split4>', 2), ' '), 10) ||
                       LPad(Nvl(v_Split(v_List, '<split4>', 3), ' '), 8) ||
                       LPad(Nvl(v_Split(v_List, '<split4>', 4), ' '), 10) ||
                       LPad(Nvl(v_Split(v_List, '<split4>', 5), ' '), 13);
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
          Values
            (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
        End Loop;
      Else
        --微生物标本
        n_父id := n_Nextid;
      
        --取得每组细菌指标结果集,直到为空时退出循环,位于第10个开始
        For n_i In 10 .. 999 Loop
          v_Stritems := v_Split(v_Strval, '<split2>', n_i);
          Exit When v_Stritems Is Null;
          n_No := n_No + 1;
        
          v_Content  := '       鉴定结果：' || v_Split(v_Stritems, '<split3>', 1) || v_Split(v_Stritems, '<split3>', 2) ||
                        v_Split(v_Stritems, '<split3>', 3) || Chr(13) || Chr(10);
          v_Content  := v_Content || '       抗生素          ';
          v_Listtype := v_Split(v_Stritems, '<split4>', 4);
          Select v_Content || RPad(Decode(v_Listtype, '1-MIC', '  MIC', '2-Disk', ' Disk', '3-K-B', '  K-B', ' '), 5)
          Into v_Content
          From Dual;
          v_Content := v_Content || RPad('耐药性', 12) || RPad('用法用量', 12) || RPad('血药浓度', 7) || RPad('尿药浓度', 7) ||
                       Chr(13) || Chr(10);
          v_Content := v_Content || Replace(RPad(' ', 47, '￣'), ' ', '￣');
          Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
          Values
            (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
        
          --取出每组抗生素指标结果串,直到为空时退出循环,位于第4个开始
          For n_l In 4 .. 999 Loop
            v_List := v_Split(v_Stritems, '<split3>', n_l);
            Exit When v_List Is Null;
            n_No      := n_No + 1;
            v_Content := RPad(Nvl(v_Split(v_List, '<split4>', 1), ' '), 20) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 2), ' '), 5) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 3), ' '), 12) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 5), ' '), 12) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 7), ' '), 7) ||
                         RPad(Nvl(v_Split(v_List, '<split4>', 9), ' '), 7);
            Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行)
            Values
              (n_Nextid, n_Recordid, 1, 0, n_父id, n_No, 2, n_No, Null, 0, Null, v_Content, 1);
          End Loop;
        End Loop;
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验报告单_Apply;
/

--98417:蔡青松,2016-08-12,修复查看老板微生物报告弹出新版界面问题
Create Or Replace Procedure Zl_检验普通结果_Write
(
  检验标本id_In In 检验普通结果.检验标本id%Type,
  仪器id_In     In 检验普通结果.仪器id%Type,
  检验指标_In   In Varchar2, --格式：医嘱ID^项目ID^值^标志^参考^诊疗项目ID|。。。
  是否覆盖_In   In Number,
  微生物_In     In Number := 0
) Is
  Err_Custom Exception;
  V_Flag      Number(1);
  V_Records   Varchar2(4000);
  V_Currrec   Varchar2(500);
  V_Item      Varchar2(200);
  V_医嘱id    检验项目分布.医嘱id%Type;
  V_项目id    检验普通结果.检验项目id%Type;
  V_检验结果  检验普通结果.检验结果%Type;
  V_检验结果1 检验普通结果.检验结果%Type;

  V_结果标志   检验普通结果.结果标志%Type;
  V_结果参考   检验普通结果.结果参考%Type;
  V_结果参考1  检验普通结果.结果参考%Type;
  V_诊疗项目id 检验普通结果.诊疗项目id%Type;
  V_排列序号   检验普通结果.排列序号%Type;
  V_Pos1       Number;
  V_Pos2       Number;
  V_标本类型   检验标本记录.标本类型%Type;
  V_性别       检验标本记录.性别%Type;
  V_年龄       检验标本记录.年龄%Type;
  V_出生日期   病人信息.出生日期%Type;

  V_糖耐量id  检验普通结果.检验项目id%Type;
  V_糖耐量id1 检验普通结果.检验项目id%Type;

  V_多参考 Number;

  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar(10);
    Function Sub_Is_Number(V_In In Varchar2) Return Boolean Is
      N_Tmp Number;
    Begin
      N_Tmp := To_Number(V_In);
      If N_Tmp Is Not Null Then
        Return True;
      Else
        Return False;
      End If;
    Exception
      When Others Then
        Return False;
    End Sub_Is_Number;
  Begin
    Strnum := '';
    If Sub_Is_Number(Vstr) = True Then
      Result := To_Number(Nvl(Vstr, 0));
      Return(Result);
    Else
      For Intbit In 1 .. 10 Loop
        If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
          Exit;
        End If;
        Strnum := Strnum || Substr(Vstr, Intbit, 1);
        Null;
      End Loop;
      Result := To_Number(Nvl(Strnum, 0));
      Return(Result);
    End If;
  End Zlval;
  -- >>>>>>>>>>>>>>>>>>  检查是否数字的函数  <<<<<<<<<<<<<<<<<<
  Function Sub_Is_Number(V_In In Varchar2) Return Boolean Is
    N_Tmp Number;
  Begin
    N_Tmp := To_Number(V_In);
    If N_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;
Begin
  V_Records := 检验指标_In || '|';
  --已审核不能覆盖
  V_Flag := 0;
  Begin
    Select 1 Into V_Flag From 检验标本记录 Where ID = 检验标本id_In And 样本状态 = 2;
  Exception
    When Others Then
      V_Flag := 0;
  End;
  If V_Flag = 1 Then
    Return;
  End If;

  If 是否覆盖_In = 1 Then
    Delete From 检验普通结果 Where 检验标本id = 检验标本id_In;
    Delete 检验项目分布 Where 标本id = 检验标本id_In;
  End If;
  --没有找到数据后退出
  Begin
    Select A.标本类型, A.性别, A.年龄, B.出生日期
    Into V_标本类型, V_性别, V_年龄, V_出生日期
    From 检验标本记录 A, 病人信息 B
    Where A.病人id = B.病人id(+) And A.Id = 检验标本id_In;
  Exception
    When Others Then
      Return;
  End;

  If 检验指标_In Is Not Null Then
    While V_Records Is Not Null Loop
      V_Currrec    := Substr(V_Records, 1, Instr(V_Records, '|') - 1);
      V_Pos1       := Instr(V_Currrec, '^', 1);
      V_医嘱id     := To_Number(Substr(V_Currrec, 1, V_Pos1 - 1));
      V_Pos2       := Instr(V_Currrec, '^', V_Pos1 + 1);
      V_项目id     := To_Number(Substr(V_Currrec, V_Pos1 + 1, V_Pos2 - V_Pos1 - 1));
      V_Pos1       := Instr(V_Currrec, '^', V_Pos2 + 1);
      V_检验结果   := Substr(V_Currrec, V_Pos2 + 1, V_Pos1 - V_Pos2 - 1);
      V_Pos2       := Instr(V_Currrec, '^', V_Pos1 + 1);
      V_结果标志   := To_Number(Substr(V_Currrec, V_Pos1 + 1, V_Pos2 - V_Pos1 - 1));
      V_Pos1       := Instr(V_Currrec, '^', V_Pos2 + 1);
      V_结果参考   := To_Number(Substr(V_Currrec, V_Pos1 + 1, V_Pos2 - V_Pos1 - 1));
      V_Pos2       := Instr(V_Currrec, '^', V_Pos1 + 1);
      V_诊疗项目id := To_Number(Substr(V_Currrec, V_Pos1 + 1, V_Pos2 - V_Pos1 - 1));
      V_排列序号   := Substr(V_Currrec, V_Pos2 + 1);

      V_Flag := 0;
      If 是否覆盖_In <> 1 Then
        V_检验结果1 := V_检验结果;
        Begin
          If 微生物_In = 0 Then
            --新增2005-5-26
            Select 1, 检验结果
            Into V_Flag, V_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 检验项目id = V_项目id;
          Else
            Select 1, 检验结果
            Into V_Flag, V_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 细菌id = V_项目id;
          End If;
        Exception
          When Others Then
            V_Flag     := 0;
            V_检验结果 := V_检验结果1;
        End;
      End If;
      If V_Flag = 0 Then
        If 微生物_In = 0 Then
          Insert Into 检验普通结果
            (ID, 检验标本id, 检验项目id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, V_项目id, V_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In),
             Decode(V_多参考, 0, V_结果标志, 1), Decode(V_多参考, 0, V_结果参考, V_结果参考1), V_诊疗项目id, V_排列序号);
        Else
          If Instr(V_检验结果, ';') > 0 Then
            If Instr(V_检验结果, V_标本类型) > 0 Then
              --找到标本
              V_Item := Substr(V_检验结果, Instr(V_检验结果, V_标本类型));
              V_Item := Substr(V_Item, Instr(V_Item, ',') + 1);
              If Instr(V_Item, ';') > 0 Then
                V_检验结果 := Substr(V_Item, 1, Instr(V_Item, ';') - 1);
              Else
                V_检验结果 := V_Item;
              End If;
            Else
              --没有找到相同的标本类型时使用第一个
              V_Item := Substr(V_检验结果, Instr(V_检验结果, ',') + 1);
              If Instr(V_Item, ';') > 0 Then
                V_检验结果 := Substr(V_Item, 1, Instr(V_Item, ';') - 1);
              Else
                V_检验结果 := V_Item;
              End If;
            End If;
          End If;

          Insert Into 检验普通结果
            (ID, 检验标本id, 细菌id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, V_项目id, V_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In), V_结果标志, V_结果参考,
             V_诊疗项目id, V_排列序号);

          Insert Into 检验药敏结果
            (细菌结果id, 抗生素id, 修改者, 修改时间, 结果, 结果类型, 记录类型, 仪器id)
            Select 检验普通结果_Id.Currval, B.抗生素id, '', Null, '', C.默认药敏, 0, Decode(仪器id_In, 0, Null, 仪器id_In)
            From (Select 抗生素分组id, 细菌id
                   From (Select 抗生素分组id, 细菌id
                          From 检验细菌抗生素 A
                          Where A.细菌id = V_项目id
                          Order By Nvl(缺省标志, 0) Desc)
                   Where Rownum = 1) A, 检验抗生素用药 B, 检验细菌 C
            Where A.抗生素分组id = B.抗生素分组id And C.Id = V_项目id;
        End If;
      End If;
      If V_医嘱id = 0 Then
        V_医嘱id := Null;
      End If;
      If 微生物_In = 0 Then
        Update 检验项目分布
        Set 医嘱id = Decode(V_医嘱id, Null, 医嘱id, V_医嘱id)
        Where 标本id = 检验标本id_In And 项目id + 0 = V_项目id And 医嘱id Is Null;
        If Sql%Rowcount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 项目id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, V_项目id, V_医嘱id, 1);
        End If;
      Else
        Update 检验项目分布
        Set 医嘱id = Decode(V_医嘱id, Null, 医嘱id, V_医嘱id)
        Where 标本id = 检验标本id_In And 细菌id + 0 = V_项目id And 医嘱id Is Null;
        If Sql%Rowcount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 细菌id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, V_项目id, V_医嘱id, 1);
        End If;
      End If;

      V_Records := Replace('|' || V_Records, '|' || V_Currrec || '|');
    End Loop;
  elsif 微生物_In=1 then
        select 医嘱ID into v_医嘱ID from 检验标本记录 where ID=检验标本id_In;
        Update 检验项目分布
        Set 医嘱id = Decode(V_医嘱id, Null, 医嘱id, V_医嘱id)
        Where 标本id = 检验标本id_In  And 医嘱id Is Null;
        If Sql%Rowcount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id,  医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval,  检验标本id_In, V_医嘱id, 1);
        End If;
    
  End If;
  If 微生物_In = 0 Then
    --通过医嘱来自动合并糖耐量项目
    Begin
      Select B.检验项目id
      Into V_糖耐量id
      From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
      Where A.Id = B.检验标本id And B.检验项目id = C.项目id And A.仪器id = C.仪器id And C.糖耐量项目 = -1 And A.Id = 检验标本id_In And
            B.检验结果 Is Not Null;

      Select E.项目id
      Into V_糖耐量id1
      From 检验标本记录 A, 检验项目分布 B, 病人医嘱记录 C, 检验报告项目 D, 检验仪器项目 E
      Where A.Id = B.标本id And B.医嘱id = C.相关id And C.诊疗项目id = D.诊疗项目id And A.仪器id = E.仪器id And D.报告项目id = E.项目id And
            E.糖耐量项目 = -1 And A.Id = 检验标本id_In;

      Update 检验普通结果 Set 检验项目id = V_糖耐量id1 Where 检验标本id = 检验标本id_In And 检验项目id = V_糖耐量id;
      Delete 检验普通结果
      Where 检验标本id = 检验标本id_In And 检验结果 Is Null And
            检验项目id In
            (Select B.检验项目id
             From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
             Where A.Id = B.检验标本id And B.检验项目id = C.项目id And A.仪器id = C.仪器id And C.糖耐量项目 = -1 And A.Id = 检验标本id_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]||v_Error||[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_检验普通结果_Write;
/

--101049:刘尔旋,2016-10-17,支付宝挂号适用性检查
--99524:刘尔旋,2016-08-16,专家号挂号限制
--99034:刘尔旋,2016-08-16,三方挂号检查接口
Create Or Replace Procedure Zl_Third_Registercheck
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS挂号检查
  --入参:Xml_In:
  --<IN>
  --  <BRID>1</BRID>                    //病人ID
  --  <HM>0100</HM>                     //号码
  --  <CZJLID>100</CZJLID>              //出诊记录ID,计划排班模式可以不传
  --  <GHSJ>2016-08-10 09:52:00</GHSJ>  //挂号时间
  --  <KSID>1</KSID>                    //科室ID
  --  <YSXM>张震</YSXM>                 //医生姓名
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <ERROR><MSG></MSG></ERROR> //为空表示检查成功
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_存在           Number(3);
  n_病人id         病人信息.病人id%Type;
  v_号码           挂号安排.号码%Type;
  n_出诊记录id     Number(18);
  d_发生时间       病人挂号记录.发生时间%Type;
  v_Type           Varchar2(50);
  v_Para           Varchar2(500);
  d_启用时间       Date;
  n_挂号模式       Number(3);
  n_同科限号数     Number;
  n_同科限约数     Number;
  n_病人挂号科室数 Number;
  n_病人预约科室数 Number;
  n_专家号挂号限制 Number;
  n_专家号预约限制 Number;
  n_Exists         Number;
  n_Count          Number;
  n_科室id         病人挂号记录.执行部门id%Type;
  n_医生id         人员表.Id%Type;
  v_医生姓名       病人挂号记录.执行人%Type;
  v_性别           病人信息.性别%Type;
  v_年龄           病人信息.年龄%Type;
  n_已约科室       Number;
  v_Checkresult    Varchar2(500);
  v_Temp           Varchar2(32767); --临时XML
  x_Templet        Xmltype; --模板XML
  v_Err_Msg        Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/BRID'), Extractvalue(Value(A), 'IN/HM'), Extractvalue(Value(A), 'IN/CZJLID'),
         To_Date(Extractvalue(Value(A), 'IN/GHSJ'), 'yyyy-mm-dd hh24:mi:ss'),
         To_Number(Extractvalue(Value(A), 'IN/KSID')), Extractvalue(Value(A), 'IN/YSXM')
  Into n_病人id, v_号码, n_出诊记录id, d_发生时间, n_科室id, v_医生姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para := zl_GetSysParameter(256);
  If v_Para Is Not Null Then
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  
    If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
      If n_挂号模式 = 1 And Nvl(d_发生时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
        v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    Else
      If n_挂号模式 = 1 And Nvl(d_发生时间, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = v_号码 And Nvl(d_发生时间, Sysdate) Between a.开始时间 And a.终止时间;
        Exception
          When Others Then
            v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
            v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
            Xml_Out := x_Templet;
            Return;
        End;
      End If;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    Select 性别, 年龄 Into v_性别, v_年龄 From 病人信息 Where 病人id = n_病人id And Rownum < 2;
    v_Checkresult := Zl_临床出诊限制_Check(n_出诊记录id, v_年龄, v_性别);
    If Substr(Nvl(v_Checkresult, '0'), 1, 1) <> '0' Then
      v_Temp := '病人不适用该本号别,请检查！';
      v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
      Xml_Out := x_Templet;
      Return;
    End If;
  End If;

  If Trunc(Sysdate) > Trunc(d_发生时间) Then
    v_Temp := '不能挂以前的号(' || To_Char(d_发生时间, 'yyyy-mm-dd') || ')。';
    v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  v_Temp := Zl_Identity(0);
  If Nvl(v_Temp, ' ') = ' ' Then
    v_Temp := '当前操作人员未设置对应的人员关系,不能继续。';
    v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
  n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
  n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
  n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
  n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
  n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
  n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));

  If Trunc(Sysdate) <> Trunc(d_发生时间) Then
    If Nvl(n_病人预约科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(d_发生时间) And
                              Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
        v_Temp := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
    If Nvl(n_同科限约数, 0) <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(d_发生时间) And
            Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
        v_Temp := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
  Else
    If Nvl(n_病人挂号科室数, 0) <> 0 Then
      n_已约科室 := 0;
      For c_Chkitem In (Select Distinct 执行部门id
                        From 病人挂号记录
                        Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(d_发生时间) And
                              Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
        n_已约科室 := n_已约科室 + 1;
      End Loop;
      If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
        v_Temp := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
    If Nvl(n_同科限号数, 0) <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人挂号记录
      Where 病人id = n_病人id And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(d_发生时间) And
            Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
      If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
        v_Temp := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
        v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
        Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
        Xml_Out := x_Templet;
        Return;
      End If;
    End If;
  End If;

  If Trunc(Sysdate) = Trunc(d_发生时间) Then
    --挂号
    If Nvl(n_专家号挂号限制, 0) <> 0 And v_医生姓名 Is Not Null Then
      If n_出诊记录id Is Null Then
        --无出诊记录对应
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 号别 = v_号码 And 发生时间 Between Trunc(d_发生时间) And Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And
                记录状态 = 1 And 记录性质 = 1;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号挂号限制 Then
          v_Temp := '该病人已经超过本号挂号限制,不能再次挂号！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      Else
        --对应出诊记录
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 出诊记录id = n_出诊记录id And 记录状态 = 1 And 记录性质 = 1;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号挂号限制 Then
          v_Temp := '该病人已经超过本号挂号限制,不能再次挂号！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      End If;
    End If;
  Else
    --预约
    If Nvl(n_专家号预约限制, 0) <> 0 And v_医生姓名 Is Not Null Then
      If n_出诊记录id Is Null Then
        --无出诊记录对应
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 号别 = v_号码 And 发生时间 Between Trunc(d_发生时间) And Trunc(d_发生时间) + 1 - 1 / 24 / 60 / 60 And
                记录状态 = 1 And 记录性质 = 2;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号预约限制 Then
          v_Temp := '该病人已经超过本号预约限制,不能再次预约！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      Else
        --对应出诊记录
        Begin
          Select Count(1)
          Into n_Exists
          From 病人挂号记录
          Where 病人id = n_病人id And 出诊记录id = n_出诊记录id And 记录状态 = 1 And 记录性质 = 2;
        Exception
          When Others Then
            n_Exists := 0;
        End;
        If n_Exists >= n_专家号预约限制 Then
          v_Temp := '该病人已经超过本号预约限制,不能再次预约！';
          v_Temp := '<ERROR><MSG>' || v_Temp || '</MSG></ERROR>';
          Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
          Xml_Out := x_Templet;
          Return;
        End If;
      End If;
    End If;
  End If;

  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Registercheck;
/


--99524:刘尔旋,2016-08-12,获取病人ID问题
Create Or Replace Procedure Zl_Third_Buildpatiinfo
(
  Xml_In    In Xmltype,
  Expend_In In Xmltype,
  Xml_Out   Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:挂号数据写入
  --入参:Xml_In:
  --  <IN>
  --    <FB>费别</FB>                      //掌上中联后台中设定
  --    <FKFS>医疗付款方式</FKFS>          //掌上中联后台中设定
  --    <XM>姓名</XM>
  --    <XB>性别</XB>
  --    <NL>年龄</NL>
  --    <CSRQ>出生日期</CSRQ>
  --    <SFZ >身份证号</SFZ>              //必须有
  --    <KLB>医疗卡名称</KLB>             //固定为：手机支付
  --     <SJH>手机号</SJH>                //如果手机号为空，则以身份证号创建就诊卡；否则以手机号创建就诊卡
  --  </IN>
  --      Expend_In:扩展信息,暂不用,主要是适应移动产品的参数统一
  --出参:Xml_Out
  --  <OUTPUT>
  --    <BRID>1</BRID>                   //返回创建好的档案，或原来已有的档案
  --                                     //如无下列错误结点则说明正确执行
  --    <ERROR>
  --      <MSG>错误信息</MSG>
  --    </ERROR>
  --  </OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_费别         病人信息.费别%Type;
  v_付款方式     病人信息.医疗付款方式%Type;
  v_姓名         病人信息.姓名%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  d_出生日期     病人信息.出生日期%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_医疗卡名称   医疗卡类别.名称%Type;
  v_卡号         病人医疗卡信息.卡号%Type;
  n_卡类别id     医疗卡类别.Id%Type;
  v_结算方式     医疗卡类别.结算方式%Type;
  v_验证姓名     病人信息.姓名%Type;
  n_病人id       病人信息.病人id%Type;
  n_卡病人id     病人信息.病人id%Type;
  v_医疗卡编码   医疗卡类别.编码%Type;
  n_是否缺省密码 医疗卡类别.是否缺省密码%Type;
  v_密码         病人医疗卡信息.密码%Type;
  n_密码长度     医疗卡类别.密码长度%Type;
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(2);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/FB'), Extractvalue(Value(A), 'IN/FKFS'), Extractvalue(Value(A), 'IN/XM'),
         Extractvalue(Value(A), 'IN/SFZ'), Extractvalue(Value(A), 'IN/KLB'), Extractvalue(Value(A), 'IN/SJH'),
         Extractvalue(Value(A), 'IN/XB'), Extractvalue(Value(A), 'IN/NL'), To_Date(Extractvalue(Value(A), 'IN/CSRQ')),
         Extractvalue(Value(A), 'IN/YLKID'), Extractvalue(Value(A), 'IN/YLKBM')
  Into v_费别, v_付款方式, v_姓名, v_身份证号, v_医疗卡名称, v_卡号, v_性别, v_年龄, d_出生日期, n_卡类别id, v_医疗卡编码
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --某些入参节点为空的情况
  If Nvl(v_卡号, '_') = '_' Then
    v_卡号 := v_身份证号;
  End If;
  If Nvl(v_性别, '_') = '_' Then
    If Mod(To_Number(Substr(v_身份证号, -2, 1)), 2) = 1 Then
      v_性别 := '男';
    Else
      v_性别 := '女';
    End If;
  End If;
  If d_出生日期 Is Null Then
    If Length(Trim(v_身份证号)) = 15 Then
      d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
    End If;
    If Length(Trim(v_身份证号)) = 18 Then
      d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
    End If;
  End If;
  If Nvl(v_年龄, '_') = '_' Then
    v_年龄 := Zl_Age_Calc(0, d_出生日期, Sysdate);
  End If;

  --检查医疗卡名称
  If Nvl(n_卡类别id, 0) = 0 Then
    If Nvl(v_医疗卡编码, '_') <> '_' Then
      v_Err_Msg := Null;
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 编码 = v_医疗卡编码;
      Exception
        When Others Then
          v_Err_Msg := '医疗卡编码:' || v_医疗卡编码 || '不存在!';
      End;
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
    Elsif Nvl(v_医疗卡名称, '_') <> '_' Then
    
      v_Err_Msg := Null;
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
        Into n_卡类别id, v_结算方式, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_医疗卡名称;
      Exception
        When Others Then
          v_Err_Msg := v_医疗卡名称 || '不存在!';
      End;
      If Not v_Err_Msg Is Null Then
        Raise Err_Item;
      End If;
    Else
      v_Err_Msg := '系统不能识别有效的医疗卡,不允许挂号!';
      Raise Err_Item;
    End If;
  Else
    v_Err_Msg := Null;
    Begin
      Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行挂号!')
      Into n_卡类别id, v_结算方式, v_Err_Msg
      From 医疗卡类别
      Where ID = n_卡类别id;
    Exception
      When Others Then
        v_Err_Msg := '系统不能识别指定的医疗卡(' || n_卡类别id || ')!';
    End;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;

  --建档操作
  Begin
    Select 1, 姓名, 病人id Into n_Exists, v_验证姓名, n_病人id From 病人信息 Where 身份证号 = v_身份证号;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists >= 1 Then
    If v_姓名 <> v_验证姓名 Then
      v_Err_Msg := '身份证号码与病人姓名不匹配!';
      Raise Err_Item;
    End If;
  Else
    n_病人id := Nextno(1);
    Zl_挂号病人病案_Insert(1, n_病人id, Null, Null, Null, v_姓名, v_性别, v_年龄, v_费别, v_付款方式, Null, Null, Null, Null, v_身份证号, Null,
                     Null, Null, Null, Null, Null, Null, Sysdate, Null, Null, d_出生日期);
  End If;
  v_Temp := '<BRID>' || n_病人id || '</BRID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
  --发卡操作
  Begin
    Select 1, 病人id Into n_Exists, n_卡病人id From 病人医疗卡信息 Where 卡类别id = n_卡类别id And 卡号 = v_卡号;
  Exception
    When Others Then
      n_Exists := 0;
  End;
  If n_Exists = 0 Then
    Zl_医疗卡变动_Insert(1, n_病人id, n_卡类别id, Null, v_卡号, '手机建档', Null, Null, Sysdate);
  Else
    If n_病人id <> n_卡病人id Then
      v_Err_Msg := '该卡号已经被其他人绑定!';
      Raise Err_Item;
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatiinfo;
/


--99524:刘尔旋,2016-08-12,获取病人ID问题
Create Or Replace Procedure Zl_Third_Buildpatient
(
  Patiinfo_In  In Xmltype,
  Patiinfo_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------
  --参数说明:
  -- 入参 Patiinfo_In:
  --<IN>
  --  <ZJH></ZJH>                 //证件号，目前仅支持身份证号
  --  <ZJLX></ZJLX>                       //证件类型(目前仅支持身份证,为空时默认为身份证)
  --  <XM></XM>                       //姓名
  --  <SJH></SJH>                      //手机号
  --</IN>

  --出参 Patiinfo_Out：
  --<OUTPUT>
  --       <BRID></BRID>                //病人ID
  --       <MZH></MZH>                  //门诊号
  --     <ERROR></ERROR>         //如果有错误返回该节点
  --</OUTPUT>
  -------------------------------------------------------------------------------
  n_Pati_Id      病人信息.病人id%Type;
  n_Card_Type_Id 医疗卡类别.Id%Type;
  n_Count        Number(5);
  n_Sum          Number(5);
  v_校验位       Varchar2(50);

  v_姓名         病人信息.姓名%Type;
  v_身份证号     病人信息.身份证号%Type;
  v_手机号       病人信息.家庭电话%Type;
  v_性别         病人信息.性别%Type;
  v_年龄         病人信息.年龄%Type;
  v_操作员       人员表.姓名%Type;
  v_医疗付款方式 病人信息.医疗付款方式%Type;
  n_门诊号       病人信息.门诊号%Type;
  v_证件类型     医疗卡类别.名称%Type;
  v_证件号       病人医疗卡信息.卡号%Type;

  v_Pattern Varchar2(500);
  v_Temp    Varchar2(32767); --临时XML
  v_Err_Msg Varchar2(2000);
  n_存在    Number(2);

  d_出生日期  病人信息.出生日期%Type;
  d_Curr_Time Date;

  Err_Item Exception;
Begin
  Patiinfo_Out := Xmltype('<OUTPUT></OUTPUT>');
  Select Sysdate Into d_Curr_Time From Dual;

  --新建病人：姓名、身份证号、手机号（存在家庭电话中）、出生日期、性别、年龄(后面三项可从身份证中获取)。
  Select Extractvalue(Value(I), 'IN/XM'), Extractvalue(Value(I), 'IN/ZJH'), Extractvalue(Value(I), 'IN/SJH'),
         Extractvalue(Value(I), 'IN/ZJLX')
  Into v_姓名, v_证件号, v_手机号, v_证件类型
  From Table(Xmlsequence(Extract(Patiinfo_In, 'IN'))) I;

  Begin
    If v_证件类型 Is Null Then
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 Like '%身份证%') And Rownum < 2;
    Else
      Select 病人id
      Into n_Pati_Id
      From 病人医疗卡信息
      Where 卡号 = v_证件号 And 卡类别id In (Select ID From 医疗卡类别 Where 名称 = v_证件类型) And Rownum < 2;
    End If;
    n_存在 := 1;
  Exception
    When Others Then
      n_存在 := 0;
  End;

  If Nvl(n_存在, 0) = 1 Then
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    Select 门诊号 Into n_门诊号 From 病人信息 Where 病人id = n_Pati_Id;
    If n_门诊号 Is Null Then
      n_门诊号 := Nextno(3);
      Update 病人信息 Set 门诊号 = n_门诊号 Where 病人id = n_Pati_Id;
    End If;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  Else
    If v_姓名 Is Null Then
      v_Err_Msg := '传人姓名为空!';
      Raise Err_Item;
    End If;
    If v_证件类型 Like '%身份证%' Or v_证件类型 Is Null Then
      v_身份证号 := v_证件号;
    Else
      v_Err_Msg := '目前不支持身份证以外的方式建档！';
      Raise Err_Item;
    End If;
  
    If v_身份证号 Is Null Then
      v_Err_Msg := '传人身份证号为空!';
      Raise Err_Item;
    Else
      --身份证合法验证
      v_Pattern := '11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82,91';
    
      --地区检验
      If Instr(v_Pattern, Substr(v_身份证号, 1, 2)) = 0 Then
        v_Err_Msg := '身份证前两位地区码不正确!';
        Raise Err_Item;
      End If;
      --身份证长度检查
      If Length(v_身份证号) = 15 Then
        --检查身份证号:15位身份证号要求全部为数字
        v_Pattern := '^\d{15}$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符，请检查!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 15, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date('19' || Substr(v_身份证号, 7, 6), 'yyyy-mm-dd');
        v_Pattern  := '^[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like('19' || Substr(v_身份证号, 7, 6), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
        End If;
      Elsif Length(v_身份证号) = 18 Then
        -- 18 位身份证号前17 位全部为数字，最后1位可为数字或x
        v_Pattern := '^\d{17}[0-9Xx]$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(v_身份证号, v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中包含非法字符!';
          Raise Err_Item;
        End If;
        --获取性别
        If Mod(To_Number(Substr(v_身份证号, 17, 1)), 2) = 1 Then
          v_性别 := '男';
        Else
          v_性别 := '女';
        End If;
        --出生日期的合法性检查
        d_出生日期 := To_Date(Substr(v_身份证号, 7, 8), 'yyyy-mm-dd');
        v_Pattern  := '^(1[6-9]|[2-9][0-9])[0-9]{2}((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))$';
        Select Count(1) Into n_Count From Dual Where Regexp_Like(Substr(v_身份证号, 7, 8), v_Pattern);
        If n_Count = 0 Then
          v_Err_Msg := '身份证中的出生日期无效，请检查!';
          Raise Err_Item;
        Else
          If d_出生日期 > To_Date(To_Char(d_Curr_Time, 'YYYY-MM-DD'), 'YYYY-MM-dd') Then
            v_Err_Msg := '身份证中的出生日期无效，请检查!';
            Raise Err_Item;
          End If;
          --计算校验位
          n_Sum     := (To_Number(Substr(v_身份证号, 1, 1)) + To_Number(Substr(v_身份证号, 11, 1))) * 7 +
                       (To_Number(Substr(v_身份证号, 2, 1)) + To_Number(Substr(v_身份证号, 12, 1))) * 9 +
                       (To_Number(Substr(v_身份证号, 3, 1)) + To_Number(Substr(v_身份证号, 13, 1))) * 10 +
                       (To_Number(Substr(v_身份证号, 4, 1)) + To_Number(Substr(v_身份证号, 14, 1))) * 5 +
                       (To_Number(Substr(v_身份证号, 5, 1)) + To_Number(Substr(v_身份证号, 15, 1))) * 8 +
                       (To_Number(Substr(v_身份证号, 6, 1)) + To_Number(Substr(v_身份证号, 16, 1))) * 4 +
                       (To_Number(Substr(v_身份证号, 7, 1)) + To_Number(Substr(v_身份证号, 17, 1))) * 2 +
                       To_Number(Substr(v_身份证号, 8, 1)) * 1 + To_Number(Substr(v_身份证号, 9, 1)) * 6 +
                       To_Number(Substr(v_身份证号, 10, 1)) * 3;
          n_Count   := Mod(n_Sum, 11);
          v_Pattern := '10X98765432';
          v_校验位  := Substr(v_Pattern, n_Count + 1, 1);
          If v_校验位 <> Upper(Substr(v_身份证号, 18, 1)) Then
            v_Err_Msg := '身份证号码不正确，请检查。';
            Raise Err_Item;
          End If;
        End If;
      Else
        v_Err_Msg := '身份证长度不对,请检查。';
        Raise Err_Item;
      End If;
    
      If Nvl(v_年龄, '_') = '_' Then
        v_年龄 := Zl_Age_Calc(0, d_出生日期, d_Curr_Time);
      End If;
    End If;
  
    Select 名称 Into v_医疗付款方式 From 医疗付款方式 Where 缺省标志 = 1;
    n_Pati_Id := Nextno(1);
    n_门诊号  := Nextno(3);
    Insert Into 病人信息
      (病人id, 姓名, 身份证号, 家庭电话, 出生日期, 性别, 年龄, 登记时间, 门诊号, 医疗付款方式)
      Select n_Pati_Id, v_姓名, v_身份证号, v_手机号, d_出生日期, v_性别, v_年龄, d_Curr_Time, n_门诊号, v_医疗付款方式
      From Dual;
  
    --病人信息保存完后，完成医疗卡绑定（二代身份证卡类别的绑定）
    Begin
      If v_证件类型 Is Null Then
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 Like '%身份证%' And Rownum < 2;
      Else
        Select ID Into n_Card_Type_Id From 医疗卡类别 Where 名称 = v_证件类型 And Rownum < 2;
      End If;
    Exception
      When No_Data_Found Then
        v_Err_Msg := '身份证卡类别不存在！';
        Raise Err_Item;
    End;
    Select b.姓名 Into v_操作员 From 上机人员表 A, 人员表 B Where a.人员id = b.Id And a.用户名 = User;
  
    Zl_医疗卡变动_Insert(11, n_Pati_Id, n_Card_Type_Id, Null, v_身份证号, '创建虚拟卡', Null, v_操作员, d_Curr_Time);
  
    v_Temp := '<BRID>' || n_Pati_Id || '</BRID>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
    v_Temp := '<MZH>' || n_门诊号 || '</MZH>';
    Select Appendchildxml(Patiinfo_Out, '/OUTPUT', Xmltype(v_Temp)) Into Patiinfo_Out From Dual;
  End If;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Buildpatient;
/


--92798:余伟节,2016-08-11,路径医嘱审核
Create Or Replace Procedure Zl_路径医嘱变动_Insert
(
  项目ids_In    Varchar2, --项目Id 串 ID,ID,...
  操作时间_In   Date,
  操作员_In     人员表.姓名%Type,
  项目id_In     路径医嘱变动.项目id%Type := Null,
  医嘱内容id_In 路径医嘱变动.医嘱内容id%Type := Null,
  相关id_In     路径医嘱变动.相关id%Type := Null,
  序号_In       路径医嘱变动.序号%Type := Null,
  期效_In       路径医嘱变动.期效%Type := Null,
  诊疗项目id_In 路径医嘱变动.诊疗项目id%Type := Null,
  收费细目id_In 路径医嘱变动.收费细目id%Type := Null,
  医嘱内容_In   路径医嘱变动.医嘱内容%Type := Null,
  单次用量_In   路径医嘱变动.单次用量%Type := Null,
  总给予量_In   路径医嘱变动.总给予量%Type := Null,
  标本部位_In   路径医嘱变动.标本部位%Type := Null,
  检查方法_In   路径医嘱变动.检查方法%Type := Null,
  执行频次_In   路径医嘱变动.执行频次%Type := Null,
  频率次数_In   路径医嘱变动.频率次数%Type := Null,
  频率间隔_In   路径医嘱变动.频率间隔%Type := Null,
  间隔单位_In   路径医嘱变动.间隔单位%Type := Null,
  医生嘱托_In   路径医嘱变动.医生嘱托%Type := Null,
  执行性质_In   路径医嘱变动.执行性质%Type := Null,
  执行标记_In   路径医嘱变动.执行标记%Type := Null,
  执行科室id_In 路径医嘱变动.执行科室id%Type := Null,
  时间方案_In   路径医嘱变动.时间方案%Type := Null,
  是否缺省_In   路径医嘱变动.是否缺省%Type := Null,
  是否备选_In   路径医嘱变动.是否备选%Type := Null,
  配方id_In     路径医嘱变动.配方id%Type := Null,
  组合项目id_In 路径医嘱变动.组合项目id%Type := Null
) Is
  n_Count Number(5);
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Select /*+cardinality(D,10)*/
   Count(a.操作时间)
  Into n_Count
  From 路径医嘱变动 A, Table(f_Num2list(项目ids_In)) D
  Where a.项目id = d.Column_Value And a.操作时间 = 操作时间_In;
  If n_Count > 0 Then
    v_Error := '不允许同一个临床路径项目在同一时间被操作！';
    Raise Err_Custom;
  End If;
  If 项目ids_In Is Not Null Then
    Insert Into 路径医嘱变动
      (项目id, 操作时间, 操作员, 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位,
       医生嘱托, 执行性质, 执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id, 审核状态, 审核人, 审核时间)
      Select /*+cardinality(D,10)*/
       c.路径项目id, 操作时间_In, 操作员_In, b.Id, b.相关id, b.序号, b.期效, b.诊疗项目id, b.收费细目id, b.医嘱内容, b.单次用量, b.总给予量, b.标本部位, b.检查方法,
       b.执行频次, b.频率次数, b.频率间隔, b.间隔单位, b.医生嘱托, b.执行性质, b.执行标记, b.执行科室id, b.时间方案, b.是否缺省, b.是否备选, b.配方id, b.组合项目id, 1,
       操作员_In, 操作时间_In
      From 路径医嘱内容 B, 临床路径医嘱 C, Table(f_Num2list(项目ids_In)) D
      Where c.医嘱内容id = b.Id And c.路径项目id = d.Column_Value;
  Else
    Insert Into 路径医嘱变动
      (项目id, 操作时间, 操作员, 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位,
       医生嘱托, 执行性质, 执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id)
    Values
      (项目id_In, 操作时间_In, 操作员_In, 医嘱内容id_In, 相关id_In, 序号_In, 期效_In, 诊疗项目id_In, 收费细目id_In, 医嘱内容_In, 单次用量_In, 总给予量_In,
       标本部位_In, 检查方法_In, 执行频次_In, 频率次数_In, 频率间隔_In, 间隔单位_In, 医生嘱托_In, 执行性质_In, 执行标记_In, 执行科室id_In, 时间方案_In, 是否缺省_In,
       是否备选_In, 配方id_In, 组合项目id_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
  
End Zl_路径医嘱变动_Insert;
/

--92798:余伟节,2016-08-11,路径医嘱审核
Create Or Replace Procedure Zl_路径医嘱变动_Audit
(
  项目id_In   路径医嘱变动.项目id%Type,
  操作时间_In Date,
  功能_In     Number := 0
) Is
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 功能_In = 0 Then
    --将原来的医嘱导入路径医嘱变动记录
    Zl_路径医嘱变动_Insert(项目id_In, Sysdate, Zl_Username);
  
    --删除原来的【路径医嘱内容】的数据;同时级联删除【临床路径医嘱】的数据
    Delete From 路径医嘱内容 Where ID In (Select 医嘱内容id From 临床路径医嘱 Where 路径项目id = 项目id_In);
  
    --将【路径医嘱变动】未审核的医嘱复制到【路径医嘱内容】,并将路径项目ID和医嘱ID关联
    Insert Into 路径医嘱内容
      (ID, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质, 执行标记, 执行科室id,
       时间方案, 是否缺省, 是否备选, 配方id, 组合项目id)
      Select 医嘱内容id, 相关id, 序号, 期效, 诊疗项目id, 收费细目id, 医嘱内容, 单次用量, 总给予量, 标本部位, 检查方法, 执行频次, 频率次数, 频率间隔, 间隔单位, 医生嘱托, 执行性质,
             执行标记, 执行科室id, 时间方案, 是否缺省, 是否备选, 配方id, 组合项目id
      From 路径医嘱变动
      Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
  
    Insert Into 临床路径医嘱
      (路径项目id, 医嘱内容id)
      Select 项目id, 医嘱内容id From 路径医嘱变动 Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
    --删除【路径医嘱变动】中已经复制到【路径医嘱内容】的数据
    Delete From 路径医嘱变动 Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
  Else
    --审核不通过
    Update 路径医嘱变动
    Set 审核人 = Zl_Username, 审核时间 = Sysdate, 审核状态 = 0
    Where 项目id = 项目id_In And 操作时间 = 操作时间_In;
  End If;
Exception

  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_路径医嘱变动_Audit;
/

--99389:刘尔旋,2016-08-10,部分审核记账单医嘱发送计费状态问题
Create Or Replace Procedure Zl_住院记帐记录_Verify
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  病人id_In     住院费用记录.病人id%Type := Null,
  审核时间_In   住院费用记录.登记时间%Type := Null
) As
  --功能：审核一张住院记帐划价单
  --参数：
  --    序号_IN：格式如"1,3,5,7,8",为空表示审核所有未审核的行
  --    病人ID_IN：只审核指定病人,用于按病人审核记帐表。
  --    审核时间_IN：用于部份需要统一控制或返回时间的地方
  --只读取指定序号的,未审核的部份进行处理
  Cursor c_Bill Is
    Select ID, 病人id, 主页id, 收费细目id, 实收金额, 门诊标志, 收入项目id, 执行部门id, 开单部门id, 病人病区id, 病人科室id, 医嘱序号



    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 0 And NO = No_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null) And
          (病人id + 0 = 病人id_In Or 病人id_In Is Null)
    Order By 序号;

  --审核中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  Cursor c_Stuff Is
    Select ID, 库房id
    From 药品收发记录 M
    Where NO = No_In And 单据 In (25, 26) And 库房id Is Not Null And 记录状态 = 1 And 审核人 Is Null And Exists
     (Select 1
           From 住院费用记录 A, 材料特性 B
           Where a.Id = m.费用id + 0 And a.记录性质 = 2 And a.记录状态 = 1 And a.No = No_In And
                 (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And
                 (a.病人id + 0 = 病人id_In Or 病人id_In Is Null) And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id, 药品id;
  --
  v_发料号         药品收发记录.汇总发药号%Type;
  v_库房id         药品收发记录.库房id%Type;
  v_收发ids        Varchar2(4000);
  v_医嘱ids        Varchar2(4000);
  v_Date           Date;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);

  n_病人id  病案主页.病人id%Type;
  n_主页id  病案主页.主页id%Type;
  v_Err_Msg Varchar2(500);
  Err_Item Exception;

Begin
  If 审核时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 审核时间_In;
  End If;

  For r_Bill In c_Bill Loop
    Update 住院费用记录
    Set 记录状态 = 1, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 登记时间 = v_Date --已产生的药品记录的时间不变
    Where ID = r_Bill.Id;
    If Nvl(n_病人id, 0) <> Nvl(r_Bill.病人id, 0) Then
      If Nvl(zl_GetSysParameter(185), 0) = 1 Then
        n_病人id := Nvl(r_Bill.病人id, 0);
        n_主页id := Nvl(r_Bill.主页id, 0);
      
        n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
        n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
        If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
          Begin
            Select 审核标志, 状态
            Into n_审核标志, n_住院状态
            From 病案主页
            Where 病人id = n_病人id And 主页id = n_主页id;
          Exception
            When Others Then
              n_审核标志 := 0;
              n_住院状态 := 0;
          End;
          If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
            v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
            Raise Err_Item;
          End If;
        
          If n_病人审核方式 = 1 Then
            If Nvl(n_审核标志, 0) = 1 Then
              v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
              Raise Err_Item;
            End If;
            If Nvl(n_审核标志, 0) = 2 Then
              v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
              Raise Err_Item;
            End If;
          End If;
        End If;
      End If;
    
    End If;
  
    --药品收发记录.填制日期
    Update 药品收发记录
    Set 填制日期 = Decode(Sign(Nvl(审核日期, v_Date) - v_Date), -1, 填制日期, v_Date)
    Where NO = No_In And 单据 In (9, 10, 25, 26) And 费用id = r_Bill.Id;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(r_Bill.实收金额, 0)
    Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 2;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (r_Bill.病人id, 1, 2, r_Bill.实收金额, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Bill.实收金额, 0)
    Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = Nvl(r_Bill.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Bill.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = r_Bill.门诊标志;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (r_Bill.病人id, r_Bill.主页id, r_Bill.病人病区id, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id,
         r_Bill.门诊标志, Nvl(r_Bill.实收金额, 0));
    End If;
  
    If r_Bill.医嘱序号 Is Not Null Then
      v_医嘱ids := v_医嘱ids || ',' || r_Bill.医嘱序号;
    End If;
  End Loop;

  --处理医嘱发送计费状态
  If v_医嘱ids Is Not Null Then
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(1, 2, 1, No_In, v_医嘱ids);
  End If;

  --库房中的药品已全部审核则标为已收费
  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = v_Date
  Where NO = No_In And 单据 In (9, 10) And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In
        (Select Distinct Nvl(执行部门id, 0)
         From 住院费用记录
         Where 记录性质 = 2 And NO = No_In And 收费类别 In ('5', '6', '7') And 记录状态 = 0);

  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = v_Date
  Where NO = No_In And 单据 In (25, 26) And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In (Select Distinct Nvl(执行部门id, 0)
                             From 住院费用记录
                             Where 记录性质 = 2 And NO = No_In And 收费类别 = '4' And 记录状态 = 0);
  If zl_GetSysParameter(63) = '1' Then
  
    --处理跟踪在用卫料自动发料
    For r_Stuff In c_Stuff Loop
      If v_发料号 Is Null Then
        v_发料号 := Nextno(20);
      End If;
    
      If r_Stuff.库房id <> Nvl(v_库房id, 0) Then
        If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
        End If;
      
        v_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(v_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, v_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, v_发料号, 操作员姓名_In);
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Verify;
/

--99389:刘尔旋,2016-08-10,部分审核记账单医嘱发送计费状态问题
Create Or Replace Procedure Zl_门诊记帐记录_Verify
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  审核时间_In   门诊费用记录.登记时间%Type := Null
) As
  --功能：审核一张门诊记帐划价单
  --参数：
  --    序号_IN：格式如"1,3,5,7,8",为空表示审核所有未审核的行
  --    审核时间_IN：用于部份需要统一控制或返回时间的地方
  --只读取指定序号的,未审核的部份进行处理
  Cursor c_Bill Is
    Select a.Id, a.病人id, a.实收金额, a.门诊标志, a.收入项目id, a.执行部门id, a.开单部门id, a.病人科室id, a.发药窗口, a.收费类别, Nvl(b.跟踪在用, 0) As 跟踪在用,
           a.医嘱序号
    From 门诊费用记录 A, 材料特性 B
    Where a.收费细目id = b.材料id(+) And a.记录性质 = 2 And a.记录状态 = 0 And a.No = No_In And
          (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null)
    Order By a.序号;

  --审核中包含跟踪在用的未发卫料时，根据参数设置是否自动发料
  Cursor c_Stuff Is
    Select ID, 库房id
    From 药品收发记录 M
    Where NO = No_In And 单据 = 25 And 库房id Is Not Null And 记录状态 = 1 And 审核人 Is Null And Exists
     (Select 1
           From 门诊费用记录 A, 材料特性 B
           Where a.Id = m.费用id + 0 And a.记录性质 = 2 And a.记录状态 = 1 And a.No = No_In And
                 (Instr(',' || 序号_In || ',', ',' || Nvl(a.价格父号, a.序号) || ',') > 0 Or 序号_In Is Null) And
                 a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id, 药品id;

  --
  n_发料号   药品收发记录.汇总发药号%Type;
  n_库房id   药品收发记录.库房id%Type;
  v_收发ids  Varchar2(4000);
  d_Date     Date;
  v_医嘱ids  Varchar2(4000);
  v_发药窗口 药品收发记录.发药窗口%Type;

  Type t_Record Is Record(
    药房id   Number(18),
    发药窗口 Varchar2(10));

  Type t_发药窗口 Is Table Of t_Record;
  c_发药窗口 t_发药窗口 := t_发药窗口();
  n_Step     Number(18);
  n_Havedata Number(2);
  n_Count    Number(18);

Begin
  If 审核时间_In Is Null Then
    Select Sysdate Into d_Date From Dual;
  Else
    d_Date := 审核时间_In;
  End If;

  For r_Bill In c_Bill Loop
  
    --处理发药窗口
    If (r_Bill.收费类别 In ('5', '6', '7') Or r_Bill.收费类别 = '4' And r_Bill.跟踪在用 = 1) Then
      --同一张单据,满足同一药房同一窗口
      v_发药窗口 := Null;
      n_Havedata := 0;
      For n_Step In 1 .. c_发药窗口.Count Loop
        If c_发药窗口(n_Step).药房id = Nvl(r_Bill.执行部门id, 0) Then
          v_发药窗口 := c_发药窗口(n_Step).发药窗口;
          n_Havedata := 1;
          Exit;
        End If;
      End Loop;
    
      If v_发药窗口 Is Null Then
        --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
        n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
        If n_Count = 0 Then
          n_Count := 1;
        End If;
      
        Begin
          Select 发药窗口
          Into v_发药窗口
          From (Select 登记时间, 发药窗口
                 From 门诊费用记录 A
                 Where 收费类别 In ('5', '6', '7', '4') And 病人id = r_Bill.病人id And 登记时间 Between Sysdate - n_Count And Sysdate And
                       记录性质 = 2 And 执行部门id = r_Bill.执行部门id And 发药窗口 Is Not Null And Exists
                  (Select 1
                        From 未发药品记录
                        Where a.No = NO And 单据 In (9, 26) And 库房id + 0 = r_Bill.执行部门id And 病人id + 0 = r_Bill.病人id) And
                       Exists
                  (Select 1
                        From 发药窗口
                        Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = r_Bill.执行部门id)
                 Order By 登记时间 Desc)
          Where Rownum <= 1;
        Exception
          When Others Then
            v_发药窗口 := Null;
        End;
        If v_发药窗口 Is Null Then
          v_发药窗口 := Zl_Get发药窗口(r_Bill.执行部门id);
        End If;
      
      End If;
      If n_Havedata = 0 Then
        c_发药窗口.Extend;
        c_发药窗口(c_发药窗口.Count).药房id := r_Bill.执行部门id;
        c_发药窗口(c_发药窗口.Count).发药窗口 := v_发药窗口;
      End If;
    End If;
  
    Update 门诊费用记录
    Set 记录状态 = 1, 发药窗口 = v_发药窗口, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 登记时间 = d_Date --已产生的药品记录的时间不变 
    Where ID = r_Bill.Id;
  
    --药品收发记录.填制日期
    Update 药品收发记录
    Set 填制日期 = Decode(Sign(Nvl(审核日期, d_Date) - d_Date), -1, 填制日期, d_Date)
    Where NO = No_In And 单据 In (9, 25) And 费用id = r_Bill.Id;
  
    --病人余额
  
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(r_Bill.实收金额, 0)
    Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (r_Bill.病人id, 1, 1, r_Bill.实收金额, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(r_Bill.实收金额, 0)
    Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And
          Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And
          收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = r_Bill.门诊标志;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (r_Bill.病人id, Null, Null, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, r_Bill.门诊标志,
         Nvl(r_Bill.实收金额, 0));
    End If;
  
    If r_Bill.医嘱序号 Is Not Null Then
      v_医嘱ids := v_医嘱ids || ',' || r_Bill.医嘱序号;
    End If;
  
  End Loop;

  --处理医嘱发送计费状态
  If v_医嘱ids Is Not Null Then
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(0, 2, 1, No_In, v_医嘱ids);
  End If;
  --更新发药窗口
  For n_Step In 1 .. c_发药窗口.Count Loop
    Update 未发药品记录
    Set 发药窗口 = c_发药窗口(n_Step).发药窗口
    Where 库房id = c_发药窗口(n_Step).药房id And 单据 In (9, 25) And NO = No_In;
  End Loop;

  --库房中的药品已全部审核则标为已收费
  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = d_Date
  Where NO = No_In And 单据 = 9 And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In
        (Select Distinct Nvl(执行部门id, 0)
         From 门诊费用记录
         Where 记录性质 = 2 And NO = No_In And 收费类别 In ('5', '6', '7') And 记录状态 = 0);

  Update 未发药品记录
  Set 已收费 = 1, 填制日期 = d_Date
  Where NO = No_In And 单据 = 25 And Nvl(已收费, 0) = 0 And
        Nvl(库房id, 0) Not In (Select Distinct Nvl(执行部门id, 0)
                             From 门诊费用记录
                             Where 记录性质 = 2 And NO = No_In And 收费类别 = '4' And 记录状态 = 0);

  --处理跟踪在用卫料自动发料
  If zl_GetSysParameter(92) = '1' Then
    For r_Stuff In c_Stuff Loop
      If n_发料号 Is Null Then
        n_发料号 := Nextno(20);
      End If;
    
      If r_Stuff.库房id <> Nvl(n_库房id, 0) Then
        If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
          v_收发ids := Substr(v_收发ids, 2);
          Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, n_发料号, 操作员姓名_In);
        End If;
      
        n_库房id  := r_Stuff.库房id;
        v_收发ids := Null;
      End If;
    
      v_收发ids := v_收发ids || '|' || r_Stuff.Id || ',0';
    End Loop;
    If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
      v_收发ids := Substr(v_收发ids, 2);
      Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 操作员姓名_In, Sysdate, 1, 操作员姓名_In, n_发料号, 操作员姓名_In);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Verify;
/

--103632:冉俊明,2016-12-15,门诊医保多单据一次结算部分退费时医嘱发送的计费状态不正确。
--99389:刘尔旋,2016-08-10,部分审核记账单医嘱发送计费状态问题
Create Or Replace Procedure Zl_医嘱发送_计费状态_Update
(
  场合_In    Integer := 0, --0:门诊;1-住院
  性质_In    Integer := 1, --1-收费单;2-记帐单
  操作_In    Integer := 0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  No_In      门诊费用记录.No%Type,
  医嘱ids_In Varchar2 := Null
) As
  Err_Item Exception;
  v_Err_Msg Varchar2(255);

  l_医嘱id   t_Numlist := t_Numlist();
  l_计费状态 t_Numlist := t_Numlist();
  l_医嘱id1  t_Numlist := t_Numlist();

  n_Count Number(18);

  n_组状态 Number(18);
  n_状态   Number(18);

  Type Ty_Rec_医嘱 Is Record(
    医嘱id   病人医嘱记录.Id%Type,
    计费状态 病人医嘱发送.计费状态%Type,
    附加信息 Varchar2(100));
  Type Ty_Tb_医嘱 Is Table Of Ty_Rec_医嘱;
  c_主医嘱信息 Ty_Tb_医嘱 := Ty_Tb_医嘱();
  c_医嘱信息   Ty_Tb_医嘱 := Ty_Tb_医嘱();

  v_Temp Varchar2(4000);

  Function Get_Status(主医嘱id_In 病人医嘱记录.Id%Type) Return Number Is
    n_Temp Number(2);
  Begin
  
    If 场合_In = 0 Then
      For c_主医嘱 In (Select Max(Case
                                  When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                   0
                                  When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                   2
                                  Else
                                   3 --3--表示部分退
                                End) As 状态,
                           Min(Case
                                  When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                   0
                                  When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                   2
                                  Else
                                   3 --3--表示部分退
                                End) As 状态1, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                    From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量,
                                  Min(Nvl(a.记录状态, 0)) As 记录状态,
                                  Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                           Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量
                           From 门诊费用记录 A
                           Where a.医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = 主医嘱id_In Or 相关id = 主医嘱id_In) And
                                 Decode(性质_In, 2, a.记录性质, Mod(a.记录性质, 10)) = 性质_In And a.No = No_In And a.价格父号 Is Null And
                                 Nvl(a.附加标志, 0) <> 9
                           Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No) A) Loop
        n_Temp := Case
                    When c_主医嘱.状态 Is Null Then
                     0
                    When Nvl(c_主医嘱.状态, -1) <> Nvl(c_主医嘱.状态1, -1) Or c_主医嘱.状态 = 3 Then
                     2
                    When Nvl(c_主医嘱.Min_记录状态, -1) = 0 And Instr(',0,-1,', ',' || Nvl(c_主医嘱.Max_记录状态, -1) || ',') = 0 Then
                     2
                    When c_主医嘱.状态 = 2 Then
                     4
                    When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                     1
                    When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(c_主医嘱.Min_记录状态, -1) <> 0 And Nvl(性质_In, 0) = 1 Then
                    --收费时，表示全部收费，同一单据不存在部分收费
                     3
                    Else
                     0
                  End;
        Return n_Temp;
        Exit;
      End Loop;
    End If;
  
    For c_主医嘱 In (Select Max(Case
                               When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                0
                               When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                2
                               Else
                                3 --3--表示部分退
                             End) As 状态,
                         Min(Case
                               When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                0
                               When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                2
                               Else
                                3 --3--表示部分退
                             End) As 状态1, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                  From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量,
                                Min(Nvl(a.记录状态, 0)) As 记录状态,
                                Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                         Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量
                         From 住院费用记录 A
                         Where a.医嘱序号 + 0 In (Select ID From 病人医嘱记录 Where ID = 主医嘱id_In Or 相关id = 主医嘱id_In) And
                               a.记录性质 = 性质_In And a.No = No_In And a.价格父号 Is Null And Nvl(a.附加标志, 0) <> 9
                         Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No) A) Loop
      n_Temp := Case
                  When c_主医嘱.状态 Is Null Then
                   0
                  When Nvl(c_主医嘱.状态, -1) <> Nvl(c_主医嘱.状态1, -1) Or c_主医嘱.状态 = 3 Then
                   2
                  When Nvl(c_主医嘱.Min_记录状态, -1) = 0 And Instr(',0,-1,', ',' || Nvl(c_主医嘱.Max_记录状态, -1) || ',') = 0 Then
                   2
                  When c_主医嘱.状态 = 2 Then
                   4
                  When c_主医嘱.状态 = 0 And c_主医嘱.状态1 = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   0
                End;
      Return n_Temp;
      Exit;
    End Loop;
  
  End Get_Status;
Begin

  If 医嘱ids_In Is Null Then
    If 场合_In = 0 Then
      Select ID Bulk Collect
      Into l_医嘱id
      From (Select Distinct 医嘱序号 As ID
             From 门诊费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    Else
      Select ID Bulk Collect
      Into l_医嘱id
      From (Select Distinct 医嘱序号 As ID
             From 住院费用记录
             Where NO = No_In And 记录性质 = 性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null);
    End If;
  Else
    Select ID Bulk Collect
    Into l_医嘱id
    From (Select Distinct Column_Value As ID From Table(f_Str2list(医嘱ids_In)) B);
  End If;

  If l_医嘱id.Count = 0 Then
    Return;
  End If;

  If 操作_In = 0 Or 操作_In = 1 Then
    v_Temp := '';
    For c_医嘱 In (
                 --1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
                 Select a.医嘱id, Max(Nvl(b.相关id, b.Id)) As 主医嘱id,
                         Max(Decode(Nvl(c.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱
                 From 病人医嘱发送 A, 病人医嘱记录 B, 病人医嘱记录 C
                 Where NO = No_In And a.记录性质 = 性质_In And a.医嘱id = b.Id And
                       a.医嘱id + 0 In (Select Column_Value From Table(l_医嘱id)) And Nvl(b.相关id, b.Id) + 0 = c.Id
                 Group By a.医嘱id) Loop
    
      If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null And
         Instr(Nvl(v_Temp, '') || ',', ',' || c_医嘱.主医嘱id || ',') = 0 Then
        --查找是否存在划价单的情况或者被删除或者存在审核
        If Nvl(操作_In, 0) = 0 Then
          --删除划价单,分两种情况:
          --1.整张单据删除,这个时候填为0
          --2.部分删除（如：记帐单
          If 性质_In = 1 Then
            n_组状态 := 0;
          Else
            n_组状态 := Get_Status(c_医嘱.主医嘱id);
          End If;
        End If;
        If 操作_In = 1 Then
          --收费记帐
          If 性质_In = 1 Then
            n_组状态 := 3;
          Else
            n_组状态 := Get_Status(c_医嘱.主医嘱id);
          End If;
        End If;
        c_主医嘱信息.Extend;
        c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
        c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
        v_Temp := Nvl(v_Temp, '') || ',' || c_医嘱.主医嘱id;
      End If;
      c_医嘱信息.Extend;
      c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
      c_医嘱信息(c_医嘱信息.Count).计费状态 := Case
                                     When 操作_In = 1 And 性质_In = 1 Then
                                      3
                                     When 操作_In = 1 And 性质_In = 2 Then
                                      1
                                     Else
                                      0
                                   End;
    End Loop;
  End If;
  --退费或销帐
  If 操作_In = 2 Then
    If 场合_In = 0 Then
    
      For c_医嘱 In (Select a.医嘱id, Max(Decode(Nvl(b.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱, Max(a.主医嘱id) As 主医嘱id,
                          Max(Case
                                 When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                  0
                                 When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                  2
                                 Else
                                  3 --3--表示部分退
                               End) As 状态, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                   From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, a.No,
                                 Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量, Min(Nvl(a.记录状态, 0)) As 记录状态,
                                 Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                          Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量, c.相关id As 主医嘱id
                          From 门诊费用记录 A, 病人医嘱记录 C
                          Where a.医嘱序号 = c.Id And Decode(性质_In, 2, a.记录性质, Mod(a.记录性质, 10)) = 性质_In And a.No = No_In And
                                a.价格父号 Is Null And Nvl(a.附加标志, 0) <> 9 And
                                a.医嘱序号 + 0 In (Select Column_Value From Table(l_医嘱id))
                          Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No, c.相关id) A, 病人医嘱记录 B
                   Where a.主医嘱id = b.Id(+)
                   Group By a.医嘱id
                   
                   ) Loop
      
        ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        n_状态 := Case
                  When Nvl(c_医嘱.状态, 0) = 3 Then --表示部分退
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) = 1 Then --收费时，表示全收
                   3
                  When Nvl(c_医嘱.Min_记录状态, 0) = 0 And Nvl(c_医嘱.Max_记录状态, 0) <> 0 Then
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   4
                End;
      
        c_医嘱信息.Extend;
        c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
        c_医嘱信息(c_医嘱信息.Count).计费状态 := n_状态;
      
        If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null Then
          --手术或检查医嘱，需要处理主医嘱
          n_组状态 := -9;
          n_Count  := 0;
          For J In 1 .. c_主医嘱信息.Count Loop
            If c_主医嘱信息(J).医嘱id = c_医嘱.主医嘱id Then
              --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
              If c_主医嘱信息(J).计费状态 <> 2 And n_状态 = 2 Then
                --部分退
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
            
              If Instr(Nvl(c_主医嘱信息(J).附加信息, '') || ',', ',' || n_状态 || ',') = 0 And Nvl(c_主医嘱信息(J).计费状态, 0) <> 2 Then
                c_主医嘱信息(J).附加信息 := Nvl(c_主医嘱信息(J).附加信息, '') || ',' || n_状态;
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
              n_Count := 1;
              Exit;
            End If;
          End Loop;
          If n_Count = 0 Then
            If n_状态 = 2 Then
              n_组状态 := 2;
            End If;
            --未找到时,需要重新加入
            c_主医嘱信息.Extend;
            c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
            c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
            c_主医嘱信息(c_主医嘱信息.Count).附加信息 := ',' || n_状态;
          End If;
        End If;
      End Loop;
    Else
    
      For c_医嘱 In (Select a.医嘱id, Max(Decode(Nvl(b.诊疗类别, '-'), 'D', 1, 'F', 1, 0)) As 检查手术医嘱, Max(a.主医嘱id) As 主医嘱id,
                          Max(Case
                                When Nvl(a.剩余数量, 0) = Nvl(a.原始数量, 0) And Nvl(a.原始数量, 0) <> 0 Then --0：表示未退
                                 0
                                When Nvl(a.剩余数量, 0) = 0 Then --2-表示全退
                                 2
                                Else
                                 3 --3--表示部分退
                              End) As 状态, Min(a.记录状态) As Min_记录状态, Max(a.记录状态) As Max_记录状态
                   From (Select a.序号, a.医嘱序号 As 医嘱id, Mod(a.记录性质, 10) As 记录性质, a.No,
                                 Sum(Nvl(Nvl(a.付数, 1) * a.数次, 0)) As 剩余数量, Min(Nvl(a.记录状态, 0)) As 记录状态,
                                 Nvl(Sum(Decode(a.记录状态, 1, 1, 3, 1, 0) * Decode(a.记录性质, 11, 0, 1) *
                                          Nvl(Nvl(a.付数, 1) * a.数次, 0)), 0) As 原始数量, c.相关id As 主医嘱id
                          From 住院费用记录 A, 病人医嘱记录 C
                          Where a.医嘱序号 = c.Id And a.记录性质 = 性质_In And a.No = No_In And a.价格父号 Is Null And
                                Nvl(a.附加标志, 0) <> 9 And a.医嘱序号 + 0 In (Select Column_Value From Table(l_医嘱id))
                          Group By a.序号, a.医嘱序号, Mod(a.记录性质, 10), a.No, c.相关id) A, 病人医嘱记录 B
                   Where a.主医嘱id = b.Id(+)
                   Group By a.医嘱id
                   
                   ) Loop
      
        ---1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        n_状态 := Case
                  When Nvl(c_医嘱.状态, 0) = 3 Then --表示部分退
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) = 1 Then --收费时，表示全收
                   3
                  When Nvl(c_医嘱.Min_记录状态, 0) = 0 And Nvl(c_医嘱.Max_记录状态, 0) <> 0 Then
                   2
                  When Nvl(c_医嘱.状态, 0) = 0 And Nvl(性质_In, 0) <> 1 Then --记帐时，表示已记帐
                   1
                  Else
                   4
                End;
      
        c_医嘱信息.Extend;
        c_医嘱信息(c_医嘱信息.Count).医嘱id := c_医嘱.医嘱id;
        c_医嘱信息(c_医嘱信息.Count).计费状态 := n_状态;
      
        If Nvl(c_医嘱.检查手术医嘱, 0) = 1 And c_医嘱.主医嘱id Is Not Null Then
          --手术或检查医嘱，需要处理主医嘱
          n_组状态 := -9;
          n_Count  := 0;
          For J In 1 .. c_主医嘱信息.Count Loop
            If c_主医嘱信息(J).医嘱id = c_医嘱.主医嘱id Then
              --:-1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
              If c_主医嘱信息(J).计费状态 <> 2 And n_状态 = 2 Then
                --部分退
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
            
              If Instr(Nvl(c_主医嘱信息(J).附加信息, '') || ',', ',' || n_状态 || ',') = 0 And Nvl(c_主医嘱信息(J).计费状态, 0) <> 2 Then
                c_主医嘱信息(J).附加信息 := Nvl(c_主医嘱信息(J).附加信息, '') || ',' || n_状态;
                c_主医嘱信息(J).计费状态 := 2;
                n_组状态 := 2;
              End If;
              n_Count := 1;
              Exit;
            End If;
          End Loop;
          If n_Count = 0 Then
            If n_状态 = 2 Then
              n_组状态 := 2;
            End If;
            --未找到时,需要重新加入
            c_主医嘱信息.Extend;
            c_主医嘱信息(c_主医嘱信息.Count).医嘱id := c_医嘱.主医嘱id;
            c_主医嘱信息(c_主医嘱信息.Count).计费状态 := n_组状态;
            c_主医嘱信息(c_主医嘱信息.Count).附加信息 := ',' || n_状态;
          End If;
        End If;
      End Loop;
    
    End If;
    --处理主医嘱
    If c_主医嘱信息.Count <> 0 Then
      For J In 1 .. c_主医嘱信息.Count Loop
        --需要处理划价信息部分
        --收费时: -1-无须计费(通常无执行和院外执行的都无须计费);0-未计费;1-已计费，2-部分退费(销帐)，3-全部收费(仅门诊收费有)，4-全部退费(销帐)
        If c_主医嘱信息(J).计费状态 = -9 Then
          n_组状态 := Get_Status(c_主医嘱信息(J).医嘱id);
          c_主医嘱信息(J).计费状态 := n_组状态;
        End If;
      End Loop;
    End If;
  End If;

  If c_主医嘱信息.Count = 0 And c_医嘱信息.Count = 0 Then
    Return;
  End If;
  For J In 1 .. c_医嘱信息.Count Loop
    l_医嘱id1.Extend;
    l_计费状态.Extend;
    l_医嘱id1(l_医嘱id1.Count) := c_医嘱信息(J).医嘱id;
    l_计费状态(l_计费状态.Count) := c_医嘱信息(J).计费状态;
  End Loop;

  For J In 1 .. c_主医嘱信息.Count Loop
    l_医嘱id1.Extend;
    l_计费状态.Extend;
    l_医嘱id1(l_医嘱id1.Count) := c_主医嘱信息(J).医嘱id;
    l_计费状态(l_计费状态.Count) := c_主医嘱信息(J).计费状态;
  End Loop;

  Forall I In 1 .. l_医嘱id1.Count
    Update 病人医嘱发送 A
    Set a.计费状态 = l_计费状态(I)
    Where 医嘱id = l_医嘱id1(I) And 记录性质 = 性质_In And NO = No_In;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_医嘱发送_计费状态_Update;
/

--97495:张险华,2016-08-09,出院提交状态错误变更
Create Or Replace Procedure Zl_病案反馈记录_Finish
(
  Id_In     In 病案反馈记录.Id%Type,
  归档人_In 病案提交记录.归档人%Type := Null
) Is
  n_病人id 病案反馈记录.病人id%Type;
  n_主页id 病案反馈记录.病人id%Type;
  n_Have   Number(1) := 0;
  n_Type   Number(1) := 0;
Begin
  n_病人id := 0;
  n_主页id := 0;
  Begin
    Select 病人id, 主页id Into n_病人id, n_主页id From 病案反馈记录 Where ID = Id_In;
  Exception
    When Others Then
      n_病人id := 0;
  End;

  Update 病案反馈记录 Set 记录状态 = 3 Where ID = Id_In And 记录状态 <> 3 Returning 记录性质 Into n_Type;

  If Sql%RowCount > 0 Then
    --电子病案审查结束后自动归档
    n_Have := 0;
    Begin
      Select 1 Into n_Have From 病案提交记录 A Where a.病人id = n_病人id And a.主页id = n_主页id And Rownum = 1;
    Exception
      When Others Then
        n_Have := 0;
    End;
  
    If n_Have = 1 And n_Type = 2 Then
      Update 病案提交记录 A
      Set 记录状态 = 5, 归档人 = 归档人_In, 归档时间 = Sysdate
      Where a.病人id = n_病人id And a.主页id = n_主页id And a.记录状态 <> 2 And Not Exists
       (Select 1 From 病案反馈记录 B Where b.病人id = n_病人id And b.主页id = n_主页id And b.记录状态 = 1);
    End If;
  
    Zl_病案反馈记录_Updatesatue(n_病人id, n_主页id);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病案反馈记录_Finish;
/

--89363:余伟节,2016-08-03,允许生成多个婴儿医嘱
Create Or Replace Procedure Zl_病人路径生成_Insert
(
  序号_In           Number, --医嘱界面产生路径项目时，序号为0
  病人id_In         病人临床路径.病人id%Type,
  主页id_In         病人临床路径.主页id%Type,
  婴儿_In           Varchar2,
  科室id_In         病人临床路径.科室id%Type,
  路径记录id_In     病人路径执行.路径记录id%Type,
  阶段id_In         病人路径执行.阶段id%Type,
  日期_In           病人路径执行.日期%Type,
  天数_In           病人路径执行.天数%Type,
  分类_In           病人路径执行.分类%Type,
  项目id_In         病人路径执行.项目id%Type,
  医嘱ids_In        Varchar2,
  病历文件ids_In    Varchar2,
  病人病历ids_In    Varchar2,
  登记人_In         病人路径执行.登记人%Type,
  登记时间_In       病人路径执行.登记时间%Type,
  项目内容_In       病人路径执行.项目内容%Type := Null,
  执行者_In         病人路径执行.执行者%Type := Null,
  项目结果_In       病人路径执行.项目结果%Type := Null,
  图标id_In         病人路径执行.图标id%Type := Null,
  添加原因_In       病人路径执行.添加原因%Type := Null,
  变异原因_In       病人路径执行.变异原因%Type := Null,
  自动执行_In       Number := 0,
  电子病历id_In     电子病历记录.Id%Type := Null,
  合并路径阶段s_In  Varchar2 := Null, --用于修改合并路径的当前阶段ID，格式：合并路径记录ID:阶段ID,合并路径记录ID:阶段ID。。。。
  合并路径记录id_In 病人路径执行.合并路径记录id%Type := Null,
  合并路径阶段id_In 病人路径执行.合并路径阶段id%Type := Null,
  插入位置id_In     病人路径执行.Id%Type := 0,
  生成者_In         病人路径执行.生成者 %Type := 1,
  任务ids_In        Varchar2 := Null,
  生成时间性质_In   病人路径执行.生成时间性质%Type := Null --1-补录,2-暂存,Null-正常情况
) Is
  v_当前阶段id 病人临床路径.当前阶段id%Type;
  v_路径执行id 病人路径执行.Id%Type;
  v_病历id     电子病历记录.Id%Type;
  t_Advice     t_Numlist;
  t_File       t_Numlist;
  t_Doc        t_Numlist;
  t_Baby       t_Numlist;
  t_Strfile    t_Strlist;
  t_Strdoc     t_Strlist;

  v_Id             电子病历内容.Id%Type;
  v_父id           电子病历内容.父id%Type;
  v_当前父id       电子病历内容.父id%Type;
  v_原对象序号     电子病历内容.父id%Type;
  v_内容文本       电子病历内容.内容文本%Type;
  v_执行环节       Varchar2(20);
  n_当前天数       病人临床路径.当前天数%Type;
  n_合并路径记录id 病人路径执行.合并路径记录id%Type;
  n_合并路径阶段id 病人路径执行.合并路径阶段id%Type;
  n_天数           病人临床路径.当前天数%Type;
  n_婴儿           电子病历记录.婴儿%Type;
  v_合并路径阶段s  Varchar2(255);

  v_项目序号 病人路径执行.项目序号%Type;
  n_Count    Number;
  n_Minnum   Number;
  v_Error    Varchar2(255);
  Err_Custom Exception;

  --项目序号处理
  Procedure p_Sort_项目序号
  (
    项目序号_In In 病人路径执行.项目序号%Type,
    执行id_In   In 病人路径执行.Id%Type
  ) Is
    n_Num Number;
  Begin
    n_Num := 项目序号_In;
    For r_Outpathitem In (Select a.Id, Nvl(a.项目序号, b.项目序号) As 项目序号
                          From 病人路径执行 A, 临床路径项目 B
                          Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And
                                a.项目id = b.Id(+) And Nvl(a.项目序号, b.项目序号) >= 项目序号_In
                          Order By Nvl(a.项目序号, b.项目序号)) Loop
      n_Num := n_Num + 1;
      --1-从插入位置处之后的所有路径外项目序号加 1
      Update 病人路径执行 A Set a.项目序号 = n_Num Where a.Id = r_Outpathitem.Id;
    End Loop;
    Update 病人路径执行 A Set a.项目序号 = 项目序号_In Where a.Id = 执行id_In;
  Exception
    When Others Then
      Null;
  End p_Sort_项目序号;
Begin
  If 序号_In = 1 And (项目内容_In Is Null Or 项目内容_In = '未生成任何项目' Or 项目内容_In = '路径外项目') Then
    --合并路径
    If 合并路径阶段s_In Is Not Null Then
      Select Nvl(当前天数, 1) Into n_当前天数 From 病人临床路径 Where ID = 路径记录id_In;
      --求出增量(首要路径提前合并路径就提前，首要路径延后，合并路径就延后)
      n_天数          := 天数_In - n_当前天数;
      v_合并路径阶段s := 合并路径阶段s_In || ',';
      While v_合并路径阶段s Is Not Null Loop
        n_合并路径记录id := To_Number(Substr(v_合并路径阶段s, 1, Instr(v_合并路径阶段s, ':') - 1));
        n_合并路径阶段id := To_Number(Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ':') + 1,
                                       Instr(v_合并路径阶段s, ',') - Instr(v_合并路径阶段s, ':') - 1));
        Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人合并路径 Where ID = n_合并路径记录id;
        If v_当前阶段id <> n_合并路径阶段id Then
          Update 病人合并路径 Set 前一阶段id = 当前阶段id, 当前阶段id = n_合并路径阶段id Where ID = n_合并路径记录id;
        End If;
        Update 病人合并路径 Set 当前天数 = Nvl(当前天数, 1) + n_天数 Where ID = n_合并路径记录id;
      
        v_合并路径阶段s := Substr(v_合并路径阶段s, Instr(v_合并路径阶段s, ',') + 1);
      End Loop;
    End If;
    --首要路径
    If 生成者_In = 1 Then
      Select Nvl(当前阶段id, 0) Into v_当前阶段id From 病人临床路径 Where ID = 路径记录id_In;
      If v_当前阶段id <> 阶段id_In Then
        Update 病人临床路径 Set 前一阶段id = 当前阶段id, 当前阶段id = 阶段id_In Where ID = 路径记录id_In;
      End If;
      Update 病人临床路径 Set 当前天数 = 天数_In Where ID = 路径记录id_In;
    End If;
  End If;

  --添加的路径外项目:即使有可选的项目可能还未生成,序号占用见后面补充项目调序处理
  If 项目内容_In Is Not Null Then
    Select Max(Nvl(a.项目序号, b.项目序号)) + 1
    Into v_项目序号
    From 病人路径执行 A, 临床路径项目 B
    Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id(+);
  End If;

  v_路径执行id := 0;
  If 序号_In = 0 And 项目内容_In Is Null Then
    --加max是为了容错以前的数据，实际上同一项目在当天只有一条执行记录
    Select Nvl(Max(ID), 0)
    Into v_路径执行id
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 项目id = 项目id_In;
  End If;

  --医嘱界面添加的非路径外项目
  If v_路径执行id = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 日期 = 日期_In;
    If n_Count = 0 Then
      --首次生成路径项目，转存前一天的暂存项目
      Update 病人路径执行
      Set 阶段id = 阶段id_In, 日期 = 日期_In, 天数 = 天数_In, 项目序号 = Null
      Where ID In (Select ID From 病人路径执行 Where 路径记录id = 路径记录id_In And 生成时间性质 = 2);
      --修改暂存标识
      Update 病人路径执行
      Set 生成时间性质 = Null
      Where ID In (Select a.Id
                   From 病人路径执行 A, 病人路径医嘱 B, 病人医嘱记录 C
                   Where a.Id = b.路径执行id And b.病人医嘱id = c.Id And a.路径记录id = 路径记录id_In And a.生成时间性质 = 2 And
                         a.日期 = Trunc(c.开始执行时间));
    End If;
    Select 病人路径执行_Id.Nextval Into v_路径执行id From Dual;
    Insert Into 病人路径执行
      (ID, 路径记录id, 阶段id, 日期, 天数, 分类, 项目id, 登记人, 登记时间, 项目序号, 项目内容, 执行者, 生成者, 项目结果, 图标id, 添加原因, 变异原因, 合并路径记录id, 合并路径阶段id,
       生成时间性质)
    Values
      (v_路径执行id, 路径记录id_In, 阶段id_In, 日期_In, 天数_In, 分类_In, 项目id_In, 登记人_In, 登记时间_In, v_项目序号, 项目内容_In, 执行者_In, 生成者_In,
       项目结果_In, 图标id_In, 添加原因_In, 变异原因_In, 合并路径记录id_In, 合并路径阶段id_In, 生成时间性质_In);
  
    --路径外项目序号插入 排序
    If 插入位置id_In <> 0 Then
      --获取要插入的序号
      Select Nvl(a.项目序号, b.项目序号)
      Into v_项目序号
      From 病人路径执行 A, 临床路径项目 B
      Where a.Id = 插入位置id_In And a.项目id = b.Id(+);
      --序号调整
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
    --路径项目补充生成时,序号重整:假如临床路径项目存在A1,A2,A3这3个项目,首次生成A1,A2后,再生成路径外项目B1,B2,同时将B1,B2插入到A1的位置
    --         那么此时病人路径执行中的序号变为:B1(1),B2(2),A1(3),A2(4),如果再补充生成A3时,路径显示顺序变为：B1(1),B2(2),A1(3),A3(3),A2(4)
    --         这样就会出现路径项目中补充生成的A3不能按照临床路径项目的顺序A1,A2,A3 正确排序。
  
    --当前阶段，当前天数，当前分类下，存在路径内项目且路径内的项目序号被重新调整过。（未添加路径外项目时，路径内项目的序号为空）
    Select Nvl(Count(ID), 0)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = 路径记录id_In And 阶段id = 阶段id_In And 天数 = 天数_In And 分类 = 分类_In And 项目id Is Not Null And 项目序号 Is Not Null;
    --补充生成的路径项目序号重整
    If n_Count > 0 And 项目id_In Is Not Null Then
      --查找补充生成的路径项目,应该插入的位置
      Select Min(b.项目序号)
      Into n_Minnum
      From 病人路径执行 A, 临床路径项目 B
      Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id;
    
      Select 项目序号 Into v_项目序号 From 临床路径项目 Where ID = 项目id_In;
      --确定该路径项目序号插入的位置：
      If v_项目序号 = n_Minnum Then
        --v_项目序号 = n_Minnum：病人路径执行记录已在此排序前插入到数据库，插入的这天数据就是最小的这条数据
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 > n_Minnum
               Order By b.项目序号)
        Where Rownum = 1;
      Else
        Select 项目序号
        Into v_项目序号
        From (Select Nvl(a.项目序号, b.项目序号) As 项目序号
               
               From 病人路径执行 A, 临床路径项目 B
               Where a.路径记录id = 路径记录id_In And a.阶段id = 阶段id_In And a.天数 = 天数_In And a.分类 = 分类_In And a.项目id = b.Id And
                     b.项目序号 < v_项目序号
               Order By b.项目序号 Desc)
        Where Rownum = 1;
        v_项目序号 := v_项目序号 + 1;
      End If;
      p_Sort_项目序号(v_项目序号, v_路径执行id);
    End If;
  
    --如果是自动执行模式（连续提前多个阶段时调用）;补录路径外项目
    If 自动执行_In = 1 Then
      Select zl_GetSysParameter('是否启用路径执行环节', 1256) Into v_执行环节 From Dual;
      If v_执行环节 = '1' Then
        Select zl_GetSysParameter('路径执行环节启用场合', 1256) Into v_执行环节 From Dual;
      
        Select Nvl(Nvl(a.执行者, b.执行者), 0)
        Into n_Count
        From 病人路径执行 A, 临床路径项目 B
        Where a.项目id = b.Id(+) And a.Id = v_路径执行id;
        --当前执行者符合启用场合自动执行,当执行者取不到值时,统一处理。
        If n_Count = 0 Or Substr(v_执行环节, n_Count, 1) = '1' Then
          Update 病人路径执行
          Set 执行人 = 登记人_In, 执行时间 = 登记时间_In, 执行结果 = '已经执行', 执行说明 = '自动执行。'
          Where ID = v_路径执行id;
        End If;
      End If;
    End If;
  End If;
  --删除特殊项目：未生成任何项目（如果当前阶段，当前日期存在其他项目，需删除“未生成任何项目”）
  Select Count(ID)
  Into n_Count
  From 病人路径执行 T
  Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And Nvl(t.项目内容, '路径内项目') = '未生成任何项目';

  If n_Count > 0 Then
    Select Count(ID)
    Into n_Count
    From 病人路径执行 T
    Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And Nvl(t.项目内容, '路径内项目') <> '未生成任何项目';
    If n_Count > 0 Then
      Delete From 病人路径执行 T
      Where t.路径记录id = 路径记录id_In And t.阶段id = 阶段id_In And t.天数 = 天数_In And Nvl(t.项目内容, '路径内项目') = '未生成任何项目';
    End If;
  End If;

  If 医嘱ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Advice From Table(f_Num2list(医嘱ids_In));
    Forall I In 1 .. t_Advice.Count
      Insert Into 病人路径医嘱 (路径执行id, 病人医嘱id) Values (v_路径执行id, t_Advice(I));
  End If;
  If 婴儿_In Is Not Null And 病人病历ids_In Is Not Null Then
    Select Column_Value Bulk Collect Into t_Baby From Table(f_Num2list(婴儿_In, '|'));
    Select Column_Value Bulk Collect Into t_Strdoc From Table(f_Str2list(病人病历ids_In, '|'));
    Select Column_Value Bulk Collect Into t_Strfile From Table(f_Str2list(病历文件ids_In, '|'));
    For K In 1 .. t_Baby.Count Loop
      n_婴儿 := t_Baby(K);
      Select Column_Value Bulk Collect Into t_Doc From Table(f_Num2list(t_Strdoc(K)));
      Select Column_Value Bulk Collect Into t_File From Table(f_Num2list(t_Strfile(K)));
      For I In 1 .. t_Doc.Count Loop
        v_病历id := t_Doc(I);
        Insert Into 电子病历记录
          (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间, 最后版本, 签名级别, 编辑方式, 路径执行id)
          Select v_病历id, 2, 病人id_In, 主页id_In, n_婴儿, 科室id_In, 种类, ID, 名称, 登记人_In, 登记时间_In, 登记人_In, 登记时间_In, 1, 0,
                 Decode(保留, 2, 1, 0), v_路径执行id
          From 病历文件列表
          Where ID = t_File(I);
      
        For Rs In (Select ID, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲,
                          使用时机, 诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域
                   From 病历文件结构
                   Where 文件id = t_File(I)
                   Order By 对象序号) Loop
        
          Select 电子病历内容_Id.Nextval Into v_Id From Dual;
        
          If Rs.父id = 0 Then
            v_当前父id := v_Id;
            v_父id     := Null;
          Else
            --对象序号为空的时候，父ID就不是按照顺序的了，需要重新查找
            If Rs.对象序号 Is Null Then
              Select 对象序号 Into v_原对象序号 From 病历文件结构 Where ID = Rs.父id;
              If v_原对象序号 Is Null Then
                v_父id := Null;
              Else
                Select ID Into v_父id From 电子病历内容 Where 文件id = v_病历id And 对象序号 = v_原对象序号;
              End If;
            Else
              v_父id := v_当前父id;
            End If;
          End If;
        
          If Rs.对象类型 = 4 And Rs.替换域 = 1 Then
            v_内容文本 := Zl_Replace_Element_Value(Rs.要素名称, 病人id_In, 主页id_In, 2, Null, n_婴儿);
          Else
            v_内容文本 := Rs.内容文本;
          End If;
        
          Insert Into 电子病历内容
            (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 定义提纲id, 复用提纲, 使用时机,
             诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
          Values
            (v_Id, v_病历id, 1, 0, v_父id, Rs.对象序号, Rs.对象类型, Rs.对象标记, Rs.保留对象, Rs.对象属性, Rs.内容行次, v_内容文本, Rs.是否换行,
             Rs.预制提纲id, Decode(Rs.父id, 0, Rs.Id, Null), Rs.复用提纲, Rs.使用时机, Rs.诊治要素id, Rs.替换域, Rs.要素名称, Rs.要素类型, Rs.要素长度,
             Rs.要素小数, Rs.要素单位, Rs.要素表示, Rs.输入形态, Rs.要素值域);
        
          If Rs.对象类型 = 5 Then
            Insert Into 电子病历图形
              (对象id, 图形)
            Values
              (v_Id, (Select 图形 From 病历文件图形 Where 对象id = Rs.Id));
          End If;
        
        End Loop;
      
        Insert Into 电子病历格式
          (文件id, 内容)
        Values
          (v_病历id, (Select 内容 From 病历文件格式 Where 文件id = t_File(I)));
      End Loop;
    End Loop;
  End If;

  If Nvl(电子病历id_In, 0) <> 0 Then
    Update 电子病历记录 Set 路径执行id = v_路径执行id Where ID = 电子病历id_In;
  End If;
  If 任务ids_In Is Not Null Then
    For Rs In (Select /*+ Rule*/
                Column_Value As 任务id
               From Table(Cast(f_Str2list(任务ids_In, ',') As Zltools.t_Strlist))) Loop
      Insert Into 病人路径病历 (路径执行id, 任务id) Values (v_路径执行id, Rs.任务id);
    End Loop;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径生成_Insert;
/

--86654:黄捷,2016-07-28,检查号并发出现重复号码问题

CREATE OR REPLACE Function Nextno
(
  序号_In     In 号码控制表.项目序号%Type,
  科室id_In   In 部门表.Id%Type := Null,
  v_Tag       In Varchar2 := Null,
  号码个数_In In Integer := 1
) Return Varchar2
--    功能：根据特定规则产生新的号码,规则如下：
  --    一、项目序号：
  --       1   病人ID         数字
  --       2   住院号         数字
  --       3   门诊号         数字
  --       10  医嘱发送号     数字,顺序递增编号
  --       x   其它单据号     字符,根据编号规则顺序递增编号,不自动补缺
  --    二、年度位确定原则：
  --       以1990为基数，随年度增长，按“0～9/A～Z”顺序作为年度编码
  --
  --    说明：最大号码-10存入号码控制表,用于并发情况下补缺号(取了号,但未使用)
  --          For Update在并发情况下锁定行,不用Wait选项以避免向调用者返回空
  --          v_Tag 可用其它未指明的参数,目前 有影像检查类别(编码)
  --    返回：最大号码
 Is
  Pragma Autonomous_Transaction;
  v_No     号码控制表.最大号码%Type;
  v_Maxno  号码控制表.最大号码%Type;
  n_Maxno  Number;
  n_Amt    Number;
  n_Mod    号码控制表.编号规则%Type;
  v_Deptno Varchar2(20);
  v_Year   Varchar2(1);
  v_Tmp    Varchar2(10);

  v_试管编码   Number;
  v_生成条码   Varchar2(20);
  v_编码       Varchar2(10);
  v_医嘱       Varchar2(18);
  v_Error      Varchar2(255);
  n_Checkmaxno Number;

  Err_Custom Exception;
Begin

  --1.病人ID
  If 序号_In = 1 Then
    Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;

    --从序列取值，用于不要求病人ID必须连续的用户减少并发争用
    If n_Mod = 1 Then
      Select 病人信息_Id.Nextval Into v_No From Dual;
    Else
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      Select Nvl(Max(病人id), 0) + 1 Into n_Maxno From 病人信息 Where 病人id >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
      v_No := To_Char(n_Maxno);
    End If;
    --2.住院号
  Elsif 序号_In = 2 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --0.顺序编号
      Select Nvl(Max(住院号), 0) + 1 Into n_Maxno From 病人信息 Where 住院号 >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.年月(YYMM)+顺序号(0000)
      v_Tmp := To_Char(Sysdate, 'YYMM');

      Select Nvl(Max(住院号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;

    Elsif n_Mod = 2 Then
      --2.年(YYYY)+顺序号(00000)
      v_Tmp := To_Char(Sysdate, 'YYYY');

      Select Nvl(Max(住院号), To_Number(v_Tmp || '00000')) + 1
      Into n_Maxno
      From 病人信息
      Where 住院号 Like To_Number(v_Tmp) || '%' And 住院号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '00000')), 1, n_Maxno - 10, To_Number(v_Tmp || '00001'))
      Where 项目序号 = 序号_In;

    End If;
    v_No := To_Char(n_Maxno);

    --3.门诊号
  Elsif 序号_In = 3 Then
    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --0.顺序编号

      Select Nvl(Max(门诊号), 0) + 1 Into n_Maxno From 病人信息 Where 门诊号 >= To_Number(v_Maxno);

      Update 号码控制表 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 项目序号 = 序号_In;
    Elsif n_Mod = 1 Then
      --1.日期编号YYMMDD
      v_Tmp := To_Char(Sysdate, 'YYMMDD');

      Select Nvl(Max(门诊号), To_Number(v_Tmp || '0000')) + 1
      Into n_Maxno
      From 病人信息
      Where 门诊号 Like To_Number(v_Tmp) || '%' And 门诊号 >= To_Number(v_Maxno);
      Update 号码控制表
      Set 最大号码 = Decode(Sign(n_Maxno - 10 - To_Number(v_Tmp || '0000')), 1, n_Maxno - 10, To_Number(v_Tmp || '0001'))
      Where 项目序号 = 序号_In;

    End If;
    v_No := To_Char(n_Maxno);

    --10.医嘱发送号
  Elsif 序号_In = 10 Then
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;

    --汇总发药号
  Elsif 序号_In = 20 Then
    --YYYYMMDD+5位顺序号(00000)
    Select To_Char(Sysdate, 'yyyymmdd') Into v_Tmp From Dual;
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '00001';
    Else
      If Substr(v_Maxno, 1, 8) = v_Tmp Then
        If To_Number(Substr(v_Maxno, 9, 5)) = 99999 Then
          v_Maxno := v_Tmp || '00001';
        Else
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 9, 5)) + 1, '00000'));
        End If;
      Else
        v_Maxno := v_Tmp || '00001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;

    v_No := v_Maxno;

  Elsif 序号_In = 123 Then

    Select Nvl(Max(参数值), 0) Into n_Mod From 影像流程参数 Where 科室id = 科室id_In And 参数名 = '检查号生成方式';
    Select Nvl(Max(参数值), 1)
    Into n_Checkmaxno
    From 影像流程参数
    Where 科室id = 科室id_In And 参数名 = '提取实际最大号码';

    If n_Mod = 1 Then
      --影像检查号按科室递增
      --从号码表提取最大号码
      Select Count(*) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In;
      If Nvl(n_Maxno, 0) = 0 Then
          --没有记录，则自动增加科室号码表
          Insert Into 科室号码表 (项目序号, 科室id, 编号, 最大号码) Values (序号_In, 科室id_In, 'A', '1');
          Commit;
      End If;
      
      Select Nvl(最大号码, 0) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In for update;      

      --提取实际最大号码,如果有实际最大号码，这个号码会比号码表中的大10
      If n_Checkmaxno = 1 Then
        Select Nvl(Max(检查号), 0) + 1 Into n_Amt From 影像检查记录 Where 执行科室id = 科室id_In And 检查号 >= n_Maxno;

        If n_Amt > n_Maxno Then
          n_Maxno := n_Amt;
        End If;
      Else
        -- 如果不提取实际最大号码，加上10
        n_Maxno := n_Maxno + 10 + 1;
      End If;

      -- 回填最大号码
      Update 科室号码表
        Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1)
        Where 项目序号 = 序号_In And 科室id = 科室id_In;
    Else
      --影像检查号按类别递增
      Select Nvl(最大号码, 0) Into n_Maxno From 影像检查类别 Where 编码 = v_Tag for update ;
      --提取实际最大号码，如果有实际最大号码，这个号码会比号码表中的大10
      If n_Checkmaxno = 1 Then
        Select Nvl(Max(检查号), 0) + 1 Into n_Amt From 影像检查记录 Where 影像类别 = v_Tag And 检查号 >= n_Maxno;

        If n_Amt > n_Maxno Then
          n_Maxno := n_Amt;
        End If;
      Else
        -- 如果不提取实际最大号码，加上10
        n_Maxno := n_Maxno + 10 + 1;
      End If;

      -- 回填最大号码
      Update 影像检查类别 Set 最大号码 = Decode(Sign(n_Maxno - 10), 1, n_Maxno - 10, 1) Where 编码 = v_Tag;
    End If;
    v_No := To_Char(n_Maxno);

  Elsif 序号_In = 124 Then
    ----------------------------------------------------------------------------------------------------------------------------
    --体检健康号

    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;

    If n_Mod = 0 Then
      --顺序编号
      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into v_Maxno
      From 号码控制表
      Where 项目序号 = 序号_In
      For Update;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    Else
      --前缀+顺序号
      Update 号码编号表 Set 最大号码 = 最大号码 Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
      If Sql%RowCount = 0 Then
        Insert Into 号码编号表
          (项目序号, 号码前缀, 日期, 最大号码)
          Select 序号_In, v_Tag, Sysdate, '' From Dual;
      End If;

      Select Nvl(Zl_To_Number(最大号码), 0) + 号码个数_In
      Into n_Maxno
      From 号码编号表 A
      Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;

      If Substr(n_Maxno, 1, Length(v_Tag)) <> v_Tag Then
        --进位了
        Select Nvl(Zl_To_Number(Substr(最大号码, Length(v_Tag) + 1)), 0) + 号码个数_In
        Into n_Maxno
        From 号码编号表 A
        Where a.项目序号 = 序号_In And a.号码前缀 = v_Tag;
        Select v_Tag || n_Maxno Into v_Maxno From Dual;
      Else
        If n_Maxno = 号码个数_In Then
          v_Maxno := v_Tag || To_Char(号码个数_In);
        Else
          v_Maxno := n_Maxno;
        End If;
      End If;

      Update 号码编号表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In And 号码前缀 = v_Tag;
    End If;
    v_No := v_Maxno;

  Elsif 序号_In = 125 Then
    --这里是为了减少号码控制表的锁定时间
    If n_Mod = 0 Then
      Begin
        Select 试管编码
        Into v_试管编码
        From 病人医嘱记录 A, 诊疗项目目录 B
        Where a.诊疗项目id = b.Id And a.Id = 科室id_In And 试管编码 Is Not Null;
      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码！';
          Raise Err_Custom;
      End;
    Else
      Begin
        Select 试管编码, c.编码
        Into v_试管编码, v_编码
        From 病人医嘱记录 A, 诊疗项目目录 B, 诊疗检验类型 C
        Where a.诊疗项目id = b.Id And a.Id = 科室id_In And b.操作类型 = c.名称 And 试管编码 Is Not Null;

      Exception
        When Others Then
          v_Error := '没有找到检验项目对应的管码和编码！';
          Raise Err_Custom;
      End;
    End If;

    Select Nvl(最大号码, '0'), Nvl(编号规则, 0)
    Into v_Maxno, n_Mod
    From 号码控制表
    Where 项目序号 = 序号_In
    For Update;

    If n_Mod = 0 Then
      --按医嘱生成

      v_医嘱 := 科室id_In;
      If Length(v_医嘱) > 12 Then
        v_医嘱 := Substr(v_医嘱, Length(v_医嘱) - 11);
      Else
        v_医嘱 := LPad(v_医嘱, 12, '0');
      End If;
      if Length(ltrim(v_医嘱,'0'))>8 then
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (13 - Length(v_试管编码) - 2)), (13 - Length(v_试管编码)), '0')
          Into v_生成条码
         From Dual;
      else
         Select v_试管编码 || LPad(Substr(v_医嘱, Length(v_医嘱) - (12 - Length(v_试管编码) - 2)), (12 - Length(v_试管编码)), '0')
         Into v_生成条码
         From Dual;
      end if;
      v_No := v_生成条码;
    Else
      --按"小组编号（1位）+管码(2位)+日期(6位)+顺序号(3)位"生成条码
      Begin
        Select 最大号码
        Into v_Maxno
        From 号码编号表
        Where 项目序号 = 序号_In And 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate)
        For Update;
        v_Maxno := v_Maxno + 1;
        If Length(v_Maxno) <= 3 Then
          v_Maxno := LPad(v_Maxno, 3, '0');
        End If;
        v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || v_Maxno;
        Update 号码编号表
        Set 日期 = Trunc(Sysdate), 最大号码 = v_Maxno
        Where 号码前缀 = v_编码 || v_试管编码 And Trunc(日期) = Trunc(Sysdate);
      Exception
        When Others Then
          Update 号码编号表 Set 日期 = Trunc(Sysdate), 最大号码 = 1 Where 号码前缀 = v_编码 || v_试管编码;
          If Sql%RowCount = 0 Then
            Insert Into 号码编号表
              (项目序号, 号码前缀, 日期, 最大号码)
            Values
              (序号_In, v_编码 || v_试管编码, Trunc(Sysdate), 1);
          End If;
          v_No := v_编码 || v_试管编码 || To_Char(Trunc(Sysdate), 'yymmdd') || '001';
      End;
    End If;
    --卫材条码序号
  Elsif 序号_In = 126 Then
    --12位顺序号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := '000000000001';
    Else
      v_Maxno := Trim(To_Char(To_Number(v_Maxno) + 1, '000000000000'));
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;

    v_No := v_Maxno;
  Elsif 序号_In = 135 Then
    --药品卫材调价
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;
    --1.年月(YYYYMM)+顺序号(0000)
    v_Tmp := To_Char(Sysdate, 'YYYYMM');
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

    If v_Maxno = '0' Then
      v_Maxno := v_Tmp || '0001';
    Else
      If Substr(v_Maxno, 1, 6) = v_Tmp Then
        v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 4)) + 1, '0000'));
      Else
        v_Maxno := v_Tmp || '0001';
      End If;
    End If;
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
  Elsif 序号_In = 136 Then
      --YYMMDD+5位顺序号(00000)
      Select To_Char(sysdate, 'yymmdd') Into v_Tmp From Dual;
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '00001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          If To_Number(Substr(v_Maxno, 7, 5)) = 99999 Then
            v_Maxno := v_Tmp || '00001';
          Else
            v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 5)) + 1, '00000'));
          End If;
        Else
          v_Maxno := v_Tmp || '00001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;
  Elsif 序号_In = 131 Then
    --体检报到号
    Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;
    v_Maxno := To_Char(To_Number(v_Maxno) + 1);
    Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
    v_No := v_Maxno;
    --其它单据号
  Else
    Begin
      Select Nvl(编号规则, 0) Into n_Mod From 号码控制表 Where 项目序号 = 序号_In;
    Exception
      When Others Then
        v_Error := '号码控制表中不存在序号为' || 序号_In || '的号码';
        Raise Err_Custom;
    End;

    --如果规则是按科室编号顺序产生，但又未设置科室编码，则采取按年顺序编号
    If n_Mod = 2 And 序号_In <> 122 Then
      Begin
        Select 编号 Into v_Deptno From 科室号码表 Where 科室id = 科室id_In And 项目序号 = 序号_In;
      Exception
        When Others Then
          Null;
      End;
      If v_Deptno Is Null Then
        n_Mod := 0;
      End If;
    End If;

    Select Decode(Sign(Intyear - 10), -1, To_Char(Intyear, '9'), Chr(55 + Intyear))
    Into v_Year
    From (Select To_Number(To_Char(Sysdate, 'yyyy'), '9999') - 1990 As Intyear From Dual);

    If n_Mod = 0 Then
      --0.按年顺序编号
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;

      --第2位增长方式:0-9,A-Z
      Select Bit1 || Decode(Sign(Ascii(Bit2) - Ascii('9')), -1, LPad(To_Number(Bit28) + 1, 7, '0'),
                             Decode(Bit38, '999999', Decode(Bit2, '9', 'A', Chr(Ascii(Bit2) + 1)) || '000000',
                                     Bit2 || LPad(To_Number(Bit38) + 1, 6, '0')))
      Into v_No
      From (Select Substr(Maxno, 1, 1) As Bit1, Substr(Maxno, 2, 1) As Bit2, Substr(Maxno, 2) As Bit28,
                    Substr(Maxno, 3) As Bit38
             From (Select Decode(v_No, '0', v_Year || '0000000',
                                   Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)), -1, v_Year || '0000000', v_No)) As Maxno
                    From Dual));

      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;

    Elsif n_Mod = 1 Then
      --1.按年+日顺序编号:YDDD0000
      Select Nvl(最大号码, '0') Into v_No From 号码控制表 Where 项目序号 = 序号_In For Update;
      Select v_Year || LPad(Trunc(Sysdate - Trunc(Sysdate, 'YYYY') + 1, 0), 3, '0') || '0000' Into v_Maxno From Dual;
      If v_No < v_Maxno Then
        v_No := v_Maxno;
      End If;
      v_No := Substr(v_No, 1, 4) || LPad(To_Number(Substr(v_No, 5, 4)) + 1, 4, '0');
      Update 号码控制表 Set 最大号码 = v_No Where 项目序号 = 序号_In;

    Elsif n_Mod = 2 Then
      If 序号_In = 122 Then
        --2.按科室编码+YYMMDD+3位顺序号:2201090728001
        Select Count(*) Into n_Maxno From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In;
        If Nvl(n_Maxno, 0) = 0 Then
          Insert Into 科室号码表 (项目序号, 科室id, 最大号码, 编号) Values (序号_In, 科室id_In, Null, Null);
          Commit;
        End If;

        Select 编码 Into v_Deptno From 部门表 Where ID = 科室id_In;
        Select Nvl(最大号码, '-') Into v_No From 科室号码表 Where 项目序号 = 序号_In And 科室id = 科室id_In For Update;
        v_Tmp := To_Char(Sysdate, 'YYMMDD');

        If Substr(v_No, 1, Length(v_Deptno || v_Tmp)) = v_Deptno || v_Tmp Then
          v_No := v_Deptno || v_Tmp || LPad(To_Number(Substr(v_No, Length(v_Deptno || v_Tmp) + 1)) + 1, 3, '0');
        Else
          v_No := v_Deptno || v_Tmp || LPad('1', 3, '0');
        End If;
        Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And 科室id = 科室id_In;

      Else
        --2.按年+科室编号+月+顺序号:YKDD0000
        Begin
          --符号-的asscii为45,用于和year比较(0的ascii为48)
          Select 编号, Nvl(最大号码, '-')
          Into v_Deptno, v_No
          From 科室号码表
          Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0)
          For Update;
        Exception
          When Others Then
            Null;
        End;
        If v_Deptno Is Null Then
          v_Error := '科室未设置编号，无法产生号码！';
          Raise Err_Custom;
        Else
          v_Tmp := To_Char(Sysdate, 'MM');
          Select Substr(Maxno, 1, 4) || LPad(To_Number(Substr(Maxno, 5, 4)) + 1, 4, '0')
          Into v_No
          From (Select Decode(Sign(Ascii(Substr(v_No, 1, 1)) - Ascii(v_Year)), -1, v_Year || v_Deptno || v_Tmp || '0000',
                                Decode(Sign(To_Number(Substr(v_No, 3, 2)) - To_Number(v_Tmp)), -1,
                                        v_Year || v_Deptno || v_Tmp || '0000', v_No)) As Maxno
                 From Dual);
          Update 科室号码表 Set 最大号码 = v_No Where 项目序号 = 序号_In And Nvl(科室id, 0) = Nvl(科室id_In, 0);

        End If;
      End If;
    Elsif n_Mod = 3 Then

      --按年月日+000001生成
      Select Substr(To_Char(Sysdate, 'yyyymmdd'), 3, 6) Into v_Tmp From Dual;
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;

    Elsif n_Mod = 5 Then
      --1.年月(YYYYMM)+顺序号(000000)
      v_Tmp := To_Char(Sysdate, 'YYYYMM');
      Select Nvl(最大号码, '0') Into v_Maxno From 号码控制表 Where 项目序号 = 序号_In For Update;

      If v_Maxno = '0' Then
        v_Maxno := v_Tmp || '000001';
      Else
        If Substr(v_Maxno, 1, 6) = v_Tmp Then
          v_Maxno := v_Tmp || Trim(To_Char(To_Number(Substr(v_Maxno, 7, 6)) + 1, '000000'));
        Else
          v_Maxno := v_Tmp || '000001';
        End If;
      End If;
      Update 号码控制表 Set 最大号码 = v_Maxno Where 项目序号 = 序号_In;
      v_No := v_Maxno;
    Else
      v_Error := '序号为' || 序号_In || '的号码,其规则值:' || n_Mod || ',当前系统不支持！';
      Raise Err_Custom;
    End If;
  End If;

  Commit;
  Return v_No;
Exception
  When Err_Custom Then
    Rollback;
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Rollback;
    zl_ErrorCenter(SQLCode, SQLErrM);
End Nextno;
/

--97597:张德婷,2016-07-20,修正优先级问题
CREATE OR REPLACE Procedure Zl_输液配药记录_分批
(
 配药id_In In Varchar2, --ID串:配药ID1,批次1:优先级|配药ID2,批次2....
 手工调整批次_In in number:=0
) Is
  v_Tansid  Varchar2(20);
  v_批次  Varchar2(20);
  v_Tmp     Varchar2(4000);
  v_Fields  Varchar2(4000);
  n_优先级  输液配药记录.优先级%type;
  d_执行时间 date;
Begin
  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || '|';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Fields    := Substr(v_Tmp, 1, Instr(v_Tmp, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_批次 := Substr(v_Fields, Instr(v_Fields, ',') + 1,Instr(v_Fields, ':') - 1- Instr(v_Fields, ','));
    n_优先级:= Substr(v_Fields, Instr(v_Fields, ':') + 1);

    v_Tmp := Replace('|' || v_Tmp, '|' || v_Fields || '|');

    Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_Tansid;
    
    if 手工调整批次_In=1 then
      select 执行时间 into d_执行时间 from 输液配药记录 where ID = v_Tansid and rownum<2;
      update 输液配药记录 set 手工调整批次=1 where 医嘱id in (select 医嘱id from 病人医嘱记录 where 病人id=(select 病人id from 病人医嘱记录 where 医嘱id=(select 医嘱id from 输液配药记录 where ID = v_Tansid and rownum<2) and rownum<2)) and Trunc(执行时间)=Trunc(d_执行时间);
    end if;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_分批;
/

--99836:胡俊勇,2016-09-06,门诊作废有附加费用的医嘱
--100297:胡俊勇,2016-09-06,门诊医嘱作废
--98672:胡俊勇,2016-07-19,门诊作废医保病人部分退费医嘱
Create Or Replace Procedure Zl_病人医嘱记录_作废
(
  Id_In         病人医嘱记录.Id%Type,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null,
  护理医嘱id_In 病人医嘱记录.Id%Type := Null,
  作废时间_In   病人医嘱状态.操作时间%Type := Null
) Is
  --功能：作废指定的医嘱(未发送的长嘱或临嘱)
  --说明：一并给药的只能调用一次(界面显示有多行)
  --参数：ID_IN=组医嘱ID
  --      护理医嘱id_In 取除开本次作废的护理等级医嘱外的最近的自动停止的护理等级医嘱id

  v_发送号       病人医嘱发送.发送号%Type;
  v_费用no       门诊费用记录.No%Type;
  v_记录性质     门诊费用记录.记录性质%Type;
  v_费用序号     Varchar2(255);
  n_自动取消执行 Number(1) := 0;
  n_先作废后退药 Number(1) := 0;

  v_Date     Date;
  v_Count    Number;
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;

  --包含医嘱相关信息
  Cursor c_Advice Is
    Select a.病人id, a.挂号单, a.主页id, a.婴儿, a.医嘱状态, a.上次执行时间, a.医嘱内容, a.诊疗类别, b.操作类型, a.病人来源, a.执行科室id, b.执行频率, a.诊疗项目id,
           a.开始执行时间
    From 病人医嘱记录 A, 诊疗项目目录 B
    Where a.诊疗项目id = b.Id And a.Id = Id_In;

  r_Advice c_Advice%RowType;

  --门诊医嘱作废时，取对应的费用销帐或作废(收费划价单)：
  --根据医嘱及发送NO求出本次回退要销帐或退费的记录
  --一组医嘱并不是都填写了发送记录,也不一定都计费了,且可能NO不同
  --只管记录状态为1的记录,如果已经销帐或部份销帐的记录,不再处理
  --费用只求价格父号为空的,以便取序号销帐
  --如果"门诊药嘱先作废后退药",则不对相应费用(包括给药途径的)进行检查和处理,除非是还没有执行的记帐单,或未执行、收费的划价单，可以先删了

  Cursor c_Rollmoney(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Decode(a.记录性质, 11, 1, a.记录性质) As 记录性质, a.记录状态, a.No, a.序号, a.执行状态 As 费用执行, c.执行状态 As 医嘱执行, c.执行部门id, b.病人科室id,
           b.诊疗类别, i.操作类型
    From 门诊费用记录 A, 病人医嘱记录 B, 病人医嘱发送 C, 诊疗项目目录 I
    Where c.医嘱id = b.Id And c.发送号 = v_发送号 And (b.Id = Id_In Or b.相关id = Id_In) And a.医嘱序号 = b.Id And a.记录状态 In (0, 1) And
          a.No = c.No And (a.记录性质 = c.记录性质 Or a.记录性质 = 11 And c.记录性质 = 1) And b.诊疗项目id = i.Id And a.价格父号 Is Null And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And
          Not (Exists (Select 1
                        From 门诊费用记录 D
                        Where d.医嘱序号 = b.Id And d.记录状态 In (0, 1) And d.No = c.No And
                              (d.记录性质 = c.记录性质 Or d.记录性质 = 11 And c.记录性质 = 1) And d.收费类别 In ('5', '6', '7'))) Or
          Nvl(a.执行状态, 0) = 0 And Not (a.记录性质 = 1 And a.记录状态 <> 0))
    Order By a.记录性质, a.No, a.序号, a.收费细目id;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态是否正确:并发操作
  Open c_Advice;
  Fetch c_Advice
    Into r_Advice;

  --当前操作人员
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;

  --检查是否是输液配液记录，并是否已经锁定
  Select Count(1) Into v_Count From 输液配药记录 Where 是否锁定 = 1 And 医嘱id = Id_In;
  If v_Count > 0 Then
    v_Error := '医嘱"' || r_Advice.医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能作废。';
    Raise Err_Custom;
  End If;

  If r_Advice.挂号单 Is Null And r_Advice.病人来源 <> 3 Then
    If r_Advice.医嘱状态 In (4, 8, 9) Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经被作废或停止，不能再作废。';
      Raise Err_Custom;
    Elsif r_Advice.上次执行时间 Is Not Null Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经发送，不能被作废。';
      Raise Err_Custom;
    End If;
  
    --持续性护理等级无须发送，校对后就可能已自动计费，作废及回退作废都应按停止流程处理。
    If r_Advice.诊疗类别 = 'H' And r_Advice.操作类型 = '1' And r_Advice.执行频率 = '2' And Nvl(r_Advice.婴儿, 0) = 0 Then
      --(已取消，由于存在无费退院的情况，问题号：45977)a.开始时间是当天之前的，说明已生效（自动费用计算），不允许作废。
      --医嘱的时间只精确到了分钟，所以变动记录的开始时间要去掉秒来比较。
      v_Count := 0;
      Begin
        Select b.终止时间
        Into v_Date
        From 病人变动记录 B, 病人医嘱计价 C
        Where b.病人id = r_Advice.病人id And b.主页id = r_Advice.主页id And c.医嘱id = Id_In And c.收费细目id = b.护理等级id And
              b.开始原因 = 6 And b.附加床位 = 0 And
              To_Char(b.开始时间, 'yyyy-mm-dd hh24:mi') = To_Char(r_Advice.开始执行时间, 'yyyy-mm-dd hh24:mi');
      Exception
        When Others Then
          v_Count := 1;
      End;
      If v_Count = 0 Then
        --d.后续有其他变动发生
        If v_Date Is Not Null Then
          v_Error := '由于护理等级医嘱生效后已经产生了其他变动记录,不能作废该医嘱。';
          Raise Err_Custom;
        Else
          --本次有要自动启用的护理等级，如果和原来护理等级相同则不用撤消护理变动记录
          If Nvl(护理医嘱id_In, 0) <> 0 Then
            Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
            Select 操作类型
            Into v_Count
            From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
            Where Rownum < 2;
            Update 病人医嘱记录
            Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
            Where ID = 护理医嘱id_In;
            --排除过于频繁的操作
            Select Count(a.Id)
            Into v_Count
            From 病人医嘱记录 A, 诊疗收费关系 B, 病案主页 C
            Where a.诊疗项目id = b.诊疗项目id And c.护理等级id = b.收费项目id And c.病人id = a.病人id And c.主页id = a.主页id And
                  a.Id = 护理医嘱id_In;
          End If;
          If v_Count = 0 Then
            --c.护理等级是最后一条变动
            Zl_病人变动记录_Undo(r_Advice.病人id, r_Advice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
          End If;
        End If;
      Else
        --恢复最近一次被自动停止的护理等级
        If Nvl(护理医嘱id_In, 0) <> 0 Then
          Delete 病人医嘱状态 Where 医嘱id = 护理医嘱id_In And 操作类型 In (8, 9);
          Select 操作类型
          Into v_Count
          From (Select 操作类型 From 病人医嘱状态 Where 医嘱id = 护理医嘱id_In Order By 操作时间 Desc)
          Where Rownum < 2;
          Update 病人医嘱记录
          Set 医嘱状态 = v_Count, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null, 确认停嘱时间 = Null, 确认停嘱护士 = Null
          Where ID = 护理医嘱id_In;
        Else
          --病人入院时指定的护理级产生的变动记录和医嘱新开产生的变动记录不同，这里要先判断
          Select Count(a.Id)
          Into v_Count
          From 病人变动记录 A
          Where a.病人id = r_Advice.病人id And a.主页id = r_Advice.主页id And a.开始原因 = 6;
          If v_Count <> 0 Then
            --b.如果与以前的护理等级相同，则校对时没有产生护理等级变动,产生护理等级停止变动
            Zl_病人变动记录_Nurse(r_Advice.病人id, r_Advice.主页id, Null, Sysdate, v_人员编号, v_人员姓名);
          End If;
        End If;
      End If;
    End If;
  Else
    If r_Advice.医嘱状态 <> 8 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"尚未发送或已经作废。';
      Raise Err_Custom;
    End If;
    --医嘱附费判断
    Select Count(1)
    Into v_Count
    From 病人医嘱附费 A, 病人医嘱记录 B
    Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In);
    If v_Count <> 0 Then
      v_Error := '医嘱"' || r_Advice.医嘱内容 || '"存在附加费用，不能作废。';
      Raise Err_Custom;
    End If;
  
    Begin
      --医嘱ID为传入值的这条医嘱不一定发送了的,甚至无发送。
      Select Distinct 发送号
      Into v_发送号
      From 病人医嘱发送
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    Exception
      When Others Then
        v_发送号 := Null;
    End;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter(68), 0)) Into n_先作废后退药 From Dual;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('门诊本科自动执行', '1252'), 0)) Into n_自动取消执行 From Dual;
    If n_自动取消执行 = 1 And v_发送号 Is Not Null Then
      --先更新医嘱和费用的执行状态，因为后续的判断，以及过程Zl_门诊记帐记录_Delete中有检查
      For Rc In (Select a.医嘱id, a.执行部门id
                 From 病人医嘱发送 A, 病人医嘱记录 B
                 Where a.医嘱id = b.Id And (b.Id = Id_In Or b.相关id = Id_In) And a.执行部门id = b.病人科室id) Loop
        Zl_病人医嘱执行_Cancel(Rc.医嘱id, v_发送号, Null, 1, Rc.执行部门id);
      End Loop;
    End If;
  
    --门诊医嘱只可能发送一次
    --后面退费时还有检查，因为可能医嘱没有费用，所以要检查一次执行状态
    Select Count(*)
    Into v_Count
    From 病人医嘱发送 A, 病人医嘱记录 B, 诊疗项目目录 I
    Where a.医嘱id = b.Id And b.诊疗项目id = i.Id And a.执行状态 In (1, 3) And (b.Id = Id_In Or b.相关id = Id_In) And
          (n_先作废后退药 = 0 Or
          n_先作废后退药 = 1 And Not (b.诊疗类别 In ('5', '6', '7') Or b.诊疗类别 = 'E' And i.操作类型 In ('2', '3', '4')));
    If v_Count > 0 Then
      v_Error := '该医嘱已经执行或正在执行，不能作废。';
      Raise Err_Custom;
    End If;
  End If;

  If 作废时间_In Is Null Then
    Select Sysdate Into v_Date From Dual;
  Else
    v_Date := 作废时间_In;
  End If;

  Update 病人医嘱记录 Set 医嘱状态 = 4 Where ID = Id_In Or 相关id = Id_In;

  Insert Into 病人医嘱状态
    (医嘱id, 操作类型, 操作人员, 操作时间)
    Select ID, 4, v_人员姓名, v_Date From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In;

  --住院医嘱作废时,未打印的情况下,缺省设置为屏蔽打印
  If r_Advice.挂号单 Is Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱打印
    Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    If Nvl(v_Count, 0) = 0 Then
      Zl_病人医嘱记录_屏蔽打印(Id_In, 1);
    End If;
  Else
    --门诊医嘱(临嘱)作废时还需要回退相关内容:只有一次发送
    --回退划价或记帐费用
    If v_发送号 Is Not Null Then
      --将该组医嘱的费用删除或销帐(按一组医嘱可能有不同NO处理)
      --门诊记帐：如果原始费用已被销帐(或部分销帐),调用过程中有判断
      --门诊划价：如果已收费，则不允许删除
      v_费用no   := Null;
      v_费用序号 := Null;
      For r_Rollmoney In c_Rollmoney(v_发送号) Loop
        If Nvl(r_Rollmoney.医嘱执行, 0) In (1, 3) Then
          --1-完全执行;3-正在执行
          v_Error := '医嘱"' || r_Advice.医嘱内容 || '"已经执行或正在执行，不能作废。';
          Raise Err_Custom;
        End If;
        If Nvl(r_Rollmoney.费用执行, 0) In (1, 2) Then
          --1-完全执行;2-部份执行
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的内容已经全部或部分执行，不能作废。';
          Raise Err_Custom;
        End If;
        If r_Rollmoney.费用执行 = 9 Then
          v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"中的收费结算产生异常，不能作废。';
          Raise Err_Custom;
        End If;
        v_Count := 1;
        If r_Rollmoney.记录性质 = 1 And r_Rollmoney.记录状态 <> 0 Then
          If 1 = n_先作废后退药 And r_Rollmoney.诊疗类别 = 'E' And r_Rollmoney.操作类型 In ('2', '3', '4') Then
            v_Count := 0;
          Else
            v_Error := '医嘱费用单据"' || r_Rollmoney.No || '"已经收费，不能作废。';
            Raise Err_Custom;
          End If;
        End If;
        If 1 = v_Count Then
          If Nvl(v_费用no, '空') <> r_Rollmoney.No Then
            If v_费用序号 Is Not Null And v_费用no Is Not Null Then
              v_费用序号 := Substr(v_费用序号, 2);
              If v_记录性质 = 1 Then
                Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
              Elsif v_记录性质 = 2 Then
                Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
              End If;
            End If;
            v_费用序号 := Null;
          End If;
          v_记录性质 := r_Rollmoney.记录性质;
          v_费用no   := r_Rollmoney.No;
          v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
        End If;
      End Loop;
      If v_费用序号 Is Not Null And v_费用no Is Not Null Then
        v_费用序号 := Substr(v_费用序号, 2);
        If v_记录性质 = 1 Then
          Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
        Elsif v_记录性质 = 2 Then
          Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
        End If;
      End If;
    
      --如果"门诊药嘱先作废后退药"，则对应的给药途径费用设置为未执行，以便退费
      If n_先作废后退药 = 1 Then
        Update 门诊费用记录
        Set 执行状态 = 0
        Where 执行状态 = 1 And 医嘱序号 = Id_In And Exists
         (Select 1
               From 病人医嘱记录 A, 诊疗项目目录 B
               Where a.诊疗项目id = b.Id And b.类别 = 'E' And b.操作类型 In ('2', '3', '4') And a.Id = Id_In);
      End If;
    
      --回退医嘱发送记录(及执行记录)
      Delete From 病人医嘱执行 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
      Delete From 病人医嘱发送 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = Id_In Or 相关id = Id_In);
    
      --回退特殊医嘱的处理
      If r_Advice.诊疗类别 = 'Z' And Nvl(r_Advice.操作类型, '0') <> '0' And Nvl(r_Advice.婴儿, 0) = 0 Then
        If r_Advice.操作类型 = '1' And r_Advice.执行科室id Is Not Null Then
          --留观医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And 病人性质 In (1, 2);
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        Elsif r_Advice.操作类型 = '2' And r_Advice.执行科室id Is Not Null Then
          --住院医嘱
          Select Count(*)
          Into v_Count
          From 病案主页
          Where 病人id = r_Advice.病人id And Nvl(主页id, 0) = 0 And 入院科室id = r_Advice.执行科室id And Nvl(病人性质, 0) = 0;
          If v_Count = 1 Then
            Zl_入院病案主页_Delete(r_Advice.病人id, 0);
          End If;
        End If;
      End If;
    End If;
  End If;

  --删除过敏登记记录
  If r_Advice.诊疗类别 = 'E' And r_Advice.操作类型 = '1' Then
    --Update 病人医嘱记录 Set 皮试结果=Null Where ID=ID_IN; --保留最后的皮试结果
    --删除不过敏的记录，过敏记录保留，因为不管医嘱是否作废，病人对该药过敏
    For r_Test In (Select 操作时间 From 病人医嘱状态 Where 医嘱id = Id_In And 操作类型 = 10) Loop
      Delete From 病人过敏记录
      Where 病人id = r_Advice.病人id And 记录来源 = 2 And Nvl(主页id, 0) = Nvl(r_Advice.主页id, 0) And 记录时间 = r_Test.操作时间;
    End Loop;
  End If;

  Close c_Advice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_作废;
/

--98644:张永康,2016-07-15,以最终截止时间来判断每批次可转出的数据
--100994:张永康,2016-09-21,玉溪医院历史数据转出测试集中修改
Create Or Replace Procedure Zl1_Datamoveout1
(
  Demoded_In        In Number,
  Optmode_In        In Number := 0,
  Curtime_In        In Number := 1,
  Totaltime_In      In Number := 1,
  Speedmode_In      In Number := 0,
  Disabletrigger_In In Number := 0,
  Disablejob_In     In Number := 0,
  Parallel_In       In Number := 0,
  Sysowner_In       In Varchar2 := Null,
  Peissysowner_In   In Varchar2 := Null,
  Opersysowner_In   In Varchar2 := Null
) As
  --功能：标记并转出n天前的数据到历史表空间 
  --参数:Demoded_in:          标记转出多少天以前的数据,当参数Optmode_In为0或1时才有效 
  --     Optmode_in:           0-标记并执行转出,1-只进行标记，2-只执行转出(将已标记的) 
  --     Curtime_in,Totaltime_in，连续多次转出时的当前次数和总次数，如果都为1表示一次性转出 
  --                首次时会检查在线表与历史表的结构一致性、在线表的子表是否转出，并且禁用他表外键，禁用转出表引用非转出表的外键索引 
  --                最后一次执行后，需在界面程序中手工恢复禁用的外键和索引 
  --     Speedmode_in:        0-在线模式，1-离线模式（在客户端停用时，转出期间禁用转出表的主键、唯一键、外键约束和索引，以加快删除操作） 
  --                          历史库的约束和索引禁用在应用程序时进行（因为需要用到历史库的连接） 
  --     Disabletrigger_in:   1=转出期间禁用当前所有者的触发器，0-不禁用 
  --     Disablejob_in:       1=转出期间禁用当前所有者的自动作业，0-不禁用 
  --     parallel_in:         重建标记查询所需索引时的并行度，缺省为不并行执行
  --     SysOwner_In:         标准系统指定转出历史表空间所有者
  --     PeisSysOwner_In:     体检系统指定转出历史表空间所有者
  --     OperSysOwner_In:     手麻系统指定转出历史表空间所有者
  --说明：1.标记要转出的数据，可以多次标记，然后分批执行转出 
  --      2.转出时，根据zlBakTables中定义的分组和顺序转出数据，分组提交事务; 
  --      3.为了避免查询范围太大导致性能问题，及Undo表空间增长太大，建议每次不要转出太多的数据(界面程序调用时自动拆分为每次调用转一个月); 
  d_End        Date;
  n_System     Number(5);
  v_Systems    Varchar2(100);
  n_Peissystem Number(5);
  n_Opersystem Number(5);
  n_Reset      Number(1) := 0;
  v_Sql        Varchar2(4000);
  v_Owner      Varchar2(20);

  v_Pre组号      Number(2);
  v_当前批次     Number(8);
  v_序列         Number(8);
  n_重建索引间隔 Zldatamove.重建索引间隔%Type;
  n_重建索引范围 Zldatamove.重建索引范围%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(4000);

  --功能：转移数据（插入后删除，按组提交事务） 
  Procedure Movedata
  (
    v_Table    In Varchar2,
    v_当前批次 In Varchar2,
    v_Owner    In Varchar2
  ) As
    v_Colstr Varchar2(4000);
  Begin
    Select f_List2str(Cast(Collect(Column_Name) As t_Strlist)) As Colsstr
    Into v_Colstr
    From (Select Column_Name From User_Tab_Columns Where Table_Name = v_Table Order By Column_Id);
  
    v_Sql := 'Insert Into /*+ append */ ' || v_Owner || '.' || v_Table || '(' || v_Colstr || ') Select ' || v_Colstr ||
             ' From ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
  
    v_Sql := 'Delete ' || v_Table || ' Where 待转出 = ' || v_当前批次;
    Execute Immediate v_Sql;
    Commit;
    --每张表提交一次，避免Undo占用过多，耗时的业务查询可能报ora-01555快照太旧的错误
  End Movedata;

  --检查历史表等 
  Function Checkvalid(v_Systems In Varchar2) Return Varchar2 Is
    n_只读 Number(3);
    n_状态 Number(1);
    v_Err  Varchar2(4000);
    v_Tmp1 Varchar2(4000);
    v_Tmp2 Varchar2(4000);
    v_Tmp3 Varchar2(4000);
  Begin
    Select Count(1)
    Into n_只读
    From zlBakSpaces
    Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
          (所有者 = Sysowner_In Or 所有者 = Peissysowner_In Or 所有者 = Opersysowner_In) And 只读 = 1;
  
    If n_只读 > 0 Then
      v_Err := '[ZLSOFT]存在只读状态的当前历史数据空间,操作不能继续![ZLSOFT]';
      Return(v_Err);
    End If;
  
    --并发检查，避免人工转出期间，自动作业又调用本过程 
    Select Nvl(状态, 0) Into n_状态 From zlDataMove Where 系统 = n_System And 组号 = 1;
    If n_状态 = 1 Then
      v_Err := '[ZLSOFT]其他用户正在进行转出操作，如果不是这种情况，请手工更新"zlDataMove.状态"的值为空![ZLSOFT]';
      Return(v_Err);
    End If;
    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
    If Optmode_In <> 2 Then
      --检查在线表与后备表的字段是否一致,以避免数据转移了一部分时才报错。 
      For R In (Select 表名 From zlBakTables Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems)))) Loop
        v_Tmp1 := '';
        v_Tmp2 := '';
        v_Tmp3 := '';
        For C In (Select *
                  From (Select a.Column_Name, a.Data_Type, a.Data_Precision, b.Column_Name As Bcolumn_Name,
                                b.Data_Type As Bdata_Type, b.Data_Precision As Bdata_Precision
                         From (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From User_Tab_Columns A
                                Where Table_Name = r.表名) A,
                              (Select Column_Name, Data_Type,
                                       Decode(Data_Type, 'VARCHAR2', Data_Length, Data_Precision) As Data_Precision
                                From All_Tab_Columns
                                Where Table_Name = r.表名 And
                                      Owner In
                                      (Select 所有者
                                       From zlBakSpaces
                                       Where 系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
                                             (所有者 = Sysowner_In Or 所有者 = Peissysowner_In Or 所有者 = Opersysowner_In))) B
                         Where a.Column_Name = b.Column_Name(+))
                  Where Bcolumn_Name Is Null Or Data_Type <> Bdata_Type Or Data_Precision > Bdata_Precision) Loop
        
          If c.Bcolumn_Name Is Null Then
            v_Tmp1 := v_Tmp1 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || ')';
          Elsif c.Data_Type <> c.Bdata_Type Then
            If c.Data_Type = 'DATE' Then
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || ',历史表的为' || c.Bdata_Type;
            Else
              v_Tmp2 := v_Tmp2 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),历史表的为' ||
                        c.Bdata_Type;
            End If;
          Else
            v_Tmp3 := v_Tmp3 || ',' || c.Column_Name || ' ' || c.Data_Type || '(' || c.Data_Precision || '),历史表的为' ||
                      c.Bdata_Precision;
          End If;
        End Loop;
      
        If v_Tmp1 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',缺字段：' || r.表名 || ' ' || v_Tmp1;
        End If;
        If v_Tmp2 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',类型不同：' || r.表名 || ' ' || v_Tmp2;
        End If;
        If v_Tmp3 Is Not Null Then
          v_Err := v_Err || Chr(10) || ',长度较小：' || r.表名 || ' ' || v_Tmp3;
        End If;
      
        If Lengthb(v_Err) > 3000 Then
          v_Err := '[ZLSOFT]请到【管理工具】中执行【历史库修正】' || Substr(v_Err, 1, 3000) || '......[ZLSOFT]';
          Return(v_Err);
        End If;
      End Loop;
    
      If v_Err Is Not Null Then
        v_Err := '[ZLSOFT]请到【管理工具】中执行【历史库修正】:' || Substr(v_Err, 1, 3000) || '[ZLSOFT]';
        --重建H表视图的脚本生成语句示例： 
        --Select 'Create or replace view  ZLHIS.H' || 表名 || ' as Select * From ZLBAK1.' || 表名 || ';' From Zlbaktables Where 系统 In(Select Column_Value From Table(f_num2list(v_Systems))) 
        Return(v_Err);
      End If;
    
      --可能由于历史升级脚本的遗漏，有些不再使用的外键或子表没有删除，为了避免转移到中途时才报错，先检查一遍 
      For P In (Select Constraint_Name
                From (Select Constraint_Name,
                              Row_Number() Over(Partition By Constraint_Name Order By Decode(Constraint_Type, 'P', 0, 1)) Rn
                       From User_Constraints A, zlBakTables B
                       Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))) And
                             a.Constraint_Type In ('P', 'U'))
                Where Rn = 1) Loop
        For R In (Select a.Table_Name, a.Constraint_Name, a.Delete_Rule
                  From User_Constraints A
                  Where a.r_Constraint_Name = p.Constraint_Name And Not Exists
                   (Select 1
                         From zlBakTables B
                         Where b.表名 = a.Table_Name And b.系统 In (Select Column_Value From Table(f_Num2list(v_Systems))))
                  Order By a.r_Constraint_Name) Loop
          v_Err := v_Err || Chr(10) || r.Table_Name || '(' || r.Constraint_Name || ',' || r.Delete_Rule || '->' ||
                   p.Constraint_Name || ')';
          If Lengthb(v_Err) > 2000 Then
            v_Err := '[ZLSOFT]子表未转出:' || Substr(v_Err, 1, 2000) || '......[ZLSOFT]';
            Return(v_Err);
          End If;
        End Loop;
      End Loop;
    
      If v_Err Is Not Null Then
        v_Err := '[ZLSOFT]子表未转出:' || Substr(v_Err, 1, 2000) || '[ZLSOFT]';
        Return(v_Err);
      End If;
    End If;
    Return('');
  End Checkvalid;
Begin
  If Optmode_In <> 2 Then
    Select Trunc(Sysdate) - Demoded_In Into d_End From Dual;
  End If;
  v_Owner := Zl_Owner;
  Select 编号 Into n_System From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '1%';

  Select Nvl(Min(编号), 0) Into n_Peissystem From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '21%';
  Select Nvl(Min(编号), 0) Into n_Opersystem From zlSystems Where Upper(所有者) = v_Owner And 编号 Like '24%';

  --1.安全性检查 
  ----------------------------------------------------------------------------------- 
  If Curtime_In = 1 Then
    v_Systems := n_System;
    If n_Peissystem > 0 Then
      v_Systems := v_Systems || ',' || n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      v_Systems := v_Systems || ',' || n_Opersystem;
    End If;
  
    v_Err_Msg := Checkvalid(v_Systems);
    If v_Err_Msg Is Not Null Then
      Raise Err_Item;
    End If;
  
    --一批中的首次调用时禁用触发器和作业 
    If Disabletrigger_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 1, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 1, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 1, 0);
      End If;
    End If;
  
    If Disablejob_In = 1 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 2, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 2, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 2, 0);
      End If;
    End If;
  
    Update zlDataMove Set 状态 = 1 Where 系统 = n_System And 组号 = 1;
    Commit;
  End If;

  --2.标记要转出的数据 
  ----------------------------------------------------------------------------------- 
  If Optmode_In <> 2 Then
    --上次标记转出出错后继续进行标记转出 
    Select Nvl(Max(批次), 0) Into v_当前批次 From Zldatamovelog Where 系统 = n_System And 待转出 = 2;
  
    If v_当前批次 = 0 Then
      Select Nvl(Max(批次), 0) + 1, Decode(Curtime_In, 1, Nvl(Max(序列), 0) + 1, Max(序列))
      Into v_当前批次, v_序列
      From Zldatamovelog
      Where 系统 = n_System;
    
      Insert Into Zldatamovelog
        (系统, 批次, 序列, 截止时间, 标记开始时间, 待转出, 当前进度)
      Values
        (n_System, v_当前批次, v_序列, d_End, Sysdate, 2, '正在标记待转出数据');
      Commit;
    Else
      Update Zldatamovelog
      Set 标记开始时间 = Sysdate, 当前进度 = '正在标记待转出数据'
      Where 系统 = n_System And 批次 = v_当前批次;
      Commit;
    End If;
  
    Zl1_Datamove_Tag(d_End, v_当前批次, n_System);
    If n_Peissystem > 0 Then
      Execute Immediate 'Begin Zl21_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Peissystem;
    End If;
    If n_Opersystem > 0 Then
      Execute Immediate 'Begin Zl24_Datamove_Tag(:1, :2, :3); End;'
        Using d_End, v_当前批次, n_Opersystem;
    End If;
  
    Update Zldatamovelog
    Set 标记结束时间 = Sysdate, 当前进度 = '标记待转出数据完成', 待转出 = 1
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

  --3.转移数据处理 
  ----------------------------------------------------------------------------------- 
  If Optmode_In = 1 Then
    If Curtime_In = Totaltime_In Then
      Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
    End If;
    Commit;
  Else
    --从最小的批次开始执行转出 
    If Optmode_In = 2 Then
      Select Nvl(Min(批次), 0), Max(截止时间)
      Into v_当前批次, d_End
      From Zldatamovelog
      Where 系统 = n_System And 待转出 = 1;
    
      If v_当前批次 = 0 Then
        Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
        Return;
      End If;
    End If;
  
    --禁用约束和索引 
    If Curtime_In = 1 Then
      Update Zldatamovelog Set 当前进度 = '正在禁用约束和索引' Where 系统 = n_System And 批次 = v_当前批次;
      --要先禁用约束，否则主键或唯一键的索引被禁用后，会导致查询或插入操作报错，而禁用主键或唯一键则会删除对应的索引 
      n_Reset := 1;
      Zl1_Datamove_Reb(n_System, Speedmode_In, 3, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 3, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 3, 0);
      End If;
    
      Zl1_Datamove_Reb(n_System, Speedmode_In, 4, 0);
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 4, 0);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 4, 0);
      End If;
    End If;
  
    --数据转出处理 
    ----------------------------------------------------------------------------------- 
    --不更新汇总表：病人费用汇总，药品收发汇总，药品库存，人员缴款余额等，虽然只是更新的期初数， 
    --但是，由于并非这个时间以前的数据都转出了（部分未符合转出条件的数据未转出），更新后，如果按时间查询，会发现在线中这些日期的数据非常小，容易引起误解 
    --即使出于某些特殊原因需要更新汇总表，也可以通过汇总表处理的过程进行重新汇总，所以，不必在转出过程中逐条更新。 
  
    --"标记结束时间=转出开始时间"时不记录 
    If Optmode_In = 2 Then
      Update Zldatamovelog Set 转出开始时间 = Sysdate Where 系统 = n_System And 批次 = v_当前批次;
    End If;
  
    --a.转出标准版数据
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_System And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Sysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    --b.转出体检数据
    v_Pre组号 := -1;
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_Peissystem And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出体检第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Peissysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
  
    --c.转出手麻数据
    v_Pre组号 := -1;
    For R In (Select 表名, 组号 From zlBakTables Where 系统 = n_Opersystem And 直接转出 = 1 Order By 组号, 序号) Loop
      If Nvl(v_Pre组号, -1) <> r.组号 Then
        Update Zldatamovelog
        Set 当前进度 = '正在转出手麻第' || r.组号 || '组(' || r.表名 || '...)数据'
        Where 系统 = n_System And 批次 = v_当前批次;
        Commit;
      End If;
    
      Movedata(r.表名, v_当前批次, Opersysowner_In);
      v_Pre组号 := r.组号;
    End Loop;
    Commit;
  
    Update 病案主页 Set 待转出 = Null, 数据转出 = 1 Where 待转出 = v_当前批次;
  
    Update zlDataMove Set 上次日期 = d_End Where 系统 = n_System And 组号 = 1;
  
    v_Sql := 'Update ' || Sysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_System;
    Execute Immediate v_Sql;
  
    If n_Peissystem > 0 Then
      v_Sql := 'Update ' || Peissysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_Peissystem;
      Execute Immediate v_Sql;
    End If;
  
    If n_Opersystem > 0 Then
      v_Sql := 'Update ' || Opersysowner_In || '.zlBakInfo Set 最后转储日期 = Sysdate Where 系统 = ' || n_Opersystem;
      Execute Immediate v_Sql;
    End If;
  
    Update Zldatamovelog
    Set 转出结束时间 = Sysdate, 待转出 = Null, 当前进度 = '转出数据完成,正在重建待转出索引'
    Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  
    If Curtime_In = Totaltime_In Then
      Update zlDataMove
      Set 状态 = Null, 本次最终日期 = Decode(Sign(d_End - 本次最终日期), -1, 本次最终日期, Null)
      Where 系统 = n_System And 组号 = 1;
      Commit;
    End If;
  
    --4.索引重建（以提高下次标记转出查询的速度） 
    ----------------------------------------------------------------------------------- 
    --每次转完后都要重建"待转出"索引，否则影响下一次查询待转出数据的SQL性能
    Zl1_Datamove_Reb(n_System, Speedmode_In, 5);
    If n_Peissystem > 0 Then
      Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 5);
    End If;
    If n_Opersystem > 0 Then
      Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 5);
    End If;
  
    --收缩标记转出查询所需的索引被删除后的空闲空间，下次标记转出时减少范围扫描的数据块 
    --如果每次转完后进行，则耗时较多，所以，可根据查询的耗时来动态决定间隔次数(界面缺省为24次转出后重建一次) 
    Select Nvl(重建索引间隔, 0), Nvl(重建索引范围, 0)
    Into n_重建索引间隔, n_重建索引范围
    From zlDataMove
    Where 系统 = n_System And 组号 = 1;
  
    If Mod(Curtime_In, n_重建索引间隔) = 0 And n_重建索引间隔 <> 0 Then
      Zl1_Datamove_Reb(n_System, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
    
      If n_Peissystem > 0 Then
        Zl1_Datamove_Reb(n_Peissystem, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
      End If;
      If n_Opersystem > 0 Then
        Zl1_Datamove_Reb(n_Opersystem, Speedmode_In, 6, 1, Parallel_In, n_重建索引范围);
      End If;
    End If;
  
    Update Zldatamovelog Set 重建结束时间 = Sysdate, 当前进度 = '完成' Where 系统 = n_System And 批次 = v_当前批次;
    Commit;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    --可能部分数据插入成功，删除操作由于主键或唯一的索引被禁用而失败 
    Rollback;
    Update zlDataMove Set 状态 = Null Where 系统 = n_System And 组号 = 1;
  
    v_Err_Msg := Substr(SQLErrM, 1, 60);
    If Curtime_In = 1 And n_Reset = 0 Then
      Update Zldatamovelog Set 当前进度 = '转出标记出错：' || v_Err_Msg Where 系统 = n_System And 批次 = v_当前批次;
    Else
      Update Zldatamovelog
      Set 当前进度 = '转出出错：' || v_Err_Msg || Substr(v_Sql, 1, 30)
      Where 系统 = n_System And 批次 = v_当前批次;
    End If;
    Commit;
  
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Datamoveout1;
/


--91721:刘尔旋,2016-07-15,自动记账更改
Create Or Replace View 在院病人自动记帐 As
Select p.病人id, p.主页id, i.姓名, i.性别, i.年龄, i.住院号, a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志,
       p.现价 As 标准单价, p.开始日期, p.终止日期, p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, a.开始时间, a.附加床位, a.病区id, a.科室id, a.床号, a.床位等级id, 1 As 数量, a.责任护士, a.经治医师, a.终止时间,
                     a.操作员编号, a.操作员姓名, a.上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where a.开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select a.病人id, a.主页id, 开始时间, 附加床位, a.病区id, a.科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A, 病人信息 B
              Where 开始原因 <> 10 And a.病人id = b.病人id And a.主页id = b.主页id And b.在院 = 1
              Union All
              Select b.病人id, b.主页id, 开始时间, 附加床位, b.病区id, b.科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号,
                     操作员姓名, 上次计算时间
              From 病人变动记录 B, 收费从属项目 I, 病人信息 C
              Where b.护理等级id = i.主项id And b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.开始原因 <> 10 And i.固有从属 > 0) B,
            收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P, 病人信息 C
       Where a.病区id = b.病区id And b.病人id = c.病人id And b.主页id = c.主页id And c.在院 = 1 And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;
/


Create Or Replace View 出院病人自动记帐 As
Select p.病人id, p.主页id, i.姓名, i.性别, i.年龄, i.住院号, a.费别, p.科室id, p.病区id, p.床号, p.附加床位, p.收费细目id, p.收入项目id, 1 As 标志,
       p.现价 As 标准单价, p.开始日期, p.终止日期, p.终止日期 - p.开始日期 As 天数, p.数量, p.经治医师, p.责任护士, p.操作员编号, p.操作员姓名
From 病人信息 I, 病案主页 A,
     (Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 床位等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录 A
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 床位等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.床位等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P
       Where a.病区id = b.病区id And Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.计算标志 = 1 And b.床位等级id = p.收费细目id And Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, b.数量
       From 自动计价项目 A,
            (Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, 护理等级id, 1 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名, 上次计算时间
              From 病人变动记录
              Where 开始原因 <> 10
              Union All
              Select 病人id, 主页id, 开始时间, 附加床位, 病区id, 科室id, 床号, i.从项id As 护理等级id, i.从项数次 As 数量, 责任护士, 经治医师, 终止时间, 操作员编号, 操作员姓名,
                     上次计算时间
              From 病人变动记录 B, 收费从属项目 I
              Where b.护理等级id = i.主项id And b.开始原因 <> 10 And i.固有从属 > 0) B, 收费价目 P, 收费项目目录 C
       Where a.病区id = b.病区id And b.附加床位 <> 1 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And a.计算标志 = 2 And
             b.护理等级id = p.收费细目id And b.护理等级id = c.Id And Nvl(c.计算方式, 0) <> 1 And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))
       Union All
       Select b.病人id, b.主页id, b.科室id, b.病区id, b.床号, b.附加床位, p.收费细目id, p.收入项目id, p.现价, b.经治医师, b.责任护士, b.操作员编号, b.操作员姓名,
              Zl_Date_Half(Greatest(Least(Nvl(b.上次计算时间, b.开始时间), Nvl(b.终止时间, Greatest(Nvl(b.上次计算时间, b.开始时间))),
                                           Greatest(Nvl(b.上次计算时间, b.开始时间))), p.执行日期, Nvl(a.启用日期, Add_Months(Sysdate, -2)))) As 开始日期,
              Zl_Date_Half(Least(Nvl(b.终止时间, Greatest(b.开始时间, Sysdate)), Nvl(p.终止日期, Sysdate + 30) + 1)) As 终止日期, a.数量
       From (Select 病区id, 计算标志, 收费细目id, 1 As 数量, 启用日期
              From 自动计价项目
              Union All
              Select 病区id, 计算标志, 从项id, i.从项数次 As 数量, 启用日期
              From 自动计价项目 A, 收费从属项目 I
              Where a.收费细目id = i.主项id And i.固有从属 > 0) A, 病人变动记录 B, 收费价目 P
       Where a.病区id = b.病区id And b.附加床位 <> 1 And b.开始原因 <> 10 And
             Zl_Date_Half(Nvl(b.上次计算时间, b.开始时间)) <> Zl_Date_Half(Nvl(b.终止时间, Sysdate)) And p.现价 <> 0 And
             a.收费细目id = p.收费细目id And (a.计算标志 = 6 And b.床位等级id Is Not Null Or a.计算标志 = 7) And
             Zl_Date_Half(Nvl(b.终止时间, Sysdate)) >= Zl_Date_Half(p.执行日期) And
             Zl_Date_Half(b.开始时间) <= Zl_Date_Half(Nvl(p.终止日期, Sysdate) + 1) And
             Zl_Date_Half(Least(Nvl(b.终止时间, Sysdate), Nvl(p.终止日期, Sysdate + 30) + 1)) >=
             Zl_Date_Half(Nvl(a.启用日期, Add_Months(Sysdate, -2)))) P
Where i.病人id = p.病人id And a.病人id = p.病人id And a.主页id = p.主页id;
/

--102010:刘尔旋,2016-11-02,撤销出院冲销自动记帐费用问题
Create Or Replace Procedure Zl1_Autocptone
(
  病人id_In   In Number,
  主页id_In   In Number,
  期间_In     In Varchar2,
  在院记帐_In In Number := 0,
  强制记帐_In In Number := 0
) As

  -------------------------------------------------------------------------
  --功能说明：完成指定病人指定期间自动计价项目表设置自动计算的项目进行记帐处理
  --          1、系统首先根据系统参数"修正上期自动计费"，修改以往该病人自动记帐记录标志;
  --          2、综合病人的床位变化、入出转情况、调价情况等多项因素，结合期间跨度、病人费
  --             别等完成费用的正确计算：
  --             如果发现已经计算，则修改标志为正常;如果未计算，则插入新的自动记帐记录;
  --             作废以前的错误计算的记录;
  --             统计本次变动(新增和作废)，填写余额表和汇总表;
  --入口参数：
  --       病人ID_IN  number    病人身份ID
  --       主页ID_IN  number    病案主页ID，两个参数共同确定需要计算的病人
  --       期间_IN  varchar2     需要计算的最小期间
  --       在院记帐_IN number   为1时,仅计算在院病人的费用
  --       强制记帐_IN number   为1时,不受病案主页.禁止自动记帐属性控制
  --调用关系：zl1_AutoCptPati/zl1_AutoCptWard/zl1_AutoCptAll 调用本过程

  Cursor v_Autocur
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select * From 出院病人自动记帐 Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  Cursor v_Autocurzy
  (
    期间_In Varchar2,
    Insure  病案主页.险类%Type
  ) Is
    Select l.病人id, l.主页id, l.姓名, l.性别, l.年龄, l.住院号, l.费别, l.科室id, l.病区id, l.床号, l.附加床位, l.收费细目id, l.收入项目id, l.标志, l.标准单价,
           Greatest(l.开始日期, Trunc(p.开始日期)) As 开始日期, l.终止日期, l.天数, l.数量, l.经治医师, l.责任护士, l.操作员编号, l.操作员姓名, i.险类, i.大类id,
           k.算法, k.统筹比额
    From (Select * From 在院病人自动记帐 Where 病人id = 病人id_In And 主页id = 主页id_In) L,
         (Select Min(开始日期) As 开始日期 From 期间表 Where 期间 >= 期间_In) P, 保险支付项目 I, 保险支付大类 K
    Where Trunc(l.终止日期) >= Trunc(p.开始日期) And l.收费细目id = i.收费细目id(+) And i.险类(+) = Insure And i.大类id = k.Id(+)
    Order By l.开始日期;

  n_Insure       病案主页.险类%Type;
  v_Billno       Varchar2(8); --费用表实际的自动记帐号码
  n_Datecount    Integer; --日期计数器
  d_Datefrom     Date; --开始计算日期
  d_Dateto       Date; --终止计算日期
  d_Datelast     Date;
  n_Billcount    Number(5) := 0; --单据序号计数器
  n_Exsetax      Number(16, 2) := 0; --费用收取比率
  n_Exsetax_Temp Number(16, 2) := 0; --费用收取比率
  n_Summoney     Number(16, 2) := 0; --金额

  Cursor v_Sumcur
  (
    Billno    Varchar2,
    Datestart Date
  ) Is
    Select 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Decode(附加标志, 0, 1, -1) * 应收金额) As 应收金额,
           Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
          (NO = Billno Or 附加标志 = 5 And 发生时间 >= Datestart)
    Group By 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  n_Dec            Number; --金额小数位数
  d_登记时间       Date; --登记时间
  d_发生时间       Date; --发生时间
  n_Dates          Number(3, 1); --当前记录的天数，全天为1
  n_Do             Number(1);
  n_返回值         病人余额.预交余额%Type;
  n_Delete         Number;
  n_医疗小组id     住院费用记录.医疗小组id%Type;
  n_护理计算标准   Number(2); --护理费计算标准
  n_收费细目id     Number(18);
  n_Temp           Number(18);
  l_护理id         t_Numlist := t_Numlist();
  l_护理等级       t_Numlist := t_Numlist();
  n_护理项目       Number(2); --1:是护理项目;0-非不护理
  n_价格           收费价目.现价%Type;
  n_护理已处理     Number(2); --1-护理费已经处理,;0-未处理
  n_收入项目id     Number(18);
  n_从属项目       Number(2);
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  n_禁止自动记帐   Number(2);

  n_病人病区id 住院费用记录.病人病区id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;

  --已经计算了的护理类型
  Type t_护理_Rec Is Record(
    收费细目id 收费项目目录.Id%Type,
    日期       Date);
  Type t_护理 Is Table Of t_护理_Rec;
  c_护理 t_护理 := t_护理();

Begin
  Begin
    Select 险类, Nvl(审核标志, 0), Nvl(状态, 0), Nvl(是否禁止自动记帐, 0)
    Into n_Insure, n_审核标志, n_住院状态, n_禁止自动记帐
    From 病案主页
    Where 病人id = 病人id_In And 主页id = 主页id_In;
  Exception
    When Others Then
      Return;
  End;

  If 强制记帐_In = 0 And n_禁止自动记帐 = 1 Then
    Return;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 And Nvl(n_审核标志, 0) >= 1 Then
    Return;
  End If;
  If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
    Return;
  End If;

  v_Billno := Nextno(17);

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(160), '0'))
  Into n_Dec, n_护理计算标准
  From Dual;

  --每天5点以前，将记录时间登记为昨天，否则登记为当时
  Select Decode(Sign(To_Number(To_Char(Sysdate, 'HH24')) - 5), -1, Trunc(Sysdate) - 1 / 24 / 60, Sysdate)
  Into d_登记时间
  From Dual;

  --锁定该病人的记录,以免重复计算
  Update 病案主页 Set 状态 = 状态 Where 病人id = 病人id_In And 主页id = 主页id_In;

  -----------------------------------------------------------------
  d_Datefrom := Sysdate + 1000;
  d_Dateto   := Sysdate - 1000;
  n_Do       := 0;
  --------------------------------------------------------------------
  If n_护理计算标准 = 1 Then
    --同天以最高价位的护理费为准,先将其护理等级记住,
    For v_护理 In (Select Distinct 护理等级id
                 From (Select 护理等级id
                        From 病人变动记录
                        Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In
                        Union All
                        Select i.从项id As 护理等级id
                        From 病人变动记录 B, 收费从属项目 I
                        Where b.护理等级id = i.主项id And 病人id = 病人id_In And 主页id = 主页id_In And b.开始原因 <> 10 And i.固有从属 > 0)) Loop
      If Nvl(v_护理.护理等级id, 0) <> 0 Then
        l_护理id.Extend;
        l_护理id(l_护理id.Count) := v_护理.护理等级id;
      End If;
    End Loop;
  End If;
  -----------------------------------------------------------------
  --循环检查计算情况，并增加正确和新计算的记录
  -----------------------------------------------------------------
  If 在院记帐_In = 1 Then
    For v_Currrow In v_Autocurzy(期间_In, n_Insure) Loop
    
      n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
    
      If d_Datefrom > v_Currrow.开始日期 Then
        d_Datefrom := v_Currrow.开始日期;
        n_Do       := 1;
        --将本次开始计算时间以后的已计算记录标志修改
        Update 住院费用记录
        Set 附加标志 = 5
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
              发生时间 >= v_Currrow.开始日期;
      End If;
    
      If d_Dateto < v_Currrow.终止日期 Then
        d_Dateto := v_Currrow.终止日期;
      End If;
      n_收费细目id := v_Currrow.收费细目id;
      n_护理项目   := 0;
      --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。
      If n_护理计算标准 = 1 Then
        --先确定是否护理项目,如果是,则需要重新进行计算
        Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
      End If;
    
      --提取当前收入项目的收费比率
      Begin
        Select 实收比率
        Into n_Exsetax
        From (Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
               Union All
               Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
      Exception
        When Others Then
          n_Exsetax := 100.00;
      End;
    
      n_Exsetax := Nvl(n_Exsetax, 100);
      For n_Datecount In 0 .. (Trunc(v_Currrow.终止日期 + 0.5) - Trunc(v_Currrow.开始日期)) - 1 Loop
        d_发生时间   := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                        Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_护理已处理 := 0;
        If n_护理项目 = 1 Then
          --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准)
          n_从属项目 := 1;
          If l_护理等级.Count > 0 Then
            l_护理等级.Delete;
          End If;
          For v_护理 In (Select Distinct 护理等级id
                       From 病人变动记录
                       Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And
                             (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))) Loop
            If Nvl(v_护理.护理等级id, 0) <> 0 Then
              l_护理等级.Extend;
              l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
              If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
                n_从属项目 := 0;
              End If;
            End If;
          End Loop;
          If l_护理等级.Count > 1 Then
            --2. 存在两个以上变动,则取价位最高的
            n_Temp       := v_Currrow.收费细目id;
            n_价格       := Nvl(v_Currrow.标准单价, 0);
            n_收入项目id := v_Currrow.收入项目id;
            --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算
            If Nvl(n_从属项目, 0) = 1 Then
              n_护理已处理 := 1;
            End If;
            --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的
            For I In 1 .. c_护理.Count Loop
              If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
                n_护理已处理 := 1;
                Exit;
              End If;
            End Loop;
            If Nvl(n_护理已处理, 0) = 0 Then
              c_护理.Extend;
              c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
              c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
            End If;
            If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
              --3.处理最高价位
              For v_价位 In (Select /*+ rule */
                            a.Column_Value As 收费细目id, p.现价, p.收入项目id
                           From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                           Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                                 Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1) Loop
                If Nvl(v_价位.现价, 0) > n_价格 Then
                  n_价格       := Nvl(v_价位.现价, 0);
                  n_Temp       := v_价位.收费细目id;
                  n_收入项目id := v_价位.收入项目id;
                End If;
              End Loop;
            
              If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              
                n_开单部门id := v_Currrow.科室id;
                n_病人病区id := v_Currrow.病区id;
              
                For c_变动记录 In (Select 病区id, 科室id
                               From 病人变动记录
                               Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id + 0 = n_Temp And
                                     (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))
                               Order By 开始时间 Desc) Loop
                  n_开单部门id := c_变动记录.科室id;
                  n_病人病区id := c_变动记录.病区id;
                  Exit;
                End Loop;
              
                --4. 不等的话,需要重新处理相关费用
                For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                             From Dual
                             Union All
                             Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                             From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                             Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                   d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate)) Loop
                  --确定比例
                  Begin
                    Select 实收比率
                    Into n_Exsetax_Temp
                    From (Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                           Union All
                           Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                            (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                  Exception
                    When Others Then
                      n_Exsetax_Temp := 100.00;
                  End;
                  n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                  --如果已经计算，原记录计算完全正确，则直接修改将标志改正
                  Update 住院费用记录
                  Set 附加标志 = 0
                  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                        病人科室id = Nvl(n_开单部门id, 0) And 病人病区id = Nvl(n_病人病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                        收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And 发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And
                        标准单价 = v_费用.单价 And 应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                        实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
                
                  If Sql%RowCount = 0 Then
                    --如果未计算或计算错误，则增加正确的计算记录
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                       姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                       收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                      Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                             Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, n_病人病区id, n_开单部门id,
                             n_开单部门id, n_病人病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                             v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1, v_费用.数量 * n_Dates,
                             Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                             Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                             j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                             Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                             Decode(v_Currrow.算法, 1,
                                     Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                     v_Currrow.统筹比额, 0), n_医疗小组id
                      From (Select 类别, 计算单位
                             From 收费细目
                             Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                           (Select 收据费目
                             From 收入项目
                             Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                    n_Billcount := n_Billcount + Sql%RowCount;
                  End If;
                  n_护理已处理 := 1;
                End Loop;
              End If;
            End If;
          End If;
        End If;
      
        If Nvl(n_护理已处理, 0) = 0 Then
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And 发生时间 = d_发生时间 And
                数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
                应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
                实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录\
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                     v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号,
                     v_Currrow.床号, v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1,
                     v_Currrow.数量 * n_Dates, Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                     Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位,
                     v_Currrow.附加床位, j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间,
                     d_登记时间, Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                     Decode(v_Currrow.算法, 1,
                             Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                             2, v_Currrow.统筹比额, 0), n_医疗小组id
              From (Select 类别, 计算单位
                     From 收费细目
                     Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                   (Select 收据费目
                     From 收入项目
                     Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
          
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End If;
      End Loop;
    End Loop;
  Else
    For v_Currrow In v_Autocur(期间_In, n_Insure) Loop
    
      n_医疗小组id := Zl_医疗小组_Get(v_Currrow.科室id, v_Currrow.操作员姓名, v_Currrow.病人id, v_Currrow.主页id, d_发生时间);
    
      If d_Datefrom > v_Currrow.开始日期 Then
        d_Datefrom := v_Currrow.开始日期;
        n_Do       := 1;
        --将本次开始计算时间以后的已计算记录标志修改
        Update 住院费用记录
        Set 附加标志 = 5
        Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
              发生时间 >= v_Currrow.开始日期;
      End If;
    
      If d_Dateto < v_Currrow.终止日期 Then
        d_Dateto := v_Currrow.终止日期;
      End If;
      n_收费细目id := v_Currrow.收费细目id;
      n_护理项目   := 0;
      --护理费计算标准:0-按最后一次护理计算;1-按价格最高的护理等级计算。
      If n_护理计算标准 = 1 Then
        --先确定是否护理项目,如果是,则需要重新进行计算
        Select Count(*) Into n_护理项目 From Table(l_护理id) Where Column_Value = n_收费细目id;
      End If;
    
      --提取当前收入项目的收费比率
      Begin
        Select 实收比率
        Into n_Exsetax
        From (Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值)
               Union All
               Select 实收比率
               From 费别明细
               Where 费别 = v_Currrow.费别 And 收入项目id = v_Currrow.收入项目id And
                     (Abs(v_Currrow.标准单价 * v_Currrow.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_Currrow.收费细目id));
      Exception
        When Others Then
          n_Exsetax := 100.00;
      End;
    
      n_Exsetax := Nvl(n_Exsetax, 100);
      For n_Datecount In 0 .. (Trunc(v_Currrow.终止日期 + 0.5) - Trunc(v_Currrow.开始日期)) - 1 Loop
        d_发生时间   := Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_Dates      := Least(Trunc(v_Currrow.开始日期 + n_Datecount + 1), v_Currrow.终止日期) -
                        Greatest(v_Currrow.开始日期, Trunc(v_Currrow.开始日期 + n_Datecount));
        n_护理已处理 := 0;
        If n_护理项目 = 1 Then
          --1.先检查当天是否存在护理变动,只有存在多个护理变动的,才会去处理(以主项目为准)
          n_从属项目 := 1;
          If l_护理等级.Count > 0 Then
            l_护理等级.Delete;
          End If;
          For v_护理 In (Select Distinct 护理等级id
                       From 病人变动记录
                       Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And
                             (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))) Loop
            If Nvl(v_护理.护理等级id, 0) <> 0 Then
              l_护理等级.Extend;
              l_护理等级(l_护理等级.Count) := v_护理.护理等级id;
              If Nvl(v_护理.护理等级id, 0) = Nvl(v_Currrow.收费细目id, 0) Then
                n_从属项目 := 0;
              End If;
            End If;
          End Loop;
          If l_护理等级.Count > 1 Then
            --2. 存在两个以上变动,则取价位最高的
            n_Temp       := v_Currrow.收费细目id;
            n_价格       := Nvl(v_Currrow.标准单价, 0);
            n_收入项目id := v_Currrow.收入项目id;
            --本身是从属项目时,由于主项目计算时,已经计算了的,所以就不再计算
            If Nvl(n_从属项目, 0) = 1 Then
              n_护理已处理 := 1;
            End If;
            --因为可能存在多个收入项目,但收费细目相同的情况,因此,必须先检查该项目是否已经参与计算过的
            For I In 1 .. c_护理.Count Loop
              If c_护理(I).收费细目id = v_Currrow.收费细目id And c_护理(I).日期 = Trunc(d_发生时间) Then
                n_护理已处理 := 1;
                Exit;
              End If;
            End Loop;
            If Nvl(n_护理已处理, 0) = 0 Then
              c_护理.Extend;
              c_护理(c_护理.Count).收费细目id := v_Currrow.收费细目id;
              c_护理(c_护理.Count).日期 := Trunc(d_发生时间);
            End If;
            If Nvl(n_从属项目, 0) = 0 And Nvl(n_护理已处理, 0) = 0 Then
              --3.处理最高价位
              For v_价位 In (Select /*+ rule */
                            a.Column_Value As 收费细目id, p.现价, p.收入项目id
                           From Table(l_护理等级) A, 收费价目 P, 收费项目目录 C
                           Where a.Column_Value = p.收费细目id And a.Column_Value = c.Id And d_发生时间 Between p.执行日期 And
                                 Nvl(p.终止日期, Sysdate) And Nvl(c.计算方式, 0) <> 1) Loop
                If Nvl(v_价位.现价, 0) > n_价格 Then
                  n_价格       := Nvl(v_价位.现价, 0);
                  n_Temp       := v_价位.收费细目id;
                  n_收入项目id := v_价位.收入项目id;
                End If;
              End Loop;
            
              If n_Temp <> v_Currrow.收费细目id And Nvl(n_护理已处理, 0) = 0 Then
              
                n_开单部门id := v_Currrow.科室id;
                n_病人病区id := v_Currrow.病区id;
              
                For c_变动记录 In (Select 病区id, 科室id
                               From 病人变动记录
                               Where 开始原因 <> 10 And 病人id = 病人id_In And 主页id = 主页id_In And 护理等级id + 0 = n_Temp And
                                     (Trunc(开始时间) = Trunc(d_发生时间) Or Trunc(Nvl(终止时间, Sysdate)) = Trunc(d_发生时间))
                               Order By 开始时间 Desc) Loop
                  n_开单部门id := c_变动记录.科室id;
                  n_病人病区id := c_变动记录.病区id;
                  Exit;
                End Loop;
              
                --4. 不等的话,需要重新处理相关费用
                For v_费用 In (Select n_Temp As 收费细目id, v_Currrow.数量 As 数量, n_价格 As 单价, n_收入项目id As 收入项目id
                             From Dual
                             Union All
                             Select 从项id As 收费细目id, a.从项数次 As 数量, p.现价 As 单价, p.收入项目id
                             From 收费从属项目 A, 收费价目 P, 收费项目目录 C
                             Where a.从项id = p.收费细目id And a.从项id = c.Id And Nvl(c.计算方式, 0) <> 1 And a.主项id = n_Temp And
                                   d_发生时间 Between p.执行日期 And Nvl(p.终止日期, Sysdate)) Loop
                  --确定比例
                  Begin
                    Select 实收比率
                    Into n_Exsetax_Temp
                    From (Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值)
                           Union All
                           Select 实收比率
                           From 费别明细
                           Where 费别 = v_Currrow.费别 And 收入项目id = v_费用.收入项目id And
                                 (Abs(v_费用.单价 * v_费用.数量) Between 应收段首值 And 应收段尾值) And Not Exists
                            (Select 1 From 费别明细 Where 费别 = v_Currrow.费别 And 收费细目id = v_费用.收费细目id));
                  Exception
                    When Others Then
                      n_Exsetax_Temp := 100.00;
                  End;
                  n_Exsetax_Temp := Nvl(n_Exsetax_Temp, 100);
                  --如果已经计算，原记录计算完全正确，则直接修改将标志改正
                  Update 住院费用记录
                  Set 附加标志 = 0
                  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                        病人科室id = Nvl(n_开单部门id, 0) And 病人病区id = Nvl(n_病人病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                        收费细目id = v_费用.收费细目id And 收入项目id = v_费用.收入项目id And 发生时间 = d_发生时间 And 数次 = v_费用.数量 * n_Dates And
                        标准单价 = v_费用.单价 And 应收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec) And
                        实收金额 = Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec);
                
                  If Sql%RowCount = 0 Then
                    --如果未计算或计算错误，则增加正确的计算记录
                    Insert Into 住院费用记录
                      (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
                       姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志,
                       收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
                      Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                             Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, n_病人病区id, n_开单部门id,
                             n_开单部门id, n_病人病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号, v_Currrow.床号,
                             v_Currrow.费别, 1, v_费用.收费细目id, v_费用.收入项目id, 0, v_费用.单价, 1, v_费用.数量 * n_Dates,
                             Round(v_费用.单价 * v_费用.数量 * n_Dates, n_Dec),
                             Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位, v_Currrow.附加床位,
                             j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间, d_登记时间,
                             Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                             Decode(v_Currrow.算法, 1,
                                     Round(v_费用.单价 * v_费用.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec), 2,
                                     v_Currrow.统筹比额, 0), n_医疗小组id
                      From (Select 类别, 计算单位
                             From 收费细目
                             Where ID = v_费用.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                           (Select 收据费目
                             From 收入项目
                             Where ID = v_费用.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
                    n_Billcount := n_Billcount + Sql%RowCount;
                  End If;
                  n_护理已处理 := 1;
                End Loop;
              End If;
            End If;
          End If;
        End If;
      
        If Nvl(n_护理已处理, 0) = 0 Then
          --如果已经计算，原记录计算完全正确，则直接修改将标志改正
          Update 住院费用记录
          Set 附加标志 = 0
          Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And Nvl(加班标志, 0) = v_Currrow.附加床位 And
                病人科室id = v_Currrow.科室id And 病人病区id = Nvl(v_Currrow.病区id, 0) And Nvl(床号, 0) = Nvl(v_Currrow.床号, 0) And
                收费细目id = v_Currrow.收费细目id And 收入项目id = v_Currrow.收入项目id And 发生时间 = d_发生时间 And
                数次 = v_Currrow.数量 * n_Dates And 标准单价 = v_Currrow.标准单价 And
                应收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec) And
                实收金额 = Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec);
        
          If Sql%RowCount = 0 Then
            --如果未计算或计算错误，则增加正确的计算记录\
            Insert Into 住院费用记录
              (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别,
               年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人,
               操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
              Select 病人费用记录_Id.Nextval, 3, v_Billno, 1, Rownum + n_Billcount, Null, Null, 0, Null,
                     Decode(v_Currrow.主页id, Null, 1, 2), v_Currrow.病人id, v_Currrow.主页id, v_Currrow.病区id, v_Currrow.科室id,
                     v_Currrow.科室id, v_Currrow.病区id, v_Currrow.姓名, v_Currrow.性别, v_Currrow.年龄, v_Currrow.住院号,
                     v_Currrow.床号, v_Currrow.费别, 1, v_Currrow.收费细目id, v_Currrow.收入项目id, 0, v_Currrow.标准单价, 1,
                     v_Currrow.数量 * n_Dates, Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates, n_Dec),
                     Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100, n_Dec), i.类别, i.计算单位,
                     v_Currrow.附加床位, j.收据费目, v_Currrow.经治医师, v_Currrow.责任护士, v_Currrow.操作员编号, v_Currrow.操作员姓名, d_发生时间,
                     d_登记时间, Decode(v_Currrow.险类, Null, 0, 1), v_Currrow.大类id,
                     Decode(v_Currrow.算法, 1,
                             Round(v_Currrow.标准单价 * v_Currrow.数量 * n_Dates * n_Exsetax / 100 * v_Currrow.统筹比额 / 100, n_Dec),
                             2, v_Currrow.统筹比额, 0), n_医疗小组id
              From (Select 类别, 计算单位
                     From 收费细目
                     Where ID = v_Currrow.收费细目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) I,
                   (Select 收据费目
                     From 收入项目
                     Where ID = v_Currrow.收入项目id And (撤档时间 Is Null Or 撤档时间 > d_发生时间)) J;
          
            n_Billcount := n_Billcount + Sql%RowCount;
          End If;
        End If;
      End Loop;
    End Loop;
  End If;
  If n_Do = 0 Then
    --撤销出院后,如果修改出院时间为入院当天则不产生新费用,但以前的费用要冲销
    Begin
      Select Trunc(Nvl(b.上次计算时间,b.终止时间))
      Into d_Datelast
      From 病人变动记录 A, 病人变动记录 B
      Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.终止原因 = 1 And a.病人id = b.病人id And a.主页id = b.主页id And b.开始原因 = 1 And
            Trunc(b.开始时间) = Trunc(a.终止时间) And a.附加床位 = 0 And b.附加床位 = 0;
    Exception
      When Others Then
        Null;
    End;
    If d_Datelast Is Not Null Then
      d_Datefrom := d_Datelast;
      d_Dateto   := Sysdate;
      Update 住院费用记录
      Set 附加标志 = 5
      Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 <> 8 And Nvl(医嘱序号, 0) = 0 And
            发生时间 >= d_Datefrom;
    End If;
  End If;

  -----------------------------------------------------------------
  --作废以前计算的错误记录
  -----------------------------------------------------------------
  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 姓名, 性别, 年龄, 标识号,
     床号, 费别, 记帐费用, 收费细目id, 收入项目id, 附加标志, 标准单价, 付数, 数次, 应收金额, 实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人, 划价人, 操作员编号, 操作员姓名, 发生时间,
     登记时间, 保险项目否, 保险大类id, 统筹金额, 医疗小组id)
    Select 病人费用记录_Id.Nextval, 记录性质, NO, 2, 序号, 从属父号, 价格父号, 多病人单, 医嘱序号, 门诊标志, 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id,
           姓名, 性别, 年龄, 标识号, 床号, 费别, 记帐费用, 收费细目id, 收入项目id, 0, 标准单价, 付数, -数次, -应收金额, -实收金额, 收费类别, 计算单位, 加班标志, 收据费目, 开单人,
           划价人, 操作员编号, 操作员姓名, 发生时间, d_登记时间, 保险项目否, 保险大类id, -统筹金额, 医疗小组id
    From 住院费用记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --填写病人余额
  -----------------------------------------------------------------
  Select Sum(Decode(附加标志, 0, 1, -1) * 实收金额) As 实收金额
  Into n_Summoney
  From 住院费用记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And
        (NO = v_Billno Or 附加标志 = 5 And 发生时间 >= d_Datefrom);

  Update 病人余额
  Set 费用余额 = Nvl(费用余额, 0) + Nvl(n_Summoney, 0)
  Where 病人id = 病人id_In And 性质 = 1 And 类型 = 2
  Returning 费用余额 Into n_返回值;

  If Sql%RowCount = 0 Then
    Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 2, n_Summoney, 0);
    n_返回值 := n_Summoney;
  End If;

  If Nvl(n_返回值, 0) = 0 Then
    Delete From 病人余额 Where 性质 = 1 And 病人id = 病人id_In And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
  End If;

  -----------------------------------------------------------------
  --填写病人汇总费用
  -----------------------------------------------------------------
  n_Delete := 0;
  For v_Currrow In v_Sumcur(v_Billno, d_Datefrom) Loop
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(v_Currrow.实收金额, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(v_Currrow.病人病区id, 0) And
          Nvl(病人科室id, 0) = Nvl(v_Currrow.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(v_Currrow.开单部门id, 0) And
          Nvl(执行部门id, 0) = Nvl(v_Currrow.执行部门id, 0) And Nvl(收入项目id, 0) = Nvl(v_Currrow.收入项目id, 0) And 来源途径 + 0 = 2
    Returning 金额 Into n_返回值;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, v_Currrow.病人病区id, v_Currrow.病人科室id, v_Currrow.开单部门id, v_Currrow.执行部门id, v_Currrow.收入项目id, 2,
         v_Currrow.实收金额);
      n_返回值 := v_Currrow.实收金额;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      n_Delete := 1;
    End If;
  End Loop;

  If Nvl(n_Delete, 0) = 1 Then
    Delete From 病人未结费用 Where 病人id = 病人id_In And 金额 = 0;
  End If;

  -----------------------------------------------------------------
  --将所有修改的附加标志还原为正常标志
  -----------------------------------------------------------------
  Update 住院费用记录
  Set 附加标志 = 0, 记录状态 = 3
  Where 病人id = 病人id_In And 主页id = 主页id_In And 记录性质 = 3 And 记录状态 = 1 And 附加标志 = 5 And 发生时间 >= d_Datefrom;

  -----------------------------------------------------------------
  --修改计算时间标志
  -----------------------------------------------------------------
  Update 病人变动记录
  Set 上次计算时间 = Least(d_Dateto, Nvl(终止时间, Greatest(开始时间, Sysdate)))
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(终止时间, Sysdate) > d_Datefrom;
  Commit; --单个病人提交
End Zl1_Autocptone;
/

Create Or Replace Procedure Zl1_Autocptall(强制记帐_In In Number := 0) As
  Modilast Number(1); --是否修正上期自动计费参数
  Period   Varchar2(6); --需要计算的最小期间
  Cursor Patitab Is
    Select Distinct 病人id, 主页id
    From 在院病人自动记帐
    Where Trunc(终止日期) >= (Select Min(开始日期) From 期间表 Where 期间 >= Period);
Begin
  If f_Is_Primary_Node = 0 Then
    Return;
  End If;
  Begin
    Select 期间 Into Period From 期间表 Where Trunc(Sysdate) - 1 Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;
  Select zl_GetSysParameter(7) Into Modilast From Dual;

  If Modilast = 1 Then
    Period := To_Char(Add_Months(To_Date(Period || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;

  For Patifld In Patitab Loop
    If Patifld.病人id Is Not Null And Patifld.主页id Is Not Null Then
      Zl1_Autocptone(Patifld.病人id, Patifld.主页id, Period, 1, 强制记帐_In);
      Commit;
    End If;
  End Loop;
End Zl1_Autocptall;
/

Create Or Replace Procedure Zl1_Autocptward
(
  Wardid      In Number,
  Recalcbdate In 病人变动记录.上次计算时间%Type := Null,
  强制记帐_In In Number := 0
) As
  Modilast Number(1); --是否修正上期自动计费参数
  Period   Varchar2(6); --需要计算的最小期间

  Cursor Patitab Is
    Select Distinct 病人id, 主页id
    From 在院病人自动记帐
    Where 病区id = Wardid And Trunc(终止日期) >= (Select Min(开始日期) From 期间表 Where 期间 >= Period);
Begin
  Begin
    Select 期间 Into Period From 期间表 Where Trunc(Sysdate) - 1 Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;
  Select zl_GetSysParameter(7) Into Modilast From Dual;

  If Modilast = 1 Then
    Period := To_Char(Add_Months(To_Date(Period || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;

  If Recalcbdate Is Not Null Then
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where (病人id, 主页id) In (Select 病人id, 主页id From 病案主页 Where 当前病区id = Wardid And 出院日期 Is Null) And
          上次计算时间 >= Recalcbdate;
    Commit;
  End If;

  For Patifld In Patitab Loop
    If Patifld.病人id Is Not Null And Patifld.主页id Is Not Null Then
      Zl1_Autocptone(Patifld.病人id, Patifld.主页id, Period, 1, 强制记帐_In);
      Commit;
    End If;
  End Loop;
End Zl1_Autocptward;
/

Create Or Replace Procedure Zl1_Autocptpati
(
  Patiid      In Number,
  Pageid      In Number,
  Recalcbdate In 病人变动记录.上次计算时间%Type := Null,
  强制记帐_In In Number := 0
) As
  Modilast Number(1); --是否修正上期自动计费参数
  Period   Varchar2(6); --需要计算的最小期间
Begin
  Begin
    Select 期间 Into Period From 期间表 Where Trunc(Sysdate) Between Trunc(开始日期) And Trunc(终止日期);
  Exception
    When Others Then
      Return;
  End;

  Select Zl_To_Number(zl_GetSysParameter(7)) Into Modilast From Dual;

  If Modilast = 1 Then
    Period := To_Char(Add_Months(To_Date(Period || '05', 'yyyymmdd'), -1), 'yyyymm');
  End If;

  If Recalcbdate Is Not Null Then
    Update 病人变动记录
    Set 上次计算时间 = Null
    Where 病人id = Patiid And 主页id = Pageid And 上次计算时间 >= Recalcbdate;
    Commit;
  End If;

  Zl1_Autocptone(Patiid, Pageid, Period, 0, 强制记帐_In);
  Commit;
End Zl1_Autocptpati;
/

Create Or Replace Procedure Zl_病人自动记帐_Stop
(
  病人id_In   病人信息.病人id%Type,
  住院次数_In Varchar2
) As
  v_Temp  Varchar2(255);
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  Update 病案主页
  Set 是否禁止自动记帐 = 1
  Where 病人id = 病人id_In And 主页id In (Select Column_Value From Table(f_Str2list(住院次数_In))) And 病人性质 = 0;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人自动记帐_Stop;
/

Create Or Replace Procedure Zl_病人自动记帐_Restore(No_In 病人结帐记录.No%Type) As
  n_病人id   病人结帐记录.病人id%Type;
  v_住院次数 Varchar2(500);
  n_结帐id   病人结帐记录.Id%Type;
  v_Temp     Varchar2(255);
  v_Error    Varchar2(255);
  Err_Custom Exception;
Begin
  Begin
    Select 病人id, ID
    Into n_病人id, n_结帐id
    From 病人结帐记录
    Where NO = No_In And 记录状态 = 3 And 结帐类型 = 2 And 中途结帐 = 0;
    For r_住院 In (Select Distinct 主页id From 住院费用记录 Where 结帐id = n_结帐id) Loop
      If Instr(',' || v_住院次数 || ',', ',' || r_住院.主页id || ',') = 0 Then
        v_住院次数 := v_住院次数 || ',' || r_住院.主页id;
      End If;
    End Loop;
  Exception
    When Others Then
      n_病人id   := Null;
      v_住院次数 := Null;
  End;
  If v_住院次数 Is Not Null Then
    v_住院次数 := Substr(v_住院次数, 2);
    Update 病案主页
    Set 是否禁止自动记帐 = 0
    Where 病人id = n_病人id And 主页id In (Select Column_Value From Table(f_Str2list(v_住院次数))) And 病人性质 = 0;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人自动记帐_Restore;
/


--99934:刘尔旋,2016-08-29,门诊转住院记录性质问题
--98536:刘尔旋,2016-07-13,门诊转住院原始预交记录状态问题
Create Or Replace Procedure Zl_门诊转住院_收费转出
(
  No_In         住院费用记录.No%Type,
  操作员编号_In 住院费用记录.操作员编号%Type,
  操作员姓名_In 住院费用记录.操作员姓名%Type,
  退费时间_In   住院费用记录.发生时间%Type,
  门诊退费_In   Number := 0,
  入院科室id_In 住院费用记录.开单部门id%Type := Null,
  主页id_In     住院费用记录.主页id%Type := Null,
  结算方式_In   病人预交记录.结算方式%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  原结帐id_In   病人预交记录.结帐id%Type := Null,
  误差费_In     病人预交记录.冲预交%Type := Null
) As
  --门诊退费_In:0-门诊转住院立即销帐;1-门诊退费模式
  -- 门诊退费_In为1时:入院科室id_In和主页ID_IN可以不传入
  n_Count      Number(5);
  n_原结帐id   住院费用记录.结帐id%Type;
  n_实收金额   门诊费用记录.实收金额%Type;
  n_预交使用额 病人预交记录.冲预交%Type;
  n_实际冲销   病人预交记录.冲预交%Type;
  n_组id       财务缴款分组.Id%Type;
  n_病人id     病人信息.病人id%Type;
  v_预交no     病人预交记录.No%Type;
  n_预交金额   病人预交记录.冲预交%Type;
  n_打印id     票据使用明细.打印id%Type;
  n_开单部门id 住院费用记录.开单部门id%Type;
  v_开单人     门诊费用记录.开单人%Type;
  n_结帐id     门诊费用记录.结帐id%Type;
  n_误差费     病人预交记录.冲预交%Type;
  v_误差费     结算方式.名称%Type;
  n_返回值     病人余额.费用余额%Type;
  v_结算方式   结算方式.名称%Type;
  v_Nos        Varchar2(3000);
  v_结帐ids    Varchar2(3000);
  v_原结帐ids  Varchar2(3000);
  n_Tempid     病人预交记录.Id%Type;
  n_预交id     病人预交记录.Id%Type;
  n_医保       Number;
  n_存在       Number;
  n_退现       Number;
  n_部分退费   Number;
  n_退费条数   Number;
  n_异常标志   Number;
  n_计算误差   Number;
  n_费用状态   门诊费用记录.费用状态%Type;

  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  Procedure Zl_Square_Update
  (
    结帐ids_In    Varchar2,
    现结帐id_In   病人预交记录.结帐id%Type,
    缴款组id_In   病人预交记录.缴款组id%Type,
    退款时间_In   病人预交记录.收款时间%Type,
    结算序号_In   病人预交记录.结算序号%Type,
    结算内容_In   Varchar2 := Null,
    退费金额_In   病人预交记录.冲预交%Type := Null,
    结算卡序号_In 病人预交记录.结算卡序号%Type := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select Min(a.Id) As 预交id, c.消费卡id, Sum(c.结算金额) As 结算金额, c.接口编号, c.卡号, Max(c.序号) As 序号, Max(c.Id) As ID
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And a.结算卡序号 = 结算卡序号_In And b.卡结算id = c.Id And a.记录性质 = 3 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And
                       a.结帐id In (Select Column_Value From Table(f_Str2list(结帐ids_In)))
                 Group By c.消费卡id, c.接口编号, c.卡号) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 退费金额_In, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位, 2, 结算序号_In,
                 结算性质
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + 退费金额_In Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * 退费金额_In, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --误差费
  Begin
    Select 名称 Into v_误差费 From 结算方式 Where 性质 = 9 And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '没有发现误差结算方式，请检查是否正确设置！';
      Raise Err_Item;
  End;

  If 原结帐id_In Is Null Then
  
    Select Count(NO), Sum(实收金额) Into n_Count, n_实收金额 From 门诊费用记录 Where NO = No_In And 记录性质 = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '单据' || No_In || '不是收费单据或因并发原因他人操作了该单据,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
  
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id,
             收费类别, 收费细目id, 计算单位, 付数, 发药窗口, -1 * 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, -1 * 应收金额, -1 * 实收金额, 开单部门id,
             开单人, 执行部门id, 划价人, 执行人, -1, 执行时间, 操作员编号_In, 操作员姓名_In, 发生时间, 退费时间_In, n_结帐id, -1 * 结帐金额, 保险项目否, 保险大类id, 统筹金额,
             摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, n_组id, 0
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
    --1.2作废预交记录
    --作废冲预交部分
    For r_结账id In (Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select 结帐id
                                               From 病人预交记录
                                               Where 结算序号 In (Select b.结算序号
                                                              From 门诊费用记录 A, 病人预交记录 B
                                                              Where a.No = No_In And b.结算序号 < 0 And Mod(a.记录性质, 10) = 1 And
                                                                    a.记录状态 <> 0 And a.结帐id = b.结帐id))) And
                         Mod(记录性质, 10) = 1 And 记录状态 <> 0
                   Union
                   Select Distinct 结帐id
                   From 门诊费用记录
                   Where NO In (Select Distinct NO
                                From 门诊费用记录
                                Where 结帐id In (Select a.结帐id
                                               From 门诊费用记录 A, 病人预交记录 B
                                               Where a.No = No_In And b.结算序号 > 0 And Mod(a.记录性质, 10) = 1 And a.记录状态 <> 0 And
                                                     a.结帐id = b.结帐id)) And Mod(记录性质, 10) = 1 And 记录状态 <> 0) Loop
      v_原结帐ids := v_原结帐ids || ',' || r_结账id.结帐id;
    End Loop;
    v_原结帐ids := Substr(v_原结帐ids, 2);
  
    Begin
      Select 1
      Into n_医保
      From 保险结算记录
      Where 记录id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        n_医保 := 0;
    End;
  
    If n_医保 = 1 Then
      Begin
        Select 1
        Into n_存在
        From 医保结算明细
        Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And Rownum < 2;
      Exception
        When Others Then
          v_Err_Msg := '当前单据' || No_In || '不存在医保结算明细,无法进行门诊转住院!';
          Raise Err_Item;
      End;
    End If;
  
    --医保退款
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO = No_In And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_医保.金额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_医保.结算方式, 1, -1 * r_医保.金额);
        n_返回值 := r_医保.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_医保.结算方式 And Nvl(余额, 0) = 0;
      End If;
    
      Update 病人预交记录
      Set 冲预交 = 冲预交 + (-1 * r_医保.金额)
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_医保.金额, r_医保.结算方式, Null, 退费时间_In,
           Null, Null, Null, 操作员编号_In, 操作员姓名_In, r_医保.备注, n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id,
           0, 3);
      End If;
    
      Update 病人预交记录
      Set 记录状态 = 3
      Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
            结算方式 = r_医保.结算方式;
    
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = No_In And 结帐id = n_结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (n_结帐id, No_In, r_医保.结算方式, -1 * r_医保.金额);
      End If;
      n_实收金额 := n_实收金额 - r_医保.金额;
    End Loop;
  
    Begin
      Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
    Exception
      When Others Then
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
    End;
  
    If n_实收金额 <> 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号,
                              卡号, 交易流水号, 交易说明, 合作单位
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids)))
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 卡类别id, 结算卡序号, 卡号,
                                交易流水号, 交易说明, 合作单位) Loop
        If n_实收金额 <> 0 Then
          If r_Prepay.冲预交 >= n_实收金额 Then
            Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 缴款组id)
              Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                     r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                     操作员编号_In, -1 * n_实收金额, n_结帐id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                     r_Prepay.交易说明, r_Prepay.合作单位, 1, -1 * n_结帐id, n_组id
              From Dual;
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_实收金额, 0)
            Where 病人id = n_病人id And 类型 = 1 And 性质 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_实收金额, 1);
              n_返回值 := n_实收金额;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
            n_实收金额 := 0;
          Else
            Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
               冲预交, 结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 预交类别, 结算序号, 缴款组id)
              Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                     r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                     操作员编号_In, -1 * r_Prepay.冲预交, n_结帐id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                     r_Prepay.交易说明, r_Prepay.合作单位, 1, -1 * n_结帐id, n_组id
              From Dual;
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + Nvl(r_Prepay.冲预交, 0)
            Where 病人id = n_病人id And 类型 = 1 And 性质 = 1
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, r_Prepay.冲预交, 1);
              n_返回值 := r_Prepay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
            n_实收金额 := n_实收金额 - r_Prepay.冲预交;
          End If;
        End If;
      End Loop;
    End If;
    --2.票据收回
    --可能以前没有打印,无收回
    Select Nvl(Max(ID), 0)
    Into n_打印id
    From (Select b.Id
           From 票据使用明细 A, 票据打印内容 B
           Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
           Order By a.使用时间 Desc)
    Where Rownum < 2;
    If n_打印id > 0 Then
      --多张单据循环调用时只能收回一次
      Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      End If;
    End If;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                         a.结算方式 = b.名称 And b.性质 In (1, 2, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0
                   Order By a.卡类别id, 性质 Desc) Loop
        If n_实收金额 <> 0 Then
          Begin
            Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
          Exception
            When Others Then
              n_退现 := 0;
          End;
          If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
            If c_预交.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_费用状态 := 1;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = c_预交.结算方式;
              n_费用状态 := 1;
              n_实收金额 := n_实收金额 - c_预交.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
              v_结算方式 := c_预交.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
              If n_实收金额 >= c_预交.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id, Null, Null, Null, Null, Null, Null,
                     n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := c_预交.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, c_预交.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If c_预交.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := c_预交.冲预交;
              End If;
            End If;
          
            If c_预交.结算卡序号 Is Null Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, v_结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
              End If;
            
              --退原预交记录
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                   -1 * n_结帐id, 0, 3);
              End If;
            End If;
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = c_预交.结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select ID From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
      For r_Clinic In (Select 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型,
                              发药窗口, 付数, Sum(数次) As 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, Sum(应收金额) As 应收金额,
                              Sum(实收金额) As 实收金额, Sum(统筹金额) As 统筹金额, 开单部门id, 开单人, 执行部门id, 划价人, Max(记帐单id) As 记帐单id, 发生时间,
                              实际票号
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (2, 3) And Nvl(附加标志, 0) Not In (8, 9)
                       Group By 序号, 从属父号, 价格父号, 病人id, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 保险编码,
                                费用类型, 发药窗口, 付数, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 开单部门id, 开单人, 执行部门id, 划价人, 发生时间, 实际票号
                       Having Sum(数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 缴款组id, 结帐id, 结帐金额, 费用状态)
        Values
          (病人费用记录_Id.Nextval, 1, No_In, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号, 1, r_Clinic.病人id,
           '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别, r_Clinic.收费细目id,
           r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口, r_Clinic.付数,
           -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, 0);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                          a.结算方式 = b.名称 And (b.性质 In (1, 2, 7, 8)) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    
                    Having Sum(a.冲预交) <> 0
                    Order By a.卡类别id, 性质 Desc) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If n_实收金额 <> 0 Then
          If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
            If r_Pay.冲预交 > n_实收金额 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * n_实收金额 || '|', n_组id,
                   Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_费用状态 := 1;
              n_实收金额 := 0;
            Else
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|',
                   n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
              End If;
            
              Update 病人预交记录
              Set 记录状态 = 3
              Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                    结算方式 = r_Pay.结算方式;
              n_费用状态 := 1;
              n_实收金额 := n_实收金额 - r_Pay.冲预交;
            End If;
          Else
            n_实际冲销 := 0;
            If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
              v_结算方式 := r_Pay.结算方式;
            Else
              If 结算方式_In Is Null Then
                Begin
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
                Exception
                  When Others Then
                    Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
                End;
              Else
                v_结算方式 := 结算方式_In;
              End If;
            End If;
          
            If r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null Then
              If n_实收金额 >= r_Pay.冲预交 Then
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null,
                     退费时间_In, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
                     '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id, Null, Null, Null, Null, Null,
                     Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := r_Pay.冲预交;
              Else
                --Zl_Square_Update(v_原结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, n_实收金额, r_Pay.结算卡序号);
                Update 病人预交记录
                Set 冲预交 = 冲预交 + (-1 * n_实收金额), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|'
                Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
                If Sql%RowCount = 0 Then
                  Insert Into 病人预交记录
                    (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                     摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
                  Values
                    (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实收金额, Null, Null, 退费时间_In,
                     Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * n_实收金额 || '|', n_组id,
                     Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
                End If;
                n_费用状态 := 1;
                n_实际冲销 := n_实收金额;
              End If;
            Else
              If r_Pay.冲预交 > n_实收金额 Then
                n_实际冲销 := n_实收金额;
              Else
                n_实际冲销 := r_Pay.冲预交;
              End If;
            End If;
          
            If r_Pay.性质 Not In (3, 4, 7, 8) Then
              Update 病人预交记录
              Set 金额 = 金额 + n_实际冲销
              Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                v_预交no := Nextno(11);
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 预交类别)
                Values
                  (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
              End If;
            
              --病人余额
              Update 病人余额
              Set 预交余额 = Nvl(预交余额, 0) + n_实际冲销
              Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
              Returning 预交余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, n_实际冲销, 0);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 病人余额
                Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
              End If;
            End If;
            --4.2缴款数据处理
            --   因为没有实际收病人的钱,所以不处理
            --部分退费情况，退原预交记录
            If r_Pay.性质 In (3, 4) Then
              Update 人员缴款余额
              Set 余额 = Nvl(余额, 0) - n_实际冲销
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
              Returning 余额 Into n_返回值;
              If Sql%RowCount = 0 Then
                Insert Into 人员缴款余额
                  (收款员, 结算方式, 性质, 余额)
                Values
                  (操作员姓名_In, r_Pay.结算方式, 1, -1 * n_实际冲销);
                n_返回值 := n_实际冲销;
              End If;
              If Nvl(n_返回值, 0) = 0 Then
                Delete From 人员缴款余额
                Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
              End If;
            End If;
          
            If r_Pay.性质 <> 8 Then
              Update 病人预交记录
              Set 冲预交 = 冲预交 + (-1 * n_实际冲销)
              Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
              If Sql%RowCount = 0 Then
                Insert Into 病人预交记录
                  (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名,
                   摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
                Values
                  (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * n_实际冲销, v_结算方式, Null, 退费时间_In,
                   Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                   r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
              End If;
            End If;
          
            Update 病人预交记录
            Set 记录状态 = 3
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_原结帐ids))) And
                  结算方式 = r_Pay.结算方式;
            n_实收金额 := n_实收金额 - n_实际冲销;
          
          End If;
        End If;
      End Loop;
    End If;
  
    If 误差费_In Is Not Null Then
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要, 缴款组id,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
      Values
        (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
         Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
    End If;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Update 门诊费用记录 Set 费用状态 = Nvl(n_费用状态, 0) Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2;
  Else
    --医保按结算转出
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And a.结帐id = 原结帐id_In) Loop
      v_Nos := v_Nos || ',' || r_Nos.No;
    End Loop;
    v_Nos := Substr(v_Nos, 2);
  
    For r_结帐ids In (Select Distinct a.结帐id
                    From 门诊费用记录 A
                    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                          a.记录状态 <> 0) Loop
      v_结帐ids := v_结帐ids || ',' || r_结帐ids.结帐id;
    End Loop;
    v_结帐ids := Substr(v_结帐ids, 2);
    Select Count(a.No), Sum(a.实收金额)
    Into n_Count, n_实收金额
    From 门诊费用记录 A
    Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1;
    If n_Count = 0 Or n_实收金额 = 0 Then
      v_Err_Msg := '本次结算不是收费或因并发原因他人操作了该结算,不能转为住院费用.';
      Raise Err_Item;
    End If;
  
    Select 结帐id, 病人id, 开单部门id, 开单人
    Into n_原结帐id, n_病人id, n_开单部门id, v_开单人
    From 门诊费用记录
    Where 结帐id = 原结帐id_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Rownum < 2;
  
    Begin
      Select 1
      Into n_部分退费
      From 门诊费用记录 A
      Where Mod(a.记录性质, 10) = 1 And a.记录状态 = 2 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            Rownum < 2;
    Exception
      When Others Then
        n_部分退费 := 0;
    End;
  
    Begin
      Select 0
      Into n_部分退费
      From 门诊费用记录 A
      Where 记录性质 = 11 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    Begin
      Select Count(Avg(1))
      Into n_退费条数
      From 病人预交记录 A
      Where a.记录性质 = 3 And a.记录状态 <> 0 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))
      Group By a.结算方式;
    Exception
      When Others Then
        n_退费条数 := 0;
    End;
    --1.1作废费用记录
    If 结帐id_In Is Null Then
      Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
    Else
      n_结帐id := 结帐id_In;
    End If;
    Insert Into 门诊费用记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
       计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态, 执行时间,
       操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 缴款组id, 费用状态)
      Select 病人费用记录_Id.Nextval, a.No, a.实际票号, a.记录性质, 2, a.序号, a.从属父号, a.价格父号, a.病人id, a.医嘱序号, a.门诊标志, a.姓名, a.性别, a.年龄,
             a.标识号, a.付款方式, a.费别, a.病人科室id, a.收费类别, a.收费细目id, a.计算单位, a.付数, a.发药窗口, -1 * a.数次, a.加班标志, a.附加标志, a.收入项目id,
             a.收据费目, a.记帐费用, a.标准单价, -1 * a.应收金额, -1 * a.实收金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.执行人, -1, a.执行时间,
             操作员编号_In, 操作员姓名_In, a.发生时间, 退费时间_In, n_结帐id, -1 * a.结帐金额, a.保险项目否, a.保险大类id, a.统筹金额, a.摘要,
             Decode(Nvl(a.附加标志, 0), 9, 1, 0), a.保险编码, a.费用类型, n_组id, 0
      From 门诊费用记录 A
      Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1;
  
    --作废医保
    For r_医保 In (Select 结帐id, NO, 结算方式, 金额, 备注
                 From 医保结算明细
                 Where NO In (Select Column_Value From Table(f_Str2list(v_Nos))) And
                       结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
      Update 医保结算明细
      Set 金额 = 金额 + (-1 * r_医保.金额)
      Where NO = r_医保.No And 结帐id = r_医保.结帐id And 结算方式 = r_医保.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 医保结算明细
          (结帐id, NO, 结算方式, 金额)
        Values
          (r_医保.结帐id, r_医保.No, r_医保.结算方式, -1 * r_医保.金额);
      End If;
    End Loop;
  
    --Update 门诊费用记录 Set 记录状态 = 3 Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    --1.2作废预交记录
    --作废冲预交部分
    If n_部分退费 = 0 And Nvl(门诊退费_In, 0) = 0 Then
      For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, -1 * Sum(冲预交) As 冲预交,
                              卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                       From 病人预交记录 A
                       Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                             Nvl(冲预交, 0) <> 0
                       Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号,
                                卡号, 交易流水号, 交易说明, 合作单位, 结算性质) Loop
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
          Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                 r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                 操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                 r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
          From Dual;
      End Loop;
    
      For v_预交 In (Select 病人id, Nvl(预交类别, 2) As 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录 A
                   Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                         a.结帐id <> n_结帐id
                   Group By 病人id, Nvl(预交类别, 2)
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = v_预交.病人id And 类型 = Nvl(v_预交.预交类别, 2) And 性质 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (v_预交.病人id, Nvl(v_预交.预交类别, 2), v_预交.预交金额, 1);
          n_返回值 := v_预交.预交金额;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额
          Where 病人id = v_预交.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    Else
      If n_退费条数 = 0 And Nvl(门诊退费_In, 0) = 0 Then
        --只使用了预交，原样退回预交
        For r_Prepay In (Select NO, 实际票号, 病人id, 主页id, 科室id, Max(结算方式) As 结算方式, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间,
                                -1 * Sum(冲预交) As 冲预交, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质
                         From 病人预交记录 A
                         Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                               Nvl(冲预交, 0) <> 0
                         Group By n_Tempid, NO, 实际票号, 病人id, 主页id, 科室id, 结算号码, 缴款单位, 单位开户行, 单位帐号, 收款时间, 卡类别id, 结算卡序号, 卡号,
                                  交易流水号, 交易说明, 合作单位, 结算性质) Loop
          Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 预交类别, 结算性质)
            Select n_Tempid, r_Prepay.No, r_Prepay.实际票号, 11, 1, r_Prepay.病人id, r_Prepay.主页id, r_Prepay.科室id, Null,
                   r_Prepay.结算方式, r_Prepay.结算号码, Null, r_Prepay.缴款单位, r_Prepay.单位开户行, r_Prepay.单位帐号, 退费时间_In, 操作员姓名_In,
                   操作员编号_In, r_Prepay.冲预交, n_结帐id, n_组id, r_Prepay.卡类别id, r_Prepay.结算卡序号, r_Prepay.卡号, r_Prepay.交易流水号,
                   r_Prepay.交易说明, r_Prepay.合作单位, -1 * n_结帐id, 1, r_Prepay.结算性质
            From Dual;
          Select -1 * 冲预交 Into n_预交金额 From 病人预交记录 Where ID = n_Tempid;
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) + Nvl(n_预交金额, 0)
          Where 病人id = r_Prepay.病人id And 类型 = 1 And 性质 = 1
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_预交金额, 1);
            n_返回值 := n_预交金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = r_Prepay.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
          End If;
        End Loop;
      Else
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
        Exception
          When Others Then
            Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
        End;
        Select 病人预交记录_Id.Nextval Into n_Tempid From Dual;
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
          Select n_Tempid, Max(NO), Max(实际票号), 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, Max(结算号码), '预交临时记录', Null, Null,
                 Null, Max(收款时间), 操作员姓名_In, 操作员编号_In, Sum(冲预交), n_原结帐id, Null, Null, Null, Null, Null, Null,
                 -1 * n_原结帐id, 3
          From 病人预交记录 A
          Where 记录性质 In (1, 11) And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
                Nvl(冲预交, 0) <> 0
          Group By n_Tempid, 3, 3, 病人id, 主页id, 科室id, Null, v_结算方式, '预交临时记录', 操作员姓名_In, 操作员编号_In, n_原结帐id;
      End If;
    End If;
  
    --作废门诊缴费及医保部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 Not In (7, 8);
  
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 校对标志)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退费时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             0, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, -1 * n_结帐id, 结算性质, 1
      From 病人预交记录 A, 结算方式 B
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And
            a.结算方式 = b.名称 And b.性质 = 7;
    If Sql%RowCount <> 0 Then
      n_费用状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 记录状态 = 3
    Where 记录性质 = 3 And 记录状态 = 1 And 结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)));
  
    --2.票据收回
    --可能以前没有打印,无收回
    For r_Nos In (Select Distinct a.No
                  From 门诊费用记录 A
                  Where Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                        a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
    
      Select Nvl(Max(ID), 0)
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = r_Nos.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
      If n_打印id > 0 Then
        --多张单据循环调用时只能收回一次
        Select Count(打印id) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 退费时间_In, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        End If;
      End If;
    End Loop;
  
    --3.缴款数据处理(
    --   现有两种情况:
    --    1. 转出过程直接销帐的,则缴款数据不增加;
    --    2. 先转出,再到门诊退款退票,则需要进行缴款数据处理
    If Nvl(门诊退费_In, 0) = 1 Then
      For c_预交 In (Select a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, Min(a.交易流水号) As 交易流水号,
                          Min(a.交易说明) As 交易说明, Min(a.合作单位) As 合作单位, b.性质
                   From 病人预交记录 A, 结算方式 B
                   Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                         a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                         b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                   Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质
                   Having Sum(a.冲预交) <> 0) Loop
        Begin
          Select 是否退现 Into n_退现 From 医疗卡类别 Where ID = c_预交.卡类别id;
        Exception
          When Others Then
            n_退现 := 0;
        End;
        If (c_预交.性质 = 7 Or (c_预交.性质 = 8 And c_预交.卡类别id Is Not Null)) And n_退现 = 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || c_预交.卡类别id || ',' || -1 * c_预交.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
          n_费用状态 := 1;
        Else
          If c_预交.性质 In (3, 4) Or (c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null) Then
            v_结算方式 := c_预交.结算方式;
          Else
            If 结算方式_In Is Null Then
              Begin
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
              Exception
                When Others Then
                  Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
              End;
            Else
              v_结算方式 := 结算方式_In;
            End If;
          End If;
        
          If c_预交.性质 = 8 And c_预交.结算卡序号 Is Not Null Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, c_预交.冲预交, c_预交.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交), 摘要 = 摘要 || '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || c_预交.结算卡序号 || ',' || -1 * c_预交.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
            n_费用状态 := 1;
          End If;
          If c_预交.结算卡序号 Is Null Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - c_预交.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, v_结算方式, 1, -1 * c_预交.冲预交);
              n_返回值 := c_预交.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式 And Nvl(余额, 0) = 0;
            End If;
            --部分退费情况，退原预交记录
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * c_预交.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * c_预交.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, c_预交.合作单位, n_结帐id,
                 -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    
      --更新费用审核记录
      Update 费用审核记录
      Set 记录状态 = 2
      Where 费用id In (Select a.Id
                     From 门诊费用记录 A
                     Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                           a.记录状态 In (1, 3)) And 性质 = 1;
      --作废门诊记录
      For r_Nos In (Select Distinct NO
                    From 门诊费用记录
                    Where Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And
                          结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids)))) Loop
        Update 门诊费用记录 Set 记录状态 = 3 Where NO = r_Nos.No And Mod(记录性质, 10) = 1 And 记录状态 = 1;
      End Loop;
      For r_Clinic In (Select Min(a.记录性质) As 记录性质, a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别,
                              a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, Sum(a.数次) As 数次,
                              a.加班标志, a.附加标志, a.收入项目id, a.收据费目, a.标准单价, Sum(a.应收金额) As 应收金额, Sum(a.实收金额) As 实收金额,
                              Sum(a.统筹金额) As 统筹金额, a.开单部门id, a.开单人, a.执行部门id, a.划价人, Max(a.记帐单id) As 记帐单id,
                              Max(a.是否急诊) As 是否急诊, a.发生时间, Min(a.实际票号) As 实际票号
                       From 门诊费用记录 A
                       Where a.No In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(a.记录性质, 10) = 1 And
                             a.记录状态 In (2, 3) And Nvl(a.附加标志, 0) Not In (8, 9)
                       Group By a.No, a.序号, a.从属父号, a.价格父号, a.病人id, a.姓名, a.性别, a.年龄, a.病人科室id, a.费别, a.收费类别, a.收费细目id,
                                a.计算单位, a.保险项目否, a.保险大类id, a.保险编码, a.费用类型, a.发药窗口, a.付数, a.加班标志, a.附加标志, a.收入项目id, a.收据费目,
                                a.标准单价, a.开单部门id, a.开单人, a.执行部门id, a.划价人, a.发生时间
                       Having Sum(a.数次) <> 0) Loop
        Insert Into 门诊费用记录
          (ID, 记录性质, NO, 实际票号, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
           保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间,
           登记时间, 执行部门id, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 缴款组id, 结帐id, 结帐金额, 执行状态, 费用状态)
        Values
          (病人费用记录_Id.Nextval, r_Clinic.记录性质, r_Clinic.No, r_Clinic.实际票号, 2, r_Clinic.序号, r_Clinic.从属父号, r_Clinic.价格父号,
           1, r_Clinic.病人id, '', r_Clinic.姓名, r_Clinic.性别, r_Clinic.年龄, r_Clinic.病人科室id, r_Clinic.费别, r_Clinic.收费类别,
           r_Clinic.收费细目id, r_Clinic.计算单位, r_Clinic.保险项目否, r_Clinic.保险大类id, r_Clinic.保险编码, r_Clinic.费用类型, r_Clinic.发药窗口,
           r_Clinic.付数, -1 * r_Clinic.数次, r_Clinic.加班标志, r_Clinic.附加标志, r_Clinic.收入项目id, r_Clinic.收据费目, r_Clinic.标准单价,
           -1 * r_Clinic.应收金额, -1 * r_Clinic.实收金额, -1 * r_Clinic.统筹金额, 0, r_Clinic.开单部门id, r_Clinic.开单人, r_Clinic.发生时间,
           退费时间_In, r_Clinic.执行部门id, r_Clinic.划价人, 操作员编号_In, 操作员姓名_In, r_Clinic.记帐单id, '', r_Clinic.是否急诊, n_组id, n_结帐id,
           -1 * r_Clinic.实收金额, -1, 0);
      End Loop;
    Else
      --4.退款转预交(不产生票据,由操作员通过重打进行)
    
      For r_Pay In (Select Min(a.Id) As 预交id, a.结算方式, Sum(a.冲预交) As 冲预交, 2 As 预交类别, a.卡类别id, a.结算卡序号, a.卡号, a.交易流水号,
                           a.交易说明, a.合作单位, b.性质
                    From 病人预交记录 A, 结算方式 B
                    Where a.记录性质 = 3 And a.记录状态 In (2, 3) And
                          a.结帐id In (Select Column_Value From Table(f_Str2list(v_结帐ids))) And a.结算方式 = b.名称 And
                          b.性质 In (1, 2, 3, 4, 7, 8) And a.结算方式 Is Not Null
                    Group By a.结算方式, 预交类别, a.卡类别id, a.结算卡序号, a.卡号, b.性质, a.交易流水号, a.交易说明, a.合作单位

                    
                    Having Sum(a.冲预交) <> 0) Loop
        --4.1产生预交款单据 (不存在部分退费的情况)
        --所有单据,按规则生成预交款单据
        --因为收款后立即缴款,所以人员缴款余额无变化
        If r_Pay.性质 = 7 Or (r_Pay.性质 = 8 And r_Pay.卡类别id Is Not Null) Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|'
          Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
          If Sql%RowCount = 0 Then
            Insert Into 病人预交记录
              (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
               缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
            Values
              (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
               Null, Null, Null, 操作员编号_In, 操作员姓名_In, '1' || ',' || r_Pay.卡类别id || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
               Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
          End If;
          n_费用状态 := 1;
        Else
          If r_Pay.性质 In (3, 4) Or (r_Pay.性质 = 8 And r_Pay.结算卡序号 Is Not Null) Then
            v_结算方式 := r_Pay.结算方式;
          Else
            Begin
              Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
            Exception
              When Others Then
                Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
            End;
          End If;
        
          If r_Pay.性质 = 8 Then
            --Zl_Square_Update(v_结帐ids, n_结帐id, n_组id, 退费时间_In, -1 * n_结帐id, Null, r_Pay.冲预交, r_Pay.结算卡序号);
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交), 摘要 = 摘要 || '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|'
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 Is Null;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 结算性质, 校对标志)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, Null, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '0' || ',' || r_Pay.结算卡序号 || ',' || -1 * r_Pay.冲预交 || '|', n_组id,
                 Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 3, 1);
            End If;
            n_费用状态 := 1;
          End If;
          If r_Pay.性质 Not In (3, 4, 7, 8) Then
            Update 病人预交记录
            Set 金额 = 金额 + r_Pay.冲预交
            Where 记录性质 = 1 And 记录状态 = 1 And 收款时间 = 退费时间_In And 病人id + 0 = n_病人id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              v_预交no := Nextno(11);
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 预交类别)
              Values
                (病人预交记录_Id.Nextval, v_预交no, Null, 1, 1, n_病人id, 主页id_In, 入院科室id_In, r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '门诊转住院预交', n_组id, r_Pay.预交类别);
            End If;
          
            --病人余额
            Update 病人余额
            Set 预交余额 = Nvl(预交余额, 0) + r_Pay.冲预交
            Where 性质 = 1 And 病人id = n_病人id And 类型 = 2
            Returning 预交余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额 (病人id, 性质, 类型, 预交余额, 费用余额) Values (n_病人id, 1, 2, r_Pay.冲预交, 0);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 病人余额
              Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
            End If;
          End If;
          --4.2缴款数据处理
          --   因为没有实际收病人的钱,所以不处理
          --部分退费情况，退原预交记录
          If r_Pay.性质 In (3, 4) Then
            Update 人员缴款余额
            Set 余额 = Nvl(余额, 0) - r_Pay.冲预交
            Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式
            Returning 余额 Into n_返回值;
            If Sql%RowCount = 0 Then
              Insert Into 人员缴款余额
                (收款员, 结算方式, 性质, 余额)
              Values
                (操作员姓名_In, r_Pay.结算方式, 1, -1 * r_Pay.冲预交);
              n_返回值 := r_Pay.冲预交;
            End If;
            If Nvl(n_返回值, 0) = 0 Then
              Delete From 人员缴款余额
              Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Pay.结算方式 And Nvl(余额, 0) = 0;
            End If;
          End If;
        
          If r_Pay.结算卡序号 Is Null Then
            Update 病人预交记录
            Set 冲预交 = 冲预交 + (-1 * r_Pay.冲预交)
            Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
            If Sql%RowCount = 0 Then
              Insert Into 病人预交记录
                (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
                 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
              Values
                (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, -1 * r_Pay.冲预交, v_结算方式, Null, 退费时间_In,
                 Null, Null, Null, 操作员编号_In, 操作员姓名_In, '', n_组id, r_Pay.卡类别id, r_Pay.结算卡序号, r_Pay.卡号, r_Pay.交易流水号,
                 r_Pay.交易说明, r_Pay.合作单位, n_结帐id, -1 * n_结帐id, 0, 3);
            End If;
          End If;
        End If;
      End Loop;
    End If;
    If 误差费_In Is Not Null Then
      Begin
        Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And 名称 Like '%现金%' And Rownum < 2;
      Exception
        When Others Then
          Select 名称 Into v_结算方式 From 结算方式 Where 性质 = 1 And Rownum < 2;
      End;
      Update 病人预交记录
      Set 冲预交 = 冲预交 - 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_结算方式;
      Update 病人预交记录
      Set 冲预交 = 冲预交 + 误差费_In
      Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = n_结帐id And 结算方式 = v_误差费;
      If Sql%RowCount = 0 Then
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 冲预交, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 摘要,
           缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结帐id, 结算序号, 校对标志, 结算性质)
        Values
          (病人预交记录_Id.Nextval, Null, Null, 3, 2, n_病人id, 主页id_In, 入院科室id_In, 误差费_In, v_误差费, Null, 退费时间_In, Null, Null,
           Null, 操作员编号_In, 操作员姓名_In, '', n_组id, Null, Null, Null, Null, Null, Null, n_结帐id, -1 * n_结帐id, 0, 3);
      End If;
    End If;
    Delete From 病人预交记录 Where 结帐id = n_原结帐id And 摘要 = '预交临时记录' And 记录性质 = 3;
    Delete From 病人预交记录
    Where 结帐id = n_结帐id And 记录性质 = 3 And 记录状态 = 2 And 冲预交 = 0 And 结算方式 Is Not Null;
    Update 门诊费用记录
    Set 费用状态 = Nvl(n_费用状态, 0)
    Where NO In (Select Column_Value From Table(f_Str2list(v_Nos))) And Mod(记录性质, 10) = 1 And 记录状态 = 2;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊转住院_收费转出;
/

--102117:胡俊勇,2016-11-02,出院医嘱发送前检查
--98435:梁唐彬,2016-07-12,上次计算时间变动记录当天清空调整
Create Or Replace Procedure Zl_病人变动记录_Preout
(
  病人id_In   病案主页.病人id%Type,
  主页id_In   病案主页.主页id%Type,
  发生时间_In 病人变动记录.开始时间%Type
) As
  -----------------------------------------------------------
  --功能：将病人标为预出院状态，并产生一条变动
  -----------------------------------------------------------
 Cursor c_Oldinfo Is
        Select b.*
    From (Select c.*
           From 病人变动记录 C
           Where c.病人id = 病人id_In And c.主页id = 主页id_In And
                 c.开始时间 = (Select Min(开始时间) From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 开始时间 > 发生时间_In)) A, 病人变动记录 B

    Where b.病人id = 病人id_In And b.主页id = 主页id_In And a.开始时间 = b.终止时间 And a.开始原因 = b.终止原因 And a.附加床位 = b.附加床位
    Union
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null And 开始时间 <= 发生时间_In;

  Cursor c_Endinfo Is
    Select * From 病人变动记录 Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  r_Oldinfo c_Oldinfo%RowType;
  r_Endinfo c_Endinfo%RowType;
  v_终止原因 病人变动记录.终止原因%Type;
  v_终止时间 病人变动记录.终止时间%Type;
  v_终止人员 病人变动记录.终止人员%Type;

  v_Temp     Varchar2(255);
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;
  v_姓名     病人信息.姓名%Type;

  v_Count Number;
  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --并发操作检查
  Select Nvl(状态, 0) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If v_Count <> 0 Then
    v_Error := '该病人当前正在转科或尚未入科，不能执行预出院。';
    Raise Err_Custom;
  End If;

  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1  And Nvl(婴儿, 0) = 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;

    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记,0)<>-1  And Nvl(婴儿, 0) = 0 And 
	Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --操作员信息
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Open c_Oldinfo; --必须在处理之前先打开
  Fetch c_Oldinfo
    Into r_Oldinfo;
  Open c_Endinfo;
  Fetch c_Endinfo
    Into r_Endinfo;
  If c_Endinfo%RowCount = 0 Then
    Close c_Endinfo;
    v_Error := '未发现该病人当前有效的变动记录！';
    Raise Err_Custom;
  End If;

  --取消上次变动
  If r_Oldinfo.终止时间 Is not NULL then
    v_终止时间:=r_Oldinfo.终止时间;
    v_终止原因:=r_Oldinfo.终止原因;
    v_终止人员:=r_Oldinfo.终止人员;
    --取消上次变动
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名 ,上次计算时间 = Null
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 = v_终止时间 And 终止原因=v_终止原因;
    
  Else
    Update 病人变动记录
    Set 终止时间 = 发生时间_In, 终止原因 = 10, 终止人员 = v_人员姓名, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 发生时间_In) - 发生时间_In), 1, Null, 上次计算时间)
    Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;
  End If;
  --更新将来的记录如果有停止到将来的则删除上次计算时间
    Update 病人变动记录 Set 上次计算时间 = Null Where 病人id = 病人id_In And 主页id = 主页id_In And (开始时间 > 发生时间_In Or Trunc(上次计算时间) = Trunc(发生时间_In));

  --产生新变动
  While c_Oldinfo%Found Loop
    Insert Into 病人变动记录
      (ID, 病人id, 主页id, 开始时间, 开始原因, 附加床位, 病区id, 科室id, 医疗小组id, 护理等级id, 床位等级id, 床号, 责任护士, 经治医师, 主治医师, 主任医师, 病情, 操作员编号,
       操作员姓名,终止时间,终止原因,终止人员)
    Values
      (病人变动记录_Id.Nextval, 病人id_In, 主页id_In, 发生时间_In, 10, r_Oldinfo.附加床位, r_Oldinfo.病区id, r_Oldinfo.科室id,
       r_Oldinfo.医疗小组id, r_Oldinfo.护理等级id, r_Oldinfo.床位等级id, r_Oldinfo.床号, r_Oldinfo.责任护士, r_Oldinfo.经治医师,
       r_Oldinfo.主治医师, r_Oldinfo.主任医师, r_Oldinfo.病情, v_人员编号, v_人员姓名,v_终止时间,v_终止原因,v_终止人员);
    If Nvl(r_Oldinfo.附加床位, 0) = 0 Then
      --产生病历书写时机
      Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', r_Oldinfo.科室id, r_Oldinfo.经治医师, 发生时间_In, 发生时间_In);
    End If;
    Fetch c_Oldinfo
      Into r_Oldinfo;
  End Loop;

  Close c_Oldinfo;
  Close c_Endinfo;

  Update 病案主页 Set 状态 = 3 Where 病人id = 病人id_In And 主页id = 主页id_In;

  --并发操作检查
  Select Count(*)
  Into v_Count
  From 病人变动记录
  Where 病人id = 病人id_In And 主页id = 主页id_In And Nvl(附加床位, 0) = 0 And 开始时间 Is Not Null And 终止时间 Is Null;
  If v_Count > 1 Then
    v_Error := '发现病人存在非法的变动记录,当前操作不能继续！' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态后再试！';
    Raise Err_Custom;
  End If;

  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;
  If v_Count = 0 Then
    v_Error := '操作失败,该病人已出院,不能进行当前操作.' || Chr(13) || Chr(10) || '这可能是由于网络并发操作引起的,请刷新病人状态！';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Preout;
/

--97721:胡俊勇,2016-07-12,诊疗执行科室获取
Create Or Replace Function zl_ClinicExeDept
(
  病人id_In     病人信息.病人id%Type,
  主页id_In     病案主页.主页id%Type,
  诊疗类别_In   诊疗项目目录.类别%Type,
  项目id_In     诊疗项目目录.ID%Type,
  药品id_In     收费项目目录.ID%Type,
  病人科室id_In 病人医嘱记录.病人科室id%Type,
  开嘱科室id_In 病人医嘱记录.开嘱科室id%Type
  --功能:获取指定诊疗项目在医嘱下达时的执行科室
  --参数：
  ----主页id_In：住院病人的主页ID，如果为NULL表示门诊病人。
  ----药品id_In：按规格下达药品医嘱时，为对应规格的药品ID；其他情况传入为Null。
  --返回:具体的执行科室ID，如果返回Null，则由根据程序规则处理
) Return Number As
  v_Return Number;
Begin
  v_Return := Null;
  Return v_Return;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End zl_ClinicExeDept;
/

--97493:蔡青松,2016-07-11,给标本发送批号参数添加默认值
CREATE OR REPLACE Procedure Zl_Lis预置条码_标本送出
( 
  医嘱内容_In Varchar2, --内容包括多个|医嘱ID,医嘱ID,医嘱ID...| 
  Type_In     Number := 0, --0为送检 1为取消送检 
  送检人_In   病人医嘱发送.送检人%Type := '' ,
  标本发送批号_In 病人医嘱发送.标本发送批号%type:=null
) Is 
  V_Nowdate Date; 
Begin 
  If Type_In = 0 Then 
    V_Nowdate := Sysdate; 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Decode(标本送出时间, Null, V_Nowdate, 标本送出时间), 送检人 = 送检人_In ,标本发送批号 = 标本发送批号_In
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  Else 
    Update /*+ rule */ 病人医嘱发送 
    Set 标本送出时间 = Null, 送检人 = Null ,标本发送批号 = Null
    Where 医嘱id In (Select A.Id 
                   From 病人医嘱记录 A, (Select * From Table(Cast(F_Num2list(医嘱内容_In) As Zltools.T_Numlist))) B 
                   Where B.Column_Value In (A.Id, A.相关id)); 
  End If; 
Exception 
 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_Lis预置条码_标本送出;
/

--98147:王振涛,2016-07-12,费用不一致
Create Or Replace Procedure Zl_检验标本记录_报告审核
(
  Id_In       检验标本记录.Id%Type,
  审核人_In   检验标本记录.审核人%Type := Null,
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null
) Is

  --未审核的费用行(不包含药品)
  Cursor c_Verify(v_医嘱id In Number) Is
    Select Distinct 2 as 记录性质, NO, 序号
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Union All
    Select Distinct 1 as 记录性质, NO, 序号
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And 记帐费用 = 1 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id = v_医嘱id
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID From 病人医嘱记录 Where v_医嘱id In (ID, 相关id))) And 医嘱序号 = v_医嘱id
    Order By 记录性质, NO, 序号;

  --查找当前标本的相关申请
  Cursor c_Samplequest(v_微生物 In Number) Is
    Select Distinct 医嘱id, 病人来源
    From (Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 0 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select a.医嘱id, b.病人来源
           From 检验项目分布 A, 检验标本记录 B
           Where 1 = v_微生物 And a.标本id = Id_In And a.医嘱id Is Not Null And a.标本id = b.Id
           Union
           Select b.Id As 医嘱id, a.病人来源
           From 检验标本记录 A, 病人医嘱记录 B
           Where a.Id = Id_In And a.医嘱id = b.相关id);

  Cursor c_Stuff
  (
    v_No     Varchar2,
    v_主页id Number
  ) Is
    Select NO, 单据, 库房id
    From 未发药品记录
    Where NO = v_No And 单据 In (24, 25, 26) And 库房id Is Not Null And Not Exists
     (Select 1 From Dual Where zl_GetSysParameter(Decode(v_主页id, Null, 92, 63)) = '1') And Exists
     (Select a.序号
           From 住院费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1
           Union All
           Select a.序号
           From 门诊费用记录 A, 材料特性 B
           Where a.记录性质 = 2 And a.记录状态 = 1 And a.No = v_No And a.收费细目id = b.材料id And b.跟踪在用 = 1)
    Order By 库房id;

  v_执行  Number(1);
  v_No    病人医嘱发送.No%Type;
  v_Nonew 病人医嘱发送.No%Type;
  v_性质  病人医嘱发送.记录性质%Type;
  v_序号  Varchar2(1000);

  v_Count      Number(18);
  v_Counts     Number(18);
  v_微生物标本 Number(1) := 0;
  v_主页id     Number(18);
  v_婴儿       Number(1);
  v_年龄       Varchar2(100);
  v_仪器       Number(18);
  v_Intloop    Number;
  Err_Custom Exception;
  v_Error Varchar2(100);
Begin
  Select Nvl(婴儿, 0), 年龄 Into v_婴儿, v_年龄 From 检验标本记录 Where ID = Id_In;

  --执行后自动审核对应的记帐划价单(不包含药品)
  Select Zl_To_Number(Nvl(zl_GetSysParameter(81), '0')) Into v_执行 From Dual;

  v_微生物标本 := 0;
  Begin
    Select 1 Into v_微生物标本 From 检验标本记录 Where 微生物标本 = 1 And ID = Id_In;
  Exception
    When Others Then
      v_微生物标本 := 0;
  End;

  --1.置本标本的状态及审核人和时间
  Update 检验标本记录
  Set 审核人 = Decode(审核人_In, Null, 人员姓名_In, 审核人_In), 审核时间 = Sysdate, 样本状态 = 2
  Where ID = Id_In;

  --记录审核过程
  Insert Into 检验操作记录
    (ID, 标本id, 操作类型, 操作员, 操作时间)
  Values
    (检验操作记录_Id.Nextval, Id_In, 0, Decode(审核人_In, Null, 人员姓名_In, 审核人_In), Sysdate);

  --2.检查当前标本相关的申请的相关标本是否完成审核
  For r_Samplequest In c_Samplequest(v_微生物标本) Loop
  
    v_Count := 0;
  
    If v_微生物标本 = 0 Then
      Begin
        Select Nvl(Count(1), 0)
        Into v_Count
        From 检验标本记录
        Where 样本状态 < 2 And ID In (Select 标本id From 检验项目分布 Where 医嘱id = r_Samplequest.医嘱id);
      Exception
        When Others Then
          v_Count := 0;
      End;
    End If;
  
    --r_SampleQuest.医嘱id申请已经完成,处理后续环节
    If v_Count = 0 Then
    
      --1.置申请单的执行状态
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
      Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id));
    
      Update 病人医嘱发送
      Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
      Where 医嘱id In (Select 相关id
                     From 病人医嘱记录
                     Where ID In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
    
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      Else
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID From 病人医嘱记录 Where r_Samplequest.医嘱id In (ID, 相关id)));
      End If;
    
      --3.自动审核记帐
      If v_执行 = 1 Then
        Select Count(*) Into v_Counts From 病人医嘱记录 Where 相关id = r_Samplequest.医嘱id;
        If v_Counts > 0 Then
          For r_相关医嘱 In (Select ID As 医嘱id From 病人医嘱记录 Where 相关id = r_Samplequest.医嘱id) Loop
            For r_Verify In c_Verify(r_相关医嘱.医嘱id) Loop
              If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
                If v_序号 Is Not Null Then
                  If v_性质 = 1 Then
                    Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  Elsif v_性质 = 2 Then
                    Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                  End If;
                End If;
                v_序号 := Null;
              End If;
              v_No   := r_Verify.No;
              v_性质 := r_Verify.记录性质;
              v_序号 := v_序号 || ',' || r_Verify.序号;
            End Loop;
          End Loop;
        Else
          For r_Verify In c_Verify(r_Samplequest.医嘱id) Loop
            If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
              If v_序号 Is Not Null Then
                If v_性质 = 1 Then
                  Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                Elsif v_性质 = 2 Then
                  Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
                End If;
              End If;
              v_序号 := Null;
            End If;
            v_No   := r_Verify.No;
            v_性质 := r_Verify.记录性质;
            v_序号 := v_序号 || ',' || r_Verify.序号;
          End Loop;
        End If;
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
          v_序号 := Null;
          --  v_性质 := null;
        End If;
      End If;
    
      --审核试剂消耗单
      v_Intloop := 1;
    
      Select 仪器id Into v_仪器 From 检验标本记录 Where ID = Id_In;
      For r_检验试剂 In (Select c.材料id, c.数量
                     From 病人医嘱记录 A, 检验报告项目 B, 检验试剂关系 C
                     Where a.相关id = r_Samplequest.医嘱id And a.诊疗项目id = b.诊疗项目id And b.报告项目id = c.项目id And c.仪器id = v_仪器) Loop
        Zl_检验试剂记录_Insert(r_Samplequest.医嘱id, v_Intloop, r_检验试剂.材料id, r_检验试剂.数量);
        v_Intloop := v_Intloop + 1;
      End Loop;
      Select Count(*) Into v_Intloop From 检验试剂记录 Where 医嘱id = r_Samplequest.医嘱id And NO Is Null;
      If v_Intloop > 1 Then
        v_Nonew := Nextno(14);
        Update 检验试剂记录 Set NO = v_Nonew Where 医嘱id = r_Samplequest.医嘱id;
      End If;
      If v_Nonew Is Not Null Then
      
        Zl_检验试剂记录_Bill(r_Samplequest.医嘱id, v_Nonew);
      
        v_主页id := Null;
        Select 主页id Into v_主页id From 病人医嘱记录 A Where ID = r_Samplequest.医嘱id;
      
        If v_主页id Is Null Then
          Zl_门诊记帐记录_Verify(v_Nonew, 人员编号_In, 人员姓名_In);
        Else
          Zl_住院记帐记录_Verify(v_Nonew, 人员编号_In, 人员姓名_In);
        End If;
      
        --如果记帐没有自动发料,则自动发料,否则不处理
        For r_Stuff In c_Stuff(v_Nonew, v_主页id) Loop
          Zl_材料收发记录_处方发料(r_Stuff.库房id, 25, v_Nonew, 人员姓名_In, 人员姓名_In, 人员姓名_In, 1, Sysdate);
        End Loop;
      End If;
    End If;
  End Loop;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 9, 0 || ',' || Id_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_报告审核;
/

--101042:黄捷,2016-11-01,创建报告时有报告才删除旧报告
--98119:黄捷,2016-07-08,退号后报告内容创建出错
CREATE OR REPLACE Procedure Zl_影像报告内容_创建
(
  医嘱id_In     In 病人医嘱记录.Id%Type,
  病历文件id_In In 病历文件结构.文件id%Type,
  病历范文id_In In 病历范文目录.Id%Type,
  格式来源      In Number
) Is
  --格式来源 = 0 ,从病历文件列表中提取格式，格式来源=1，从病历范文目录中提取格式
  v_主页id     病人医嘱记录.主页id%Type;
  v_挂号单id   病人挂号记录.Id%Type;
  v_执行科室id 病人医嘱记录.执行科室id%Type;
  v_病人来源   病人医嘱记录.病人来源%Type;
  v_病人id     病人医嘱记录.病人id%Type;
  v_婴儿       病人医嘱记录.婴儿%Type;
  v_保存人     电子病历记录.保存人%Type;

  v_病历文件名 病历文件列表.名称%Type;
  v_当前父id   电子病历内容.父id%Type;
  v_父id_In    电子病历内容.父id%Type;
  v_文件id     电子病历内容.文件id%Type;
  v_Nextid     电子病历内容.Id%Type;
  v_原对象序号 电子病历内容.对象序号%Type;
  v_替换内容   电子病历内容.内容文本%Type;
  v_Loop       Number := 0;
  v_Temp       Varchar2(255);

  Cursor v_Source0 Is
    Select Id, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本,
           是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数,
           要素单位, 要素表示, 输入形态, 要素值域,decode(对象类型,1,id,Null) As 定义提纲ID
    From 病历文件结构
    Where 文件id = 病历文件id_In
    Order By 对象序号;

  Cursor v_Source1 Is
    Select Id, 文件id, Nvl(父id, 0) As 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本,
           是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数,
           要素单位, 要素表示, 输入形态, 要素值域
    From 病历范文内容
    Where 文件id = 病历范文id_In
    Order By 对象序号;

Begin

  Select 主页id, 病人来源, 病人id, 执行科室id, Nvl(婴儿, 0)
  Into v_主页id, v_病人来源, v_病人id, v_执行科室id, v_婴儿
  From 病人医嘱记录 b
  Where Id = 医嘱id_In;

  If v_病人来源 = 1 Then
    --门诊，提取挂号单ID
    Select Nvl(c.Id, 0)
    Into v_挂号单id
    From 病人医嘱记录 b, 病人挂号记录 c
    Where b.挂号单 = c.No(+) and c.记录状态 in (1,3) And b.Id = 医嘱id_In;
  Else
    --体检或者外诊，无挂号单ID，直接设置为0
    v_挂号单id := 0;
  End If;

  If 格式来源 = 0 Then
    Select 名称 Into v_病历文件名 From 病历文件列表 Where Id = 病历文件id_In;
  Else
    Select 名称 Into v_病历文件名 From 病历范文目录 Where Id = 病历范文id_In;
  End If;

  --如果原来存在报告，则删除以前的报告记录
  Select nvl(max(病历id),0) Into v_文件id From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Rownum <= 1;
  if v_文件id <>0 then 
    Delete 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    Delete 电子病历记录 Where Id = v_文件id;
    Delete 电子病历内容 Where 文件id = v_文件id;
  end if;

  Select 电子病历记录_Id.Nextval Into v_文件id From Dual;

  v_Temp   := Zl_Identity;
  v_Temp   := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp   := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_保存人 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Insert Into 电子病历记录
    (Id, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 保存人, 保存时间,
     最后版本, 签名级别)
  Values
    (v_文件id, v_病人来源, v_病人id, Decode(v_病人来源, 2, v_主页id, v_挂号单id), v_婴儿, v_执行科室id, 7,
     病历文件id_In, v_病历文件名, v_保存人, Sysdate, v_保存人, Sysdate, 1, 0);

  Insert Into 病人医嘱报告 (医嘱id, 病历id) Values (医嘱id_In, v_文件id);

  If 格式来源 = 0 Then
    For r_Source In v_Source0 Loop
      v_Loop := v_Loop + 1;
      Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;

      If r_Source.父id = 0 Then
        v_当前父id := v_Nextid;
        v_父id_In  := Null;
      Else
        --对象序号为空的时候，父ID就不是按照顺序的了，需要重新查找
        If r_Source.对象序号 Is Null Then
          Select 对象序号 Into v_原对象序号 From 病历文件结构 Where Id = r_Source.父id;
          If v_原对象序号 Is Null Then
            v_父id_In := Null;
          Else
            Select Id Into v_父id_In From 电子病历内容 Where 文件id = v_文件id And 对象序号 = v_原对象序号;
          End If;
        Else
          v_父id_In := v_当前父id;
        End If;
      End If;

      If r_Source.对象类型 = 4 And r_Source.替换域 = 1 Then
        If v_病人来源 = 2 Then
          v_替换内容 := Zl_Replace_Element_Value(r_Source.要素名称, v_病人id, v_主页id, v_病人来源, 医嘱id_In);
        Else
          v_替换内容 := Zl_Replace_Element_Value(r_Source.要素名称, v_病人id, v_挂号单id, v_病人来源, 医嘱id_In);
        End If;
      Else
        v_替换内容 := r_Source.内容文本;
      End If;
      Insert Into 电子病历内容
        (Id, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本,
         是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位,
         要素表示, 输入形态, 要素值域,定义提纲ID)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象,
         r_Source.对象属性, r_Source.内容行次, v_替换内容, r_Source.是否换行, r_Source.预制提纲id, r_Source.复用提纲,
         r_Source.使用时机, r_Source.诊治要素id, r_Source.替换域, r_Source.要素名称, r_Source.要素类型,
         r_Source.要素长度, r_Source.要素小数, r_Source.要素单位, r_Source.要素表示, r_Source.输入形态,
         r_Source.要素值域, r_Source.定义提纲ID);

      If r_Source.对象类型 = 5 Then
        Insert Into 电子病历图形
          (对象id, 图形)
        Values
          (v_Nextid, (Select 图形 From 病历文件图形 Where 对象id = r_Source.Id));
      End If;
    End Loop;
  Else
    For r_Source In v_Source1 Loop
      v_Loop := v_Loop + 1;
      Select 电子病历内容_Id.Nextval Into v_Nextid From Dual;

      If r_Source.父id = 0 Then
        v_当前父id := v_Nextid;
        v_父id_In  := Null;
      Else
        --对象序号为空的时候，父ID就不是按照顺序的了，需要重新查找
        If r_Source.对象序号 Is Null Then
          Select 对象序号 Into v_原对象序号 From 病历范文内容 Where Id = r_Source.父id;
          If v_原对象序号 Is Null Then
            v_父id_In := Null;
          Else
            Select Id Into v_父id_In From 电子病历内容 Where 文件id = v_文件id And 对象序号 = v_原对象序号;
          End If;
        Else
          v_父id_In := v_当前父id;
        End If;
      End If;

      If r_Source.对象类型 = 4 And r_Source.替换域 = 1 Then
        If v_病人来源 = 2 Then
          v_替换内容 := Zl_Replace_Element_Value(r_Source.要素名称, v_病人id, v_主页id, v_病人来源, 医嘱id_In);
        Else
          v_替换内容 := Zl_Replace_Element_Value(r_Source.要素名称, v_病人id, v_挂号单id, v_病人来源, 医嘱id_In);
        End If;
      Else
        v_替换内容 := r_Source.内容文本;
      End If;
      Insert Into 电子病历内容
        (Id, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本,
         是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位,
         要素表示, 输入形态, 要素值域)
      Values
        (v_Nextid, v_文件id, 1, 0, v_父id_In, v_Loop, r_Source.对象类型, r_Source.对象标记, r_Source.保留对象,
         r_Source.对象属性, r_Source.内容行次, v_替换内容, r_Source.是否换行, r_Source.预制提纲id, r_Source.复用提纲,
         r_Source.使用时机, r_Source.诊治要素id, r_Source.替换域, r_Source.要素名称, r_Source.要素类型,
         r_Source.要素长度, r_Source.要素小数, r_Source.要素单位, r_Source.要素表示, r_Source.输入形态,
         r_Source.要素值域);

      If r_Source.对象类型 = 5 Then
        Insert Into 电子病历图形
          (对象id, 图形)
        Values
          (v_Nextid, (Select 图形 From 病历范文图形 Where 对象id = r_Source.Id));
      End If;
    End Loop;
  End If;

  --复制报告格式
  If 格式来源 = 0 Then
    Insert Into 电子病历格式
      (文件id, 内容)
    Values
      (v_文件id, (Select 内容 From 病历文件格式 Where 文件id = 病历文件id_In));
  Else
    Insert Into 电子病历格式
      (文件id, 内容)
    Values
      (v_文件id, (Select 内容 From 病历范文格式 Where 文件id = 病历范文id_In));
  End If;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像报告内容_创建;

/

--98297:刘尔旋,2016-07-06,支付宝预约天数支持
Create Or Replace Procedure Zl_Third_Docarrange
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:医生排班计划
  --入参:Xml_In:
  --<IN>
  --   <YSID>870</YSID>    //医生ID
  --   <KDID>870</KSID>    //科室ID
  --   <KSSJ>2014-10-29 </KSSJ>    //开始时间
  --   <CXTS>14</CXTS>    //查询天数
  --   <HZDW>支付宝</HZDW> //合作单位
  --   <HL>号类</HL>      //号类，可传多个，用逗号分隔，格式:普通,专家,...
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --   <PBLIST>       //未返回该节点表示没有数据
  --    <PB>
  --     <RQ>2014-10-29</RQ>     //日期
  --     <SYHS>5</SYHS>    //剩余号数
  --     <SBSJ>全日</SBSJ>             //上班时间
  --     <YGS>5</YGS>    //已挂号数
  --    </PB>
  --   <PBLIST>
  --   <ERROR><MSG></MSG></ERROR> //错误情况返回
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  v_排班         挂号安排.周日%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_已挂数       挂号安排限制.限号数%Type;
  n_总已挂数     挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限号数%Type;
  n_已约数       挂号安排限制.限号数%Type;
  n_剩余数       挂号安排限制.限号数%Type;
  v_上班时间     Varchar2(300);
  n_医生id       人员表.Id%Type;
  n_科室id       部门表.Id%Type;
  n_查询天数     Number(4);
  n_合作单位数量 Number(5);
  n_合约已挂数   Number(4);
  n_合约存在     Number(3);
  n_安排存在     Number(3);
  v_号码         挂号安排.号码%Type;
  n_安排id       挂号安排计划.安排id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_合作单位     挂号合作单位.名称%Type;
  n_Daycount     Number(4);
  d_开始时间     Date;
  d_原始时间     Date;
  n_禁用         Number(3);
  v_Temp         Varchar2(32767); --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  v_号类         Varchar2(200);
  n_Exists       Number(2);
  n_预约天数     Number(5);
  n_挂号模式     Number(3);
  n_合约模式     临床出诊挂号控制记录.控制方式%Type;
  v_启用时间     Varchar2(500);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/KSID'), Extractvalue(Value(A), 'IN/CXTS'),
         To_Date(Extractvalue(Value(A), 'IN/KSSJ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/HL')
  Into n_医生id, n_科室id, n_查询天数, d_开始时间, v_合作单位, v_号类
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  n_查询天数 := Nvl(n_查询天数, 14);
  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  d_原始时间 := Trunc(d_开始时间);
  d_开始时间 := Trunc(d_开始时间);
  n_Daycount := 0;
  n_挂号模式 := To_Number(Substr(Nvl(zl_GetSysParameter('挂号排班模式'), '0'), 1, 1));
  v_启用时间 := Substr(Nvl(zl_GetSysParameter('挂号排班模式'), '0'), 3);
  If n_挂号模式 = 0 Then
    If Nvl(n_科室id, 0) = 0 Then
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
          d_开始时间 := Sysdate - n_Daycount;
        Else
          d_开始时间 := d_原始时间;
        End If;
        n_安排存在 := 0;
        v_上班时间 := Null;
        n_总已挂数 := 0;
        n_已挂数   := 0;
        n_剩余数   := 0;
        n_限号数   := 0;
        n_已约数   := 0;
        n_限约数   := 0;
        For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                            a.安排id, a.计划id, a.号码, a.号类
                     
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                  Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Ap.医生id = n_医生id And
                                         Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And Ap.停用日期 Is Null And
                                         d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                  Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And
                                         Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And Ap.停用日期 Is Null And
                                         Jh.医生id = n_医生id And
                                         d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And d_开始时间 + n_Daycount Between
                                                Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                           b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                     
                     ) Loop
          If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
            v_上班时间 := v_上班时间 || '+' || r_排班.排班;
            n_总已挂数 := n_总已挂数 + r_排班.已挂数;
            n_已挂数   := r_排班.已挂数;
            n_限号数   := r_排班.限号数;
            n_已约数   := r_排班.已约数;
            n_限约数   := r_排班.限约数;
            n_安排id   := Nvl(r_排班.安排id, 0);
            n_计划id   := Nvl(r_排班.计划id, 0);
            v_号码     := r_排班.号码;
            n_安排存在 := 1;
            If v_上班时间 Is Not Null Then
              If v_合作单位 Is Not Null Then
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位计划控制
                    Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位安排控制
                    Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                End If;
              End If;
            
              If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                Else
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                End If;
              Else
                --合约单位
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                End If;
                If Nvl(n_禁用, 0) = 0 Then
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                
                End If;
              End If;
            End If;
            n_合作单位数量 := 0;
            n_合约存在     := 0;
            n_禁用         := 0;
          End If;
        End Loop;
        v_上班时间 := Substr(v_上班时间, 2);
        If n_安排存在 = 1 Then
          v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                    '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                    '</PB>';
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    Else
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
          d_开始时间 := Sysdate - n_Daycount;
        Else
          d_开始时间 := d_原始时间;
        End If;
        v_上班时间 := Null;
        n_总已挂数 := 0;
        n_已挂数   := 0;
        n_剩余数   := 0;
        n_限号数   := 0;
        n_已约数   := 0;
        n_限约数   := 0;
        n_安排存在 := 0;
        For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                            a.安排id, a.计划id, a.号码, a.号类
                     
                     From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                                   Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数


                            
                            From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                          Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                  Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                   Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                         Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                         d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         Not Exists
                                    (Select Rownum
                                          From 挂号安排计划 Jh
                                          Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                   Union All
                                   Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                          Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                          Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                  Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                          Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                   From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                   Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                         Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And Ap.科室id = n_科室id And
                                         d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                         Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                         Xz.限制项目(+) =
                                         Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                    (Select Rownum
                                          From 挂号安排停用状态 Ty
                                          Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                         (Jh.生效时间, Jh.安排id) =
                                         (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                          From 挂号安排计划 Sxjh
                                          Where Sxjh.审核时间 Is Not Null And d_开始时间 + n_Daycount Between
                                                Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                          Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                            Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                          病人挂号汇总 Hz, 收费价目 B
                     Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                           b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                     
                     ) Loop
          If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
            v_上班时间 := v_上班时间 || '+' || r_排班.排班;
            n_总已挂数 := n_总已挂数 + r_排班.已挂数;
            n_已挂数   := r_排班.已挂数;
            n_限号数   := r_排班.限号数;
            n_已约数   := r_排班.已约数;
            n_限约数   := r_排班.限约数;
            n_安排id   := Nvl(r_排班.安排id, 0);
            n_计划id   := Nvl(r_排班.计划id, 0);
            v_号码     := r_排班.号码;
            n_安排存在 := 1;
          
            If v_上班时间 Is Not Null Then
              If v_合作单位 Is Not Null Then
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位计划控制
                    Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_合约存在
                    From 合作单位安排控制
                    Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_合约存在 := 0;
                  End;
                End If;
              End If;
            
              If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                If n_计划id <> 0 Then
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                Else
                  Begin
                    Select Sum(数量)
                    Into n_合作单位数量
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null);
                  Exception
                    When Others Then
                      n_合作单位数量 := 0;
                  End;
                End If;
                Begin
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                        Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                Exception
                  When Others Then
                    n_合约已挂数 := 0;
                End;
                If n_合作单位数量 = 0 Then
                  n_合作单位数量 := Null;
                End If;
                If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                Else
                  n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                End If;
              Else
                --合约单位
                If n_计划id <> 0 Then
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位计划控制
                    Where 计划id = n_计划id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                Else
                  Begin
                    Select 1
                    Into n_禁用
                    From 合作单位安排控制
                    Where 安排id = n_安排id And
                          限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                        '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                          Rownum < 2;
                  Exception
                    When Others Then
                      n_禁用 := 0;
                  End;
                End If;
                If Nvl(n_禁用, 0) = 0 Then
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                
                End If;
              End If;
            End If;
            n_合作单位数量 := 0;
            n_合约存在     := 0;
            n_禁用         := 0;
          End If;
        End Loop;
        v_上班时间 := Substr(v_上班时间, 2);
        If n_安排存在 = 1 Then
          v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                    '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 || '</YGS>' ||
                    '</PB>';
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    End If;
    v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    If Nvl(n_科室id, 0) = 0 Then
      --通过医生查找
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) < To_Date(Substr(v_启用时间, 1, Instr(v_启用时间, ' ') - 1), 'yyyy-mm-dd') Then
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                              a.安排id, a.计划id, a.号码, a.号类
                       From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称,
                                     Ap.号码, Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                              
                              From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                            Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                    Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                     Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.医生id = n_医生id And Ap.停用日期 Is Null And
                                           d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           Not Exists (Select Rownum
                                            From 挂号安排计划 Jh
                                            Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                     Union All
                                     Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                            Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                    Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                     Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And
                                           d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           (Jh.生效时间, Jh.安排id) =
                                           (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                            From 挂号安排计划 Sxjh
                                            Where Sxjh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                            Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                              Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                            病人挂号汇总 Hz, 收费价目 B
                       Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                             b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                       
                       ) Loop
            If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
              v_上班时间 := v_上班时间 || '+' || r_排班.排班;
              n_总已挂数 := n_总已挂数 + r_排班.已挂数;
              n_已挂数   := r_排班.已挂数;
              n_限号数   := r_排班.限号数;
              n_已约数   := r_排班.已约数;
              n_限约数   := r_排班.限约数;
              n_安排id   := Nvl(r_排班.安排id, 0);
              n_计划id   := Nvl(r_排班.计划id, 0);
              v_号码     := r_排班.号码;
              n_安排存在 := 1;
              If v_上班时间 Is Not Null Then
                If v_合作单位 Is Not Null Then
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位计划控制
                      Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位安排控制
                      Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  End If;
                End If;
              
                If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  Else
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  End If;
                Else
                  --合约单位
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  End If;
                  If Nvl(n_禁用, 0) = 0 Then
                    Begin
                      Select Count(1)
                      Into n_合约已挂数
                      From 病人挂号记录
                      Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                            Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                    Exception
                      When Others Then
                        n_合约已挂数 := 0;
                    End;
                    If n_计划id <> 0 Then
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位计划控制
                        Where 计划id = n_计划id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    Else
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位安排控制
                        Where 安排id = n_安排id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    End If;
                    If n_合作单位数量 = 0 Then
                      n_合作单位数量 := Null;
                    End If;
                    n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                  
                  End If;
                End If;
              End If;
              n_合作单位数量 := 0;
              n_合约存在     := 0;
              n_禁用         := 0;
            End If;
          End Loop;
          v_上班时间 := Substr(v_上班时间, 2);
          If n_安排存在 = 1 Then
            v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                      '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                      '</YGS>' || '</PB>';
          End If;
        Else
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          If v_合作单位 Is Null Then
            --非合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              --当天挂号
              For r_出诊 In (Select a.已挂数, a.限号数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已挂数, 0);
                n_限号数   := n_限号数 + r_出诊.限号数;
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --预约挂号
              For r_出诊 In (Select a.已约数, a.限号数, a.限约数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已约数, 0);
                n_限号数   := n_限号数 + Nvl(r_出诊.限约数, r_出诊.限号数);
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          Else
            --合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              For r_出诊 In (Select a.Id, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If r_出诊.限号数 - r_出诊.已挂数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + r_出诊.限号数 - r_出诊.已挂数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                    n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_安排存在 := 1;
                  Else
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
            
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --非当天
              For r_出诊 In (Select a.Id, a.已约数, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    --分时段非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 预约顺序号 Is Not Null And 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) <> 0;
                      If r_合作.数量 - n_Exists > 0 Then
                        n_剩余数   := n_剩余数 + r_合作.数量 - n_Exists;
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  Else
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已约数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限约数 - Nvl(r_出诊.已约数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          End If;
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    Else
      --通过科室+医生查找
      While (n_Daycount < n_查询天数) Loop
        If Trunc(d_开始时间 + n_Daycount) < To_Date(Substr(v_启用时间, 1, Instr(v_启用时间, ' ') - 1), 'yyyy-mm-dd') Then
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          n_安排存在 := 0;
          For r_排班 In (Select d_开始时间 + n_Daycount As 日期, a.排班, a.限号数, a.限约数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数,
                              a.安排id, a.计划id, a.号码, a.号类
                       
                       From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称,
                                     Ap.号码, Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数
                              
                              From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                            Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4',
                                                    Ap.周三, '5', Ap.周四, '6', Ap.周五, '7', Ap.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                                     Where Ap.科室id = Bm.Id(+) And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.医生id = n_医生id And Ap.科室id = n_科室id And Ap.停用日期 Is Null And
                                           d_开始时间 + n_Daycount Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Ap.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           Not Exists (Select Rownum
                                            From 挂号安排计划 Jh
                                            Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                                     Union All
                                     Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id,
                                            Jh.Id As 计划id, Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                            Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4',
                                                    Jh.周三, '5', Jh.周四, '6', Jh.周五, '7', Jh.周六, Null) As 排班,
                                            Nvl(Xz.限约数, Xz.限号数) As 限约数, Nvl(Xz.限号数, 0) As 限号数
                                     From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                                     Where Jh.安排id = Ap.Id And Sysdate + Nvl(Ap.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And
                                           Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And Jh.医生id = n_医生id And Ap.科室id = n_科室id And
                                           d_开始时间 + n_Daycount Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                           Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                           Xz.限制项目(+) =
                                           Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                                  '周三', '5', '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                      (Select Rownum
                                            From 挂号安排停用状态 Ty
                                            Where Ty.安排id = Ap.Id And d_开始时间 + n_Daycount Between Ty.开始停止时间 And Ty.结束停止时间) And
                                           (Jh.生效时间, Jh.安排id) =
                                           (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                            From 挂号安排计划 Sxjh
                                            Where Sxjh.审核时间 Is Not Null And
                                                  d_开始时间 + n_Daycount Between
                                                  Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                                  Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                            Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                              Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                            病人挂号汇总 Hz, 收费价目 B
                       Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_开始时间 + n_Daycount) And a.项目id = b.收费细目id And
                             b.终止日期 > d_开始时间 + n_Daycount And b.执行日期 <= d_开始时间 + n_Daycount
                       
                       ) Loop
            If v_号类 Is Null Or Instr(',' || v_号类 || ',', ',' || r_排班.号类 || ',') > 0 Then
              v_上班时间 := v_上班时间 || '+' || r_排班.排班;
              n_总已挂数 := n_总已挂数 + r_排班.已挂数;
              n_已挂数   := r_排班.已挂数;
              n_限号数   := r_排班.限号数;
              n_已约数   := r_排班.已约数;
              n_限约数   := r_排班.限约数;
              n_安排id   := Nvl(r_排班.安排id, 0);
              n_计划id   := Nvl(r_排班.计划id, 0);
              v_号码     := r_排班.号码;
              n_安排存在 := 1;
            
              If v_上班时间 Is Not Null Then
                If v_合作单位 Is Not Null Then
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位计划控制
                      Where 计划id = n_计划id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_合约存在
                      From 合作单位安排控制
                      Where 安排id = n_安排id And 合作单位 = v_合作单位 And Rownum < 2;
                    Exception
                      When Others Then
                        n_合约存在 := 0;
                    End;
                  End If;
                End If;
              
                If v_合作单位 Is Null Or Nvl(n_合约存在, 0) = 0 Then
                  If n_计划id <> 0 Then
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  Else
                    Begin
                      Select Sum(数量)
                      Into n_合作单位数量
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null);
                    Exception
                      When Others Then
                        n_合作单位数量 := 0;
                    End;
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                          Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  If n_合作单位数量 = 0 Then
                    n_合作单位数量 := Null;
                  End If;
                  If Trunc(d_开始时间 + n_Daycount) > Trunc(Sysdate) Then
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限约数 - n_已约数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  Else
                    n_剩余数 := Nvl(n_剩余数, 0) + n_限号数 - n_已挂数 - Nvl(n_合作单位数量, n_合约已挂数) + Nvl(n_合约已挂数, 0);
                  End If;
                Else
                  --合约单位
                  If n_计划id <> 0 Then
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位计划控制
                      Where 计划id = n_计划id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  Else
                    Begin
                      Select 1
                      Into n_禁用
                      From 合作单位安排控制
                      Where 安排id = n_安排id And
                            限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                          '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位 And 数量 = 0 And
                            Rownum < 2;
                    Exception
                      When Others Then
                        n_禁用 := 0;
                    End;
                  End If;
                  If Nvl(n_禁用, 0) = 0 Then
                    Begin
                      Select Count(1)
                      Into n_合约已挂数
                      From 病人挂号记录
                      Where 号别 = v_号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_开始时间 + n_Daycount) And
                            Trunc(d_开始时间 + n_Daycount + 1) - 1 / 60 / 60 / 24;
                    Exception
                      When Others Then
                        n_合约已挂数 := 0;
                    End;
                    If n_计划id <> 0 Then
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位计划控制
                        Where 计划id = n_计划id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    Else
                      Begin
                        Select Sum(数量)
                        Into n_合作单位数量
                        From 合作单位安排控制
                        Where 安排id = n_安排id And
                              限制项目 = Decode(To_Char(d_开始时间 + n_Daycount, 'D'), '1', '周日', '2', '周一', '3', '周二', '4',
                                            '周三', '5', '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
                      Exception
                        When Others Then
                          n_合作单位数量 := 0;
                      End;
                    End If;
                    If n_合作单位数量 = 0 Then
                      n_合作单位数量 := Null;
                    End If;
                    n_剩余数 := Nvl(n_剩余数, 0) + Nvl(n_合作单位数量, n_合约已挂数) - Nvl(n_合约已挂数, 0);
                  
                  End If;
                End If;
              End If;
              n_合作单位数量 := 0;
              n_合约存在     := 0;
              n_禁用         := 0;
            End If;
          End Loop;
          v_上班时间 := Substr(v_上班时间, 2);
          If n_安排存在 = 1 Then
            v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                      '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                      '</YGS>' || '</PB>';
          End If;
        Else
          n_安排存在 := 0;
          v_上班时间 := Null;
          n_总已挂数 := 0;
          n_已挂数   := 0;
          n_剩余数   := 0;
          n_限号数   := 0;
          n_已约数   := 0;
          n_限约数   := 0;
          If v_合作单位 Is Null Then
            --非合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              --当天挂号
              For r_出诊 In (Select a.已挂数, a.限号数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已挂数, 0);
                n_限号数   := n_限号数 + r_出诊.限号数;
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --预约挂号
              For r_出诊 In (Select a.已约数, a.限号数, a.限约数, a.上班时段
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                n_已挂数   := n_已挂数 + Nvl(r_出诊.已约数, 0);
                n_限号数   := n_限号数 + Nvl(r_出诊.限约数, r_出诊.限号数);
                v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                n_安排存在 := 1;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_限号数 - n_已挂数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          Else
            --合作单位
            If Trunc(d_开始时间 + n_Daycount) = Trunc(Sysdate) Then
              For r_出诊 In (Select a.Id, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If r_出诊.限号数 - r_出诊.已挂数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + r_出诊.限号数 - r_出诊.已挂数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                    n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_安排存在 := 1;
                  Else
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                    n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已挂数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限号数 - Nvl(r_出诊.已挂数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
            
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            Else
              --非当天
              For r_出诊 In (Select a.Id, a.已约数, a.已挂数, a.限号数, a.限约数, a.上班时段, a.是否序号控制
                           From 临床出诊记录 A, 临床出诊号源 B
                           Where a.出诊日期 = Trunc(d_开始时间 + n_Daycount) And a.号源id = b.Id And
                                 Sysdate + Nvl(b.预约天数, n_预约天数) >= d_开始时间 + n_Daycount And a.医生id = n_医生id And
                                 a.科室id = n_科室id And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间)) And
                                 Nvl(a.是否锁定, 0) = 0 And Exists
                            (Select 1
                                  From 临床出诊安排 M, 临床出诊表 N
                                  Where m.Id = a.安排id And m.出诊id = n.Id And n.发布时间 Is Not Null)) Loop
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_限号数
                  From 临床出诊挂号控制记录
                  Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_限号数 := n_限号数 * Nvl(r_出诊.限约数, r_出诊.限号数) / 100;
                  End If;
                  Select Count(1)
                  Into n_已挂数
                  From 病人挂号记录
                  Where 出诊记录id = r_出诊.Id And 记录状态 = 1 And 合作单位 = v_合作单位;
                  If Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数 < n_限号数 - n_已挂数 Then
                    n_剩余数 := n_剩余数 + Nvl(r_出诊.限约数, r_出诊.限号数) - r_出诊.已约数;
                  Else
                    n_剩余数 := n_剩余数 + n_限号数 - n_已挂数;
                  End If;
                  n_总已挂数 := n_总已挂数 + n_已挂数;
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
                If n_合约模式 = 3 Then
                  If r_出诊.是否序号控制 = 0 Then
                    --分时段非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 预约顺序号 Is Not Null And 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) <> 0;
                      If r_合作.数量 - n_Exists > 0 Then
                        n_剩余数   := n_剩余数 + r_合作.数量 - n_Exists;
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + n_Exists;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  Else
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_出诊.Id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1) Loop
                      Begin
                        Select 1
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_出诊.Id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0;
                      Exception
                        When Others Then
                          n_Exists := 0;
                      End;
                      If n_Exists = 1 Then
                        n_剩余数   := n_剩余数 + 1;
                        n_安排存在 := 1;
                      Else
                        n_总已挂数 := n_总已挂数 + 1;
                        n_安排存在 := 1;
                      End If;
                    End Loop;
                    v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  n_总已挂数 := n_总已挂数 + Nvl(r_出诊.已约数, 0);
                  n_剩余数   := n_剩余数 + r_出诊.限约数 - Nvl(r_出诊.已约数, 0);
                  v_上班时间 := v_上班时间 || '+' || r_出诊.上班时段;
                  n_安排存在 := 1;
                End If;
              End Loop;
              If v_上班时间 Is Not Null Then
                v_上班时间 := Substr(v_上班时间, 2);
              End If;
              If n_安排存在 = 1 Then
                v_Temp := v_Temp || '<PB>' || '<RQ>' || To_Char(Trunc(d_开始时间 + n_Daycount), 'YYYY-MM-DD') || '</RQ>' ||
                          '<SYHS>' || n_剩余数 || '</SYHS>' || '<SBSJ>' || v_上班时间 || '</SBSJ>' || '<YGS>' || n_总已挂数 ||
                          '</YGS>' || '</PB>';
              End If;
            End If;
          End If;
        End If;
        n_Daycount := n_Daycount + 1;
      End Loop;
    End If;
    v_Temp := '<PBLIST>' || v_Temp || '</PBLIST>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Docarrange;
/


--104114:胡俊勇,2016-12-19,超期发送收回
--102633:胡俊勇,2016-11-21,收回配液医嘱
--97556:胡俊勇,2016-06-23,超期收回已销帐的配液药品医嘱
Create Or Replace Procedure Zl_病人医嘱记录_收回
(
  --功能：将指定医嘱超期发送部分收回。如果上次发送没有产生费用，则仅收回医嘱的上次执行时间。
  --参数：
  --      收回量_IN=对西药、中成药为按住院单位的收回量,对中药为收回付数,对其它医嘱为收回总量或次数。
  --      医嘱ID_IN=每条要收回的医嘱记录的ID(明细存储的ID),对成药或配方,不一定包含给药途径或用法煎法(可能为叮嘱而未读取)
  --      上次时间_IN=医嘱超期发送部分收回后应该还原的上次执行时间(严格按频率计算得来),为空时表示被全部收回了。
  --      NO_IN=当收回要产生负数费用记录时，为新生成记录的单据号(供费用及药品使用),当前处理的只是新NO的一部份。
  --            因为药品可能分批,所以序号在处理时取。
  --            如果全是划价单（传入值为：调整划价单），则不产生负数单据，直接修改或删除划价单
  收回量_In     病人医嘱发送.发送数次%Type,
  医嘱id_In     病人医嘱记录.Id%Type,
  上次时间_In   病人医嘱记录.上次执行时间%Type,
  收回时间_In   Date,
  No_In         住院费用记录.No%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --收回医嘱对应的发送费用明细的剩余数量,按后产生的费用先收回
  --剩余数量没有排开已申请的数量部份，在产生新申请时覆盖原来的申请
  --对药品和卫材，对一个数量，可能存在未执行和已执行部分，需分别填写申请记录，且以未执行优先
  --执行标志=0-未执行,1-已执行；药品的有部分执行，以收发记录中的明细量区分为准；非药品的只优先处理未执行的
  Cursor c_Detail Is
    Select *
    From (With 医嘱费用记录 As (Select Max(Decode(b.记录状态, 2, 0, b.Id)) As 费用id, b.No, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                                 b.病人病区id, Sum(Nvl(b.付数, 1) * b.数次) As 剩余数量, b.收费类别, Max(Nvl(b.执行状态, 0)) As 执行状态, d.跟踪在用,
                                 c.诊疗类别, c.医嘱内容, c.单次用量, Max(b.记录状态) As 记录状态, Max(b.登记时间) As 登记时间, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 材料特性 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.材料id(+) And c.Id = 医嘱id_In And e.医嘱id(+) = b.医嘱序号 And
                                e.收费细目id(+) = b.收费细目id
                          Group By b.No, b.记录性质, Nvl(b.价格父号, b.序号), b.收费细目id, b.病人病区id, b.收费类别, d.跟踪在用, c.诊疗类别, c.医嘱内容,
                                   c.单次用量, e.收费方式
                          Having Sum(Nvl(b.付数, 1) * b.数次) > 0)
           Select 费用id, NO, 序号, 收费细目id, 病人病区id, 收费类别, 跟踪在用, 诊疗类别, 医嘱内容, 单次用量, 剩余数量, Null As 已执行量, Null As 未执行量,
                  执行状态 As 执行标志, 记录状态, 登记时间, 收费方式
           From 医嘱费用记录
           Where 收费类别 Not In ('5', '6', '7') And Not (收费类别 = '4' And Nvl(跟踪在用, 0) = 1)
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 0 As 已执行量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 未执行量, 0 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 已执行量, 0 As 未执行量, 1 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Not (Mod(b.记录状态, 3) = 1 And b.审核人 Is Null)
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0)
           Order By Decode(诊疗类别, '5', 0, '6', 0, '7', 0, 收费细目id), 执行标志, 登记时间 Desc;


  Cursor c_Applay(v_费用ids Varchar2) Is
    Select a.费用id, b.No, b.序号, a.数量, a.申请时间, a.申请类别
    From 病人费用销帐 A, 住院费用记录 B
    Where a.费用id = b.Id And a.申请部门id = a.审核部门id And a.申请时间 = 收回时间_In And
          a.费用id In (Select * From Table(Cast(f_Num2list(v_费用ids) As Zltools.t_Numlist)))
    Order By NO, 序号;

  --包含指定药品长嘱发送时产生的相关费用及药品/卫材记录信息(因多次发送有多条记录,分批的已在界面禁止)
  --药品医嘱填写了"病人医嘱发送"记录,对应的给药途径不一定填写了的(可能为叮嘱),且NO不同。
  --因为要收回的次数可能包含了多次发送的内容,所以要将多次发送的收发记录都取出来，多次发送时，划价的先收回（修改或删除）
  Cursor c_Drug Is
    Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装, x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量,
           b.Id As 收发id, b.单据, b.药品id, b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No,
           a.序号, a.收费细目id, a.执行状态 As 执行标志
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱发送 C, 病人信息 D, 药品规格 X
    Where c.医嘱id = 医嘱id_In And a.No = c.No And a.记录性质 = c.记录性质 And a.记录状态 In (0, 1, 3) And a.医嘱序号 + 0 = 医嘱id_In And
          a.No = b.No And a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
          a.病人id = d.病人id And b.药品id = x.药品id(+)
    Order By a.记录状态, b.No Desc, b.Id Desc;

  --包含非药长嘱(含给药途径)发送时所产生的费用(因多个收入而有多条记录)
  --对非药医嘱,直接收回指定量,不管多次发送(如果多次发送价格不同,则收回的价格是以最后次的；不然就要根据多个收入依次减收回量)。
  --卫材本身是售价单位，无需住院单位转换
  --非药长嘱都填写了发送记录(除开了叮嘱及护理等级)
  --一天只收一次或一次发送只收一次的项目暂时不支持负数申请
  Cursor c_Other Is
    With 医嘱费用记录 As
     (Select a.No, a.序号, a.记录状态, a.收费细目id, a.Id As 费用id, a.数次 As 剩余数量, Nvl(a.执行状态, 0) As 执行状态, a.医嘱序号, b.发送号,
             c.数量 As 对照数量, Nvl(c.收费方式, 0) As 收费方式, a.收费类别
      From 住院费用记录 A, 病人医嘱发送 B, 病人医嘱计价 C
      Where a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱序号 + 0 = b.医嘱id And b.医嘱id = 医嘱id_In And a.医嘱序号 = c.医嘱id(+) And
            a.收费细目id = c.收费细目id(+))
    Select a.No, a.序号, a.费用id, a.剩余数量, a.收费细目id, a.记录状态, a.执行状态, a.对照数量, a.收费方式, a.收费类别
    From (Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 In (1, 3) And a.发送号 = (Select Max(发送号) From 医嘱费用记录 Where 记录状态 In (1, 3))
           Union All
           Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 = 0) A
    Order By a.收费细目id, a.序号, a.记录状态;

  --按序号排序是为了产生新记录时,填写同一收费细目的不同收入项目的价格父号

  --该游标用于处理费用相关汇总表
  Cursor c_Money
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Nvl(应收金额, 0)) As 应收金额, Sum(Nvl(实收金额, 0)) As 实收金额
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 1 And NO = No_In And 序号 Between v_Start And v_End
    Group By 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  --系统参数指定执行后需要自动审核的划价费用：用于非药医嘱，包含对应的药品及卫材费用
  Cursor c_Verify
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select NO, 序号
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 0 And NO = No_In And 价格父号 Is Null And 序号 Between v_Start And v_End;

  Cursor c_Compound
  (
    相关id_In       病人医嘱记录.相关id%Type,
    执行终止时间_In 病人医嘱记录.执行终止时间%Type,
    配药id_In       输液配药记录.Id%Type
  ) Is
    Select b.费用id, b.药品id As 收费细目id, a.数量, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id As 配药id, f.No,
           Nvl(f.价格父号, f.序号) As 序号, f.记录状态 As 记录状态, f.执行状态 As 执行标志
    From 输液配药内容 A, 药品收发记录 B, 药品规格 C, 收费项目目录 D, 输液配药记录 E, 住院费用记录 F
    Where a.收发id = b.Id And b.药品id = c.药品id And c.药品id = d.Id And e.Id = a.记录id And f.No = b.No And f.Id = b.费用id And
          e.医嘱id = 相关id_In And e.执行时间 > 执行终止时间_In And e.Id = 配药id_In;

  v_Dec      Number;
  v_First    Number;
  v_划价类别 Varchar2(255);

  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_单次用量 病人医嘱记录.单次用量%Type;
  v_跟踪在用 材料特性.跟踪在用%Type;

  v_费用序号 住院费用记录.序号%Type;
  v_收发序号 药品收发记录.序号%Type;
  v_费用id   住院费用记录.Id%Type;
  v_实收金额 住院费用记录.实收金额%Type;

  v_开始序号 住院费用记录.序号%Type;
  v_结束序号 住院费用记录.序号%Type;

  v_医嘱执行 病人医嘱发送.执行状态%Type;

  v_剂量系数 药品规格.剂量系数%Type;
  v_住院包装 药品规格.住院包装%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_结帐参数       Zlparameters.参数值%Type;
  v_配液药销帐申请 Zlparameters.参数值%Type;
  v_结帐金额       住院费用记录.结帐金额%Type;

  v_收费细目id   住院费用记录.收费细目id%Type;
  v_剩余数量     住院费用记录.数次%Type;
  v_收回数量     住院费用记录.数次%Type;
  v_当前数量     住院费用记录.数次%Type;
  v_当前付数     住院费用记录.付数%Type;
  v_费用ids      Varchar2(4000);
  v_组id         病人医嘱记录.Id%Type;
  v_对照数量     病人医嘱计价.数量%Type;

  v_Delno    Varchar2(4000);
  v_Temp     Varchar2(4000);
  v_收费内容 Varchar2(4000);
  v_No       住院费用记录.No%Type;
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;

  n_相关id       病人医嘱记录.相关id%Type;
  d_执行终止时间 病人医嘱记录.执行终止时间%Type;
  n_药品id       病人医嘱记录.收费细目id%Type;
  b_输液配药记录 Boolean;
  d_收回时间     病人医嘱记录.执行终止时间%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  n_Count        Number;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Procedure 负数收发记录_Insert
  (
    费用id_In     Number,
    批次_In       药品收发记录.批次%Type,
    分批_In       药品规格.药房分批%Type,
    批号_In       药品收发记录.批号%Type,
    效期_In       药品收发记录.效期%Type,
    最大效期_In   药品规格.最大效期%Type,
    收发id_In     药品收发记录.Id%Type,
    病人id_In     住院费用记录.病人id%Type,
    主页id_In     住院费用记录.主页id%Type,
    药品id_In     药品收发记录.药品id%Type,
    库房id_In     药品收发记录.库房id%Type,
    单据_In       药品收发记录.单据%Type,
    姓名_In       病人信息.姓名%Type,
    对方部门id_In 药品收发记录.对方部门id%Type,
    收费类别_In   住院费用记录.收费类别%Type,
    划价类别_In   Varchar
  ) Is
    v_批次   药品收发记录.批次%Type;
    v_效期   药品收发记录.效期%Type;
    v_批号   药品收发记录.批号%Type;
    v_优先级 身份.优先级%Type;
  Begin
    --确定批次
    If Nvl(批次_In, 0) <> 0 And 分批_In = 0 Then
      --原分批,现不分批
      v_批次 := Null;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    Elsif Nvl(批次_In, 0) = 0 And 分批_In = 1 Then
      --原不分批,现分批
      Select 药品收发记录_Id.Nextval Into v_批次 From Dual;
      Select To_Char(Sysdate, 'YYYYMMDD') Into v_批号 From Dual;
      If 最大效期_In Is Not Null Then
        v_效期 := Trunc(Sysdate + 最大效期_In * 30);
      Else
        v_效期 := Null;
      End If;
    Else
      v_批次 := 批次_In;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    End If;
  
    Insert Into 药品收发记录
      (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人, 填制日期,
       费用id, 单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期)
      Select 药品收发记录_Id.Nextval, 1, 单据, No_In, v_收发序号, 库房id, 对方部门id, 入出类别id, -1, 药品id, v_批次, 产地, v_批号, v_效期, v_当前付数,
             -1 * v_当前数量, -1 * v_当前数量, 零售价, Round(-1 * v_当前付数 * v_当前数量 * 零售价, v_Dec), '超期发送收回', v_人员姓名, 收回时间_In, 费用id_In,
             单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期
      From 药品收发记录
      Where ID = 收发id_In;
  
    --药品库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - (-1 * v_当前付数 * v_当前数量)
    Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(v_批次, 0) And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 性质, 可用数量, 批次, 效期)
      Values
        (库房id_In, 药品id_In, 1, v_当前付数 * v_当前数量, v_批次, v_效期);
    End If;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = 单据_In And NO = No_In And 库房id + 0 = 库房id_In;
  
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (单据_In, No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, 对方部门id_In, 库房id_In, 收回时间_In,
         Decode(Nvl(Instr(划价类别_In, Decode(收费类别_In, '4', '4', '5')), 0), 0, 1, 0), 0);
    End If;
  
    v_收发序号 := v_收发序号 + 1;
  End;
Begin
  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --检查是否是输液配液记录，并是否已经锁定
  Select 医嘱内容 Into v_医嘱内容 From 病人医嘱记录 Where ID = 医嘱id_In;
  Select Count(1)
  Into n_Count
  From 输液配药记录 A, 病人医嘱记录 B
  Where a.医嘱id = b.Id And 医嘱id = 医嘱id_In And a.执行时间 > b.执行终止时间 And a.是否锁定 = 1;

  If n_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能超期收回。';
    Raise Err_Custom;
  End If;

  If Nvl(收回量_In, 0) > 0 Then
    --判断是否是输液配药药品(输液配制中心药品统一走销帐申请)
    b_输液配药记录 := False;
    Select a.相关id, a.执行终止时间, Max(b.收费细目id)
    Into n_相关id, d_执行终止时间, n_药品id
    From 病人医嘱记录 A, 住院费用记录 B
    Where a.Id = 医嘱id_In And a.Id = b.医嘱序号(+)
    Group By a.相关id, a.执行终止时间;
    If n_相关id Is Not Null Then
      If d_执行终止时间 Is Not Null Then
        d_收回时间       := 收回时间_In;
        v_配液药销帐申请 := zl_GetSysParameter('配液输液单配药后允许销帐申请', 1345);
        Select Count(1) Into n_Count From 输液配药记录 E Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间;
        If n_Count > 0 Then
          b_输液配药记录 := True;
          For X In (Select e.Id As 配药id, e.操作状态
                    From 输液配药记录 E
                    Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间 And Nvl(e.操作状态, 0) In (1, 2, 3, 4, 5, 6, 7, 8)) Loop
            If Not (x.操作状态 In (4, 5, 6, 7, 8) And Nvl(v_配液药销帐申请, '0') = '0') Then
              For r_Compound In c_Compound(n_相关id, d_执行终止时间, x.配药id) Loop
                If x.操作状态 = 1 Then
                  n_申请类别 := 0;
                Else
                  n_申请类别 := 1;
                End If;
                Select Count(1)
                Into n_Count
                From 病人费用销帐
                Where 费用id = r_Compound.费用id And 收费细目id = r_Compound.收费细目id And
                      申请时间 =
                      (Select Max(操作时间) From 输液配药状态 A Where a.配药id = r_Compound.配药id And a.操作类型 = 9);
                If n_Count = 0 Then
                  Zl_病人费用销帐_Insert(r_Compound.费用id, r_Compound.收费细目id, r_Compound.病人病区id, r_Compound.数量, v_人员姓名, d_收回时间,
                                   n_申请类别, Null, r_Compound.配药id);
                  If x.操作状态 = 1 Then
                    --未发药的，自动审核。
                    Zl_病人费用销帐_Audit(r_Compound.费用id, d_收回时间, v_人员姓名, d_收回时间, 1, 1, n_申请类别);
                    Zl_住院记帐记录_Delete(r_Compound.No, r_Compound.序号 || ':' || r_Compound.数量 || ':' || r_Compound.配药id,
                                     v_人员编号, v_人员姓名, 2, Null, Null, d_收回时间);
                  End If;
                End If;
              End Loop;
              --由于不同批次（执行时间）申请时，申请时间和费用ID有唯一约束，所以同时销帐多个批次时，依次加一秒
              d_收回时间 := d_收回时间 + 1 / 24 / 60 / 60;
            End If;
          End Loop;
        End If;
      End If;
    End If;
    --a.销帐申请收回模式
    --输液配药记录单独进行销帐
    If b_输液配药记录 = False Then
      If No_In Is Null Then
        v_结帐参数 := zl_GetSysParameter(23);
        --根据收回数量对照原始费用进行分摊申请
        For r_Detail In c_Detail Loop
          --确定该收费细目ID的收回总数量
          If Nvl(v_收费细目id, 0) <> r_Detail.收费细目id And (r_Detail.诊疗类别 Not In ('5', '6', '7') Or Nvl(v_收费细目id, 0) = 0) Then
            --数量未分摊完成
            If v_收费细目id Is Not Null And v_收回数量 > 0 Then
              v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
              Raise Err_Custom;
            End If;
            --药品收回总量是以最后发送规格为准计算的，以此计算出收回售价数量
            Begin
              Select 剂量系数, 住院包装 Into v_剂量系数, v_住院包装 From 药品规格 Where 药品id = r_Detail.收费细目id;
            Exception
              When Others Then
                Null;
            End;
            --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
            If r_Detail.收费方式 = 0 Then
              If r_Detail.诊疗类别 = '7' Then
                --中药配方药品：付数*单量
                v_收回数量 := Round(收回量_In * r_Detail.单次用量 / Nvl(v_剂量系数, 1), 5);
              Else
                If r_Detail.诊疗类别 Not In ('5', '6') Then
                  Select Nvl(Max(数量), 1)
                  Into v_对照数量
                  From 病人医嘱计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id;
                Else
                  v_对照数量 := 1;
                End If;
                v_收回数量 := Round(收回量_In * Nvl(v_住院包装, 1), 5) * v_对照数量;
              End If;
            Else
              Select Nvl(Sum(数量), 0)
              Into v_收回数量
              From 医嘱执行计价
              Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id And
                    要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
            
              v_收回数量 := Round(v_收回数量, 5);
            
            End If;
            v_医嘱内容 := r_Detail.医嘱内容;
          End If;
        
          --该收费细目的每个费用明细分摊收回
          If v_收回数量 > 0 Then
            --检查对应费用是否已结帐，当禁止时
            v_结帐金额 := 0;
            If v_结帐参数 = '2' And r_Detail.记录状态 <> 0 Then
              Select Sum(结帐金额)
              Into v_结帐金额
              From 住院费用记录
              Where NO = r_Detail.No And 记录性质 In (2, 12) And Nvl(价格父号, 序号) = r_Detail.序号;
            End If;
          
            If Nvl(v_结帐金额, 0) = 0 Then
              If r_Detail.收费类别 In ('5', '6', '7') Or r_Detail.收费类别 = '4' And r_Detail.跟踪在用 = 1 Then
                --药品和跟踪在用的卫材
                If r_Detail.执行标志 = 0 Then
                  v_剩余数量 := r_Detail.未执行量;
                Elsif r_Detail.执行标志 = 1 Then
                  v_剩余数量 := r_Detail.已执行量;
                End If;
              Else
                --普通费用
                v_剩余数量 := r_Detail.剩余数量;
              End If;
              If v_收回数量 > v_剩余数量 Then
                v_当前数量 := v_剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              --系统参数决定执行后是否审核划价单，所以，已执行的仍然可能是划价单
              If r_Detail.执行标志 = 0 And r_Detail.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Detail.No || ',' || r_Detail.序号 || ':' || v_当前数量;
              Else
                If Not (r_Detail.收费类别 = '7' And r_Detail.执行标志 <> 0) Then
                  Zl_病人费用销帐_Insert(r_Detail.费用id, r_Detail.收费细目id, r_Detail.病人病区id, v_当前数量, v_人员姓名, 收回时间_In,
                                   r_Detail.执行标志);
                End If;
              End If;
              v_费用ids := v_费用ids || ',' || r_Detail.费用id;
            End If;
          End If;
          v_收费细目id := r_Detail.收费细目id;
        End Loop;
      
        --数量未分摊完成
        If v_收回数量 > 0 Then
          v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
          Raise Err_Custom;
        End If;
        --本科的销帐申请自动审核
        If zl_GetSysParameter('超期收回费用本科自动审核', 1254) = '1' And v_费用ids Is Not Null Then
          For r_Applay In c_Applay(Substr(v_费用ids, 2)) Loop
            Zl_病人费用销帐_Audit(r_Applay.费用id, r_Applay.申请时间, v_人员姓名, 收回时间_In, 1, 1, r_Applay.申请类别);
            v_Delno := v_Delno || '|' || r_Applay.No || ',' || r_Applay.序号 || ':' || r_Applay.数量;
          End Loop;
        End If;
      Else
        ---b.负数收回模式-------------------------------------------------------------------------------------------------------
        --如果全是划价单，就不用产生负数冲销单据
        If No_In = '调整划价单' Then
          --未审核的划价单，先进行修改或删除，可能多次发送为不同的NO,为了计算每次的收回量，需要按收费细目ID排序
          For r_Price In (Select c.诊疗类别, b.No, b.序号, b.收费细目id, Nvl(b.付数, 1) * b.数次 As 剩余数量, c.单次用量, d.剂量系数, d.住院包装,
                                 c.医嘱内容, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 药品规格 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.药品id(+) And b.记录状态 = 0 And c.Id = a.医嘱id And
                                b.医嘱序号 = e.医嘱id(+) And b.收费细目id = e.收费细目id(+)
                          Order By 收费细目id, NO Desc) Loop
            If Nvl(v_收费细目id, 0) <> r_Price.收费细目id Then
              --数量未分摊完成
              If v_收费细目id Is Not Null And v_收回数量 > 0 Then
                v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
                Raise Err_Custom;
              End If;
              --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
              If r_Price.收费方式 = 0 Then
                If r_Price.诊疗类别 = '7' Then
                  --中药配方药品：付数*单量
                  v_收回数量 := Round(收回量_In * r_Price.单次用量 / Nvl(r_Price.剂量系数, 1), 5);
                Else
                  If r_Price.诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(收回量_In * Nvl(r_Price.住院包装, 1), 5) * v_对照数量;
                End If;
              Else
                Select Nvl(Sum(数量), 0)
                Into v_收回数量
                From 医嘱执行计价
                Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id And
                      要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
              
                v_收回数量 := Round(v_收回数量, 5);
              End If;
              v_医嘱内容 := r_Price.医嘱内容;
            End If;
            If v_收回数量 > 0 Then
              If v_收回数量 > r_Price.剩余数量 Then
                v_当前数量 := r_Price.剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              v_Delno    := v_Delno || '|' || r_Price.No || ',' || r_Price.序号 || ':' || v_当前数量;
            End If;
            v_收费细目id := r_Price.收费细目id;
          End Loop;
          --数量未分摊完成
          If v_收回数量 > 0 Then
            v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
            Raise Err_Custom;
          End If;
        Else
          --负数冲销，可能存在划价单与记帐单混合的情况
          --金额小数位数
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;
          --生成划价单系统参数
          Select zl_GetSysParameter(80) Into v_划价类别 From Dual;
          v_开始序号 := Null;
          v_结束序号 := Null;
        
          Select a.诊疗类别, a.单次用量, b.跟踪在用
          Into v_诊疗类别, v_单次用量, v_跟踪在用
          From 病人医嘱记录 A, 材料特性 B
          Where ID = 医嘱id_In And a.收费细目id = b.材料id(+);
        
          If v_诊疗类别 In ('5', '6', '7') Or (v_诊疗类别 = '4' And Nvl(v_跟踪在用, 0) = 1) Then
            --药品、卫材
            -----------------------------------------------------------------------------------------------------
            v_收回数量 := Null;
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            --一条医嘱的药品只有一行，这里的循环是为了处理多次发送的情况，分批药品在界面已禁用负数收回
            For r_Drug In c_Drug Loop
              --初始化要收回的总数量(零售数量)
              v_First := 0;
              If v_收回数量 Is Null Then
                If v_诊疗类别 = '7' Then
                  v_收回数量 := Round(收回量_In * v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  If v_诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Drug.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(收回量_In * r_Drug.住院包装, 5) * v_对照数量;
                End If;
                v_First := 1;
              End If;
            
              --如果第一次数量就足够，则按付数处理，否则付数不好处理
              If v_收回数量 > r_Drug.数量 Then
                v_当前付数 := 1;
                v_当前数量 := r_Drug.数量;
                v_收回数量 := v_收回数量 - r_Drug.数量;
              Else
                If v_First = 1 And v_诊疗类别 = '7' Then
                  v_当前付数 := 收回量_In;
                  v_当前数量 := Round(v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  v_当前付数 := 1;
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := 0;
              End If;
            
              If r_Drug.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Drug.No || ',' || r_Drug.序号 || ':' || v_当前数量 * v_当前付数;
              Else
                If Not (v_诊疗类别 = '7' And r_Drug.执行标志 <> 0) Then
                
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  负数收发记录_Insert(v_费用id, r_Drug.批次, r_Drug.分批, r_Drug.批号, r_Drug.效期, r_Drug.最大效期, r_Drug.收发id,
                                r_Drug.病人id, r_Drug.主页id, r_Drug.药品id, r_Drug.库房id, r_Drug.单据, r_Drug.姓名, r_Drug.对方部门id,
                                v_诊疗类别, v_划价类别);
                
                  --住院费用记录
                  -------------------------------------------------------------------------------------
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, 1, 0),
                           v_费用序号, Null, Null, 多病人单, 2, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
                           收费细目id, 计算单位, 保险项目否, 保险大类id, v_当前付数, -1 * v_当前数量, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价,
                           Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Null, 1,
                           开单部门id, 开单人, 收回时间_In, 收回时间_In, 执行部门id, 0, 医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员姓名, Null)
                    From 住院费用记录
                    Where ID = r_Drug.费用id;
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                End If;
                If v_收回数量 <= 0 Then
                  Exit;
                End If;
              End If;
            End Loop;
          
            If v_收回数量 <> 0 Then
              --没有收回所有数量,收发记录本身有问题(如记录不全或数量为负)
              Null;
            End If;
          Else
            --其它非药医嘱(包括给药途径，及绑定的卫材等)
            -----------------------------------------------------------------------------------------------------
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            --取费用序号
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            For r_Other In c_Other Loop
              If Nvl(v_收费内容, '0') <> r_Other.收费细目id || ',' || r_Other.序号 Then
                --根据最近一次发送的费用记录，按需要收回的数量全部收回
                --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
                If r_Other.收费方式 = 0 Then
                  v_收回数量 := 收回量_In * Nvl(r_Other.对照数量, 1);
                Else
                  Select Nvl(Sum(数量), 0)
                  Into v_收回数量
                  From 医嘱执行计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Other.收费细目id And
                        要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
                End If;
              End If;
            
              If v_收回数量 > 0 Then
                If r_Other.记录状态 = 0 Then
                  If v_收回数量 > r_Other.剩余数量 Then
                    v_当前数量 := r_Other.剩余数量;
                  Else
                    v_当前数量 := v_收回数量;
                  End If;
                Else
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := v_收回数量 - v_当前数量;
                v_当前付数 := 1;
              
                If r_Other.记录状态 = 0 Then
                  v_Delno := v_Delno || '|' || r_Other.No || ',' || r_Other.序号 || ':' || v_当前数量;
                Else
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  --住院费用记录:按理如果收回量大于了上次发送量,则不正确
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  If r_Other.收费类别 In ('4', '5', '6', '7') Then
                    For r_Otherdrug In (Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装,
                                               x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量, b.Id As 收发id, b.单据, b.药品id, b.对方部门id,
                                               b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No, a.序号,
                                               a.收费细目id
                                        From 住院费用记录 A, 药品收发记录 B, 病人信息 D, 药品规格 X
                                        Where a.Id = r_Other.费用id And a.记录状态 In (0, 1, 3) And a.No = b.No And
                                              a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And
                                              (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And a.病人id = d.病人id And
                                              b.药品id = x.药品id(+)
                                        Order By a.记录状态, b.No Desc, b.Id Desc) Loop
                      负数收发记录_Insert(v_费用id, r_Otherdrug.批次, r_Otherdrug.分批, r_Otherdrug.批号, r_Otherdrug.效期,
                                    r_Otherdrug.最大效期, r_Otherdrug.收发id, r_Otherdrug.病人id, r_Otherdrug.主页id,
                                    r_Otherdrug.药品id, r_Otherdrug.库房id, r_Otherdrug.单据, r_Otherdrug.姓名,
                                    r_Otherdrug.对方部门id, r_Other.收费类别, v_划价类别);
                    End Loop;
                  End If;
                  --医嘱已执行，收回的费用也填为已执行：不包含药品和跟踪在用的卫材，因为实际发放表示执行
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行时间, 执行人, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, 1, 0), v_费用序号, Null,
                           Decode(a.价格父号, Null, Null, v_费用序号 + a.价格父号 - a.序号), a.多病人单, 2, a.病人id, a.主页id, a.标识号, a.姓名,
                           a.性别, a.年龄, a.床号, a.病人病区id, a.病人科室id, a.费别, a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, 1,
                           -1 * v_当前数量, a.加班标志, a.附加标志, a.婴儿费, a.收入项目id, a.收据费目, a.标准单价,
                           Round(-1 * v_当前数量 * a.标准单价, v_Dec), Round(-1 * v_当前数量 * a.标准单价, v_Dec), Null, 1, a.开单部门id,
                           a.开单人, 收回时间_In, 收回时间_In, a.执行部门id,
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, 0, 1), Decode(Instr(',5,6,7,', a.收费类别), 0, 1, 0)),
                                   0),
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, 收回时间_In),
                                           Decode(Instr(',5,6,7,', a.收费类别), 0, 收回时间_In, Null)), Null),
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, v_人员姓名),
                                           Decode(Instr(',5,6,7,', a.收费类别), 0, v_人员姓名, Null)), Null), a.医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员姓名, Null)
                    From 住院费用记录 A, 材料特性 B
                    Where a.Id = r_Other.费用id And a.收费细目id = b.材料id(+);
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                  v_医嘱执行 := r_Other.执行状态; --多个收费项目的执行状态是一样的
                End If;
              
                v_收费内容 := r_Other.收费细目id || ',' || r_Other.序号;
              End If;
            End Loop;
          
            --如果医嘱已执行，则按系统参数执行后自动审核费用：包含已执行医嘱对应的药品和卫材费用。
            -----------------------------------------------------------------------------------------------------
            If Nvl(v_医嘱执行, 0) = 1 And v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
              If zl_GetSysParameter(81) = '1' Then
                For r_Verify In c_Verify(v_开始序号, v_结束序号) Loop
                  Zl_住院记帐记录_Verify(r_Verify.No, v_人员编号, v_人员姓名, r_Verify.序号, Null, 收回时间_In);
                End Loop;
              End If;
            End If;
          End If;
        
          --处理费用汇总表
          -----------------------------------------------------------------------------------------------------
          If v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
            --最后统一处理费用相关汇总表
            For r_Money In c_Money(v_开始序号, v_结束序号) Loop
              --病人余额
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 性质 = 1 And 类型 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Money.病人id, 1, 2, r_Money.实收金额, 0);
              End If;
            
              --病人未结费用
              Update 病人未结费用
              Set 金额 = Nvl(金额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 主页id = r_Money.主页id And Nvl(病人病区id, 0) = Nvl(r_Money.病人病区id, 0) And
                    Nvl(病人科室id, 0) = Nvl(r_Money.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Money.开单部门id, 0) And
                    Nvl(执行部门id, 0) = Nvl(r_Money.执行部门id, 0) And 收入项目id + 0 = r_Money.收入项目id And 来源途径 + 0 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人未结费用
                  (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
                Values
                  (r_Money.病人id, r_Money.主页id, r_Money.病人病区id, r_Money.病人科室id, r_Money.开单部门id, r_Money.执行部门id,
                   r_Money.收入项目id, 2, r_Money.实收金额);
              End If;
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End If;

  --过程Zl_住院记帐记录_Delete，不支持每次删除一行的循环处理（序号重整），必须把一个单据要删除的序号一次性传入
  If Not v_Delno Is Null Then
    v_Temp := '';
    v_No   := '';
    For r_Price In (Select /*+ rule*/
                     C1 As NO, C2 As 序号数量
                    From Table(f_Str2list2(Substr(v_Delno, 2), '|', ','))
                    Order By NO) Loop
      If v_No Is Not Null And v_No <> r_Price.No Then
        Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
        v_No := '';
      End If;
      If v_No Is Null Then
        v_No   := r_Price.No;
        v_Temp := r_Price.序号数量;
      Else
        v_Temp := v_Temp || ',' || r_Price.序号数量;
      End If;
    End Loop;
    If Not v_No Is Null Then
      Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
    End If;
  End If;

  --处理医嘱的上次执行时间:给药途径等可能因为未发送而没调用收回过程。
  -----------------------------------------------------------------------------------------------------
  Select Nvl(相关id, ID) Into v_组id From 病人医嘱记录 Where ID = 医嘱id_In;
  Update 病人医嘱记录 Set 上次执行时间 = 上次时间_In Where ID = v_组id Or 相关id = v_组id;

  --删除医嘱执行时间
  If 上次时间_In Is Null Then
    --全部收回
    Delete From 医嘱执行时间 Where 医嘱id = v_组id;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In;
  Else
    --可能收回多次发送的数据
    Delete From 医嘱执行时间 Where 医嘱id = v_组id And 要求时间 > 上次时间_In;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 要求时间 > 上次时间_In;
  End If;
  --处理输液配液记录的批次问题，每个医嘱都进行调用，在过程里面只处理了输液配液的医嘱
  Zl_输液配药记录_批次调整(医嘱id_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_收回;
/

--101446:刘尔旋,2016-10-21,失约号处理
--97856:刘尔旋,2016-06-23,预约清空序号状态的问题
Create Or Replace Procedure Zl_挂号序号状态_Delete
(
  操作方式_In Number := 0,
  号别_In     病人挂号记录.号别%Type := Null
) As
  n_预约有效时间 Number(5);
  n_失约用于挂号 Number(2);
  n_挂号有效天数 Number(5);
Begin
  If 操作方式_In = 0 Then
    --清除历史记录
    Delete 挂号序号状态 Where 日期 < Trunc(Sysdate);
  Else
    --清除失约号
    n_预约有效时间 := Nvl(zl_GetSysParameter('预约有效时间', 1111), 0);
    n_失约用于挂号 := Nvl(zl_GetSysParameter('失约用于挂号', 1111), 0);
    If n_失约用于挂号 <> 0 Then
      If 号别_In Is Null Then
        For c_失效预约 In (Select b.号码, b.日期, b.序号
                       From 病人挂号记录 A, 挂号序号状态 B
                       Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Trunc(Sysdate) And a.记录性质 = 2 And
                             a.号别 = b.号码 And a.号序 = b.序号 And Trunc(a.预约时间) = Trunc(b.日期) And b.状态 = 2) Loop
          Delete From 挂号序号状态
          Where 日期 = c_失效预约.日期 And 序号 = c_失效预约.序号 And 状态 = 2 And 号码 = c_失效预约.号码;
        End Loop;
      Else
        For c_失效预约 In (Select b.号码, b.日期, b.序号
                       From 病人挂号记录 A, 挂号序号状态 B
                       Where a.预约时间 - 1 / 24 / 60 * n_预约有效时间 < Sysdate And a.预约时间 > Trunc(Sysdate) And a.记录性质 = 2 And
                             a.号别 = b.号码 And a.号序 = b.序号 And a.号别 = 号别_In And Trunc(a.预约时间) = Trunc(b.日期) And b.状态 = 2) Loop
          Delete From 挂号序号状态
          Where 日期 = c_失效预约.日期 And 序号 = c_失效预约.序号 And 状态 = 2 And 号码 = c_失效预约.号码;
        End Loop;
      End If;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号序号状态_Delete;
/

--102117:胡俊勇,2016-11-02,出院医嘱发送前检查
--87472:余伟节,2016-06-21,出院后不更新病案主页的病案状态
Create Or Replace Procedure Zl_病人变动记录_Out
(
  病人id_In       病案主页.病人id%Type,
  主页id_In       病案主页.主页id%Type,
  疾病id_In       病人诊断记录.疾病id%Type,
  诊断id_In       病人诊断记录.诊断id%Type,
  出院诊断_In     病人诊断记录.诊断描述%Type,
  出院情况_In     病人诊断记录.出院情况%Type,
  中医疾病id_In   病人诊断记录.疾病id%Type,
  中医诊断id_In   病人诊断记录.诊断id%Type,
  中医诊断_In     病人诊断记录.诊断描述%Type,
  中医出院情况_In 病人诊断记录.出院情况%Type,
  是否疑诊_In     病案主页.是否确诊%Type, --同时作为西医的是否疑诊
  出院方式_In     病案主页.出院方式%Type,
  出院时间_In     病案主页.出院日期%Type,
  随诊标志_In     病案主页.随诊标志%Type, --0/NULL-不随诊，1-月，2-年，3-周，4-天，9-终身
  随诊期限_In     病案主页.随诊期限%Type,
  尸检标志_In     病案主页.尸检标志%Type,
  操作员编号_In   病人变动记录.操作员编号%Type,
  操作员姓名_In   病人变动记录.操作员姓名%Type,
  确诊日期_In     病案主页.确诊日期%Type := Null
) As
  -----------------------------------------------------------
  --说明：病人出院
  -----------------------------------------------------------
  Cursor c_Bedinfo Is
    Select 病区id, 床号 From 床位状况记录 Where 病人id = 病人id_In;

  v_Count Number;
  Err_Custom Exception;
  v_Error      Varchar2(255);
  v_随诊期限   Date;
  v_应发时间   Date;
  v_共享号     Zlsystems.共享号%Type;
  v_年龄       病人信息.年龄%Type;
  v_Sql        Varchar2(1000);
  v_住院医师   Varchar2(20);
  v_出院科室   Number;
  v_姓名       病人信息.姓名%Type;
  n_婴儿科室id 病案主页.婴儿科室id%Type;
Begin
  --首先判断该病人是否已出院
  Select Count(*) Into v_Count From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null;

  If v_Count = 0 Then
    v_Error := '操作失败,该病人可能已经出院！';
    Raise Err_Custom;
  End If;

  --首先判断该病人是否处于等待转科或入科状态
  Select Count(*)
  Into v_Count
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In And 出院日期 Is Null And Nvl(状态, 0) In (0, 3);
  If v_Count = 0 Then
    v_Error := '操作失败,该病人正处于转科状态或尚未入科,不能出院！';
    Raise Err_Custom;
  End If;

  --临床路径正在执行时不允许出院
  Select Max(b.状态)
  Into v_Count
  From 病案主页 a, 病人临床路径 b
  Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.病人id = b.病人id And a.主页id = b.主页id And a.出院科室id = b.科室id;
  If v_Count = 1 Then
    v_Error := '该病人的临床路径正在执行中,不能出院。';
    Raise Err_Custom;
  End If;

  --母婴分离婴儿未出院则母亲不能出院
  Select 婴儿科室id Into n_婴儿科室id From 病案主页 Where 病人id = 病人id_In And 主页id = 主页id_In;
  If n_婴儿科室id Is Not Null Then
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 a, 诊疗项目目录 b
    Where a.病人id = 病人id_In And a.主页id = 主页id_In And a.诊疗项目id = b.Id And b.操作类型 = '5' And b.类别 = 'Z' And
          Nvl(a.婴儿, 0) <> 0 And a.医嘱状态 <> 4;
    If v_Count = 0 Then
      v_Error := '该病人的婴儿还在其他科室，并未下达出院医嘱,请先给婴儿下达出院医嘱后再出院。';
      Raise Err_Custom;
    End If;
  End If;

  v_Count := Nvl(Zl_Getsysparameter('特殊医嘱发送前检查未生效医嘱', 1254), 0);
  If v_Count = 1 Then
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱状态 = 1 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在未校对的医嘱，请删除或校对后再继续。';
      Raise Err_Custom;
    End If;
  
    v_姓名 := Null;
    Select Max(姓名)
    Into v_姓名
    From 病人医嘱记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 医嘱期效 = 1 And 医嘱状态 In (2, 3) And Nvl(执行标记, 0) <> -1 And 
	Nvl(执行性质, 0) <> 0 And Rownum = 1;
    If v_姓名 Is Not Null Then
      v_Error := v_姓名 || '存在校对后未发送的临嘱，请发送或作废后再继续。';
      Raise Err_Custom;
    End If;
  End If;

  --判断是否产生住院日报
  Select Nvl(出院科室id, 入院科室id), 住院医师
  Into v_出院科室, v_住院医师
  From 病案主页
  Where 病人id = 病人id_In And 主页id = 主页id_In;
  Select Zl_住院日报_Count(v_出院科室, 出院时间_In) Into v_Count From Dual;
  If v_Count > 0 Then
    v_Error := '已产生业务时间内的住院日报,不能办理该业务!';
    Raise Err_Custom;
  End If;

  --判断是否与病案系统共享
  Begin
    Select 共享号 Into v_共享号 From Zlsystems Where Floor(编号 / 100) = 3;
  Exception
    When Others Then
      Null;
  End;
  --出院变动
  Update 病人变动记录
  Set 终止时间 = 出院时间_In, 终止原因 = 1, 终止人员 = 操作员姓名_In, 上次计算时间 = Decode(Sign(Nvl(上次计算时间, 出院时间_In) - 出院时间_In), 1, Null, 上次计算时间)
  Where 病人id = 病人id_In And 主页id = 主页id_In And 终止时间 Is Null;

  --床位记录
  For r_Bedrow In c_Bedinfo Loop
    Update 床位状况记录
    Set 状态 = '空床', 病人id = Null, 科室id = Decode(共用, 1, Null, 科室id)
    Where 病区id = r_Bedrow.病区id And 床号 = r_Bedrow.床号;
  End Loop;

  --病案主页
  Update 病案主页
  Set 状态 = 0, 出院日期 = 出院时间_In, 出院方式 = 出院方式_In,
      住院天数 = Decode(Trunc(出院时间_In) - Trunc(入院日期), 0, 1, Trunc(出院时间_In) - Trunc(入院日期)), 随诊标志 = 随诊标志_In,
      随诊期限 = Decode(随诊期限_In, 0, Null, 随诊期限_In), 尸检标志 = 尸检标志_In, 是否确诊 = Decode(Nvl(是否疑诊_In, 0), 0, 0, 1),
      确诊日期 = 确诊日期_In
  Where 病人id = 病人id_In And 主页id = 主页id_In;

  --产生病历书写时机
  Zl_电子病历时机_Insert(病人id_In, 主页id_In, 2, '出院', v_出院科室, v_住院医师, 出院时间_In, 出院时间_In);
  --增加随诊记录
  If v_共享号 = 100 Then
    If Nvl(随诊期限_In, 0) <> 0 Then
      If 随诊标志_In = 1 Then
        v_随诊期限 := Add_Months(出院时间_In, 随诊期限_In);
      Elsif 随诊标志_In = 2 Then
        v_随诊期限 := Add_Months(出院时间_In, 12 * 随诊期限_In);
      Elsif 随诊标志_In = 3 Then
        v_随诊期限 := 出院时间_In + 7 * 随诊期限_In;
      Elsif 随诊标志_In = 4 Then
        v_随诊期限 := 出院时间_In + 随诊期限_In;
      End If;
    Else
      v_随诊期限 := To_Date('3000-1-1', 'YYYY-MM-DD');
    End If;
  
    If 随诊标志_In = 1 Or 随诊标志_In = 2 Or 随诊标志_In = 3 Or 随诊标志_In = 4 Then
      If v_随诊期限 > Add_Months(出院时间_In, 3) Then
        v_应发时间 := Trunc(Add_Months(出院时间_In, 3));
      Else
        v_应发时间 := v_随诊期限;
      End If;
      v_Sql := 'Insert Into 随诊记录 (ID, 病人id, 主页id, 随诊期限, 应发时间) Values (随诊记录_Id.Nextval,:1,:2,:3,:4)';
      Execute Immediate v_Sql
        Using 病人id_In, 主页id_In, To_Date(To_Char(v_随诊期限, 'YYYY-MM-DD'), 'YYYY-MM-DD'), To_Date(To_Char(v_应发时间, 'YYYY-MM-DD'), 'YYYY-MM-DD');
    End If;
  End If;
  --病人信息
  v_年龄 := Zl_Age_Calc(病人id_In);
  Update 病人信息
  Set 当前科室id = Null, 当前病区id = Null, 当前床号 = Null, 出院时间 = 出院时间_In, 年龄 = v_年龄, 在院 = Null
  Where 病人id = 病人id_In;
  --在院病人
  Delete From 在院病人 Where 病人id = 病人id_In;
  --出院诊断
  If 出院诊断_In Is Not Null Or 疾病id_In Is Not Null Or 诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 3 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 3, 1, 疾病id_In, 诊断id_In, 出院诊断_In, Decode(Nvl(是否疑诊_In, 0), 0, 1, 0),
       出院情况_In, Sysdate, 操作员姓名_In);
  End If;

  --中医出院诊断
  If 中医诊断_In Is Not Null Or 中医疾病id_In Is Not Null Or 中医诊断id_In Is Not Null Then
    Delete From 病人诊断记录
    Where 病人id = 病人id_In And 主页id = 主页id_In And 诊断类型 = 13 And 诊断次序 = 1 And 记录来源 = 2;
    Insert Into 病人诊断记录
      (Id, 病人id, 主页id, 记录来源, 诊断类型, 诊断次序, 疾病id, 诊断id, 诊断描述, 是否疑诊, 出院情况, 记录日期, 记录人)
    Values
      (病人诊断记录_Id.Nextval, 病人id_In, 主页id_In, 2, 13, 1, 中医疾病id_In, 中医诊断id_In, 中医诊断_In, Null, 中医出院情况_In, Sysdate, 操作员姓名_In);
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_病人变动记录_Out;
/

--101938:张德婷,2016-12-09,修正静配中心跨批次数据问题的错误
--99542:张德婷,2016-08-31,修正启用备用批次后，所有批次都为备用批次
--98699:张德婷,2016-07-27,肿瘤药品临时医嘱也进静配配制
--97579:张德婷,2016-06-21,修正当设置的频次为所有频次时优先级不正确的问题
CREATE OR REPLACE Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Lableno     Varchar2(200);
  v_Maxbatch    Number;
  v_Curdose     Number;
  v_Sumdose     Number;
  v_Drugcount   Number;
  v_Currdate    Date;
  n_Needcheck   Number;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean;
  n_Sum         Number(8);
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_上次发送号  病人医嘱发送.发送号%Type;
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_输液总量       Number;
  v_大输液剂型     Varchar2(2000);
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  n_Tpn处置方式    Number := 0;
  v_药品类型       varchar2(20);
  n_打包药品批次   number(1);
  n_特殊药品批次   number(1);
  n_优先级         number:=999;
  n_自动排批       number:=0;
  n_科室id       number:=0;
  n_row            number(2);
  n_备用批次       number:=0;
  n_剩余数量       number:=0;
  n_单次数量     Number:=0;
  n_累计数量       number:=0;
  n_医嘱id         Number:=0;
  n_填写数量       number:=0;
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And  c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C
    Where e.医嘱id = b.id And b.病人id = a.病人id And b.诊疗项目id = c.Id And
          b.相关id = v_相关id And e.发送号 = 发送号_In 
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.id = n_医嘱id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;
    
  Cursor c_原始收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;

  Function Zl_Getpivaworkbatch(执行时间_In In Date,药品类型_In In varchar2:=null) Return Number As



    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包,药品类型 From 配药工作批次 Where 启用 = 1 and 配置中心id=部门id_In Order By 批次;




    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');

    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 and 配置中心id=部门id_In;

    For v_配药批次 In c_配药批次 Loop
      v_Batch     := 0;



      if 药品类型_In is null then
        --当天发送的医嘱发送到备用批次
        if Trunc(执行时间_In) > v_Currdate or n_备用批次=0 then
          if v_配药批次.批次<>'0'and v_配药批次.药品类型 is null then
            v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
            v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');

            If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
              v_Batch := v_配药批次.批次;
              n_打包  := v_配药批次.打包;
              Exit When v_Batch > 0;
            End If;
          end if;
        end if;
      else
        if 药品类型_In=v_配药批次.药品类型 then
          v_Batch := v_配药批次.批次;
          n_打包  := v_配药批次.打包;
          Exit When v_Batch > 0;
        end if;
      end if;
    End Loop;

    If v_Batch = 0 and (n_打包药品批次<>1 or n_备用批次=1) Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;

  Function Zl_GetFirst(配药id_In In number,科室id_In In number) Return Number As
    n_First     Number;
    n_科室id    number;
    Cursor c_优先级 Is
      select 科室id,配药类型,优先级,频次 from 输液药品优先级 where (科室id=科室id_In or 科室id=0) order by 科室id,优先级 desc;

    r_优先级 c_优先级%RowType;
  Begin
   n_First:=0;
   for r_优先级 in c_优先级 loop
     if n_科室id<>0 and r_优先级.科室id=0 then
       exit;
     end if;
     n_科室id:=r_优先级.科室id;

     for r_配药记录 in(select distinct D.配药类型,E.执行频次 from 输液配药记录 A,输液配药内容 B,药品收发记录 C,输液药品属性 D,病人医嘱记录 E  where A.医嘱id=E.Id and A.id=B.记录ID and B.收发ID=C.id and C.药品ID=D.药品ID and a.id=配药id_In) loop
       if instr(r_配药记录.配药类型,r_优先级.配药类型,1)>0 and (instr(r_优先级.频次,r_配药记录.执行频次,1)>0 or r_优先级.频次='所有频次') then
         n_First:= r_优先级.优先级;
         exit;
       end if;
     end loop;
   end loop;

   if n_First=0 then
     n_First:=999;
   end if;
   Return(n_First);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_输液总量       := Zl_To_Number(Nvl(zl_GetSysParameter('同批次输液总量', 1345), 0));
  v_大输液剂型     := Nvl(zl_GetSysParameter('大输液药品剂型', 1345), '');
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源科室', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  n_Tpn处置方式    := Zl_To_Number(Nvl(zl_GetSysParameter('静脉营养药物处置方式', 1345), 0));
  n_打包药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('单个药品，不予配置药品及根据给药时间没有配药批次的输液单默认为0批次并打包', 1345), 0));
  n_特殊药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('特殊药品按药品类型指定批次', 1345), 0));
  n_自动排批:= Zl_To_Number(Nvl(zl_GetSysParameter('启动自动排批', 1345), 0));
  n_备用批次:=Zl_To_Number(Nvl(zl_GetSysParameter('当天发送的医嘱产生的输液单全部到备用批次', 1345), 0));
  v_医嘱ids  := 医嘱id_In;
  v_当前病人 := '';
  n_发送次数:=0;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  --先将原收发记录的序号增大，新的收发记录产生后再删除
  --Update 药品收发记录
  --Set 序号 = 序号 + 10000
  --Where ID In (Select \*+rule *\
  --             Distinct c.Id
  --             From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, Table(f_Num2list(医嘱id_In)) F
  --             Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
  --                   c.单据 = 9 And c.审核日期 Is Null And a.相关id = f.Column_Value And b.发送号 = 发送号_In And c.序号 < 10000);

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
    n_病人id := v_医嘱记录.病人id;
    n_科室id:= v_医嘱记录.病人科室id;

    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B,住院费用记录 C
    Where c.收费细目id = b.药品id And c.医嘱序号 =A.id and A.相关id= v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;

    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;

    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;

    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人科室id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;

    v_药品类型:=null;
    for r_药品类型 in (Select decode(nvl(D.是否肿瘤药,0),0,'','肿瘤药') 药品类型
    From 病人医嘱记录 A, 药品规格 B,住院费用记录 C,药品特性 D
    Where c.收费细目id = b.药品id And B.药名ID=D.药名ID And c.医嘱序号 =A.id and A.相关id= v_医嘱记录.相关id) loop
      if r_药品类型.药品类型 is not null then
        v_药品类型:=r_药品类型.药品类型;
        v_Continue := 1;
      end if;
    end loop;

    if v_药品类型 is null then
       If v_医嘱记录.是否tpn = 2 Then
        v_药品类型:='营养药';
        v_Continue := 1;
      end if;
    end if;

    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;


      If v_Continue = 1 Then
        --v_Count := Zl_Gettransexenumber(v_医嘱记录.开始执行时间, v_医嘱记录.首次时间, v_医嘱记录.末次时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;

        v_Nodosage := 0;

        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;

          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            --v_执行时间 := Zl_Gettransexetime(v_医嘱记录.开始执行时间, v_执行时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;

          v_批次 := 0;
          --药品类型不为空，则根据药品类型匹配批次

          if (v_药品类型 is null or n_特殊药品批次=0) and n_自动排批=0 then
            If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
              b_Change      := True;
              d_Old执行时间 := v_执行时间;

              Select /*+ rule*/
               Count(a.要求时间)
              Into n_Cur
              From 医嘱执行时间 A
              Where a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间+1) - 1 / 24 / 60 / 60;

              Select Count(a.要求时间)
              Into n_Sum
              From 医嘱执行时间 A
              Where a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;

              Select Count(Distinct a.摆药单号)
              Into n_摆药单
              From 输液配药记录 A
              Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
              If n_Cur <> n_Sum Or  n_摆药单 > 1 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And

                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;

              End If;
            End If;

            If b_Change = True Then
              b_Change := True;
              n_病人id := v_医嘱记录.病人id;
              Select Count(ID)

              Into n_Sum
              From 输液配药记录
              Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
              If n_Sum = 0 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And

                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;

              End If;



              If b_Change = True Then
                --检查输液单是否调整到打包状态
                Select Count(ID)
                Into n_Sum
                From 输液配药记录
                Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And
                      打包时间 Is Not Null;
                If n_Sum <> 0 Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                End If;

                Select Count(医嘱id)
                Into n_Cur
                From 医嘱执行时间
                Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
                Select Count(医嘱id)
                Into n_Sum
                From 医嘱执行时间
                Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
                If n_Sum <> n_Cur Then
                  Update 输液配药记录
                  Set 是否调整批次 = 1
                  Where 医嘱id In
                        (Select ID
                         From 病人医嘱记录
                         Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                        执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                  b_Change := False;
                End If;
              End If;
            End If;

            If (v_保持上次批次 = 1 Or b_Change = True) and n_自动排批=0 Then
              --取上次的批次
              Begin
                Select Distinct 配药批次
                Into v_批次
                From 输液配药记录 A
                Where 医嘱id = v_医嘱记录.相关id And
                      发送号 = (Select Distinct Max(发送号)
                             From 输液配药记录
                             Where 医嘱id = v_医嘱记录.相关id And 发送号 <> v_医嘱记录.发送号) And
                      To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_执行时间, 'hh24:mi:ss');
              Exception
                When Others Then
                  v_批次 := 0;
              End;
            End If;

            If v_批次 = 0 Then
              v_批次 := Zl_Getpivaworkbatch(v_执行时间);

              --同病人同批次总输液量控制，超过则分配到下个批次
              If v_输液总量 > 0 And Not v_大输液剂型 Is Null And v_批次 < v_Maxbatch Then
                Begin
                  Select /*+rule */
                   Sum(单量) As 单量
                  Into v_Curdose
                  From (Select Distinct c.Id, c.单量
                         From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                         Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id And
                               e.药名id = f.药名id And b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And
                               f.药品剂型 = g.Column_Value And a.相关id = v_相关id And b.发送号 = v_发送号);
                Exception
                  When Others Then
                    v_Curdose := 0;
                End;

                Begin
                  Select /*+rule */
                   Sum(单量) As 单量
                  Into v_Sumdose
                  From (Select Distinct a.Id, a.单量
                         From 药品收发记录 A, 病人医嘱记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 药品特性 F, Table(f_Str2list(v_大输液剂型)) G
                         Where c.Id = d.记录id And a.Id = d.收发id And c.医嘱id = b.Id And a.药品id + 0 = e.药品id And
                               e.药名id = f.药名id And b.病人id + 0 = v_医嘱记录.病人id And f.药品剂型 = g.Column_Value And
                               c.执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And c.配药批次 = v_批次);
                Exception
                  When Others Then
                    v_Sumdose := 0;
                End;

                If v_Sumdose > 0 And v_Sumdose + v_Curdose > v_输液总量 Then
                  v_批次 := v_批次 + 1;
                End If;
              End If;
            End If;


          elsif v_药品类型 is not null and n_特殊药品批次=1 then
            --药品类型不为空，直接根据药品类型匹配批次
            v_批次 := Zl_Getpivaworkbatch(sysdate,v_药品类型);
          else
            v_批次 := Zl_Getpivaworkbatch(v_执行时间);
          end if;  

          Select Count(医嘱id)
          Into n_发送次数
          From 医嘱执行时间
          Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
          Order By 要求时间;

          If n_发送次数 > 99 Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;

          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;

          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_批次;
          End If;

          If (Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0) and (v_药品类型 is null or n_特殊药品批次=0) Then
            n_是否打包     := 1;
            d_手工打包时间 := Sysdate;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;

          --如果是TPN不管其他条件如何都设置为配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;

          if v_批次=0 then
             n_是否打包:=1;
          end if;
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, v_批次, v_Maxno, n_调整批次, n_是否打包,
             d_手工打包时间, 1, 核查人_In, 核查时间_In);

          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
          
          For v_单个医嘱记录 In c_单个医嘱记录 Loop
            n_医嘱id:=v_单个医嘱记录.医嘱id;
            n_累计数量:=0;
            n_剩余数量:=0;
            
            Select  sum(c.实际数量) Into n_sum
            From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D
            Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And
            b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.id = n_医嘱id And b.发送号 = v_医嘱记录.发送号 And c.序号 < 1000;
        
            --产生配药记录对应的药品记录
            For v_收发记录 In c_收发记录 Loop
              If v_收发记录.是否不予配置 = 1 Then
                v_Nodosage := 1;
              End If;

              Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
              n_累计数量:=n_累计数量+v_收发记录.数量;
              
              If n_剩余数量=0 Then
                n_剩余数量:=n_sum/v_Count;
              End If;
              n_单次数量:=n_sum/v_Count;

              If n_累计数量 >=n_sum/v_Count*I Then
                n_Count := n_Count + 1;
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
                   产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                         效期, 付数, n_剩余数量, n_剩余数量, 成本价,成本价*n_剩余数量, 扣率, 零售价, 零售价*n_剩余数量, 差价*(实际数量/n_剩余数量),
                         '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                         领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间



                  From 药品收发记录
                  Where ID = v_收发记录.收发id;

                  Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_剩余数量);

                  n_剩余数量:=0;
                  Exit;
                Elsif n_累计数量>(n_sum/v_Count*(I-1)) Then
                  n_Count := n_Count + 1;
                  n_填写数量:= n_累计数量-(n_sum/v_Count*(I-1))-(n_单次数量-n_剩余数量);
                  Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期,
                   产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期,
                         效期, 付数, n_填写数量,n_填写数量, 成本价, 成本价*n_填写数量, 扣率, 零售价, 零售价*n_填写数量, 差价*(实际数量/n_填写数量),
                         '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式, 发药窗口,
                         领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间



                  From 药品收发记录
                  Where ID = v_收发记录.收发id;

                  Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_填写数量);

                  n_剩余数量:=n_剩余数量-n_填写数量;
                End If;
            End Loop;
          End Loop;
          n_优先级:=Zl_GetFirst(v_配药id,v_医嘱记录.病人科室id);
          update 输液配药记录 set 优先级=n_优先级 where id=v_配药id;

        End Loop;

        For v_收发记录 In c_原始收发记录 Loop
          n_单据 := v_收发记录.单据;

          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;

        --单个药品或者不予配置的药品默认为0批次
        select count(收发id) into n_Row from 输液配药内容 where 记录id=v_配药id;
        if (v_Nodosage = 1 or n_row=1) and n_打包药品批次=1 then
          Update 输液配药记录 Set 配药批次 = 0,是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 and 操作状态<2;
        end if;
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录 Set 是否打包 = 1 Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 and 操作状态<2;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

  if n_自动排批=1 then
    Zl_输液配药记录_自动排批(n_病人id,n_科室id,部门id_In,v_执行时间);
  end if;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--97707:刘尔旋,2016-06-21,服务窗新增退费申请审核接口
Create Or Replace Procedure Zl_Third_Charge_Delapply
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  ---入参：
  ---<IN> 
  ---  <BRID></BRID>        //病人ID
  ---  <JSKLB></JSKLB >　//结算卡类别(暂固定传“支付宝”，同医疗卡类别名称，主要用于不同平台的区分)
  ---  <SQSM></ SQSM >      //固定传“支付宝退款申请”
  ---  <FYLIST>
  ---    <FY>
  ---      <DJH> </DJH>   //单据号
  ---      <DJLX></DJLX>   //单据类型
  ---      <JE></JE>       //单据金额
  ---    </FY>
  ---  </FYLIST>
  ---</IN>
  ---出参:
  ---<OUTPUT>
  ---  <ERROR><MSG></MSG></ERROR> //error节点为空表示退费申请成功
  ---</OUTPUT>
  --------------------------------------------------------------------------------------------------
  n_病人id     门诊费用记录.病人id%Type;
  v_结算卡类别 Varchar2(100);
  n_卡类别id   医疗卡类别.Id%Type;
  v_申请说明   病人退费申请.申请原因%Type;
  n_金额       Number(8, 2);
  n_Klbid      Number(8);
  n_结帐id     Number(8);
  v_姓名       Varchar2(10);
  x_Templet    Xmltype; --模板XML
  v_Temp       Varchar2(1000);
  v_Err_Msg    Varchar2(200);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  ---获取基本信息
  Select To_Number(Extractvalue(Value(A), 'IN/BRID')), Extractvalue(Value(A), 'IN/JSKLB'),
         Extractvalue(Value(A), 'IN/SQSM')
  Into n_病人id, v_结算卡类别, v_申请说明
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Select ID Into n_卡类别id From 医疗卡类别 Where 名称 = v_结算卡类别;
  Select 姓名 Into v_姓名 From 病人信息 Where 病人id = n_病人id;

  ---退费申请检查
  For Mx In (Select Extractvalue(b.Column_Value, '/FY/DJH') As 单据号,
                    To_Number(Extractvalue(b.Column_Value, '/FY/DJLX')) As 单据类型,
                    To_Number(Extractvalue(b.Column_Value, '/FY/JE')) As 金额
             From Table(Xmlsequence(Extract(Xml_In, '/IN/FYLIST/FY'))) B) Loop
  
    If Mx.单据号 Is Null Then
      v_Err_Msg := '未确定指定退费申请的单据号,不能退费申请!';
      Raise Err_Item;
    End If;
  
    Begin
      Select a.结帐id, Sum(a.实收金额)
      Into n_结帐id, n_金额
      From 门诊费用记录 A
      Where a.No = Mx.单据号 And a.记录性质 = Mx.单据类型 And a.病人id = n_病人id And a.记录状态 In (1, 3)
      Group By a.结帐id;
    Exception
      When Others Then
        v_Err_Msg := '未确定指定退费申请的单据号,不能退费申请!';
        Raise Err_Item;
    End;
  
    If Mx.金额 <> n_金额 Then
      v_Err_Msg := '申请退费金额不正确，退费申请失败!';
      Raise Err_Item;
    End If;
  
    Select Distinct 卡类别id Into n_Klbid From 病人预交记录 Where 结帐id = n_结帐id;
  
    If n_卡类别id <> n_Klbid Then
      v_Err_Msg := '申请退费的单据不是由' || v_结算卡类别 || '结算，不能进行退费申请!';
      Raise Err_Item;
    End If;
  
    Zl_病人退费申请_Apply(0, Mx.单据号, Mx.单据类型, v_姓名, Sysdate, v_申请说明);
  End Loop;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '<ERROR><MSG>' || v_Err_Msg || '</MSG></ERROR>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Charge_Delapply;
/

--97532:陈刘,2016-06-21,数据来源为0,3 处理方式相同
CREATE OR REPLACE Procedure Zl_病人护理数据_Update
(
  文件id_In   In 病人护理数据.文件id%Type,
  发生时间_In In 病人护理数据.发生时间%Type,
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，签名记录=5，审签记录=15
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容；37或38/37
  体温部位_In In 病人护理明细.体温部位%Type := Null,
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  审签_In     In Number := 0,
  操作员_In   In 病人护理数据.保存人%Type := Null,
  记录组号_In In 病人护理明细.记录组号%Type := Null, --适用分类汇总(一条数据对应多条相同项目的明细)
  相关序号_In In 病人护理明细.相关序号%Type := Null, --适用分类汇总(记录汇总项目关联的名称项目序号)
  未记说明_In In 病人护理明细.未记说明%Type := Null --入量导入存储医嘱ID:发送号
) Is
  Intins      Number(18);
  Int共用     Number(1);
  n_Newid     病人护理数据.Id%Type;
  n_Oldid     病人护理数据.Id%Type;
  n_行数      病人护理打印.行数%Type;
  n_Mutilbill Number(1);
  n_Syntend   Number(1);
  n_Synchro   Number(1);

  n_汇总类别     病人护理数据.汇总类别%Type;
  v_科室id       部门表.Id%Type;
  v_保存人       人员表.姓名%Type;
  v_记录人       人员表.姓名%Type;
  n_文件id       病人护理数据.文件id%Type;
  n_记录id       病人护理数据.Id%Type;
  n_明细id       病人护理明细.Id%Type;
  n_来源id       病人护理明细.来源id%Type;
  v_数据来源     病人护理明细.数据来源%Type;
  n_最高版本     病人护理明细.开始版本%Type;
  n_项目性质     护理记录项目.项目性质%Type;
  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  --提取该病人当前科室所有未结束的护理文件，且文件开始时间小于等于记录发生时间的文件列表供同步数据使用
  Cursor Cur_Fileformats Is
    Select a.Id As 格式id, b.Id As 文件id, a.保留, a.子类, b.婴儿
    From 病历文件列表 A, 病人护理文件 B, 病人护理文件 C, 病人护理数据 D
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id <> c.Id And b.结束时间 Is Null And b.开始时间 <= d.发生时间 And
          (a.通用 = 1 Or (a.通用 = 2 And b.科室id = c.科室id)) And c.病人id = b.病人id And c.主页id = b.主页id And c.婴儿 = b.婴儿 And
          c.Id = d.文件id And d.Id = n_记录id And c.Id = 文件id_In
    Order By a.编号;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --取记录ID
  Int共用     := 0;
  n_记录id    := 0;
  n_Mutilbill := 0;
  n_Syntend   := 0;
  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;

  --如果是对应多份护理文件值为1，表示需同步其它护理文件；否则不处理文件同步
  n_Mutilbill := Zl_To_Number(zl_GetSysParameter('对应多份护理文件', 1255));
  --如果允许多份护理文件之间数据同步,则自动同步,否则不同步
  n_Syntend := Zl_To_Number(zl_GetSysParameter('允许数据同步', 1255));

  Begin
    Select ID, 汇总类别
    Into n_记录id, n_汇总类别
    From 病人护理数据
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 And 审签_In = 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '你无权修改他人登记的护理数据！';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否入科
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '59', 'YYYY-MM-DD HH24:MI:SS') >= a.开始时间 And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '00', 'YYYY-MM-DD HH24:MI:SS') < = Nvl(a.终止时间, Sysdate) Or
            a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or 发生时间_In > d_婴儿出院时间 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;

  --如果数据来源<>0则退出
  n_来源id := 0;
  If n_记录id > 0 Then
    Begin
      Select 数据来源, Nvl(来源id, 0)
      Into v_数据来源, n_来源id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0);
    Exception
      When Others Then
        v_数据来源 := 0;
    End;
    If v_数据来源 > 0 And n_来源id > 0 Then
      Return;
    End If;
  End If;

  --取最高版本
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1, Count(b.Id)
  Into n_最高版本, Intins
  From 病人护理明细 A, 病人护理数据 B
  Where b.Id = n_记录id And a.记录id = b.Id And Mod(a.记录类型, 10) = 5;

  --目前已经签名的数据不能修改，只有在审签模式下进行修改，即审签_In=1
  If 审签_In <> 1 And Intins > 0 Then
    v_Error := '发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 所对应的数据已经签名或审签，不能继续操作！' || Chr(13) || Chr(10) ||
               '这可能是由于网络并发操作引起的，请刷新后再试！';
    Raise Err_Custom;
  End If;
  Intins := 0;

  --无内容时,要清除数据（审签回退时会自动清除审签过程中修改的数据，所以此处只需考虑普签即可）
  If 记录内容_In Is Null Then
    Begin
      Select ID
      Into n_明细id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      --无数据退出
      When Others Then
        Return;
    End;
  
    --查找除了本条要删除的数据，是否还存其他有效的数据，如果存在只删除本条数据，否则删除此发生时间对应的所有数据。
    Select Count(ID)
    Into Intins
    From 病人护理明细
    Where 记录id = n_记录id And Mod(记录类型, 10) <> 5 And 终止版本 Is Null And ID <> n_明细id;
    If Intins = 0 Then
      Delete From 病人护理明细 Where 记录id = n_记录id;
    Else
      Delete From 病人护理明细 Where ID = n_明细id;
    End If;
  
    Delete From 病人护理数据 A
    Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理明细 B Where b.记录id = a.Id);
  
    --如果是删除签名后修改产生的最后一条数据,则应将签名记录的终止版本清为空
    Begin
      Select 1
      Into Intins
      From 病人护理明细
      Where 开始版本 = n_最高版本 And 终止版本 Is Null And 记录类型 = 1 And 记录id = n_记录id;
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Update 病人护理明细 Set 终止版本 = Null Where 记录类型 = 5 And 开始版本 = n_最高版本 - 1 And 记录id = n_记录id;
    End If;
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --清除共用数据
    --############
    For Rsdel In (Select Distinct 记录id From 病人护理明细 Where 来源id = n_明细id) Loop
    
      Delete 病人护理明细 Where 来源id = n_明细id And 记录id = Rsdel.记录id;
      --删除对应的打印数据
      Begin
        Select Count(*) Into Intins From 病人护理明细 Where 记录id = Rsdel.记录id;
      Exception
        When Others Then
          Intins := 0;
      End;
      If Intins = 0 Then
        --提取清除数据对应的文件ID
        Begin
          Select b.Id, a.保留
          Into n_文件id, Intins
          From 病历文件列表 A, 病人护理文件 B, 病人护理数据 C
          Where a.Id = b.格式id And b.Id = c.文件id And c.Id = Rsdel.记录id;
        Exception
          When Others Then
            n_文件id := 0;
        End;
        Delete 病人护理数据 Where ID = Rsdel.记录id;
        If Intins <> -1 Then
          Zl_病人护理打印_Update(n_文件id, 发生时间_In, 1, 1);
        End If;
      End If;
    End Loop;
  Else
    --检查录入的项目是否属于该记录单
    Begin
      Select 1
      Into Intins
      From (Select b.项目序号
             From 病历文件结构 A, 护理记录项目 B
             Where a.要素名称 = b.项目名称 And b.项目序号 = 项目序号_In And
                   父id = (Select b.Id
                          From 病人护理文件 A, 病历文件结构 B
                          Where a.Id = 文件id_In And a.格式id = b.文件id And b.父id Is Null And b.对象序号 = 4)
             Union
             Select 项目序号
             From 护理记录项目
             Where 项目性质 = 2 And 项目序号 = 项目序号_In);
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Return;
    End If;
    If n_记录id = 0 Then
      Select 病人护理数据_Id.Nextval Into n_记录id From Dual;
    
      Insert Into 病人护理数据
        (ID, 文件id, 发生时间, 最后版本, 保存人, 保存时间)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_最高版本, v_保存人, Sysdate);
    End If;
  
    --插入本次登记的病人护理明细
    Update 病人护理明细
    Set 记录内容 = 记录内容_In, 数据来源 = 数据来源_In, 未记说明 = 未记说明_In, 记录人 = v_保存人, 记录时间 = Sysdate
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    If Sql%RowCount = 0 Then
      Select 病人护理明细_Id.Nextval Into n_明细id From Dual;
      Insert Into 病人护理明细
        (ID, 记录id, 记录类型, 项目分组, 项目id, 相关序号, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录组号, 体温部位, 数据来源, 共用, 未记说明, 开始版本, 终止版本,
         记录人, 记录时间)
        Select n_明细id, n_记录id, 记录类型_In, a.分组名, a.项目id, 相关序号_In, a.项目序号, Upper(a.项目名称), a.项目类型, 记录内容_In, a.项目单位, 0,
               记录组号_In, 体温部位_In, 数据来源_In, Nvl(b.共用, 0), 未记说明_In, n_最高版本, Null, v_保存人, Sysdate
        From 护理记录项目 A, 病人护理明细 B
        Where a.项目序号 = b.项目序号(+) And b.终止版本(+) Is Null And b.记录id(+) = n_记录id And a.项目序号 = 项目序号_In And Rownum < 2;
    End If;
    Select ID
    Into n_明细id
    From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    --填写历史数据及签名记录的终止版本
    Update 病人护理明细
    Set 终止版本 = n_最高版本
    Where 记录id = n_记录id And ((Mod(记录类型, 10) <> 5 And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0)) Or 记录类型 = Decode(审签_In, 1, 15, 5)) And 开始版本 <= n_最高版本 - 1 And 终止版本 Is Null;
  
    --如果是未签名数据，最后修改操作员做为该记录的保存人更新
    If n_最高版本 = 1 Then
      Update 病人护理数据 Set 保存人 = v_保存人, 保存时间 = Sysdate Where ID = n_记录id;
    End If;
  
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;
  
    --############
    --同步共用数据
    --############
    --1\先处理体温单（一个病人始终只存在一份有效的体温单文件）
    --如果体温表存在相同发生时间的数据，使用它的ID
    --CL,2015-12-30,记录单同步文字项目到体温单
    For Row_Format In Cur_Fileformats Loop
      If Row_Format.保留 = -1 Then
        If Row_Format.子类 = '1' Then
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (Select To_Char(f.项目序号) As 序号, g.项目性质
                   From 体温记录项目 F, 护理记录项目 G
                   Where f.项目序号 = g.项目序号 And g.项目性质 = 2 And
                         (g.适用科室 = 1 Or
                         (g.适用科室 = 2 And Exists
                          (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id))) And Nvl(g.应用方式, 0) <> 0 And
                         (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2))
                   Union All
                   Select b.内容文本 As 序号, 1 As 项目性质
                   From 病历文件结构 A, 病历文件结构 B
                   Where a.文件id = Row_Format.格式id And a.父id Is Null And a.对象序号 In (2, 3) And b.父id = a.Id) H
            Where Instr(',' || h.序号 || ',', ',' || 项目序号_In || ',', 1) > 0;
          Exception
            When Others Then
              Intins := 0;
          End;
        Else
          Begin
            Select 1, g.项目性质
            Into Intins, n_项目性质
            From 体温记录项目 F, 护理记录项目 G
            Where f.项目序号 = g.项目序号 And Nvl(g.应用方式, 0) <> 0 And g.护理等级 >= 0 And
                  (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2)) And f.项目序号 = 项目序号_In And
                  (g.适用科室 = 1 Or (g.适用科室 = 2 And Exists
                   (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id)));
          Exception
            When Others Then
              Intins := 0;
          End;
        End If;
      
        If Intins > 0 Then
          --LPF,2013-01-23,检查此项目是否需要进行同步(对于以前已经同步过的数据，为了保证记录单和体温单数据一直将不根据此函数判断。)
          n_Synchro := Zl_Temperatureprogram(文件id_In, v_科室id, 项目序号_In, 发生时间_In);
          Begin
            Select b.Id
            Into n_Newid
            From 病人护理文件 A, 病人护理数据 B
            Where a.Id = Row_Format.文件id And b.文件id = a.Id And b.发生时间 = 发生时间_In;
          Exception
            When Others Then
              n_Newid := 0;
          End;
          n_Oldid := n_Newid;
          If n_Newid = 0 And n_Synchro = 1 Then
            Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            --产生体温单主记录
            Insert Into 病人护理数据
              (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
            Values
              (n_Newid, Row_Format.文件id, v_保存人, Sysdate, 发生时间_In, 1);
          End If;
        
          If n_Newid > 0 Then
            --插入未同步的体温单数据(仍然要联接多表查询)
            Select Count(*)
            Into v_数据来源
            From 病人护理明细
            Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                  Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
            If v_数据来源 = 0 Then
              --说明在同步开始已经进行过检查
              If n_Synchro = 1 Then
                --没有检查此项目是否需要同步
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 开始版本, 终止版本, 记录人,
                   记录时间, 记录组号)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, 1, Null, b.记录人, Sysdate, 1
                  From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                         From Dual
                         Minus
                         Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                         From 病人护理明细 E, 护理记录项目 F
                         Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            Else
              Update 病人护理明细
              Set 记录内容 = 记录内容_In, 来源id = n_明细id
              Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                    Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
              If Sql%RowCount > 0 Then
                Int共用 := 1;
              End If;
            End If;
          End If;
        End If;
        --2\再循环处理记录单
      Else
        If n_Mutilbill = 1 And n_Syntend = 1 Then
          --提取记录单与当前记录单存在重叠的且有数据的固定项目
          Select Count(*)
          Into Intins
          From (Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B
                 Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                       父id =
                       (Select ID From 病历文件结构 Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                 Intersect
                 Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                 Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                       b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                       a.父id = (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4));
        
          If Intins > 0 Then
            n_Newid := 0;
            --可能指定文件已经存在相同发生时间的数据，直接用它的ID即可
            Begin
              Select c.Id
              Into n_Newid
              From 病人护理数据 C
              Where c.文件id = Row_Format.文件id And c.发生时间 = 发生时间_In;
            Exception
              When Others Then
                n_Newid := 0;
            End;
          
            If n_Newid = 0 Then
              --产生记录单主记录
              Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            
              Insert Into 病人护理数据
                (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
                Select n_Newid, Row_Format.文件id, c.保存人, c.保存时间, c.发生时间, 1
                From 病人护理数据 C
                Where c.Id = n_记录id;
            End If;
          
            If n_Newid > 0 Then
              --插入未同步的记录单数据
              Select Count(*) Into v_数据来源 From 病人护理明细 Where 记录id = n_Newid And 项目序号 = 项目序号_In;
              If v_数据来源 = 0 Then
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                   记录人, 记录时间)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, b.未记说明, 1, Null, b.记录人, Sysdate
                  From (Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B
                         Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                               父id = (Select ID
                                      From 病历文件结构
                                      Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                         Intersect
                         Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                         Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                               b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                               a.父id =
                               (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4)) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                  --原行数不要动
                  Begin
                    Select 行数 Into n_行数 From 病人护理打印 Where 文件id = Row_Format.文件id And 记录id = n_Newid;
                  Exception
                    When Others Then
                      n_行数 := 1;
                  End;
                  Zl_病人护理打印_Update(Row_Format.文件id, 发生时间_In, n_行数, 0);
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 未记说明 = 未记说明_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And (数据来源 > 0 or 数据来源 <> 3);
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;
  
    If Int共用 = 1 Then
      Update 病人护理明细 Set 共用 = 1 Where ID = n_明细id;
      --将历史数据的共用标志设置为NULL
      Update 病人护理明细 Set 共用 = Null Where 记录id = n_记录id And 项目序号 = 项目序号_In And ID <> n_明细id;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理数据_Update;
/

--97532:陈刘,2016-06-21,数据来源为0,3 处理方式相同
CREATE OR REPLACE Procedure Zl_病人护理数据_Signname
( 
  文件id_In     In 病人护理数据.文件id%Type, 
  发生时间_In   In 病人护理数据.发生时间%Type, 
  审签_In       In Number, 
  签名人_In     In Varchar2, 
  签名信息_In   In Varchar2, 
  签名级别_In   In Number, 
  证书id_In     In Number, 
  签名规则_In   In Number, 
  签名时间_In   In Varchar2 := Null, 
  交班签名_In   In Number := 0, 
  时间戳信息_In In Varchar2 := Null, 
  记录时间_In   In 病人护理明细.记录时间%Type := Null, 
  项目分组_In   In 病人护理明细.项目分组%Type := Null 
) Is 
  n_Have       Number; 
  n_记录id     病人护理数据.Id%Type; 
  n_最后版本   病人护理数据.最后版本%Type; 
  v_签名人     病人护理数据.签名人%Type; 
  v_签名时间   病人护理数据.签名时间%Type; 
  v_交班签名人 病人护理数据.交班签名人%Type; 
  d_记录时间   病人护理明细.记录时间%Type; 
Begin 
  n_Have := 0; 
  If 记录时间_In Is Null Then 
    d_记录时间 := Sysdate; 
  Else 
    d_记录时间 := 记录时间_In; 
  End If; 
  Begin 
    Select Id, 汇总类别, 签名人, 签名时间, 交班签名人 
    Into n_记录id, n_Have, v_签名人, v_签名时间, v_交班签名人 
    From 病人护理数据 
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In; 
  Exception 
    When Others Then 
      n_记录id := Null; 
  End; 
  ----汇总数据不允许签名 
  --IF N_HAVE <>0 THEN 
  --  RETURN ; 
  --End IF ; 
 
  --同步过来的数据不需要签名,直接退出 
  Begin 
    Select 1 
    Into n_Have 
    From 病人护理明细 
    Where 数据来源 in( 0,3) And 记录id = (Select Id From 病人护理数据 Where 文件id = 文件id_In And 发生时间 = 发生时间_In) And Rownum < 2; 
  Exception 
    When Others Then 
      n_Have := 0; 
  End; 
  If n_Have = 0 Then 
    Return; 
  End If; 
 
  --取明细的终止版本,做为签名记录的开始版本 
  Select Max(开始版本) 
  Into n_最后版本 
  From 病人护理明细 a, 病人护理数据 b 
  Where a.记录id = b.Id And b.文件id = 文件id_In And b.发生时间 = 发生时间_In And Mod(记录类型, 10) = 5; 
  If n_最后版本 Is Null Then 
    n_最后版本 := 1; 
  End If; 
  If 审签_In = 0 Then 
    n_最后版本 := n_最后版本 + 交班签名_In; 
    If 交班签名_In = 0 Then 
      v_交班签名人 := Null; 
    Else 
      v_交班签名人 := 签名人_In; 
    End If; 
  Else 
    n_最后版本 := n_最后版本 + 审签_In; 
  End If; 
 
  If n_记录id Is Not Null Then 
    If 审签_In = 0 Then 
      --普通签名是只保留第一次签名人信息 
      If v_签名人 Is Null Then 
        v_签名人   := 签名人_In; 
        v_签名时间 := Sysdate; 
      End If; 
    Else 
      --再次审签时，原审签人丢弃 
      If Instr(v_签名人, '/', 1) <> 0 Then 
        v_签名人   := Substr(v_签名人, Instr(v_签名人, '/', 1) + 1); 
        v_签名时间 := Substr(v_签名时间, Instr(v_签名时间, '/', 1) + 1); 
      End If; 
      v_签名人   := 签名人_In || '/' || v_签名人; 
      v_签名时间 := Sysdate || '/' || v_签名时间; 
    End If; 
 
    --项目ID->证书ID_IN; 
    --项目类型->签名级别_IN; 
    --项目名称->签名时间_IN; 
    --记录内容->签名信息_IN; 
    --记录标记->签名规则_IN; 
    --记录人->签名人_IN 
    --未记录说明->时间戳信息_In 
    Insert Into 病人护理明细 
      (Id, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录人, 体温部位, 未记说明, 开始版本, 终止版本, 记录时间) 
      Select 病人护理明细_Id.Nextval, n_记录id, Decode(审签_In, 0, 5, 15), 项目分组_In, Decode(证书id_In, 0, Null, 证书id_In), Null, 
             签名时间_In, 签名级别_In, 签名信息_In, Null, 签名规则_In, 签名人_In, Null, 时间戳信息_In, n_最后版本, Null, d_记录时间 
 
      From 病人护理数据 
      Where Id = n_记录id; 
 
    --更新本记录签名人信息 
    Update 病人护理数据 
    Set 签名人 = v_签名人, 交班签名人 = v_交班签名人, 签名时间 = v_签名时间, 签名级别 = 签名级别_In, 最后版本 = n_最后版本 
    Where Id = n_记录id; 
  End If; 
Exception 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_病人护理数据_Signname;
/


--96690:廖思奇,2016-06-20,增加待处理人字段用于分配某医生写报告

CREATE OR REPLACE Procedure Zl_影像检查_Begin
( 
  执行间_In     病人医嘱发送.执行间%Type, 
  检查号_In     影像检查记录.检查号%Type, 
  医嘱id_In     影像检查记录.医嘱id%Type, 
  发送号_In     影像检查记录.发送号%Type, 
  影像类别_In   影像检查记录.影像类别%Type, 
  姓名_In       影像检查记录.姓名%Type, 
  英文名_In     影像检查记录.英文名%Type, 
  性别_In       影像检查记录.性别%Type, 
  年龄_In       影像检查记录.年龄%Type, 
  出生日期_In   影像检查记录.出生日期%Type, 
  身高_In       影像检查记录.身高%Type, 
  体重_In       影像检查记录.体重%Type, 
  病理检查_In   影像检查记录.病理检查%Type, 
  发放胶片_IN   影像检查记录.发放胶片%Type, 
  检查设备_In   影像检查记录.检查设备%Type, 
  检查技师_In   影像检查记录.检查技师%Type, 
  检查技师二_In 影像检查记录.检查技师二%Type, 
  附加主述_In   影像检查记录.附加主述%Type, 
  检查时间_In   病人医嘱发送.首次时间%Type, 
  执行科室ID_In 影像检查记录.执行科室ID%Type, 
  待处理人_In   影像检查记录.待处理人%Type:= NULL
) Is 
  Cursor c_Advice Is 
    Select A.医嘱id, A.首次时间 
    From 病人医嘱发送 A, 病人医嘱记录 B 
    Where (B.ID = 医嘱id_In Or B.相关id = 医嘱id_In) And B.诊疗类别 In ('F', 'G', 'E', 'D') And A.医嘱id = B.ID And 
          A.发送号 + 0 = 发送号_In; 
  v_Temp         Varchar2(255); 
  v_人员姓名     人员表.姓名%Type; 
Begin 
  v_Temp     := Zl_Identity; 
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1); 
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1); 
 
  Update 影像检查记录 
  Set 影像类别 = 影像类别_In, 检查号 = 检查号_In, 姓名 = 姓名_In, 英文名 = 英文名_In, 性别 = 性别_In, 年龄 = 年龄_In, 出生日期 = 出生日期_In, 
      身高 = 身高_In, 体重 = 体重_In, 病理检查 = 病理检查_In, 发放胶片 = 发放胶片_IN, 检查设备 = 检查设备_In, 检查技师 = 检查技师_In,检查技师二=检查技师二_In, 
      附加主述 = 附加主述_In,执行科室ID=执行科室ID_In,待处理人=待处理人_In 
  Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In; 
 
  If Sql%RowCount = 0 Then 
    Insert Into 影像检查记录 
      (医嘱id, 发送号, 影像类别, 检查号, 姓名, 英文名, 性别, 年龄, 出生日期, 身高, 体重, 病理检查, 发放胶片, 检查设备, 检查技师,检查技师二, 附加主述, 报到人,执行科室ID,待处理人) 
    Values 
      (医嘱id_In, 发送号_In, 影像类别_In, 检查号_In, 姓名_In, 英文名_In, 性别_In, 年龄_In, 出生日期_In, 身高_In, 体重_In, 
       病理检查_In, 发放胶片_IN, 检查设备_In, 检查技师_In,检查技师二_In, 附加主述_In, v_人员姓名,执行科室ID_In,待处理人_In); 
  End If; 
 
  For r_Advice In c_Advice Loop 
    Update 病人医嘱发送 
    Set 首次时间 = Nvl(检查时间_In, Sysdate), 安排时间 = Sysdate, 末次时间 = Nvl(检查时间_In, Sysdate), 报到时间 = Nvl(检查时间_In, Sysdate), 执行状态 = 3, 
        执行过程 = 2, 执行间 = 执行间_In 
    Where 医嘱id = r_Advice.医嘱id And 发送号 = 发送号_In; 
  End Loop; 
Exception 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_影像检查_Begin;
/

--96690:廖思奇,2016-06-20,增加字段用于方便区分分配给谁写报告
CREATE OR REPLACE Procedure ZL_影像检查记录_UPDATE
( 
  医嘱ID_In       影像检查记录.医嘱ID%Type, 
  发送号_In       影像检查记录.发送号%Type, 
  检查号_In       影像检查记录.检查号%Type, 
  姓名_In         影像检查记录.姓名%Type, 
  英文名_In       影像检查记录.英文名%Type, 
  性别_In         影像检查记录.性别%Type, 
  年龄_In         影像检查记录.年龄%Type, 
  出生日期_In     影像检查记录.出生日期%Type, 
  身高_In         影像检查记录.身高%Type, 
  体重_In         影像检查记录.体重%Type, 
  检查设备_In     影像检查记录.检查设备%Type, 
  检查技师_In     影像检查记录.检查技师%Type, 
  检查技师二_In   影像检查记录.检查技师二%Type, 
  附加主述_In     影像检查记录.附加主述%Type, 
  执行间_In       病人医嘱发送.执行间%Type, 
  检查时间_In     病人医嘱发送.末次时间%Type, 
  待处理人_In     影像检查记录.待处理人%Type:= NULL
) As 
Begin 
 
  Update 影像检查记录 
  Set    姓名 = 姓名_In,英文名=英文名_In,检查号=检查号_In,性别=性别_In,年龄=年龄_In,出生日期=出生日期_In,身高=身高_In,体重=体重_In, 
         检查设备=检查设备_In,检查技师=检查技师_In,检查技师二=检查技师二_In,附加主述=附加主述_In,待处理人=待处理人_In 
  Where  医嘱ID = 医嘱ID_In And 发送号 =发送号_In; 
 
  Update 病人医嘱发送 
  Set 首次时间=检查时间_In,末次时间=检查时间_In,执行间=执行间_In 
  Where 医嘱ID=医嘱ID_In And 发送号=发送号_In; 
Exception 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End ZL_影像检查记录_UPDATE;
/

--103236:刘尔旋,2016-12-26,支付宝停诊处理
--102628:刘尔旋,2016-12-06,支付宝当天获取分时段非序号控制号别问题
--102103:刘尔旋,2016-11-07,支付宝简易模式挂号
--101259:刘尔旋,2016-10-10,失约序号用于挂号
--98755:刘尔旋,2016-07-19,挂号安排存在多个收入项目的获取号源问题
--97219:刘尔旋,2016-06-20,支付宝挂号预约天数
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表(简易模式)
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --  <SJJG>60</SJJG>     //时间间隔,不传则返回序号时段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <CZJLID>1</CZJLID>     //出诊记录ID
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD></SJD>          //时间段,格式:hh24:mi-hh24:mi
  --                  <GHZS></GHZS>      //时段挂号总数
  --                  <SL></SL>      //剩余数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  d_日期         Date;
  n_科室id       病人挂号记录.执行部门id%Type;
  n_医生id       人员表.Id%Type;
  v_医生姓名     人员表.姓名%Type;
  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  v_合作单位     挂号合作单位.名称%Type;
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);
  d_加号时间     Date;
  d_开始时间     临床出诊记录.开始时间%Type;
  d_终止时间     临床出诊记录.终止时间%Type;
  n_缓冲序号     Number(3);
  n_时段数量     Number(5);
  n_序号控制     临床出诊记录.是否序号控制%Type;
  n_预留数量     Number(5);
  n_特殊预约     Number(3);
  n_禁用         Number(3);
  v_剩余数量     Varchar2(100);
  v_Timetemp     Varchar2(100);
  v_Temp         Varchar2(32767); --临时XML
  v_Xmlmain      Clob; --临时XML
  c_Xmlmain      Clob; --临时XML
  x_Templet      Xmltype; --模板XML
  v_Err_Msg      Varchar2(200);
  n_Exists       Number(5);
  n_时段已挂     Number(5);
  n_挂号模式     Number(3);
  v_挂号模式     Varchar2(500);
  v_启用时间     Varchar2(500);
  n_时间间隔     Number(5);
  n_预约天数     Number(5);
  d_时段开始     Date;
  d_时段结束     Date;
  n_时段总数     Number(5);
  n_时段剩余     Number(5);
  Err_Item Exception;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/SJJG')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位, n_时间间隔
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_挂号模式 := zl_GetSysParameter('挂号排班模式');
  n_挂号模式 := To_Number(Substr(v_挂号模式, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      v_启用时间 := Substr(v_挂号模式, 3);
    Exception
      When Others Then
        v_启用时间 := Null;
    End;
  End If;
  --日期节点为空的情况
  If d_日期 Is Null Then
    d_日期 := Trunc(Sysdate);
  End If;
  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  If d_日期 < To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss') And n_挂号模式 = 1 Then
    n_挂号模式 := 0;
  End If;

  If n_挂号模式 = 0 Then
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    n_合约剩余数量 := 0;
  
    For r_No In (Select a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                        a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收,
                        Sum(b.现价) As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数, Ap.预约天数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Ap.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Ap.医生姓名) = Nvl(v_医生姓名, '-') And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000 - 01 - 01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And
                                     Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Jh.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Jh.医生姓名) = Nvl(v_医生姓名, '-') And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-Mm-DD')) > d_日期 And b.执行日期 <= d_日期
                 Group By a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                          a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0), Nvl(Hz.已约数, 0), Nvl(Hz.其中已接收, 0)) Loop
      Zl_挂号序号状态_Delete(1, r_No.号码);
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        --分时段不序号控制当天号为普通号
        If Trunc(Sysdate) = Trunc(d_日期) And n_分时段 = 1 And r_No.序号控制 = 0 Then
          n_分时段 := 0;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
            
              d_时段开始 := Null;
              d_时段结束 := Null;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+)
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          Else
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + n_单个剩余;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+)
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Else
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          End If;
        End If;
        --限约数=0的预约禁止
        If Trunc(d_日期) <> Trunc(Sysdate) Then
          If r_No.限约数 = 0 Then
            n_禁用 := 1;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Select Nvl(Max(1), 0)
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                           '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                           r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                           '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Else
    --出诊表排班模式
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.医生姓名, a.医生id, d.专业技术职务 As 职称, b.号码, a.Id As 记录id, a.上班时段 As 排班,
                        a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数, Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数,
                        Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收, a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间,
                        a.替诊终止时间, Nvl(b.预约天数, n_预约天数) As 预约天数, a.停诊开始时间, a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.终止时间 > Sysdate And a.号源id = b.Id And a.项目id = e.Id And
                       a.医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And (a.开始时间 < Nvl(a.替诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.替诊终止时间, a.开始时间)) And
                       Nvl(a.是否发布, 0) = 1 And a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      Zl_挂号序号状态_出诊_Delete(r_No.记录id);
      v_Temp := Null;
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := d_开始时间;
                      d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                    Else
                      If d_开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := d_开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                        n_Exists   := n_Exists + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + r_Time.数量 - n_时段已挂;
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Begin
                    Select Count(1)
                    Into n_合约已挂数
                    From 病人挂号记录
                    Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                          Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  Exception
                    When Others Then
                      n_合约已挂数 := 0;
                  End;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            n_Exists   := n_Exists + 1;
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1
                          Into n_Exists
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          If d_开始时间 > Sysdate Then
                            n_已挂数 := n_已挂数 + n_时段已挂;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      v_Temp     := '<SPANLIST>';
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    v_Temp     := '<SPANLIST>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.开始时间, 'HH24:MI') || '-' || To_Char(r_No.终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
  
    --加入替诊号源
    n_合约剩余数量 := 0;
    For r_No In (Select a.科室id, b.号类, c.名称 As 科室名称, a.替诊医生姓名 As 医生姓名, a.替诊医生id As 医生id, d.专业技术职务 As 职称, b.号码,
                        a.Id As 记录id, a.上班时段 As 排班, a.项目id, e.名称 As 项目名称, a.是否序号控制 As 序号控制, a.限号数,
                        Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收,
                        a.是否分时段 As 分时段, a.开始时间, a.终止时间, a.预约控制, a.替诊开始时间, a.替诊终止时间, Nvl(b.预约天数, n_预约天数) As 预约天数, a.停诊开始时间,
                        a.停诊终止时间
                 From 临床出诊记录 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.出诊日期 = Trunc(d_日期) And a.替诊医生姓名 Is Not Null And a.终止时间 > Sysdate And a.号源id = b.Id And
                       a.项目id = e.Id And a.替诊医生id = d.Id(+) And b.科室id = c.Id And Nvl(a.是否锁定, 0) = 0 And
                       (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) Or Exists
                        (Select 1
                         From 临床出诊序号控制 C, 临床出诊记录 D
                         Where d.Id = a.Id And c.记录id = d.Id And Nvl(c.是否停诊, 0) = 0 And d.是否序号控制 = 1 And d.是否分时段 = 1 And
                               c.开始时间 <> c.终止时间)) And Nvl(a.是否发布, 0) = 1 And
                       a.开始时间 > Trunc(To_Date(v_启用时间, 'yyyy-mm-dd hh24:mi:ss')) And
                       Decode(Nvl(n_科室id, 0), 0, 0, b.科室id) = Nvl(n_科室id, 0) And
                       Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                       Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-')) Loop
      v_Temp := '';
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If Trunc(d_日期) = Trunc(Sysdate) Then
          --当天挂号
          If v_合作单位 Is Null Then
            --未传入合作单位
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              --分时段
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                    n_时段总数 := n_时段总数 + 1;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                End If;
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                              To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                      n_Exists := n_Exists + 1;
                    Else
                      v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                    End If;
                  Else
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_Exists   := n_Exists + 1;
                      n_时段剩余 := n_时段剩余 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
              If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                          To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --传入合作单位
            n_已挂数 := r_No.已挂数;
            Begin
              Select 控制方式
              Into n_合约模式
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
            Exception
              When Others Then
                n_合约模式 := 4;
            End;
            If n_合约模式 = 0 Then
              n_禁用 := 1;
            End If;
            If n_合约模式 = 1 Or n_合约模式 = 2 Then
              Select 数量
              Into n_合约总数量
              From 临床出诊挂号控制记录
              Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
              If n_合约模式 = 1 Then
                n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
              End If;
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                v_剩余数量 := n_合约剩余数量;
              End If;
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
            If n_合约模式 = 3 Then
              If n_序号控制 = 0 Then
                n_已挂数   := r_No.已挂数;
                v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              Else
                n_已挂数   := 0;
                v_剩余数量 := 0;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_合作 In (Select 序号
                             From 临床出诊挂号控制记录
                             Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                  Begin
                    Select 1, 开始时间, 终止时间
                    Into n_Exists, d_开始时间, d_终止时间
                    From 临床出诊序号控制
                    Where 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                          Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1;
                  Exception
                    When Others Then
                      n_Exists := 0;
                  End;
                  If n_Exists = 1 Then
                    v_剩余数量 := v_剩余数量 + 1;
                    If r_No.分时段 = 1 Then
                    
                      If Nvl(n_时间间隔, 0) <> 0 Then
                        If d_时段开始 Is Null Then
                          d_时段开始 := d_开始时间;
                          d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                          n_时段总数 := n_时段总数 + 1;
                        Else
                          If d_开始时间 >= d_时段结束 Then
                            v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                          To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                          '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          Else
                            n_时段总数 := n_时段总数 + 1;
                          End If;
                        End If;
                      End If;
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD><SL>1</SL></SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + 1;
                        End If;
                      End If;
                    End If;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If v_Temp Is Not Null Then
                  v_Temp := '<SPANLIST>' || v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
            If n_合约模式 = 4 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
              If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
                --分时段
                v_Temp   := '<SPANLIST>';
                n_Exists := 0;
                Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                
                  If Nvl(n_时间间隔, 0) <> 0 Then
                    If d_时段开始 Is Null Then
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                      n_时段总数 := n_时段总数 + 1;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  End If;
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                        n_Exists := n_Exists + 1;
                      Else
                        v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                      End If;
                    Else
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_Exists   := n_Exists + 1;
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                                n_时段剩余 || '</SL>' || '</SPAN>';
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                End If;
                If n_Exists < To_Number(v_剩余数量) And r_No.替诊开始时间 Is Null Then
                
                  v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD><SL>' ||
                            To_Number(v_剩余数量 - n_Exists) || '</SL></SPAN>';
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            End If;
          End If;
        Else
          --预约挂号
          If r_No.预约控制 = 1 Then
            n_禁用 := 1;
          Else
            --不限制预约
            If v_合作单位 Is Null Then
              If r_No.分时段 = 0 Then
                n_已挂数   := r_No.已约数;
                v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
              Else
                --分时段
                n_已挂数   := 0;
                v_剩余数量 := 0;
                v_Temp     := '<SPANLIST>';
                If r_No.序号控制 = 0 Then
                  --非序号控制分时段预约
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                       开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                       开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + r_Time.数量;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    End If;
                    Select Count(1)
                    Into n_时段已挂
                    From 临床出诊序号控制
                    Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                      End If;
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                Else
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                 From 临床出诊序号控制
                                 Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                       Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                    If Nvl(n_时间间隔, 0) <> 0 Then
                      If d_时段开始 Is Null Then
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                        n_时段总数 := n_时段总数 + 1;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                        '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    End If;
                    If r_Time.开始时间 > Sysdate Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      Else
                        If Nvl(r_Time.挂号状态, 0) = 0 Then
                          n_时段剩余 := n_时段剩余 + 1;
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End If;
                    End If;
                  End Loop;
                  If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                    v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                  To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                  '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                  End If;
                End If;
                v_Temp := v_Temp || '</SPANLIST>';
              End If;
            Else
              --合作单位预约挂号
              If r_No.预约控制 = 2 Then
                n_禁用 := 1;
              Else
                Begin
                  Select 控制方式
                  Into n_合约模式
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1 And Rownum < 2;
                Exception
                  When Others Then
                    n_合约模式 := 4;
                End;
                If n_合约模式 = 0 Then
                  n_禁用 := 1;
                End If;
                If n_合约模式 = 1 Or n_合约模式 = 2 Then
                  Select 数量
                  Into n_合约总数量
                  From 临床出诊挂号控制记录
                  Where 记录id = r_No.记录id And 类型 = 1 And 名称 = v_合作单位 And 性质 = 1;
                  If n_合约模式 = 1 Then
                    n_合约总数量 := Round(r_No.限号数 * n_合约总数量 / 100);
                  End If;
                  Select Count(1)
                  Into n_合约已挂数
                  From 病人挂号记录
                  Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                        Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
                  n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
                  If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    v_剩余数量 := n_合约剩余数量;
                  End If;
                  If r_No.分时段 = 1 Then
                    v_Temp := '<SPANLIST>';
                    If r_No.序号控制 = 1 Then
                      --分时段,序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp   := v_Temp || '<SL>1</SL></SPAN>';
                              n_Exists := n_Exists + 1;
                            Else
                              v_Temp := v_Temp || '<SL>0</SL></SPAN>';
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              n_Exists   := n_Exists + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    Else
                      --分时段,非序号控制
                      n_Exists   := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_Exists := n_Exists + (r_Time.数量 - n_时段已挂);
                        
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      If n_Exists < To_Number(v_剩余数量) Then
                        v_剩余数量 := n_Exists;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                  n_已挂数 := r_No.已约数;
                End If;
                If n_合约模式 = 3 Then
                  If r_No.分时段 = 0 Then
                    If r_No.序号控制 = 0 Then
                      n_禁用 := 1;
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Select Nvl(Max(1), 0)
                        Into n_Exists
                        From 临床出诊序号控制
                        Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                              开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                              Nvl(是否停诊, 0) <> 1;
                        If n_Exists = 1 Then
                          v_剩余数量 := v_剩余数量 + 1;
                        Else
                          n_已挂数 := n_已挂数 + 1;
                        End If;
                      End Loop;
                      If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                        v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                      End If;
                    End If;
                  Else
                    If r_No.序号控制 = 0 Then
                      --合作单位,分时段,非序号控制
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号, 数量
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select Count(1), Max(开始时间), Max(终止时间)
                          Into n_时段已挂, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1);
                        
                          If Nvl(n_时间间隔, 0) <> 0 Then
                            If d_时段开始 Is Null Then
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            Else
                              If d_开始时间 >= d_时段结束 Then
                                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                              '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                                n_时段总数 := r_合作.数量;
                                n_时段剩余 := 0;
                                d_时段开始 := d_开始时间;
                                d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              Else
                                n_时段总数 := n_时段总数 + r_合作.数量;
                              End If;
                            End If;
                          End If;
                          n_已挂数 := n_已挂数 + n_时段已挂;
                          If d_开始时间 > Sysdate Then
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || r_合作.数量 - n_时段已挂 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                            End If;
                            v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                          End If;
                        Exception
                          When Others Then
                            Null;
                        End;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                      v_Temp := v_Temp || '</SPANLIST>';
                    Else
                      n_已挂数   := 0;
                      v_剩余数量 := 0;
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      v_Temp     := '<SPANLIST>';
                      For r_合作 In (Select 序号
                                   From 临床出诊挂号控制记录
                                   Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                        Begin
                          Select 1, 开始时间, 终止时间
                          Into n_Exists, d_开始时间, d_终止时间
                          From 临床出诊序号控制
                          Where 记录id = r_No.记录id And Nvl(挂号状态, 0) = 0 And 序号 = r_合作.序号 And
                                开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                Nvl(是否停诊, 0) <> 1;
                        Exception
                          When Others Then
                            n_Exists := 0;
                        End;
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If d_开始时间 > Sysdate Then
                          If n_Exists = 1 Then
                            v_剩余数量 := v_剩余数量 + 1;
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 1 || '</SL></SPAN>';
                            Else
                              n_时段剩余 := n_时段剩余 + 1;
                            End If;
                          Else
                            If Nvl(n_时间间隔, 0) = 0 Then
                              v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_开始时间, 'hh24:mi:ss') || '-' ||
                                        To_Char(d_终止时间, 'hh24:mi:ss') || '</SJD>';
                              v_Temp := v_Temp || '<SL>' || 0 || '</SL></SPAN>';
                            End If;
                            n_已挂数 := n_已挂数 + 1;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                  End If;
                End If;
                If n_合约模式 = 4 Then
                  If r_No.分时段 = 0 Then
                    n_已挂数   := r_No.已约数;
                    v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                  Else
                    --分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    n_时段总数 := 0;
                    n_时段剩余 := 0;
                    d_时段开始 := Null;
                    d_时段结束 := Null;
                    v_Temp     := '<SPANLIST>';
                    If r_No.序号控制 = 0 Then
                      --非序号控制分时段预约
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                           开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) And
                                           开始时间 Not Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1)) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + r_Time.数量;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        End If;
                        Select Count(1)
                        Into n_时段已挂
                        From 临床出诊序号控制
                        Where 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            v_Temp := v_Temp || '<SL>' || r_Time.数量 - n_时段已挂 || '</SL></SPAN>';
                          Else
                            n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          End If;
                          n_已挂数   := n_已挂数 + n_时段已挂;
                          v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    Else
                      n_时段总数 := 0;
                      n_时段剩余 := 0;
                      d_时段开始 := Null;
                      d_时段结束 := Null;
                      Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                      For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                     From 临床出诊序号控制
                                     Where 记录id = r_No.记录id And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                           Nvl(r_No.替诊终止时间, Sysdate - 1) And Nvl(是否停诊, 0) <> 1) Loop
                      
                        If Nvl(n_时间间隔, 0) <> 0 Then
                          If d_时段开始 Is Null Then
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + 1 / 24 / 60 * n_时间间隔;
                            n_时段总数 := n_时段总数 + 1;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                            To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 ||
                                            '</GHZS>' || '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + 1 / 24 / 60 * n_时间间隔;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        End If;
                        If r_Time.开始时间 > Sysdate Then
                          If Nvl(n_时间间隔, 0) = 0 Then
                            v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                      To_Char(r_Time.终止时间, 'hh24:mi:ss') || '</SJD>';
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              v_Temp     := v_Temp || '<SL>1</SL></SPAN>';
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              v_Temp   := v_Temp || '<SL>0</SL></SPAN>';
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          Else
                            If Nvl(r_Time.挂号状态, 0) = 0 Then
                              n_时段剩余 := n_时段剩余 + 1;
                              v_剩余数量 := v_剩余数量 + 1;
                            Else
                              n_已挂数 := n_已挂数 + 1;
                            End If;
                          End If;
                        End If;
                      End Loop;
                      If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                        v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                      To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                      '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                        n_时段总数 := 0;
                        n_时段剩余 := 0;
                        d_时段开始 := Null;
                        d_时段结束 := Null;
                      End If;
                    End If;
                    v_Temp := v_Temp || '</SPANLIST>';
                  End If;
                End If;
              End If;
            End If;
          End If;
        End If;
      
        If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
          If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
          If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
            n_禁用 := 1;
          End If;
        End If;
      
        If Nvl(n_禁用, 0) = 0 Then
          n_合计金额 := 0;
          For r_Fee In (Select b.现价, a.从项数次
                        From 收费从属项目 A, 收费价目 B
                        Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                        Union
                        Select b.现价, 1 As 从项数次
                        From 收费项目目录 A, 收费价目 B
                        Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                              Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
          End Loop;
          v_时间段 := To_Char(r_No.替诊开始时间, 'HH24:MI') || '-' || To_Char(r_No.替诊终止时间, 'HH24:MI');
          If Trunc(Sysdate) = Trunc(d_日期) Then
            c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                         r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' ||
                         '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id ||
                         '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' ||
                         v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' ||
                         '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 ||
                         '</FWMC>' || v_Temp || '</HB>';
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          Else
            If r_No.已约数 >= r_No.限约数 Then
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || r_No.已约数 ||
                           '</YGHS>' || '<SYHS>' || 0 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            Else
              c_Xmlmain := '<HB>' || '<CZJLID>' || r_No.记录id || '</CZJLID>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' ||
                           r_No.医生id || '</YSID>' || '<YS>' || r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id ||
                           '</KSID>' || '<KSMC>' || r_No.科室名称 || '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' ||
                           r_No.项目id || '</XMID>' || '<XMMC>' || r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 ||
                           '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' || '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' ||
                           r_No.号类 || '</HL>' || '<FSD>' || r_No.分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' ||
                           '<FWMC>' || r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
              v_Xmlmain := v_Xmlmain || c_Xmlmain;
            End If;
          End If;
        End If;
      End If;
      n_禁用 := 0;
    End Loop;
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/

--68694:刘尔旋,2016-10-20,新挂号安排
--97219:刘尔旋,2016-06-24,服务窗支持预约天数
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室

  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --  <ZD></ZD>              //站点
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --    <ZDYYTS>最大可预约天数</ZDYYTS>     //最大可预约天数
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_Temp      Varchar(5000); --临时XML
  x_Templet   Xmltype; --模板XML
  v_Para      Varchar2(4000);
  n_查询天数  Number(5);
  n_预约天数  Number(5);
  n_Add_Lists Number(3);
  v_合作单位  合作单位安排控制.合作单位%Type;
  n_站点      部门表.站点%Type;
  v_Err_Msg   Varchar2(200);
  d_启用时间  Date;
  Err_Item Exception;
  n_挂号模式 Number(3);
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');
  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW'), Extractvalue(Value(A), 'IN/ZD')
  Into n_查询天数, v_合作单位, n_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  v_Para     := zl_GetSysParameter('挂号排班模式');
  n_预约天数 := zl_GetSysParameter(66);
  n_挂号模式 := To_Number(Substr(v_Para, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;
  If n_挂号模式 = 0 Then
    If n_查询天数 Is Null Then
      If v_合作单位 Is Null Then
        For r_Dept In (Select Distinct a.科室id, b.名称, Max(Nvl(a.预约天数, n_预约天数)) As 预约天数
                       From 挂号安排 A, 部门表 B
                       Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                       Group By a.科室id, b.名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            --增加DJList节点
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      Else
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                       From (Select b.科室id, d.名称, Max(a.预约天数) As 预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   挂号安排计划 C, 部门表 D
                              Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                    ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + a.预约天数) Or
                                    (c.生效时间 Between Sysdate And Sysdate + a.预约天数) Or
                                    (c.失效时间 Between Sysdate And Sysdate + a.预约天数)) And Not Exists
                               (Select 1
                                     From 合作单位计划控制
                                     Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                              Group By b.科室id, d.名称
                              Union All
                              Select b.科室id, d.名称, Max(a.预约天数) As 预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   部门表 D
                              Where a.Id = b.Id And Not Exists
                               (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                              Group By b.科室id, d.名称)
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            --增加DJList节点
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      End If;
    Else
      If v_合作单位 Is Null Then
        For r_Dept In (Select Distinct a.科室id, b.名称, Max(Nvl(a.预约天数, n_预约天数)) As 预约天数
                       From 挂号安排 A, 部门表 B
                       Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null)
                       Group By a.科室id, b.名称) Loop
        
          If Nvl(n_Add_Lists, 0) = 0 Then
            --增加DJList节点
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      Else
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                       From (Select b.科室id, d.名称, Max(a.预约天数) As 预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   挂号安排计划 C, 部门表 D
                              Where a.Id = b.Id And c.安排id = a.Id And c.审核时间 Is Not Null And
                                    ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + n_查询天数) Or
                                    (c.生效时间 Between Sysdate And Sysdate + n_查询天数) Or
                                    (c.失效时间 Between Sysdate And Sysdate + n_查询天数)) And Not Exists
                               (Select 1
                                     From 合作单位计划控制
                                     Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                              Group By b.科室id, d.名称
                              Union All
                              Select b.科室id, d.名称, Max(a.预约天数) As 预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   部门表 D
                              Where a.Id = b.Id And Not Exists
                               (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                              Group By b.科室id, d.名称)
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            --增加DJList节点
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      End If;
    End If;
  Else
    --出诊表排班模式
    If n_查询天数 Is Null Then
      If v_合作单位 Is Null Then
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                       From (Select a.科室id, b.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                              From 挂号安排 A, 部门表 B
                              Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And
                                    Sysdate < d_启用时间
                              Union
                              Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                              From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                              Where a.号源id = c.Id And a.开始时间 > d_启用时间 And a.出诊日期 >= Trunc(Sysdate) And
                                    a.出诊日期 <= Trunc(Sysdate + Nvl(c.预约天数, n_预约天数)) And Nvl(a.是否发布, 0) = 1 And
                                    a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null))
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      Else
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数 From (
			Select 科室id, 名称, 预约天数 
                       From (Select b.科室id, d.名称, a.预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   挂号安排计划 C, 部门表 D
                              Where a.Id = b.Id And Sysdate < d_启用时间 And c.安排id = a.Id And c.审核时间 Is Not Null And
                                    ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + a.预约天数) Or
                                    (c.生效时间 Between Sysdate And Sysdate + a.预约天数) Or
                                    (c.失效时间 Between Sysdate And Sysdate + a.预约天数)) And Not Exists
                               (Select 1
                                     From 合作单位计划控制
                                     Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                              Union All
                              Select b.科室id, d.名称, a.预约天数
                              From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A
                                     Where a.停用日期 Is Null And Not Exists
                                      (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                     Union All
                                     Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                     From 挂号安排 A, 合作单位安排控制 B
                                     Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                   部门表 D
                              Where a.Id = b.Id And Sysdate < d_启用时间 And Not Exists
                               (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                    (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                    (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null))
                       Union
                       Select 科室id, 名称, 预约天数
                       From (Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                              From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                              Where a.号源id = c.Id And a.开始时间 > d_启用时间 And a.出诊日期 >= Trunc(Sysdate) And
                                    a.出诊日期 <= Trunc(Sysdate + Nvl(c.预约天数, n_预约天数)) And Nvl(a.是否发布, 0) = 1 And
                                    a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And Not Exists
                               (Select 1 From 临床出诊挂号控制记录 Where 记录id = a.Id And 性质 = 1 And 类型 = 1)
                              Union
                              Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                              From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                              Where a.号源id = c.Id And a.开始时间 > d_启用时间 And a.出诊日期 >= Trunc(Sysdate) And
                                    a.出诊日期 <= Trunc(Sysdate + Nvl(c.预约天数, n_预约天数)) And Nvl(a.是否发布, 0) = 1 And
                                    a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And Exists
                               (Select 1
                                     From 临床出诊挂号控制记录
                                     Where 记录id = a.Id And 名称 = v_合作单位 And 性质 = 1 And 类型 = 1 And 控制方式 <> 0)))
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      End If;
    Else
      If v_合作单位 Is Null Then
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                       From (Select a.科室id, b.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                              From 挂号安排 A, 部门表 B
                              Where a.停用日期 Is Null And a.科室id = b.Id And (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And
                                    Sysdate < d_启用时间
                              Union
                              Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                              From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                              Where a.出诊日期 >= Trunc(Sysdate) And a.号源id = c.Id And a.开始时间 > d_启用时间 And
                                    a.出诊日期 <= Trunc(Sysdate + n_查询天数) And Nvl(a.是否发布, 0) = 1 And a.科室id = b.Id And
                                    (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null))
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      Else
        For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                       From (Select 科室id, 名称, 预约天数
                              From (Select b.科室id, d.名称, a.预约天数
                                     From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                            From 挂号安排 A
                                            Where a.停用日期 Is Null And Not Exists
                                             (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                            Union All
                                            Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                            From 挂号安排 A, 合作单位安排控制 B
                                            Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                          挂号安排计划 C, 部门表 D
                                     Where a.Id = b.Id And Sysdate < d_启用时间 And c.安排id = a.Id And c.审核时间 Is Not Null And
                                           ((c.生效时间 < Sysdate And c.失效时间 > Sysdate + n_查询天数) Or
                                           (c.生效时间 Between Sysdate And Sysdate + n_查询天数) Or
                                           (c.失效时间 Between Sysdate And Sysdate + n_查询天数)) And Not Exists
                                      (Select 1
                                            From 合作单位计划控制
                                            Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 = 0) And b.科室id = d.Id And
                                           (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                           (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null)
                                     Union All
                                     Select b.科室id, d.名称, a.预约天数
                                     From (Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                            From 挂号安排 A
                                            Where a.停用日期 Is Null And Not Exists
                                             (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位)
                                            Union All
                                            Select a.Id, Nvl(a.预约天数, n_预约天数) As 预约天数
                                            From 挂号安排 A, 合作单位安排控制 B
                                            Where a.停用日期 Is Null And 合作单位 = v_合作单位 And a.Id = b.安排id And b.数量 <> 0) A, 挂号安排 B,
                                          部门表 D
                                     Where a.Id = b.Id And Sysdate < d_启用时间 And Not Exists
                                      (Select 1 From 挂号安排计划 Where 安排id = a.Id And Rownum < 2) And b.科室id = d.Id And
                                           (d.站点 = Nvl(n_站点, 0) Or d.站点 Is Null) And
                                           (Sysdate Between d.建档时间 And d.撤档时间 Or Sysdate >= d.建档时间 And d.撤档时间 Is Null))
                              Union
                              Select 科室id, 名称, 预约天数
                              From (Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                                     From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                                     Where a.出诊日期 >= Trunc(Sysdate) And a.号源id = c.Id And a.开始时间 > d_启用时间 And
                                           a.出诊日期 <= Trunc(Sysdate + n_查询天数) And Nvl(a.是否发布, 0) = 1 And a.科室id = b.Id And
                                           (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And Not Exists
                                      (Select 1 From 临床出诊挂号控制记录 Where 记录id = a.Id And 性质 = 1 And 类型 = 1)
                                     Union
                                     Select a.科室id, b.名称, Nvl(c.预约天数, n_预约天数) As 预约天数
                                     From 临床出诊记录 A, 部门表 B, 临床出诊号源 C
                                     Where a.出诊日期 >= Trunc(Sysdate) And a.号源id = c.Id And a.开始时间 > d_启用时间 And
                                           a.出诊日期 <= Trunc(Sysdate + n_查询天数) And Nvl(a.是否发布, 0) = 1 And a.科室id = b.Id And
                                           (b.站点 = Nvl(n_站点, 0) Or b.站点 Is Null) And Exists
                                      (Select 1
                                            From 临床出诊挂号控制记录
                                            Where 记录id = a.Id And 名称 = v_合作单位 And 性质 = 1 And 类型 = 1 And 控制方式 <> 0)))
                       Group By 科室id, 名称) Loop
          If Nvl(n_Add_Lists, 0) = 0 Then
            Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<KSLIST></KSLIST>')) Into x_Templet From Dual;
            n_Add_Lists := 1;
          End If;
          v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>' || '<ZDYYTS>' ||
                    r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
          Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
        End Loop;
      End If;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptlist;
/


  --97977:李业庆,2016-07-04,负数冲销
  Create Or Replace Procedure Zl_材料领用_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type
) Is
  Err_Item Exception;
  v_Err_Msg  Varchar2(100);
  v_产地     药品收发记录.产地%Type;
  v_批号     药品收发记录.批号%Type;
  v_摘要     药品收发记录.摘要%Type;
  v_领用人   药品收发记录.领用人%Type;
  v_批准文号 药品库存.批准文号%Type;

  n_Batch_Count  Integer; --原不分批现在分批的材料的数量
  n_库房id       药品收发记录.库房id%Type;
  n_对方部门id   药品收发记录.对方部门id%Type;
  n_入出类别id   药品收发记录.入出类别id%Type;
  n_批次         药品收发记录.批次%Type;
  n_成本价       药品收发记录.成本价%Type;
  n_成本金额     药品收发记录.成本金额%Type;
  n_扣率         药品收发记录.扣率%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_零售金额     药品收发记录.零售金额%Type;
  n_差价         药品收发记录.差价%Type;
  n_剩余数量     药品收发记录.实际数量%Type;
  n_剩余成本金额 药品收发记录.成本金额%Type;
  n_剩余零售金额 药品收发记录.零售金额%Type;
  n_入出系数     药品收发记录.入出系数%Type;
  n_收发id       药品收发记录.Id%Type;
  n_实价卫材     收费项目目录.是否变价%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_平均成本价   药品库存.平均成本价%Type;

  n_记录数       Number;
  n_小数         Number(2);
  d_效期         药品收发记录.效期%Type;
  d_灭菌日期     药品收发记录.灭菌日期%Type;
  d_灭菌效期     药品收发记录.灭菌效期%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
Begin
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 20 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      v_Err_Msg := '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --主要针对原不分批现在分批的材料，不能对其审核
  Select Count(*)
  Into n_Batch_Count
  From 药品收发记录 A, 材料特性 B
  Where a.药品id = b.材料id And a.No = No_In And a.单据 = 20 And Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And
        ((Nvl(b.库房分批, 0) = 1 And
        a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))) Or Nvl(b.在用分批, 0) = 1);

  If n_Batch_Count > 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的材料，不能冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;

  Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, Max(供药单位id) As 供药单位id, 库房id, 对方部门id, 入出类别id, 入出系数,
         批次, 产地, 批号, 效期, 灭菌日期, 生产日期, 批准文号, 灭菌效期, 成本价, 扣率, 零售价, 摘要, 领用人, 商品条码, 内部条码
  Into n_剩余数量, n_剩余成本金额, n_剩余零售金额, n_上次供应商id, n_库房id, n_对方部门id, n_入出类别id, n_入出系数, n_批次, v_产地, v_批号, d_效期, d_灭菌日期,
       d_上次生产日期, v_批准文号, d_灭菌效期, n_成本价, n_扣率, n_零售价, v_摘要, v_领用人, v_商品条码, v_内部条码
  From 药品收发记录
  Where NO = No_In And 单据 = 20 And 药品id + 0 = 材料id_In And 序号 = 序号_In
  Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 灭菌日期, 生产日期, 批准文号, 灭菌效期, 成本价, 扣率, 零售价, 摘要, 领用人, 商品条码, 内部条码;

  If Nvl(n_剩余数量, 0) = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据中第' || 序号_In || '行的材料已经被冲销完成,不能再冲！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --冲销数量大于剩余数量，不允许
  If Abs(n_剩余数量) < Abs(冲销数量_In) Then
    v_Err_Msg := '[ZLSOFT]剩余数据不能于被冲销数量,不能冲销！[ZLSOFT]';
    Raise Err_Item;
  End If;

  n_成本金额 := Round(冲销数量_In / n_剩余数量 * n_剩余成本金额, n_小数);
  n_零售金额 := Round(冲销数量_In / n_剩余数量 * n_剩余零售金额, n_小数);
  n_差价     := Round(n_零售金额 - n_成本金额, n_小数);

  Select 药品收发记录_Id.Nextval Into n_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 审核人, 审核日期, 供药单位id, 生产日期, 批准文号, 领用人, 扣率, 商品条码, 内部条码)
  Values
    (n_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 20, No_In, 序号_In, n_库房id, n_对方部门id, n_入出类别id, n_入出系数, 材料id_In, n_批次,
     v_产地, v_批号, d_效期, d_灭菌日期, d_灭菌效期, -冲销数量_In, -冲销数量_In, n_成本价, -n_成本金额, n_零售价, -n_零售金额, -n_差价, v_摘要, 填制人_In, 填制日期_In,
     填制人_In, 填制日期_In, Decode(n_上次供应商id, 0, Null, n_上次供应商id), d_上次生产日期, v_批准文号, v_领用人, n_扣率, v_商品条码, v_内部条码);

  --原分批现不分批的材料,在C冲消时，要处理他
  Begin
    Select Count(*)
    Into n_记录数
    From 药品收发记录 A, 材料特性 B
    Where a.药品id = b.材料id And b.材料id + 0 = 材料id_In And a.No = No_In And a.单据 = 20 And Mod(a.记录状态, 3) = 0 And
          Nvl(a.批次, 0) > 0 And
          (Nvl(b.库房分批, 0) = 0 Or
          (Nvl(b.在用分批, 0) = 0 And
          a.库房id In (Select 部门id From 部门性质说明 Where (工作性质 Like '发料部门') Or (工作性质 Like '制剂室'))));
  Exception
    When Others Then
      n_记录数 := 0;
  End;

  If n_记录数 > 0 Then
    n_批次 := 0;
  Else
    n_批次 := Nvl(n_批次, 0);
  End If;
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  --更改药品库存表的相应数据
  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) + Nvl(冲销数量_In, 0), 实际数量 = Nvl(实际数量, 0) + Nvl(冲销数量_In, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(n_零售金额, 0),
      实际差价 = Nvl(实际差价, 0) + Nvl(n_差价, 0),
      零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null),
      商品条码 = Nvl(商品条码, v_商品条码), 内部条码 = Nvl(内部条码, v_内部条码)
  Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(批次, 0) = n_批次 And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (n_库房id, 材料id_In, n_批次, 1, 冲销数量_In, 冲销数量_In, n_零售金额, n_差价, d_效期, d_灭菌效期, Decode(n_上次供应商id, 0, Null, n_上次供应商id),
       n_成本价, v_批号, d_上次生产日期, v_产地, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_扣率, v_商品条码,
       v_内部条码, n_成本价);
  End If;

  Delete 药品库存
  Where 库房id = n_库房id And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  Zl_材料收发记录_调价修正(n_收发id);

  --病人信息处理
  Insert Into 材料领用信息
    (收发id, 材料id, 病人id, 主页id, 姓名, 性别, 年龄, 床号, 医疗付款方式, 当前科室id, 当前病区id, 使用时间, 条码)
    Select n_收发id, 材料id, 病人id, 主页id, 姓名, 性别, 年龄, 床号, 医疗付款方式, 当前科室id, 当前病区id, 使用时间, 条码
    From 材料领用信息
    Where 收发id In (Select ID
                   From 药品收发记录
                   Where NO = No_In And 单据 = 20 And 药品id + 0 = 材料id_In And 序号 = 序号_In And
                         记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3));

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料领用_Strike;
/

--90160:胡俊勇,2016-11-28,医嘱附费判断
--96408:梁唐彬,2016-05-18,回退医嘱时检查附费问题
Create Or Replace Procedure Zl_病人医嘱记录_回退
(
  医嘱id_In     病人医嘱记录.Id%Type,
  Flag_In       Number := 0,
  医嘱内容_In   病人医嘱记录.医嘱内容%Type := Null,
  操作类型_In   病人医嘱状态.操作类型%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
  --功能：回退住院医嘱的状态操作或发送操作(回退重整操作通过调用Zl_病人医嘱记录_批量回退来进行)
  --参数：医嘱ID_IN=一组医嘱ID
  --      FLAG_IN=附加数据。回退停止：0=清除执行终止时间,1=保留现有的执行终止时间。
  --      医嘱内容_IN=该过程被批量回退调用时才用，用于错误提示。
  --      操作类型_IN=该过程被批量回退调用时才用，用于核对回退数据。0-回退发送,n=回退具体医嘱操作
) Is
  --包含指定医嘱的操作记录,第一条为要回退的内容(状态操作优先)
  --临嘱不回退发送后的自动停止,在回退发送时自动回退停止操作
  Cursor c_Rolladvice Is
    Select b.操作人员, b.操作时间, 0 As 发送号, b.操作类型, 0 As 执行状态, Sysdate + Null As 首次时间, Sysdate + Null As 末次时间, a.上次执行时间, a.医嘱期效,
           a.诊疗类别 As 类别, a.诊疗项目id, Null As 类型, a.病人id, a.主页id, a.婴儿, 0 As 记录性质, 0 As 门诊记帐, 0 As 开嘱科室id, a.审核标记, a.开嘱医生,
           a.执行科室id
    From 病人医嘱记录 A, 病人医嘱状态 B
    Where a.Id = b.医嘱id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
          (Nvl(a.医嘱期效, 0) = 0 And b.操作类型 Not In (1, 2, 3) Or Nvl(a.医嘱期效, 0) = 1 And b.操作类型 Not In (1, 2, 3, 8))
    Union
    Select b.发送人 As 操作人员, b.发送时间 As 操作时间, b.发送号, -null As 操作类型, b.执行状态, b.首次时间, b.末次时间, a.上次执行时间, a.医嘱期效, c.类别, a.诊疗项目id,
           c.操作类型 As 类型, a.病人id, a.主页id, a.婴儿, b.记录性质, b.门诊记帐, a.开嘱科室id, a.审核标记, a.开嘱医生, a.执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 诊疗项目目录 C
    Where a.Id = b.医嘱id And a.诊疗项目id = c.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By 操作时间 Desc, 发送号;
  r_Rolladvice c_Rolladvice%RowType;

  --方式同c_Rolladvice，只取发送部份用了自动回退处理
  Cursor c_Rollsend(v_发送号 病人医嘱发送.发送号%Type) Is
    Select Distinct b.医嘱id, b.发送时间 As 操作时间, b.发送号, b.执行状态, a.诊疗类别 As 类别, c.当前病区id As 病人病区id, a.病人科室id,
                    b.执行部门id As 执行科室id
    From 病人医嘱记录 A, 病人医嘱发送 B, 病案主页 C
    Where a.Id = b.医嘱id And b.发送号 = v_发送号 And a.病人id = c.病人id And a.主页id = c.主页id And
          (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In)
    Order By b.发送时间 Desc, b.发送号;

  --根据医嘱及发送NO求出本次回退要销帐的费用记录
  --一组医嘱并不是都填写了发送记录,且可能NO不同(药品有,用法煎法不一定有)
  --不管发送记录的计费状态(可能无需计费),有费用记录自然关联出来
  --费用只求价格父号为空的,以便取序号销帐
  --只管记录状态为1的费用,对于已销帐或部份销帐的记录,不再处理；其中"记录状态=3"的读取出来仅用于判断，不处理。
  Cursor c_Rollmoneyout
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 门诊费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  Cursor c_Rollmoneyin
  (
    v_发送号    病人医嘱发送.发送号%Type,
    v_医嘱id    病人医嘱记录.Id%Type,
    t_Adviceids t_Numlist
  ) Is
    Select /*+ Rule*/
     a.Id, a.记录状态, a.No, a.序号, a.收费类别, a.执行状态, d.跟踪在用, a.执行部门id, a.记录性质
    From 住院费用记录 A, Table(t_Adviceids) B, 病人医嘱发送 C, 材料特性 D
    Where c.医嘱id = b.Column_Value And c.发送号 = v_发送号 And a.医嘱序号 = b.Column_Value And
          (a.医嘱序号 = v_医嘱id Or Nvl(v_医嘱id, 0) = 0) And a.记录状态 In (0, 1, 3) And a.No = c.No And a.记录性质 = c.记录性质 And
          a.价格父号 Is Null And a.收费细目id = d.材料id(+)
    Order By a.No, a.序号;

  --取发送住院记帐时自动发放的卫材(还没有退料的)
  Cursor c_Stuff_Drug(v_费用id 药品收发记录.费用id%Type) Is
    Select ID
    From 药品收发记录
    Where 费用id = v_费用id And (记录状态 = 1 Or Mod(记录状态, 3) = 0) And 审核人 Is Not Null
    Order By 药品id;

  --用于处理特殊医嘱的回退
  Cursor c_Patilog
  (
    v_病人id 病人变动记录.病人id%Type,
    v_主页id 病人变动记录.主页id%Type
  ) Is
    Select *
    From 病人变动记录
    Where 病人id = v_病人id And 主页id = v_主页id And 终止时间 Is Null
    Order By 开始时间 Desc;
  r_Patilog c_Patilog%RowType;

  Cursor c_Adviceids Is
    Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
  t_Adviceids t_Numlist;

  v_医嘱状态     病人医嘱记录.医嘱状态%Type;
  v_医嘱期效     病人医嘱记录.医嘱期效%Type;
  v_费用no       病人医嘱发送.No%Type;
  v_费用序号     Varchar2(255);
  v_末次时间     病人医嘱发送.末次时间%Type;
  v_重整时间     病人医嘱状态.操作时间%Type;
  v_操作类型     诊疗项目目录.操作类型%Type;
  v_执行频率     诊疗项目目录.执行频率%Type;
  v_上次时间     病人医嘱记录.上次执行时间%Type;
  v_执行时间     病人医嘱记录.执行时间方案%Type;
  v_开始执行时间 病人医嘱记录.开始执行时间%Type;
  v_上次打印时间 病人医嘱记录.上次打印时间%Type;
  v_频率间隔     病人医嘱记录.频率间隔%Type;
  v_间隔单位     病人医嘱记录.间隔单位%Type;
  v_发送号       病人医嘱发送.发送号%Type;
  n_护理等级id   病人变动记录.护理等级id%Type;
  d_开始时间     病人变动记录.开始时间%Type;
  d_操作时间     病人医嘱状态.操作时间%Type;
  v_Tmp发送号    病人医嘱发送.发送号%Type;
  n_执行         Number;

  Intdigit   Number(3);
  v_Update   Number(1);
  v_Count    Number(5);
  v_Temp     Varchar2(2000);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  v_Time     Varchar2(4000);
  n_Blndo    Number;

  v_Error Varchar2(2000);
  Err_Custom Exception;

  Function Checkmoneyundo
  (
    v_No       住院费用记录.No%Type,
    v_记录性质 住院费用记录.记录性质%Type,
    v_序号     住院费用记录.序号%Type,
    n_场合     Number := 0 --0住院，1门诊
  ) Return Number Is
    n_Num      Number;
    n_执行状态 Number;
  Begin
    n_Num := 0;
    If n_场合 = 0 Then
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 住院费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    Else
      Select Nvl(Sum(Nvl(付数, 1) * 数次), 0) As 数量
      Into n_Num
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 In (2, 3);
      Select Nvl(执行状态, 0)
      Into n_执行状态
      From 门诊费用记录
      Where NO = v_No And 记录性质 = v_记录性质 And 序号 = v_序号 And 记录状态 = 3;
    End If;
    If n_Num <> 0 Then
      n_Num := 1;
    End If;
    --如果主记录是已执行（部分执行的）则不自动退。
    If n_执行状态 <> 0 Then
      n_Num := 0;
    End If;
    Return(n_Num);
  End;
Begin
  v_Tmp发送号 := -1;
  Open c_Rolladvice;
  Loop
    Fetch c_Rolladvice
      Into r_Rolladvice;
    If c_Rolladvice%RowCount = 0 Then
      Close c_Rolladvice;
      v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前没有可以回退的内容。';
      Raise Err_Custom;
    End If;
    Exit When c_Rolladvice%NotFound;
    Exit When d_操作时间 <> r_Rolladvice.操作时间 And d_操作时间 Is Not Null;
    d_操作时间 := r_Rolladvice.操作时间;
  
    --批量回退调用时判断
    If 医嘱内容_In Is Not Null Then
      If Nvl(r_Rolladvice.操作类型, 0) <> Nvl(操作类型_In, 0) Then
        v_Error := Nvl(医嘱内容_In, '该医嘱') || '不能与当前医嘱一起回退，可能该医嘱已经执行了其他操作。';
        Raise Err_Custom;
      End If;
    End If;
  
    --一组发送号只执行一次
    If v_Tmp发送号 <> r_Rolladvice.发送号 Then
      v_Tmp发送号 := r_Rolladvice.发送号;
      n_执行      := 1;
    Else
      n_执行 := 0;
    End If;
  
    If n_执行 = 1 Then
      Open c_Adviceids;
      Fetch c_Adviceids Bulk Collect
        Into t_Adviceids;
      Close c_Adviceids;
    
      If r_Rolladvice.发送号 = 0 Then
        --回退医嘱状态操作(以时间关键字)
        --4-作废；5-重整；6-暂停；7-启用；8-停止；9-确认停止；10-皮试结果;13-停嘱申请
        ------------------------------------------------------------------
        --最多只能退回到校对状态
        If r_Rolladvice.操作类型 = 3 Then
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '当前处于通过校对状态，不能再回退。';
          Raise Err_Custom;
        Elsif r_Rolladvice.操作类型 = 4 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          If r_Rolladvice.类别 = 'H' Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              v_Error := '护理等级作废后不能再回退。';
              Raise Err_Custom;
            End If;
          End If;
        End If;
      
        --检查是否回退最近次重整之前的操作
        If r_Rolladvice.操作类型 <> 5 Then
          --取最后重整时间
          Select Nvl(医嘱重整时间, To_Date('1900-01-01', 'YYYY-MM-DD'))
          Into v_重整时间
          From 病案主页
          Where 病人id = r_Rolladvice.病人id And 主页id = r_Rolladvice.主页id;
        
          If r_Rolladvice.操作时间 < v_重整时间 Then
            v_Error := '该病人最近次重整之前的操作不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        --删除(该组医嘱)最近的状态操作记录
        Delete /*+ Rule*/
        From 病人医嘱状态
        Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 操作时间 = r_Rolladvice.操作时间;
      
        --取删除后应恢复的医嘱状态
        Select 操作类型
        Into v_医嘱状态
        From 病人医嘱状态
        Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
      
        --恢复(该组医嘱)回退后的状态
        Update 病人医嘱记录 Set 医嘱状态 = v_医嘱状态 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --其它额外的处理
        If r_Rolladvice.操作类型 = 8 Then
          --被超期发送收回过的医嘱 ，如果是销帐申请模式，则判断对应的“病人费用销帐”申请是否取消，是则允许回退，否则不允许，
          --                       如果是产生负数费用模式，则不允许再回退。
          --可能超期发送收回时被全部收回(无上次执行时间)
          Select /*+ Rule*/
           Nvl(Count(*), 0)
          Into v_Count
          From 病人医嘱记录 A, 病人医嘱发送 B
          Where b.医嘱id = a.Id And (a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) And
                b.发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                a.执行终止时间 Is Not Null And ((a.上次执行时间 < b.末次时间) Or (a.上次执行时间 Is Null And b.末次时间 Is Not Null));
          If v_Count > 0 Then
            If zl_GetSysParameter('超期收回产生负数费用', 1254) = '1' Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
              Raise Err_Custom;
            Else
              --如果已经取消销帐申请，则允许回退.
              Select Count(1)
              Into v_Count
              From 病人费用销帐 A, 住院费用记录 B, 病人医嘱记录 C
              Where a.费用id = b.Id And c.Id = b.医嘱序号 And (c.Id = 医嘱id_In Or c.相关id = 医嘱id_In);
              If v_Count > 0 Then
                v_Error := Nvl(医嘱内容_In, '该医嘱') || '已被超期发送收回，不能再撤消停止操作。';
                Raise Err_Custom;
              Else
                --得到上次执行时间等信息
                Select 上次执行时间, 执行时间方案, 开始执行时间, 上次打印时间, 频率间隔, 间隔单位
                Into v_上次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位
                From 病人医嘱记录
                Where ID = 医嘱id_In;
                v_上次时间 := To_Date(To_Char(v_上次时间 + 1 / 24 / 60 / 60, 'yyyy-MM-dd hh24:mi:ss'), 'yyyy-MM-dd hh24:mi:ss');
              
                --修改上次执行时间为收回后的末次执行时间。
                v_末次时间 := Null;
                Begin
                  --一组医嘱的发送首末时间相同,一并给药是取最小的
                  --取相关ID为NULL的医嘱的发送记录的时间
                  --但给药途径或中药用法可能未填写发送记录
                  Select /*+ Rule*/
                   末次时间, 发送号
                  Into v_末次时间, v_发送号
                  From 病人医嘱发送
                  Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                        发送号 = (Select Max(发送号)
                               From 病人医嘱发送
                               Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And Rownum = 1;
                Exception
                  When Others Then
                    Null;
                End;
                Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
              
                --还原医嘱执行时间
                Select Zl_Adviceexetimes(医嘱id_In, v_上次时间, v_末次时间, v_执行时间, v_开始执行时间, v_上次打印时间, v_频率间隔, v_间隔单位, 0)
                Into v_Time
                From Dual;
                Insert Into 医嘱执行时间
                  (要求时间, 医嘱id, 发送号)
                  Select To_Date(Column_Value, 'yyyy-mm-dd hh24:mi:ss'), 医嘱id_In, v_发送号
                  From Table(f_Str2list(v_Time));
              End If;
            End If;
          End If;
        
          --护理等级变动，后续有其他变动时，不允许回退
          If r_Rolladvice.类别 = 'H' And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
            Select 操作类型, 执行频率 Into v_操作类型, v_执行频率 From 诊疗项目目录 Where ID = r_Rolladvice.诊疗项目id;
            If v_操作类型 = '1' And v_执行频率 = '2' Then
              Select Count(*), Max(a.护理等级id), Max(a.开始时间)
              Into v_Count, n_护理等级id, d_开始时间
              From 病人变动记录 A
              Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6 And a.终止时间 Is Null And
                    a.附加床位 = 0;
              --如果没有找到最后一条是护理等级变动则禁止
              If v_Count = 0 Then
                --医嘱护理等级和入住时候的护理等级一致时要单独判断
                Select Count(*)
                Into v_Count
                From 病人变动记录 A
                Where a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.开始原因 = 6;
                If v_Count > 0 Then
                  v_Error := '由于护理等级医嘱停止后该病人已经产生了其他变动记录,不能回退该医嘱的停止操作。';
                  Raise Err_Custom;
                End If;
              Else
                --如果n_护理等级ID为Null，则检查是否是当前回退的医嘱对应的变动记录,目的是有多个护理等级医嘱时要求按顺序回退。
                --如果n_护理等级ID不为Null，则有可能是校对下一条护理等级时，自动停止的，未产生变动记录，
                --     则需要检查当前最后一条变动的护理等级ID是否是当前医嘱的护理等级ID,目的是有多个护理等级医嘱时要求按顺序回退，如果是则不需要再撤销最后一次变动，直接回退医嘱即可。
                If n_护理等级id Is Null Then
                  Select Count(*)
                  Into v_Count
                  From 病人变动记录 B, 病人医嘱计价 C
                  Where b.病人id = r_Rolladvice.病人id And b.主页id = r_Rolladvice.主页id And c.医嘱id = 医嘱id_In And
                        c.收费细目id = b.护理等级id And b.终止时间 = d_开始时间 And b.终止原因 = 6 And b.附加床位 = 0;
                Else
                  --开始时间只取分钟对比，校对的时候护理等级的开始时间是医嘱开始时间+当前时间的秒钟
                  Select Count(*)
                  Into v_Count
                  From 病人医嘱计价 C, 病人医嘱记录 A
                  Where a.Id = c.医嘱id And a.Id = 医嘱id_In And c.收费细目id = n_护理等级id And
                        a.开始执行时间 = To_Date(To_Char(d_开始时间, 'yyyy-mm-dd hh24:mi'), 'yyyy-mm-dd hh24:mi');
                End If;
                If v_Count = 0 Then
                  v_Error := '您回退的医嘱不是最后一条护理等级医嘱，请将后面的护理等级医嘱作废后再回退本条医嘱。';
                  Raise Err_Custom;
                End If;
              
                If n_护理等级id Is Null Then
                  --当前操作人员
                  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
                    v_人员编号 := 操作员编号_In;
                    v_人员姓名 := 操作员姓名_In;
                  Else
                    v_Temp     := Zl_Identity;
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
                    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
                    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
                  End If;
                
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, '1', Null, Null, '护理等级变动');
                End If;
              End If;
            End If;
          End If;
          
          If r_Rolladvice.类别 = 'Z' And  Instr(',9,10,',  ','||r_Rolladvice.类型||',' ) > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then 
            --回退病况医嘱时，调用变动记录回退
            Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '病况变动'); 
          End If;
        
          --回退医嘱停止时,清空停嘱医生和时间,如果是实习医师申请后审核的，则恢复待审核状态
          Update 病人医嘱记录
          Set 执行终止时间 = Decode(Flag_In, 1, 执行终止时间, Null), 停嘱医生 = Null, 停嘱时间 = Null,
              审核标记 = Decode(r_Rolladvice.审核标记, 3, 2, r_Rolladvice.审核标记)
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 9 Then
          --回退医嘱确认停止时,检查是否已打印停嘱时间
          Select /*+ Rule*/
           Count(*)
          Into v_Count
          From 病人医嘱打印
          Where 打印标记 = 1 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '的停嘱时间已经打印，不能再撤消确认停止操作。';
            Raise Err_Custom;
          End If;
        
          --回退医嘱确认停止时,清空停嘱医生和时间
          Update 病人医嘱记录 Set 确认停嘱时间 = Null, 确认停嘱护士 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 10 Then
          --回退标注皮试结果,同时删除过敏登记(+)或(-),根据记录时间
          Delete From 病人过敏记录
          Where 病人id = r_Rolladvice.病人id And Nvl(主页id, 0) = Nvl(r_Rolladvice.主页id, 0) And 记录时间 = r_Rolladvice.操作时间;
        
          Update 病人医嘱记录 Set 皮试结果 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        Elsif r_Rolladvice.操作类型 = 13 Then
          If Instr(r_Rolladvice.开嘱医生, '/') > 0 Then
            Update 病人医嘱记录 Set 审核标记 = 1 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          Else
            Update 病人医嘱记录 Set 审核标记 = Null Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
          End If;
        End If;
      Else
        --回退医嘱发送(以发送号关键字)
        ------------------------------------------------------------------
        --当前操作人员
        v_Temp     := Zl_Identity;
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      
        --检查是否是输液配液记录，并是否已经锁定，如果查询有数据说明是配液记录
        Begin
          Select Decode(max(是否锁定), 1, 1, 0)
          Into v_Count
          From 输液配药记录
          Where 医嘱id = 医嘱id_In And 发送号 = r_Rolladvice.发送号;
        Exception
          When Others Then
            v_Count := -1;
        End;
      
        If v_Count = 1 Then
          v_Error := '医嘱"' || 医嘱内容_In || '"是输液药品，已经被输液配置中心锁定，不能回退发送。';
          Raise Err_Custom;
        Elsif v_Count = 0 Then
          Zl_输液配药记录_医嘱回退(医嘱id_In, r_Rolladvice.发送号, v_人员姓名, Sysdate);
        End If;
        
        --检查医嘱是否存在有效的医嘱附费
        Select Count(*)
        Into v_Count
        From 病人医嘱附费 A, 住院费用记录 B
        Where a.医嘱id = b.医嘱序号 And a.No = b.No And b.记录状态 = 1 And b.实收金额 <> 0 And a.发送号 = r_Rolladvice.发送号 And A.医嘱id In (Select Column_Value From Table(t_Adviceids));
        If v_Count > 0 Then
          v_Error := '该医嘱下还存在附费项目，请先冲销。';
          Raise Err_Custom;
        End If;
      
        --本科发送自动执行时，回退也自动回退执行(仅护士站有此功能)
        --非跟踪在用的卫材医嘱，同普通医嘱执行处理
        Select 医嘱期效 Into v_医嘱期效 From 病人医嘱记录 Where ID = 医嘱id_In;
        If Substr(zl_GetSysParameter('本科执行自动完成', 1254), v_医嘱期效 + 1, 1) = '1' Then
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into Intdigit From Dual;
        
          For r_Rollsend In c_Rollsend(r_Rolladvice.发送号) Loop
            If Nvl(r_Rollsend.执行状态, 0) = 1 And
               (Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人病区id, 0) Or
                Nvl(r_Rollsend.执行科室id, 0) = Nvl(r_Rollsend.病人科室id, 0)) Then
            
              --医嘱的执行状态
              Update 病人医嘱发送 Set 执行状态 = 0 Where 发送号 = r_Rollsend.发送号 And 医嘱id = r_Rollsend.医嘱id;
              v_Update := 1;
            
              If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
                --费用的执行状态
                For r_Rollmoney In c_Rollmoneyin(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 住院费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --住院科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 2);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              Else
                --住院病人费用发送到门诊的情况，病人来源都是住院的
                For r_Rollmoney In c_Rollmoneyout(r_Rollsend.发送号, r_Rollsend.医嘱id, t_Adviceids) Loop
                  n_Blndo := 0;
                  If r_Rollmoney.记录状态 <> 3 Then
                    n_Blndo := 1;
                  Else
                    n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
                  End If;
                  If n_Blndo > 0 Then
                    If Not (r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1) And
                       Not r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --普通费用直接取消执行状态，不含药品和跟踪在用的卫材
                      Update 门诊费用记录
                      Set 执行状态 = 0, 执行时间 = Null, 执行人 = Null
                      Where NO = r_Rollmoney.No And 记录性质 = r_Rolladvice.记录性质 And 记录状态 = r_Rollmoney.记录状态 And
                            Nvl(价格父号, 序号) = r_Rollmoney.序号 And 医嘱序号 = r_Rollsend.医嘱id;
                    Elsif r_Rollmoney.收费类别 = '4' And Nvl(r_Rollmoney.跟踪在用, 0) = 1 Then
                      If Nvl(zl_GetSysParameter(33), '0') = '1' Then
                        --跟踪在用的卫材，当系统参数为自动发料时，才自动退料
                        For r_Stuff In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_材料收发记录_部门退料(r_Stuff.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, 0, v_人员姓名);
                        End Loop;
                      End If;
                    Elsif r_Rollmoney.收费类别 In ('5', '6', '7') Then
                      --本科室发药的药品自动退药
                      If r_Rollmoney.执行部门id = r_Rollsend.病人病区id Or r_Rollmoney.执行部门id = r_Rollsend.病人科室id Then
                        For r_Drug In c_Stuff_Drug(r_Rollmoney.Id) Loop
                          Zl_药品收发记录_部门退药(r_Drug.Id, v_人员姓名, Sysdate, Null, Null, Null, Null, Null, Null, Intdigit, 1);
                        End Loop;
                      End If;
                    End If;
                  End If;
                End Loop;
              End If;
            End If;
          End Loop;
        End If;
        ------------------------------------------------------------------
        --被超期收回的长期药品医嘱不允许回退(再退费用就多退了)
        If Nvl(r_Rolladvice.医嘱期效, 0) = 0 Then
          If r_Rolladvice.上次执行时间 Is Not Null And r_Rolladvice.末次时间 Is Not Null Then
            If r_Rolladvice.上次执行时间 < r_Rolladvice.末次时间 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近超期发送的内容已被收回，不能再回退。';
              Raise Err_Custom;
            End If;
          Elsif r_Rolladvice.上次执行时间 Is Null And r_Rolladvice.末次时间 Is Not Null Then
            --长嘱可能被全部超期收回
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '未被发送，或发送的内容已被全部超期收回，不能再回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        If Nvl(r_Rolladvice.执行状态, 0) In (1, 3) And v_Update <> 1 Then
          --1-完全执行;3-正在执行
          v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
          Raise Err_Custom;
        Else
          --如果相关医嘱已执行，则也要限制回退（例如：检验的采集方式）
          Select /*+ Rule*/
           Count(1)
          Into v_Count
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And 执行状态 In (1, 3) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids)));
          If v_Count > 0 Then
            v_Error := Nvl(医嘱内容_In, '该医嘱') || '最近发送的内容已经执行或正在执行，不能回退。';
            Raise Err_Custom;
          End If;
        End If;
      
        ------------------------------------------------------------------
        --将该组医嘱的费用销帐(按一组医嘱可能有不同NO处理)
        --如果原始费用已被销帐(或部分销帐),调用过程中有判断
        v_费用no   := Null;
        v_费用序号 := Null;
        If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
          For r_Rollmoney In c_Rollmoneyin(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                Zl_住院记帐记录_Delete(v_费用no, Substr(v_费用序号, 2), v_人员编号, v_人员姓名, 2, 0, 0);
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        Else
          For r_Rollmoney In c_Rollmoneyout(r_Rolladvice.发送号, Null, t_Adviceids) Loop
            --对应的费用已执行
            If Nvl(r_Rollmoney.执行状态, 0) <> 0 And Not (Nvl(r_Rollmoney.执行状态, 0) = -1 And Nvl(r_Rollmoney.记录状态, 0) = 0) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的费用单据"' || r_Rollmoney.No || '"中的内容已被部分或完全执行，不能回退。';
              Raise Err_Custom;
            End If;
            --收费单据已收费
            If r_Rollmoney.记录状态 = 1 And Not (r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1) Then
              v_Error := Nvl(医嘱内容_In, '该医嘱') || '发送的门诊单据"' || r_Rollmoney.No || '"已收费，不能回退。';
              Raise Err_Custom;
            End If;
            n_Blndo := 0;
            If r_Rollmoney.记录状态 <> 3 Then
              n_Blndo := 1;
            Else
              n_Blndo := Checkmoneyundo(r_Rollmoney.No, r_Rollmoney.记录性质, r_Rollmoney.序号, 1);
            End If;
            If n_Blndo > 0 Then
              --这种仅用于判断部分退药
              If v_费用no <> r_Rollmoney.No And v_费用序号 Is Not Null Then
                If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
                  --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
                  Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
                Else
                  Zl_门诊划价记录_Delete(v_费用no, Substr(v_费用序号, 2));
                End If;
                v_费用序号 := Null;
              End If;
              v_费用no   := r_Rollmoney.No;
              v_费用序号 := v_费用序号 || ',' || r_Rollmoney.序号;
            End If;
          End Loop;
        End If;
        If v_费用序号 Is Not Null And v_费用no Is Not Null Then
          v_费用序号 := Substr(v_费用序号, 2);
          If r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 0 Then
            Zl_住院记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名, 2, 0, 0);
          Elsif r_Rolladvice.记录性质 = 2 And Nvl(r_Rolladvice.门诊记帐, 0) = 1 Then
            --住院发送为门诊记帐(如果是门诊医生发送为门诊记帐，门诊医嘱没有回退功能)
            Zl_门诊记帐记录_Delete(v_费用no, v_费用序号, v_人员编号, v_人员姓名);
          Else
            Zl_门诊划价记录_Delete(v_费用no, v_费用序号);
          End If;
        End If;
        --输血医嘱先删除病人医嘱附费
        Delete From 病人医嘱附费 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除医嘱执行时间 (仅主医嘱ID才产生了记录)
        Delete From 医嘱执行时间 Where 发送号 = r_Rolladvice.发送号 And 医嘱id = 医嘱id_In;
      
        --删除发送记录(该组医嘱的)
        Delete /*+ Rule*/
        From 病人医嘱发送
        Where 发送号 = r_Rolladvice.发送号 And 医嘱id In (Select Column_Value From Table(t_Adviceids));
      
        --标记(该组医嘱)上次执行时间(以上次发送的末次执行时间)
        --所有长嘱(包括持续性长嘱)发送时都填写了末次时间
        --临嘱可能没有，且只可能发送了一次。
        v_末次时间 := Null;
        Begin
          --一组医嘱的发送首末时间相同,一并给药是取最小的
          --取相关ID为NULL的医嘱的发送记录的时间
          --但给药途径或中药用法可能未填写发送记录
          Select /*+ Rule*/
           末次时间
          Into v_末次时间
          From 病人医嘱发送
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                发送号 =
                (Select Max(发送号) From 病人医嘱发送 Where 医嘱id In (Select Column_Value From Table(t_Adviceids))) And
                Rownum = 1;
        Exception
          When Others Then
            Null;
        End;
        Update 病人医嘱记录 Set 上次执行时间 = v_末次时间 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      
        --回退临嘱发送时，同时自动回退停止
        If Nvl(r_Rolladvice.医嘱期效, 0) = 1 Then
          --删除(该组临嘱)最近的停止状态操作记录
          Delete /*+ Rule*/
          From 病人医嘱状态
          Where 医嘱id In (Select Column_Value From Table(t_Adviceids)) And
                操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 操作类型 = 8;
          --r_RollAdvice.操作时间:因发送时间可能不与自动停止时间相同。
        
          --取删除后应恢复的医嘱状态
          Select 操作类型
          Into v_医嘱状态
          From 病人医嘱状态
          Where 操作时间 = (Select Max(操作时间) From 病人医嘱状态 Where 医嘱id = 医嘱id_In) And 医嘱id = 医嘱id_In;
        
          --恢复(该组医嘱)回退后的状态
          Update 病人医嘱记录
          Set 医嘱状态 = v_医嘱状态, 执行终止时间 = Null, 停嘱医生 = Null, 停嘱时间 = Null
          Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
        End If;
      
        --住院特殊医嘱发送后的回退(3-转科;5-出院;6-转院,11-死亡)
        If r_Rolladvice.类别 = 'Z' And Instr(',3,5,6,11,',  ','||r_Rolladvice.类型||',') > 0 And Nvl(r_Rolladvice.婴儿, 0) = 0 Then
          Open c_Patilog(r_Rolladvice.病人id, r_Rolladvice.主页id);
          Fetch c_Patilog
            Into r_Patilog;
          If c_Patilog%Found Then
            If r_Rolladvice.类型 = '3' And r_Patilog.开始原因 = 3 Then
              --取消病人转科状态
              If r_Patilog.开始时间 Is Null Then
                --转科医嘱的特殊处理，当一个病人有两条转科医嘱时，只能回退最近的一条,70443
                Select Count(1)
                Into v_Count
                From 病人医嘱记录 A, 诊疗项目目录 B
                Where a.诊疗项目id = b.Id And a.病人id = r_Rolladvice.病人id And a.主页id = r_Rolladvice.主页id And a.诊疗类别 = 'Z' And
                      b.操作类型 = '3' And a.医嘱状态 = 8 And
                      a.开始执行时间 > (Select 开始执行时间 From 病人医嘱记录 Where ID = 医嘱id_In);
                If v_Count = 0 Then
                  Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '转科');
                Else
                  v_Error := '病人转科已经入科，不能再回退。';
                  Raise Err_Custom;
                End If;
              Else
                v_Error := '病人转科已经入科，不能再回退。';
                Raise Err_Custom;
              End If;
            Elsif r_Rolladvice.类型 In ('5', '6', '11') And r_Patilog.开始原因 = 10 Then
              --取消病人预出院状态
              Zl_病人变动记录_Undo(r_Rolladvice.病人id, r_Rolladvice.主页id, v_人员编号, v_人员姓名, Null, Null, Null, '预出院');
            End If;
          End If;
          Close c_Patilog;
        End If;
      
        --回退病历时机
        --1.特殊事件(只有一条医嘱记录)：手术，7-会诊,8-抢救,11-死亡
        If r_Rolladvice.类别 = 'F' Or r_Rolladvice.类别 = 'Z' And Instr(',7,8,11,',  ','||r_Rolladvice.类型||',') > 0 Then
          Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, 医嘱id_In);
        End If;
      
        --2.额外处理：知情同意书(手术相关的知情同意需再次调用，因为附加手术或麻醉项目可能有关联的知情同意书)
        If Instr('C,D,E,F,G,K,L', r_Rolladvice.类别) > 0 Then
          For R In (Select a.Id, a.诊疗类别 From 病人医嘱记录 A Where a.Id = 医嘱id_In Or a.相关id = 医嘱id_In) Loop
            --相关id的一组医嘱不一定是这个类别的，所以要再判断一次类别
            If Instr('C,D,E,F,G,K,L', r.诊疗类别) > 0 Then
              Zl_电子病历时机_Delete(r_Rolladvice.病人id, r_Rolladvice.主页id, '医嘱', r_Rolladvice.开嘱科室id, r.Id);
            End If;
          End Loop;
        End If;
      End If;
    End If;
    Exit When r_Rolladvice.发送号 = 0;
  End Loop;
  Close c_Rolladvice;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_回退;
/

--98351:李业庆,2016-08-19,药房配药控制
Create Or Replace Procedure Zl_药房配药控制_Update
(
  药房id_In   In 药房配药控制.药房id%Type,
  配药_In     In 药房配药控制.配药%Type,
  配药确认_In In 药房配药控制.配药确认%Type := 0
) Is
  n_服务对象 Number(1);
Begin
  Update 药房配药控制 Set 配药确认 = 配药确认_In Where 药房id = 药房id_In And (门诊 = 1 Or 门诊 = 3);
  Update 药房配药控制 Set 配药 = 配药_In Where 药房id = 药房id_In;

  If Sql%RowCount = 0 Then
    Select 服务对象
    Into n_服务对象
    From 部门性质说明
    Where 部门id = 药房id_In And 工作性质 Like '%药房' And Rownum = 1;
    If n_服务对象 = 1 Or n_服务对象 = 3 Then
      Insert Into 药房配药控制 (门诊, 药房id, 配药, 配药确认) Values (1, 药房id_In, 配药_In, 配药确认_In);
    Else
      Insert Into 药房配药控制 (门诊, 药房id, 配药) Values (n_服务对象, 药房id_In, 配药_In);
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药房配药控制_Update;
/

--99870:李业庆,2016-08-23,时价分批零售价问题
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  Delete_In   In Number := 0,
  冲销方式_In In Number := 0,
  发药标志_In In Number := 0,
  财务审核_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:根据明细数据更新库存
  --关键：根据下可用库存参数决定是否处理可用数量
  --业务规则：按照模块分开处理数据，便于后期维护
  --过程适用范围：药品流通业务，涉及到产生药品收发记录明细后再更新库存表并重算库存表平均成本价的业务，该过程
  --只能由其他过程内部调用，不能作为单独过程直接执行
  --参数:
  --     Id_In:药品业务新增、删除、审核、冲销时产生收发记录明细的id
  --     Delete_in: 0--非删除操作业务（新增、审核、冲销） 1--删除操作业务
  --     冲销方式_In: 0--正常冲销方式 1-产生冲销申请单据 2-发送 3-回退 目前只有移库模块有效
  --     发药标志_in: 0--不标记  1--标记  此参数只有药品处方、部门发药模块有效
  --     财务审核_in:0,财务审核单据,1-其他业务
  ----------------------------------------------------------------------------------------
  v_下可用数量 Zlparameters.参数值%Type;
  n_可用数量   药品库存.实际数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_差价       药品库存.实际差价%Type;
  n_时价分批   Number(1);
  n_成本价     药品收发记录.成本价%Type;
  n_零售价     药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;

  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  v_Detail c_Detail%RowType;
Begin
  --取下可用库存参数
  Select zl_GetSysParameter(96) Into v_下可用数量 From Dual;

  For v_Detail In c_Detail Loop
    n_实际数量 := v_Detail.入出系数 * v_Detail.实际数量 * Nvl(v_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_零售金额 := v_Detail.入出系数 * v_Detail.零售金额;
    n_差价     := v_Detail.入出系数 * v_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), Nvl(平均成本价, 0)
      Into n_库存数量, n_库存平均价
      From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
    Exception
      When Others Then
        n_库存数量   := 0;
        n_库存平均价 := 0;
    End;
  
    --外购入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，退库模式时在填单时要根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --冲销时直接按数量加减库存可用数量
    --用数量判断是入库还是退库
    If v_Detail.单据 = 1 Then
      If v_Detail.审核日期 Is Null Then
        --未审核单据，填单或删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --已审核或已冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            --退库要考虑填单时已经处理了可用数量
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --自制入库：对于自制药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于原料药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 2 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --协定入库：对于协定药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于组成药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 3 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --其他入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，负数入库模式时要根据参数处理可用数量，在审核时则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --用数量判断是入库还是退库
    If v_Detail.单据 = 4 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --差价调整，成本价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 5 Then
      n_可用数量 := 0;
    End If;
  
    --移库：移库有两条单据，一条出库单据，一条入库单据；出库单据需要根据下可用库存参数决定是否下可用库存，如果是冲销则可用库存则相反处理
    --在填单不减可用数量时，在发送时预减可用数量，审核时不处理可用数量
    --申请冲销模式时也要根据参数来处理可用数量
    --填单时出库业务根据参数决定是否下库存，入库业务不下库存；删除时出库业务更加参数要把库存还回去，入库业务不还库存
    If v_Detail.单据 = 6 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          --新增、修改、发送、回退、冲销申请
          If v_Detail.记录状态 = 1 Then
            If 冲销方式_In = 2 Then
              --发送
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Elsif 冲销方式_In = 3 Then
              --回退
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := -1 * n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Else
              --新增
              If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            End If;
          Else
            --申请冲销
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        Else
          --删除
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Elsif v_Detail.配药日期 Is Not Null And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = -1 Then
            --出的那笔
            n_可用数量 := 0;
          Else
            --入的那笔
            n_可用数量 := n_实际数量;
          End If;
        Else
          If 冲销方式_In = 0 Then
            --正常冲销审核
            n_可用数量 := n_实际数量;
          Else
            --申请冲销审核
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --领用：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 7 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --发药业务：在填单时固定处理可用数量，在审核时不处理
    --删除单据时要把填单时预减的加回去
    --不再发药标记的可用数量处理等同于删除，填单操作
    If v_Detail.单据 = 8 Or v_Detail.单据 = 9 Or v_Detail.单据 = 10 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          If 发药标志_In = 0 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := -1 * n_实际数量;
          End If;
        Else
          n_可用数量 := -1 * n_实际数量;
        End If;
      Else
        n_可用数量 := 0;
      End If;
    End If;
  
    --其他出库：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 11 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --冲销和审核
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --盘点：填单时盘盈业务不处理可用数量，盘亏业务固定处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    --用入出系数区分盘盈盘亏业务
    If v_Detail.单据 = 12 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --售价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 13 Then
      n_可用数量 := 0;
    End If;
  
    --药品留存：产生发药单据时，已经下了库存，部门发药时，需要将库存加回去
    If v_Detail.单据 = 27 Then
      n_可用数量 := n_实际数量;
    End If;
  
    If v_Detail.批次 > 0 And v_Detail.是否变价 = 1 Then
      n_时价分批 := 1;
    Else
      n_时价分批 := 0;
    End If;
  
    n_零售价 := v_Detail.零售价;
    --特殊单据需要处理成本价 特殊单据有单据=5 单据=12
    If v_Detail.单据 = 5 Or v_Detail.单据 = 12 Then
      If v_Detail.单据 = 5 Then
        If v_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(v_Detail.零售价, 0) / v_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If v_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := v_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(v_Detail.零售价, 0) - Nvl(v_Detail.成本价, 0)) / v_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = v_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := v_Detail.单量;
      End If;
    Else
      If v_Detail.单据 = 13 Then
        n_成本价 := Nvl(v_Detail.单量, 0) - Nvl(v_Detail.频次, 0);
      Else
        n_成本价 := v_Detail.成本价;
      End If;
    End If;
  
    --根据业务数据更新库存记录
    If v_Detail.审核日期 Is Null Then
      If n_可用数量 <> 0 Then
        --填单，删除时只更新可用数量
        Update 药品库存
        Set 可用数量 = 可用数量 + n_可用数量
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, 0, 0, 0, v_Detail.供药单位id, n_成本价,
             v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号, Decode(n_时价分批, 1, n_零售价, Null),
             v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    Else
      --审核时更新库存可用数量，实际数量，库存金额，库存差价等数据
      If v_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If v_Detail.摘要 = '外购退库差价误差自动修正' Or v_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, n_差价, v_Detail.批号, v_Detail.效期, v_Detail.产地,
               v_Detail.供药单位id, v_Detail.生产日期, v_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          
            Insert Into 药品入库信息
              (药品id, 库房id, 批次, 入库日期)
              Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
              From Dual
              Where Not Exists (Select 1
                     From 药品入库信息
                     Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
          End If;
        End If;
      Elsif v_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        Update 药品库存
        Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价分批, 1, n_零售价, Null));
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      Else
        --按入库和出库 状态分解
        --入库业务,出库冲销，不分批多种价格入库冲销需要更新库存表所有信息
        If (v_Detail.入出系数 = 1 And v_Detail.记录状态 = 1) Or (v_Detail.入出系数 = -1 And Mod(v_Detail.记录状态, 3) = 2) Or
           (v_Detail.入出系数 = 1 And Mod(v_Detail.记录状态, 3) = 2) Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = v_Detail.供药单位id,
              上次采购价 = Decode(v_Detail.单据, 1, Decode(v_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(v_Detail.批号, 上次批号), 上次生产日期 = Nvl(v_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(v_Detail.产地, 上次产地),
              灭菌效期 = Nvl(v_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(v_Detail.效期, 效期), 批准文号 = Nvl(v_Detail.批准文号, 批准文号),
              上次扣率 = Decode(v_Detail.单据, 1, v_Detail.扣率, 上次扣率), 商品条码 = Nvl(v_Detail.商品条码, 商品条码),
              内部条码 = Nvl(v_Detail.内部条码, 内部条码)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          --外购入库和其他入库审核时
          If (v_Detail.单据 = 1 And v_Detail.记录状态 = 1 And 财务审核_In = 0) Or (v_Detail.单据 = 4 And v_Detail.记录状态 = 1) Then
            Update 药品库存
            Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null)
            Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          End If;
          --不分批入库需要重算成本价
          --外购退货、财务审核和所有冲销业务不更新平均成本价，保持当前价格
          If (v_Detail.单据 = 1 And v_Detail.发药方式 = 1) Or Mod(v_Detail.记录状态, 3) = 2 Or (v_Detail.单据 = 1 And 财务审核_In = 1) Then
            Null;
          Else
            --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
            n_总数量 := (n_库存数量 + n_实际数量);
            If n_总数量 <> 0 Then
              n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
              Update 药品库存
              Set 平均成本价 = n_总成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          --出库业务只需要更新数量、金额、差价
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        End If;
        --库存表未找到数据则需要产生库存表所有信息
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, v_Detail.供药单位id,
             n_成本价, v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号,
             Decode(n_时价分批, 1, n_零售价, Null), v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    End If;
  
    --删除多余的库存数据
    If 财务审核_In = 0 Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/

--79968:余伟节,2016-08-30,新生儿登记身长、体重、血型、备注说明
Create Or Replace Procedure Zl_病人新生儿记录_Insert
(
  病人id_In   病人新生儿记录.病人id%Type,
  主页id_In   病人新生儿记录.主页id%Type,
  序号_In     病人新生儿记录.序号%Type,
  婴儿姓名_In 病人新生儿记录.婴儿姓名%Type,
  婴儿性别_In 病人新生儿记录.婴儿性别%Type,
  分娩次数_In 病人新生儿记录.分娩次数%Type,
  分娩方式_In 病人新生儿记录.分娩方式%Type,
  胎儿状况_In 病人新生儿记录.胎儿状况%Type,
  出生时间_In 病人新生儿记录.出生时间%Type,
  身长_In     病人新生儿记录.身长%Type,
  体重_In     病人新生儿记录.体重%Type,
  血型_In     病人新生儿记录.血型%Type,
  备注说明_In 病人新生儿记录.备注说明%Type := Null
) Is
Begin
  Insert Into 病人新生儿记录
    (病人id, 主页id, 序号, 婴儿姓名, 婴儿性别, 分娩次数, 分娩方式, 胎儿状况, 身长, 体重, 血型, 出生时间, 备注说明)
  Values
    (病人id_In, 主页id_In, 序号_In, 婴儿姓名_In, 婴儿性别_In, 分娩次数_In, 分娩方式_In, 胎儿状况_In, 身长_In, 体重_In, 血型_In, 出生时间_In, 备注说明_In);

  Zl_病区自动标记_Update(病人id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人新生儿记录_Insert;
/

--100189:李业庆,2016-09-20,库存不严格控制时库存数量为0允许出库
Create Or Replace Procedure Zl_病人门诊收费_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  保险大类id_In 门诊费用记录.保险大类id%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  摘要_In       门诊费用记录.摘要%Type := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  中药形态_In   门诊费用记录.结论%Type := Null
) As
  --功能：新收一张门诊收费单据
  --参数：
  --  病人来源_IN:1-门诊;2-住院  住院病人收费时用。
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock(n_Outmode Number) Is
    Select *
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = 执行部门id_In And 性质 = 1 And (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And
          Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  v_分批 药品规格.药房分批%Type;
  v_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  v_总数量   Number;
  v_当前数量 Number;
  v_总金额   Number;
  v_当前单价 Number;
  --药品收发记录
  v_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_序号       药品收发记录.序号%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_灭菌日期   药品收发记录.灭菌日期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;

  v_煎法 药品收发记录.外观%Type;
  ------------------------------------------------------------
  --结算方式串
  v_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;

  --临时变量
  n_Outmode Number(1);
  v_Count   Number;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_单价小数 Number;
  n_出库检查   Number(1);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
     保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
     执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 结论, 缴款组id)
  Values
    (v_费用id, 1, No_In, 1, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In),
     Decode(病人来源_In, 1, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 付款方式_In, 姓名_In, 性别_In,
     年龄_In, 病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 保险项目否_In, 保险大类id_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In,
     收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 0, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In,
     0, 1, 结帐id_In, 实收金额_In, 操作员编号_In, 操作员姓名_In, 摘要_In, 是否急诊_In, 中药形态_In, n_组id);

  --药品和卫生材料部分
  v_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
  
    v_总数量 := 付数_In * 数次_In;
    v_总金额 := 0;
    Open c_Stock(n_Outmode);
    
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = 执行部门id_In;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = 执行部门id_In;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
      
    While v_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If v_分批 = 1 Or v_时价 = 1 Then
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
          Else
            v_Error := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
          End If;
          Raise Err_Custom;
        End If;
      Elsif (v_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (v_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
        Else
          v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
        End If;
        Raise Err_Custom;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (v_总数量 > 0 Or v_时价 = 1) And n_出库检查=2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
          Else
            v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
          End If;
          Raise Err_Custom;
        End If;
      End If;
    
      --确定本次分解数量
      If v_分批 = 1 Or v_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If v_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          v_当前数量 := v_总数量;
        Else
          v_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If v_时价 = 1 Then
          v_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif v_分批 = 1 Then
          v_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        v_当前数量 := v_总数量;
        v_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * v_当前数量);
        End If;
      End If;
    
      --药品收发记录
      v_批次       := Null;
      v_批号       := Null;
      v_效期       := Null;
      v_产地       := Null;
      v_灭菌效期   := Null;
      v_灭菌日期   := Null;
      v_供药单位id := Null;
      v_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        v_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        v_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        v_供药单位id := r_Stock.上次供应商id;
        v_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            v_灭菌效期 := r_Stock.灭菌效期;
            v_灭菌日期 := v_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into v_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If v_分批 = 1 And v_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      --注意卫材单据与药品单据不同
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 灭菌效期, 灭菌日期, 外观, 供药单位id, 生产日期, 批准文号)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, v_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         v_批次, v_产地, v_批号, v_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In),
         Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In), v_当前单价, Round(v_当前单价 * v_当前数量, v_Dec), Null, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, v_灭菌效期, v_灭菌日期, v_煎法, v_供药单位id, v_生产日期, v_批准文号);
    
      v_总数量 := v_总数量 - v_当前数量;
      v_总金额 := v_总金额 + Round(v_当前数量 * v_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录:可能同一个库房,但一个为药品,一个为卫材,插入两条记录。
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 发药窗口 = Nvl(发药窗口_In, 发药窗口) --可能药品和材料用同一个库房,但材料无发药窗口
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), Null, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 1, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If v_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If v_当前数量 <> 付数_In * 数次_In Then
        v_当前单价 := Round(v_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If v_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        Else
          v_Error := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And Nvl(病人来源_In, 1) = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人门诊收费_Insert;
/

--100189:李业庆,2016-09-20,库存不严格控制时库存数量为0允许出库
Create Or Replace Procedure Zl_门诊收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  保险大类id_In 门诊费用记录.保险大类id%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  原no_In       门诊费用记录.No%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  摘要_In       门诊费用记录.摘要%Type := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null
) As
  --功能：新收一张门诊收费单据
  --参数：
  --  病人来源_IN:1-门诊;2-住院  住院病人收费时用。
  --  原NO_IN:修改保存新单据时用。目前用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  -- 收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  -- 保险结算_IN:格式="结算方式|结算金额||....."

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  --不包含结算方式为代收款项的预交款。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select *
    From (Select a.Id, a.记录状态, a.No, Nvl(a.金额, 0) As 金额
           From 病人预交记录 A,
                (Select NO, Sum(Nvl(a.金额, 0)) As 金额
                  From 病人预交记录 A
                  Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.病人id = v_病人id And 预交类别 = 1
                  Group By NO
                  Having Sum(Nvl(a.金额, 0)) <> 0) B
           Where a.结帐id Is Null And Nvl(a.金额, 0) <> 0 And a.预交类别 = 1 And
                 a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5) And a.No = b.No And a.病人id = v_病人id
           Union All
           Select 0 As ID, 记录状态, NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额
           From 病人预交记录
           Where 记录性质 In (1, 11) And 结帐id Is Not Null And Nvl(金额, 0) <> Nvl(冲预交, 0) And 病人id = v_病人id And 预交类别 = 1 Having
            Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
           Group By 记录状态, NO)
    Order By ID, NO;

  v_费用id   门诊费用记录.Id%Type;
  v_优先级   未发药品记录.优先级%Type;
  v_预交金额 病人预交记录.冲预交%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock(n_Outmode Number) Is
    Select *
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = 执行部门id_In And 性质 = 1 And (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And
          Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  v_分批 药品规格.药房分批%Type;
  v_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  v_总数量   Number;
  v_当前数量 Number;
  v_总金额   Number;
  v_当前单价 Number;
  --药品收发记录
  v_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_序号       药品收发记录.序号%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_灭菌日期   药品收发记录.灭菌日期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;

  v_煎法 药品收发记录.外观%Type;
  ------------------------------------------------------------
  --结算方式串
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_返回值   病人余额.费用余额%Type;

  v_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;

  --临时变量
  n_Outmode Number(1);
  v_Count   Number;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_单价小数 Number;
  n_出库检查   Number(1);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(Zl_Getsysparameter(9), '2')), Zl_To_Number(Nvl(Zl_Getsysparameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
     保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
     执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 结论, 缴款组id)
  Values
    (v_费用id, 1, No_In, 1, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In),
     Decode(病人来源_In, 1, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 付款方式_In, 姓名_In, 性别_In,
     年龄_In, 病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 保险项目否_In, 保险大类id_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In,
     收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 0, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In,
     0, 结帐id_In, 实收金额_In, 操作员编号_In, 操作员姓名_In, 摘要_In, 是否急诊_In, 中药形态_In, n_组id);

  If 序号_In = 1 Then
    --病人预交记录(第一行时处理)
    --正常结算
    If 收费结算_In Is Not Null Then
      --各个收费结算
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
      
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
        v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, 登记时间_In,
             操作员编号_In, 操作员姓名_In, v_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
             Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, 登记时间_In, 操作员编号_In,
             操作员姓名_In, v_结算金额, 结帐id_In, n_组id, 3);
        End If;
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --预交结算
    If Nvl(冲预交额_In, 0) <> 0 Then
      If Nvl(病人id_In, 0) = 0 Then
        v_Error := '不能确定病人病人ID,收费使用预交款结算失败！';
        Raise Err_Custom;
      End If;
    
      v_预交金额 := 冲预交额_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        If r_Deposit.Id <> 0 Then
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - v_预交金额), -1, r_Deposit.金额, v_预交金额), 结帐id_In,
                 n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        --检查是否已经处理完
        If r_Deposit.金额 < v_预交金额 Then
          v_预交金额 := v_预交金额 - r_Deposit.金额;
        Else
          v_预交金额 := 0;
        End If;
        If v_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      --检查金额是否足够
      If v_预交金额 > 0 Then
        v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
        Raise Err_Custom;
      End If;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交额_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -冲预交额_In, 1, 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  --相关汇总表的处理
  --汇总"人员缴款余额"(注意要处理个人帐户的结算)
  n_返回值 := 0;
  If 序号_In = 1 Then
    --各个收费结算
    If 收费结算_In Is Not Null Then
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    End If;
  
    --药品分批出库方式
    Select Zl_To_Number(Nvl(Zl_Getsysparameter(150), 0)) Into n_Outmode From Dual;
  
    v_总数量 := 付数_In * 数次_In;
    v_总金额 := 0;
    Open c_Stock(n_Outmode);
  
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = 执行部门id_In;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = 执行部门id_In;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
    
    While v_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If v_分批 = 1 Or v_时价 = 1 Then
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
          Else
            v_Error := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
          End If;
          Raise Err_Custom;
        End If;
      Elsif (v_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (v_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
        Else
          v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
        End If;
        Raise Err_Custom;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (v_总数量 > 0 Or v_时价 = 1) And n_出库检查=2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
          Else
            v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
          End If;
          Raise Err_Custom;
        End If;
      End If;
    
      --确定本次分解数量
      If v_分批 = 1 Or v_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If v_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          v_当前数量 := v_总数量;
        Else
          v_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If v_时价 = 1 Then
          v_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif v_分批 = 1 Then
          v_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        v_当前数量 := v_总数量;
        v_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * v_当前数量);
        End If;
      End If;
    
      --药品收发记录
      v_批次       := Null;
      v_批号       := Null;
      v_效期       := Null;
      v_产地       := Null;
      v_灭菌效期   := Null;
      v_灭菌日期   := Null;
      v_供药单位id := Null;
      v_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        v_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        v_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        v_供药单位id := r_Stock.上次供应商id;
        v_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            v_灭菌效期 := r_Stock.灭菌效期;
            v_灭菌日期 := v_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into v_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If v_分批 = 1 And v_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      --注意卫材单据与药品单据不同
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 灭菌效期, 灭菌日期, 外观, 供药单位id, 生产日期, 批准文号)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, v_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         v_批次, v_产地, v_批号, v_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In),
         Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In), v_当前单价, Round(v_当前单价 * v_当前数量, v_Dec), 原no_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, v_灭菌效期, v_灭菌日期, v_煎法, v_供药单位id, v_生产日期, v_批准文号);
    
      v_总数量 := v_总数量 - v_当前数量;
      v_总金额 := v_总金额 + Round(v_当前数量 * v_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录:可能同一个库房,但一个为药品,一个为卫材,插入两条记录。
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 发药窗口 = Nvl(发药窗口_In, 发药窗口) --可能药品和材料用同一个库房,但材料无发药窗口
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), Null, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 1, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If v_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If v_当前数量 <> 付数_In * 数次_In Then
        v_当前单价 := Round(v_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If v_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        Else
          v_Error := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And Nvl(病人来源_In, 1) = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(Zl_Getsysparameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Insert;
/

--85169:梁唐彬,2015-06-12,处方审查系统医嘱部分调整
CREATE OR REPLACE Procedure Zl_病人医嘱记录_处方审查删除
( 
  医嘱ids_In Varchar2 
) Is 
  Cursor c_Advice Is
    Select * From Table(Cast(f_Num2list(医嘱ids_In) As t_Numlist));
 
  v_Error Varchar2(255); 
  Err_Custom Exception; 
Begin 
  For r_Advice In c_Advice Loop
      Update 病人医嘱记录 Set 执行标记 = -1 Where ID = r_Advice.Column_Value Or 相关id = r_Advice.Column_Value; 
  End Loop;
Exception 
  When Err_Custom Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]'); 
  When Others Then 
    Zl_Errorcenter(Sqlcode, Sqlerrm); 
End Zl_病人医嘱记录_处方审查删除;
/

--101538:李业庆,2016-10-28,库存平均成本价和零售价处理
Create Or Replace Procedure Zl_药品收发记录_更改库房
(
  Partid_In       In 药品收发记录.库房id%Type,
  Bill_In         In 药品收发记录.单据%Type,
  No_In           In 药品收发记录.No%Type,
  Otherstockid_In In 药品收发记录.库房id%Type,
  门诊_In         In Number := 1,
  Date_In         In 药品收发记录.填制日期%Type := Null
) Is
  --重新计算用
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 门诊费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null;

  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 住院费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null;

  --用于修正病人未结费用
  Cursor c_Billout Is
    Select b.实收金额, b.病人id, 0 主页id, 0 病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1;

  Cursor c_Billin Is
    Select b.实收金额, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 住院费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1;

  r_Modifybillout c_Modifybillout%RowType;
  r_Modifybillin  c_Modifybillin%RowType;
  r_Billout       c_Billout%RowType;
  r_Billin        c_Billin%RowType;
  v_Count         Number;
  n_成本价        药品收发记录.成本价%Type;
  n_零售价        药品收发记录.零售价%Type;
Begin
  --增加原库房的可以库存，减现库房的可用库存
  If 门诊_In = 1 Then
    --处理门诊
    For r_Modifybillout In c_Modifybillout Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillout.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillout.药品id, r_Modifybillout.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillout.成本价;
        End If;
      
        If r_Modifybillout.是否变价 = 1 And r_Modifybillout.批次 > 0 Then
          --药品/卫材时价分批
          n_零售价 := r_Modifybillout.零售价;
        Else
          n_零售价 := Null;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillout.药品id, r_Modifybillout.批次, 1, 0 - Nvl(r_Modifybillout.数量, 0), 0, 0,
           r_Modifybillout.供药单位id, n_成本价, r_Modifybillout.批号, r_Modifybillout.产地, r_Modifybillout.效期,
           r_Modifybillout.生产日期, r_Modifybillout.批准文号, n_零售价, n_成本价);
      End If;
    End Loop;
  Else
    --处理住院
    For r_Modifybillin In c_Modifybillin Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillin.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillin.药品id, r_Modifybillin.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillin.成本价;
        End If;
      
        If r_Modifybillin.是否变价 = 1 And r_Modifybillin.批次 > 0 Then
          --药品卫材时价分批
          n_零售价 := r_Modifybillin.零售价;
        Else
          n_零售价 := Null;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillin.药品id, r_Modifybillin.批次, 1, 0 - Nvl(r_Modifybillin.数量, 0), 0, 0,
           r_Modifybillin.供药单位id, n_成本价, r_Modifybillin.批号, r_Modifybillin.产地, r_Modifybillin.效期, r_Modifybillin.生产日期,
           r_Modifybillin.批准文号, n_零售价, n_成本价);
      End If;
    End Loop;
  End If;

  --处理发其它药房处方情况，改变库房ID
  If 门诊_In = 1 Then
    --处理门诊
    For r_Billout In c_Billout Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billout.实收金额, 0)
      Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Billout.执行部门id, 0) And
            收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billout.实收金额, 0)
        Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And
              收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billout.病人id, r_Billout.病人科室id, r_Billout.开单部门id, Partid_In, r_Billout.收入项目id, r_Billout.门诊标志,
             Nvl(r_Billout.实收金额, 0));
        End If;
      End If;
    End Loop;
  Else
    --处理住院
    For r_Billin In c_Billin Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billin.实收金额, 0)
      Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Billin.执行部门id, 0) And 收入项目id + 0 = r_Billin.收入项目id And 来源途径 + 0 = r_Billin.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billin.实收金额, 0)
        Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And 收入项目id + 0 = r_Billin.收入项目id And
              来源途径 + 0 = r_Billin.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billin.病人id, r_Billin.主页id, r_Billin.病人病区id, r_Billin.病人科室id, r_Billin.开单部门id, Partid_In,
             r_Billin.收入项目id, r_Billin.门诊标志, Nvl(r_Billin.实收金额, 0));
        End If;
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 金额 = 0;

  If 门诊_In = 1 Then
    Update 门诊费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  Else
    Update 住院费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  End If;

  --修改该单据所有记录(退药后再代发的情况)
  Update 药品收发记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;

  --修改未发药品记录
  Begin
    Select 1 Into v_Count From 未发药品记录 Where 库房id + 0 = Partid_In And NO = No_In And 单据 = Bill_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  If v_Count = 0 Then
    Update 未发药品记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  Else
    Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  End If;

  If Date_In Is Not Null Then
    Delete From 病人费用汇总 Where 日期 >= Date_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_更改库房;
/



---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------
--102830:刘硕,2016-11-21,支持文件下载到多个目录
Update Zltools.Zlfilesupgrade a Set a.附加安装路径 = '[APPSOFT]\DEV_[*]' Where Upper(a.文件名) = 'ZL9LABRECEIV.EXE';
--102526:刘硕,2016-11-21,ZLHISCrust无法自身更新导致无法升级
Update Zltools.Zlfilesupgrade a Set a.文件名 = Upper(a.文件名) Where Upper(a.文件名) = 'ZLHISCRUST.EXE';

--系统版本号
Update zlSystems Set 版本号='10.34.90' Where 编号=&n_System;
--部件版本号
Commit;
