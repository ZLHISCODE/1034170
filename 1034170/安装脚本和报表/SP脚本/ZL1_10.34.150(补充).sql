--[连续升级]1
--[管理工具版本号]10.34.150
--本脚本支持从ZLHIS+ v10.34.140 升级到 v10.34.150
--请以系统所有者登录PLSQL并执行下列脚本
--脚本执行后，请手工升级导出报表
Define n_System=100;
-------------------------------------------------------------------------------
--结构修正部份
-------------------------------------------------------------------------------
--123793:殷瑞,2018-04-02,科室容量设置表添加唯一约束
Alter Table 科室容量设置 Add Constraint 科室容量设置_UQ_科室id Unique(科室id, 配药批次, 配置中心id) Using Index Tablespace Zl9indexhis;

--000000:蒋敏,2018-03-30,标准版和病案系统共有表：分化程度、病案接收记录、疾病编码科室、抢救病因分类、最高诊断依据 表的主键或唯一键缺失(病案系统有)
ALTER TABLE 分化程度 ADD CONSTRAINT 分化程度_PK PRIMARY KEY (编码) USING INDEX  TABLESPACE zl9Indexhis;
ALTER TABLE 分化程度 ADD CONSTRAINT 分化程度_UQ_名称 UNIQUE (名称) USING INDEX  TABLESPACE zl9Indexhis;

ALTER TABLE 病案接收记录 ADD CONSTRAINT 病案接收记录_PK PRIMARY KEY (ID) USING INDEX  TABLESPACE zl9Indexhis;
ALTER TABLE 病案接收记录 ADD CONSTRAINT 病案接收记录_UQ_病人id UNIQUE (病人id,主页ID) USING INDEX  TABLESPACE zl9Indexhis;
ALTER TABLE 病案接收记录 ADD CONSTRAINT 病案接收记录_FK_病人id FOREIGN KEY (病人id) REFERENCES 病人信息(病人ID);
ALTER TABLE 病案接收记录 ADD CONSTRAINT 病案接收记录_FK_主页ID FOREIGN KEY (病人ID,主页ID) REFERENCES 病案主页(病人ID,主页ID);

ALTER TABLE 抢救病因分类 Add CONSTRAINT 抢救病因分类_PK PRIMARY KEY (编码) USING INDEX  TABLESPACE zl9Indexhis;
ALTER TABLE 抢救病因分类 Add CONSTRAINT 抢救病因分类_UQ_名称 UNIQUE (名称) USING INDEX  TABLESPACE zl9Indexhis;

ALTER TABLE 最高诊断依据 ADD CONSTRAINT 最高诊断依据_PK PRIMARY KEY (编码) USING INDEX  TABLESPACE zl9Indexhis;
ALTER TABLE 最高诊断依据 ADD CONSTRAINT 最高诊断依据_UQ_名称 UNIQUE (名称) USING INDEX  TABLESPACE zl9Indexhis;

--123451:黄捷,2018-03-28,RIS接口预约增加打印人和打印时间
alter table RIS检查预约 add 打印时间 date;
alter table RIS检查预约 add 打印人 VARCHAR2(100);

--120765:曾杰,2018-03-21,图像校对
alter table 影像检查记录 add 校对日期 date;
alter table 影像检查记录 add 校对状态 Number(1);
alter table 影像检查图象 add 校对结果 Number(1);
Create Index 影像检查记录_IX_校对状态 On 影像检查记录(校对状态)  Tablespace zl9Indexcis;

--123180:董露露,2018-03-21,邮编录入后回车报错的问题
alter table 区域 add 邮编 varchar2(10);
--122828:董露露,2018-03-14,首页诊断录入时通过简码匹配程序报错
Alter Table 疾病诊断目录 Add 建档时间 Date;
Alter Table 疾病诊断目录 Add 撤档时间 Date;

--121419:刘鹏飞,2018-03-08,医生下达用血申请确定发放血液
alter table 输血申请项目 add 血液信息 varchar2(200);

--122597:秦龙,2018-03-08,药品规格表增加字段图片、使用说明
Alter Table 药品规格 Add 图片 Blob;

Alter Table 药品规格 Add 使用说明 Clob;

--117750:殷瑞,2018-03-07,新增按给药途径的配置费收取方案
alter table 配置收费方案 add 诊疗ID number(18);
ALTER TABLE 配置收费方案 ADD CONSTRAINT 配置收费方案_FK_诊疗ID FOREIGN KEY (诊疗ID) REFERENCES 诊疗项目目录(ID)  On Delete Cascade;
alter table 配置收费方案 drop constraint 配置收费方案_PK Cascade Drop index;
alter table 配置收费方案 add constraint  配置收费方案_UQ_项目ID Unique (项目ID,诊疗ID,配药类型) Using Index Tablespace zl9Indexhis;
alter table 配置收费方案 Modify 项目ID Constraint 配置收费方案_NN_项目ID Not Null;
Create Index 配置收费方案_IX_诊疗ID On 配置收费方案(诊疗ID) Tablespace zl9Indexhis;

--119722:秦龙,2018-03-05,增加字段“来源库房”、“来源药房”
Alter Table 药品采购计划 Add 来源库房 varchar2(200);

Alter Table 药品采购计划 Add 来源药房 varchar2(200);

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
Alter Table 临床出诊表 Add 关联ID Number(18);

Create Index 临床出诊表_IX_关联ID On 临床出诊表(关联ID) Tablespace zl9Indexhis;

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Alter Table 临床出诊停诊记录 Add 停诊号码 Varchar2(600);

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Alter Table 临床出诊表 Add 站点 Varchar2(1);
Alter Table 临床出诊表 Drop Constraint 临床出诊表_UQ_出诊表名 Cascade drop Index;
Alter Table 临床出诊表 Add Constraint 临床出诊表_UQ_年份 Unique(年份, 月份, 周数, 出诊表名, 排班方式, 站点) Using Index Tablespace Zl9indexhis;

--94246:蒋廷中,2018-01-31,将开单人字段变长，可以储存实习医生与审核医生
alter table 门诊费用记录 modify 开单人 varchar2(41);
alter table 住院费用记录 modify 开单人 varchar2(41);

--109990:刘涛,2018-01-12,药品批号对照修改
alter table 药品批号对照 add 供应商ID Number(18);

Alter Table 药品批号对照 Add Constraint 药品批号对照_FK_供应商ID Foreign Key (供应商ID) References 供应商(ID);
Create Index 药品批号对照_IX_供应商ID on 药品批号对照(供应商ID) Tablespace zl9Indexhis;

--118296:董露露,2018-01-08,解决将35版本的首页修改到34版本的问题
 Create Table 医疗机构(
    编码 VARCHAR2(4),
    名称 VARCHAR2(50),
    简码 VARCHAR2(25),
    上级 Varchar2(4),
    末级 Number(1)
    )
    TABLESPACE zl9BaseItem;
Alter Table 医疗机构 Add Constraint 医疗机构_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;
Alter Table 医疗机构 Add Constraint 医疗机构_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;
Alter Table 医疗机构 Add Constraint 医疗机构_FK_上级 Foreign Key (上级) References 医疗机构 (编码) On Delete Cascade;
Create Index 医疗机构_IX_上级 on 医疗机构(上级) Tablespace zl9Indexhis;
Alter Table 出院转入 Add 上级 Varchar2(5);
Alter Table 出院转入 Add 末级 Number(1);
Alter Table 出院转入 Add Constraint 出院转入_FK_上级 Foreign Key (上级) References 出院转入 (编码) On Delete Cascade;
Create Index 出院转入_IX_上级 on 出院转入(上级) Tablespace zl9Indexhis;
CREATE TABLE 切口部位(
  编码 VARCHAR2(5),
  名称 VARCHAR2(100),
  简码 VARCHAR2(100),
  缺省标志 NUMBER(1) default 0
)TABLESPACE zl9BaseItem;
Alter Table 切口部位 Add Constraint 切口部位_PK Primary Key (编码) Using Index Tablespace zl9Indexhis;
Alter Table 切口部位 Add Constraint 切口部位_UQ_名称 Unique (名称) Using Index Tablespace zl9Indexhis;
Alter table 病人分娩信息 add 分娩时间 Date;

--118402:秦龙,2018-01-08,新增字段加成率
Alter Table 药品规格 Add(加成率 Number(16, 5));
Alter Table 材料特性 Add(加成率 Number(16, 5));

--116073:黄捷,2018-01-03,RIS接口支持多HIS库
create table RIS分院设置
(
  id     NUMBER(18),
  医院名称   VARCHAR2(100),
  医院代码   VARCHAR2(20),
  用户名    VARCHAR2(20),
  密码     VARCHAR2(20),
  数据库服务名 VARCHAR2(20)
)
tablespace ZL9CISREC;

alter table RIS分院设置 add constraint RIS分院设置_PK primary key (ID) using index tablespace ZL9INDEXHIS;
alter table RIS分院设置 add constraint RIS分院设置_UQ_医院代码 unique (医院代码) using index tablespace ZL9INDEXHIS;


-------------------------------------------------------------------------------
--数据修正部份
-------------------------------------------------------------------------------
--114815:蔡青松,2018-04-04,传染病报告指定打印科室
Insert Into zlComponent(部件,名称,主版本,次版本,附版本,系统,注册产品名称,注册产品简名,注册产品版本) Values('zl9LisInsideComm','新版LIS接口部件',10,34,0,&n_System,'中联检验信息系统','ZLLIS','10.9.0');

--120765:曾杰,2018-03-29,图像校对
Insert Into 快捷功能信息
  (Id, 项目, 模块号, 菜单分组, 分组序号, 菜单id, 菜单说明, 控制键, 字符键, 默认键, 组合名)
  Select 快捷功能信息_Id.Nextval, 'ZL9PACSWORK', 1290, '工具', 11, 8, '图像校对', 0, 84, '0+84', 'MENU+T' From Dual;

Insert Into 快捷功能信息
  (Id, 项目, 模块号, 菜单分组, 分组序号, 菜单id, 菜单说明, 控制键, 字符键, 默认键, 组合名)
  Select 快捷功能信息_Id.Nextval, 'ZL9PACSWORK', 1291, '工具', 11, 8, '图像校对', 0, 84, '0+84', 'MENU+T' From Dual;

Insert Into 快捷功能信息
  (Id, 项目, 模块号, 菜单分组, 分组序号, 菜单id, 菜单说明, 控制键, 字符键, 默认键, 组合名)
  Select 快捷功能信息_Id.Nextval, 'ZL9PACSWORK', 1294, '工具', 11, 8, '图像校对', 0, 84, '0+84', 'MENU+T' From Dual;

--117628:董露露,2018-03-22,诊断录入附码
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值,参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -Null, 0, 0, 0, 0, 296, '诊断自动提取附码', '0', '0','启用参数时：首页中诊断录入时附码自动提取，否则就手动填写。'
  From Dual;

--120765:曾杰,2018-03-21,图像校对
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值,参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1291, 0, 1, 0, 0, 58, '图像校对', '0', '0','打开影像工作站是否自动校对图像,0-不校对;1-校对'
  From Dual;
   
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值,参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1290, 0, 1, 0, 0, 55, '图像校对', '0', '0','打开影像工作站是否自动校对图像,0-不校对;1-校对'
  From Dual;
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值,参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1294, 0, 1, 0, 0, 112, '图像校对', '0', '0','打开影像工作站是否自动校对图像,0-不校对;1-校对'
  From Dual;

--121551:李业庆,2018-03-09,时价入库价格参数分模块调整
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1300, 0, 0, 1, 0, 17, '时价药品以加价率入库', '0', '0',
         '在外购入库中，对于时价药品，如果勾选该参数，则允许录入加成率，并按“售价=成本价*（1+加成率）”的公式计算售价；如果不勾选，则不能录入加成率，并直接取药品的原始售价（新建药品时录入的售价）或最近售价（如果调价）'
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1300, 0, 0, 1, 0, 18, '时价药品入库采用分段加成', '0', '0',
         '在外购入库时，对于时价药品的售价计算，如果勾选了该参数，那么就按已设置的药品分段加成方案计算售价'
  From Dual;
      
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1300, 0, 0, 1, 0, 19, '时价药品入库时取上次售价', '0', '0',
         '在外购入库时，对于时价药品的售价计算，如果勾选该参数则取该药品上次入库的售价；如果不勾选则按界面成本价*加成率的默认方式计算'
  From Dual;
  

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1302, 0, 0, 1, 0, 10, '时价药品以加价率入库', '0', '0',
         '在其他入库中，对于时价药品，如果勾选该参数，则允许录入加成率，并按“售价=成本价*（1+加成率）”的公式计算售价；如果不勾选，则不能录入加成率，并直接取药品的原始售价（新建药品时录入的售价）或最近售价（如果调价）'
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1302, 0, 0, 1, 0, 11, '时价药品入库采用分段加成', '0', '0',
         '在其他入库时，对于时价药品的售价计算，如果勾选了该参数，那么就按已设置的药品分段加成方案计算售价'
  From Dual;
      
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1302, 0, 0, 1, 0, 12, '时价药品入库时取上次售价', '0', '0',
         '在其他入库时，对于时价药品的售价计算，如果勾选该参数则取该药品上次入库的售价；如果不勾选则按界面成本价*加成率的默认方式计算'
  From Dual;


Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1712, 0, 0, 1, 0, 22, '时价卫材以加价率入库', '0', '0',
         '在外购入库中，对于时价卫材以加价率输入，并通过这个加价率计算出零售价'
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1712, 0, 0, 1, 0, 23, '卫材分段加成率', '0', '0',
         '对于时价卫材在入库时,按分段加成率计算.'
  From Dual;
      
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1712, 0, 0, 1, 0, 24, '时价卫材入库时取上次售价', '0', '0',
         '用来处理卫材在外购入库的时候，售价是按什么方式来的， 0-其他方式取（默认） 1-优先取上次外购入库的售价作为本次售价'
  From Dual;
  

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1714, 0, 0, 1, 0, 22, '时价卫材以加价率入库', '0', '0',
         '其他入库中，对于时价卫材以加价率输入，并通过这个加价率计算出零售价'
  From Dual;
  
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1714, 0, 0, 1, 0, 23, '卫材分段加成率', '0', '0',
         '对于时价卫材在入库时,按分段加成率计算.'
  From Dual;
      
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1714, 0, 0, 1, 0, 24, '时价卫材入库时取上次售价', '0', '0',
         '用来处理卫材在其他入库的时候，售价是按什么方式来的， 0-其他方式取（默认） 1-优先取上次外购入库的售价作为本次售价'
  From Dual;

--121551:李业庆,2018-03-09,时价入库价格参数分模块调整
Declare
  n_加价率入库   Number;
  n_分段加成入库 Number;
  n_取上次售价   Number;
Begin
  --取药品原系统参数值设置
  Select Zl_To_Number(Nvl(zl_GetSysParameter(54), '1')) Into n_加价率入库 From Dual;
  Select Zl_To_Number(Nvl(zl_GetSysParameter(181), '0')) Into n_分段加成入库 From Dual;
  Select Zl_To_Number(Nvl(zl_GetSysParameter(183), '0')) Into n_取上次售价 From Dual;
  
  If n_加价率入库 = 1 Then
    n_分段加成入库 := 0;
    n_取上次售价   := 0;
  Elsif n_取上次售价 = 1 Then
    n_加价率入库   := 0;
    n_分段加成入库 := 0;
  Elsif n_分段加成入库 = 1 Then
    n_加价率入库 := 0;
    n_取上次售价 := 0;
  End If;

  Update zlParameters Set 参数值 = n_加价率入库 Where 系统 = &n_System And 模块 = 1300 And 参数名 = '时价药品以加价率入库';
  Update zlParameters Set 参数值 = n_加价率入库 Where 系统 = &n_System And 模块 = 1302 And 参数名 = '时价药品以加价率入库';

  Update zlParameters Set 参数值 = n_取上次售价 Where 系统 = &n_System And 模块 = 1300 And 参数名 = '时价药品入库时取上次售价';
  Update zlParameters Set 参数值 = n_取上次售价 Where 系统 = &n_System And 模块 = 1302 And 参数名 = '时价药品入库时取上次售价';

  Update zlParameters Set 参数值 = n_分段加成入库 Where 系统 = &n_System And 模块 = 1300 And 参数名 = '时价药品入库采用分段加成';
  Update zlParameters Set 参数值 = n_分段加成入库 Where 系统 = &n_System And 模块 = 1302 And 参数名 = '时价药品入库采用分段加成';

  --取卫材原系统参数值设置
  Select Zl_To_Number(Nvl(zl_GetSysParameter(82), '1')) Into n_加价率入库 From Dual;
  Select Zl_To_Number(Nvl(zl_GetSysParameter(121), '0')) Into n_分段加成入库 From Dual;
  Select Zl_To_Number(Nvl(zl_GetSysParameter(229), '0')) Into n_取上次售价 From Dual;

  If n_加价率入库 = 1 Then
    n_分段加成入库 := 0;
    n_取上次售价   := 0;
  Elsif n_取上次售价 = 1 Then
    n_加价率入库   := 0;
    n_分段加成入库 := 0;
  Elsif n_分段加成入库 = 1 Then
    n_加价率入库 := 0;
    n_取上次售价 := 0;
  End If;

  Update zlParameters Set 参数值 = n_加价率入库 Where 系统 = &n_System And 模块 = 1712 And 参数名 = '时价卫材以加价率入库';
  Update zlParameters Set 参数值 = n_加价率入库 Where 系统 = &n_System And 模块 = 1714 And 参数名 = '时价卫材以加价率入库';

  Update zlParameters Set 参数值 = n_取上次售价 Where 系统 = &n_System And 模块 = 1712 And 参数名 = '时价卫材入库时取上次售价';
  Update zlParameters Set 参数值 = n_取上次售价 Where 系统 = &n_System And 模块 = 1714 And 参数名 = '时价卫材入库时取上次售价';

  Update zlParameters Set 参数值 = n_分段加成入库 Where 系统 = &n_System And 模块 = 1712 And 参数名 = '卫材分段加成率';
  Update zlParameters Set 参数值 = n_分段加成入库 Where 系统 = &n_System And 模块 = 1714 And 参数名 = '卫材分段加成率';

  --删除系统参数表中的参数
  Delete From zlParameters Where 系统 = &n_System And 模块 Is Null And 参数号 In (54, 181, 183, 82, 121, 229);
End;
/

--102705:焦博,2018-03-14,修正用户历史数据,将全部已经失效的计划的实际生效字段进行更新操作
Begin
  For c_安排 In (Select Distinct a.执行时间, b.安排id, Nvl(b.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 失效时间
                 From 挂号安排 A, 挂号安排计划 B
                 Where b.Id = a.执行计划id And Nvl(b.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) < Sysdate And
                       b.实际生效 >= To_Date('3000-01-01', 'yyyy-mm-dd')) Loop
      Update 挂号安排计划
      Set 实际生效 = Decode(Sign(Nvl(c_安排.执行时间, 生效时间) - Nvl(c_安排.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))), 1, 生效时间,
                         c_安排.执行时间)
      Where 安排id = c_安排.安排id And 失效时间 < Sysdate And
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) >= To_Date('3000-01-01', 'yyyy-mm-dd');
  End Loop;
  Commit;
End;
/

--114191:焦博,2018-03-13,增加公共模块参数退号回单打印方式,用来控制退号时是否打印回单
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1111, 0, 0, 0, 0, 73, '退号回单打印方式', Null, '0',
         '控制病人在退号后回单的打印:0-不打印,1-自动打印,2-选择是否打印'
  From Dual;

--120838:王煜,2018-03-12,控制费用查询时间条件
Insert Into Zlparameters
  (Id, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1806, 0, 0, 0, 0, 11, '费用统计时间点', Null, '0',
         '控制在费用统计时，使用哪种时间统计:0-登记时间;1-发生时间'
  From Dual;

--122724:刘鹏飞,2018-03-12,输血科直接发血提示医生站
insert into 业务消息类型(编码,名称,说明,保留天数) values ('ZLHIS_BLOOD_004','输血科直接发血提醒','输血科直接发血完成，提醒医生站进行医嘱审核',7);

--114815:蔡青松,2018-03-09,传染病报告指定打印科室
Insert into zlPrograms(序号,标题,说明,系统,部件) Values(1285,'检验传染病报告打印','查看和打印检验传染病报告',&n_System,'zl9LisInsideComm');

Insert Into zlMenus
  (组别, ID, 上级id, 标题, 短标题, 快键, 图标, 说明, 系统, 模块)
  Select '缺省', Zlmenus_Id.Nextval, ID, '检验传染病报告打印', '检验传染病', Null, 105, '查看和打印检验传染病报告', &n_System, 1285
  From zlMenus
  Where 系统 = &n_System And 组别 = '缺省' And 标题 = '传染病管理系统' And 模块 Is Null;

--108210:李南春,2018-03-09,自助挂号快捷签约模式
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1802, 0, 0, 0, 0, 45, '签约模式', '0', '0',
         '0-完整模式：需要由用户设置联系电话以及密码等操作，完善签约信息;' || chr(13) || '1-简略模式：不需要用户做任何设置，隐形完成签约过程，但账户风险会提高。'
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1803, 0, 0, 0, 0, 45, '签约模式', '0', '0',
         '0-完整模式：需要由用户设置联系电话以及密码等操作，完善签约信息;' || chr(13) || '1-简略模式：不需要用户做任何设置，隐形完成签约过程，但账户风险会提高。'
  From Dual;


--121419:刘鹏飞,2018-03-08,医生下达用血申请确定发放血液
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, -null, -null, -null, -null, -null, 293, '下达用血申请时确定发血信息', '', '',
         '启用血库系统且通过申请单下达输血用血申请时，决定是否要确定具体发放的血液信息才能下达申请，0-选择品种输入申请量即可,1-选择品种必须确定具体的血液信息，且不能修改申请量'
  From Dual;

--120836:冉俊明,2018-03-07,门诊收费禁止取消挂号划价单
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1121, 0, 0, 0, 0, 116, '禁止取消挂号划价单', Null, '0',
         '在收费时，根据该参数来判断是否允许取消挂号划价单继续收取其他费用：0-允许，1-禁止'
  From Dual;

--119720:李业庆,2018-03-07,按批号先进先出
Update zlParameters
Set 参数说明 = '药品出库优先算法：0-按批次先进先出，1-按效期最近先出，2-按批号最近先出'
Where 系统 = &n_System And 模块 Is Null And 参数号 = 150;

--119329:冉俊明,2018-03-05,三方接口获取可挂号科室过程调整
Declare
  --功能：修正临床出诊挂号控制
  Cursor c_限制 Is
    Select Rowid From 临床出诊挂号控制 Where 控制方式 = 3 And 序号 = 0 And 数量 = 0;

  c_Rowid      t_Strlist := t_Strlist();
  n_Array_Size Number := 10000; --每批一万,多了可能PGA不够
  I            Number(8) := 0; --每修正10万条记录提交一次,多了可能Undo不够,少了提交过于频繁
  J            Number(16) := 0;
Begin
  Open c_限制();
  Loop
    Fetch c_限制 Bulk Collect
      Into c_Rowid Limit n_Array_Size;
    Exit When c_Rowid.Count = 0;
  
    Forall K In 1 .. c_Rowid.Count
      Update 临床出诊挂号控制 Set 控制方式 = 4 Where Rowid = c_Rowid(K);
  
    J := J + c_Rowid.Count;
    If I = 10 Then
      Commit;
      I := 0;
    Else
      I := I + 1;
    End If;
  End Loop;
  Close c_限制;
  Commit;
End;
/

--119329:冉俊明,2018-03-05,三方接口获取可挂号科室过程调整
Declare
  --功能：修正临床出诊挂号控制记录
  Cursor c_记录 Is
    Select Rowid From 临床出诊挂号控制记录 Where 控制方式 = 3 And 序号 = 0 And 数量 = 0;

  c_Rowid      t_Strlist := t_Strlist();
  n_Array_Size Number := 10000; --每批一万,多了可能PGA不够
  I            Number(8) := 0; --每修正10万条记录提交一次,多了可能Undo不够,少了提交过于频繁
  J            Number(16) := 0;
Begin
  Open c_记录();
  Loop
    Fetch c_记录 Bulk Collect
      Into c_Rowid Limit n_Array_Size;
    Exit When c_Rowid.Count = 0;
  
    Forall K In 1 .. c_Rowid.Count
      Update 临床出诊挂号控制记录 Set 控制方式 = 4 Where Rowid = c_Rowid(K);
  
    J := J + c_Rowid.Count;
    If I = 10 Then
      Commit;
      I := 0;
    Else
      I := I + 1;
    End If;
  End Loop;
  Close c_记录;
  Commit;
End;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--合并跨月的两个周出诊表为一个出诊表（整个周的数据都放在前一个出诊表中，后一个出诊表用“相关ID”进行关联）
Declare
  n_Id       临床出诊表.Id%Type;
  n_年份     临床出诊表.年份%Type;
  n_月份     临床出诊表.月份%Type;
  n_周数     临床出诊表.周数%Type;
  d_首日     Date;
  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;
Begin
  --1.查找到需要合并的每月第一个出诊表
  For c_出诊表 In (Select a.Id, a.年份, a.月份, a.周数, a.发布人, a.发布时间, Nvl(a.站点, '-') As 站点
                From 临床出诊表 A
                Where a.排班方式 = 2 And a.周数 = 1 And Exists
                 (Select 1 From 临床出诊安排 Where 出诊id = a.Id And 终止时间 - 开始时间 < 6)
                Order By 站点, 年份, 月份, 周数) Loop
    --2.确定需要合并的另一个出诊表的年月周，及完整周的日期范围
    If c_出诊表.月份 = 1 Then
      n_年份 := c_出诊表.年份 - 1;
      n_月份 := 12;
    Else
      n_年份 := c_出诊表.年份;
      n_月份 := c_出诊表.月份 - 1;
    End If;
    ----根据本月有多少个周一计算总周数
    d_首日 := To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd');
    Select Count(1) + Decode(To_Char(d_首日, 'D'), 2, 0, 1)
    Into n_周数
    From (Select d_首日 + Level - 1 As 日期 From Dual Connect By Level <= Add_Months(d_首日, 1) - d_首日)
    Where To_Char(日期, 'D') = 2;
    ----计算合并后的日期范围
    Select Next_Day(Last_Day(d_首日) - 7, 2), Next_Day(Add_Months(d_首日, 1) - 1, 1)
    Into d_开始时间, d_终止时间
    From Dual;
    --3.查找需要合并的另一个出诊表ID
    Begin
      Select a.Id
      Into n_Id
      From 临床出诊表 A
      Where a.排班方式 = 2 And Nvl(a.站点, '-') = c_出诊表.站点 And a.年份 = n_年份 And a.月份 = n_月份 And a.周数 = n_周数;
    Exception
      When Others Then
        --没有的，新增一张出诊表，保证跨月的周出诊表都有两个
        Select 临床出诊表_Id.Nextval Into n_Id From Dual;
        Insert Into 临床出诊表
          (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点, 发布人, 发布时间)
        Values
          (n_Id, 2, n_年份 || '年' || n_月份 || '月第' || n_周数 || '周出诊表', n_年份, n_月份, n_周数, c_出诊表.站点, c_出诊表.发布人, c_出诊表.发布时间);
    End;
    --4.合并出诊表
    Update 临床出诊表 Set 关联ID = n_Id Where ID = c_出诊表.Id;
    Update 临床出诊安排
    Set 出诊id = n_Id, 开始时间 = d_开始时间, 终止时间 = d_终止时间
    Where 出诊id In (n_Id, c_出诊表.Id);
  End Loop;
End;
/

--119907:殷瑞,2018-03-02,药品部门发药新增模块参数
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1342, 0, 0, 0, 0, 32, '有销帐申请时不能进行退药操作', '0', '0', '0-允许退药操作；1-不能退药操作，只能进行销帐审核'
  From Dual;

--118685:曾杰,2017-02-28,缩略图大图显示参数调整
Insert Into 影像流程参数
  (Id, 科室id, 参数名, 参数值)
  Select 影像流程参数_Id.Nextval, 科室id, '缩略图预览方式', 参数值
  From 影像流程参数
  Where 参数名 = '报告中显示大图';

Delete From 影像流程参数 Where 参数名 = '报告中显示大图';
Delete From 影像流程参数 Where 参数名 = '报告大图放大倍数';

Delete From Zlparameters Where 参数名 = '鼠标移动时显示大图' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);
Delete From Zlparameters Where 参数名 = '采集大图放大倍数' And 系统 = &n_System And (模块 = 1291 or 模块 = 1294);
Delete From Zlparameters Where 参数名 = '大图显示范围限制' And 系统 = &n_System And 模块 = 1291 ;
Delete From Zlparameters Where 参数名 = '大图显示最大分辨率' And 系统 = &n_System And 模块 = 1291;

--114183:陈刘,2018-02-11,取消骑线显示的发热值
Delete From zlParameters Where 系统 = &n_System And 模块 = 1255 And 参数名 = '发热值' And 参数号 = 92;
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 0, 0, 0, 0, 10, '未区分站点的号源的维护站点', Null, Null,
         '未区分院区的科室的号源由哪个院区来维护出诊安排。'
  From Dual;

--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
--根据站点拆分临床出诊表 ,每个站点的号源及安排各自独立维护
Declare
  n_出诊id 临床出诊表.Id%Type;

  n_无站点   Number;
  n_有站点   Number;
  v_最小站点 部门表.站点%Type;
Begin
  --1.升级已有出诊表的站点为该出诊表中的号源站点编号最小的站点
  For r_出诊表 In (Select m.Id, Min(d.站点) As 站点
                From 临床出诊表 M, 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = m.Id And m.站点 Is Null
                Group By m.Id) Loop
    Update 临床出诊表 Set 站点 = r_出诊表.站点 Where ID = r_出诊表.Id;
  End Loop;

  --2.拆分出诊表
  For r_出诊表 In (Select ID, 排班方式, 出诊表名, 年份, 月份, 周数, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, Nvl(站点, '-') As 站点
                From 临床出诊表) Loop
    --2.1将不分站点的号源保留在已有出诊表中进行维护
    For r_安排 In (Select a.Id, d.站点
                 From 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                 Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = r_出诊表.Id And d.站点 Is Not Null) Loop
      /*--2.1将不分站点的号源放在编号为2的站点进行维护
      For r_安排 In (Select a.Id, Nvl(d.站点, '2') As 站点
                   From 临床出诊安排 A, 临床出诊号源 B, 部门表 D
                   Where a.号源id = b.Id And b.科室id = d.Id And a.出诊id = r_出诊表.Id) Loop*/
      If r_安排.站点 <> r_出诊表.站点 Then
        Begin
          Select ID
          Into n_出诊id
          From 临床出诊表
          Where 排班方式 = r_出诊表.排班方式 And 出诊表名 = r_出诊表.出诊表名 And Nvl(年份, 0) = Nvl(r_出诊表.年份, 0) And
                Nvl(月份, 0) = Nvl(r_出诊表.月份, 0) And Nvl(周数, 0) = Nvl(r_出诊表.周数, 0) And 站点 = r_安排.站点;
        Exception
          When Others Then
            n_出诊id := Null;
        End;
      
        If Nvl(n_出诊id, 0) = 0 Then
          Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
          Insert Into 临床出诊表
            (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
          Values
            (n_出诊id, r_出诊表.排班方式, r_出诊表.出诊表名, r_出诊表.年份, r_出诊表.月份, r_出诊表.周数, r_出诊表.应用范围, r_出诊表.科室id, r_出诊表.备注, r_出诊表.发布人,
             r_出诊表.发布时间, r_出诊表.模板类型, r_安排.站点);
        End If;
      
        Update 临床出诊安排 Set 出诊id = n_出诊id Where ID = r_安排.Id;
      End If;
    End Loop;
  End Loop;

  --如果出诊表既有分站点的，又有不分站点的，则将不分站点的修正为最小站点
  Select Sum(Decode(站点, Null, 1, 0)), Sum(Decode(站点, Null, 0, 1)), Min(站点)
  Into n_无站点, n_有站点, v_最小站点
  From 临床出诊表;
  If Nvl(n_有站点, 0) > 0 And Nvl(n_无站点, 0) > 0 Then
    Update 临床出诊表 Set 站点 = v_最小站点 Where 站点 Is Null;
  End If;
End;
/

--121591:冉俊明,2018-02-06,临床出诊号源的号码排序方式调整
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1114, 0, 0, 0, 0, 11, '号码排序比较方式', Null, '1',
         '号源号码按哪种比较方式进行排序：0-按字符比较，1-按数值比较'
  From Dual;

--118197,118296:董露露,2018-01-16
Insert into zlTables(系统,表名,表空间,分类) Values(100,'医疗机构','ZL9BASEITEM','A2');
Insert into zlTables(系统,表名,表空间,分类) Values(100,'切口部位','ZL9BASEITEM','A2');

--119822:殷瑞,2018-01-16,删除系统无效参数
Delete from Zlparameters Where 系统 = &n_System And  模块 = 1345 and 参数名 = '启用条码扫描设备';

--109990:刘涛,2018-01-12,药品批号对照修改
Declare
Begin
  For c_药品批号对照 In (Select a.药品id, a.批次, a.供药单位id 供应商id
                   From (Select a.药品id, a.批次, a.供药单位id, Row_Number() Over(Partition By 药品id, 批次 Order By 审核日期 Desc) Top
                          From 药品收发记录 A
                          Where 单据 = 1 And Mod(记录状态, 3) <> 2 And 审核日期 Is Not Null And Exists
                           (Select 1 From 药品批号对照 B Where a.药品id = b.药品id And a.批次 = b.批次)) A
                   Where a.Top = 1) Loop
    --期间数据
    Update 药品批号对照
    Set 供应商id = c_药品批号对照.供应商id
    Where 药品id = c_药品批号对照.药品id And 批次 = c_药品批号对照.批次;
  
  End Loop;
  Commit;
End;
/


--118402:秦龙,2018-01-10,修正加成率数据
Update 药品规格 A Set a.加成率 =(1/(1-a.指导差价率/100)-1)*100 Where a.加成率 Is Null;

Update 材料特性 A Set a.加成率 =(1/(1-a.指导差价率/100)-1)*100 Where a.加成率 Is Null;

--119475:刘鹏飞,2017-01-09,输血申请单预览打印调用
Insert Into Zlprocedure(Id, 类型, 名称, 状态, 所有者, 说明) Values(Zlprocedure_Id.Nextval,2,'Zl1_Fun_BloodApplyPrint',3,User,'申请单预览打印时对医嘱的相关内容进行检查，并返回提示及处理结果。');

--118296:董露露,2018-01-08,解决将35版本的首页修改到34版本的问题
Insert Into zlBaseCode (系统,表名,固定,说明,分类) Values (&n_System,'医疗机构',0,'提供病人入院登记时可选的转入机构','医疗工作');
Insert Into zlBaseCode(系统,表名,固定,说明,分类) Values(&n_System,'切口部位',0,'病人发生手术时的手术切口部位','医疗工作' );

--91654:秦龙,2018-01-04,药品计划管理列设置
Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 1, 11, '选择列', '', '',
         '用户自定义编辑界面的列的显示,为空表示按默认列顺序并且所有列都显示;有内容表示按用户所选列及顺序显示。格式为:C1|C2|…'
  From Dual;

Insert Into zlParameters
  (ID, 系统, 模块, 私有, 本机, 授权, 固定, 参数号, 参数名, 参数值, 缺省值, 参数说明)
  Select Zlparameters_Id.Nextval, &n_System, 1330, 1, 0, 0, 1, 12, '屏蔽列', '', '',
         '用户自定义编辑界面的列的隐藏,为空表示没有屏蔽列;有内容表示这些列不在单据界面显示。格式为:C1|C2|…'
  From Dual;


--116073:黄捷,2018-01-03,RIS接口支持多HIS库
Insert into zlTables(系统,表名,表空间,分类) Values(100,'RIS分院设置','ZL9BASEITEM','A2');

--87412:余伟节,2018-04-02,校对医嘱电子签名
Update zlParameters
Set 参数名 = '校对医嘱电子签名'
Where 系统 = &n_System And 模块 = 1254 And 参数名 = '校对医嘱使用电子签名';


-------------------------------------------------------------------------------
--权限修正部份
-------------------------------------------------------------------------------
--107905:冉俊明,2018-04-02,根据权限允许重新结算他人的异常结算单据
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1121, '重收他人异常单据', 35, '允许针对其他人产生的收费异常单据进行重新收费。', 0
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1121 And 功能 = '重收他人异常单据');

Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1124, '重结他人异常单据', 9, '允许针对其他人产生的结算异常单据进行重新结算。', 0
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1124 And 功能 = '重结他人异常单据');

--118295:董露露,2018-03-26,首页手术等级修改权限
Insert Into zlProgFuncs
  (系统, 序号, 功能, 排列, 说明, 缺省值)
  Select &n_System, 1261, '修改手术等级', 18, '有该权限时，可以在住院首页修改已绑定手术等级的手术记录的手术等级',1
  From Dual
  Where Not Exists (Select 1 From zlProgFuncs Where 系统 = &n_System And 序号 = 1261 And 功能 = '修改手术等级');

--120765:曾杰,2018-03-21,图像校对
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查图象_校对','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查图象_校对','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查图象_校对','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--118124:李南春,2018-03-14,根据病人信息获取卡费
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1111, '基本', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1111 And 功能 = '基本' And 对象 = 'Zl1_Ex_CardFee');  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '发卡事务', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1101 And 功能 = '发卡事务' And 对象 = 'Zl1_Ex_CardFee');  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1101, '绑定卡号', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1101 And 功能 = '绑定卡号' And 对象 = 'Zl1_Ex_CardFee');  

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1131, '基本', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1131 And 功能 = '基本' And 对象 = 'Zl1_Ex_CardFee'); 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '发卡', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1107 And 功能 = '基本' And 对象 = 'Zl1_Ex_CardFee'); 

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1107, '绑定卡', User, 'Zl1_Ex_CardFee', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1 From zlProgPrivs Where 系统 = &n_System And 序号 = 1107 And 功能 = '绑定卡' And 对象 = 'Zl1_Ex_CardFee'); 

--122597:秦龙,2018-03-09,增加过程用于清空药品规格里的某些字段
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1023, '基本', User, 'Zl_药品规格_字段清空', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1023 And 功能 = '基本' And Upper(对象) = Upper('Zl_药品规格_字段清空'));

--114815:蔡青松,2018-03-09,传染病报告指定打印科室
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select &n_System,1285,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All 
  Select '基本',1,'基本权限。',1 From Dual Union All
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--108210:李南春,2018-03-09,自助挂号快捷签约模式
Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1802, '基本', User, 'Zl_病人信息_联系电话_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1802 And 功能 = '基本' And Upper(对象) = Upper('Zl_病人信息_联系电话_Update'));

Insert Into zlProgPrivs
  (系统, 序号, 功能, 所有者, 对象, 权限)
  Select &n_System, 1803, '基本', User, 'Zl_病人信息_联系电话_Update', 'EXECUTE'
  From Dual
  Where Not Exists (Select 1
         From zlProgPrivs
         Where 系统 = &n_System And 序号 = 1803 And 功能 = '基本' And Upper(对象) = Upper('Zl_病人信息_联系电话_Update'));

--110000:曾杰,2018-01-18,变更影像检查记录待处理人
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1290,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1291,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1294,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select 'Zl_影像检查记录_变更待处理人','EXECUTE' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--103954:曾杰,2018-01-15,影像工作站增加插件配置的权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1290,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',40,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1291,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',37,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1294,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '插件配置管理',60,'配置第三方插件',0 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--119825:胡俊勇,2018-01-10,护士站权限修正
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select  &n_System,1254,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
	Select '处方审查记录','SELECT' From Dual Union All
	Select '处方审查明细','SELECT' From Dual Union All
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

--119290:廖思奇,2018-01-09,Pacs排队叫号增加预呼功能。增加预呼权限
Insert Into zlProgFuncs(系统,序号,功能,排列,说明,缺省值)
Select  &n_System,1160,A.* From (
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0 Union All
Select '预呼',20,'对排队中的患者进行预先呼叫，提示患者即将正式呼叫',1 From Dual Union All 
Select 功能,排列,说明,缺省值 From zlProgFuncs Where 1 = 0) A;

--119475:刘鹏飞,2017-01-09,输血申请单预览打印调用
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1252,User,'基本','Zl1_Fun_BloodApplyPrint','EXECUTE');
Insert Into zlProgPrivs(系统,序号,所有者,功能,对象,权限) values(&n_System,1253,User,'基本','Zl1_Fun_BloodApplyPrint','EXECUTE');

--118296:董露露,2018-01-08,解决将35版本的首页修改到34版本的问题
Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1132,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '医疗机构','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
Select &n_System,1131,'基本',User,A.* From (
Select 对象,权限 From zlProgPrivs Where 1 = 0 Union All 
    Select '医疗机构','SELECT' From Dual Union All 
Select 对象,权限 From zlProgPrivs Where 1 = 0) A;

Insert Into zlProgPrivs(系统, 序号, 功能, 所有者, 对象, 权限)
Select &n_System, 1261, '基本', User, A.* From (
Select 对象, 权限 From zlProgPrivs Where 1 = 0 Union All
    Select '切口部位', 'SELECT' From Dual Union All
Select 对象, 权限 From zlProgPrivs Where 1 = 0)A;

--116073:黄捷,2018-01-03,RIS接口支持多HIS库
Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1011, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1287, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1252, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1253, User, '基本', 'RIS分院设置', 'SELECT');

Insert Into zlProgPrivs
  (系统, 序号, 所有者, 功能, 对象, 权限)
Values
  (&n_System, 1254, User, '基本', 'RIS分院设置', 'SELECT');

--107905:冉俊明,2018-04-02,根据权限允许重新结算他人的异常结算单据
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1121, 2, '重收他人异常单据', 2, 0, 0
  From Dual
  Where Not Exists
   (Select 1 From Zlprogrelas Where 系统 = &n_System And 序号 = 1121 And 组号 = 2 And 功能 = '重收他人异常单据');
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1124, 2, '医保结算', 2, 1, 0
  From Dual
  Where Not Exists (Select 1 From Zlprogrelas Where 系统 = &n_System And 序号 = 1124 And 组号 = 2 And 功能 = '医保结算');
Insert Into Zlprogrelas
  (系统, 序号, 组号, 功能, 关系, 主项, 主项关系)
  Select &n_System, 1124, 2, '重结他人异常单据', 2, 0, 0
  From Dual
  Where Not Exists
   (Select 1 From Zlprogrelas Where 系统 = &n_System And 序号 = 1124 And 组号 = 2 And 功能 = '重结他人异常单据');




-------------------------------------------------------------------------------
--报表修正部份
-------------------------------------------------------------------------------
--114191:焦博,2018-03-19,增加固定的系统报表ZL1_BILL_1111_3用于打印退号回单
--报表：ZL1_BILL_1111_3/退号回单
Insert Into zlReports(ID,编号,名称,说明,密码,进纸,打印机,票据,系统,程序ID,功能,修改时间,发布时间,打印方式,禁止开始时间,禁止结束时间) Values(zlReports_ID.NextVal,'ZL1_BILL_1111_3','退号回单',Null,'Zl0hF`4~h)%]{2fcI ^J',15,'Microsoft XPS Document Writer',1,100,Null,Null,Sysdate,Sysdate,0,To_Date('2018-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'),To_Date('2018-03-01 00:00:00','YYYY-MM-DD HH24:MI:SS'));
Insert Into zlRPTPuts(报表ID,系统,程序ID,功能) Values(zlReports_ID.CurrVal,100,1111,'退号回单');
Insert Into zlRPTFmts(报表ID,序号,说明,图样,W,H,纸张,纸向,动态纸张) Values(zlReports_ID.CurrVal,1,'退号回单',0,6237,7937,256,1,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'P','NO,202|姓名,202|性别,202|年龄,202|挂号时间,202|科室,202|医生,202|操作员,202|号序,139|项目,202',User||'.门诊费用记录,'||User||'.病人挂号记录,'||User||'.收费项目目录,'||User||'.部门表',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select Max(a.No) As NO, Max(a.姓名) As 姓名, Max(a.性别) As 性别, Max(a.年龄) As 年龄, To_Char(Max(b.发生时间), ''yyyy-mm-dd HH:MM'') As 挂号时间, Max(d.名称) As 科室,' From Dual Union All
  Select 2,'       Max(a.执行人) As 医生, Max(a.操作员姓名) As 操作员, Max(b.号序) As 号序, Max(Decode(a.序号, 1, c.名称, Null)) As 项目' From Dual Union All
  Select 3,'From 门诊费用记录 A, 病人挂号记录 B, 收费项目目录 C, 部门表 D' From Dual Union All
  Select 4,'Where a.记录性质 = 4 And a.记录状态 = 2 And a.No = b.No And b.记录状态 = 2 And b.执行部门id = d.Id And a.收费细目id = c.Id And' From Dual Union All
  Select 5,'      a.No = [0]' From Dual Union All
  Select 6,'Group By a.No, a.姓名, a.性别, a.年龄, b.发生时间, d.名称, a.执行人, a.操作员姓名, b.号序' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'挂号信息','挂号费,202',User||'.门诊费用记录',0,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select LTrim(To_Char(Sum(数次 * 实收金额), ''99999999990.00'')) As 挂号费' From Dual Union All
  Select 2,'From 门诊费用记录' From Dual Union All
  Select 3,'Where 记录性质 = 4 And 记录状态 = 3 And NO = [0]' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTDatas(ID,报表ID,名称,字段,对象,类型,说明) Values(zlRPTDatas_ID.NextVal,zlReports_ID.CurrVal,'退款信息','退款方式,202|退款金额,139',User||'.门诊费用记录,'||User||'.病人预交记录',1,Null);
Insert Into zlRPTSQLs(源ID,行号,内容)  Select zlRPTDatas_ID.CurrVal,a.* From (
  Select 1,'Select 结算方式 as 退款方式, Sum(冲预交 * -1) As 退款金额' From Dual Union All
  Select 2,'From 病人预交记录' From Dual Union All
  Select 3,'Where 结帐id = (Select Distinct 结帐id From 门诊费用记录 Where 记录性质 = 4 And 记录状态 = 2 And NO = [0]) ' From Dual Union All
  Select 4,'group by 结算方式' From Dual Union All
  Select 5,'Order By 结算方式' From Dual) a;
Insert Into zlRPTPars(源ID,组名,序号,名称,类型,缺省值,格式,值列表,分类SQL,明细SQL,分类字段,明细字段,对象,锁定) Values(zlRPTDatas_ID.CurrVal,Null,0,'NO',0,Null,0,Null,Null,Null,Null,Null,Null,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'退号回单',14,Null,0,Null,0,Null,Null,135,255,5880,7335,0,0,0,'宋体',9,0,0,0,0,16777215,1,Null,Null,Null,1,0,0,Null,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条2',1,Null,0,Null,0,Null,Null,375,2400,4995,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-1,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条3',1,Null,0,Null,0,Null,Null,405,6450,5070,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-2,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'线条1',1,Null,0,Null,0,Null,Null,4124,1200,1140,0,0,0,1,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-3,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'挂号日期',2,Null,0,Null,0,'日期:[P.挂号时间]',Null,375,2715,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-4,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'科室',2,Null,0,Null,0,'科室:[P.科室]',Null,375,3210,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-5,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'医生',2,Null,0,Null,0,'医生:[P.医生]',Null,375,3645,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-6,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'项目',2,Null,0,Null,0,'项目:[P.项目]',Null,375,4155,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-7,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'退款情况',2,Null,0,Null,0,'退款情况:',Null,395,4620,810,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-8,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'姓名',2,Null,0,Null,0,'姓名:[P.姓名]',Null,450,1980,1740,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-9,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'操作员',2,Null,0,Null,0,'操作员:[P.操作员]',Null,450,6750,2520,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-10,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'标题',2,Null,0,Null,0,'退号回单',Null,2265,330,1410,330,0,0,1,'宋体',16,1,0,0,0,16777215,0,Null,Null,Null,1,0,1,zlRPTItems_ID.CurrVal-11,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'性别',2,Null,0,Null,0,'性别:[P.性别]',Null,2280,1965,1905,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-12,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'操作时间',2,Null,0,Null,0,'操作时间:[yyyy-mm-dd HH:MM]',Null,2835,6750,2430,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-13,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'号序',2,Null,0,Null,0,'号序:[P.号序]',Null,3030,3645,1845,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-14,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'挂号费',2,Null,0,Null,0,'挂号费:[挂号信息.挂号费]',Null,3030,4155,2160,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-15,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'年龄',2,Null,0,Null,0,'年龄:[P.年龄]',Null,3975,1965,1800,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-16,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'NO',2,Null,0,Null,0,'NO:[P.NO]',Null,4110,945,1530,180,0,0,1,'宋体',9,0,0,0,0,16777215,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-17,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,'退款信息',4,Null,0,Null,0,Null,Null,380,5010,5238,1455,345,0,1,'宋体',9,0,0,0,0,16777215,1,Null,'16777215',Null,1,16777215,0,zlRPTItems_ID.CurrVal-18,Null,0,0,0,0,0);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-1,0,Null,Null,'[退款信息.退款方式]','4^345^退款方式^0^0',0,0,2520,0,0,1,0,'宋体',0,0,0,0,0,0,0,Null,Null,Null,1,0,0,zlRPTItems_ID.CurrVal-19,Null,Null,Null,Null,Null,Null);
Insert Into zlRPTItems(ID,报表ID,格式号,名称,类型,上级ID,序号,参照,性质,内容,表头,X,Y,W,H,行高,对齐,自调,字体,字号,粗体,斜体,下线,前景,背景,边框,排序,格式,汇总,分栏,网格,系统,父ID,源ID,上下间距,左右间距,纵向分栏,横向分栏,源行号) Values(zlRPTItems_ID.NextVal,zlReports_ID.CurrVal,1,Null,6,zlRPTItems_ID.CurrVal-2,1,Null,Null,'[退款信息.退款金额]','4^345^退款金额^0^0',0,0,2415,0,0,1,0,Null,0,0,0,0,0,0,0,Null,'0.00',Null,1,0,0,zlRPTItems_ID.CurrVal-20,Null,Null,Null,Null,Null,Null);

--报表：ZL1_BILL_1111_3/退号回单
Insert into zlProgFuncs(系统,序号,功能,说明) Values(100,1111,'退号回单',Null);
Insert into zlProgPrivs(系统,序号,功能,所有者,对象,权限)
  Select 100,1111,'退号回单',User,'病人挂号记录','SELECT' From Dual Union All
  Select 100,1111,'退号回单',User,'病人预交记录','SELECT' From Dual Union All
  Select 100,1111,'退号回单',User,'部门表','SELECT' From Dual Union All
  Select 100,1111,'退号回单',User,'门诊费用记录','SELECT' From Dual Union All
  Select 100,1111,'退号回单',User,'收费项目目录','SELECT' From Dual;

-------------------------------------------------------------------------------
--过程修正部份
-------------------------------------------------------------------------------
--92225:余伟节,2018-04-03,删除补录路径外医嘱
CREATE OR REPLACE Procedure Zl_病人医嘱记录_Delete
(
  --功能：删除指定医嘱,适用于门诊和住院。
  --参数：
  --      医嘱ID_IN：当前要删除的医嘱的ID(是可见行的单条医嘱ID，不是组ID)
  --      删相关_IN=0时,只删除指定ID的医嘱(医嘱编辑程序调用)。
  --          1.相关医嘱的同步删除及删除之后的序号调整由程序处理后调用对应过程。
  --          2.被删除的医嘱应该未校对,程序应已控制。
  --          3.病人医嘱状态的内容会自动删除；病人医嘱计价，病人医嘱发送未校对的没有记录。
  --      删相关_IN=1时,删除整条医嘱(管理界面调用)，如给药途径，检查组合，手术附项，中药配方。
  --          1.需要在过程中同时调整相关记录的序号。
  --          2.一并给药的只删除当前药品记录(不包括给药途径)。
  医嘱id_In 病人医嘱记录.Id%Type,
  删相关_In Number := 0
) Is
  v_状态            病人医嘱记录.医嘱状态%Type;
  v_相关id          病人医嘱记录.相关id%Type;
  v_病人id          病人医嘱记录.病人id%Type;
  v_挂号单          病人医嘱记录.挂号单%Type;
  v_主页id          病人医嘱记录.主页id%Type;
  v_婴儿            病人医嘱记录.婴儿%Type;
  v_序号            病人医嘱记录.序号%Type;
  v_内容            病人医嘱记录.医嘱内容%Type;
  v_路径执行id      病人路径执行.Id%Type;
  v_Other路径执行id 病人路径执行.Id%Type;
  v_路径执行方式    临床路径项目.执行方式%Type;
  v_内容要求        临床路径项目.内容要求%Type;
  n_Count           Number(5);
  v_路径记录id      病人临床路径.Id%Type;
  v_变异原因        病人路径执行.变异原因%Type;
  n_是否评估        Number(5);
  n_路径项目id      病人路径执行.项目id%Type;
  n_Islast          Number(5);
  n_Del_Count       Number(5);
  n_Del类型         Number(2); --0-只删除指定ID的医嘱，1-删除整条医嘱
  n_紧急标志        Number(2); --2-补录医嘱
  v_处方审查锁定ids Varchar2(4000);
  v_诊疗类别        病人医嘱记录.诊疗类别%Type;
  v_审核状态        病人医嘱记录.审核状态%Type;
  v_诊疗项目id      病人医嘱记录.诊疗项目id%Type;
  v_启用血库        Zlparameters.参数值%Type;
  v_执行分类        诊疗项目目录.执行分类%Type;
  n_路径记录id      病人临床路径.Id%Type;
  n_阶段id          临床路径阶段.Id%Type;
  d_日期            Date;
  n_时间进度        Number(5);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --检查医嘱状态:并发操作
  Begin
    Select 病人id, 挂号单, 主页id, 婴儿, 医嘱状态, 相关id, 医嘱内容, 诊疗类别, 审核状态, 诊疗项目id, 紧急标志
    Into v_病人id, v_挂号单, v_主页id, v_婴儿, v_状态, v_相关id, v_内容, v_诊疗类别, v_审核状态, v_诊疗项目id, n_紧急标志
    From 病人医嘱记录
    Where ID = 医嘱id_In;
  Exception
    When Others Then
      Begin
        v_Error := '未发现要删除的医嘱记录，可能已被其他人删除。';
        Raise Err_Custom;
      End;
  End;
  If v_挂号单 Is Null Then
    If Not v_状态 In (1, 2, -1) Then
      v_Error := '医嘱"' || v_内容 || '"已经过校对，不能再删除。';
      Raise Err_Custom;
    End If;
  Else
    If v_状态 <> 1 Then
      v_Error := '医嘱"' || v_内容 || '"已经被发送或作废，不能删除。';
      Raise Err_Custom;
    End If;
  End If;

  --输血医嘱并发处理
  If v_诊疗类别 = 'K' And v_审核状态 In (2, 5) Then
    --是否安装了血库系统
    Select Count(1) Into n_Count From zlSystems Where 编号 = 2200;
    If Nvl(n_Count, 0) > 0 Then
      Select 执行分类 Into v_执行分类 From 诊疗项目目录 Where ID = v_诊疗项目id;
      If Not (Nvl(v_执行分类, 0) = 1) Then
        --是否启用了血库管理系统
        Select zl_GetSysParameter(236) Into v_启用血库 From Dual;
        If Nvl(v_启用血库, '0') <> '0' Then
          If v_审核状态 = 5 Then
            v_Error := '正在配血，';
          Else
            v_Error := '并且已完成配血，';
          End If;
          v_Error := '医嘱"' || v_内容 || '"已被血库接收，' || v_Error || '不能删除，若需删除请与输血科联系。';
          Raise Err_Custom;
        End If;
      End If;
    End If;
  End If;

  Select Count(*)
  Into n_Count
  From 病人医嘱状态
  Where 医嘱id = 医嘱id_In And 操作类型 In (1, 11) And 签名id Is Not Null;
  If Nvl(n_Count, 0) > 0 Then
    v_Error := '医嘱"' || v_内容 || '"已经电子签名,不能删除。';
    Raise Err_Custom;
  End If;

  --处方审查撤销
  If v_相关id Is Null Then
    Zl_处方审查_Cancel(医嘱id_In, v_处方审查锁定ids);
  Else
    Zl_处方审查_Cancel(v_相关id, v_处方审查锁定ids);
  End If;

  If v_处方审查锁定ids Is Not Null Then
    v_Error := '医嘱"' || v_内容 || '"已锁定，正在进行处方审查，不能再删除。';
    Raise Err_Custom;
  End If;

  --判断删整组还是指定ID的医嘱
  If Nvl(删相关_In, 0) = 0 Then
    n_Del类型 := 0;
  Else
    If v_相关id Is Null Then
      --检查组合,手术及附加,中药配方,检验组合,以及独立医嘱
      Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
      n_Del类型 := 1;
    Else
      --成药一并给药的情况(无申请)
      --先判断是否一并给药
      Select Count(*) Into n_Del_Count From 病人医嘱记录 Where 相关id = v_相关id;
      If n_Del_Count = 1 Then
        --单独给药:同时删除其给药途径
        Select Max(序号), Count(*) Into v_序号, n_Del_Count From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
        n_Del类型 := 1;
      Else
        --一并给药:只删除当前药品
        n_Del_Count := 1;
        Select 序号 Into v_序号 From 病人医嘱记录 Where ID = 医嘱id_In;
        n_Del类型 := 0;
      End If;
    End If;
  End If;
  --
  Begin
    --如果不是路径的医嘱，则不查询路径执行表
    Select Count(1) Into n_Count From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In;
  
    If n_Count > 0 Then
      --外连接是因为路径外项目的项目id是空
      --游标循环处理：存在同一天，同一条医嘱对应多个路径项目的情况。
      --必须生成的项目需要填写变异原因，不删项目，只删医嘱；非必须生成的项目，直接删除医嘱和对应项目
      For Rs In (Select a.Id, d.执行方式, d.内容要求, a.路径记录id, a.变异原因, a.项目id
                 From 病人路径执行 A, 病人路径医嘱 B, 临床路径项目 D
                 Where b.病人医嘱id = 医嘱id_In And b.路径执行id = a.Id And a.项目id = d.Id(+)) Loop
        v_路径执行id   := Rs.Id;
        v_路径执行方式 := Rs.执行方式;
        v_内容要求     := Rs.内容要求;
        v_路径记录id   := Rs.路径记录id;
        v_变异原因     := Rs.变异原因;
        n_路径项目id   := Rs.项目id;
        --92225未生效的补录医嘱删除时不做路径检查
        If n_紧急标志 <> 2 Then
          Select Count(1)
          Into n_是否评估
          From 病人路径执行 A, 病人路径评估 B
          Where a.路径记录id = b.路径记录id And a.阶段id = b.阶段id And a.天数 = b.天数 And a.Id = v_路径执行id;
        
          If n_是否评估 > 0 Then
            v_Error := '该医嘱对应的临床路径项目已经评估，请取消评估再删除。';
            Raise Err_Custom;
          End If;
        
          --生成时填了变异原因的必须适用的项目允许删除
          If Not v_路径执行方式 Is Null And v_变异原因 Is Null Then
            If v_路径执行方式 <> 3 Then
              --如果必须生成的项目，选择生成的医嘱还剩最后一个，则不允许删除
              If v_内容要求 = 1 Then
                --路径内外的医嘱进行一并给药时，可以删除原有的给药途径
                If Nvl(删相关_In, 0) = 0 And v_相关id Is Null Then
                  Select Count(*)
                  Into n_Count
                  From 病人路径医嘱 A
                  Where a.路径执行id = v_路径执行id And a.病人医嘱id <> 医嘱id_In;
                Else
                  Select Count(*)
                  Into n_Count
                  From 病人路径医嘱 A
                  Where a.路径执行id = v_路径执行id And
                        a.病人医嘱id Not In
                        (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In Or ID = v_相关id);
                End If;
                If n_Count = 0 Then
                  v_Error := '该医嘱对应的临床路径项目不是必要时生成的，不能删除。';
                  Raise Err_Custom;
                End If;
              Else
                --执行方式：0-无须执行(也可用于实现标签)，1-每天执行，2-至少执行一次，3-必要时执行,4-必须执行一次（所在阶段必须且仅执行一次）



                If v_路径执行方式 = 2 Or v_路径执行方式 = 4 Then
                  --程序界面已经处理（当阶段为多天的情况下,当前天数不是阶段最后一天时,执行方式为2或4时，是允许不添加变异原因就删除医嘱的）
                  Null;
                Else
                  v_Error := '该医嘱对应的临床路径项目是必须生成的，需要添加变异原因才能删除。';
                  Raise Err_Custom;
                End If;
              End If;
            End If;
          End If;
        End If;
        --判断是否是最后一条医嘱，分几种情况，一组医嘱，一条医嘱
        If n_Del类型 = 0 Then
          Select Count(1)
          Into n_Islast
          From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
          Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And b.Id = c.路径执行id And a.Id = v_路径记录id;
        Else
          --n_Del类型=1的都是删整组医嘱，有可能传入的是相关ID=null的也有可能是传入的相关ID<>null的
          If v_相关id Is Null Then
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C, 病人医嘱记录 D
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And a.Id = v_路径记录id And c.病人医嘱id = d.Id And
                  c.路径执行id = b.Id And (d.Id <> 医嘱id_In And d.相关id <> 医嘱id_In);
          Else
            Select Decode(Count(1), 0, 1, 0)
            Into n_Islast
            From 病人临床路径 A, 病人路径执行 B, 病人路径医嘱 C
            Where a.Id = b.路径记录id And a.当前阶段id = b.阶段id And a.当前天数 = b.天数 And c.路径执行id = b.Id And a.Id = v_路径记录id And
                  (c.病人医嘱id <> 医嘱id_In And c.病人医嘱id <> v_相关id);
          End If;
        End If;
      
        If n_Islast = 1 Then
          --是最后一条项目的最后一条医嘱，就调用路径项目删除的过程
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Zl_病人路径生成_Delete(v_路径执行id, 3);
          Else
            --必须生成但没有生成填写过变异原因的不删除项目
            Zl_病人路径生成_Delete(v_路径执行id, 2);
          End If;
        Else
          If n_Del类型 = 0 Then
            Delete From 病人路径医嘱 Where 病人医嘱id = 医嘱id_In And 路径执行id = v_路径执行id;
          
            --如果当前药品删除后，该执行id下只剩给药途径，则要该执行ID更改为一并给药中其他药品的执行ID
            If v_相关id Is Not Null Then
              Select Nvl(Max(c.Id), 0)
              Into v_Other路径执行id
              From 病人路径医嘱 A, 病人医嘱记录 B, 病人路径执行 C
              Where c.Id = a.路径执行id And b.相关id = v_相关id And b.Id <> 医嘱id_In And a.病人医嘱id = b.Id And
                    a.路径执行id <> v_路径执行id And c.登记时间 = (Select Max(d.登记时间)
                                                       From 病人路径执行 D, 病人医嘱记录 E, 病人路径医嘱 F
                                                       Where e.Id = f.病人医嘱id And d.Id = f.路径执行id And e.相关id = v_相关id And
                                                             f.路径执行id <> v_路径执行id);
            
              If v_Other路径执行id <> 0 Then
                Select Count(1)
                Into n_Count
                From 病人路径执行 A, 病人路径执行 B
                Where a.Id = v_Other路径执行id And b.Id = v_路径执行id And a.阶段id = b.阶段id And a.天数 = b.天数;
              
                If n_Count > 0 Then
                  Update 病人路径医嘱
                  Set 路径执行id = v_Other路径执行id
                  Where 病人医嘱id = v_相关id And 路径执行id = v_路径执行id And Not Exists
                   (Select 1 From 病人路径医嘱 C Where 路径执行id = v_路径执行id And 病人医嘱id <> v_相关id);
                End If;
              End If;
            End If;
          Else
            If v_相关id Is Null Then
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And
                    病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
            Else
              --单独给药:同时删除其给药途径
              Delete From 病人路径医嘱
              Where 路径执行id = v_路径执行id And 病人医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
            End If;
          End If;
          --该项目对应的医嘱删除完后，则删除路径项目，如果变异原因不为空且不是路径外项目则不删除项目，只删医嘱
          If v_变异原因 Is Null Or Nvl(n_路径项目id, 0) = 0 Then
            Delete From 病人路径执行
            Where ID = v_路径执行id And Not Exists (Select 1 From 病人路径医嘱 Where 路径执行id = v_路径执行id)
            Returning 路径记录id, 阶段id, 日期 Into n_路径记录id, n_阶段id, d_日期;
            --删除补录医嘱时,同时更新评估结果及变异原因
            If Nvl(n_路径项目id, 0) = 0 And n_紧急标志 = 2 And n_路径记录id <> 0 Then
              Select Count(1)
              Into n_Count
              From 病人路径评估
              Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
              If n_Count > 0 Then
                Select Count(1)
                Into n_Count
                From 病人路径执行
                Where 路径记录id = n_路径记录id And 阶段id + 0 = n_阶段id And 日期 = d_日期 And 变异原因 || '' = v_变异原因 And ID <> v_路径执行id;
                If n_Count = 0 Then
                  Select 时间进度
                  Into n_时间进度
                  From 病人路径评估
                  Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                  Select Count(1)
                  Into n_Count
                  From 病人路径变异
                  Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                  --当前阶段有且仅有一个变异原因且评估时的时间进度非正常时,不允许调整变异原因
                  If Not (n_Count = 1 And n_时间进度 <> 0) Then
                    Delete 病人路径变异
                    Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期 And 变异原因 = v_变异原因;
                    Select Count(1)
                    Into n_Count
                    From 病人路径变异
                    Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    If n_Count > 0 Then
                      Select 变异原因
                      Into v_变异原因
                      From 病人路径变异
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期 And Rownum < 2;
                      Update 病人路径评估
                      Set 变异原因 = v_变异原因
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    Else
                      Update 病人路径评估
                      Set 变异原因 = Null, 评估结果 = 1
                      Where 路径记录id = n_路径记录id And 阶段id = n_阶段id And 日期 = d_日期;
                    End If;
                  End If;
                End If;
              End If;
            End If;
          End If;
        
        End If;
      End Loop;
    End If;
  End;

  --删除关联诊断后删除医嘱
  If n_Del类型 = 0 Then
    Delete From 病人诊断医嘱 Where 医嘱id = 医嘱id_In;
    Delete From 病人医嘱记录 Where ID = 医嘱id_In;
  Else
    If v_相关id Is Null Then
      Delete From 病人诊断医嘱
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      --单独给药:同时删除其给药途径
      Delete From 病人诊断医嘱 Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id);
      Delete From 病人医嘱记录 Where ID = 医嘱id_In Or ID = v_相关id;
    End If;
  End If;

  If Nvl(删相关_In, 0) <> 0 Then
    --调整序号
    Update 病人医嘱记录
    Set 序号 = 序号 - n_Del_Count
    Where 病人id = v_病人id And Nvl(主页id, 0) = Nvl(v_主页id, 0) And Nvl(挂号单, '空') = Nvl(v_挂号单, '空') And
          Nvl(婴儿, 0) = Nvl(v_婴儿, 0) And 序号 > v_序号;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_Delete;
/

--92225:余伟节,2018-04-03,取消路径外项目
Create Or Replace Procedure Zl_病人路径生成_Delete
(
  执行记录id_In 病人路径执行.Id%Type,
  调用模式_In   Number := 0,
  调用场合_In   Number := 0
) Is
  --参数:调用模式_in=0:取消路径项目时调用,=1:重新生成医嘱时调用,=2：取消生成必须生成的项目时,
  --               =3:ZL_病人医嘱记录_Delete调用,防止住院医嘱编辑界面删除路径医嘱时将病人临床路径的当前阶段和当前天数置为空。
  --     调用场合_In =0:医生站  ;1-护士站
  t_Id   t_Numlist;
  t_时间 t_Strlist;
  --长期医嘱,其它阶段存在时不删除,未校对时才删除医嘱(界面已限制已校对但未作废的不允许删除路径项目)
  Cursor c_Advice(导入时间_In 病人临床路径.导入时间%Type) Is
    Select a.病人医嘱id
    From 病人路径医嘱 A, 病人医嘱记录 C
    Where 路径执行id = 执行记录id_In And a.病人医嘱id = c.Id And c.医嘱状态 = 1 And
          To_Date(To_Char(c.开嘱时间 + 59 / 24 / 60 / 60, 'yyyy-mm-dd hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') > 导入时间_In And
          Not Exists
     (Select 1 From 病人路径医嘱 B Where a.病人医嘱id = b.病人医嘱id And a.路径执行id <> b.路径执行id);

  Cursor c_Doc Is
    Select ID, To_Char(创建时间, 'yyyy-MM-dd hh24:mi:ss') From 电子病历记录 Where 路径执行id = 执行记录id_In;

  --删除最后一个项目时，检查前面是否有提前跳过的阶段。
  Cursor c_Turn
  (
    路径记录id_In 病人路径执行.路径记录id%Type,
    天数_In       病人路径执行.天数%Type,
    阶段id_In     病人路径执行.阶段id%Type
  ) Is
    Select a.阶段id
    From 病人路径执行 A
    Where a.路径记录id = 路径记录id_In And a.天数 = 天数_In And a.阶段id <> 阶段id_In And a.项目内容 = '未生成任何项目' And Exists
     (Select 1
           From 病人路径评估 B
           Where a.路径记录id = b.路径记录id And a.阶段id = b.阶段id And a.天数 = b.天数 And b.时间进度 = 1)
    Order By a.登记时间 Desc;
  t_阶段id t_Numlist;

  Cursor c_Merge
  (
    路径记录id_In 病人路径执行.路径记录id%Type,
    阶段id_In     病人路径执行.阶段id%Type
  ) Is
    Select a.Id, Max(b.合并路径阶段id) As 阶段id
    From 病人合并路径 A, 病人合并路径评估 B
    Where a.Id = b.合并路径记录id(+) And a.首要路径记录id = b.路径记录id(+) And b.阶段id(+) <> 阶段id_In And a.首要路径记录id = 路径记录id_In And
          (b.登记时间 = (Select Max(登记时间)
                     From 病人合并路径评估 C
                     Where c.路径记录id = b.路径记录id And c.合并路径记录id = b.合并路径记录id And c.阶段id = b.阶段id) Or b.登记时间 Is Null)
    Group By a.Id;
  t_合并路径阶段id t_Numlist;
  t_合并路径记录id t_Numlist;

  r_Pp_Item 病人路径执行%RowType;

  v_阶段id          病人路径执行.阶段id%Type;
  v_前一阶段id      病人路径执行.阶段id%Type;
  v_路径记录id      病人路径执行.路径记录id%Type;
  v_天数            病人路径执行.天数%Type;
  v_Last天数        病人路径执行.天数%Type;
  v_相关id          病人医嘱记录.相关id%Type;
  v_Other路径执行id 病人路径执行.Id%Type;
  v_变异原因        病人路径执行.变异原因%Type;
  n_Count           Number(5);
  n_变化天数        Number(5);
  d_导入时间        病人临床路径.导入时间%Type;
  n_时间进度        Number(5);

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin

  --如果路径内外项目是一并给药的，删除其中一个路径项目后，要该将其中的给药途径的执行ID更改为一并给药中其他药品的执行ID
  Select Nvl(Max(b.相关id), 0)
  Into v_相关id
  From 病人路径医嘱 A, 病人医嘱记录 B
  Where a.路径执行id = 执行记录id_In And a.病人医嘱id = b.Id And b.诊疗类别 In ('5', '6');

  If v_相关id <> 0 Then
    Select Nvl(Max(c.Id), 0)
    Into v_Other路径执行id
    From 病人路径医嘱 A, 病人医嘱记录 B, 病人路径执行 C
    Where c.Id = a.路径执行id And b.相关id = v_相关id And a.病人医嘱id = b.Id And a.路径执行id <> 执行记录id_In And
          c.登记时间 = (Select Max(d.登记时间)
                    From 病人路径执行 D, 病人医嘱记录 E, 病人路径医嘱 F
                    Where e.Id = f.病人医嘱id And d.Id = f.路径执行id And e.相关id = v_相关id And f.路径执行id <> 执行记录id_In);
  
    If v_Other路径执行id <> 0 Then
      Select Count(1)
      Into n_Count
      From 病人路径执行 A, 病人路径执行 B
      Where a.Id = v_Other路径执行id And b.Id = 执行记录id_In And a.阶段id = b.阶段id And a.天数 = b.天数;
    
      If n_Count > 0 Then
        --如果是两个项目有相同医嘱，对应不同的路径项目（合并路径和首要路径不重复生成的医嘱）时，不修改路径执行ID
        Select Count(1) Into n_Count From 病人路径医嘱 Where 路径执行id = v_Other路径执行id And 病人医嘱id = v_相关id;
        If n_Count = 0 Then
          Update 病人路径医嘱
          Set 路径执行id = v_Other路径执行id
          Where 病人医嘱id = v_相关id And 路径执行id = 执行记录id_In;
        End If;
      End If;
    End If;
  End If;

  --导入时间之前的路径项目对应的病历医嘱不删除
  Select b.导入时间
  Into d_导入时间
  From 病人路径执行 A, 病人临床路径 B
  Where a.路径记录id = b.Id And a.Id = 执行记录id_In;
  If d_导入时间 Is Not Null Then
    --是否允许取消的逻辑规则在界面程序中检查
    Open c_Advice(d_导入时间);
    Fetch c_Advice Bulk Collect
      Into t_Id;
    Close c_Advice;
  
    Delete 病人路径医嘱 Where 路径执行id = 执行记录id_In;
    If t_Id.Count > 0 Then
      Forall I In 1 .. t_Id.Count
        Delete From 病人医嘱记录 Where ID = t_Id(I) And 医嘱状态 = 1;
    End If;
  
    If 调用模式_In = 0 Or 调用模式_In = 2 Then
      Open c_Doc;
      Fetch c_Doc Bulk Collect
        Into t_Id, t_时间;
      Close c_Doc;
      If t_Id.Count > 0 Then
        For I In 1 .. t_Id.Count Loop
          If To_Date(t_时间(I), 'yyyy-MM-dd hh24:mi:ss') > d_导入时间 Then
            Zl_电子病历记录_Delete(t_Id(I));
          Else
            Update 电子病历记录 Set 路径执行id = Null Where ID = t_Id(I);
          End If;
        End Loop;
      End If;
    End If;
  End If;

  --如果是取消生成必须生成的项目时，不删除执行记录
  If 调用模式_In <> 2 Then
    If 调用模式_In = 3 Or 调用模式_In = 0 Then
      Select * Into r_Pp_Item From 病人路径执行 T Where ID = 执行记录id_In;
    End If;
    Delete 病人路径执行
    Where ID = 执行记录id_In
    Returning 路径记录id, 阶段id, 天数 Into v_路径记录id, v_阶段id, v_天数;
  End If;
  --避免医嘱下达界面时,删除所有医嘱导致临床路径项目都删除,当前天数和当前阶段被设置为空。
  If 调用模式_In = 3 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数;
  
    If n_Count = 0 Then
      --增加一个特殊项目[未生成任何项目]
      Insert Into 病人路径执行
        (ID, 路径记录id, 阶段id, 日期, 天数, 分类, 项目id, 登记人, 登记时间, 项目序号, 项目内容, 执行者, 生成者, 项目结果)
      Values
        (病人路径执行_Id.Nextval, r_Pp_Item.路径记录id, r_Pp_Item.阶段id, r_Pp_Item.日期, r_Pp_Item.天数, r_Pp_Item.分类, Null,
         Zl_Username, Sysdate, Null, '未生成任何项目', Null, 1, '已经执行|1' || Chr(9) || '已经执行');
    End If;
  End If;

  --取消补录的路径外项目时，如果存在阶段评估,自动更新 评估结果及 变异原因
  If (调用模式_In = 0 Or 调用模式_In = 3) And Nvl(r_Pp_Item.生成时间性质, 0) = 1 And Nvl(r_Pp_Item.项目id, 0) = 0 And 调用场合_In = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径评估
    Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数;
    If n_Count > 0 Then
      Select Count(1)
      Into n_Count
      From 病人路径执行
      Where 路径记录id = r_Pp_Item.路径记录id And 阶段id + 0 = r_Pp_Item.阶段id And 天数 = r_Pp_Item.天数 And 变异原因 = r_Pp_Item.变异原因 And
            ID <> r_Pp_Item.Id;
      If n_Count = 0 Then
        Select 时间进度
        Into n_时间进度
        From 病人路径评估
        Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
        Select Count(1)
        Into n_Count
        From 病人路径变异
        Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
        --当前阶段有且仅有一个变异原因且评估时的时间进度非正常时,不允许调整变异原因
        If Not (n_Count = 1 And n_时间进度 <> 0) Then
          Delete 病人路径变异
          Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期 And 变异原因 = r_Pp_Item.变异原因;
          Select Count(1)
          Into n_Count
          From 病人路径变异
          Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          If n_Count > 0 Then
            Select 变异原因
            Into v_变异原因
            From 病人路径变异
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期 And Rownum < 2;
            Update 病人路径评估
            Set 变异原因 = v_变异原因
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          Else
            Update 病人路径评估
            Set 变异原因 = Null, 评估结果 = 1
            Where 路径记录id = r_Pp_Item.路径记录id And 阶段id = r_Pp_Item.阶段id And 日期 = r_Pp_Item.日期;
          End If;
        End If;
      End If;
    End If;
  End If;
  If 调用模式_In = 0 And 调用场合_In = 0 Then
    Select Count(1)
    Into n_Count
    From 病人路径执行
    Where 路径记录id = v_路径记录id And 阶段id = v_阶段id And 天数 = v_天数;
    If n_Count = 0 Then
      Select Max(天数) Into v_天数 From 病人路径执行 Where 路径记录id = v_路径记录id And 阶段id = v_阶段id;
      Select Max(天数) Into v_Last天数 From 病人路径执行 Where 路径记录id = v_路径记录id;
      --记录变化的天数
      Select 当前天数 Into n_变化天数 From 病人临床路径 Where ID = v_路径记录id;
      --如果当前阶段的最后一个执行记录被删除(全部都是非必须执行的情况下)
      --由于路径跳转，一个阶段的天数可能与另一个路径的阶段交叉（例如：a路径第3阶段:3-5天,先执行第3天，跳转到其他路径后跳回来执行第5天）
      If v_天数 Is Null Or v_天数 <> v_Last天数 Then
        --a.如果当前没有任何执行记录
        If v_Last天数 Is Null Then
          Update 病人临床路径
          Set 前一阶段id = Null, 当前阶段id = Null, 当前天数 = Null, 状态 = 1
          Where ID = v_路径记录id;
          Update 病人合并路径
          Set 前一阶段id = Null, 当前阶段id = Null, 当前天数 = Null
          Where 首要路径记录id = v_路径记录id;
        Else
          --b.回退到前一个阶段
          --如果前一阶段是跳过的阶段，则直接删除
          Open c_Turn(v_路径记录id, v_Last天数, v_阶段id);
          Fetch c_Turn Bulk Collect
            Into t_阶段id;
          Close c_Turn;
          If t_阶段id.Count > 0 Then
            Forall I In 1 .. t_阶段id.Count
              Delete From 病人路径评估 Where 路径记录id = v_路径记录id And 阶段id = t_阶段id(I) And 天数 = v_Last天数;
            Forall I In 1 .. t_阶段id.Count
              Delete From 病人路径执行 Where 路径记录id = v_路径记录id And 阶段id = t_阶段id(I) And 天数 = v_Last天数;
            --删除后取最后一个阶段为前一阶段ID
            Select Max(阶段id)
            Into v_前一阶段id
            From 病人路径执行
            Where 路径记录id = v_路径记录id And 登记时间 = (Select Max(登记时间) From 病人路径执行 Where 路径记录id = v_路径记录id);
            Update 病人临床路径 Set 前一阶段id = v_前一阶段id Where ID = v_路径记录id;
          End If;
          --修改病人临床路径信息
          Select Max(阶段id)
          Into v_阶段id
          From 病人路径执行
          Where 路径记录id = v_路径记录id And
                登记时间 = (Select Max(登记时间)
                        From 病人路径执行
                        Where 路径记录id = v_路径记录id And 阶段id <> (Select 前一阶段id From 病人临床路径 Where ID = v_路径记录id));
          --重新获取当前天数
          --当前一阶段评估为：下一阶段提前至明天（时间进度=2）且第二天生成时在可选阶段中又跳过中间阶段生成后面的阶段时,
          --这种场景生成的路径表单执行取消本次生成时，v_Last天数需要重新获取）
          Select Max(天数) Into v_Last天数 From 病人路径执行 Where 路径记录id = v_路径记录id;
          --
          Update 病人临床路径
          Set 当前阶段id = 前一阶段id, 前一阶段id = v_阶段id, 当前天数 = v_Last天数, 状态 = 1
          Where ID = v_路径记录id;
        
          n_变化天数 := n_变化天数 - v_Last天数;
          --修改病人临床合并路径信息
          Select Nvl(当前阶段id, 0) Into v_阶段id From 病人临床路径 Where ID = v_路径记录id;
          Open c_Merge(v_路径记录id, v_阶段id);
          Fetch c_Merge Bulk Collect
            Into t_合并路径记录id, t_合并路径阶段id;
          Close c_Merge;
          If t_合并路径阶段id.Count > 0 Then
            Forall I In 1 .. t_合并路径阶段id.Count
              Update 病人合并路径
              Set 当前天数 = Decode(前一阶段id, Null, Null, Nvl(当前天数, 0) - Nvl(n_变化天数, 0)), 当前阶段id = 前一阶段id,
                  前一阶段id = t_合并路径阶段id(I)
              Where 首要路径记录id = v_路径记录id And ID = t_合并路径记录id(I);
          End If;
        End If;
      Else
        --如果一个阶段有多天，取消最后一个项目时，只更新天数
        Update 病人临床路径 Set 当前天数 = v_天数 Where ID = v_路径记录id And 当前天数 <> v_天数;
        n_变化天数 := n_变化天数 - v_天数;
        If n_变化天数 <> 0 Then
          --修改病人临床合并路径信息
          Select Nvl(当前阶段id, 0) Into v_阶段id From 病人临床路径 Where ID = v_路径记录id;
          Open c_Merge(v_路径记录id, v_阶段id);
          Fetch c_Merge Bulk Collect
            Into t_合并路径记录id, t_合并路径阶段id;
          Close c_Merge;
          If t_合并路径阶段id.Count > 0 Then
            Forall I In 1 .. t_合并路径阶段id.Count
              Update 病人合并路径
              Set 当前天数 = Decode(前一阶段id, Null, Null, Nvl(当前天数, 0) - Nvl(n_变化天数, 0)), 当前阶段id = 前一阶段id,
                  前一阶段id = t_合并路径阶段id(I)
              Where 首要路径记录id = v_路径记录id And ID = t_合并路径记录id(I);
          End If;
        End If;
      End If;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人路径生成_Delete;
/

--123545:刘涛,2018-04-02,留存领用冲销处理
Create Or Replace Procedure Zl_药品领用_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isnonum Exception;
  Err_Isbatch Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_库房id       药品收发记录.库房id%Type;
  v_对方部门id   药品收发记录.对方部门id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_摘要         药品收发记录.摘要%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;

  v_收发id   药品收发记录.Id%Type;
  v_领用人   药品收发记录.领用人%Type;
  v_批准文号 药品收发记录.批准文号%Type;
  v_发药方式 药品收发记录.发药方式%Type;

  v_是否变价     收费项目目录.是否变价%Type;
  Intdigit       Number;
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_按月留存领用 Varchar2(4000);
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  Select Nvl(是否变价, 0) Into v_是否变价 From 收费项目目录 Where ID = 药品id_In;
  Select Zl_Getsysparameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 7 And 记录状态 = 原记录状态_In;
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 7 And
          Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(实际数量) As 剩余数量, Sum(成本金额) As 剩余成本金额, Sum(零售金额) As 剩余零售金额, 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价,
         扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价, v_摘要,
       v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期
  From 药品收发记录
  Where NO = No_In And 单据 = 7 And 药品id = 药品id_In And 序号 = 序号_In
  Group By 库房id, 对方部门id, 入出类别id, 入出系数, 批次, 产地, 批号, 效期, 成本价, 扣率, 零售价, 摘要, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期;

  --冲销数量大于剩余数量，不允许
  If v_剩余数量 < 冲销数量_In Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 审核人, 审核日期, 领用人, 批准文号, 发药方式, 供药单位id, 生产日期, 扣率)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 7, No_In, 序号_In, v_库房id, v_对方部门id, v_入出类别id, v_入出系数, 药品id_In, v_批次,
     v_产地, v_批号, v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, v_摘要, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In,
     v_领用人, v_批准文号, v_发药方式, n_上次供应商id, d_上次生产日期, v_扣率);

  --更新库存信息
  Zl_药品库存_Update(v_收发id, 0);

  --科室药品留存处理
  If v_发药方式 = 1 Then
    Update 药品留存
    Set 可用数量 = Nvl(可用数量, 0) + 冲销数量_In, 实际数量 = Nvl(实际数量, 0) + 冲销数量_In, 实际金额 = Nvl(实际金额, 0) + v_零售金额
    Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_对方部门id And 库房id = v_库房id And
          药品id = 药品id_In;
	
	If Sql%RowCount = 0 Then
      Insert Into 药品留存
        (期间, 科室id, 库房id, 药品id, 可用数量, 实际数量, 实际金额)
      Values
        (To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')), v_对方部门id, v_库房id, 药品id_In, 冲销数量_In, 冲销数量_In, v_零售金额);
    End If;
	
    --将金额和数量等于0的记录删除掉
    Delete From 药品留存 Where Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0;
  End If;

  --处理调价后冲销
  Zl_药品收发记录_调价修正(v_收发id);
Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品领用_Strike;
/

--107905:冉俊明,2018-04-02,根据权限允许重新结算他人的异常结算单据
Create Or Replace Procedure Zl_门诊异常收费_更新操作员
(
  病人id_In     门诊费用记录.病人id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  结算序号_In   病人预交记录.结算序号%Type
) As
  n_组id 病人预交记录.缴款组id%Type;
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  For c_预交 In (Select Distinct 结帐id, 操作员姓名
               From 病人预交记录
               Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结算序号 = 结算序号_In) Loop
    --1.更新门诊费用记录的操作员
    Update 门诊费用记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
    Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结帐id = c_预交.结帐id;
    If Sql%RowCount = 0 Then
      Update 费用补充记录
      Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In
      Where Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0) And 结算id = c_预交.结帐id;
    End If;
  
    --2.更新病人预交记录的操作员
    --将原操作员姓名存在“摘要”中
    Update 病人预交记录
    Set 缴款组id = n_组id, 操作员编号 = 操作员编号_In, 操作员姓名 = 操作员姓名_In, 摘要 = 摘要 || '(原收款员：' || c_预交.操作员姓名 || ')'
    Where 结帐id = c_预交.结帐id And Nvl(病人id, 0) + 0 = Nvl(病人id_In, 0);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊异常收费_更新操作员;
/

--122592:陈刘,2018-03-26,专科体温单不能同步舒张压

CREATE OR REPLACE Procedure Zl_病人护理数据_Update
(
  文件id_In   In 病人护理数据.文件id%Type,
  发生时间_In In 病人护理数据.发生时间%Type,
  记录类型_In In 病人护理明细.记录类型%Type, --护理项目=1，签名记录=5，审签记录=15
  项目序号_In In 病人护理明细.项目序号%Type, --护理项目的序号，非护理项目固定为0
  记录内容_In In 病人护理明细.记录内容%Type := Null, --记录内容，如果内容为空，即清除以前的内容；37或38/37
  体温部位_In In 病人护理明细.体温部位%Type := Null,
  他人记录_In In Number := 1,
  数据来源_In In 病人护理明细.数据来源%Type := 0,
  审签_In     In Number := 0,
  操作员_In   In 病人护理数据.保存人%Type := Null,
  记录组号_In In 病人护理明细.记录组号%Type := Null, --适用分类汇总(一条数据对应多条相同项目的明细)
  相关序号_In In 病人护理明细.相关序号%Type := Null, --适用分类汇总(记录汇总项目关联的名称项目序号)
  未记说明_In In 病人护理明细.未记说明%Type := Null --入量导入存储医嘱ID:发送号
) Is
  Intins      Number(18);
  Int共用     Number(1);
  n_Newid     病人护理数据.Id%Type;
  n_Oldid     病人护理数据.Id%Type;
  n_行数      病人护理打印.行数%Type;
  n_Mutilbill Number(1);
  n_Syntend   Number(1);
  n_Synchro   Number(1);
  n_未记说明  Number(1);
  n_曲线      Number(1);
  n_Num       Number(18);

  n_汇总类别     病人护理数据.汇总类别%Type;
  v_科室id       部门表.Id%Type;
  v_保存人       人员表.姓名%Type;
  v_记录人       人员表.姓名%Type;
  n_文件id       病人护理数据.文件id%Type;
  n_记录id       病人护理数据.Id%Type;
  n_明细id       病人护理明细.Id%Type;
  n_来源id       病人护理明细.来源id%Type;
  v_数据来源     病人护理明细.数据来源%Type;
  n_最高版本     病人护理明细.开始版本%Type;
  n_项目性质     护理记录项目.项目性质%Type;
  n_病人id       病人护理文件.病人id%Type;
  n_主页id       病人护理文件.主页id%Type;
  n_婴儿         病人护理文件.婴儿%Type;
  d_婴儿出院时间 病人医嘱记录.开始执行时间%Type;
  d_文件开始时间 病人护理文件.开始时间%Type;
  v_Name         体温记录项目.记录名%Type;
  --提取该病人当前科室所有未结束的护理文件，且文件开始时间小于等于记录发生时间的文件列表供同步数据使用
  Cursor Cur_Fileformats Is
    Select a.Id As 格式id, b.Id As 文件id, a.保留, a.子类, b.婴儿
    From 病历文件列表 A, 病人护理文件 B, 病人护理文件 C, 病人护理数据 D
    Where a.种类 = 3 And a.保留 <> 1 And a.Id = b.格式id And b.Id <> c.Id And b.结束时间 Is Null And b.开始时间 <= d.发生时间 And
          (a.通用 = 1 Or (a.通用 = 2 And b.科室id = c.科室id)) And c.病人id = b.病人id And c.主页id = b.主页id And c.婴儿 = b.婴儿 And
          c.Id = d.文件id And d.Id = n_记录id And c.Id = 文件id_In
    Order By a.编号;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  --取记录ID
  Int共用     := 0;
  n_记录id    := 0;
  n_Mutilbill := 0;
  n_Syntend   := 0;
  n_未记说明  := 0;
  n_曲线      := 0;

  If 操作员_In Is Null Then
    v_保存人 := Zl_Username;
  Else
    v_保存人 := 操作员_In;
  End If;

  --如果是对应多份护理文件值为1，表示需同步其它护理文件；否则不处理文件同步
  n_Mutilbill := Zl_To_Number(zl_GetSysParameter('对应多份护理文件', 1255));
  --如果允许多份护理文件之间数据同步,则自动同步,否则不同步
  n_Syntend := Zl_To_Number(zl_GetSysParameter('允许数据同步', 1255));

  Begin
    Select ID, 汇总类别
    Into n_记录id, n_汇总类别
    From 病人护理数据
    Where 文件id = 文件id_In And 发生时间 = 发生时间_In;
  Exception
    When Others Then
      n_记录id := 0;
  End;

  Begin
    Select 记录名 Into v_Name From 体温记录项目 Where 项目序号 = 项目序号_In;
  Exception
    When Others Then
      v_Name := '';
  End;

  --检查是不是本人的记录
  ---------------------------------------------------------------------------------------------------------------------
  If 他人记录_In = 0 And n_记录id > 0 And 审签_In = 0 Then
    v_记录人 := '';
    Begin
      Select 记录人
      Into v_记录人
      From 病人护理明细
      Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      When Others Then
        v_记录人 := '';
    End;
    If v_记录人 Is Not Null And v_记录人 <> v_保存人 Then
      v_Error := '你无权修改他人登记的护理数据！';
      Raise Err_Custom;
    End If;
  End If;

  --检查是否入科
  Select 病人id, 主页id, Nvl(婴儿, 0), 开始时间
  Into n_病人id, n_主页id, n_婴儿, d_文件开始时间
  From 病人护理文件
  Where ID = 文件id_In;
  d_婴儿出院时间 := Null;
  If n_婴儿 <> 0 Then
    Begin
      Select 开始执行时间
      Into d_婴儿出院时间
      From 病人医嘱记录 B, 诊疗项目目录 C
      Where b.诊疗项目id + 0 = c.Id And b.医嘱状态 = 8 And Nvl(b.婴儿, 0) <> 0 And c.类别 = 'Z' And
            Instr(',3,5,11,', ',' || c.操作类型 || ',', 1) > 0 And b.病人id = n_病人id And b.主页id = n_主页id And b.婴儿 = n_婴儿;
    Exception
      When Others Then
        d_婴儿出院时间 := Null;
    End;
  End If;
  If d_婴儿出院时间 Is Null Then
    v_科室id := 0;
    Begin
      Select a.科室id
      Into v_科室id
      From 病人变动记录 A, 病人护理文件 B
      Where a.科室id Is Not Null And a.病人id = b.病人id And a.主页id = b.主页id And b.Id = 文件id_In And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '59', 'YYYY-MM-DD HH24:MI:SS') >= a.开始时间 And
            (To_Date(To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI') || '00', 'YYYY-MM-DD HH24:MI:SS') < = Nvl(a.终止时间, Sysdate) Or
            a.终止时间 Is Null)) And Rownum < 2;
    Exception
      When Others Then
        v_科室id := 0;
    End;
    If v_科室id = 0 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  Else
    If 发生时间_In < d_文件开始时间 Or 发生时间_In > d_婴儿出院时间 Then
      v_Error := '数据发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 不在病人有效变动时间范围内，不能操作！';
      Raise Err_Custom;
    End If;
  End If;

  --如果数据来源<>0则退出
  n_来源id := 0;
  If n_记录id > 0 Then
    Begin
      Select 数据来源, Nvl(来源id, 0)
      Into v_数据来源, n_来源id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0);
    Exception
      When Others Then
        v_数据来源 := 0;
    End;
    If v_数据来源 > 0 And n_来源id > 0 Then
      Return;
    End If;
  End If;

  --取最高版本
  Select Nvl(Max(Nvl(a.开始版本, 1)), 0) + 1, Count(b.Id)
  Into n_最高版本, Intins
  From 病人护理明细 A, 病人护理数据 B
  Where b.Id = n_记录id And a.记录id = b.Id And Mod(a.记录类型, 10) = 5;

  --目前已经签名的数据不能修改，只有在审签模式下进行修改，即审签_In=1
  If 审签_In <> 1 And Intins > 0 Then
    v_Error := '发生时间 ' || To_Char(发生时间_In, 'YYYY-MM-DD HH24:MI:SS') || ' 所对应的数据已经签名或审签，不能继续操作！' || Chr(13) || Chr(10) ||
               '这可能是由于网络并发操作引起的，请刷新后再试！';
    Raise Err_Custom;
  End If;
  Intins := 0;

  --无内容时,要清除数据（审签回退时会自动清除审签过程中修改的数据，所以此处只需考虑普签即可）
  If 记录内容_In Is Null Then
    Begin
      Select ID
      Into n_明细id
      From 病人护理明细
      Where 记录id = n_记录id And Nvl(项目序号, 0) = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
            Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 终止版本 Is Null;
    Exception
      --无数据退出
      When Others Then
        Return;
    End;

    --查找除了本条要删除的数据，是否还存其他有效的数据，如果存在只删除本条数据，否则删除此发生时间对应的所有数据。
    Select Count(ID)
    Into Intins
    From 病人护理明细
    Where 记录id = n_记录id And Mod(记录类型, 10) <> 5 And 终止版本 Is Null And ID <> n_明细id;
    If Intins = 0 Then
      Delete From 病人护理明细 Where 记录id = n_记录id;
    Else
      Delete From 病人护理明细 Where ID = n_明细id;
    End If;

    Delete From 病人护理数据 A
    Where a.Id = n_记录id And Not Exists (Select 1 From 病人护理明细 B Where b.记录id = a.Id);

    --如果是删除签名后修改产生的最后一条数据,则应将签名记录的终止版本清为空
    Begin
      Select 1
      Into Intins
      From 病人护理明细
      Where 开始版本 = n_最高版本 And 终止版本 Is Null And 记录类型 = 1 And 记录id = n_记录id;
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Update 病人护理明细 Set 终止版本 = Null Where 记录类型 = 5 And 开始版本 = n_最高版本 - 1 And 记录id = n_记录id;
    End If;
    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;

    --############
    --清除共用数据
    --############
    For Rsdel In (Select Distinct 记录id From 病人护理明细 Where 来源id = n_明细id) Loop

      Delete 病人护理明细 Where 来源id = n_明细id And 记录id = Rsdel.记录id;
      --删除对应的打印数据
      Begin
        Select Count(*) Into Intins From 病人护理明细 Where 记录id = Rsdel.记录id;
      Exception
        When Others Then
          Intins := 0;
      End;
      If Intins = 0 Then
        --提取清除数据对应的文件ID
        Begin
          Select b.Id, a.保留
          Into n_文件id, Intins
          From 病历文件列表 A, 病人护理文件 B, 病人护理数据 C
          Where a.Id = b.格式id And b.Id = c.文件id And c.Id = Rsdel.记录id;
        Exception
          When Others Then
            n_文件id := 0;
        End;
        Delete 病人护理数据 Where ID = Rsdel.记录id;
        If Intins <> -1 Then
          Zl_病人护理打印_Update(n_文件id, 发生时间_In, 1, 1);
        End If;
      End If;
    End Loop;
  Else
    --检查录入的项目是否属于该记录单
    Begin
      Select 1
      Into Intins
      From (Select b.项目序号
             From 病历文件结构 A, 护理记录项目 B
             Where a.要素名称 = b.项目名称 And b.项目序号 = 项目序号_In And
                   父id = (Select b.Id
                          From 病人护理文件 A, 病历文件结构 B
                          Where a.Id = 文件id_In And a.格式id = b.文件id And b.父id Is Null And b.对象序号 = 4)
             Union
             Select 项目序号
             From 护理记录项目
             Where 项目性质 = 2 And 项目序号 = 项目序号_In);
    Exception
      When Others Then
        Intins := 0;
    End;
    If Intins = 0 Then
      Return;
    End If;
    If n_记录id = 0 Then
      Select 病人护理数据_Id.Nextval Into n_记录id From Dual;

      Insert Into 病人护理数据
        (ID, 文件id, 发生时间, 最后版本, 保存人, 保存时间)
      Values
        (n_记录id, 文件id_In, 发生时间_In, n_最高版本, v_保存人, Sysdate);
    End If;

    --插入本次登记的病人护理明细
    Update 病人护理明细
    Set 记录内容 = 记录内容_In, 数据来源 = 数据来源_In, 未记说明 = 未记说明_In, 记录人 = v_保存人, 记录时间 = Sysdate
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    If Sql%RowCount = 0 Then
      Select 病人护理明细_Id.Nextval Into n_明细id From Dual;
      Insert Into 病人护理明细
        (ID, 记录id, 记录类型, 项目分组, 项目id, 相关序号, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 记录组号, 体温部位, 数据来源, 共用, 未记说明, 开始版本, 终止版本,
         记录人, 记录时间)
        Select n_明细id, n_记录id, 记录类型_In, a.分组名, a.项目id, 相关序号_In, a.项目序号, Upper(a.项目名称), a.项目类型, 记录内容_In, a.项目单位, 0,
               记录组号_In, 体温部位_In, 数据来源_In, Nvl(b.共用, 0), 未记说明_In, n_最高版本, Null, v_保存人, Sysdate
        From 护理记录项目 A, 病人护理明细 B
        Where a.项目序号 = b.项目序号(+) And b.终止版本(+) Is Null And b.记录id(+) = n_记录id And a.项目序号 = 项目序号_In And Rownum < 2;
    End If;
    Select ID
    Into n_明细id
    From 病人护理明细
    Where 记录id = n_记录id And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0) And 开始版本 = n_最高版本 And 终止版本 Is Null;
    --填写历史数据及签名记录的终止版本
    Update 病人护理明细
    Set 终止版本 = n_最高版本
    Where 记录id = n_记录id And ((Mod(记录类型, 10) <> 5 And 项目序号 = 项目序号_In And Nvl(体温部位, 'TWBW') = Nvl(体温部位_In, 'TWBW') And
          Nvl(记录组号, 0) = Nvl(记录组号_In, 0)) Or 记录类型 = Decode(审签_In, 1, 15, 5)) And 开始版本 <= n_最高版本 - 1 And 终止版本 Is Null;

    --如果是未签名数据，最后修改操作员做为该记录的保存人更新
    If n_最高版本 = 1 Then
      Update 病人护理数据 Set 保存人 = v_保存人, 保存时间 = Sysdate Where ID = n_记录id;
    End If;

    If Nvl(n_汇总类别, 0) <> 0 Then
      Return;
    End If;

    --############
    --同步共用数据
    --############
    --1\先处理体温单（一个病人始终只存在一份有效的体温单文件）
    --如果体温表存在相同发生时间的数据，使用它的ID
    --CL,2015-12-30,记录单同步文字项目到体温单
    For Row_Format In Cur_Fileformats Loop
      If Row_Format.保留 = -1 Then
        If Row_Format.子类 = '1' Then
          If 项目序号_In = 4 Or 项目序号_In = 5 Then
            Select Max(内容文本)
            Into n_Num
            From 病人护理文件 A, 病历文件结构 B
            Where a.格式id = b.文件id And a.Id = Row_Format.文件id And 要素名称 = '婴儿体温单';
            If Not (n_Num = 1) Then
              v_Name := '血压';
            End If;
          End If;
          Begin
            Select 1, h.项目性质
            Into Intins, n_项目性质
            From (Select To_Char(f.记录名) As 项目名称, g.项目性质
                   From 体温记录项目 F, 护理记录项目 G
                   Where f.项目序号 = g.项目序号 And g.项目性质 = 2 And
                         (g.适用科室 = 1 Or
                         (g.适用科室 = 2 And Exists
                          (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id))) And Nvl(g.应用方式, 0) <> 0 And
                         (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2))
                   Union All
                   Select b.要素名称 As 项目名称, 1 As 项目性质
                   From 病历文件结构 A, 病历文件结构 B
                   Where a.文件id = Row_Format.格式id And a.父id Is Null And a.对象序号 In (2, 3) And b.父id = a.Id) H
            Where Instr(',' || h.项目名称 || ',', ',' || v_Name || ',', 1) > 0;
          Exception
            When Others Then
              Intins := 0;
          End;
        Else
          Begin
            Select 1, g.项目性质
            Into Intins, n_项目性质
            From 体温记录项目 F, 护理记录项目 G
            Where f.项目序号 = g.项目序号 And Nvl(g.应用方式, 0) <> 0 And g.护理等级 >= 0 And
                  (Nvl(g.适用病人, 0) = 0 Or Nvl(g.适用病人, 0) = Decode(Nvl(Row_Format.婴儿, 0), 0, 1, 2)) And f.项目序号 = 项目序号_In And
                  (g.适用科室 = 1 Or (g.适用科室 = 2 And Exists
                   (Select 1 From 护理适用科室 D Where g.项目序号 = d.项目序号 And d.科室id = v_科室id)));
          Exception
            When Others Then
              Intins := 0;
          End;
        End If;

        If Intins > 0 Then
          --LPF,2013-01-23,检查此项目是否需要进行同步(对于以前已经同步过的数据，为了保证记录单和体温单数据一直将不根据此函数判断。)
          n_Synchro := Zl_Temperatureprogram(文件id_In, v_科室id, 项目序号_In, 发生时间_In);
          Begin
            Select b.Id
            Into n_Newid
            From 病人护理文件 A, 病人护理数据 B
            Where a.Id = Row_Format.文件id And b.文件id = a.Id And b.发生时间 = 发生时间_In;
          Exception
            When Others Then
              n_Newid := 0;
          End;
          n_Oldid := n_Newid;
          If n_Newid = 0 And n_Synchro = 1 Then
            Select 病人护理数据_Id.Nextval Into n_Newid From Dual;
            --产生体温单主记录
            Insert Into 病人护理数据
              (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
            Values
              (n_Newid, Row_Format.文件id, v_保存人, Sysdate, 发生时间_In, 1);
          End If;

          Begin
            Select To_Number(记录内容_In) Into n_Num From Dual;
          Exception
            When Invalid_Number Then
              Begin
                Select 1 Into n_曲线 From 体温记录项目 Where 项目序号 = 项目序号_In And 记录法 = 1;
              Exception
                When Others Then
                  n_曲线 := 0;
              End;
              Begin
                Select 1 Into n_未记说明 From 常用体温说明 Where 名称 = 记录内容_In;
              Exception
                When Others Then
                  n_未记说明 := 0;
              End;
          End;

          If n_Newid > 0 Then
            --插入未同步的体温单数据(仍然要联接多表查询)
            Select Count(*)
            Into v_数据来源
            From 病人护理明细
            Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                  Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无');
            If v_数据来源 = 0 Then
              --说明在同步开始已经进行过检查
              If n_Synchro = 1 Then
                --没有检查此项目是否需要同步
                If n_曲线 = 1 And n_未记说明 = 1 Then
                  Insert Into 病人护理明细
                    (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                     记录人, 记录时间, 记录组号)
                    Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, Null, b.项目单位,
                           b.记录标记, b.体温部位, 1, b.Id, b.记录内容, 1, Null, b.记录人, Sysdate, 1
                    From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                           From Dual
                           Minus
                           Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                           From 病人护理明细 E, 护理记录项目 F
                           Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                    Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                  If Sql%RowCount > 0 Then
                    Int共用 := 1;
                  End If;
                Else
                  Insert Into 病人护理明细
                    (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 开始版本, 终止版本, 记录人,
                     记录时间, 记录组号)
                    Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                           b.记录标记, b.体温部位, 1, b.Id, 1, Null, b.记录人, Sysdate, 1
                    From (Select 项目序号_In As 项目序号, Nvl(体温部位_In, '无') As 体温部位
                           From Dual
                           Minus
                           Select f.项目序号, Decode(Nvl(f.项目性质, 1), 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无'))
                           From 病人护理明细 E, 护理记录项目 F
                           Where e.记录id = n_Newid And e.项目序号 = f.项目序号) A, 病人护理明细 B
                    Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                  If Sql%RowCount > 0 Then
                    Int共用 := 1;
                  End If;
                end if;
              End If;
            Else
              If n_曲线 = 1 And n_未记说明 = 1 Then
                Update 病人护理明细
                Set 未记说明 = 记录内容_In, 来源id = n_明细id, 记录内容 = Null
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                      Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And
                      Decode(n_项目性质, 2, Nvl(体温部位, '无'), Nvl(体温部位_In, '无')) = Nvl(体温部位_In, '无') And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
        --2\再循环处理记录单
      Else
        If n_Mutilbill = 1 And n_Syntend = 1 Then
          --提取记录单与当前记录单存在重叠的且有数据的固定项目
          Select Count(*)
          Into Intins
          From (Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B
                 Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                       父id =
                       (Select ID From 病历文件结构 Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                 Intersect
                 Select b.项目序号
                 From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                 Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                       b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                       a.父id = (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4));

          If Intins > 0 Then
            n_Newid := 0;
            --可能指定文件已经存在相同发生时间的数据，直接用它的ID即可
            Begin
              Select c.Id
              Into n_Newid
              From 病人护理数据 C
              Where c.文件id = Row_Format.文件id And c.发生时间 = 发生时间_In;
            Exception
              When Others Then
                n_Newid := 0;
            End;

            If n_Newid = 0 Then
              --产生记录单主记录
              Select 病人护理数据_Id.Nextval Into n_Newid From Dual;

              Insert Into 病人护理数据
                (ID, 文件id, 保存人, 保存时间, 发生时间, 最后版本)
                Select n_Newid, Row_Format.文件id, c.保存人, c.保存时间, c.发生时间, 1
                From 病人护理数据 C
                Where c.Id = n_记录id;
            End If;

            If n_Newid > 0 Then
              --插入未同步的记录单数据
              Select Count(*) Into v_数据来源 From 病人护理明细 Where 记录id = n_Newid And 项目序号 = 项目序号_In;
              If v_数据来源 = 0 Then
                Insert Into 病人护理明细
                  (ID, 记录id, 记录类型, 项目分组, 项目id, 项目序号, 项目名称, 项目类型, 记录内容, 项目单位, 记录标记, 体温部位, 数据来源, 来源id, 未记说明, 开始版本, 终止版本,
                   记录人, 记录时间)
                  Select 病人护理明细_Id.Nextval, n_Newid, b.记录类型, b.项目分组, b.项目id, b.项目序号, b.项目名称, b.项目类型, b.记录内容, b.项目单位,
                         b.记录标记, b.体温部位, 1, b.Id, b.未记说明, 1, Null, b.记录人, Sysdate
                  From (Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B
                         Where a.要素名称 = b.项目名称 And b.项目表示 In (0, 4, 5) And
                               父id = (Select ID
                                      From 病历文件结构
                                      Where 文件id = Row_Format.格式id And 父id Is Null And 对象序号 = 4)
                         Intersect
                         Select b.项目序号
                         From 病历文件结构 A, 护理记录项目 B, 病人护理文件 C, 病人护理数据 D, 病人护理明细 G
                         Where c.Id = d.文件id And a.文件id = c.格式id And d.Id = g.记录id And d.Id = n_记录id And g.Id = n_明细id And
                               b.项目序号 = g.项目序号 And b.项目表示 In (0, 4, 5) And g.记录类型 = 1 And a.要素名称 = b.项目名称 And
                               a.父id =
                               (Select ID From 病历文件结构 E Where e.文件id = c.格式id And 父id Is Null And 对象序号 = 4)) A, 病人护理明细 B
                  Where a.项目序号 = b.项目序号 And b.记录id = n_记录id And b.Id = n_明细id;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                  --原行数不要动
                  Begin
                    Select 行数 Into n_行数 From 病人护理打印 Where 文件id = Row_Format.文件id And 记录id = n_Newid;
                  Exception
                    When Others Then
                      n_行数 := 1;
                  End;
                  Zl_病人护理打印_Update(Row_Format.文件id, 发生时间_In, n_行数, 0);
                End If;
              Else
                Update 病人护理明细
                Set 记录内容 = 记录内容_In, 未记说明 = 未记说明_In, 来源id = n_明细id
                Where 记录id = n_Newid And 项目序号 = 项目序号_In And 数据来源 > 0;
                If Sql%RowCount > 0 Then
                  Int共用 := 1;
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    End Loop;

    If Int共用 = 1 Then
      Update 病人护理明细 Set 共用 = 1 Where ID = n_明细id;
      --将历史数据的共用标志设置为NULL
      Update 病人护理明细 Set 共用 = Null Where 记录id = n_记录id And 项目序号 = 项目序号_In And ID <> n_明细id;
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人护理数据_Update;
/

--120765:曾杰,2018-03-21,图像校对
Create Or Replace Procedure Zl_影像检查图象_校对
(
  医嘱id_In   In 影像检查记录.医嘱id%Type,
  图像uid_In  In 影像检查图象.图像uid%Type,
  校对日期_In In 影像检查记录.校对日期%Type,
  校对结果_In In 影像检查图象.校对结果%Type
) Is
  n_校对状态 Number(1);
  n_Tag      Number(1);
  n_Count    Number(4);
Begin

  Select Nvl(校对状态, 0) Into n_校对状态 From 影像检查记录 Where 医嘱id = 医嘱id_In;
  Update 影像检查图象 Set 校对结果 = 校对结果_In Where 图像uid = 图像uid_In;
  Commit;

  If 校对结果_In = 5 Or 校对结果_In = 6 Then
    n_Tag := 1;
  Else
    n_Tag := 2;
  End If;

  If n_校对状态 = 0 Then
    Update 影像检查记录 Set 校对状态 = n_Tag, 校对日期 = 校对日期_In Where 医嘱id = 医嘱id_In;
  Elsif n_校对状态 = 1 And n_Tag = 2 Then
    Update 影像检查记录 Set 校对状态 = n_Tag Where 医嘱id = 医嘱id_In;
  Elsif n_校对状态 = 2 And (校对结果_In = 5 Or 校对结果_In = 6) Then
    Select Count(1)
    Into n_Count
    From 影像检查记录 a, 影像检查序列 b, 影像检查图象 c
    Where a.检查uid = b.检查uid And b.序列uid = c.序列uid And a.医嘱id = 医嘱id_In And (c.校对结果 > 0 And c.校对结果 < 5);
  
    If n_Count = 0 Then
      Update 影像检查记录 Set 校对状态 = 1 Where 医嘱id = 医嘱id_In;
    End If;
  End If;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查图象_校对;
/

--123126:刘兴洪,2018-03-21,限号数判断错误
Create Or Replace Procedure Zl_病人挂号记录_出诊_Insert
(
  出诊记录id_In    临床出诊记录.Id%Type,
  病人id_In        门诊费用记录.病人id%Type,
  门诊号_In        门诊费用记录.标识号%Type,
  姓名_In          门诊费用记录.姓名%Type,
  性别_In          门诊费用记录.性别%Type,
  年龄_In          门诊费用记录.年龄%Type,
  付款方式_In      门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号
  费别_In          门诊费用记录.费别%Type,
  单据号_In        门诊费用记录.No%Type,
  票据号_In        门诊费用记录.实际票号%Type,
  序号_In          门诊费用记录.序号%Type,
  价格父号_In      门诊费用记录.价格父号%Type,
  从属父号_In      门诊费用记录.从属父号%Type,
  收费类别_In      门诊费用记录.收费类别%Type,
  收费细目id_In    门诊费用记录.收费细目id%Type,
  数次_In          门诊费用记录.数次%Type,
  标准单价_In      门诊费用记录.标准单价%Type,
  收入项目id_In    门诊费用记录.收入项目id%Type,
  收据费目_In      门诊费用记录.收据费目%Type,
  结算方式_In      Varchar2,
  应收金额_In      门诊费用记录.应收金额%Type,
  实收金额_In      门诊费用记录.实收金额%Type,
  病人科室id_In    门诊费用记录.病人科室id%Type,
  开单部门id_In    门诊费用记录.开单部门id%Type,
  执行部门id_In    门诊费用记录.执行部门id%Type,
  操作员编号_In    门诊费用记录.操作员编号%Type,
  操作员姓名_In    门诊费用记录.操作员姓名%Type,
  发生时间_In      门诊费用记录.发生时间%Type,
  登记时间_In      门诊费用记录.登记时间%Type,
  医生姓名_In      挂号安排.医生姓名%Type,
  医生id_In        挂号安排.医生id%Type,
  病历费_In        Number, --该条记录是否病历工本费
  急诊_In          Number,
  号别_In          挂号安排.号码%Type,
  诊室_In          门诊费用记录.发药窗口%Type,
  结帐id_In        门诊费用记录.结帐id%Type,
  领用id_In        票据使用明细.领用id%Type,
  预交支付_In      病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入.
  现金支付_In      病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入.
  个帐支付_In      病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入.
  保险大类id_In    门诊费用记录.保险大类id%Type,
  保险项目否_In    门诊费用记录.保险项目否%Type,
  统筹金额_In      门诊费用记录.统筹金额%Type,
  摘要_In          门诊费用记录.摘要%Type, --预约挂号摘要信息
  预约挂号_In      Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数
  收费票据_In      Number := 0, --挂号是否使用收费票据
  保险编码_In      门诊费用记录.保险编码%Type,
  复诊_In          病人挂号记录.复诊%Type := 0,
  号序_In          挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录
  社区_In          病人挂号记录.社区%Type := Null,
  预约接收_In      Number := 0,
  预约方式_In      预约方式.名称%Type := Null,
  生成队列_In      Number := 0,
  卡类别id_In      病人预交记录.卡类别id%Type := Null,
  结算卡序号_In    病人预交记录.结算卡序号%Type := Null,
  卡号_In          病人预交记录.卡号%Type := Null,
  交易流水号_In    病人预交记录.交易流水号%Type := Null,
  交易说明_In      病人预交记录.交易说明%Type := Null,
  合作单位_In      病人预交记录.合作单位%Type := Null,
  操作类型_In      Number := 0,
  险类_In          病人挂号记录.险类%Type := Null,
  结算模式_In      Number := 0,
  记帐费用_In      Number := 0,
  退号重用_In      Number := 1,
  冲预交病人ids_In Varchar2 := Null,
  修正病人费别_In  Number := 0,
  更新交款余额_In  Number := 0, --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况
  预约顺序号_In    临床出诊序号控制.预约顺序号%Type := Null,
  修正病人年龄_In  Number := 0,
  收费单_In        病人挂号记录.收费单%Type := Null
) As
  ---------------------------------------------------------------------------
  --
  --参数:
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别
  ----------------------------------------------------------------------------
  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO
    Order By 结帐id, NO;
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总)
  --       第一行费用处理票据使用情况(领用ID_IN>0)

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_排队号码 排队叫号队列.排队号码%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  v_队列名称 排队叫号队列.队列名称%Type;

  n_分时段       Number;
  n_原始分时段   Number;
  n_时段限号     Number;
  n_时段限约     Number;
  d_时段时间     Date;
  d_最大序号时间 Date;
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况
  n_已约数       病人挂号汇总.已约数%Type;
  n_已接收       病人挂号汇总.其中已接收%Type;
  n_预约有效时间 Number;
  n_失效数       Number;
  n_失约挂号     Number := 0;
  n_已用数量     Number;
  n_锁定         Number := 0;

  n_打印id   票据打印内容.Id%Type;
  n_费用id   门诊费用记录.Id%Type;
  n_预交金额 病人预交记录.金额%Type;
  n_当前金额 病人预交记录.金额%Type;
  n_返回值   病人预交记录.金额%Type;
  n_预交id   病人预交记录.Id%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_挂号id   病人挂号记录.Id%Type;

  n_组id           财务缴款分组.Id%Type;
  n_序号           挂号序号状态.序号%Type;
  n_已用序号       挂号序号状态.序号%Type;
  n_序号控制       挂号安排.序号控制%Type;
  n_分诊台签到排队 Number;
  n_Count          Number;
  n_限号数         Number(18);
  n_自制卡         Number;
  d_排队时间       Date;
  v_结算方式记录   Varchar2(1000);
  d_序号时间       Date;
  v_费别           费别.名称%Type;
  n_时段序号       Number := -1;
  n_预约生成队列   Number;
  v_结算方式       结算方式.名称%Type;
  v_结算内容       Varchar2(1000);
  v_当前结算       Varchar2(200);
  v_结算号码       病人预交记录.结算号码%Type;
  n_结算金额       病人预交记录.冲预交%Type;
  n_三方卡标志     Number(2);
  n_安排id         挂号安排.Id%Type;
  n_预约顺序号     临床出诊序号控制.预约顺序号%Type;
  n_计划id         挂号安排计划.Id%Type := 0;
  v_星期           挂号安排限制.限制项目%Type;
  n_限约数         Number(18);
  n_已挂数         Number(4) := 0;
  n_Exists         Number;
  n_挂出的最大序号 Number(4) := 0;
  n_分时点显示     Number(3);
  n_结算模式       病人信息.结算模式%Type;
  v_排队序号       排队叫号队列.排队序号%Type;
  v_机器名         挂号序号状态.机器名%Type;
  v_序号操作员     挂号序号状态.操作员姓名%Type;
  v_序号机器名     挂号序号状态.机器名%Type;
  v_付款方式       病人挂号记录.医疗付款方式%Type;
  n_状态           临床出诊序号控制.挂号状态%Type;
Begin
 
  --获取当前机器名称
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  n_组id := Zl_Get组id(操作员姓名_In);

  If Nvl(预约挂号_In, 0) = 0 Then
    --挂号或者预约接收
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*)
    Into n_Count
    From 门诊费用记录
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    --获取结算方式名称
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
    Begin
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
    Exception
      When Others Then
        v_个人帐户 := '个人帐户';
    End;
  End If;

  n_序号 := 号序_In;
  v_费别 := 费别_In;
  d_时段时间 := 发生时间_In;

  If Nvl(序号_In, 0) = 1 Then
    If 出诊记录id_In Is Not Null Then
      Begin
        Select 1
        Into n_Exists
        From 临床出诊记录
        Where ID = 出诊记录id_In And Nvl(是否发布, 0) = 1 And Nvl(是否锁定, 0) = 0;
      Exception
        When Others Then
          v_Err_Msg := '无法确定出诊记录，请检查出诊记录是否存在或被锁定！';
          Raise Err_Item;
      End;
    End If;

    If 费别_In Is Null Then
      Begin
        Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
      Exception
        When Others Then
          v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！';
          Raise Err_Item;
      End;
    End If;
    If Nvl(修正病人费别_In, 0) = 1 And v_费别 Is Not Null Then
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
    End If;
  
    If Nvl(修正病人年龄_In, 0) = 1 Then
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In;
    End If;
  
    If 门诊号_In Is Not Null Then
      Update 病人信息 Set 门诊号 = 门诊号_In Where 病人id = 病人id_In And Nvl(门诊号, 0) = 0;
    End If;
  
    Update 临床出诊序号控制
    Set 挂号状态 = 0
    Where 记录id = 出诊记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
  
    --获取是否分时段
    Begin
      Select Nvl(是否分时段, 0), Nvl(是否序号控制, 0), 限号数, 限约数, 已挂数, 已约数
      Into n_分时段, n_序号控制, n_限号数, n_限约数, n_已挂数, n_已约数
      From 临床出诊记录
      Where ID = 出诊记录id_In;
      n_原始分时段 := n_分时段;
    Exception
      When Others Then
        n_分时段     := 0;
        n_原始分时段 := n_分时段;
        n_序号控制   := 0;
        n_限号数     := Null;
        n_限约数     := Null;
    End;
  
    --获取当前未使用的序号
    If Nvl(预约挂号_In, 0) = 0 Then
      n_预约有效时间 := Zl_To_Number(Zl_Getsysparameter('预约有效时间', 1111));
      n_失约挂号     := Zl_To_Number(Zl_Getsysparameter('失约用于挂号', 1111));
    End If;
    n_失效数 := 0;
  
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量>
      If Nvl(预约挂号_In, 0) = 0 And Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
        Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 预约时间), 1, 1, 0))
        Into n_失效数
        From 病人挂号记录
        Where 出诊记录id = 出诊记录id_In And 记录状态 = 1 And 记录性质 = 2;
      End If;
      If n_序号 Is Null Then
        n_已用序号 := Null;
        If n_原始分时段 = 0 Then
          Select Min(序号) Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And Nvl(挂号状态, 0) = 0;
        End If;
        If n_已用序号 Is Null Then
          Select Nvl(Max(序号), 0) + 1 Into n_已用序号 From 临床出诊序号控制 Where 记录id = 出诊记录id_In;
        End If;
        n_序号 := Nvl(n_已用序号, 0);
      End If;
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end
      --非加号的情况需要检查是否超过了限制
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号时检查
          --启用序号控制未分时段 达到了限制
          If n_限号数 <= n_已挂数 And n_限号数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已达到最大限号数！';
            Raise Err_Item;
          End If;
        Else
          --预约时检查
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
        
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！';
            Raise Err_Item;
          End If;
        End If;
      Else
        Null;
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充
      End If;
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then
      --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来
      If n_序号 Is Null And Nvl(预约挂号_In, 0) = 1 Then
        Begin
          Select 序号
          Into n_序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 开始时间 = 发生时间_In And Rownum < 2;
        Exception
          When Others Then
            n_序号 := Null;
        End;
      End If;
    
      If Nvl(预约挂号_In, 0) = 1 Then
        Begin
          Select Nvl(序号, 0),
                 To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
                 数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
          Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 Is Null;
        Exception
          When Others Then
            n_时段序号 := -1;
            n_分时段   := 0;
            d_时段时间 := 发生时间_In;
            n_时段限号 := 0;
            n_时段限约 := 0;
        End;
      End If;
    
      --<--普通号分时段 这里只有预约一种情况-->
      If 操作类型_In = 0 And Nvl(预约挂号_In, 0) = 1 Then
        --<正常预约挂号-->
      
        Select Nvl(Sum(Decode(Nvl(Sign(a.开始时间 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数
        Into n_已约数
        From 临床出诊序号控制 A
        Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
      
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理
        --检查限制数量
        If n_限约数 = 0 Then
          n_限约数 := n_限号数;
        End If;
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！';
          Raise Err_Item;
        End If;
      Elsif 操作类型_In = 0 And n_限号数 <= n_已挂数 - n_失效数 Then
        v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
        Raise Err_Item;
      End If;
      If Nvl(预约挂号_In, 0) = 1 Then
        --获取当天挂出的最大号序
        Select Nvl(Max(序号), 0)
        Into n_挂出的最大序号
        From 临床出诊序号控制 A
        Where 记录id = 出诊记录id_In And 预约顺序号 Is Null And 挂号状态 Not In (0, 5);
        If 预约顺序号_In Is Not Null Then
          n_预约顺序号 := 预约顺序号_In;
        Else
        
          Select Nvl(Max(预约顺序号), 0) + 1
          Into n_预约顺序号
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Not Null;
        
        End If;
        --设置序号
        n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_预约顺序号;
        If n_预约顺序号 Is Null Then
          n_序号 := Nvl(n_挂出的最大序号, 0) + 1;
        End If;
      End If;
      --<--普通号分时段--End>
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then
      --<启用序号控制 设置时段
      --专家号分时段
      Begin
        Select Nvl(序号, 0),
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               数量, Decode(Nvl(是否预约, 0), 0, 0, 数量)
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约
        From 临床出诊序号控制
        Where 记录id = 出诊记录id_In And 序号 = n_序号;
      Exception
        When Others Then
          n_时段序号 := -1;
          n_分时段   := 0;
          d_时段时间 := 发生时间_In;
          n_时段限号 := 0;
          n_时段限约 := 0;
      End;
    
      Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(开始时间 - d_时段时间), 0, 1, 0))
      Into n_已用序号, n_已挂数, n_已用数量
      From 临床出诊序号控制
      Where 记录id = 出诊记录id_In And 挂号状态 Not In (0, 4, 5);
    
      n_失效数 := 0;
      If Nvl(预约挂号_In, 0) = 0 Then
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then
        
          Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 开始时间), 1, 1, 0))
          Into n_失效数
          From 临床出诊序号控制
          Where 记录id = 出诊记录id_In And 开始时间 Between Trunc(Sysdate) And Sysdate And Nvl(挂号状态, 0) = 2;
        
        End If;
      End If;
    
      If 操作类型_In = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
        
          --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理
          If 号序_In Is Null Then
          
            Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'),
                                'yyyy-mm-dd hh24:mi:ss'))
            Into d_最大序号时间
            From 临床出诊序号控制
            Where 记录id = 出诊记录id_In And Nvl(数量, 0) <> 0;
          
            n_追加号 := Case Sign(发生时间_In - d_最大序号时间)
                       When -1 Then
                        0
                       Else
                        1
                     End;
          
          End If;
        
          --挂号 追加号码时不检查时段限号数
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 - n_失效数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约挂号
          If n_限约数 = 0 Then
            n_限约数 := n_限号数;
          End If;
          If n_限约数 <= n_已用数量 Then
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
          If n_限号数 <= n_已挂数 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      If n_序号 Is Null Then
        --设置序号
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then
          n_已用序号 := Nvl(n_时段序号, 0);
        End If;
        n_序号 := Nvl(n_已用序号, 0) + 1;
      End If;
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then
      ---<--普通号  -->
      If Nvl(操作类型_In, 0) = 0 Then
        If Nvl(预约挂号_In, 0) = 0 Then
          --挂号
          If Nvl(n_已挂数, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        Else
          --预约
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or
             (Nvl(n_已挂数, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      ---<--普通号  -->
    End If;
  
    --更新挂号序号状态
    If Not n_序号 Is Null Then
      If n_分时段 = 1 Then
        d_序号时间 := 发生时间_In;
      Else
        d_序号时间 := Trunc(发生时间_In);
      End If;
    
      --锁定序号的处理
      Begin
        If n_预约顺序号 Is Null Then
          Select 操作员姓名, 工作站名称
          Into v_序号操作员, v_序号机器名
          From 临床出诊序号控制
          Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_序号;
        Else
          Select 操作员姓名, 工作站名称
          Into v_序号操作员, v_序号机器名
          From 临床出诊序号控制
          Where Nvl(挂号状态, 0) = 5 And 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号;
        End If;
        n_锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_锁定       := 0;
      End;
    
      If n_锁定 = 0 Then
        If n_预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 3 And 操作员姓名 = 操作员姓名_In;
        End If;
      
        If Sql%Rowcount = 0 Then
          Begin
            If Nvl(n_分时段, 0) > 0 Then
              If Nvl(n_序号控制, 0) = 1 Then
                --分时段后专家号 失约的预约号允许挂号
                Update 临床出诊序号控制
                Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
                Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) In (0, 2);
                If Sql%NotFound Then
                  Begin
                    Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                  Exception
                    When Others Then
                      n_状态 := -1;
                  End;
                
                  If n_状态 <> -1 Then
                    v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                    Raise Err_Item;
                  End If;
                
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                    Select 出诊记录id_In, n_序号, d_序号时间, d_序号时间, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1), Null,
                           Null, Null, 操作员姓名_In, '追加号'
                    From Dual;
                End If;
              Else
                If Nvl(预约接收_In, 0) = 1 Then
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注, 预约顺序号)
                    Select 记录id, 序号, 开始时间, 终止时间, 1, 1, Decode(预约挂号_In, 1, 2, 1), Null, Null, Null, 操作员姓名_In, n_序号,
                           n_预约顺序号
                    From 临床出诊序号控制
                    Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 Is Null;
                End If;
              End If;
            Else
              If Nvl(n_序号控制, 0) = 1 Then
                Update 临床出诊序号控制
                Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In
                Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 0;
              
                If Sql%Rowcount = 0 Then
                  Begin
                    Select 挂号状态 Into n_状态 From 临床出诊序号控制 Where 记录id = 出诊记录id_In And 序号 = n_序号;
                  Exception
                    When Others Then
                      n_状态 := -1;
                  End;
                  If n_状态 <> -1 Then
                    v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
                    Raise Err_Item;
                  End If;
                  Insert Into 临床出诊序号控制
                    (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 类型, 名称, 操作员姓名, 备注)
                    Select 出诊记录id_In, n_序号, 发生时间_In, 发生时间_In, 1, Decode(预约挂号_In, 1, 1, 0), Decode(预约挂号_In, 1, 2, 1),
                           Null, Null, Null, 操作员姓名_In, '追加号'
                    From Dual;
                
                End If;
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_序号 || '已被其他站点(' || v_机器名 || ')锁定,请重新选择一个序号.';
          Raise Err_Item;
        End If;
        If n_预约顺序号 Is Null Then
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And 工作站名称 = v_机器名;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(预约挂号_In, 1, 2, 1)
          Where 记录id = 出诊记录id_In And 序号 = n_时段序号 And 预约顺序号 = n_预约顺序号 And Nvl(挂号状态, 0) = 5 And 操作员姓名 = 操作员姓名_In And
                工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  End If;


  --产生病人挂号费用(可能单独是或包括病历费用)
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到

  Insert Into 门诊费用记录
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别,
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名,
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
  Values
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In,
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In),
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In),
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In,
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)),
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In,
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In,
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id));

  --汇总结算到病人预交记录
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then
    If Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0 And 序号_In = 1 Then
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
         结算性质)
      Values
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_现金, 0, 登记时间_In, 操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费',
         n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4);
    End If;
    If Nvl(现金支付_In, 0) <> 0 And 序号_In = 1 Then
      v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
      v_结算方式记录 := '';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
      
        v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
        n_三方卡标志 := To_Number(v_当前结算);
      
        If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
          v_Err_Msg := '使用了重复的结算方式,请检查!';
          Raise Err_Item;
        Else
          v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
        End If;
      
        If n_三方卡标志 = 0 Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
        Else
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4,
             v_结算号码);
          If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then
            n_消费卡id := Null;
            Begin
              Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 0 Then
              v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！';
              Raise Err_Item;
            End If;
            If n_自制卡 = 1 Then
              Select ID
              Into n_消费卡id
              From 消费卡目录
              Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And
                    序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In);
            End If;
            Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, Nvl(v_结算方式, v_现金), Nvl(n_结算金额, 0), 卡号_In, Null, 登记时间_In, Null, 结帐id_In,
                              n_预交id);
          End If;
        End If;
      
        If Nvl(更新交款余额_In, 0) = 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + n_结算金额
          Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金)
          Returning 余额 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, Nvl(v_结算方式, v_现金), 1, n_结算金额);
            n_返回值 := n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 人员缴款余额
            Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(v_结算方式, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0;
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
      End Loop;
    End If;
  
    --对于医保挂号
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then
      Insert Into 病人预交记录
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质)
      Values
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In,
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4);
    End If;
  
    --对于就诊卡通过预交金挂号
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then
      n_预交金额 := 预交支付_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        n_当前金额 := Case
                    When r_Deposit.金额 - n_预交金额 < 0 Then
                     r_Deposit.金额
                    Else
                     n_预交金额
                  End;
      
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(填上结帐ID,金额为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id;
        
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号,
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2);
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
      
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If n_预交金额 > 0 Then
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！';
        Raise Err_Item;
      
      End If;
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
    End If;
  
    --相关汇总表的处理
    --人员缴款余额
    If 序号_In = 1 And Nvl(更新交款余额_In, 0) = 0 Then
      If Nvl(个帐支付_In, 0) <> 0 Then
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + 个帐支付_In
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户
        Returning 余额 Into n_返回值;
      
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In);
          n_返回值 := 个帐支付_In;
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --病人挂号汇总(只处理一次,且单独收取病历费不处理)
  If Nvl(预约挂号_In, 0) = 0 Then
    --病人本次就诊(以发生时间为准)
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In;
    End If;
  End If;

  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then
    --记帐
    If Nvl(病人id_In, 0) = 0 Then
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。';
      Raise Err_Item;
    End If;
  
    --病人余额
    Update 病人余额
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0)
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0));
    End If;
  End If;

  --病人挂号记录
  If 号别_In Is Not Null And 序号_In = 1 Then
    --And Nvl(预约挂号_In, 0) = 0
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    Begin
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2;
    Exception
      When Others Then
        v_付款方式 := Null;
    End;
    Insert Into 病人挂号记录
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 出诊记录id, 收费单)
    Values
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In,
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In,
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In,
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null),
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null),
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 出诊记录id_In, 收费单_In);
  
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then
      Update 病人挂号记录
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In
      Where ID = n_挂号id;
    End If;
  
    n_预约生成队列 := 0;
    If Nvl(预约挂号_In, 0) = 1 Then
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
    End If;
  
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113));
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then
          n_分时点显示 := 1;
        Else
          n_分时点显示 := Null;
        End If;
        --产生队列
        --.按”执行部门” 的方式生成队列
        v_队列名称 := 执行部门id_In;
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号);
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In);
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In,
                         n_分时点显示, v_排队序号);
      End If;
    End If;
  End If;
  --病人担保信息
  If 病人id_In Is Not Null And 序号_In = 1 Then
    --取参数:
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then
      --结算模式的确定
    
      v_Err_Msg := Null;
      Begin
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的病人信息,不允许挂号';
      End;
    
      If v_Err_Msg Is Not Null Then
        Raise Err_Item;
      End If;
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据
        Select Count(1)
        Into n_Count
        From 病人未结费用
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2;
        If Nvl(n_Count, 0) <> 0 Then
          --存在未结算数据，必须先结算后才允许执行
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!';
          Raise Err_Item;
        End If;
        --检查
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理)
      End If;
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In;
    End If;
  
    Update 病人信息
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists
     (Select 1
           From 病人担保记录
           Where 病人id = 病人id_In And 主页id Is Not Null And
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In));
  
    If Sql%RowCount > 0 Then
      Update 病人担保记录
      Set 到期时间 = Sysdate
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate;
    End If;
  End If;
  If 序号_In = 1 Then
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人挂号记录_出诊_Insert;
/

--120025:冉俊明,2018-03-16,查询交易状态时，如果在“三方交易记录”中没有查询到记录，则增加查询病人预交记录
Create Or Replace Procedure Zl_Third_Swapstaut
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:读取三方支付的状态
  --入参:Xml_In:
  --<IN>
  --        <JYLB>交易类别</JYLB> //支付宝，微信等
  --        <JYLSH>交易流水号</JYLSH>
  --        <BRID>病人ID</BRID>
  --</IN>
  --出参:Xml_Out
  --  <OUT>
  --    <ZT>状态</ZT>  DD0-交易失败,1-交易成功;2-交易正在进行中;3-不存在该交易记录
  --    <JYSJ>交易时间</JYSJ>  DD当状态为1时才返回,否则为空  格式为'YYYY-MM-DD hh24:mi:ss'
  --    <JYID>业务交易ID</JYID>  DD当状态为1时才返回,否则为空   针对挂号和结帐为结帐ID;针对预交为预交ID;针对收费为结算序号
  --    <YWLX>业务类型</YWLX>   DD null-历史数据;1-预交;2-结帐;3-收费;4-挂号
  --    <DJH>单据号</DJH>  DD 多个用逗号分隔  针对挂号为挂号单据号,针对结帐为结帐单据号,针对预交为预交单据号,针对收费为收费单据号

  --  </OUT>
  --------------------------------------------------------------------------------------------------
  v_Temp    Varchar2(32767); --临时XML
  x_Templet Xmltype; --模板XML

  v_交易类别   三方交易记录.类别%Type;
  v_交易流水号 三方交易记录.流水号%Type;
  n_病人id     病人预交记录.病人id%Type;

  n_Count    Number(18);
  n_交易id   三方交易记录.业务结算id%Type;
  n_业务类型 三方交易记录.业务类型%Type;
  v_Nos      Varchar2(3000);
  d_交易时间 Date;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Nvl(Extractvalue(Value(A), 'IN/JYLB'), '-'), Nvl(Extractvalue(Value(A), 'IN/JYLSH'), '-'),
         Nvl(Extractvalue(Value(A), 'IN/BRID'), 0)
  Into v_交易类别, v_交易流水号, n_病人id
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  Begin
    Select 状态, 交易时间, 业务结算id, 业务类型
    Into n_Count, d_交易时间, n_交易id, n_业务类型
    From 三方交易记录
    Where 类别 = v_交易类别 And 流水号 = v_交易流水号
    For Update Nowait;
    Commit;
  Exception
    When Others Then
      n_Count := -1;
  End;

  If n_Count = -1 Then
    Select Count(1) Into n_Count From 三方交易记录 Where 类别 = v_交易类别 And 流水号 = v_交易流水号;
    If n_Count = 0 Then
      Select Count(1), Max(收款时间), Max(Decode(记录性质, 1, ID, 3, 结算序号, 结帐id)), Max(Mod(记录性质, 10))
      Into n_Count, d_交易时间, n_交易id, n_业务类型
      From 病人预交记录
      Where 记录性质 <> 11 And Nvl(校对标志, 0) <> 1 And 病人id = n_病人id And 交易流水号 = v_交易流水号 And
            卡类别id In (Select ID From 医疗卡类别 Where 名称 = v_交易类别);
      If n_Count = 0 Then
        n_Count := 3;
      Else
        --不存在三方交易记录，但存在病人预交记录，也表示交易成功
        n_Count := 1;
      End If;
    Else
      n_Count := 2;
    End If;
  End If;

  If n_Count = 1 Then
    If n_业务类型 = 1 Then
      Select Max(NO) Into v_Nos From 病人预交记录 Where 记录性质 = 1 And ID = n_交易id;
    Elsif n_业务类型 = 2 Then
      Select Max(NO) Into v_Nos From 病人结帐记录 Where ID = n_交易id;
    Elsif n_业务类型 = 3 Then
      Select f_List2str(Cast(Collect(NO) As t_Strlist))
      Into v_Nos
      From (Select Distinct a.No As NO
             From 门诊费用记录 A, 病人预交记录 B
             Where a.结帐id = b.结帐id And b.结算序号 = n_交易id);
    Elsif n_业务类型 = 4 Then
      Select Max(NO) Into v_Nos From 门诊费用记录 Where 记录性质 = 4 And 结帐id = n_交易id;
    End If;
  End If;

  v_Temp := '<ZT>' || n_Count || '</ZT>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JYSJ>' || To_Char(d_交易时间, 'YYYY-MM-DD hh24:mi:ss') || '</JYSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JYID>' || Nvl(n_交易id, 0) || '</JYID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<YWLX>' || n_业务类型 || '</YWLX>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<DJH>' || Nvl(v_Nos, '') || '</DJH>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Swapstaut;
/

--120507:冉俊明,2018-03-15,接口中误差金额计算错误
Create Or Replace Procedure Zl_Third_Payment
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is

  -------------------------------------------------------------------------------------------------- 
  --功能:三方接口支付 
  --入参:Xml_In: 
  --<IN>
  --        <NO></NO>                       //收费单据号串,逗号分隔多个单据号
  --        <JE></JE>                       //总金额
  --        <BRID>病人ID</BRID>             //病人ID
  --        <XM>姓名</XM>                   //姓名
  --        <SFZH>身份证号</SFZH>           //身份证号
  --        <SFGH></SFGH>                   //是否挂号单
  --        <WCJE>误差额</WCJE>             //误差项不传时,以总金额-本次结算费用总额为准
  --       <JSLIST>
  --         <JS>
  --              <JSKLB>支付卡类别</JSKLB >
  --              <JSKH>支付卡号</ JSKH >
  --              <JSFS>支付方式</JSFS> //支付方式:现金;支票,如果是三方卡,可以传空
  --              <JSJE>支付金额</JSJE>
  --              <JYLSH>交易流水号</JYLSH>
  --              <ZY>摘要</ZY>
  --              <SFCYJ>是否冲预交</SFCYJ>  //允冲预交时,只填JSJE节点:1-冲预交
  --              <SFXFK>是否消费卡</SFXFK>  //(1-是消费卡),消费卡时,传入结算卡类别,结算卡号,结算金额等接点
  --              <EXPENDLIST>  //扩展交易信息
  --                  <EXPEND>
  --                        <JYMC >交易名称</交易名称>
  --                        <JYLR>交易内容</JYLR>
  --                  </EXPEND>
  --              </EXPENDLIST>
  --         </JS>
  --       </JSLIST >
  --</IN>

  --出参:Xml_Out 
  --  <OUT> 
  --    <CZSJ>操作时间</CZSJ>          //HIS的登记时间
  --    <JZID>结帐ID</JZID>          //本次结帐ID
  --    DD如无下列错误结点则说明正确执行 
  --    <ERROR> 
  --      <MSG>错误信息</MSG> 
  --    </ERROR> 
  --  </OUT> 
  -------------------------------------------------------------------------------------------------- 
  v_Nos      Varchar2(4000);
  n_收费总额 门诊费用记录.实收金额%Type;

  n_卡类别id 医疗卡类别.Id%Type;
  v_结算方式 Varchar2(2000);
  n_病人id   门诊费用记录.病人id%Type;
  v_身份证号 病人信息.身份证号%Type;
  v_姓名     门诊费用记录.姓名%Type;
  v_性别     门诊费用记录.性别%Type;
  v_年龄     门诊费用记录.年龄%Type;

  v_医疗付款方式编码 医疗付款方式.编码%Type;
  v_操作员编码       门诊费用记录.操作员编号%Type;
  v_操作员姓名       门诊费用记录.操作员姓名%Type;
  n_结帐id           门诊费用记录.结帐id%Type;
  n_结帐金额         门诊费用记录.结帐金额%Type;
  d_收费时间         病人预交记录.收款时间%Type;
  n_消费卡id         消费卡目录.Id%Type;
  v_收费结算         Varchar2(2000);
  v_普通结算         Varchar2(4000);
  n_是否挂号         Number(3);
  n_预交支付         门诊费用记录.实收金额%Type;
  n_普通支付         门诊费用记录.实收金额%Type;
  v_结算卡号         病人预交记录.卡号%Type;
  n_结算卡序号       病人预交记录.结算卡序号%Type;
  v_交易流水号       病人预交记录.交易流水号%Type;
  v_交易说明         病人预交记录.交易说明%Type;
  v_摘要             病人预交记录.摘要%Type;
  n_科室id           挂号安排.科室id%Type;
  n_项目id           挂号安排.项目id%Type;
  n_医生id           挂号安排.医生id%Type;
  v_医生姓名         挂号安排.医生姓名%Type;
  v_号码             挂号安排.号码%Type;
  n_门诊号           病人信息.门诊号%Type;
  d_发生时间         病人挂号记录.发生时间%Type;
  v_费别             病人信息.费别%Type;
  n_号序             病人挂号记录.号序%Type;
  n_生成队列         Number(3);
  v_Para             Varchar2(500);
  n_挂号模式         Number(3);
  d_启用时间         Date;
  v_临时结算方式     病人预交记录.结算方式%Type;
  n_出诊记录id       临床出诊记录.Id%Type;
  n_序号             门诊费用记录.序号%Type;
  v_附加项目id       Varchar2(500);
  n_实收金额         门诊费用记录.实收金额%Type;
  v_实收             Varchar2(500);
  n_从属父号         门诊费用记录.从属父号%Type;
  n_病人科室id       门诊费用记录.病人科室id%Type;
  n_执行部门id       门诊费用记录.执行部门id%Type;
  v_No               门诊费用记录.No%Type;
  n_医保支付         病人预交记录.冲预交%Type;
  n_Exists           Number;
  v_卡类别           三方交易记录.类别%Type;
  n_业务类型         三方交易记录.业务类型%Type;
  n_结算序号         病人预交记录.结算序号%Type;
  v_Temp             Varchar2(32767); --临时XML 
  x_Templet          Xmltype; --模板XML 

  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  Err_Special Exception;
  n_Count    Number(18);
  v_操作员   门诊费用记录.操作员姓名%Type;
  v_发药窗口 Varchar2(4000);
  n_误差额   病人预交记录.冲预交%Type;

  Function Zl_出诊诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
    n_分诊方式 临床出诊记录.分诊方式%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
    Begin
      Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
    Exception
      When Others Then
        v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
        Raise Err_Item;
    End;
  
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select b.名称 As 门诊诊室, 0 As Num
                          From 临床出诊诊室记录 A, 门诊诊室 B
                          Where a.诊室id = b.Id And a.记录id = 记录id_In
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 出诊记录id = 记录id_In And
                                诊室 In (Select d.名称
                                       From 临床出诊诊室记录 C, 门诊诊室 D
                                       Where c.诊室id = d.Id And c.记录id = 记录id_In)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                   From 临床出诊诊室记录 A, 门诊诊室 B
                   Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
        Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
      End If;
    End If;
    Return v_诊室;
  End;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;
  Procedure Third_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     医疗卡类别.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
    If n_卡类别id = 0 Then
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := 卡类别_In || '不存在!';
      End;
    Else
      Begin
        Select ID, 结算方式, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          n_卡类别id := -1;
          v_Err_Msg  := '未找到指定的结算支付信息!';
      End;
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    v_收费结算 := v_结算方式 || '|' || 支付金额_In || '|' || ' |' || ' ';
    --结算方式|结算金额|结算号码|结算摘要 
    Zl_门诊收费结算_Modify(1, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
  
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 0, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Third_Cardbalance_Modfiy;

  Procedure Square_Cardbalance_Modfiy
  (
    结帐id_In     病人预交记录.结帐id%Type,
    卡类别_In     Varchar2,
    卡号_In       病人预交记录.卡号%Type,
    支付金额_In   病人预交记录.冲预交%Type,
    交易流水号_In 病人预交记录.交易流水号%Type,
    交易说明_In   病人预交记录.交易说明%Type,
    Xmlexpned_In  Xmltype
  ) Is
    n_卡类别id 医疗卡类别.Id%Type;
    v_结算方式 病人预交记录.结算方式%Type;
    v_名称     卡消费接口目录.名称%Type;
  Begin
    v_Err_Msg := Null;
    Begin
      n_卡类别id := To_Number(卡类别_In);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 名称 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '消费:' || 卡类别_In || '不存在!';
      End;
    
    Else
    
      Begin
        Select 编号, 结算方式, Decode(Nvl(启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!'), 名称
        Into n_卡类别id, v_结算方式, v_Err_Msg, v_名称
        From 卡消费接口目录
        Where 编号 = 卡类别_In;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
    If v_结算方式 Is Null Then
      v_Err_Msg := Nvl(v_名称, '') || '未设置结算方式,请在医疗卡类别中设置结算方式';
      Raise Err_Item;
    End If;
  
    Select ID
    Into n_消费卡id
    From 消费卡目录
    Where 接口编号 = n_卡类别id And 卡号 = 卡号_In And
          序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = n_卡类别id And 卡号 = 卡号_In);
  
    --结算方式_IN格式为:卡类别ID|卡号|消费卡ID|消费金额||.... 
    v_收费结算 := n_卡类别id || '|' || 卡号_In || '|' || n_消费卡id || '|' || 支付金额_In;
    Zl_门诊收费结算_Modify(3, n_病人id, 结帐id_In, v_收费结算, 0, 0, n_卡类别id, 卡号_In, 交易流水号_In, 交易说明_In, 0, 0, 0, 0);
    --保存扩展结算信息
    For c_扩展 In (Select Extractvalue(j.Column_Value, '/EXPEND/JYMC') As Jymc,
                        Extractvalue(j.Column_Value, '/EXPEND/JYLR') As Jylr
                 From Table(Xmlsequence(Extract(Xmlexpned_In, '/EXPENDLIST/EXPEND'))) J) Loop
      Zl_三方结算交易_Insert(n_卡类别id, 1, 卡号_In, 结帐id_In, c_扩展.Jymc || '|' || c_扩展.Jylr, 0);
    End Loop;
  End Square_Cardbalance_Modfiy;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/NO'), To_Number(Extractvalue(Value(A), 'IN/BRID')),
         To_Number(Extractvalue(Value(A), 'IN/JE')), To_Number(Extractvalue(Value(A), 'IN/WCJE')),
         To_Number(Extractvalue(Value(A), 'IN/SFGH')), Extractvalue(Value(A), 'IN/SFZH'),
         Extractvalue(Value(A), 'IN/XM')
  Into v_Nos, n_病人id, n_收费总额, n_误差额, n_是否挂号, v_身份证号, v_姓名
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;
  If Nvl(n_病人id, 0) = 0 And Not v_身份证号 Is Null And Not v_姓名 Is Null Then
    n_病人id := Zl_Third_Getpatiid(v_身份证号, v_姓名);
  End If;
  --0.相关检查

  If Nvl(n_病人id, 0) = 0 Then
    v_Err_Msg := '不能有效识别病人身份,不允许缴费!';
    Raise Err_Item;
  
  End If;

  If v_Nos Is Null Then
    v_Err_Msg := '没有指定相关的收费单据,不允许缴费!';
    Raise Err_Item;
  
  End If;

  --人员id,人员编号,人员姓名 
  v_Temp := Zl_Identity(1);
  If Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_' Then
    v_Err_Msg := '系统不能认别有效的操作员,不允许缴费!';
    Raise Err_Item;
  End If;
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员编码 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_操作员姓名 := v_Temp;
  v_Err_Msg    := Null;
  Begin
    Select b.编码, a.姓名, a.性别, a.年龄
    Into v_医疗付款方式编码, v_姓名, v_性别, v_年龄
    From 病人信息 A, 医疗付款方式 B
    Where a.医疗付款方式 = b.名称(+) And a.病人id = n_病人id;
  Exception
    When Others Then
      v_Err_Msg := '指定的缴费单据中不能有效识别病人,不允许缴费!';
  End;
  If Not v_Err_Msg Is Null Then
    Raise Err_Item;
  End If;

  Select Decode(Nvl(n_是否挂号, 0), 0, 3, 4) Into n_业务类型 From Dual;

  For c_交易记录 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                        Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                        Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                        Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要
                 From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
  
    If c_交易记录.结算卡类别 Is Null Then
      v_卡类别 := c_交易记录.结算方式;
    Else
      Select Decode(Translate(Nvl(c_交易记录.结算卡类别, 'abcd'), '#1234567890', '#'), Null, 1, 0)
      Into n_Count
      From Dual;
    
      If Nvl(n_Count, 0) = 1 Then
        Select Max(名称) Into v_卡类别 From 医疗卡类别 Where ID = To_Number(c_交易记录.结算卡类别);
      Else
        Select Max(名称) Into v_卡类别 From 医疗卡类别 Where 名称 = c_交易记录.结算卡类别;
      End If;
    End If;
    If v_卡类别 Is Null Then
      v_Err_Msg := '不支持的结算方式,请检查！';
      Raise Err_Item;
    End If;
  
    If Zl_Fun_三方交易记录_Locked(v_卡类别, c_交易记录.交易流水号, c_交易记录.结算卡号, c_交易记录.摘要, n_业务类型) = 0 Then
      v_Err_Msg := '交易流水号为:' || c_交易记录.交易流水号 || '的交易正在进行中，不允许再次提交此交易!';
      Raise Err_Special;
    End If;
  End Loop;

  Select 病人结帐记录_Id.Nextval, Sysdate Into n_结帐id, d_收费时间 From Dual;
  n_结算序号 := -1 * n_结帐id;

  If Nvl(n_是否挂号, 0) = 0 Then
    --费用单据
    v_发药窗口 := Zl_Getclinicchargepaywins(v_Nos);
  
    --1.进行费用收费处理
    --获取发药窗口
  
    n_结帐金额 := 0;
    For c_缴费单 In (Select /*+ rule */
                   a.No, Max(a.开单部门id) As 开单部门id, Max(a.病人科室id) As 病人科室id, Max(a.病人id) As 病人id, Sum(实收金额) As 实收金额,
                   Max(a.开单人) As 开单人
                  From 门诊费用记录 A, Table(f_Str2list(v_Nos)) J
                  Where a.记录性质 = 1 And a.No = j.Column_Value And a.记录状态 = 0
                  Group By a.No) Loop
      If Nvl(c_缴费单.病人id, 0) <> n_病人id Then
        v_Err_Msg := '缴费单据:' || c_缴费单.No || '与当前病人身份不符,不允许缴费!';
        Raise Err_Item;
      End If;
    
      n_结帐金额 := n_结帐金额 + Nvl(c_缴费单.实收金额, 0);
      Zl_病人划价收费_Insert(c_缴费单.No, n_病人id, 1, v_医疗付款方式编码, v_姓名, v_性别, v_年龄, c_缴费单.病人科室id, c_缴费单.开单部门id, c_缴费单.开单人, n_结帐id,
                       d_收费时间, v_操作员编码, v_操作员姓名, v_发药窗口, 0, d_收费时间);
    
    End Loop;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_结帐金额, 0) - Nvl(n_收费总额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) <> Nvl(n_收费总额, 0) + Nvl(n_误差额, 0) Then
      v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
      Raise Err_Item;
    End If;
  
    --2.确定支付方式
    n_Count := 0;
    For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                          Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                          Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                          Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                          Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                          Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明, Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                          Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                          Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡,
                          Extract(b.Column_Value, '/JS/EXPENDLIST') As Expend
                   From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
    
      --1.三方卡结算
    
      If c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 0 Then
        --1.三方卡结算
        Third_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                 c_结算方式.Expend);
      Elsif c_结算方式.结算卡类别 Is Not Null And Nvl(c_结算方式.是否消费卡, 0) = 1 Then
        --2.消费卡结算
        Square_Cardbalance_Modfiy(n_结帐id, c_结算方式.结算卡类别, c_结算方式.结算卡号, c_结算方式.结算金额, c_结算方式.交易流水号, c_结算方式.交易说明,
                                  c_结算方式.Expend);
      Elsif Nvl(c_结算方式.是否冲预交, 0) = 1 Then
        --3.冲预交款
        Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, Null, c_结算方式.结算金额, 0, Null, Null, Null, Null, 0, 0, 0, 0);
      Else
        --4.普通结算
        If c_结算方式.结算方式 Is Null Then
          v_Err_Msg := '未指定指付方式，不允缴款!';
          Raise Err_Item;
        End If;
        --结算方式|结算金额|结算号码|结算摘要||..
        v_收费结算 := c_结算方式.结算方式 || '|' || c_结算方式.结算金额 || '| | ';
        v_普通结算 := Nvl(v_普通结算, '') || '||' || v_收费结算;
      End If;
    
      If c_结算方式.结算卡类别 Is Null Then
        v_卡类别 := c_结算方式.结算方式;
      Else
        Select Decode(Translate(Nvl(c_结算方式.结算卡类别, 'abcd'), '#1234567890', '#'), Null, 1, 0)
        Into n_Count
        From Dual;
      
        If Nvl(n_Count, 0) = 1 Then
          Select Max(名称) Into v_卡类别 From 医疗卡类别 Where ID = To_Number(c_结算方式.结算卡类别);
        Else
          Select Max(名称) Into v_卡类别 From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别;
        End If;
      End If;
    
      Update 三方交易记录
      Set 业务结算id = n_结算序号
      Where 流水号 = c_结算方式.交易流水号 And 类别 = v_卡类别 And 业务类型 = n_业务类型;
      n_Count := n_Count + 1;
    End Loop;
    If n_Count = 0 Then
      v_Err_Msg := '不能有效确认当前的支付方式!';
      Raise Err_Item;
    End If;
    --5.普通结算及完成结
    If v_普通结算 Is Not Null Then
      v_普通结算 := Substr(v_普通结算, 3);
    End If;
    Zl_门诊收费结算_Modify(0, n_病人id, n_结帐id, v_普通结算, Null, 0, Null, Null, Null, Null, 0, 0, n_误差额, 1);
  Else
    n_结帐金额 := 0;
    --挂号单据
    v_Para     := zl_GetSysParameter(256);
    n_挂号模式 := Substr(v_Para, 1, 1);
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
    For c_费用 In (Select 1 As 顺序号, b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收费类别, b.收入项目id, b.附加标志,
                        To_Char(b.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, b.价格父号, b.从属父号, b.序号, b.收费细目id, b.计算单位,
                        Max(m.名称) As 名称, Max(m.规格) As 规格, Sum(b.标准单价) As 单价, Avg(Nvl(b.付数, 1) * b.数次) As 数量,
                        Sum(b.应收金额) As 应收金额, Sum(b.实收金额) As 实收金额, Max(j.名称) As 开单科室, Max(q.名称) As 执行科室
                 From 门诊费用记录 B, 收费项目目录 M, 部门表 J, 部门表 Q
                 Where b.No = v_Nos And b.记录性质 = 4 And Nvl(b.费用状态, 0) = 0 And b.记录状态 = 0 And b.收费细目id = m.Id And
                       b.开单部门id = j.Id(+) And b.执行部门id = q.Id(+)
                 Group By b.No, b.收据费目, b.结帐id, b.执行部门id, b.病人科室id, b.开单人, b.收入项目id, b.收费类别, b.登记时间, b.价格父号, b.从属父号, b.序号,
                          b.收费细目id, b.计算单位, b.附加标志
                 Order By 序号) Loop
      Zl_病人预约挂号记录_Update(c_费用.No, c_费用.序号, c_费用.价格父号, c_费用.从属父号, c_费用.收费类别, c_费用.收费细目id, c_费用.数量, c_费用.单价, c_费用.收入项目id,
                         c_费用.收据费目, c_费用.应收金额, c_费用.实收金额, c_费用.附加标志, Null, Null, Null, Null, c_费用.病人科室id, c_费用.执行部门id);
      n_结帐金额   := n_结帐金额 + c_费用.实收金额;
      n_序号       := c_费用.序号;
      n_病人科室id := c_费用.病人科室id;
      n_执行部门id := c_费用.执行部门id;
      v_No         := c_费用.No;
    End Loop;
  
    Select a.执行部门id, a.收费细目id, c.Id, a.执行人, b.号别, b.门诊号, b.发生时间, a.费别, b.号序, b.出诊记录id
    Into n_科室id, n_项目id, n_医生id, v_医生姓名, v_号码, n_门诊号, d_发生时间, v_费别, n_号序, n_出诊记录id
    From 门诊费用记录 A, 病人挂号记录 B, 人员表 C
    Where a.No = v_Nos And a.记录性质 = 4 And a.序号 = 1 And a.No = b.No And a.执行人 = c.姓名(+);
  
    Begin
      Select Zl_Fun_Customregexpenses(n_病人id, 0, v_号码) Into v_附加项目id From Dual;
    Exception
      When Others Then
        v_附加项目id := Null;
    End;
    If v_附加项目id Is Not Null Then
      For c_附加项目 In (Select /*+cardinality(D,10)*/
                      5 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次, c.Id As 收入项目id,
                      c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, Table(f_Str2list(v_附加项目id)) D
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.Column_Value And Sysdate Between b.执行日期 And
                           Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                     Union All
                     Select /*+cardinality(E,10)*/
                      6 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                      c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, -1 As 执行科室类型
                     From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D, Table(f_Str2list(v_附加项目id)) E
                     Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And d.主项id = e.Column_Value And
                           Sysdate Between b.执行日期 And Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
        n_序号 := n_序号 + 1;
        If c_附加项目.性质 = 5 Then
          n_从属父号 := n_序号;
        End If;
      
        v_实收     := Zl_Actualmoney(v_费别, c_附加项目.项目id, c_附加项目.收入项目id, c_附加项目.数次 * c_附加项目.单价);
        n_实收金额 := To_Number(Substr(v_实收, Instr(v_实收, ':') + 1));
      
        If c_附加项目.性质 = 5 Then
          Zl_病人预约挂号记录_Update(v_No, n_序号, Null, Null, c_附加项目.类别, c_附加项目.项目id, c_附加项目.数次, c_附加项目.单价, c_附加项目.收入项目id,
                             c_附加项目.收据费目, c_附加项目.数次 * c_附加项目.单价, n_实收金额, Null, Null, Null, Null, Null, n_病人科室id,
                             n_执行部门id);
        Else
          Zl_病人预约挂号记录_Update(v_No, n_序号, Null, n_从属父号, c_附加项目.类别, c_附加项目.项目id, c_附加项目.数次, c_附加项目.单价, c_附加项目.收入项目id,
                             c_附加项目.收据费目, c_附加项目.数次 * c_附加项目.单价, n_实收金额, Null, Null, Null, Null, Null, n_病人科室id,
                             n_执行部门id);
        End If;
        n_结帐金额 := n_结帐金额 + n_实收金额;
      
      End Loop;
    End If;
  
    --检查总金额是否正确 
    If Nvl(n_误差额, 0) = 0 Then
      n_误差额 := Nvl(n_结帐金额, 0) - Nvl(n_收费总额, 0);
      If Abs(n_误差额) > 1.00 Then
        v_Err_Msg := '单据缴款金额与实际结算的误差太大!';
        Raise Err_Item;
      End If;
    End If;
    If Nvl(n_结帐金额, 0) <> Nvl(n_收费总额, 0) + Nvl(n_误差额, 0) Then
      Select Max(操作员姓名) Into v_操作员 From 门诊费用记录 Where 记录性质 = 4 And NO = v_Nos;
      If v_操作员 = v_操作员姓名 Then
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Special;
      Else
        v_Err_Msg := '指定的缴费单据的总金额不对,请重新选择缴费单据!';
        Raise Err_Item;
      End If;
    End If;
  
    --预约接收
    If n_挂号模式 = 1 Then
      If d_启用时间 > d_发生时间 And n_出诊记录id Is Null Then
        n_挂号模式 := 0;
      End If;
    End If;
  
    Select Decode(To_Number(zl_GetSysParameter('排队叫号模式', 1113, 100)), 0, 0, 1) Into n_生成队列 From Dual;
    If n_挂号模式 = 0 Then
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          If c_结算方式.结算方式 Is Not Null Then
            Select Nvl(Max(1), 0) Into n_Exists From 结算方式 Where 名称 = c_结算方式.结算方式 And 性质 In (3, 4);
            If n_Exists = 1 Then
              n_医保支付 := c_结算方式.结算金额;
            Else
              If Nvl(n_普通支付, 0) = 0 Then
                n_普通支付 := c_结算方式.结算金额;
                v_结算方式 := c_结算方式.结算方式;
                If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                  Begin
                    n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_结算卡序号 := 0;
                  End;
                  If n_结算卡序号 = 0 Then
                    Begin
                      Select 编号
                      Into n_结算卡序号
                      From 卡消费接口目录
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的消费卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                  End If;
                Else
                  Begin
                    n_卡类别id := To_Number(c_结算方式.结算卡类别);
                  Exception
                    When Others Then
                      n_卡类别id := 0;
                  End;
                  If n_卡类别id = 0 Then
                    Begin
                      Select ID
                      Into n_卡类别id
                      From 医疗卡类别
                      Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                    Exception
                      When Others Then
                        v_Err_Msg := '未找到对应的医疗卡!';
                        Raise Err_Item;
                    End;
                  End If;
                  If v_结算方式 Is Null Then
                    Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                  End If;
                End If;
                v_结算卡号   := c_结算方式.结算卡号;
                v_交易流水号 := c_结算方式.交易流水号;
                v_交易说明   := c_结算方式.交易说明;
                v_摘要       := c_结算方式.摘要;
              Else
                v_Err_Msg := '挂号结算暂不支持多种结算方式!';
                Raise Err_Item;
              End If;
            End If;
          Else
            If Nvl(n_普通支付, 0) = 0 Then
              n_普通支付 := c_结算方式.结算金额;
              v_结算方式 := c_结算方式.结算方式;
              If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
                Begin
                  n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_结算卡序号 := 0;
                End;
                If n_结算卡序号 = 0 Then
                  Begin
                    Select 编号
                    Into n_结算卡序号
                    From 卡消费接口目录
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的消费卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
                End If;
              Else
                Begin
                  n_卡类别id := To_Number(c_结算方式.结算卡类别);
                Exception
                  When Others Then
                    n_卡类别id := 0;
                End;
                If n_卡类别id = 0 Then
                  Begin
                    Select ID
                    Into n_卡类别id
                    From 医疗卡类别
                    Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                  Exception
                    When Others Then
                      v_Err_Msg := '未找到对应的医疗卡!';
                      Raise Err_Item;
                  End;
                End If;
                If v_结算方式 Is Null Then
                  Select 结算方式 Into v_结算方式 From 医疗卡类别 Where ID = n_卡类别id;
                End If;
              End If;
              v_结算卡号   := c_结算方式.结算卡号;
              v_交易流水号 := c_结算方式.交易流水号;
              v_交易说明   := c_结算方式.交易说明;
              v_摘要       := c_结算方式.摘要;
            Else
              v_Err_Msg := '挂号结算暂不支持多种结算方式!';
              Raise Err_Item;
            End If;
          End If;
        End If;
        If c_结算方式.结算卡类别 Is Null Then
          v_卡类别 := c_结算方式.结算方式;
        Else
          Select Decode(Translate(Nvl(c_结算方式.结算卡类别, 'abcd'), '#1234567890', '#'), Null, 1, 0)
          Into n_Count
          From Dual;
        
          If Nvl(n_Count, 0) = 1 Then
            Select Max(名称) Into v_卡类别 From 医疗卡类别 Where ID = To_Number(c_结算方式.结算卡类别);
          Else
            Select Max(名称) Into v_卡类别 From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别;
          End If;
        End If;
        Update 三方交易记录
        Set 业务结算id = n_结帐id
        Where 流水号 = c_结算方式.交易流水号 And 类别 = v_卡类别 And 业务类型 = n_业务类型;
      End Loop;
      Zl_预约挂号接收_Insert(v_Nos, Null, Null, n_结帐id, Zl_诊室(v_号码), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码, v_费别,
                       v_结算方式, n_普通支付, n_预交支付, n_医保支付, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id, n_结算卡序号,
                       v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    Else
      For c_结算方式 In (Select Extractvalue(b.Column_Value, '/JS/JSKLB') As 结算卡类别,
                            Extractvalue(b.Column_Value, '/JS/JSKH') As 结算卡号,
                            Extractvalue(b.Column_Value, '/JS/JSFS') As 结算方式,
                            Extractvalue(b.Column_Value, '/JS/JSJE') As 结算金额,
                            Extractvalue(b.Column_Value, '/JS/JYLSH') As 交易流水号,
                            Extractvalue(b.Column_Value, '/JS/JYSM') As 交易说明,
                            Extractvalue(b.Column_Value, '/JS/ZY') As 摘要,
                            Extractvalue(b.Column_Value, '/JS/SFCYJ') As 是否冲预交,
                            Extractvalue(b.Column_Value, '/JS/SFXFK') As 是否消费卡
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS'))) B) Loop
        If Nvl(c_结算方式.是否冲预交, 0) = 1 Then
          n_预交支付 := c_结算方式.结算金额;
        Else
          n_普通支付 := Nvl(n_普通支付, 0) + c_结算方式.结算金额;
          If c_结算方式.结算方式 Is Null Then
            --三方卡结算方式
            If Nvl(c_结算方式.是否消费卡, 0) = 1 Then
              Begin
                n_结算卡序号 := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_结算卡序号 := 0;
              End;
              If n_结算卡序号 = 0 Then
                Begin
                  Select 编号
                  Into n_结算卡序号
                  From 卡消费接口目录
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的消费卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 卡消费接口目录 Where 编号 = n_结算卡序号;
            Else
              Begin
                n_卡类别id := To_Number(c_结算方式.结算卡类别);
              Exception
                When Others Then
                  n_卡类别id := 0;
              End;
              If n_卡类别id = 0 Then
                Begin
                  Select ID
                  Into n_卡类别id
                  From 医疗卡类别
                  Where 名称 = c_结算方式.结算卡类别 And Nvl(是否启用, 0) = 1;
                Exception
                  When Others Then
                    v_Err_Msg := '未找到对应的医疗卡!';
                    Raise Err_Item;
                End;
              End If;
              Select 结算方式 Into v_临时结算方式 From 医疗卡类别 Where ID = n_卡类别id;
            End If;
            v_结算卡号   := c_结算方式.结算卡号;
            v_交易流水号 := c_结算方式.交易流水号;
            v_交易说明   := c_结算方式.交易说明;
            v_摘要       := c_结算方式.摘要;
            v_结算方式   := v_结算方式 || '|' || v_临时结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          Else
            --其他结算方式
            v_结算方式 := v_结算方式 || '|' || c_结算方式.结算方式 || ',' || c_结算方式.结算金额 || ',,1';
          End If;
        End If;
        If c_结算方式.结算卡类别 Is Null Then
          v_卡类别 := c_结算方式.结算方式;
        Else
          Select Decode(Translate(Nvl(c_结算方式.结算卡类别, 'abcd'), '#1234567890', '#'), Null, 1, 0)
          Into n_Count
          From Dual;
        
          If Nvl(n_Count, 0) = 1 Then
            Select Max(名称) Into v_卡类别 From 医疗卡类别 Where ID = To_Number(c_结算方式.结算卡类别);
          Else
            Select Max(名称) Into v_卡类别 From 医疗卡类别 Where 名称 = c_结算方式.结算卡类别;
          End If;
        End If;
        Update 三方交易记录
        Set 业务结算id = n_结帐id
        Where 流水号 = c_结算方式.交易流水号 And 类别 = v_卡类别 And 业务类型 = n_业务类型;
      End Loop;
      If v_结算方式 Is Not Null Then
        v_结算方式 := Substr(v_结算方式, 2);
      End If;
      Zl_预约挂号接收_出诊_Insert(v_Nos, Null, Null, n_结帐id, Zl_出诊诊室(n_出诊记录id), n_病人id, n_门诊号, v_姓名, v_性别, v_年龄, v_医疗付款方式编码,
                          v_费别, v_结算方式, n_普通支付, n_预交支付, Null, d_发生时间, n_号序, v_操作员编码, v_操作员姓名, n_生成队列, d_收费时间, n_卡类别id,
                          n_结算卡序号, v_结算卡号, v_交易流水号, v_交易说明, Null, 0, 0, Null, 1);
    End If;
    --处理扩展信息
    If Nvl(n_卡类别id, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_卡类别id, 0, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    If Nvl(n_结算卡序号, 0) <> 0 Then
      For c_扩展信息 In (Select Extractvalue(b.Column_Value, '/EXPEND/JYMC') As 交易名称,
                            Extractvalue(b.Column_Value, '/EXPEND/JYLR') As 交易内容
                     From Table(Xmlsequence(Extract(Xml_In, '/IN/JSLIST/JS/EXPENDLIST/EXPEND'))) B) Loop
        Zl_三方结算交易_Insert(n_结算卡序号, 1, v_结算卡号, n_结帐id, c_扩展信息.交易名称 || '|' || c_扩展信息.交易内容, 0);
      End Loop;
    End If;
    --处理汇总
    Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, d_发生时间, 2, v_号码, 1, n_出诊记录id);
  End If;
  v_Temp := '<CZSJ>' || To_Char(d_收费时间, 'YYYY-MM-DD hh24:mi:ss') || '</CZSJ>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  v_Temp := '<JZID>' || n_结帐id || '</JZID>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Err_Special Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20105, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Payment;
/

--104255:胡俊勇,2018-03-14,排队号状态调整
Create Or Replace Procedure Zl_病人接诊
(
  病人id_In     病人信息.病人id%Type,
  No_In         病人挂号记录.No%Type,
  执行部门id_In 病人挂号记录.执行部门id%Type,
  执行人_In     病人挂号记录.执行人%Type,
  诊室_In       病人挂号记录.诊室%Type := Null,
  标记急诊_In   病人挂号记录.急诊%Type := 0,
  回诊_In       Integer := 0,
  接收时间_In   病人挂号记录.接收时间%Type := Null
  --参数： 
  --    执行部门id_In：用于续诊时，确定与原挂号科室不同的续诊执行科室;正常接诊时传入空 
  --    标记急诊_in:强制续诊时，是否将挂号单标记为急诊(不改变费用) 
  --    回诊_In:0-非回诊就诊;1-回诊就诊 
) As
  d_Cur        Date;
  n_执行部门id 病人挂号记录.执行部门id%Type;
  v_诊室       病人挂号记录.诊室%Type;
  v_医生       病人挂号记录.执行人%Type;
  n_挂号id     病人挂号记录.Id%Type;
Begin
  If 接收时间_In Is Null Then
    d_Cur := Sysdate;
  Else
    d_Cur := 接收时间_In;
  End If;

  If 执行部门id_In Is Null Then
    --正常接诊 
    Update 病人信息 Set 就诊时间 = d_Cur, 就诊状态 = 2 Where 病人id = 病人id_In;
  
    Update 门诊费用记录
    Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
    Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
  
    Update 病人挂号记录
    Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  
  Elsif Nvl(回诊_In, 0) = 1 Then
    --回诊就诊 
    --1.检查是否科室;医生;诊室发生了改变的 
    Select ID, 执行部门id, 执行人, 诊室
    Into n_挂号id, n_执行部门id, v_医生, v_诊室
    From 病人挂号记录
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1 And Rownum <= 1;
  
    If n_执行部门id = 执行部门id_In Then
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行时间 = Sysdate, 诊室 = 诊室_In, 记录标志 = 0
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    
      Update 门诊费用记录
      Set 执行人 = 执行人_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
      Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
    
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行时间 = d_Cur, 诊室 = 诊室_In, 记录标志 = 0, 急诊 = Decode(标记急诊_In, 1, 1, 急诊)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    
    Else
      Insert Into 病人转诊记录
        (挂号id, NO, 申请科室id, 申请医生, 接收科室id, 接收医生, 接收时间)
        Select ID, No_In, 执行部门id, 执行人, 执行部门id_In, 执行人_In, d_Cur From 病人挂号记录 Where NO = No_In;
    
      Update 门诊费用记录
      Set 执行人 = 执行人_In, 病人科室id = 执行部门id_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
      Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
    
      Update 病人挂号记录
      Set 执行人 = 执行人_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0,
          急诊 = Decode(标记急诊_In, 1, 1, 急诊)
      Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
    End If;
  Else
    --强制接诊 
    Insert Into 病人转诊记录
      (挂号id, NO, 申请科室id, 申请医生, 接收科室id, 接收医生, 接收时间)
      Select ID, No_In, 执行部门id, 执行人, 执行部门id_In, 执行人_In, d_Cur From 病人挂号记录 Where NO = No_In;
  
    Update 病人信息 Set 就诊时间 = d_Cur, 就诊状态 = 2 Where 病人id = 病人id_In;
  
    Update 门诊费用记录
    Set 执行人 = 执行人_In, 病人科室id = 执行部门id_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 发药窗口 = 诊室_In
    Where NO = No_In And 记录性质 = 4 And 记录状态 In (1, 3);
  
    Update 病人挂号记录
    Set 执行人 = 执行人_In, 执行部门id = 执行部门id_In, 执行状态 = 2, 执行时间 = d_Cur, 诊室 = 诊室_In, 续诊科室id = 执行部门id_In, 记录标志 = 0,
        急诊 = Decode(标记急诊_In, 1, 1, 急诊)
    Where NO = No_In And 记录性质 = 1 And 记录状态 = 1;
  End If;
  --接诊后,排队叫号更新为接诊
  Update 排队叫号队列
  Set 排队状态 = 8, 回诊序号 = Null
  Where 业务类型 = 0 And 业务id = (Select ID From 病人挂号记录 Where NO = No_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人接诊;
/

--102705:焦博,2018-03-14,调整zl_挂号安排_AutoUpdate,使其正确更新实际生效时间
CREATE OR REPLACE Procedure Zl_挂号安排_Autoupdate Is
  Err_Item Exception;
  v_Date Date;
  -- v_Err_Msg Varchar2(100); 
  v_Unitscount Number;
Begin
  --n_更新执行人 ：是否更新病人挂号记录 和门诊费用记录中的执行人 
  --               如果计划中更改了 挂号项目 则不允许更新 病人挂号记录和门诊费用记录中的数据 
  Select Sysdate Into v_Date From Dual;
  Select Count(0) Into v_Unitscount From 合作单位安排控制 Where Rownum = 1;

  For v_生效 In (Select ID, 安排id, 号码, 生效时间, 失效时间, 周日, 周一, 周二, 周三, 周四, 周五, 周六, 分诊方式, 序号控制, 执行时间 As 上次生效时间, 项目id, 医生姓名, 医生id,
                      序号, 科室id, 是否相同
               From (Select a.Id, a.安排id, a.号码, a.生效时间, a.失效时间, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                             b.执行时间, a.项目id, a.医生姓名, a.医生id, Nvl(b.执行计划id, 0) As 执行计划id,
                             Row_Number() Over(Partition By a.安排id Order By a.生效时间 Desc) As 顺序号, b.序号, b.科室id,
                             Case
                               When b.项目id = a.项目id And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
                                    Nvl(a.医生姓名, '-') = Nvl(b.医生姓名, '-') Then
                                1
                               Else
                                0
                             End As 是否相同
                      From 挂号安排计划 A, 挂号安排 B
                      Where Sysdate Between a.生效时间 And a.失效时间 And a.安排id = b.Id And
                            a.实际生效 >= To_Date('3000-01-01', 'yyyy-mm-dd') And a.生效时间 + 0 <= Sysdate And 审核人 Is Not Null And
                            b.停用日期 Is Null)
               Where 顺序号 = 1 And ID <> Nvl(执行计划id, 0)) Loop
    Update 挂号安排计划 Set 实际生效 = v_生效.上次生效时间 Where 安排id = v_生效.安排id And 失效时间 < v_生效.失效时间;
  
    Update 挂号安排
    Set 周日 = v_生效.周日, 周一 = v_生效.周一, 周二 = v_生效.周二, 周三 = v_生效.周三, 周四 = v_生效.周四, 周五 = v_生效.周五, 周六 = v_生效.周六,
        分诊方式 = v_生效.分诊方式, 序号控制 = v_生效.序号控制, 开始时间 = Sysdate, 终止时间 = v_生效.失效时间, 项目id = Nvl(v_生效.项目id, 项目id), 执行时间 = v_Date,
        执行计划id = v_生效.Id, 序号 = Decode(v_生效.是否相同, 1, 序号, 9999999), 医生姓名 = v_生效.医生姓名, 医生id = v_生效.医生id
    Where ID = v_生效.安排id;
  
    --重新调整序号 
    If Nvl(v_生效.是否相同, 0) <> 1 Then
    
      Update 挂号安排 A
      Set 序号 = -1 * 序号
      Where 项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
            Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0);
      For v_序号 In (Select a.Id, Rownum As 序号
                   From 挂号安排 A
                   Where a.项目id = v_生效.项目id And a.科室id = v_生效.科室id And Nvl(a.医生姓名, '-') = Nvl(v_生效.医生姓名, '-') And
                         Nvl(a.医生id, 0) = Nvl(v_生效.医生id, 0)
                   Order By a.Id) Loop
        Update 挂号安排 A Set 序号 = v_序号.序号 Where ID = v_序号.Id;
      End Loop;
    End If;
    Delete 挂号安排诊室 Where 号表id = v_生效.安排id;
    Insert Into 挂号安排诊室
      (号表id, 门诊诊室)
      Select v_生效.安排id, 门诊诊室 From 挂号计划诊室 Where 计划id = v_生效.Id;
    Delete 挂号安排限制 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排限制
      (安排id, 限制项目, 限号数, 限约数)
      Select v_生效.安排id, 限制项目, 限号数, 限约数 From 挂号计划限制 Where 计划id = v_生效.Id;
    Delete 挂号安排时段 Where 安排id = v_生效.安排id;
    Insert Into 挂号安排时段
      (安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期)
      Select v_生效.安排id, 序号, 开始时间, 结束时间, 限制数量, 是否预约, 星期
      From 挂号计划时段
      Where 计划id = v_生效.Id;
    If Nvl(v_Unitscount, 0) > 0 Then
      Delete 合作单位安排控制 Where 安排id = v_生效.安排id;
      Insert Into 合作单位安排控制
        (安排id, 合作单位, 限制项目, 序号, 数量)
        Select v_生效.安排id, 合作单位, 限制项目, 序号, 数量 From 合作单位计划控制 Where 计划id = v_生效.Id;
    End If;
  End Loop;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_挂号安排_Autoupdate;
/

--118124:李南春,2018-03-14,根据病人信息获取卡费
CREATE OR REPLACE Function Zl1_Ex_CardFee
(
  模块号_In     In Zlparameters.模块%Type,
  卡类别ID_In   In 医疗卡类别.ID%Type,
  卡号_In       In 病人医疗卡信息.卡号%Type,
  病人ID_In     In 病人信息.病人ID%Type,
  姓名_In       In 病人信息.姓名%Type:= Null,
  性别_In       In 病人信息.性别%Type:= Null,
  年龄_In       In 病人信息.年龄%Type:= Null,
  身份证号_In   In 病人信息.身份证号%Type:= Null,
  收费细目ID_In In 收费项目目录.ID%Type:= Null
) Return Number
--功能说明：根据病人及发卡类别返回本次应收的卡费。
  --适用说明：根据病人多次办卡时，每次收取不同的费用。
  --入参说明：
  --     模块号_In：区分是哪个模块发卡
  --     卡类别ID_In：发卡类别
  --     卡号_In：发卡卡号
  --     病人ID_In：建档病人ID
  --函数返回：
  --     收费细目ID
is
Begin
  Return 收费细目ID_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl1_Ex_CardFee;
/

--119442:廖思奇,2018-03-13,签名后都会更新报告完成时间
Create Or Replace Procedure Zl_影像报告签名_保存
(
  报告文件id_In In 电子病历内容.文件id%Type,
  开始版_In     In 电子病历内容.开始版%Type,
  终止版_In     In 电子病历内容.终止版%Type,
  对象属性_In   In 电子病历内容.对象属性%Type,
  姓名_In       In 电子病历内容.内容文本%Type,
  前置文字_In   In 电子病历内容.要素名称%Type,
  时间戳_In     In 电子病历内容.要素单位%Type,
  签名级别_In   In 电子病历内容.要素表示%Type,
  签名信息_In   In 电子病历内容.要素值域%Type
) Is
  n_Nextid   电子病历内容.Id%Type;
  n_序号     电子病历内容.对象序号%Type;
  n_对象标记 电子病历内容.对象标记%Type;
Begin
  Select Max(对象序号) + 1 Into n_序号 From 电子病历内容 Where 文件id = 报告文件id_In;
  Select Nvl(Max(对象标记), 0) + 1 Into n_对象标记 From 电子病历内容 Where 文件id = 报告文件id_In And 对象类型 = 8;

  Select 电子病历内容_Id.Nextval Into n_Nextid From Dual;
  Insert Into 电子病历内容
    (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 定义提纲id, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
     要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域)
  Values
    (n_Nextid, 报告文件id_In, 开始版_In, 终止版_In, Null, n_序号, 8, n_对象标记, 1, 对象属性_In, Null, 姓名_In, 0, Null, Null, Null, Null,
     Null, Null, 前置文字_In, 1, 50, 0, 时间戳_In, 签名级别_In, 0, 签名信息_In);
  Update 电子病历记录 Set 完成时间 = Sysdate, 签名级别 = 签名级别_In Where ID = 报告文件id_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像报告签名_保存;
/

--119801:廖思奇,2018-03-13,pacs费用执行 处理全部科室情况
--119801:廖思奇,2018-03-19,脚本审核问题处理
--119801:廖思奇,2018-03-19,去掉上次新增的参数
Create Or Replace Procedure Zl_影像检查_状态更新
(
  医嘱id_In      影像检查记录.医嘱id%Type,
  发送号_In      影像检查记录.发送号%Type,
  报告id_In      影像报告记录.Id%Type,
  执行过程_In    病人医嘱发送.执行过程%Type,
  删除报告_In    Number := 0, --1删除报告，无报告完成 
  操作员编号_In  人员表.编号%Type := Null,
  操作员姓名_In  人员表.姓名%Type := Null,
  执行部门id_In  门诊费用记录.执行部门id%Type := Null,
  完成时间_In    病人医嘱发送.完成时间%Type := Null
) Is
  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_部门id   部门表.Id%Type;
  v_完成人   人员表.姓名%Type;
  v_完成时间 Date;
Begin
  --取得报告完成人和时间 
  If 执行过程_In = 6 Then
    v_完成人   := 操作员姓名_In;
    v_完成时间 := 完成时间_In;
  End If;

  

  If 删除报告_In <> 0 Then
    Delete 影像报告记录 Where 医嘱id = 医嘱id_In;
    Zl_影像报告标记_Clear(医嘱id_In);
  End If;

  Update 病人医嘱发送
  Set 执行状态 = Decode(执行过程_In, 6, 1, 3), 执行过程 = 执行过程_In, 完成人 = v_完成人, 完成时间 = v_完成时间, 采样时间 = Sysdate
  Where 发送号 + 0 = 发送号_In And 医嘱id In (Select ID From 病人医嘱记录 Where (ID = 医嘱id_In Or 相关id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In || ',' || 报告id_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
    --取当前操作人员 
    If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
      v_人员编号 := 操作员编号_In;
      v_人员姓名 := 操作员姓名_In;
      n_部门id   := 执行部门id_In;
    Else
      v_Temp     := Zl_Identity;
      n_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End If;

    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用 
    Zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In, 0, v_人员编号, v_人员姓名, n_部门id);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_状态更新;
/

--119801:廖思奇,2018-03-13,pacs费用执行 处理全部科室情况
--119801:廖思奇,2018-03-19,脚本审核问题处理
--119801:廖思奇,2018-03-19,去掉上次新增的参数
Create Or Replace Procedure Zl_影像检查_State
(
  医嘱id_In      影像检查记录.医嘱id%Type,
  发送号_In      影像检查记录.发送号%Type,
  执行过程_In    病人医嘱发送.执行过程%Type,
  删除报告_In    Number := 0, --1删除报告，无报告完成 
  操作员编号_In  人员表.编号%Type := Null,
  操作员姓名_In  人员表.姓名%Type := Null,
  执行部门id_In  门诊费用记录.执行部门id%Type := Null,
  完成时间_In    病人医嘱发送.完成时间%Type := Null
) Is

  v_Temp     Varchar2(255);
  v_人员编号 人员表.编号%Type;
  v_人员姓名 人员表.姓名%Type;
  n_部门id   部门表.Id%Type;
  n_报告id   Number;
  v_完成人   人员表.姓名%Type;
  v_完成时间 Date;
  v_Risid    Number;

Begin

  --取得报告完成人和时间 
  If 执行过程_In = 6 Then
    v_完成人   := 操作员姓名_In;
    v_完成时间 := 完成时间_In;
  End If;

  

  n_报告id := 0;

  If 删除报告_In <> 0 Then
    Begin
      Select 病历id, Risid Into n_报告id, v_Risid From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Null;
    End;
    If v_Risid Is Null Then
      Delete 电子病历记录 Where ID = n_报告id;
      Zl_影像报告标记_Clear(医嘱id_In);
    End If;
  End If;

  --只更新跟主医嘱执行状态相同的部位医嘱，跟主医嘱执行状态不同的部位医嘱，是被分部位取消执行的 
  Update 病人医嘱发送 A
  Set a.执行状态 = Decode(执行过程_In, 6, 1, 3), a.执行过程 = 执行过程_In, a.完成人 = v_完成人, a.完成时间 = v_完成时间, a.采样时间 = Sysdate
  Where a.发送号 + 0 = 发送号_In And
        a.医嘱id In (Select b.Id
                   From 病人医嘱记录 B, 病人医嘱发送 C
                   Where b.Id = c.医嘱id And (b.Id = 医嘱id_In Or b.相关id = 医嘱id_In) And
                         c.执行状态 = (Select d.执行状态 From 病人医嘱发送 D Where d.医嘱id = 医嘱id_In));

  If 执行过程_In = 5 Then
    Update 影像检查记录 Set 完成人 = Null Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 8, 医嘱id_In || ',' || 发送号_In;
    Exception
      When Others Then
        Null;
    End;
  Elsif 执行过程_In = 6 Then
  	--取当前操作人员 
    If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
      v_人员编号 := 操作员编号_In;
      v_人员姓名 := 操作员姓名_In;
      n_部门id   := 执行部门id_In;
    Else
      v_Temp     := Zl_Identity;
      n_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    End If;

    Update 影像检查记录 Set 完成人 = v_人员姓名 Where 医嘱id = 医嘱id_In And 发送号 = 发送号_In;
  
    --如果是检查完成，则不需要判断参数“执行费用_In”，检查完成时，必须执行费用 
    Zl_影像费用执行(医嘱id_In, 发送号_In, 执行过程_In, 0, v_人员编号, v_人员姓名, n_部门id);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_影像检查_State;
/

--119108:李南春,2018-03-13,并发锁号问题
CREATE OR REPLACE Procedure Zl_挂号安排_传统_Lockno
(
  操作类型_In   Integer,
  号码_In       挂号安排.号码%Type,
  日期_In       挂号序号状态.日期%Type,
  号序_In       挂号序号状态.序号%Type,
  序号_Out      Out 挂号序号状态.序号%Type,
  机器名_In     挂号序号状态.机器名%Type := Null,
  操作员姓名_In 挂号序号状态.操作员姓名%Type := Null,
  安排id_In     挂号安排.Id%Type := Null,
  计划id_In     挂号安排计划.Id%Type := Null,
  是否预约_In   Number := 0,
  备注_In       挂号序号状态.备注%Type := Null,
  合作单位_In   Varchar2 := Null,
  时间段_In     Varchar2 := Null

) Is
  --功能:传统模式的锁号操作
  --操作类型_In： 0-解锁,1-加锁（根据传入的日期来加锁，没找到取一个）;2-加锁(直接取一下有效号进行加锁)
  --安排ID_In:如果不为空，则直接从安排中取数
  --计划ID_In:如果不为空，则直接从计划中取数
  --时间段_In:可以不传入，不传入时，则直接取下一个有效号 格式:HH24:mi:ss-HH24:mi:ss
  n_安排id       挂号安排.Id%Type;
  n_计划id       挂号安排计划.Id%Type;
  v_号码         挂号安排.号码%Type;
  n_状态         挂号序号状态.状态%Type;
  v_星期         挂号安排限制.限制项目%Type;
  n_号序         挂号序号状态.序号%Type;
  v_验证姓名     挂号序号状态.操作员姓名%Type;
  v_操作员姓名   挂号序号状态.操作员姓名%Type;
  v_验证机器名   挂号序号状态.机器名%Type;
  v_机器名       挂号序号状态.机器名%Type;
  n_限号数       挂号安排限制.限号数%Type;
  n_限约数       挂号安排限制.限约数%Type;
  n_合约模式     Number(3);
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_存在         Number(18);
  n_启用合作单位 Number(3);
  n_是否挂号     Number(3); --1-挂号;0-预约
  n_自锁号       Number(3);
  d_时段开始     Date;
  d_序号时间     Date;
  d_时段结束     Date;
  n_Rowid        Rowid;
  v_Temp         Varchar2(32767); --临时XML
  Err_Item Exception;

  Function Check_Nums_Valied
  (
    安排id1_In  In 挂号安排.Id%Type,
    计划id1_In  In 挂号安排计划.Id%Type,
    星期1_In    In 挂号安排限制.限制项目%Type,
    是否挂号_In Number
  ) Return Number Is
    --功能：检查是否超出了限号或限约
    --入参:是否挂号_IN-1:挂号;0-预约
    --返回:1-表示数据合法;0-表示数据不合法:超出了限号或限约数
    n_Count Number(18);
    n_Temp  Number(18);
  Begin
    If Nvl(n_计划id, 0) <> 0 Then
      Select Max(限号数), Max(限约数)
      Into n_限号数, n_限约数
      From 挂号计划限制
      Where 计划id = 计划id1_In And 限制项目 = 星期1_In;
    Else
      Select Max(限号数), Max(限约数)
      Into n_限号数, n_限约数
      From 挂号安排限制
      Where 安排id = 安排id1_In And 限制项目 = 星期1_In;
    End If;

    Select Count(*)
    Into n_Count
    From (Select 序号
           From 挂号序号状态
           Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
           Union
           Select 序号
           From 合作单位计划控制
           Where 计划id = Decode(是否挂号_In, 1, 0, 计划id1_In) And Decode(是否挂号_In, 1, 0, 0) = 0 And 限制项目 = 星期1_In And 数量 <> 0
           Union
           Select 序号
           From 合作单位安排控制
           Where 安排id = Decode(是否挂号_In, 1, 0, 安排id1_In) And Decode(是否挂号_In, 1, 0, 0) = 0 And 限制项目 = 星期1_In And 数量 <> 0);

    If 是否挂号_In = 1 And Nvl(n_限号数, 0) <> 0 And Nvl(n_限号数, 0) < n_Count Then
      Return 0;
    Elsif 是否挂号_In = 0 Then
      n_Temp := Nvl(n_限约数, 0);
      If n_Temp = 0 Then
        n_Temp := Nvl(n_限号数, 0);
      End If;
      If n_Temp <> 0 And n_Temp < n_Count Then
        Return 0;
      End If;
    End If;
    Return 1;
  End;

  Function Get_Next_Plannum
  (
    号码1_In       In 挂号安排.号码%Type,
    日期1_In       In Date,
    安排id1_In     In 挂号安排.Id%Type,
    计划id1_In     In 挂号安排计划.Id%Type,
    星期1_In       In 挂号安排限制.限制项目%Type,
    操作员姓名1_In 人员表.姓名%Type,
    机器名1_In     挂号序号状态.机器名%Type,
    备注1_In       In 挂号序号状态.备注%Type
  ) Return Number Is
    n_Temp_序号 Number(18);
    n_Find      Number(2);
    n_自锁号    Number(2);
    d_序号时间  Date;
    n_Rowid     Rowid;
  Begin
    If Nvl(计划id_In, 0) <> 0 Then
      Select Max(序号) + 1
      Into n_Temp_序号
      From (Select Distinct 序号
             From 挂号计划时段
             Where 计划id = 计划id1_In And 星期 = 星期1_In
             Union All
             Select Distinct 序号
             From 挂号序号状态
             Where 号码 = 号码1_In And Trunc(日期) = Trunc(日期1_In));
    Else
      Select Max(序号) + 1
      Into n_Temp_序号
      From (Select Distinct 序号
             From 挂号安排时段
             Where 安排id = 安排id1_In And 星期 = 星期1_In
             Union
             Select Distinct 序号
             From 挂号序号状态
             Where 号码 = 号码1_In And Trunc(日期) = Trunc(日期1_In));
    End If;

    n_Find := 0;
    While n_Find = 0 Loop
      Begin
        Select Rowid, 1,
               Case
                 When 机器名 = 机器名1_In And 操作员姓名 = 操作员姓名1_In And 状态 = 5 Then
                  1
                 Else
                  0
               End
        Into n_Rowid, n_存在, n_自锁号
        From 挂号序号状态
        Where 号码 = 号码1_In And 日期 Between Trunc(日期1_In) And Trunc(日期1_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_Temp_序号;
      Exception
        When Others Then
          n_存在   := 0;
          n_自锁号 := 0;
      End;
      If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
        --自己锁的号，独站起:
        Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
        n_Find := 1;
        Return n_Temp_序号;
      End If;

      If Nvl(n_存在, 0) = 0 Then
        --未发现该序号被站用，插入记录
        d_序号时间 := 日期1_In;
        If 时间段_In Is Not Null Then
          Begin
            If Nvl(计划id1_In, 0) <> 0 Then
              Select To_Date(To_Char(日期1_In, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
              Into d_序号时间
              From 挂号计划时段
              Where 计划id = 计划id1_In And 星期 = v_星期 And 序号 = n_号序;
            Else

              Select To_Date(To_Char(日期1_In, 'yyyy-mm-dd') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
              Into d_序号时间
              From 挂号安排时段
              Where 安排id = 安排id1_In And 星期 = v_星期 And 序号 = n_号序;
            End If;
          Exception
            When Others Then
              d_序号时间 := 日期1_In;
          End;
        End If;
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (号码1_In, d_序号时间, n_Temp_序号, 5, 操作员姓名1_In, 备注1_In, Sysdate, 机器名1_In);

        n_Find := 1;
        Return n_Temp_序号;
      End If;
      n_Temp_序号 := n_Temp_序号 + 1;
    End Loop;
  End;

Begin

  v_机器名 := 机器名_In;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  n_号序     := 号序_In;
  v_号码     := 号码_In;
  n_是否挂号 := Case
              When Nvl(是否预约_In, 0) = 0 Then
               1
              Else
               0
            End;

  If 操作类型_In = 0 Then
    --解锁
    Delete 挂号序号状态
    Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 And 序号 = n_号序 And Trunc(日期) = Trunc(日期_In) And 号码 = 号码_In;
    If Sql%NotFound Then
      v_Temp := '没有发现需要解锁的序号';
      Raise Err_Item;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  --锁号
  If 时间段_In Is Not Null Then
    Begin
      d_时段开始 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, 1, Instr(时间段_In, '-') - 1),
                        'yyyy-mm-dd hh24:mi:ss');
      If Substr(时间段_In, Instr(时间段_In, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, Instr(时间段_In, '-') + 1),
                          'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  Select Decode(To_Char(日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
  Into v_星期
  From Dual;

  n_计划id := Nvl(计划id_In, 0);
  n_安排id := Nvl(安排id_In, 0);
  If Nvl(n_计划id, 0) <> 0 Then
    Select Max(a.序号控制), Max(b.号码)
    Into n_序号控制, v_号码
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = n_计划id And a.安排id = b.Id;
  End If;
  If Nvl(n_安排id, 0) <> 0 Then
    Select Max(序号控制), Max(号码) Into n_序号控制, v_号码 From 挂号安排 Where ID = n_安排id;
  End If;

  If Nvl(n_计划id, 0) = 0 And Nvl(n_安排id, 0) = 0 Then
    Begin
      Select 序号控制, ID
      Into n_序号控制, n_计划id
      From (Select 序号控制, ID
             From 挂号安排计划
             Where 号码 = v_号码 And 日期_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                   Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And 审核时间 Is Not Null
             Order By 生效时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Select 序号控制, ID Into n_序号控制, n_安排id From 挂号安排 Where 号码 = v_号码;
    End;
  End If;

  If Nvl(n_序号控制, 0) = 0 Then
    --未启用序号，不能锁号
    Return;
  End If;

  If Nvl(n_计划id, 0) <> 0 Then
    Select Nvl(Max(1), 0) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum < 2;

    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 合作单位计划控制
    Where 限制项目 = v_星期 And 计划id = n_计划id And 合作单位 = 合作单位_In And Rownum < 2;
  Else

    Select Nvl(Max(1), 0) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum < 2;
    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 合作单位安排控制
    Where 限制项目 = v_星期 And 安排id = n_安排id And 合作单位 = 合作单位_In And Rownum < 2;
  End If;

  If 操作类型_In = 2 Then
    --直接取一下号来进行锁号操作
    v_Temp := Zl_Fun_挂号安排_传统_Nextsn(日期_In, n_安排id, n_计划id, v_操作员姓名, v_星期, 备注_In, v_机器名, 合作单位_In, 0, Nvl(是否预约_In, 0));
    If v_Temp Is Not Null Then
      序号_Out := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    End If;
    Return;
  End If;

  n_存在 := 0;
  If 时间段_In Is Null And 操作类型_In = 1 Then
    If Nvl(n_计划id, 0) <> 0 Then
      Begin
        Select 1, a.状态, a.操作员姓名, a.机器名, a.序号
        Into n_存在, n_状态, v_验证姓名, v_验证机器名, n_号序
        From 挂号序号状态 A, 挂号计划时段 B
        Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(日期_In) And a.序号 = b.序号 And b.计划id = n_计划id And b.星期 = v_星期 And
              To_Char(b.开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    Else
      Begin
        Select 1, a.状态, a.操作员姓名, a.机器名, a.序号
        Into n_存在, n_状态, v_验证姓名, v_验证机器名, n_号序
        From 挂号序号状态 A, 挂号安排时段 B
        Where a.号码 = v_号码 And Trunc(a.日期) = Trunc(日期_In) And a.序号 = b.序号 And b.安排id = n_安排id And b.星期 = v_星期 And
              To_Char(b.开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  End If;

  If n_存在 = 1 Then
    If Not (n_状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名) Then
      --传入时间的序号已经被使用
      v_Temp := '传入时间' || 日期_In || '的序号已被使用';
      Raise Err_Item;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  If n_分时段 = 1 And 操作类型_In = 1 Then
    If 时间段_In Is Null Then
      --精确定位序号
      Begin
        n_存在 := 1;
        If Nvl(n_计划id, 0) <> 0 Then
          Select 序号
          Into n_号序
          From 挂号计划时段
          Where 计划id = n_计划id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
        Else
          Select 序号
          Into n_号序
          From 挂号安排时段
          Where 安排id = n_安排id And 星期 = v_星期 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;
        End If;
      Exception
        When Others Then
          n_存在 := 0;
      End;

      If n_存在 = 1 Then
        --存在，则检查是否被其他人站用。
        Begin
          Select Rowid, 1,
                 Case
                   When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                    1
                   Else
                    0
                 End
          Into n_Rowid, n_存在, n_自锁号
          From 挂号序号状态
          Where 号码 = v_号码 And 日期 = 日期_In And 序号 = n_号序;
        Exception
          When Others Then
            n_存在   := 0;
            n_自锁号 := 0;
        End;

        If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
          --自己锁的号，独站起:
          Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
          序号_Out := n_号序;
          Return;
        End If;
        If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 0 Then
          v_Temp := '传入时间' || 日期_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (v_号码, 日期_In, n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        序号_Out := n_号序;
        Return;
      End If;
      --不存在时，取下一个号,同时检查限号数是否正确
      n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);

      If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
        v_Temp := '传入号别' || 号码_In || '当前已无余号';
        Raise Err_Item;
      End If;
      序号_Out := n_号序;
      Return;
    Else
      If Nvl(n_计划id, 0) <> 0 Then
        --预约判断: 如果全部序号可以预约，则是否预约全部为0，所以需要单独处理这种情况

        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号计划时段
        Where 计划id = n_计划id And 星期 = v_星期 And 是否预约 = 1 And Rownum < 2;

        Select Min(a.序号), Min(b.状态)
        Into n_号序, n_状态
        From 挂号计划时段 A, 挂号序号状态 B
        Where a.序号 = b.序号(+) And (Nvl(b.状态, 0) = 0 Or Nvl(b.状态, 0) = 5) And b.号码(+) = v_号码 And
              Trunc(b.日期(+)) = Trunc(日期_In) And a.计划id = n_计划id And a.星期 = v_星期 And
              To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
              To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Case
                When n_是否挂号 = 1 Or n_存在 = 0 Then
                 1
                Else
                 a.是否预约
              End = 1; --  Decode(n_是否挂号, 1, 1, Decode(n_存在, 1, a.是否预约, 1))) = 1;
      Else
        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号安排时段
        Where 安排id = n_安排id And 星期 = v_星期 And 是否预约 = 1 And Rownum < 2;

        Select Min(a.序号), Min(b.状态)
        Into n_号序, n_状态
        From 挂号安排时段 A, 挂号序号状态 B
        Where a.序号 = b.序号(+) And (Nvl(b.状态, 0) = 0 Or Nvl(b.状态, 0) = 5) And b.号码(+) = v_号码 And
              Trunc(b.日期(+)) = Trunc(日期_In) And a.安排id = n_安排id And a.星期 = v_星期 And
              To_Char(a.开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
              To_Char(a.开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Case
                When n_是否挂号 = 1 Or n_存在 = 0 Then
                 1
                Else
                 a.是否预约
              End = 1; --  Decode(n_是否挂号, 1, 1, Decode(n_存在, 1, a.

      End If;

      If Nvl(n_号序, 0) = 0 Then
        If n_存在 = 1 Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用或未开放预约。';
          Raise Err_Item;
        End If;

        If d_时段结束 Is Not Null Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        --不存在时，取下一个号,同时检查限号数是否正确
        n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);

        If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
          v_Temp := '传入号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
        序号_Out := n_号序;
        Return;
      End If;
      --存在序号
      If Nvl(n_状态, 0) = 0 Then
        --合法时间段，插入记录
        Insert Into 挂号序号状态
          (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
        Values
          (v_号码, 日期_In, n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        序号_Out := n_号序;
        Return;

      End If;

      If Nvl(n_状态, 0) = 5 Then
        Select Nvl(Max(1), 0)
        Into n_存在
        From 挂号序号状态
        Where 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 序号 = n_号序 And 号码 = v_号码;

        If n_存在 = 0 Then
          v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
          Raise Err_Item;
        End If;
        序号_Out := n_号序;
        Return;
      End If;

      If d_时段结束 Is Not Null Then
        v_Temp := '传入时间段' || 时间段_In || '的序号已被使用';
        Raise Err_Item;
      End If;
      --不存在时，取下一个号,同时检查限号数是否正确
      n_号序 := Get_Next_Plannum(v_号码, 日期_In, n_安排id, n_计划id, v_星期, v_操作员姓名, v_机器名, 备注_In);
      If Check_Nums_Valied(n_安排id, n_计划id, v_星期, n_是否挂号) = 0 Then
        v_Temp := '传入号别' || 号码_In || '当前已无余号';
        Raise Err_Item;
      End If;
    End If;
    序号_Out := n_号序;
    Return;
  End If;

  --不分时段,但启用了序号的
  If Nvl(n_计划id, 0) <> 0 Then
    Select Decode(n_是否挂号, 1, Max(限号数), Max(限约数))
    Into n_限号数
    From 挂号计划限制
    Where 计划id = n_计划id And 限制项目 = v_星期;
  Else
    Select Decode(n_是否挂号, 1, Max(限号数), Max(限约数))
    Into n_限号数
    From 挂号安排限制
    Where 安排id = n_安排id And 限制项目 = v_星期;
  End If;

  n_号序 := 1;
  If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
    For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                 From 挂号序号状态
                 Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
                 Union
                 Select 序号, Null, Null, Null
                 From 合作单位计划控制
                 Where 计划id = Decode(n_是否挂号, 1, 0, n_计划id) And Decode(n_是否挂号, 1, 1, 0) = 0 And 限制项目 = v_星期 And 数量 <> 0
                 Union
                 Select 序号, Null, Null, Null
                 From 合作单位安排控制
                 Where 安排id = Decode(n_是否挂号, 1, 0, n_安排id) And Decode(n_是否挂号, 1, 1, 0) = 0 And 限制项目 = v_星期 And 数量 <> 0
                 Order By 序号) Loop
      --存在锁号的，则退出
      Exit When r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名;
      If r_序号.序号 = n_号序 Then
        n_号序 := n_号序 + 1;
      End If;
    End Loop;

    If n_号序 > n_限号数 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;

    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In) And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 1 Then
      序号_Out := n_号序;
      Return;
    End If;
    If n_存在 = 1 And n_自锁号 = 0 Then
      --已经站用了
      v_Temp := '序号' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;
    Insert Into 挂号序号状态
      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
    Values
      (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    序号_Out := n_号序;
    Return;
  End If;

  --启用了合作单位控制的:合约单位处理
  If Nvl(n_计划id, 0) <> 0 Then
    Select Count(1)
    Into n_合约模式
    From 合作单位计划控制
    Where 序号 = 0 And 计划id = n_计划id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0;
  Else
    Select Count(1)
    Into n_合约模式
    From 合作单位安排控制
    Where 序号 = 0 And 安排id = n_安排id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0;
  End If;

  If n_合约模式 = 0 Then
    If Nvl(n_计划id, 0) <> 0 Then
      Select Nvl(Max(序号), 0)
      Into n_号序
      From (Select 序号
             From 合作单位计划控制 A
             Where 计划id = n_计划id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0 And
                   (Not Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 <> 0) Or Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                           机器名 = v_机器名))
             Order By 序号)
      Where Rownum < 2;
    Else

      Select Nvl(Max(序号), 0)
      Into n_号序
      From (Select 序号
             From 合作单位安排控制 A
             Where 安排id = n_安排id And 合作单位 = 合作单位_In And 限制项目 = v_星期 And 数量 <> 0 And
                   (Not Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 <> 0) Or Exists
                    (Select 1
                     From 挂号序号状态
                     Where 号码 = 号码_In And 序号 = a.序号 And Trunc(日期) = Trunc(日期_In) And 状态 = 5 And 操作员姓名 = v_操作员姓名 And
                           机器名 = v_机器名))
             Order By 序号)
      Where Rownum < 2;
    End If;

    If Nvl(n_号序, 0) = 0 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;
    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 0 Then
      v_Temp := '序号为' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;
    If Nvl(n_存在, 0) = 0 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    序号_Out := n_号序;
    Return;

  Else
    n_号序 := 1;
    Select 限号数 Into n_限号数 From 挂号计划限制 Where 计划id = n_计划id And 限制项目 = v_星期;
    For r_序号 In (Select 序号, 状态, 操作员姓名, 机器名
                 From 挂号序号状态
                 Where 号码 = 号码_In And Trunc(日期) = Trunc(日期_In)
                 Union All
                 Select 序号, Null, Null, Null
                 From 合作单位计划控制
                 Where 计划id = n_计划id And Decode(Nvl(n_计划id, 0), 0, 0, 1) = 1 And 限制项目 = v_星期 And 数量 <> 0
                 Union All
                 Select 序号, Null, Null, Null
                 From 合作单位安排控制
                 Where 安排id = n_安排id And Decode(Nvl(n_计划id, 0), 0, 1, 0) = 1 And 限制项目 = v_星期 And 数量 <> 0
                 Order By 序号) Loop
      If r_序号.状态 = 5 And r_序号.操作员姓名 = v_操作员姓名 And r_序号.机器名 = v_机器名 Then
        n_号序 := r_序号.序号;
        Exit;
      End If;
      If r_序号.序号 = n_号序 Then
        n_号序 := n_号序 + 1;
      End If;
    End Loop;

    If n_号序 > n_限号数 Then
      v_Temp := '传入号别' || 号码_In || '当前已无余号';
      Raise Err_Item;
    End If;

    Begin
      Select Rowid, 1,
             Case
               When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 挂号序号状态
      Where 号码 = 号码_In And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_号序;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If n_存在 = 1 And n_自锁号 = 0 Then
      v_Temp := '序号为' || n_号序 || '已被使用';
      Raise Err_Item;
    End If;

    If Nvl(n_存在, 0) = 0 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (号码_In, Trunc(日期_In), n_号序, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    序号_Out := n_号序;
    Return;
  End If;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号安排_传统_Lockno;
/

--119108:李南春,2018-03-13,并发锁号问题
CREATE OR REPLACE Procedure Zl_挂号安排_临床出诊_Lockno
(
  操作类型_In   Integer,
  记录id_In     临床出诊记录.Id%Type,
  日期_In       临床出诊序号控制.开始时间%Type,
  序号_In       临床出诊序号控制.序号%Type,
  序号_Out      Out 临床出诊序号控制.序号%Type,
  是否预约_In   Number := 0,
  备注_In       临床出诊序号控制.备注%Type := Null,
  机器名_In     临床出诊序号控制.工作站名称%Type := Null,
  操作员姓名_In 临床出诊序号控制.操作员姓名%Type := Null,
  启用日期_In   Date := Null,
  合作单位_In   Varchar2 := Null,
  时间段_In     Varchar2 := Null,
  号码_In       临床出诊号源.号码%Type := Null
) Is

  --功能:临床出诊模式的锁号操作
  --操作类型_In： 0-解锁,1-加锁（根据传入的日期来加锁，没找到取一个）;2-加锁(直接取一下有效号进行加锁)
  --启用日期_In:启用日期为空时，必须传入记录ID_IN;
  --时间段_In:可以不传入，不传入时，则直接取下一个有效号 格式:HH24:mi:ss-HH24:mi:ss

  n_挂号状态   临床出诊序号控制.挂号状态%Type;
  n_序号       临床出诊序号控制.序号%Type;
  v_验证姓名   临床出诊序号控制.操作员姓名%Type;
  v_验证机器名 临床出诊序号控制.工作站名称%Type;

  v_操作员姓名 临床出诊序号控制.操作员姓名%Type;
  v_机器名     临床出诊序号控制.工作站名称%Type;

  n_数量         临床出诊序号控制.数量%Type;
  n_顺序号       临床出诊序号控制.预约顺序号%Type;
  n_合约模式     Number(3);
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_存在         Number(18);
  n_启用合作单位 Number(3);
  n_是否挂号     Number(3); --1-挂号;0-预约
  n_自锁号       Number(3);
  d_时段开始     Date;
  d_时段结束     Date;
  n_Rowid        Rowid;
  n_记录id       临床出诊记录.Id%Type;
  v_Temp         Varchar2(32767); --临时XML
  Err_Item Exception;

  Function Get_Next_Sn
  (
    记录id1_In     临床出诊记录.Id%Type,
    日期1_In       Date,
    机器名1_In     临床出诊序号控制.工作站名称%Type,
    操作员姓名1_In 临床出诊序号控制.操作员姓名%Type
  ) Return Number Is
    n_Temp   Number(18);
    n_限约数 临床出诊记录.限约数%Type;
    n_限号数 临床出诊记录.限号数%Type;
    v_号码   临床出诊号源.号码%Type;
  Begin
    Select Min(序号)
    Into n_Temp
    From 临床出诊序号控制
    Where 记录id = 记录id1_In And 开始时间 >= 日期1_In And
          (Nvl(挂号状态, 0) = 0 Or
          (Nvl(挂号状态, 0) = 5 And Nvl(工作站名称, 机器名1_In) = 机器名1_In And Nvl(操作员姓名, 操作员姓名1_In) = 操作员姓名1_In)) And
          Nvl(是否停诊, 0) <> 1;

    If Nvl(n_Temp, 0) = 0 Then
      --检查总体数量: --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
      Select Nvl(限约数, 0), Nvl(限号数, 0)
      Into n_限约数, n_限号数
      From 临床出诊记录
      Where ID = 记录id1_In;

      Select Sum(数量)
      Into n_数量
      From 临床出诊序号控制
      Where 记录id = 记录id1_In And (Nvl(挂号状态, 0) In (1, 2) Or
            (挂号状态 In (3, 5) And Nvl(工作站名称, '-') <> 机器名1_In And Nvl(操作员姓名, '-') <> 操作员姓名1_In));

      If Trunc(Sysdate) = Trunc(日期1_In) Then
        If n_限号数 - n_数量 <= 0 Then
          Select Max(b.号码)
          Into v_号码
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And a.Id = 记录id1_In;

          v_Temp := '传入号别' || Nvl(v_号码, '-') || '当前已无余号';
          Raise Err_Item;
        End If;
      Else
        If n_限约数 - n_数量 <= 0 Then
          v_Temp := '传入号别' || Nvl(v_号码, '-') || '当前已无余号';
          Raise Err_Item;
        End If;
      End If;

      Select Max(序号) + 1 Into n_Temp From 临床出诊序号控制 Where 记录id = 记录id1_In;
    End If;
    Return n_Temp;
  End;

  Function Save_Lockdata
  (
    记录id1_In     临床出诊记录.Id%Type,
    序号1_In       临床出诊序号控制.序号%Type,
    机器名1_In     临床出诊序号控制.工作站名称%Type,
    操作员姓名1_In 临床出诊序号控制.操作员姓名%Type,
    备注1_In       临床出诊序号控制.备注%Type := Null,
    预约顺序号1_In 临床出诊序号控制.预约顺序号%Type := Null
  ) Return Number Is
    n_Temp_序号 Number(18);
    n_自锁号    Number(2);
    n_Rowid     Rowid;
  Begin
    n_Temp_序号 := 序号1_In;

    --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
    Begin
      Select Rowid, 1,
             Case
               When (Nvl(工作站名称, 机器名1_In) = 机器名1_In And Nvl(操作员姓名, 操作员姓名1_In) = 操作员姓名1_In And
                    Instr(',0,5,', ',' || Nvl(挂号状态, 0) || ',') > 0) Or Nvl(挂号状态, 0) = 0 Then
                1
               Else
                0
             End
      Into n_Rowid, n_存在, n_自锁号
      From 临床出诊序号控制
      Where 记录id = 记录id1_In And 序号 = n_Temp_序号;
    Exception
      When Others Then
        n_存在   := 0;
        n_自锁号 := 0;
    End;
    If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 0 Then

      v_Temp := '序号为' || n_Temp_序号 || '的序号已被使用。';
      Raise Err_Item;
    End If;

    Update 临床出诊序号控制
    Set 挂号状态 = 5, 锁号时间 = Sysdate, 操作员姓名 = 操作员姓名1_In, 工作站名称 = 机器名1_In, 备注 = 备注1_In
    Where 记录id = 记录id1_In And 序号 = n_Temp_序号 And Decode(预约顺序号1_In, Null, 0, 预约顺序号) = Nvl(预约顺序号1_In, 0);

    If Sql%Rowcount = 0 Then
      Insert Into 临床出诊序号控制
        (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 锁号时间, 名称, 类型, 操作员姓名, 工作站名称, 预约顺序号, 备注)
        Select 记录id, n_Temp_序号,
               To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
               To_Date(To_Char(开始时间, 'yyyy-mm-dd') || ' ' || To_Char(日期_In, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 1,
               是否预约, 5, Sysdate, 合作单位_In, 1, 操作员姓名1_In, 机器名1_In, 预约顺序号1_In, 备注1_In
        From 临床出诊序号控制
        Where 记录id = 记录id1_In And Rownum < 2;
    End If;

    Return n_Temp_序号;
  End;

Begin
  n_记录id := 记录id_In;
  n_序号   := 序号_In;

  v_机器名 := 机器名_In;
  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  If Nvl(n_记录id, 0) = 0 Then

    --新排班模式检查:启用30天内的，如果不传入记录ID,则自动取记录ID,启用30后，必须要传入的记录ID(此规则LEX当时定的，现更改取消30的限制，无什么意义)
    If Sysdate - 10 > Nvl(启用日期_In, Sysdate) Then
      If Nvl(日期_In, Sysdate) > Nvl(启用日期_In, Sysdate) Then
        v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
        Raise Err_Item;
      End If;
    Else
      If Nvl(日期_In, Sysdate) > Nvl(启用日期_In, Sysdate) Then
        Begin
          Select a.Id
          Into n_记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(日期_In, Sysdate) Between a.开始时间 And a.终止时间;
        Exception
          When Others Then
            v_Temp := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
            Raise Err_Item;
        End;
      End If;
    End If;
  End If;

  n_是否挂号 := Case
              When Nvl(是否预约_In, 0) = 0 Then
               1
              Else
               0
            End;

  If 操作类型_In = 0 Then
    --解锁
    Update 临床出诊序号控制
    Set 挂号状态 = 0, 操作员姓名 = Null, 工作站名称 = Null, 备注 = Null
    Where 工作站名称 = v_机器名 And 操作员姓名 = v_操作员姓名 And 挂号状态 = 5 And (序号 = n_序号 Or 备注 = n_序号) And 记录id = n_记录id;
    If Sql%NotFound Then
      v_Temp := '没有发现需要解锁的序号';
      Raise Err_Item;
    End If;
    序号_Out := n_序号;
    Return;
  End If;

  If 时间段_In Is Not Null Then
    Begin
      d_时段开始 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, 1, Instr(时间段_In, '-') - 1),
                        'yyyy-mm-dd hh24:mi:ss');
      If Substr(时间段_In, Instr(时间段_In, '-') + 1) Is Null Then
        d_时段结束 := Null;
      Else
        d_时段结束 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || Substr(时间段_In, Instr(时间段_In, '-') + 1),
                          'yyyy-mm-dd hh24:mi:ss');
      End If;
    Exception
      When Others Then
        v_Temp := '无法解析传入的时间段格式，请检查！';
        Raise Err_Item;
    End;
  End If;

  Select Nvl(Max(1), 0)
  Into n_存在
  From 临床出诊记录
  Where ID = n_记录id And 日期_In Between 开始时间 And 终止时间 And Rownum < 2;
  If Nvl(n_存在, 0) = 0 Then
    v_Temp := '传入的时间' || To_Char(日期_In, 'yyyy-mm-dd hh24:mi:ss') || '不存出诊范围内,请检查!';
    Raise Err_Item;
  End If;

  If n_序号 Is Null Then

    Select Max(是否序号控制), Max(是否分时段) Into n_序号控制, n_分时段 From 临床出诊记录 Where ID = n_记录id;

    Select Nvl(Max(1), 0)
    Into n_启用合作单位
    From 临床出诊挂号控制记录
    Where 记录id = n_记录id And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;

    If Nvl(n_序号控制, 0) = 0 Then
      --不启用序号控制的，直接返回
      Return;
    End If;

    If n_分时段 = 1 Then
      n_存在 := 0;
      If 时间段_In Is Null Then

        Update 临床出诊序号控制
        Set 备注 = 备注
        Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And Rownum < 2;

        Begin
          Select 1, 挂号状态, 操作员姓名, 工作站名称, 序号
          Into n_存在, n_挂号状态, v_验证姓名, v_验证机器名, n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And
                Nvl(挂号状态, 0) <> 0 And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;
      End If;

      If n_存在 = 1 Then
        If Not (n_挂号状态 = 5 And v_验证姓名 = v_操作员姓名 And v_机器名 = v_验证机器名) Then
          --传入时间的序号已经被使用
          v_Temp := '传入时间' || To_Char(日期_In, 'hh24:mi') || '的序号已被使用';
          Raise Err_Item;
        End If;
        序号_Out := n_序号;
        Return;
      End If;

      If 时间段_In Is Null Then
        Begin
          n_存在 := 1;
          Select 序号
          Into n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') = To_Char(日期_In, 'hh24:mi') And
                Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1 And Rownum < 2;
        Exception
          When Others Then
            n_存在 := 0;
        End;

        If Nvl(n_存在, 0) = 0 Then
          If n_是否挂号 = 0 Then
            v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
            Raise Err_Item;
          End If;

          Select Min(序号)
          Into n_序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 开始时间 >= 日期_In And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;

          If Nvl(n_序号, 0) = 0 Then
            Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
          End If;

        End If;

        n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
        序号_Out := n_序号;
        Return;
      End If;

      --未传时间段
      Select Min(序号), Min(挂号状态)
      Into n_序号, n_挂号状态
      From 临床出诊序号控制
      Where 记录id = n_记录id And 开始时间 <> 终止时间 And To_Char(开始时间, 'hh24:mi') >= To_Char(d_时段开始, 'hh24:mi') And
            (Nvl(挂号状态, 0) = 0 Or Nvl(挂号状态, 0) = 5) And Nvl(是否停诊, 0) <> 1 And
            To_Char(开始时间, 'hh24:mi') < To_Char(d_时段结束, 'hh24:mi') And Decode(n_是否挂号, 1, 1, 是否预约) = 1 And Rownum < 2;

      If Nvl(n_序号, 0) = 0 Then
        If d_时段结束 Is Not Null Then
          v_Temp := '传入时间段' || 时间段_In || '序号已被使用完,无法预约';
          Raise Err_Item;
        End If;
        If Trunc(日期_In) <> Trunc(Sysdate) Then
          v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
          Raise Err_Item;
        End If;

        Select Min(序号)
        Into n_序号
        From 临床出诊序号控制
        Where 记录id = n_记录id And 开始时间 >= 日期_In And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
        If Nvl(n_序号, 0) = 0 Then
          Select Max(序号) + 1 Into n_序号 From 临床出诊序号控制 Where 记录id = n_记录id;
        End If;
      Else
        If Nvl(n_挂号状态, 0) = 5 Then
          Select Nvl(Max(1), 0)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名 And 序号 = n_序号;
          If n_存在 = 1 Then
            序号_Out := n_序号;
            Return;
          End If;
        Else
          --0-待挂或待预约的号;1-已挂,2-已经预约,3-预留号,4-已经退号;5-已经锁号;不启用序号控制且分时段的且预约顺序号为NULL的，则为0
          If Nvl(n_挂号状态, 0) <> 0 Then
            If d_时段结束 Is Not Null Then
              v_Temp := '传入时间段' || 时间段_In || '序号已被使用完,无法预约';
              Raise Err_Item;
            End If;
            If Trunc(日期_In) <> Trunc(Sysdate) Then
              v_Temp := '传入时间' || 日期_In || '没有找到对应的序号,无法预约';
              Raise Err_Item;
            End If;

            n_序号 := Get_Next_Sn(n_记录id, 日期_In, v_机器名, v_操作员姓名);
          End If;
        End If;
      End If;
      n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
      序号_Out := n_序号;
      Return;
    End If;
    --不分时段
    If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
      --非合作单位
      n_序号 := Get_Next_Sn(n_记录id, trunc(日期_In), v_机器名, v_操作员姓名);

      n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
      序号_Out := n_序号;
      Return;
    End If;
    --合作单位
    --控制方式:0-禁止预约;1-按比例控制预约;2-按总量控制预约;3-按序号控制预约;4-不作限制
    Begin
      Select 控制方式
      Into n_合约模式
      From 临床出诊挂号控制记录
      Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And Rownum < 2;
    Exception
      When Others Then
        n_合约模式 := 4;
    End;
    If n_合约模式 = 0 Then
      v_Temp := '本号别禁止该合作单位预约!';
      Raise Err_Item;
    End If;

    If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
      n_序号 := Get_Next_Sn(n_记录id, 日期_In, v_机器名, v_操作员姓名);
    End If;

    If n_合约模式 = 3 Then
      Select Min(a.序号)
      Into n_序号
      From 临床出诊序号控制 A, 临床出诊挂号控制记录 B
      Where a.记录id = n_记录id And a.记录id = b.记录id And b.类型 = 1 And b.性质 = 1 And b.名称 = 合作单位_In And a.序号 = b.序号 And
            Nvl(a.挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;

      If n_序号 = 0 Then
        v_Temp := '本号别合作单位可预约序号已经全部使用完!';
        Raise Err_Item;
      End If;
    End If;
    n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, Null);
    序号_Out := n_序号;
    Return;

  End If;

  --非序号控制:n_序号  is not null
  If n_分时段 = 1 Then
    If 合作单位_In Is Null Or n_启用合作单位 = 0 Then
      Begin
        If 时间段_In Is Null Then
          Select 序号, 数量
          Into n_序号, n_数量
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
        Else
          Select Min(序号)
          Into n_序号
          From 临床出诊序号控制 A
          Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                数量 > (Select Count(1)
                      From 临床出诊序号控制
                      Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
          If Nvl(n_序号, 0) = 0 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;
          Select 数量
          Into n_数量
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
        End If;
        Select Count(1)
        Into n_存在
        From 临床出诊序号控制
        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;

        If Nvl(n_存在, 0) >= n_数量 Then
          v_Temp := '本号别可用序号已经全部使用完!';
          Raise Err_Item;
        End If;
        Select Min(预约顺序号)
        Into n_顺序号
        From 临床出诊序号控制
        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
        If n_顺序号 = 0 Then
          Select Max(预约顺序号) + 1
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
        End If;
        n_序号   := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);
        序号_Out := n_序号;
        Return;
      Exception
        When Others Then
          Null;
      End;
    Else
      --合作单位

      Begin
        Select 控制方式
        Into n_合约模式
        From 临床出诊挂号控制记录
        Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And Rownum < 2;
      Exception
        When Others Then
          n_合约模式 := 4;
      End;
      If n_合约模式 = 0 Then
        v_Temp := '本号别禁止该合作单位预约!';
        Raise Err_Item;
      End If;
      If n_合约模式 = 1 Or n_合约模式 = 2 Or n_合约模式 = 4 Then
        Begin
          If 时间段_In Is Null Then
            Select 序号, 数量
            Into n_序号, n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
          Else
            Select Min(序号)
            Into n_序号
            From 临床出诊序号控制 A
            Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                  数量 > (Select Count(1)
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
            If Nvl(n_序号, 0) = 0 Then
              v_Temp := '本号别可用序号已经全部使用完!';
              Raise Err_Item;
            End If;
            Select 数量
            Into n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
          End If;
          Select Count(1)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;
          If Nvl(n_存在, 0) >= n_数量 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;

          Select Min(预约顺序号)
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
          If n_顺序号 = 0 Then
            Select Max(预约顺序号) + 1
            Into n_顺序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
          End If;

          n_序号 := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);

          序号_Out := n_序号;
          Return;
        Exception
          When Others Then
            Null;
        End;
      End If;
      If n_合约模式 = 3 Then
        Begin
          If 时间段_In Is Null Then
            Select 序号
            Into n_序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 开始时间 = 日期_In;
            Select 数量
            Into n_数量
            From 临床出诊挂号控制记录
            Where 记录id = n_记录id And 类型 = 1 And 性质 = 1 And 名称 = 合作单位_In And 序号 = n_序号;
          Else
            Select Min(序号)
            Into n_序号
            From 临床出诊序号控制 A
            Where a.记录id = n_记录id And a.预约顺序号 Is Null And a.开始时间 >= d_时段开始 And a.开始时间 < d_时段结束 And
                  数量 > (Select Count(1)
                        From 临床出诊序号控制
                        Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = a.序号 And Nvl(挂号状态, 0) <> 0);
            If Nvl(n_序号, 0) = 0 Then
              v_Temp := '本号别可用序号已经全部使用完!';
              Raise Err_Item;
            End If;
            Select 数量
            Into n_数量
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Null And 序号 = n_序号;
          End If;

          Select Count(1)
          Into n_存在
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) <> 0;
          If Nvl(n_存在, 0) >= n_数量 Then
            v_Temp := '本号别可用序号已经全部使用完!';
            Raise Err_Item;
          End If;

          Select Min(预约顺序号)
          Into n_顺序号
          From 临床出诊序号控制
          Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号 And Nvl(挂号状态, 0) = 0 And Nvl(是否停诊, 0) <> 1;
          If n_顺序号 = 0 Then
            Select Max(预约顺序号) + 1
            Into n_顺序号
            From 临床出诊序号控制
            Where 记录id = n_记录id And 预约顺序号 Is Not Null And 序号 = n_序号;
          End If;
          n_序号 := Save_Lockdata(记录id_In, n_序号, v_机器名, v_操作员姓名, 备注_In, n_顺序号);

          序号_Out := n_序号;
          Return;
        Exception
          When Others Then
            Null;
        End;
      End If;
    End If;
  Else
    --未分时段
    Null;
  End If;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_挂号安排_临床出诊_Lockno;
/

--119108:李南春,2018-03-13,并发锁号问题
Create Or Replace Procedure Zl_Third_Lockno
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:HIS锁号
  --入参:Xml_In:
  --<IN>
  --  <HM>5</HM>           //号码
  --  <CZJLID>1</CZJLID>       //出诊记录ID,出诊表排班模式下传入
  --  <RQ>2013-11-21 09:00</RQ>  //预约时间
  --  <CZ>1</CZ>           //操作
  --  <HX></HX>          //号序
  --  <HZDW>支付宝</HZDW>   //合作单位
  --  <JQM>机器名</JQM>        //机器名
  --  <SJD>时间段</SJD>        //锁号的时间段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  -- <HX>号序</HX>          //锁号操作并且成功时返回
  -- 错误信息  //出错时返回
  --</ OUTPUT>
  --------------------------------------------------------------------------------------------------
  v_号码       挂号安排.号码%Type;
  d_日期       Date;
  n_操作类型   Number(3);
  n_号序       挂号序号状态.序号%Type;
  v_操作员姓名 挂号序号状态.操作员姓名%Type;
  v_机器名     挂号序号状态.机器名%Type;
  v_合作单位   合作单位安排控制.合作单位%Type;
  v_Temp       Varchar2(32767); --临时XML
  x_Templet    Xmltype; --模板XML
  n_记录id     临床出诊记录.Id%Type;
  d_启用时间   Date;
  v_时间段     Varchar2(200);
  v_Para       Varchar2(2000);
  n_挂号模式   Number(3);
  n_序号_Out   临床出诊序号控制.序号%Type;
  n_是否预约   number(3);
  Err_Item Exception;
  
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/HM'), To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'),
         Extractvalue(Value(A), 'IN/CZ'), Extractvalue(Value(A), 'IN/HX'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/JQM'), Extractvalue(Value(A), 'IN/CZJLID'), Extractvalue(Value(A), 'IN/SJD')
  Into v_号码, d_日期, n_操作类型, n_号序, v_合作单位, v_机器名, n_记录id, v_时间段
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para := Nvl(Zl_Getsysparameter(256), '0');

  n_挂号模式 := To_Number(Substr(v_Para, 1, 1));

  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  
    If Nvl(d_日期, Sysdate) < Nvl(d_启用时间, Sysdate) Then
      n_挂号模式 := 0;
    End If;
  End If;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;

  v_操作员姓名 := Zl_Username;
  n_是否预约:=1;
  IF trunc(d_日期)=trunc(SYSDATE) THEN 
      n_是否预约:=0;
  END IF ;

  If Nvl(n_挂号模式, 0) = 0 Then
    --1.传统模式
    Zl_挂号安排_传统_Lockno(n_操作类型, v_号码, d_日期, n_号序, n_序号_Out, v_机器名, v_操作员姓名,NULL,NULL,n_是否预约,'移动锁号',v_合作单位, v_时间段);
  Else
    --2.临床出诊模式
    Zl_挂号安排_临床出诊_Lockno(n_操作类型, n_记录id, d_日期, n_号序, n_序号_Out,n_是否预约,'移动锁号',v_机器名, v_操作员姓名, d_启用时间, v_合作单位, v_时间段,  v_号码);
  End If;

  If n_序号_Out Is NOT Null Then
    v_Temp := '<HX>' || Nvl(n_序号_Out, 0) || '</HX>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
  End If;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Third_Lockno;
/

--119108:李南春,2018-03-13,并发锁号问题
Create Or Replace Function Zl_Fun_挂号安排_传统_Nextsn
(
  日期_In       In Date,
  安排id_In     In 挂号安排.Id%Type,
  计划id_In     In 挂号安排计划.Id%Type,
  操作员姓名_In 人员表.姓名%Type,
  星期_In       In 挂号安排限制.限制项目%Type := Null,
  备注_In       In 挂号序号状态.备注%Type := Null,
  机器名_In     In 挂号序号状态.机器名%Type := Null,
  合作单位_In   In Varchar2 := Null,
  是否加号_In   In Number := 0,
  是否预约_In   In Number := 0,
  是否锁号_In   In Number := 1
) Return Varchar2 Is
  --功能:根据指定安排，获取一下个序号(并进行相关的锁号操作)
  --入参:操作类型_In:0-挂号;1-预约
  --     是否加号_IN:0-不进行加号;1-进行加号处理
  --     是否锁号_In:是否进行相关的锁号操作,1-锁号;0-不进行锁号
  --返回:NULL:该挂号安排无需序号控制且不分时段或不启用序号控制且分时段但当前为挂号的
  --     非空:序号|序号开始时间(yyyy-mm-dd hh24:mm:ss)
  --     返回失败时，会抛出错误信息

  n_序号         Number(18);
  n_自锁号       Number(2);
  d_序号时间     Date;
  n_Rowid        Rowid;
  v_星期         挂号安排限制.限制项目%Type;
  v_机器名       挂号序号状态.操作员姓名%Type;
  v_操作员姓名   人员表.姓名%Type;
  n_序号控制     Number(3);
  n_分时段       Number(3);
  n_启用合作单位 Number(3);
  v_号码         挂号安排.号码%Type;
  d_Max_日期     Date;
  n_限号数       Number(18);
  n_限约数       Number(18);
  n_存在         Number(3);
  n_已挂数       Number(18);
  v_Temp         Varchar2(300);
  Err_Item Exception;

Begin
  v_星期 := 星期_In;
  If v_星期 Is Null Then
    Select Decode(To_Char(日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
  End If;
  v_机器名 := 机器名_In;

  If v_机器名 Is Null Then
    Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
  End If;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员姓名 Is Null Then
    v_操作员姓名 := Zl_Username;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Max(a.序号控制), Max(b.号码)
    Into n_序号控制, v_号码
    From 挂号安排计划 A, 挂号安排 B
    Where a.Id = 计划id_In And a.安排id = b.Id;
  End If;

  If Nvl(安排id_In, 0) <> 0 Then
    Select Max(序号控制), Max(号码) Into n_序号控制, v_号码 From 挂号安排 Where ID = 安排id_In;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Nvl(Max(1), 0), Trunc(Max(开始时间))
    Into n_分时段, d_Max_日期
    From 挂号计划时段
    Where 星期 = v_星期 And 计划id = 计划id_In And Rownum < 2;
    If 合作单位_In Is Not Null Then
      Select Nvl(Max(1), 0)
      Into n_启用合作单位
      From 合作单位计划控制
      Where 限制项目 = v_星期 And 计划id = 计划id_In And 合作单位 = 合作单位_In And Rownum < 2;
    End If;
  Else
    Select Nvl(Max(1), 0), Trunc(Max(开始时间))
    Into n_分时段, d_Max_日期
    From 挂号安排时段
    Where 星期 = v_星期 And 安排id = 安排id_In And Rownum < 2;
    If 合作单位_In Is Not Null Then
      Select Nvl(Max(1), 0)
      Into n_启用合作单位
      From 合作单位安排控制
      Where 限制项目 = v_星期 And 安排id = 安排id_In And 合作单位 = 合作单位_In And Rownum < 2;
    End If;
  End If;

  n_序号 := Null;
  If Nvl(n_序号控制, 0) = 0 And Nvl(n_分时段, 0) = 0 Then
    --未启用序号控制和未分时段的,直接返回
    Return n_序号;
  End If;

  If Nvl(计划id_In, 0) <> 0 Then
    Select Max(限号数), Max(限约数)
    Into n_限号数, n_限约数
    From 挂号计划限制
    Where 计划id = 计划id_In And 限制项目 = v_星期;
  Else
    Select Max(限号数), Max(限约数)
    Into n_限号数, n_限约数
    From 挂号安排限制
    Where 安排id = 安排id_In And 限制项目 = v_星期;
  End If;

  --1.未启用序号控制处理
  If Nvl(n_序号控制, 0) = 0 Then
    --1.1 不是预约，无需返回序号
    If Nvl(是否预约_In, 0) = 0 Then
      Return n_序号;
    End If;
    --1.2 分时段且是预约的，需要取一下号(暂不处理,待以后扩展
    Return n_序号;
  End If;

  If Nvl(n_限约数, 0) = 0 Then
    n_限约数 := n_限号数;
  End If;

  --2.启用序号控制且分时段的处理
  If Nvl(n_分时段, 0) = 1 Then
    --2.1 先取未使用的序号(针对跨天的，不处理，因为分时段一般情况都不跨天)
    n_序号 := Null;
    For c_序号 In (Select 序号, Max(开始时间) As 开始时间
                 From (Select 序号, 开始时间
                        From 挂号安排时段
                        Where 安排id = Nvl(安排id_In, 0) And 星期 = v_星期 And
                              日期_In <= To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(结束时间, 'hh24:mi:ss'),
                                               'yyyy-mm-dd hh24:mi:ss') And
                              Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1)
                        Union All
                        Select 序号, 开始时间
                        From 挂号计划时段
                        Where 计划id = Nvl(计划id_In, 0) And 星期 = v_星期 And
                              日期_In <= To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(结束时间, 'hh24:mi:ss'),
                                               'yyyy-mm-dd hh24:mi:ss') And
                              Nvl(是否预约, 0) = Decode(Nvl(是否预约_In, 0), 0, Nvl(是否预约, 0), 1))
                 Where 序号 Not In
                       (Select 序号
                        From 挂号序号状态
                        Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60)
                 Group By 序号
                 Order By 序号) Loop
    
      --检查该序号是否被他人使用
      n_序号 := Nvl(c_序号.序号, 0);
      Begin
        Select Rowid, 1,
               Case
                 When 机器名 = v_机器名 And 操作员姓名 = v_操作员姓名 And 状态 = 5 Then
                  1
                 Else
                  0
               End
        Into n_Rowid, n_存在, n_自锁号
        From 挂号序号状态
        Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 序号 = n_序号;
      Exception
        When Others Then
          n_存在   := 0;
          n_自锁号 := 0;
      End;
    
      If Nvl(n_存在, 0) = 1 And Nvl(n_自锁号, 0) = 1 Then
        If Nvl(是否锁号_In, 0) = 1 Then
          --自己锁的号，独站起:
          Update 挂号序号状态 Set 状态 = 5 Where Rowid = n_Rowid;
        End If;
        v_Temp := n_序号 || '|' || To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(c_序号.开始时间, 'hh24:mi:ss');
        Return v_Temp;
      End If;
    
      If Nvl(n_存在, 0) = 0 Then
        --不存在，直接锁住该号
        d_序号时间 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || ' ' || To_Char(c_序号.开始时间, 'hh24:mi:ss'),
                          'yyyy-mm-dd hh24:mi:ss');
        If Nvl(是否锁号_In, 0) = 1 Then
          Insert Into 挂号序号状态
            (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
          Values
            (v_号码, d_序号时间, n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
        End If;
      
        v_Temp := n_序号 || '|' || To_Char(d_序号时间, 'yyyy-mm-dd hh24:mi:ss');
        Return v_Temp;
      End If;
    End Loop;
  
    --2.2 再取最大号+1的序号(针对跨天的，不处理，因为分时段一般情况都不跨天)
    --    有加号权限，则不进行检查限号数
    If Nvl(是否加号_In, 0) = 0 Then
      --检查限号数是否充足
      If Nvl(是否预约_In, 0) = 0 Then
        Select Nvl(Sum(已挂数), 0)
        Into n_已挂数
        From 病人挂号汇总 A
        Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
        If n_已挂数 >= n_限号数 And Nvl(n_限号数, 0) <> 0 Then
          v_Temp := '号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
      Else
        Select Nvl(Sum(已约数), 0)
        Into n_已挂数
        From 病人挂号汇总 A
        Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
        If Nvl(n_已挂数, 0) >= n_限约数 And Nvl(n_限约数, 0) <> 0 Then
          v_Temp := '号别' || v_号码 || '当前已无余号';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --取最大号+1
    Select Nvl(Max(序号), 0) + 1, Max(结束时间)
    Into n_序号, d_序号时间
    From (Select 序号, 结束时间
           From 挂号安排时段
           Where 安排id = Nvl(安排id_In, 0) And 星期 = v_星期
           Union All
           Select 序号, 结束时间
           From 挂号计划时段
           Where 计划id = Nvl(计划id_In, 0) And 星期 = v_星期
           Union All
           Select 序号, Null As 结束时间
           From 挂号序号状态 A
           Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60);
  
    v_Temp     := To_Char(d_序号时间, 'hh24:mi:ss');
    d_序号时间 := To_Date(To_Char(日期_In, 'yyyy-mm-dd') || To_Char(d_序号时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss');
    If Nvl(是否锁号_In, 0) = 1 Then
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (v_号码, d_序号时间, n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    v_Temp := n_序号 || '|' || To_Char(d_序号时间, 'yyyy-mm-dd hh24:mi:ss');
    Return v_Temp;
  End If;

  --3.启用序号控制但不分时段的处理
  n_序号 := Null;

  --3.1先判断未使用的序号
  Select Min(序号)
  Into n_序号
  From (Select Level As 序号
         From Dual
         Connect By Level <= Nvl(n_限号数, 0)
         Minus
         Select 序号
         From 挂号序号状态
         Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And
               (nvl(状态,0) <> 5 Or nvl(状态,0) = 5 And Nvl(机器名, '-') <> Nvl(v_机器名, '-') And Nvl(操作员姓名, '-') <> Nvl(v_操作员姓名, '-')));

  If Nvl(n_序号, 0) <> 0 Then
    If Nvl(是否锁号_In, 0) = 1 Then
      --存在:返回找到的序号
      Insert Into 挂号序号状态
        (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
      Values
        (v_号码, Trunc(日期_In), n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
    End If;
    v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
    Return v_Temp;
  End If;

  --已经补使用完的号，则需要最大号+1
  If Nvl(是否加号_In, 0) = 0 Then
    --检查限号数是否充足
    If Nvl(是否预约_In, 0) = 0 Then
      Select Nvl(Sum(已挂数), 0)
      Into n_已挂数
      From 病人挂号汇总 A
      Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
      If n_已挂数 >= n_限号数 And Nvl(n_限号数, 0) <> 0 Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    Else
      Select Nvl(Sum(已约数), 0)
      Into n_已挂数
      From 病人挂号汇总 A
      Where 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60 And 号码 = v_号码;
      If Nvl(n_已挂数, 0) >= n_限约数 And Nvl(n_限约数, 0) <> 0 Then
        v_Temp := '号别' || v_号码 || '当前已无余号';
        Raise Err_Item;
      End If;
    End If;
  End If;
  Select Nvl(Max(序号), 0) + 1
  Into n_序号
  From 挂号序号状态 A
  Where 号码 = v_号码 And 日期 Between Trunc(日期_In) And Trunc(日期_In) + 1 - 1 / 24 / 60 / 60;
  If Nvl(是否锁号_In, 0) = 1 Then
    Insert Into 挂号序号状态
      (号码, 日期, 序号, 状态, 操作员姓名, 备注, 登记时间, 机器名)
    Values
      (v_号码, Trunc(日期_In), n_序号, 5, v_操作员姓名, 备注_In, Sysdate, v_机器名);
  End If;
  v_Temp := n_序号 || '|' || To_Char(Sysdate, 'yyyy-mm-dd hh24:mi:ss');
  Return v_Temp;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Temp || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_Fun_挂号安排_传统_Nextsn;
/

--122597:秦龙,2018-03-09,增加过程用于清空药品规格里的某些字段
Create Or Replace Procedure Zl_药品规格_字段清空
(
  药品id_In   In 药品规格.药品id%Type,
  更新属性_In In 药品规格.药品id%Type := 0 --0,更新图片;1-更新说明
) Is
  Err_Notfind Exception;
Begin
  If 更新属性_In = 0 Then
    Update 药品规格 Set 图片 = Null Where 药品id = 药品id_In;
  Elsif 更新属性_In = 1 Then
    Update 药品规格 Set 使用说明 = Null Where 药品id = 药品id_In;
  End If;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该规格不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品规格_字段清空;
/

--115120:李小东,2018-03-08,标本合并后重算参考值
Create Or Replace Procedure Zl_检验标本记录_Union
(
  Sourcesampleid In 检验标本记录.Id%Type,
  Unionsampleid  In 检验标本记录.Id%Type,
  Resultexample  In Varchar2 := Null
) Is
  Cursor u_Sample Is
    Select ID, 检验标本id, 检验项目id, 检验结果, 结果标志, 结果参考, 记录类型, 原始结果, 原始记录时间, 记录者, 仪器id
    From 检验普通结果
    Where 检验标本id = Unionsampleid;
  v_Itemid   Number;
  v_Flag     Number(3);
  v_Result   Varchar2(2000);
  v_Code     Varchar2(100);
  v_结果参考 Varchar2(20);
  v_结果标志 Varchar2(20);
Begin
  For r_Sample In u_Sample Loop
    Select Nvl(Max(检验项目id), 0)
    Into v_Itemid
    From 检验普通结果
    Where 检验标本id = Sourcesampleid And 检验项目id = r_Sample.检验项目id;
  
    If v_Itemid = 0 Then
      Insert Into 检验普通结果
        (ID, 检验标本id, 检验项目id, 检验结果, 结果标志, 结果参考, 记录类型, 原始结果, 原始记录时间, 记录者, 仪器id)
      Values
        (检验普通结果_Id.Nextval, Sourcesampleid, r_Sample.检验项目id, r_Sample.检验结果, r_Sample.结果标志, r_Sample.结果参考, r_Sample.记录类型,
         r_Sample.原始结果, r_Sample.原始记录时间, r_Sample.记录者, r_Sample.仪器id);
    
      Insert Into 检验项目分布
        (ID, 标本id, 项目id, 医嘱id, 范围)
      Values
        (检验项目分布_Id.Nextval, Sourcesampleid, r_Sample.检验项目id, Null, 1);
    Else
      Update 检验普通结果
      Set 检验结果 = r_Sample.检验结果, 结果标志 = r_Sample.结果标志, 结果参考 = r_Sample.结果参考, 记录者 = r_Sample.记录者, 仪器id = r_Sample.仪器id
      Where 检验项目id = v_Itemid And 检验标本id = Sourcesampleid;
    End If;
  
    Delete 检验标本记录 Where ID = Unionsampleid;
    Select Count(*) Into v_Flag From 检验普通结果 Where 检验标本id = Sourcesampleid And 检验结果 Is Null;
    Update 检验标本记录 Set 结果为空 = v_Flag Where ID = Sourcesampleid;
  End Loop;

  If Not Resultexample Is Null Then
    --标本合并后获取新的结果参考和结果标志
    v_Result := Resultexample || ';';
    While Not v_Result Is Null Loop
      v_Code     := Substr(v_Result, 1, Instr(v_Result, ';') - 1);
      v_Itemid   := Substr(v_Code, 1, Instr(v_Code, ',') - 1);
      v_Code     := Substr(v_Code, Instr(v_Code, ',') + 1);
      v_结果参考 := Substr(v_Code, 1, Instr(v_Code, ',') - 1);
      v_结果标志 := Substr(v_Code, Instr(v_Code, ',') + 1);
      v_Result   := Substr(v_Result, Instr(v_Result, ';') + 1);
    
      Update 检验普通结果
      Set 结果标志 = v_结果标志, 结果参考 = v_结果参考
      Where 检验项目id = v_Itemid And 检验标本id = Sourcesampleid;
    End Loop;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验标本记录_Union;
/

--121419:刘鹏飞,2018-03-08,医生下达用血申请确定发放血液
Create Or Replace Procedure Zl_输血申请项目_Upate
(
  医嘱id_In In 输血申请记录.医嘱id%Type,
  Para_In   In Varchar2
) Is
  Strdata      Varchar2(1000);
  Intpos       Number(5);
  Strtext      Varchar2(100);
  n_诊疗项目id 输血申请项目.诊疗项目id%Type;
  n_申请量     输血申请项目.申请量%Type;
  v_申请血型   输血申请项目.申请血型%Type;
  v_申请rh     输血申请项目.申请rh%Type;
  v_血液信息   输血申请项目.血液信息%Type;
Begin
  --删除所有体温部位
  Delete 输血申请项目 Where 医嘱id = 医嘱id_In;
  --参数格式为 诊疗项目ID,申请量,申请血型,申请RH,血液收发ID串;诊疗项目ID,申请量,申请血型,申请RH,血液收发ID串.....
  ------------血液收发ID串存放血液收发记录的ID，多个ID之间以'|'号分割,只有用血申请采用医生下达申请确定血液的模式才会有
  Strdata := Para_In;
  Intpos  := Instr(Strdata, ';', 1);
  If Intpos > 0 Then
    Strtext := Substr(Strdata, 1, Instr(Strdata, ';', 1) - 1);
    Strdata := Substr(Strdata, Instr(Strdata, ';', 1) + 1);
  Else
    Strtext := Strdata;
    Strdata := '';
  End If;

  While Strtext Is Not Null Loop
    n_诊疗项目id := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    n_申请量     := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    v_申请血型   := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
    Strtext      := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    Intpos       := Instr(Strtext, ',', 1);
    If Intpos > 0 Then
      v_申请rh   := Substr(Strtext, 1, Instr(Strtext, ',', 1) - 1);
      v_血液信息 := Substr(Strtext, Instr(Strtext, ',', 1) + 1);
    Else
      v_血液信息 := '';
      v_申请rh   := Strtext;
    End If;
  
    Insert Into 输血申请项目
      (医嘱id, 诊疗项目id, 申请量, 申请血型, 申请rh, 血液信息)
    Values
      (医嘱id_In, n_诊疗项目id, n_申请量, v_申请血型, v_申请rh, v_血液信息);
  
    Intpos := Instr(Strdata, ';', 1);
    If Intpos > 0 Then
      Strtext := Substr(Strdata, 1, Instr(Strdata, ';', 1) - 1);
      Strdata := Substr(Strdata, Instr(Strdata, ';', 1) + 1);
    Else
      Strtext := Strdata;
      Strdata := '';
    End If;
  End Loop;

Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_输血申请项目_Upate;
/

--122597:秦龙,2018-03-08,药品规格增加图片和使用说明
Create Or Replace Function Zl_Lob_Read
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Pos_In     In Number,
  Moved_In   In Number := 0,
  Lobtype_In In Number := 0
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式(图形);8-电子病历附件;9-体温重叠标记;
  --        10-临床路径文件;11-临床路径图标;12-病历页面格式(页眉文件);13-病历页面格式(页脚文件);
  --        14-人员证书记录;17-药品规格(使用说明);18-药品规格(图片);19-部门扩展信息;20-人员扩展信息;22-医嘱报告内容;23-供应商照片;24-自定义申请单文件;25-医嘱申请单文件
  --Key_In：数据记录的关键字
  --Pos_In：从0开始不断读取，直到返回为空
  --Moved_In: 0正常记录,1读取转储后备表记录
  --LobType_IN:0-BLOb,1-CLOB
) Return Varchar2 Is
  l_Blob   Blob;
  l_Clob   Clob;
  v_Buffer Varchar2(32767);
  n_Amount Number := 2000;
  n_Offset Number := 1;
  t_Key    t_Strlist;
Begin
  If Tab_In = 0 Then
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In;
  Elsif Tab_In = 1 Then
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 2 Then
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 3 Then
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In);
  Elsif Tab_In = 4 Then
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In);
  Elsif Tab_In = 5 Then
    If Moved_In = 0 Then
      Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In);
    Else
      Select 内容 Into l_Blob From H电子病历格式 Where 文件id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 6 Then
    If Moved_In = 0 Then
      Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In);
    Else
      Select 图形 Into l_Blob From H电子病历图形 Where 对象id = To_Number(Key_In);
    End If;
  Elsif Tab_In = 7 Then
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 8 Then
    If Moved_In = 0 Then
      Select 内容
      Into l_Blob
      From 电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    Else
      Select 内容
      Into l_Blob
      From H电子病历附件
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
  Elsif Tab_In = 9 Then
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In);
  Elsif Tab_In = 10 Then
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
  Elsif Tab_In = 11 Then
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In);
  Elsif Tab_In = 12 Then
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 13 Then
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
  Elsif Tab_In = 17 Then
    Select 使用说明 Into l_Clob From 药品规格 Where 药品id = To_Number(Key_In);
  Elsif Tab_In = 18 Then
    Select 图片 Into l_Blob From 药品规格 Where 药品id = To_Number(Key_In);
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
  Elsif Tab_In = 22 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    Select 内容 Into l_Blob From 医嘱报告内容 Where ID = To_Number(Key_In);
  Elsif Tab_In = 23 Then
    If To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=0 Then
       Select 许可证号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    Elsif  To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=1 Then
       Select 执照号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    Elsif To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=2 Then
       Select 授权号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
    End If;
  Elsif Tab_In = 24 Then
    Select 内容
    Into l_Clob
    From 自定义申请单文件
    Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
          类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) ;
  Elsif Tab_In = 25 Then
    Select 内容
    Into l_Clob
    From 医嘱申请单文件
    Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
          类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) ;
  End If;

  n_Offset := n_Offset + Pos_In * n_Amount;
  If Lobtype_In = 1 Then
    If l_Clob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Clob, n_Amount, n_Offset, v_Buffer);
    End If;
  Else
    If l_Blob Is Null Then
      v_Buffer := Null;
    Else
      Dbms_Lob.Read(l_Blob, n_Amount, n_Offset, v_Buffer);
    End If;
  End If;
  Return v_Buffer;
Exception
  When No_Data_Found Then
    Return Null;
End Zl_Lob_Read;
/

--122597:秦龙,2018-03-08,药品规格中增加保存图片和说明
Create Or Replace Procedure Zl_Lob_Append
(
  Tab_In     In Number,
  Key_In     In Varchar2,
  Txt_In     In Varchar2, --16进制的文件片段或文字片段
  Cls_In     In Number := 0, --是否清除原来的内容，第一片段传递时为1，以后为0
  Lobtype_In In Number := 0 --0-BLOB;1-CLOB
  --参数说明：
  --Tab_In：包含LOB的数据表
  --        0-病历标记图形;1-病历文件格式;2-病历文件图形;3-病历范文格式;4-病历范文图形;
  --        5-电子病历格式;6-电子病历图形;7-病历页面格式；8-电子病历附件;9-体温重叠标记
  --        10-临床路径文件,11-临床路径图标;14-人员证书记录;
  --        17-药品规格(使用说明);18-药品规格(图片);19-部门扩展信息;20-人员扩展信息;22-医嘱报告内容;23-供应商照片;24-自定义申请单文件;25-医嘱申请单文件
  --Key_In：数据记录的关键字
  --Txt_In：16进制的文件片段或文字片段
  --Cls_In：是否清除原来的内容，第一片段传递时为1，以后为0
  --Lobtype_In:--0-BLOB;1-CLOB
) Is
  l_Blob Blob;
  l_Clob Clob;
  t_Key  t_Strlist;

Begin
  If Tab_In = 0 Then
    If Cls_In = 1 Then
      Update 病历标记图形 Set 图形 = Empty_Blob() Where 编码 = Key_In;
    End If;
    Select 图形 Into l_Blob From 病历标记图形 Where 编码 = Key_In For Update;
  Elsif Tab_In = 1 Then
    If Cls_In = 1 Then
      Update 病历文件格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历文件格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 2 Then
    If Cls_In = 1 Then
      Update 病历文件图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历文件图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历文件图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 3 Then
    If Cls_In = 1 Then
      Update 病历范文格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 病历范文格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 4 Then
    If Cls_In = 1 Then
      Update 病历范文图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 病历范文图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 病历范文图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 5 Then
    If Cls_In = 1 Then
      Update 电子病历格式 Set 内容 = Empty_Blob() Where 文件id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历格式 (文件id, 内容) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 内容 Into l_Blob From 电子病历格式 Where 文件id = To_Number(Key_In) For Update;
  Elsif Tab_In = 6 Then
    If Cls_In = 1 Then
      Update 电子病历图形 Set 图形 = Empty_Blob() Where 对象id = To_Number(Key_In);
      If Sql%RowCount = 0 Then
        Insert Into 电子病历图形 (对象id, 图形) Values (To_Number(Key_In), Empty_Blob());
      End If;
    End If;
    Select 图形 Into l_Blob From 电子病历图形 Where 对象id = To_Number(Key_In) For Update;
  Elsif Tab_In = 7 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 图形 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 图形
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 8 Then
    If Cls_In = 1 Then
      Update 电子病历附件
      Set 内容 = Empty_Blob()
      Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 电子病历附件
    Where 病历id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 序号 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 9 Then
    If Cls_In = 1 Then
      Update 体温重叠标记 Set 标记图形 = Empty_Blob() Where 序号 = To_Number(Key_In);
    End If;
    Select 标记图形 Into l_Blob From 体温重叠标记 Where 序号 = To_Number(Key_In) For Update;
  Elsif Tab_In = 10 Then
    If Cls_In = 1 Then
      Update 临床路径文件
      Set 内容 = Empty_Blob()
      Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            文件名 = Substr(Key_In, Instr(Key_In, ',') + 1);
    End If;
    Select 内容
    Into l_Blob
    From 临床路径文件
    Where 路径id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 文件名 = Substr(Key_In, Instr(Key_In, ',') + 1)
    For Update;
  Elsif Tab_In = 11 Then
    If Cls_In = 1 Then
      Update 临床路径图标 Set 图标 = Empty_Blob() Where ID = To_Number(Key_In);
    End If;
    Select 图标 Into l_Blob From 临床路径图标 Where ID = To_Number(Key_In) For Update;
  Elsif Tab_In = 12 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页眉文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页眉文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 13 Then
    If Cls_In = 1 Then
      Update 病历页面格式
      Set 页脚文件 = Empty_Blob()
      Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3);
    End If;
    Select 页脚文件
    Into l_Blob
    From 病历页面格式
    Where 种类 = To_Number(Substr(Key_In, 1, 1)) And 编号 = Substr(Key_In, 3)
    For Update;
  Elsif Tab_In = 14 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员证书记录 Set 签章信息 = Empty_Clob() Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2);
    End If;
    Select 签章信息 Into l_Clob From 人员证书记录 Where 人员id = To_Number(t_Key(1)) And Certsn = t_Key(2) For Update;
  Elsif Tab_In = 17 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 药品规格 Set 使用说明 = Empty_Clob() Where 药品id = To_Number(t_Key(1));
    End If;
    Select 使用说明 Into l_Clob From 药品规格 Where 药品id = To_Number(t_Key(1)) For Update;
  Elsif Tab_In = 18 Then
    If Cls_In = 1 Then
      Update 药品规格 Set 图片 = Empty_Blob() Where 药品id = To_Number(Key_In);
    End If;
    Select 图片 Into l_Blob From 药品规格 Where 药品id = To_Number(Key_In) For Update;
  Elsif Tab_In = 19 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 部门扩展信息 Set 图片 = Empty_Blob() Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 部门扩展信息 Where 部门id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 部门表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 20 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 人员扩展信息 Set 图片 = Empty_Blob() Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2);
    End If;
    Select 图片 Into l_Blob From 人员扩展信息 Where 人员id = To_Number(t_Key(1)) And 项目 = t_Key(2) For Update;
    Update 人员表 Set 最后修改时间 = Sysdate Where ID = To_Number(t_Key(1));
  Elsif Tab_In = 22 Then
    Select Column_Value Bulk Collect Into t_Key From Table(f_Str2list(Key_In));
    If Cls_In = 1 Then
      Update 医嘱报告内容 Set 内容 = Empty_Blob() Where ID = To_Number(t_Key(1));
    End If;
    Select 内容 Into l_Blob From 医嘱报告内容 Where ID = To_Number(t_Key(1)) For Update;
  Elsif Tab_In = 23 Then
    If To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=0 Then
      If Cls_In = 1 Then
        Update 供应商照片 Set 许可证号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 许可证号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    Elsif  To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=1 Then
      If Cls_In = 1 Then
        Update 供应商照片 Set 执照号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 执照号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    Elsif To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))=2 Then
     If Cls_In = 1 Then
        Update 供应商照片 Set 授权号照片 = Empty_Blob() Where 供应商ID = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1));
        If Sql%RowCount = 0 Then
          Insert Into 供应商照片 (供应商ID, 许可证号照片,执照号照片,授权号照片) Values (To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)), Empty_Blob(), Empty_Blob(), Empty_Blob());
        End If;
      End If;
      Select 授权号照片 Into l_Blob From 供应商照片 Where 供应商ID =To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) For Update;
    End If;
  Elsif Tab_In = 24 Then
    If Cls_In = 1 Then
      Update 自定义申请单文件
      Set 内容 = Empty_Clob()
      Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And
            类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) ;
    End If;
    Select 内容
    Into l_Clob
    From 自定义申请单文件
    Where 文件id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) 
    For Update;
  ElsIf Tab_In = 25 Then
    If Cls_In = 1 Then
      Update 医嘱申请单文件
      Set 内容 = Empty_Clob()
      Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 
            类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1))  ;
    End If;
    Select 内容
    Into l_Clob
    From 医嘱申请单文件
    Where 医嘱id = To_Number(Substr(Key_In, 1, Instr(Key_In, ',') - 1)) And 类别 = To_Number(Substr(Key_In, Instr(Key_In, ',') + 1)) 
    For Update;
  End If;

  If Lobtype_In = 1 Then
    Dbms_Lob.Writeappend(l_Clob, Length(Txt_In), Txt_In);
  Else
    Dbms_Lob.Writeappend(l_Blob, Length(Hextoraw(Txt_In)) / 2, Hextoraw(Txt_In));
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Lob_Append;
/

--122576:蔡青松,2018-03-09,自动发料退料
--122605:蔡青松,2018-03-07,门诊记账病人不退料
Create Or Replace Procedure Zl_检验预置条码_采集完成
(
  医嘱内容_In Varchar2, --内容包括多个医嘱ID使用","分隔 
  人员编号_In 人员表.编号%Type := Null,
  人员姓名_In 人员表.姓名%Type := Null, --Null=取消，不为空时完成采集
  操作_In     Number := 0, --0=完成采集，1=取消采集
  医嘱类别_In Number := 0 --0=检验医嘱,1=输血医嘱 
) Is
  n_自动发料 Number;
  --查找当前标本的相关申请 
  Cursor c_Samplequest(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct ID As 医嘱id, 病人来源
    From 病人医嘱记录 A, 病人医嘱发送 B
    Where a.Id = b.医嘱id And b.接收人 Is Null And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
          a.Id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)));

  --未审核的费用行(不包含药品) 
  Cursor c_Verify(v_医嘱id In Varchar2) Is
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 住院费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In (Select ID
                       From 病人医嘱记录
                       Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                             Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 接收人 Is Null)
    Union All
    Select /*+ rule */
    Distinct 记录性质, NO, 序号, 记录状态, 门诊标志
    From 门诊费用记录
    Where 收费类别 Not In ('5', '6', '7') And
          医嘱序号 + 0 In (Select ID
                       From 病人医嘱记录
                       Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                             Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 记帐费用 = 1 And 记录状态 = 0 And 价格父号 Is Null And
          (记录性质, NO) In (Select 记录性质, NO
                         From 病人医嘱附费
                         Where 医嘱id In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist)))
                         Union All
                         Select 记录性质, NO
                         From 病人医嘱发送
                         Where 医嘱id In (Select ID
                                        From 病人医嘱记录
                                        Where ID In (Select * From Table(Cast(f_Num2list(v_医嘱id) As Zltools.t_Numlist))) And
                                              Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 接收人 Is Null)
    Order By 记录性质, NO, 序号;

  v_检验标本记录 Number(18);
  v_执行状态     Number(1);
  v_接收人       Varchar2(50);
  v_Error        Varchar2(100);
  v_No           病人医嘱发送.No%Type;
  v_性质         病人医嘱发送.记录性质%Type;
  v_序号         Varchar2(1000);

  v_收发ids Varchar2(4000);
  n_库房id  Number;
  n_发料号  Number;

  Err_Custom Exception;
  n_Par Number;
Begin
  Select zl_GetSysParameter('自动发料退料', 1211) Into n_自动发料 From Dual;
  If 人员姓名_In Is Not Null And 操作_In = 0 Then
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能完成采集!';
      Raise Err_Custom;
    End If;
  
    --检查医嘱是否收费
    n_Par := Zl_To_Number(Nvl(zl_GetSysParameter(163), '0'));
    If n_Par = 1 Then
      For r_Verify In c_Verify(医嘱内容_In) Loop
        If r_Verify.记录状态 = 0 Then
          If r_Verify.门诊标志 = 1 Then
            v_Error := '标本未收费，不允许执行，请联系管理员！';
            Raise Err_Custom;
          Elsif r_Verify.门诊标志 = 2 Then
            v_Error := '标本未记账，不允许执行，请联系管理员！';
            Raise Err_Custom;
          End If;
        End If;
      End Loop;
    End If;
  
    Update /*+ rule */ 检验拒收记录
    Set 重采人 = 人员姓名_In, 重采时间 = Sysdate
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新采集信息(检验和采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = 人员姓名_In, 采样时间 = Sysdate, 执行状态 = Decode(执行状态, 2, 0, 执行状态),
        重采标本 = Decode(Nvl(重采标本, 0), 0, Decode(执行状态, 2, 1, 0), 重采标本), 执行说明 = Null
    Where 医嘱id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
  
    --更新医嘱和费用记录 
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录 A, 病人医嘱发送 B
                              Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
                                    b.执行状态 In (0, 2) And b.接收人 Is Null));
      Else
        --发料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select a.记录性质, a.记录状态, b.Id, b.库房id
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And b.审核人 Is Null And
                                (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                 From 病人医嘱附费
                                 Where 医嘱id = r_Samplequest.医嘱id
                                 Union All
                                 Select 医嘱id, 记录性质, NO
                                 From 病人医嘱发送
                                 Where 医嘱id In
                                       (Select ID
                                        From 病人医嘱记录 A, 病人医嘱发送 B
                                        Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And
                                              Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And b.执行状态 In (0, 2) And b.接收人 Is Null))) Loop
            If Mod(Nvl(c_Stuff.记录性质, 0), 10) = 1 And Nvl(c_Stuff.记录状态, 0) = 1 Then
              If n_发料号 Is Null Then
                n_发料号 := Nextno(20);
              End If;
            
              If c_Stuff.库房id <> Nvl(n_库房id, 0) Then
                If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
                  v_收发ids := Substr(v_收发ids, 2);
                  Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
                End If;
              
                n_库房id  := c_Stuff.库房id;
                v_收发ids := Null;
              End If;
            
              v_收发ids := v_收发ids || '|' || c_Stuff.Id || ',0';
            End If;
          End Loop;
          If Nvl(n_库房id, 0) <> 0 And v_收发ids Is Not Null Then
            v_收发ids := Substr(v_收发ids, 2);
            Zl_药品收发记录_批量发料(v_收发ids, n_库房id, 人员姓名_In, Sysdate, 1, 人员姓名_In, n_发料号, 人员姓名_In);
          End If;
        End If;
      
        --2.费用执行处理 
        Update 门诊费用记录
        Set 执行状态 = 1, 执行时间 = Sysdate, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录 A, 病人医嘱发送 B
                              Where a.Id = b.医嘱id And r_Samplequest.医嘱id In (a.Id) And Sign(Nvl(a.相关id, 0)) = 医嘱类别_In And
                                    b.执行状态 In (0, 2) And b.接收人 Is Null));
      End If;
	  v_收发ids := Null;
    End Loop;
  
    --更新执行状态(只更新采集） 
    Update /*+ rule */ 病人医嘱发送
    Set 执行状态 = 1, 完成人 = 人员姓名_In, 完成时间 = Sysdate
    Where 医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))) And
                         Sign(Nvl(相关id, 0)) = 医嘱类别_In);
    --3.自动审核记帐 
    For r_Verify In c_Verify(医嘱内容_In) Loop
      If r_Verify.No || ',' || r_Verify.记录性质 <> v_No || ',' || v_性质 Then
        If v_序号 Is Not Null Then
          If v_性质 = 1 Then
            Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          Elsif v_性质 = 2 Then
            Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
          End If;
        End If;
        v_序号 := Null;
      End If;
      v_No   := r_Verify.No;
      v_性质 := r_Verify.记录性质;
      v_序号 := v_序号 || ',' || r_Verify.序号;
    End Loop;
    If v_序号 Is Not Null Then
      If v_性质 = 1 Then
        Zl_门诊记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      Elsif v_性质 = 2 Then
        Zl_住院记帐记录_Verify(v_No, 人员编号_In, 人员姓名_In, Substr(v_序号, 2));
      End If;
    End If;
  
  Else
    --检查标本是否被核收或接收 
    Begin
      Select /*+ rule */
       Nvl(c.Id, 0), b.执行状态, b.接收人
      Into v_检验标本记录, v_执行状态, v_接收人
      From 病人医嘱记录 A, 病人医嘱发送 B, 检验标本记录 C
      Where a.Id = b.医嘱id And a.相关id = c.医嘱id(+) And
            a.Id In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist)));
    Exception
      When Others Then
        v_检验标本记录 := 0;
    End;
  
    If v_检验标本记录 <> 0 Then
      v_Error := '标本已被检验科核收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    If v_执行状态 <> 2 And v_接收人 Is Not Null Then
      v_Error := '标本已被检验科签收不能取消完成采集!';
      Raise Err_Custom;
    End If;
  
    Update /*+ rule */ 病人医嘱发送
    Set 采样人 = Null, 采样时间 = Null, 执行状态 = 0, 执行说明 = Null, 完成人 = Null, 完成时间 = Null
    Where 医嘱id In (Select ID
                   From 病人医嘱记录
                   Where ID In (Select * From Table(Cast(f_Num2list(医嘱内容_In) As Zltools.t_Numlist))));
  
    For r_Samplequest In c_Samplequest(医嘱内容_In) Loop
    
      If r_Samplequest.病人来源 = 2 Then
        --2.费用执行处理 
        Update 住院费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录
                              Where r_Samplequest.医嘱id In (ID) And Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 执行状态 In (0, 2) And
                     接收人 Is Null);
      Else
        --退料
        If n_自动发料 = 1 Then
          For c_Stuff In (Select b.Id, b.实际数量
                          From 门诊费用记录 A, 药品收发记录 B
                          Where a.Id = b.费用id And a.收费类别 = '4' And Mod(a.记录性质, 10) = 1 And a.记录状态 = 1 And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
                                b.审核人 Is Not Null And (a.医嘱序号, a.记录性质, a.No) In
                                (Select 医嘱id, 记录性质, NO
                                                       From 病人医嘱附费
                                                       Where 医嘱id = r_Samplequest.医嘱id
                                                       Union All
                                                       Select 医嘱id, 记录性质, NO
                                                       From 病人医嘱发送
                                                       Where 医嘱id In (Select ID
                                                                      From 病人医嘱记录
                                                                      Where r_Samplequest.医嘱id In (ID) And
                                                                            Sign(Nvl(相关id, 0)) = 医嘱类别_In) And
                                                             执行状态 In (0, 2) And 接收人 Is Null)) Loop
          
            Zl_材料收发记录_部门退料(c_Stuff.Id, 人员姓名_In, Sysdate, Null, Null, Null, c_Stuff.实际数量);
          End Loop;
        End If;
        --退费
        Update 门诊费用记录
        Set 执行状态 = 0, 执行时间 = Null, 执行人 = 人员姓名_In
        Where 收费类别 Not In ('5', '6', '7') And
              (医嘱序号, 记录性质, NO) In
              (Select 医嘱id, 记录性质, NO
               From 病人医嘱附费
               Where 医嘱id = r_Samplequest.医嘱id
               Union All
               Select 医嘱id, 记录性质, NO
               From 病人医嘱发送
               Where 医嘱id In (Select ID
                              From 病人医嘱记录
                              Where r_Samplequest.医嘱id In (ID) And Sign(Nvl(相关id, 0)) = 医嘱类别_In) And 执行状态 In (0, 2) And
                     接收人 Is Null);
      End If;
    End Loop;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验预置条码_采集完成;
/

--119329:冉俊明,2018-03-05,三方接口获取可挂号科室过程调整
Create Or Replace Procedure Zl_Third_Getdeptlist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取可挂号科室
  --入参:Xml_In:
  --<IN>
  --  <CXTS>14</CXTS>        //查询天数
  --  <HZDW>支付宝</HZDW>    //合作单位
  --  <ZD></ZD>              //站点
  --</IN>
  --出参:Xml_Out
  --<OUTPUT>
  -- <KSLIST>
  --  <KS>
  --    <ID>科室ID</ID>       //科室ID
  --    <MC>科室名称</MC>     //科室名称
  --    <ZDYYTS>最大可预约天数</ZDYYTS>     //最大可预约天数
  --  </KS>
  --  <KS>
  --    ...
  --  </KS>
  -- </KSLIST>
  --</OUTPUT>
  --------------------------------------------------------------------------------------------------
  x_Templet Xmltype; --模板XML
  v_Temp    Varchar2(5000); --临时XML

  n_查询天数 Number(5);
  v_合作单位 合作单位安排控制.合作单位%Type;
  v_站点     部门表.站点%Type;

  v_Para     Varchar2(4000);
  n_预约天数 Number(5);
  n_补充天数 Number(5);

  n_挂号模式 Number(3);
  d_启用时间 Date;
Begin
  x_Templet := Xmltype('<OUTPUT><KSLIST></KSLIST></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/CXTS'), Extractvalue(Value(A), 'IN/HZDW'), Nvl(Extractvalue(Value(A), 'IN/ZD'), '-')
  Into n_查询天数, v_合作单位, v_站点
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  v_Para     := zl_GetSysParameter(256);
  n_挂号模式 := To_Number(Substr(v_Para, 1, 1));
  If n_挂号模式 = 1 Then
    Begin
      d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
    Exception
      When Others Then
        d_启用时间 := Null;
    End;
  End If;
  n_预约天数 := zl_GetSysParameter(66);

  If n_挂号模式 = 0 Then
    If v_合作单位 Is Null Then
      For r_Dept In (Select a.科室id, d.名称, Max(Nvl(a.预约天数, n_预约天数)) As 预约天数
                     From 挂号安排 A, 部门表 D
                     Where a.科室id = d.Id And a.停用日期 Is Null And Nvl(d.站点, v_站点) = v_站点 And
                           (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'))
                     Group By a.科室id, d.名称) Loop
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>';
        v_Temp := v_Temp || '<ZDYYTS>' || r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    Else
      For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                     From (
                            --1.计划
                            Select a.科室id, d.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                            From 挂号安排 A, 挂号安排计划 C, 部门表 D
                            Where a.Id = c.安排id And a.科室id = d.Id And a.停用日期 Is Null And c.审核时间 Is Not Null And
                                  Not (c.失效时间 < Sysdate Or c.生效时间 > Sysdate + Nvl(n_查询天数, Nvl(a.预约天数, n_预约天数)))
                                 
                                  And
                                  (Not Exists (Select 1 From 合作单位计划控制 Where 计划id = c.Id And 合作单位 = v_合作单位) Or Exists
                                   (Select 1
                                    From 合作单位计划控制
                                    Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 <> 0))
                                 
                                  And Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd'))
                            --2.安排
                            Union All
                            Select a.科室id, d.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                            From 挂号安排 A, 部门表 D
                            Where a.科室id = d.Id And a.停用日期 Is Null And Not Exists
                             (Select 1 From 挂号安排计划 Where 安排id = a.Id)
                                 
                                  And
                                  (Not Exists (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位) Or Exists
                                   (Select 1
                                    From 合作单位安排控制
                                    Where 安排id = a.Id And 合作单位 = v_合作单位 And 数量 <> 0))
                                 
                                  And Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Group By 科室id, 名称) Loop
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>';
        v_Temp := v_Temp || '<ZDYYTS>' || r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End If;
  Else
    --出诊表排班模式
    n_补充天数 := Zl_Fun_Getappointmentdays;
    If v_合作单位 Is Null Then
      For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                     From (
                            --启用前
                            Select a.科室id, d.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                            From 挂号安排 A, 部门表 D
                            Where a.科室id = d.Id And a.停用日期 Is Null And Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')) And Sysdate < d_启用时间
                            --启用后
                            Union All
                            Select a.科室id, d.名称, Nvl(c.预约天数, n_预约天数) + n_补充天数 As 预约天数
                            From 临床出诊记录 A, 临床出诊号源 C, 部门表 D
                            Where a.号源id = c.Id And a.科室id = d.Id And a.出诊日期 Between Trunc(Sysdate) And
                                  Trunc(Sysdate) + Nvl(n_查询天数, Nvl(c.预约天数, n_预约天数) + n_补充天数) And a.开始时间 > d_启用时间 And
                                  Nvl(a.是否发布, 0) = 1
                                 --排除全时段停诊了的
                                  And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                                  a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                                   (Select 1
                                        From 临床出诊序号控制
                                        Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And
                                              Nvl(a.是否分时段, 0) = 1 And 开始时间 <> 终止时间 And 开始时间 >= Sysdate))
                                 --
                                  And (c.撤档时间 Is Null Or c.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Group By 科室id, 名称) Loop
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>';
        v_Temp := v_Temp || '<ZDYYTS>' || r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    Else
      For r_Dept In (Select 科室id, 名称, Max(预约天数) As 预约天数
                     From (
                            --1.启用前
                            --1.1.计划
                            Select a.科室id, d.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                            From 挂号安排 A, 挂号安排计划 C, 部门表 D
                            Where a.Id = c.安排id And a.科室id = d.Id And a.停用日期 Is Null And c.审核时间 Is Not Null And
                                  Not (c.失效时间 < Sysdate Or c.生效时间 > Sysdate + Nvl(n_查询天数, Nvl(a.预约天数, n_预约天数)))
                                 
                                  And
                                  (Not Exists (Select 1 From 合作单位计划控制 Where 计划id = c.Id And 合作单位 = v_合作单位) Or Exists
                                   (Select 1
                                    From 合作单位计划控制
                                    Where 计划id = c.Id And 合作单位 = v_合作单位 And 数量 <> 0))
                                 
                                  And Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')) And Sysdate < d_启用时间
                            --1.2.安排
                            Union All
                            Select a.科室id, d.名称, Nvl(a.预约天数, n_预约天数) As 预约天数
                            From 挂号安排 A, 部门表 D
                            Where a.科室id = d.Id And a.停用日期 Is Null And Not Exists
                             (Select 1 From 挂号安排计划 Where 安排id = a.Id)
                                 
                                  And
                                  (Not Exists (Select 1 From 合作单位安排控制 Where 安排id = a.Id And 合作单位 = v_合作单位) Or Exists
                                   (Select 1
                                    From 合作单位安排控制
                                    Where 安排id = a.Id And 合作单位 = v_合作单位 And 数量 <> 0))
                                 
                                  And Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')) And Sysdate < d_启用时间
                            --2.启用后
                            Union All
                            Select a.科室id, d.名称, Nvl(c.预约天数, n_预约天数) + n_补充天数 As 预约天数
                            From 临床出诊记录 A, 临床出诊号源 C, 部门表 D
                            Where a.号源id = c.Id And a.科室id = d.Id And a.出诊日期 Between Trunc(Sysdate) And
                                  Trunc(Sysdate) + Nvl(n_查询天数, Nvl(c.预约天数, n_预约天数) + n_补充天数) And a.开始时间 >= d_启用时间 And
                                  Nvl(a.是否发布, 0) = 1
                                 --排除全时段停诊了的
                                  And (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                                  a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                                   (Select 1
                                        From 临床出诊序号控制
                                        Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And
                                              Nvl(a.是否分时段, 0) = 1 And 开始时间 <> 终止时间 And 开始时间 >= Sysdate))
                                 --临床出诊记录.预约控制：0-不作预约限制;1-该号别禁止预约;2-仅禁止三方机构平台的预约
                                  And
                                  (Not Exists (Select 1
                                               From 临床出诊挂号控制记录
                                               Where 记录id = a.Id And 性质 = 1 And 类型 = 1 And 名称 = v_合作单位) Or Exists
                                   (Select 1
                                    From 临床出诊挂号控制记录
                                    Where 记录id = a.Id And 性质 = 1 And 类型 = 1 And 名称 = v_合作单位
                                         --临床出诊挂号控制记录.控制方式：0-禁止预约;1-按比例控制预约;2-按总量控制预约;3-按序号控制预约;4-不作限制
                                          And (控制方式 In (1, 2, 3) And 数量 <> 0 Or 控制方式 = 4)))
                                 
                                  And (c.撤档时间 Is Null Or c.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.站点, v_站点) = v_站点 And
                                  (d.撤档时间 Is Null Or d.撤档时间 >= To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Group By 科室id, 名称) Loop
        v_Temp := '<KS>' || '<ID>' || r_Dept.科室id || '</ID>' || '<MC>' || r_Dept.名称 || '</MC>';
        v_Temp := v_Temp || '<ZDYYTS>' || r_Dept.预约天数 || '</ZDYYTS>' || '</KS>';
        Select Appendchildxml(x_Templet, '/OUTPUT/KSLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
      End Loop;
    End If;
  End If;
  Xml_Out := x_Templet;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getdeptlist;
/

--119722:秦龙,2018-03-05,增加传参来源库房、来源药房
Create Or Replace Procedure Zl_药品计划管理主表_Insert
(
  Id_In       In 药品采购计划.No%Type,
  No_In       In 药品采购计划.No%Type,
  计划类型_In In 药品采购计划.计划类型%Type,
  期间_In     In 药品采购计划.期间%Type,
  库房id_In   In 药品采购计划.库房id%Type := Null,
  药房id_In   In 药品采购计划.药房id%Type := Null,
  编制方法_In In 药品采购计划.编制方法%Type,
  编制人_In   In 药品采购计划.编制人%Type,
  编制日期_In In 药品采购计划.编制日期%Type,
  编制说明_In In 药品采购计划.编制说明%Type := Null,
  来源库房_In In 药品采购计划.来源库房%Type := Null,
  来源药房_In In 药品采购计划.来源药房%Type := Null
) Is
Begin
  Insert Into 药品采购计划
    (ID, NO, 计划类型, 期间, 库房id, 药房id, 编制方法, 编制说明, 编制人, 编制日期, 来源库房, 来源药房)
  Values
    (Id_In, No_In, 计划类型_In, 期间_In, 库房id_In, 药房id_In, 编制方法_In, 编制说明_In, 编制人_In, 编制日期_In, 来源库房_In, 来源药房_In);
End Zl_药品计划管理主表_Insert;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
Create Or Replace Procedure Zl_临床出诊表_新增跨月周出诊表
(
  年份_In     临床出诊表.年份%Type,
  月份_In     临床出诊表.月份%Type,
  周数_In     临床出诊表.周数%Type,
  开始时间_In 临床出诊安排.开始时间%Type,
  终止时间_In 临床出诊安排.终止时间%Type,
  站点_In     部门表.站点%Type,
  出诊id_In   In Out 临床出诊表.Id%Type
) As
  --检查是否跨月周出诊表， 如果是需要再新增一张周出诊表，并与原出诊表进行关联
  n_出诊id   临床出诊表.Id%Type;
  n_年份     临床出诊表.年份%Type;
  n_月份     临床出诊表.月份%Type;
  n_周数     临床出诊表.周数%Type;
  d_上月首日 Date;
Begin
  If To_Char(开始时间_In, 'mm') = To_Char(终止时间_In, 'mm') Then
    Return;
  End If;

  --1.已保存出诊表为本月第一周
  If 周数_In = 1 Then
    If 月份_In = 1 Then
      n_年份 := 年份_In - 1;
      n_月份 := 12;
    Else
      n_年份 := 年份_In;
      n_月份 := 月份_In - 1;
    End If;
    --计算上月的总周数
    d_上月首日 := To_Date(n_年份 || '-' || n_月份 || '-01', 'yyyy-mm-dd');
    Select Count(1) + Decode(To_Char(d_上月首日, 'D'), 2, 0, 1)
    Into n_周数
    From (Select d_上月首日 + Level - 1 As 日期 From Dual Connect By Level <= Add_Months(d_上月首日, 1) - d_上月首日)
    Where To_Char(日期, 'D') = 2;
  
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点, 关联id)
    Values
      (n_出诊id, 2, n_年份 || '年' || n_月份 || '月第' || n_周数 || '周出诊表', n_年份, n_月份, n_周数, 站点_In, Null);
    --将数据转移到上月的最后一周上
    Update 临床出诊表 Set 关联id = n_出诊id Where ID = 出诊id_In;
    Update 临床出诊安排 Set 出诊id = n_出诊id Where 出诊id = 出诊id_In;
    --将安排保存到新的出诊表上
    出诊id_In := n_出诊id;
    Return;
  End If;

  --2.已保存出诊表为上月最后一周
  If 月份_In = 12 Then
    n_年份 := 年份_In + 1;
    n_月份 := 1;
  Else
    n_年份 := 年份_In;
    n_月份 := 月份_In + 1;
  End If;
  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点, 关联id)
  Values
    (临床出诊表_Id.Nextval, 2, n_年份 || '年' || n_月份 || '月第1周出诊表', n_年份, n_月份, 1, 站点_In, 出诊id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_新增跨月周出诊表;
/

--122468:殷瑞,2018-03-02,修正sql条件中参数ID写死的情况
Create Or Replace Procedure Zl_发药窗口_业务调整
(
  药房id_In In Number,
  旧窗口_In In Varchar2,
  新窗口_In In Varchar2
) Is

  Cursor c_未发数据 Is
    Select 单据, NO, 库房id
    From 未发药品记录
    Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药房参数 
  Cursor c_药房参数 Is
    Select a.参数值
    From (Select 机器名, 参数值
           From zlUserParas
           Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药窗口')) A,
         (Select 机器名, 参数值
           From zlUserParas
           Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药药房')) B
    Where a.机器名 = b.机器名 And b.参数值 = 药房id_In;

  v_未发数据 c_未发数据%RowType;
  v_药房参数 c_药房参数%RowType;
Begin
  --费用参数 
  Update zlUserParas
  Set 参数值 = 药房id_In || ':' || 新窗口_In
  Where 参数值 = 药房id_In || ':' || 旧窗口_In And
        参数id In (Select ID From zlParameters Where 参数名 In ('西药房窗口', '中药房窗口', '成药房窗口'));

  --业务数据 
  For v_未发数据 In c_未发数据 Loop
    Update 药品收发记录
    Set 发药窗口 = 新窗口_In
    Where 单据 = v_未发数据.单据 And NO = v_未发数据.No And 库房id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 门诊费用记录
    Set 发药窗口 = 新窗口_In
    Where NO = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
    Update 住院费用记录
    Set 发药窗口 = 新窗口_In
    Where NO = v_未发数据.No And 执行部门id = v_未发数据.库房id And 发药窗口 = 旧窗口_In;
  End Loop;

  Update 未发药品记录
  Set 发药窗口 = 新窗口_In
  Where 填制日期 Between Sysdate - 3 And Sysdate And 发药窗口 = 旧窗口_In And 库房id = 药房id_In;

  --药品参数 
  Update zlUserParas
  Set 参数值 = Replace(参数值, 旧窗口_In, 新窗口_In)
  Where 参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药窗口') And
        机器名 In (Select 机器名
                From zlUserParas
                Where 参数值 = 药房id_In And
                      参数id In (Select ID From zlParameters Where 系统 = 100 And 模块 = 1341 And 参数名 = '发药药房'));

  --叫号窗口 
  Update 发药窗口 Set 叫号窗口 = 新窗口_In Where 药房id = 药房id_In And 叫号窗口 = 旧窗口_In;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_发药窗口_业务调整;
/

--121873:冉俊明,2018-02-26,门诊退费时，原使用预交款进行结算的，冲销成了挂号的结算数据
Create Or Replace Procedure Zl_门诊退费结算_Modify
(
  操作类型_In     Number,
  病人id_In       门诊费用记录.病人id%Type,
  冲销id_In       病人预交记录.结帐id%Type,
  结算方式_In     Varchar2,
  冲预交_In       病人预交记录.冲预交%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  卡号_In         病人预交记录.卡号%Type := Null,
  交易流水号_In   病人预交记录.交易流水号%Type := Null,
  交易说明_In     病人预交记录.交易说明%Type := Null,
  缴款_In         病人预交记录.缴款%Type := Null,
  找补_In         病人预交记录.找补%Type := Null,
  误差金额_In     门诊费用记录.实收金额%Type := Null,
  完成退费_In     Number := 0,
  原结帐id_In     病人预交记录.结帐id%Type := Null,
  剩余转预交_In   Number := 0,
  缺省结算方式_In 结算方式.名称%Type := Null
) As
  ------------------------------------------------------------------------------------------------------------------------------
  --功能:收费结算时,修改结算的相关信息
  --操作类型_In:
  --   0-原样退
  --      原样结算一起全退,所有校对标志都为1,医保调用成功后,调整为2,完成后变成0
  --   1-普通退费方式:
  --     ①结算方式_IN:允许传入多个,格式为:"结算方式|结算金额|结算号码|结算摘要||.." ;也允许传入空.
  --   2.三方卡退费结算:
  --     ①结算方式_IN:只能传入一个结算方式,但允许包含一些辅助信息,格式为:"结算方式|结算金额|结算号码|结算摘要"
  --     ②卡类别ID_IN,卡号_IN,交易流水号_IN,交易说明_In:需要传入
  --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
  --     ①结算方式_IN:允许传入多个,格式为:结算方式|结算金额||.."
  --     ②退支票额_In:传入零
  --   4-消费卡结算:
  --     ①结算方式_IN:允许一次刷多张卡,格式为:卡类别ID|卡号|消费卡ID|消费金额||."
  --     ②退支票额_In:传入零

  -- 冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
  -- 剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
  -- 误差金额_In:存在误差费时,传入
  -- 完成退费_In:0-未完成退费;1-异常完成退费;2-完成退费
  -- 原结帐ID_IN:原样退时,传入(如果原样退未传入时,则以最后一次结帐为准)
  ------------------------------------------------------------------------------------------------------------------------------
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_结算内容 Varchar2(500);
  v_当前结算 Varchar2(50);
  v_卡号     病人医疗卡信息.卡号%Type;
  n_消费卡id 消费卡目录.Id%Type;
  n_卡类别id 病人预交记录.结算卡序号%Type;
  v_名称     Varchar2(100);
  n_自制卡   卡消费接口目录.自制卡%Type;
  n_序号     病人卡结算记录.序号%Type;
  n_Id       病人卡结算记录.Id%Type;
  n_预交id   病人预交记录.Id%Type;
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;
  n_返回值   人员缴款余额.余额%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_冲预交   病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  v_误差费   结算方式.名称%Type;
  n_记录状态 病人预交记录.记录状态%Type;

  v_退费结算 结算方式.名称%Type;
  v_No       病人预交记录.No%Type;
  n_Dec      Number; --金额小数位数

  n_Count    Number;
  n_Havenull Number;
  l_预交id   t_Numlist := t_Numlist();
  n_原结帐id 病人预交记录.结帐id%Type;
  n_重结id   病人预交记录.结帐id%Type;
  n_结帐id   病人预交记录.结帐id%Type;
  n_结算序号 病人预交记录.结帐id%Type;
  v_Msg      Varchar2(5000);
  n_会话号   病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Cursor c_Feedata Is
    Select Max(NO) As NO, Max(m.病人id) As 病人id, Max(m.登记时间) As 登记时间, Max(m.操作员编号) As 操作员编号, Max(m.操作员姓名) As 操作员姓名,
           Sum(结帐金额) As 结算金额, Max(m.缴款组id) As 缴款组id
    From 门诊费用记录 M
    Where m.结帐id = 冲销id_In;
  r_Feedata c_Feedata%RowType;

  Cursor c_Balancedata Is
    Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
    From 病人预交记录
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
  r_Balancedata c_Balancedata%RowType;

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
  
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 In (1, 3) And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, r_Balancedata.操作员编号,
                 r_Balancedata.操作员姓名, -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明,
                 合作单位, 2, 结算序号_In, Mod(记录性质, 10), n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  Open c_Feedata;
  Fetch c_Feedata
    Into r_Feedata;

  If r_Feedata.No Is Null Then
    v_Err_Msg := '未找到指定的退费记录！';
    Raise Err_Item;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --0.正式结算
  Select Count(1), Max(Decode(结算方式, Null, 1, 0)), Max(结算序号)
  Into n_Count, n_Havenull, n_结算序号
  From 病人预交记录
  Where 结帐id = 冲销id_In;

  If Nvl(n_Count, 0) = 0 Or Nvl(误差金额_In, 0) <> 0 Then
    --增加结算方式为NULL的记录
    Begin
      Select 名称 Into v_误差费 From 结算方式 Where Nvl(性质, 0) = 9;
    Exception
      When Others Then
        v_误差费 := '误差费';
    End;
  End If;

  --1.增加结算方式为空的结算数据
  If Nvl(n_Havenull, 0) = 0 Then
    n_Count := 0;
    Begin
      n_结算金额 := Round(Nvl(r_Feedata.结算金额, 0), n_Dec);
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, 2, Decode(病人id_In, 0, Null, 病人id_In), Null, r_Feedata.登记时间, r_Feedata.操作员编号,
         r_Feedata.操作员姓名, n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      --误差费(先汇总后生成误差费
      If n_结算金额 <> Nvl(r_Feedata.结算金额, 0) Then
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, Decode(病人id_In, 0, Null, 病人id_In), v_误差费, r_Feedata.登记时间, r_Feedata.操作员编号,
           r_Feedata.操作员姓名, Nvl(r_Feedata.结算金额, 0) - n_结算金额, 冲销id_In, r_Feedata.缴款组id, -1 * 冲销id_In, 1, 3, n_会话号);
      End If;
      n_结算序号 := -1 * 冲销id_In;
    Exception
      When Others Then
        n_Count := 1;
    End;
    If n_Count = 1 Then
      v_Err_Msg := '未找到指定的退费明细数据,结算操作失败！';
      Raise Err_Item;
    End If;
  End If;

  Open c_Balancedata;
  Fetch c_Balancedata
    Into r_Balancedata;

  If 操作类型_In = 0 Then
    --0.原样退
    n_原结帐id := 原结帐id_In;
    If Nvl(n_原结帐id, 0) = 0 Then
      Select Max(结帐id)
      Into n_原结帐id
      From 门诊费用记录 A,
           (Select 登记时间 From 门诊费用记录 Where NO = r_Feedata.No And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3)) B
      Where a.No = r_Feedata.No And Mod(a.记录性质, 10) = 1 And a.登记时间 = b.登记时间;
    End If;
    If Nvl(n_原结帐id, 0) = 0 Then
      v_Err_Msg := '未找到原结帐数据,不能原样退！';
      Raise Err_Item;
    End If;
  
    --1.先处理预交款
    n_结算金额 := 0;
    For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                  From 病人预交记录 A
                  Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                  Order By 收款时间 Desc) Loop
    
      n_结算金额 := n_结算金额 + v_退预交.金额;
    
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
         卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
               r_Balancedata.操作员姓名, -1 * v_退预交.金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
        From 病人预交记录
        Where ID = v_退预交.Id;
    
      Update 病人预交记录 Set 冲预交 = 冲预交 - v_退预交.金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * n_结算金额)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * n_结算金额), 1);
        n_返回值 := (-1 * n_结算金额);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
    --2.处理消费卡部分
    Zl_Square_Update(n_原结帐id, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.收款时间, r_Balancedata.结算序号, v_结算内容);
    --3.处理其他结算部分
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, r_Balancedata.收款时间, r_Balancedata.操作员编号,
             r_Balancedata.操作员姓名, -1 * 冲预交, r_Balancedata.结帐id, r_Balancedata.缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位,
             Case
               When Nvl(a.卡类别id, 0) <> 0 Then
                1
               When Nvl(a.结算卡序号, 0) <> 0 Then
                1
               When Nvl(q.预交id, 0) <> 0 Then
                1
               When Nvl(j.名称, '-') <> '-' Then
               --医保
                1
               Else
                2
             End As 校对标志, r_Balancedata.结算序号, 3, n_会话号
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id
             From 病人预交记录 M, 一卡通目录 C
             Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 In (1, 3)) Q
      Where Mod(a.记录性质, 10) <> 1 And a.记录状态 In (1, 3) And a.结算方式 = j.名称(+) And a.结算方式 Is Not Null And a.结帐id = n_原结帐id And
            a.Id = q.预交id(+) And (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
  
    --更新结算方式为NULL 的记录
    Select Sum(冲预交) Into n_返回值 From 病人预交记录 Where 结帐id = r_Balancedata.结帐id And 结算方式 Is Not Null;
    Select Sum(结帐金额)
    Into n_结算金额
    From 门诊费用记录
    Where 结帐id = r_Balancedata.结帐id And Mod(记录性质, 10) = 1;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(n_结算金额, 0) - Nvl(n_返回值, 0)
    Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  
  End If;

  n_重结id := 0;
  If 操作类型_In <> 0 Then
    --不是全退时,检查是否产生了重新收费数据的
    Begin
      Select 结帐id Into n_重结id From 病人预交记录 Where 结算序号 = n_结算序号 And 结帐id <> 冲销id_In And Rownum < 2;
    Exception
      When Others Then
        n_重结id := 0;
    End;
  End If;

  --需要处理误差金额
  If Nvl(误差金额_In, 0) <> 0 Then
    --误差费放在重收的结算记录中
    n_结帐id   := 冲销id_In;
    n_记录状态 := 2;
    If Nvl(n_重结id, 0) <> 0 Then
      n_结帐id   := n_重结id;
      n_记录状态 := 1;
    End If;
  
    Update 病人预交记录
    Set 冲预交 = Nvl(冲预交, 0) + Nvl(误差金额_In, 0)
    Where 结帐id = n_结帐id And 结算方式 = v_误差费;
    If Sql%NotFound Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 3, Null, n_记录状态, r_Balancedata.病人id, Null, Null, v_误差费, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, 误差金额_In, n_结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
         Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
    End If;
  
    Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(误差金额_In, 0) Where 结帐id = n_结帐id And 结算方式 Is Null;
    If Sql%NotFound Then
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
      Raise Err_Item;
    End If;
  End If;

  --预交款处理:如果是冲预交,需要先处理冲预交款
  If Nvl(冲预交_In, 0) <> 0 Then
    If Nvl(r_Balancedata.病人id, 0) = 0 Then
      v_Err_Msg := '不能确定病人信息,不能使用预交款结算！';
      Raise Err_Item;
    End If;
  
    n_预交金额 := 冲预交_In;
    If n_预交金额 < 0 And Nvl(剩余转预交_In, 0) = 1 Then
    
      --     ②冲预交_In:如果涉及预交款,则传入本次的退预交 传入零<0时 表示退预交款或充值;>0 时:表示冲预交款
      --     ③剩余转预交_In: 1表示将剩余退款额转换为充值金额;0表示退预交
    
      --1.先生成冲值预交:
      v_No := Nextno(11);
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 金额, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
      Values
        (病人预交记录_Id.Nextval, 1, v_No, 1, r_Balancedata.病人id, Null, '退费生成预交', v_退费结算, r_Balancedata.收款时间,
         r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
         r_Balancedata.结算序号, 0, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 1, Null, n_会话号);
    
      --更新病人余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_预交金额
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, n_预交金额, 1);
        n_返回值 := n_预交金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
      --2.生成退费记录
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_退费结算, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
           Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      Else
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, -1 * n_预交金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
           r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 + n_预交金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    If Nvl(n_预交金额, 0) < 0 And Nvl(剩余转预交_In, 0) = 0 Then
    
      n_原结帐id := 原结帐id_In;
      If Nvl(n_原结帐id, 0) = 0 Then
        Select Max(b.结帐id)
        Into n_原结帐id
        From 门诊费用记录 A, 门诊费用记录 B
        Where a.结帐id = 冲销id_In And a.No = b.No And b.记录性质 = 1 And b.记录状态 In (1, 3);
      End If;
    
      If Nvl(n_原结帐id, 0) = 0 Then
        v_Err_Msg := '未找到原结帐数据,不能原样退！';
        Raise Err_Item;
      End If;
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          For v_退预交 In (Select a.Id, Nvl(a.冲预交, 0) As 金额
                        From 病人预交记录 A
                        Where Mod(记录性质, 10) = 1 And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0
                        Order By 收款时间 Desc) Loop
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
               结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间,
                     r_Balancedata.操作员编号, r_Balancedata.操作员姓名, Nvl(n_返回值, 0), r_Balancedata.结帐id, r_Balancedata.缴款组id,
                     r_Balancedata.结算序号, 2, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号


              From 病人预交记录
              Where ID = v_退预交.Id;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
            If Sql%NotFound Then
              v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
              Raise Err_Item;
            End If;
            n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
          End Loop;
        End If;
        n_返回值 := 0;
        --2.退预交款
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(a.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1 And a.结帐id <> 冲销id_In
                      Group By NO
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 + n_预交金额 < 0 Then
            n_结算金额 := v_退预交.金额;
            n_预交金额 := n_预交金额 + v_退预交.金额;
          Else
            n_结算金额 := n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, Null, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, 卡类别id, 结算卡序号, 卡号,
                   交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      Else
        --退预交款
        n_返回值   := 0;
        n_预交金额 := -1 * n_预交金额;
      
        For v_退预交 In (Select Max(a.Id) As ID, Max(a.收款时间) As 收款时间, Sum(Nvl(a.冲预交, 0)) As 金额
                      From 病人预交记录 A,
                           (Select Distinct a.结帐id
                             From 门诊费用记录 A, 门诊费用记录 B
                             Where a.No = b.No And Mod(a.记录性质, 10) = 1 And b.结帐id = n_原结帐id) B
                      Where a.结帐id = b.结帐id And Mod(a.记录性质, 10) = 1 And Nvl(a.预交类别, 0) = 1
                      Group By NO
                      Having Sum(Nvl(a.冲预交, 0)) > 0
                      Order By 收款时间 Desc) Loop
        
          If v_退预交.金额 - n_预交金额 < 0 Then
            n_结算金额 := -1 * v_退预交.金额;
            n_预交金额 := n_预交金额 - v_退预交.金额;
          Else
            n_结算金额 := -1 * n_预交金额;
            n_预交金额 := 0;
          End If;
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id,
             结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 11, NO, 实际票号, 记录状态, 病人id, 主页id, 摘要, 结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                   r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, 卡类别id,
                   结算卡序号, 卡号, 交易流水号, 交易说明, 结算号码, 预交类别, 3, n_会话号
            From 病人预交记录
            Where ID = v_退预交.Id;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          n_返回值 := 1;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        v_Err_Msg := '未找到原始的冲预交记录,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_预交金额, 0) <> 0 Then
        v_Err_Msg := '当前退预交超过了收费结算中的冲预交款,不能回退预交款！';
        Raise Err_Item;
      End If;
    
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + (-1 * 冲预交_In)
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, (-1 * 冲预交_In), 1);
        n_返回值 := (-1 * 冲预交_In);
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Balancedata.病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    
    End If;
  
    n_预交金额 := 冲预交_In;
    If Nvl(n_预交金额, 0) > 0 Then
      --冲预交款
      --病人余额检查
      Begin
        Select Nvl(预交余额, 0) - Nvl(费用余额, 0)
        Into n_预交金额
        From 病人余额
        Where 病人id = 病人id_In And Nvl(性质, 0) = 1 And 类型 = 1;
      Exception
        When Others Then
          n_预交金额 := 0;
      End;
      If n_预交金额 < 冲预交_In Then
        v_Err_Msg := '病人的当前预交余额为 ' || LTrim(To_Char(n_预交金额, '9999999990.00')) || '，小于本次支付金额 ' ||
                     LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      n_预交金额 := 冲预交_In;
      n_结帐id   := 冲销id_In;
      If Nvl(n_重结id, 0) <> 0 Then
        n_结帐id := n_重结id;
        --总的冲预交金额 = 本次冲预交金额 + 未冲销金额
        --因为在后面会将未冲销金额全部退为预交款
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          n_预交金额 := n_预交金额 - Nvl(n_返回值, 0);
        End If;
      End If;
    
      --先缴先用
      --不包含结算方式为代收款项的预交款。
      For c_冲预交 In (Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id,
                           Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
                           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
                           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
                    From 病人预交记录 A
                    Where a.记录性质 In (1, 11) And a.病人id = 病人id_In And Nvl(a.预交类别, 2) = 1 And
                          a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
                    Group By a.No
                    Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
                    Order By 收款时间) Loop
      
        If c_冲预交.金额 - n_预交金额 < 0 Then
          n_冲预交 := c_冲预交.金额;
        Else
          n_冲预交 := n_预交金额;
        End If;
      
        If c_冲预交.结帐id = 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录
          Set 冲预交 = 0, 结帐id = n_结帐id, 结算序号 = n_结算序号, 结算性质 = 3, 会话号 = n_会话号
          Where ID = c_冲预交.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_冲预交, n_结帐id, r_Balancedata.缴款组id, 预交类别,
                 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
          From 病人预交记录
          Where NO = c_冲预交.No And 记录状态 = c_冲预交.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_冲预交
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      
        --检查是否已经处理完
        If c_冲预交.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - c_冲预交.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --检查金额是否足够
      If Abs(n_预交金额) > 0 Then
        v_Err_Msg := '病人的当前预交余额小于本次支付金额 ' || LTrim(To_Char(冲预交_In, '9999999990.00')) || ' ！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_重结id, 0) <> 0 Then
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
             结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                   r_Balancedata.收款时间, r_Balancedata.操作员姓名, r_Balancedata.操作员编号, n_返回值, 冲销id_In, r_Balancedata.缴款组id,
                   预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 结帐id = n_重结id And 记录性质 In (1, 11) And Rownum = 1;
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      
      End If;
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (病人id_In, 1, -1 * 冲预交_In, 1);
        n_返回值 := -1 * 冲预交_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  If 操作类型_In = 1 Then
    --   1-普通退费方式:
    --各个收费结算 :格式为:"结算方式|结算金额|结算号码|结算摘要||.."
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
    
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      --不判断“结算金额”是否为零，有可能已经退完，但这时结算方式为空的重结和冲销记录的冲预交之和为零
      If v_结算方式 Is Null Then
        v_结算方式 := 缺省结算方式_In;
      End If;
      --If Nvl(n_结算金额, 0) <> 0 Then
      n_结算金额 := Nvl(n_结算金额, 0);
      If Nvl(n_重结id, 0) <> 0 Then
        --肯定是收款
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
      
        If Nvl(n_返回值, 0) <> 0 Then
        
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
        --2.退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null,
             Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
        End If;
      Else
        --:>退款
        If Nvl(n_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id,
             r_Balancedata.结算序号, 2, Null, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        
          Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
          If Sql%NotFound Then
            v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
            Raise Err_Item;
          End If;
        End If;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  
  End If;

  If 操作类型_In = 2 Then
    --   2.三方卡退费结算:
  
    v_当前结算 := 结算方式_In;
    v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    n_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
    v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
    v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
  
    If Nvl(n_结算金额, 0) <> 0 Then
    
      If Nvl(n_重结id, 0) <> 0 Then
        --1.先按此种方式全退
        --2.再按此种方式收款
        --3:1+2=本次退款
        --1.先将退费的全部作废掉
        Select Sum(冲预交)
        Into n_返回值
        From 病人预交记录
        Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
        If Nvl(n_返回值, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号,
             卡号, 交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
          Values
            (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
             r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_返回值, 冲销id_In, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
             卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
          Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
        End If;
        n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
      
        --2.退款
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, n_重结id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2,
           卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, Null, 3, n_会话号);
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = n_重结id And 结算方式 Is Null;
      
      Else
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, r_Balancedata.病人id, Null, v_结算摘要, v_结算方式, r_Balancedata.收款时间,
           r_Balancedata.操作员编号, r_Balancedata.操作员姓名, n_结算金额, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号,
           2, 卡类别id_In, Null, 卡号_In, 交易流水号_In, 交易说明_In, v_结算号码, 3, n_会话号);
      
        Update 病人预交记录 Set 冲预交 = 冲预交 - n_结算金额 Where 结帐id = 冲销id_In And 结算方式 Is Null;
        If Sql%NotFound Then
          v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;

  If 操作类型_In = 3 Then
    --   3-医保结算(如果存在医保的结算,则要先删除原医保结算,后按新传入的更新)
    --3.1检查是否已经存在医保结算数据,存在先删除
    n_结算金额 := 0;
    For v_医保 In (Select ID, 结算方式, 冲预交
                 From 病人预交记录 A
                 Where 结帐id = 冲销id_In And Exists
                  (Select 1 From 结算方式 Where a.结算方式 = 名称 And 性质 In (3, 4)) And Mod(记录性质, 10) <> 1) Loop
      n_结算金额 := n_结算金额 + Nvl(v_医保.冲预交, 0);
      l_预交id.Extend;
      l_预交id(l_预交id.Count) := v_医保.Id;
    End Loop;
    If Nvl(n_结算金额, 0) <> 0 Then
      Update 病人预交记录
      Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_结算金额, 0)
      Where 结帐id = 冲销id_In And 结算方式 Is Null;
      If Sql%NotFound Then
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！';
        Raise Err_Item;
      End If;
    End If;
    If l_预交id.Count <> 0 Then
      Forall I In 1 .. l_预交id.Count
        Delete 病人预交记录 Where ID = l_预交id(I);
    End If;
  
    If 结算方式_In Is Not Null Then
      v_结算内容 := 结算方式_In || '||';
    End If;
  
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
    
      For c_结算信息 In (Select 记录性质, NO, 记录状态, 病人id, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号
                     From 病人预交记录
                     Where 结帐id = 冲销id_In And 结算方式 Is Null) Loop
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 结算性质, 会话号)
        Values
          (病人预交记录_Id.Nextval, 3, Null, 2, c_结算信息.病人id, Null, '保险结算', v_结算方式, c_结算信息.收款时间, c_结算信息.操作员编号, c_结算信息.操作员姓名,
           n_结算金额, c_结算信息.结帐id, c_结算信息.缴款组id, c_结算信息.结算序号, 1, 3, n_会话号);
      End Loop;
      --更新数据(结算方式为NULL的)
      Update 病人预交记录
      Set 冲预交 = 冲预交 - n_结算金额
      Where 结帐id = 冲销id_In And 结算方式 Is Null
      Returning Nvl(冲预交, 0) Into n_返回值;
    
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  --4-消费卡批量结算
  If 操作类型_In = 4 Then
    v_结算内容 := 结算方式_In || '||';
    While v_结算内容 Is Not Null Loop
      v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      --卡类别ID|卡号|消费卡ID|消费金额
      n_卡类别id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      v_卡号     := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_消费卡id := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
      n_结算金额 := To_Number(v_当前结算);
      Begin
        Select 名称, 自制卡, 结算方式 Into v_名称, n_自制卡, v_结算方式 From 卡消费接口目录 Where 编号 = n_卡类别id;
      Exception
        When Others Then
          v_名称 := Null;
      End;
      If v_名称 Is Null Then
        v_Err_Msg := '未找到对应的结算卡接口,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If v_结算方式 Is Null Then
        v_Err_Msg := v_名称 || '未设置对应的结算方式,本次刷卡消费失败!';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Then
        n_结帐id := 冲销id_In;
      
        If Nvl(n_重结id, 0) <> 0 Then
        
          Select Sum(冲预交)
          Into n_返回值
          From 病人预交记录
          Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) <> 0;
          If Nvl(n_返回值, 0) <> 0 Then
          
            Update 病人预交记录
            Set 冲预交 = Nvl(冲预交, 0) + Nvl(n_返回值, 0)
            Where 结帐id = 冲销id_In And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
            Returning ID Into n_预交id;
          
            If Sql%NotFound Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志,
                 结算性质, 会话号)
              Values
                (n_预交id, 3, Null, 2, r_Balancedata. 病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
                 r_Balancedata. 操作员姓名, n_返回值, r_Balancedata.结帐id, r_Balancedata. 缴款组id, r_Balancedata.结算序号, n_卡类别id, 2,
                 3, n_会话号);
            End If;
            Update 病人预交记录 Set 冲预交 = 冲预交 - Nvl(n_返回值, 0) Where 结帐id = 冲销id_In And 结算方式 Is Null;
          
            --插入卡结算记录
            --检查消费卡是否正确
            n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
            If Nvl(n_序号, 0) = 0 Then
              Raise Err_Item;
            End If;
            Begin
              Select Nvl(Max(Nvl(序号, 0)), 0) + 1
              Into n_序号
              From 病人卡结算记录
              Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
            Exception
              When Others Then
                n_序号 := 1;
            End;
          
            Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
          
            Insert Into 病人卡结算记录
              (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
            Values
              (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_返回值, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
          
            --如果消费卡,需同时更改其余额
            If Nvl(n_消费卡id, 0) <> 0 Then
              Update 消费卡目录 Set 余额 = 余额 - n_返回值 Where ID = n_消费卡id;
              If Sql%NotFound Then
                v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
                Raise Err_Item;
              End If;
            End If;
            Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
            n_结算金额 := n_结算金额 - Nvl(n_返回值, 0);
          End If;
          n_结帐id := n_重结id;
        
        End If;
      
        Update 病人预交记录
        Set 冲预交 = Nvl(冲预交, 0) + n_结算金额
        Where 结帐id = n_结帐id And 结算方式 = v_结算方式 And 结算卡序号 = n_卡类别id
        Returning ID Into n_预交id;
      
        If Sql%NotFound Then
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算卡序号, 校对标志, 结算性质,
             会话号)
          Values
            (n_预交id, 3, Null, Decode(Nvl(n_重结id, 0), 0, 2, 1), r_Balancedata. 病人id, Null, Null, v_结算方式,
             r_Balancedata. 收款时间, r_Balancedata. 操作员编号, r_Balancedata. 操作员姓名, n_结算金额, n_结帐id, r_Balancedata. 缴款组id,
             r_Balancedata. 结算序号, n_卡类别id, 2, 3, n_会话号);
        End If;
      
        --插入卡结算记录
        n_序号 := Zl_消费卡目录_Check(n_卡类别id, v_卡号, n_消费卡id, v_Err_Msg);
        If Nvl(n_序号, 0) = 0 Then
          Raise Err_Item;
        End If;
      
        Begin
          Select Nvl(Max(Nvl(序号, 0)), 0) + 1
          Into n_序号
          From 病人卡结算记录
          Where 接口编号 = n_卡类别id And Nvl(消费卡id, 0) = Nvl(n_消费卡id, 0) And 卡号 = v_卡号;
        Exception
          When Others Then
            n_序号 := 1;
        End;
      
        Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      
        Insert Into 病人卡结算记录
          (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Values
          (n_Id, n_卡类别id, n_消费卡id, n_序号, 1, v_结算方式, n_结算金额, v_卡号, Null, r_Balancedata.收款时间, Null, 0);
        --如果消费卡,需同时更改其余额
        If Nvl(n_消费卡id, 0) <> 0 Then
          Update 消费卡目录 Set 余额 = 余额 - n_结算金额 Where ID = n_消费卡id;
          If Sql%NotFound Then
            v_Err_Msg := '卡号为' || v_卡号 || '的' || v_名称 || '未找到!';
            Raise Err_Item;
          End If;
        End If;
        Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
      
        --更新数据(结算方式为NULL的)
        Update 病人预交记录
        Set 冲预交 = 冲预交 - n_结算金额
        Where 结帐id = n_结帐id And 结算方式 Is Null
        Returning Nvl(冲预交, 0) Into n_返回值;
      End If;
      v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
    End Loop;
  End If;

  If Nvl(完成退费_In, 0) = 0 Then
    Return;
  End If;

  -----------------------------------------------------------------------------------------
  --完成收费,需要处理人员缴款余额,预交记录(结算方式=NULL)
  If Nvl(完成退费_In, 0) = 1 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
    Return;
  End If;

  --1.删除结算方式为NULL的预交记录
  Delete 病人预交记录 Where 结帐id = 冲销id_In And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
  If Sql%NotFound Then
    Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In And 结算方式 Is Null;
    If n_Count <> 0 Then
      v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
    Else
      v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
    End If;
    Raise Err_Item;
  End If;
  If Nvl(n_重结id, 0) <> 0 Then
    Delete 病人预交记录 Where 结帐id = n_重结id And 结算方式 Is Null And Nvl(冲预交, 0) = 0;
    If Sql%NotFound Then
      Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = n_重结id And 结算方式 Is Null;
      If n_Count <> 0 Then
        v_Err_Msg := '还存在未缴款的数据,不能完成结算!';
      Else
        v_Err_Msg := '结算信息错误,可能因为并发原因造成结算信息错误,请在[收费结算窗口]中重新收费！!';
      End If;
      Raise Err_Item;
    End If;
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0 Where 结帐id = n_重结id;
  
  End If;

  --结算金额为零时，增加一条金额为0的病人预交记录
  Select Count(*) Into n_Count From 病人预交记录 A Where 结帐id = 冲销id_In;

  If n_Count = 0 Then
    v_结算方式 := 缺省结算方式_In;
    If v_结算方式 Is Null Then
      Begin
        Select 结算方式 Into v_结算方式 From 结算方式应用 Where 应用场合 = '收费' And Nvl(缺省标志, 0) = 1;
      Exception
        When Others Then
          v_结算方式 := Null;
      End;
      If v_结算方式 Is Null Then
        Begin
          Select 名称 Into v_结算方式 From 结算方式 Where Nvl(性质, 0) = 1;
        Exception
          When Others Then
            v_结算方式 := '现金';
        End;
      End If;
    End If;
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 校对标志, 卡类别id, 结算卡序号, 卡号,
       交易流水号, 交易说明, 结算号码, 结算性质, 会话号)
    Values
      (病人预交记录_Id.Nextval, 3, Null, 1, r_Balancedata.病人id, Null, Null, v_结算方式, r_Balancedata.收款时间, r_Balancedata.操作员编号,
       r_Balancedata.操作员姓名, 0, r_Balancedata.结帐id, r_Balancedata.缴款组id, r_Balancedata.结算序号, 2, Null, Null, Null, Null,
       交易说明_In, Null, 3, n_会话号);
  End If;

  --2.处理缴款数据和找补数据及校对标志更新为0，会话号更新为NULL
  Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 病人预交记录 Set 缴款 = 缴款_In, 找补 = 找补_In, 校对标志 = 0, 会话号 = Null Where 结帐id = n_重结id;
  End If;

  --3.更新费用状态
  Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = 冲销id_In;
  If Nvl(n_重结id, 0) <> 0 Then
    Update 门诊费用记录 Set 费用状态 = 0 Where 结帐id = n_重结id;
  End If;

  --4.更新人员缴款数据
  If n_重结id <> 0 Then
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id In (冲销id_In, n_重结id) And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  
  Else
    For c_缴款 In (Select 结算方式, 操作员姓名, Sum(Nvl(a.冲预交, 0)) As 冲预交
                 From 病人预交记录 A
                 Where a.结帐id = 冲销id_In And Mod(a.记录性质, 10) <> 1
                 Group By 结算方式, 操作员姓名) Loop
    
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + Nvl(c_缴款.冲预交, 0)
      Where 收款员 = c_缴款.操作员姓名 And 性质 = 1 And 结算方式 = c_缴款.结算方式;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (c_缴款.操作员姓名, c_缴款.结算方式, 1, Nvl(c_缴款.冲预交, 0));
      End If;
    End Loop;
  End If;
  --消息推送
  Select 病人id_In || ',' || 冲销id_In || ',' || Decode(完成退费_In, 2, 0, 0, 0, 1) Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 5, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊退费结算_Modify;
/

--122046:焦博,2018-02-12,调整Oracle过程Zl_Third_Getvisitinfo删除外连接
Create Or Replace Procedure Zl_Third_Getvisitinfo
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  -------------------------------------------------------------------------------------------------- 
  --功能:根据挂号单号获取该次就诊详情(医嘱为主要显示) 
  --入参:Xml_In: 
  --<IN> 
  --    <GHDH>挂号单号</GHDH> 
  --    <JSKLB>结算卡类别</JSKLB> 
  --    <MXGL>明细过滤</MXGL> 0-不过滤,明细包含治疗 1-过滤,明细不包含治疗,默认为1 
  --</IN> 
  --出参:Xml_Out 
  --<OUTPUT> 
  --  <GH> 
  --     <GHDH>挂号单号</GHDH> //本次查询的挂号单号 
  --     <YYSJ>预约时间</YYSJ> //yyyy-mm-dd hh24:mi:ss 
  --     <JZSJ></JZSJ>      //实际就诊时间 
  --     <DJH></DJH>        //单据号 
  --     <JE></JE>          //金额 
  --     <DJLX></DJLX>      //单据类型,1-收费单，4-挂号单 
  --     <KDSJ></KDSJ>      //开单时间 
  --     <JKFS></JKFS>      //缴款方式,0-挂号或预约缴款;1-预约不缴款 
  --     <ZFZT></ZFZT>  //支付状态,0-待支付，1-已支付，2-已退费 
  --     <SFJSK></SFJSK>    //是否结算卡支付，0-否，1-是 
  --  </GH> 
  --  <YZLIST> 
  --     <YZ>                   //医嘱返回与HIS中显示的内容相同 
  --        <YZID><YZID>        //医嘱ID，返回组医嘱ID 
  --        <YZLX><YZLX>        //医嘱类型,如处方、检查、检验 
  --         <YZMC></YZMC>        //医嘱名称 
  --        <ZXKS></ZXKS>       //执行科室 
  --        <ZXKSID></ZXKSID>   //执行科室ID 
  --        <FYCK></FYCK>       //发药窗口 
  --        <YZMX> 
  --           <MX> 
  --              <YZNR></YZNR>        //医嘱内容 
  --              <ZXZT></ZXZT>        //医嘱执行状态 
  --              <SFFY>是否发药</SFFY> // 0-否 ，1-是 
  --              <GG>规格</GG> 
  --              <SL>数量</SL> 
  --              <DW>计算单位</DW> 
  --              <BZDJ>标准单价</BZDJ> 
  --              <YSJE>应收金额</YSJE> 
  --              <SSJE>实收金额</SSJE> 
  --           </MX> 
  --           <MX/> 
  --        </YZMX> 
  --        <BG></BG>                   //是否已出报告，是否签名 
  --        <BGLY></BGLY>               //是否外检项目,1-院内项目，2-外检项目 
  --        <BGLYSM></BGLYSM>           //外检项目说明 
  --        <JZBG></JZBG>                //禁止显示报告。0-允许，1-禁止 
  --        <JZTS></JZTS>                 //提示文字。对于禁止查看的报告，可返回用于提示病人的信息 
  --        <BLID></BLID>              //病历ID，如果<BG>字段为1，该值不为空 
  --        <DJLIST> 
  --           <DJ>                //费用单据信息 
  --              <DJH></DJH>      //费用单据号 
  --              <DJLX></DJLX>    //单据类型 
  --              <JE></JE>        //单据总金额 
  --              <KDSJ></KDSJ>    //开单时间 
  --              <ZFZT></ZFZT>    //支付状态,0-待支付，1-已支付，2-已退费,3-退费申请中,4-审核通过,5-审核未通过 
  --              <SHSM></SHSM>    //审核说明,审核未通过原因 
  --              <SFJSK></SFJSK>  //是否结算卡支付，0-否，1-是 
  --           </DJ> 
  --           <DJ/> 
  --        </DJLIST> 
  --     </YZ> 
  --  </YZLIST> 
  --    <ERROR><MSG></MSG></ERROR>                      //如果错误返回 
  --</OUTPUT> 

  -------------------------------------------------------------------------------------------------- 
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  x_Templet Xmltype; --模板XML 

  v_卡类别   Varchar2(100);
  n_卡类别id Number(18);
  v_挂号单   Varchar2(10);
  v_排队号码 Varchar2(10);
  n_Temp     Number(18);
  v_队列名称 排队叫号队列.队列名称%Type;

  n_Count Number(18);

  v_Temp       Varchar2(32767); --临时XML 
  v_队列       Varchar2(32767);
  v_No         Varchar2(50);
  n_Add_Djlist Number(1); --是否增加了DJLIST的 
  n_性质       Number(2);
  n_组医嘱id   Number(18);
  n_独立医嘱   Number(8);
  n_执行科室id Number(18);
  v_执行科室   Varchar2(50);
  n_退款金额   病人预交记录.冲预交%Type;
  n_明细过滤   Number(3);
  n_退费状态   病人退费申请.状态%Type;
  v_申请原因   病人退费申请.申请原因%Type;
  v_审核原因   病人退费申请.审核原因%Type;
  v_发药窗口   门诊费用记录.发药窗口%Type;

Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select Extractvalue(Value(A), 'IN/GHDH'), Extractvalue(Value(A), 'IN/JSKLB'), Extractvalue(Value(A), 'IN/MXGL')
  Into v_挂号单, v_卡类别, n_明细过滤
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  If v_挂号单 Is Null Then
    v_Err_Msg := '不能找到指定的挂号单号(当前挂号单号为空)';
    Raise Err_Item;
  End If;
  If n_明细过滤 Is Null Then
    n_明细过滤 := 1;
  End If;
  n_Add_Djlist := 0;

  v_Err_Msg := Null;
  If v_卡类别 Is Not Null Then
    Begin
      n_卡类别id := To_Number(v_卡类别);
    Exception
      When Others Then
        n_卡类别id := 0;
    End;
  
    If n_卡类别id = 0 Then
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where 名称 = v_卡类别;
      Exception
        When Others Then
          v_Err_Msg := '卡类别:' || v_卡类别 || '不存在!';
      End;
    
    Else
    
      Begin
        Select ID, Decode(Nvl(是否启用, 0), 1, Null, 名称 || '未启用,不允许进行缴费!')
        Into n_卡类别id, v_Err_Msg
        From 医疗卡类别
        Where ID = n_卡类别id;
      Exception
        When Others Then
          v_Err_Msg := '未找到指定的结算支付信息!';
      End;
    
    End If;
    If Not v_Err_Msg Is Null Then
      Raise Err_Item;
    End If;
  End If;
  n_性质 := 4;
  --1.获取挂号数据 

  Select Max(收费单) Into v_No From 病人挂号记录 Where NO = v_挂号单;

  If v_No Is Not Null Then
    Select Count(*) Into n_Count From 门诊费用记录 Where NO = v_No And 记录性质 = 1;
    If n_Count <> 0 Then
      n_性质 := 1;
    End If;
  End If;
  If n_性质 = 4 Then
    v_No := v_挂号单;
  End If;

  n_Count := 0;
  For c_挂号 In (Select a.Id, v_No As NO, n_性质 As 记录性质, a.执行部门id, c.名称 As 执行部门,
                      To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 登记时间, To_Char(a.预约时间, 'yyyy-mm-dd hh24:mi:ss') As 预约时间,
                      a.接收时间, To_Char(a.发生时间, 'yyyy-mm-dd HH24:mi:ss') As 就诊时间, a.号别, a.号序, b.金额, a.记录状态,
                      Decode(Nvl(a.执行状态, 0), 0, '等待接诊', 1, '完成就诊', 2, '正在就诊', -1, '取消就诊') As 执行状态,
                      Decode(Nvl(b.结帐id, 0), 0, 0, 1) As 支付标志, Decode(Nvl(a.记录性质, 0), 2, 1, 0) As 缴款方式, b.结帐id As 结帐id
               From 病人挂号记录 A,
                    (Select Max(Decode(记录状态, 0, 0, 2, 0, Nvl(结帐id, 0))) As 结帐id, Sum(实收金额) As 金额
                      From 门诊费用记录 B
                      Where 记录性质 = n_性质 And NO = v_No) B, 部门表 C
               Where a.No = v_挂号单 And a.执行部门id = c.Id) Loop
  
    If Nvl(c_挂号.记录状态, 0) <> 1 Then
      v_Err_Msg := '单据号:' || v_挂号单 || '已经被退号!';
      Raise Err_Item;
    End If;
  
    Select Max(排队号码), Max(队列名称)
    Into v_排队号码, v_队列名称
    From 排队叫号队列
    Where 业务id = c_挂号.Id And Nvl(业务类型, 0) = 0;
  
    If v_排队号码 Is Not Null Then
      --业务id_In ,业务类型_In 排队号码_In Number := Null 
      n_Temp := Zl_Getsequencebeforperons(c_挂号.Id, 0, v_排队号码, v_队列名称);
      v_队列 := v_队列 || '<DL><XH>' || v_排队号码 || '</XH><QMRS>' || n_Temp || '</QMRS></DL>';
    End If;
    n_Temp := 0;
    If Nvl(n_卡类别id, 0) <> 0 Then
      Begin
        Select 1
        Into n_Temp
        From 病人预交记录
        Where 结帐id = c_挂号.结帐id And 记录性质 = 4 And 记录状态 In (1, 3) And 卡类别id = n_卡类别id And Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    v_Temp := '<GHDH>' || v_挂号单 || '</GHDH>';
    v_Temp := v_Temp || '<DJH>' || c_挂号.No || '</DJH>';
    v_Temp := v_Temp || '<YYSJ>' || c_挂号.预约时间 || '</YYSJ>';
    v_Temp := v_Temp || '<JZSJ>' || c_挂号.就诊时间 || '</JZSJ>';
    v_Temp := v_Temp || '<KDSJ>' || c_挂号.登记时间 || '</KDSJ>';
    v_Temp := v_Temp || '<JKFS>' || c_挂号.缴款方式 || '</JKFS>';
    v_Temp := v_Temp || '<JE>' || c_挂号.金额 || '</JE>';
    v_Temp := v_Temp || '<DJLX>' || n_性质 || '</DJLX>';
    v_Temp := v_Temp || '<ZFZT>' || c_挂号.支付标志 || '</ZFZT>';
    v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
    If v_队列 Is Not Null Then
      v_Temp := v_Temp || v_队列;
    End If;
    v_Temp := '<GH>' || v_Temp || '</GH>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Temp)) Into x_Templet From Dual;
    n_Count := n_Count + 1;
  End Loop;

  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '未找到指定的挂号单据:' || v_挂号单 || '!';
    Raise Err_Item;
  End If;

  --2.组建医嘱及费用相关数据 
  n_组医嘱id := 0;

  For c_医嘱 In (With 医嘱费用 As
                  (Select 医嘱id, 发送号, 记录性质, NO, Max(Nvl(执行状态, 0)) As 执行状态
                  From (Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(b.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id
                         Union All
                         Select b.医嘱id, b.发送号, b.记录性质, b.No, Nvl(c.执行状态, 0) As 执行状态
                         From 病人医嘱记录 A, 病人医嘱发送 C, 病人医嘱附费 B
                         Where a.挂号单 = v_挂号单 And a.Id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号)
                  Group By 医嘱id, 发送号, 记录性质, NO)
                 
                 Select Nvl(a.相关id, a.Id) As 组id, Decode(a.相关id, Null, 0, 1) As 附医嘱, a.Id, a.相关id, e.发药窗口,
                        Max(Decode(a.诊疗类别, 'E', Decode(q.操作类型, '2', '处方', '4', '处方', '6', '检验', m.名称), m.名称)) As 医嘱类型,
                        a.执行科室id, d.名称 As 执行科室, Decode(a.相关id, Null, a.医嘱内容, Null) As 组医嘱内容,
                        Max(Decode(a.诊疗类别, '5', 1, '6', 1, '7', 1, 0) * Decode(Nvl(e.执行状态, 0), 1, 1, 3, 1, 0)) As 发药状态,
                        Decode(a.相关id, Null, Null, q.名称) As 明细医嘱内容, s.规格, (e.数次 * e.付数) As 数量, e.计算单位 As 单位,
                        Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行') As 执行状态,
                        Max(Decode(p.审核时间, Null, Decode(C1.完成时间, Null, 0, 1), 1)) As 是否已出报告, c.病历id, e.No, e.记录性质 As 单据类型,
                        Max(e.标准单价) As 标准单价, Sum(e.应收金额) As 应收金额, Sum(e.实收金额) As 实收金额,
                        To_Char(e.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1) As 支付状态,
                        a.病人id
                 
                 From 病人医嘱记录 A, 医嘱费用 B, 病人医嘱报告 C, 电子病历记录 C1, 部门表 D, 门诊费用记录 E, 诊疗项目类别 M, 诊疗项目目录 Q, 收费项目目录 S, 检验标本记录 P
                 Where a.Id = b.医嘱id(+) And a.执行科室id = d.Id(+) And c.病历id = C1.Id(+) And a.Id = c.医嘱id(+) And
                       a.Id = p.医嘱id(+) And b.医嘱id = e.医嘱序号(+) And e.收费细目id = s.Id(+) And b.No = e.No(+) And
                       b.记录性质 = e.记录性质(+) And e.记录状态(+) <> 2 And a.挂号单 = v_挂号单 And a.诊疗类别 = m.编码(+) And
                       a.诊疗项目id = q.Id(+) And a.医嘱状态 In (3, 8)
                 Group By a.Id, a.婴儿, a.序号, a.相关id, e.发药窗口, a.诊疗类别, a.执行科室id, d.名称, a.医嘱内容, q.名称, s.规格, e.数次 * e.付数,
                          e.计算单位, Decode(Nvl(b.执行状态, 0), 0, '未执行', 1, '完全执行', 2, '拒绝执行', 3, '正在执行', '正在执行'), C1.完成时间,
                          Decode(c.病历id, Null, 0, 1), c.病历id, e.No, e.记录性质, e.登记时间, Decode(Nvl(e.记录状态, 0), 0, 0, 3, 2, 1),
                          p.审核时间, a.病人id
                 Order By 组id, 附医嘱, Nvl(a.婴儿, 0), a.序号) Loop
    If Nvl(n_Add_Djlist, 0) = 0 Then
      --增加DJList节点 
      Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype('<YZLIST></YZLIST>')) Into x_Templet From Dual;
      n_Add_Djlist := 1;
    End If;
  
    If n_组医嘱id <> Nvl(c_医嘱.组id, 0) Then
      n_组医嘱id := Nvl(c_医嘱.组id, 0);
    
      Zl_Third_Custom_Getdeptinfo(n_组医嘱id, n_执行科室id, v_执行科室);
    
      If Nvl(n_执行科室id, 0) = 0 Then
        If c_医嘱.医嘱类型 = '检验' Then
          --检验医嘱以显示采集科室 
          n_执行科室id := c_医嘱.执行科室id;
          v_执行科室   := c_医嘱.执行科室;
        Else
          Begin
            Select b.Id, b.名称, c.发药窗口
            Into n_执行科室id, v_执行科室, v_发药窗口
            From 病人医嘱记录 A, 部门表 B, 门诊费用记录 C
            Where a.Id = c.医嘱序号 And a.相关id = n_组医嘱id And a.执行科室id = b.Id And Rownum <= 1;
          Exception
            When Others Then
              n_执行科室id := c_医嘱.执行科室id;
              v_执行科室   := c_医嘱.执行科室;
              v_发药窗口   := c_医嘱.发药窗口;
          End;
        End If;
      End If;
    
      v_Temp := '<YZID>' || n_组医嘱id || '</YZID>';
      v_Temp := v_Temp || '<YZLX>' || c_医嘱.医嘱类型 || '</YZLX>';
      v_Temp := v_Temp || '<YZMC>' || c_医嘱.组医嘱内容 || '</YZMC>';
      v_Temp := v_Temp || '<ZXKS>' || v_执行科室 || '</ZXKS>';
      v_Temp := v_Temp || '<ZXKSID>' || n_执行科室id || '</ZXKSID>';
      v_Temp := v_Temp || '<FYCK>' || v_发药窗口 || '</FYCK>';
      v_Temp := v_Temp || '<BG>' || c_医嘱.是否已出报告 || '</BG>';
      v_Temp := v_Temp || Zl_Third_Custom_Getrptfrom(n_组医嘱id);
      v_Temp := v_Temp || Zl_Third_Custom_Rptlimit(c_医嘱.病人id, n_组医嘱id);
      If Nvl(c_医嘱.是否已出报告, 0) = 1 And c_医嘱.病历id Is Not Null Then
        v_Temp := v_Temp || '<BLID>' || c_医嘱.病历id || '</BLID>';
      End If;
      v_Temp := '<YZ 医嘱ID="' || n_组医嘱id || '">' || v_Temp || '<YZMX></YZMX><DJLIST></DJLIST></YZ>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST', Xmltype(v_Temp)) Into x_Templet From Dual;
    
      For v_费用 In (
                   
                   Select a.No, Mod(a.记录性质, 10) As 单据类型, To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss') As 开单时间,
                           Max(Decode(Nvl(a.记录状态, 0), 0, 0, 3, 2, 1)) As 支付状态, Sum(a.实收金额) As 单据金额, Max(a.结帐id) As 结算卡支付
                   From 门诊费用记录 A
                   Where (a.No, a.记录性质) In
                         (Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱发送 Q
                          Where m.Id = q.医嘱id And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)
                          Union All
                          Select Distinct q.No, q.记录性质
                          From 病人医嘱记录 M, 病人医嘱附费 Q
                          Where m.Id = q.医嘱id And (m.Id = n_组医嘱id Or m.相关id = n_组医嘱id)) And Nvl(a.记录状态, 0) In (0, 1, 3)
                   Group By a.No, Mod(a.记录性质, 10), To_Char(a.登记时间, 'yyyy-mm-dd hh24:mi:ss')) Loop
        Begin
          Select 1
          Into n_Temp
          From 病人预交记录 A, 门诊费用记录 B
          Where a.结帐id = b.结帐id And b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 In (1, 3) And a.卡类别id = n_卡类别id And
                Rownum < 2;
        Exception
          When Others Then
            n_Temp := 0;
        End;
        Begin
          Select -1 * Sum(结帐金额)
          Into n_退款金额
          From 门诊费用记录 B
          Where b.No = v_费用.No And Mod(b.记录性质, 10) = 1 And b.记录状态 = 2;
        Exception
          When Others Then
            n_退款金额 := 0;
        End;
        Begin
          Select 状态, 申请原因, 审核原因
          Into n_退费状态, v_申请原因, v_审核原因
          From 病人退费申请
          Where NO = v_费用.No And Mod(记录性质, 10) = Mod(v_费用.单据类型, 10);
        Exception
          When Others Then
            n_退费状态 := -1;
            v_申请原因 := '';
            v_审核原因 := '';
        End;
      
        v_Temp := '<DJH>' || v_费用.No || '</DJH>';
        v_Temp := v_Temp || '<DJLX>' || v_费用.单据类型 || '</DJLX>';
        v_Temp := v_Temp || '<JE>' || v_费用.单据金额 || '</JE>';
        v_Temp := v_Temp || '<KDSJ>' || v_费用.开单时间 || '</KDSJ>';
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<ZFZT>' || v_费用.支付状态 || '</ZFZT>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<ZFZT>3</ZFZT>';
          End If;
          If n_退费状态 = 1 Then
            If v_费用.支付状态 = 2 Then
              v_Temp := v_Temp || '<ZFZT>2</ZFZT>';
            Else
              v_Temp := v_Temp || '<ZFZT>4</ZFZT>';
            End If;
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<ZFZT>5</ZFZT>';
          End If;
        End If;
      
        If n_退费状态 = -1 Then
          v_Temp := v_Temp || '<SHSM>' || '' || '</SHSM>';
        Else
          If n_退费状态 = 0 Then
            v_Temp := v_Temp || '<SHSM>' || v_申请原因 || '</SHSM>';
          End If;
          If n_退费状态 = 1 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
          If n_退费状态 = 2 Then
            v_Temp := v_Temp || '<SHSM>' || v_审核原因 || '</SHSM>';
          End If;
        End If;
      
        v_Temp := v_Temp || '<YTJE>' || Nvl(n_退款金额, 0) || '</YTJE>';
        v_Temp := v_Temp || '<SFJSK>' || n_Temp || '</SFJSK>';
        v_Temp := '<DJ>' || v_Temp || '</DJ>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/DJLIST', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End Loop;
    End If;
  
    --只有一条记录的医嘱，在明细中增加该条医嘱，以获取执行状态 
    Select Decode(Count(*), 0, 1, 0) Into n_独立医嘱 From 病人医嘱记录 Where 相关id = n_组医嘱id;
    If n_独立医嘱 = 1 Then
      v_Temp := '<YZNR>' || c_医嘱.组医嘱内容 || '</YZNR>';
      v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
      v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
      v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
      v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
      v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
      v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
      v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
      v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
      v_Temp := '<MX>' || v_Temp || '</MX>';
      Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
      Into x_Templet
      From Dual;
    End If;
  
    If Nvl(c_医嘱.附医嘱, 0) = 1 Then
      If n_明细过滤 = 0 Or (n_明细过滤 = 1 And c_医嘱.医嘱类型 <> '治疗') Then
        v_Temp := '<YZNR>' || c_医嘱.明细医嘱内容 || '</YZNR>';
        v_Temp := v_Temp || '<GG>' || c_医嘱.规格 || '</GG>';
        v_Temp := v_Temp || '<SL>' || c_医嘱.数量 || '</SL>';
        v_Temp := v_Temp || '<DW>' || c_医嘱.单位 || '</DW>';
        v_Temp := v_Temp || '<SFFY>' || c_医嘱.发药状态 || '</SFFY>';
        v_Temp := v_Temp || '<ZXZT>' || c_医嘱.执行状态 || '</ZXZT>';
        v_Temp := v_Temp || '<BZDJ>' || Nvl(c_医嘱.标准单价, 0) || '</BZDJ>';
        v_Temp := v_Temp || '<YSJE>' || Nvl(c_医嘱.应收金额, 0) || '</YSJE>';
        v_Temp := v_Temp || '<SSJE>' || Nvl(c_医嘱.实收金额, 0) || '</SSJE>';
        v_Temp := '<MX>' || v_Temp || '</MX>';
        Select Appendchildxml(x_Templet, '/OUTPUT/YZLIST/YZ[@医嘱ID="' || n_组医嘱id || '"]/YZMX', Xmltype(v_Temp))
        Into x_Templet
        From Dual;
      End If;
    End If;
  
  End Loop;
  Xml_Out := x_Templet;

Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getvisitinfo;
/

--118705:李小东,2018-02-07,技师站审核标本后能改变该标本下所有医嘱状态
Create Or Replace Procedure Zl_检验普通结果_Write
(
  检验标本id_In In 检验普通结果.检验标本id%Type,
  仪器id_In     In 检验普通结果.仪器id%Type,
  检验指标_In   In Varchar2, --格式：医嘱ID^项目ID^值^标志^参考^诊疗项目ID|。。。 
  是否覆盖_In   In Number,
  微生物_In     In Number := 0,
  医嘱id_In     In Varchar2 := Null
) Is
  Err_Custom Exception;
  v_Flag      Number(1);
  v_Records   Varchar2(4000);
  v_Currrec   Varchar2(500);
  v_Item      Varchar2(200);
  v_医嘱id    检验项目分布.医嘱id%Type;
  v_项目id    检验普通结果.检验项目id%Type;
  v_检验结果  检验普通结果.检验结果%Type;
  v_检验结果1 检验普通结果.检验结果%Type;

  v_结果标志   检验普通结果.结果标志%Type;
  v_结果参考   检验普通结果.结果参考%Type;
  v_结果参考1  检验普通结果.结果参考%Type;
  v_诊疗项目id 检验普通结果.诊疗项目id%Type;
  v_排列序号   检验普通结果.排列序号%Type;
  v_Pos1       Number;
  v_Pos2       Number;
  v_标本类型   检验标本记录.标本类型%Type;
  v_性别       检验标本记录.性别%Type;
  v_年龄       检验标本记录.年龄%Type;
  v_出生日期   病人信息.出生日期%Type;

  v_糖耐量id  检验普通结果.检验项目id%Type;
  v_糖耐量id1 检验普通结果.检验项目id%Type;

  v_多参考 Number;

  Function Zlval(Vstr In Varchar2) Return Number Is
    Result Number(16, 6);
    Intbit Number(8);
    Strnum Varchar2(10);
    Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
      n_Tmp Number;
    Begin
      n_Tmp := To_Number(v_In);
      If n_Tmp Is Not Null Then
        Return True;
      Else
        Return False;
      End If;
    Exception
      When Others Then
        Return False;
    End Sub_Is_Number;
  Begin
    Strnum := '';
    If Sub_Is_Number(Vstr) = True Then
      Result := To_Number(Nvl(Vstr, 0));
      Return(Result);
    Else
      For Intbit In 1 .. 10 Loop
        If Instr('0123456789.', Substr(Vstr, Intbit, 1)) = 0 Then
          Exit;
        End If;
        Strnum := Strnum || Substr(Vstr, Intbit, 1);
        Null;
      End Loop;
      Result := To_Number(Nvl(Strnum, 0));
      Return(Result);
    End If;
  End Zlval;
  -- >>>>>>>>>>>>>>>>>>  检查是否数字的函数  <<<<<<<<<<<<<<<<<< 
  Function Sub_Is_Number(v_In In Varchar2) Return Boolean Is
    n_Tmp Number;
  Begin
    n_Tmp := To_Number(v_In);
    If n_Tmp Is Not Null Then
      Return True;
    Else
      Return False;
    End If;
  Exception
    When Others Then
      Return False;
  End Sub_Is_Number;
Begin
  v_Records := 检验指标_In || '|';
  --已审核不能覆盖 
  v_Flag := 0;
  Begin
    Select 1 Into v_Flag From 检验标本记录 Where ID = 检验标本id_In And 样本状态 = 2;
  Exception
    When Others Then
      v_Flag := 0;
  End;
  If v_Flag = 1 Then
    Return;
  End If;

  If 是否覆盖_In = 1 Then
    Delete From 检验普通结果 Where 检验标本id = 检验标本id_In;
    Delete 检验项目分布 Where 标本id = 检验标本id_In;
  End If;
  --没有找到数据后退出 
  Begin
    Select a.标本类型, a.性别, a.年龄, b.出生日期
    Into v_标本类型, v_性别, v_年龄, v_出生日期
    From 检验标本记录 A, 病人信息 B
    Where a.病人id = b.病人id(+) And a.Id = 检验标本id_In;
  Exception
    When Others Then
      Return;
  End;

  If 检验指标_In Is Not Null Then
    While v_Records Is Not Null Loop
      v_Currrec    := Substr(v_Records, 1, Instr(v_Records, '|') - 1);
      v_Pos1       := Instr(v_Currrec, '^', 1);
      v_医嘱id     := To_Number(Substr(v_Currrec, 1, v_Pos1 - 1));
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_项目id     := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos1       := Instr(v_Currrec, '^', v_Pos2 + 1);
      v_检验结果   := Substr(v_Currrec, v_Pos2 + 1, v_Pos1 - v_Pos2 - 1);
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_结果标志   := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos1       := Instr(v_Currrec, '^', v_Pos2 + 1);
      v_结果参考   := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_Pos2       := Instr(v_Currrec, '^', v_Pos1 + 1);
      v_诊疗项目id := To_Number(Substr(v_Currrec, v_Pos1 + 1, v_Pos2 - v_Pos1 - 1));
      v_排列序号   := Substr(v_Currrec, v_Pos2 + 1);
    
      v_Flag := 0;
      If 是否覆盖_In <> 1 Then
        v_检验结果1 := v_检验结果;
        Begin
          If 微生物_In = 0 Then
            --新增2005-5-26 
            Select 1, 检验结果
            Into v_Flag, v_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 检验项目id = v_项目id;
          Else
            Select 1, 检验结果
            Into v_Flag, v_检验结果
            From 检验普通结果
            Where 检验标本id = 检验标本id_In And 细菌id = v_项目id;
          End If;
        Exception
          When Others Then
            v_Flag     := 0;
            v_检验结果 := v_检验结果1;
        End;
      End If;
      If v_Flag = 0 Then
        If 微生物_In = 0 Then
          Insert Into 检验普通结果
            (ID, 检验标本id, 检验项目id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, v_项目id, v_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In),
             Decode(v_多参考, 0, v_结果标志, 1), Decode(v_多参考, 0, v_结果参考, v_结果参考1), v_诊疗项目id, v_排列序号);
          Insert Into 检验流水线指标 (ID, 标本id, 项目id) Values (检验流水线指标_Id.Nextval, 检验标本id_In, v_项目id);
        Else
          If Instr(v_检验结果, ';') > 0 Then
            If Instr(v_检验结果, v_标本类型) > 0 Then
              --找到标本 
              v_Item := Substr(v_检验结果, Instr(v_检验结果, v_标本类型));
              v_Item := Substr(v_Item, Instr(v_Item, ',') + 1);
              If Instr(v_Item, ';') > 0 Then
                v_检验结果 := Substr(v_Item, 1, Instr(v_Item, ';') - 1);
              Else
                v_检验结果 := v_Item;
              End If;
            Else
              --没有找到相同的标本类型时使用第一个 
              v_Item := Substr(v_检验结果, Instr(v_检验结果, ',') + 1);
              If Instr(v_Item, ';') > 0 Then
                v_检验结果 := Substr(v_Item, 1, Instr(v_Item, ';') - 1);
              Else
                v_检验结果 := v_Item;
              End If;
            End If;
          End If;
        
          Insert Into 检验普通结果
            (ID, 检验标本id, 细菌id, 检验结果, 记录类型, 仪器id, 结果标志, 结果参考, 诊疗项目id, 排列序号)
          Values
            (检验普通结果_Id.Nextval, 检验标本id_In, v_项目id, v_检验结果, 0, Decode(仪器id_In, 0, Null, 仪器id_In), v_结果标志, v_结果参考,
             v_诊疗项目id, v_排列序号);
        
          Insert Into 检验药敏结果
            (细菌结果id, 抗生素id, 修改者, 修改时间, 结果, 结果类型, 记录类型, 仪器id)
            Select 检验普通结果_Id.Currval, b.抗生素id, '', Null, '', c.默认药敏, 0, Decode(仪器id_In, 0, Null, 仪器id_In)
            From (Select 抗生素分组id, 细菌id
                   From (Select 抗生素分组id, 细菌id
                          From 检验细菌抗生素 A
                          Where a.细菌id = v_项目id
                          Order By Nvl(缺省标志, 0) Desc)
                   Where Rownum = 1) A, 检验抗生素用药 B, 检验细菌 C
            Where a.抗生素分组id = b.抗生素分组id And c.Id = v_项目id;
        End If;
      End If;
      If v_医嘱id = 0 Then
        v_医嘱id := Null;
      End If;
      If 微生物_In = 0 Then
        Update 检验项目分布
        Set 医嘱id = Decode(v_医嘱id, Null, 医嘱id, v_医嘱id)
        Where 标本id = 检验标本id_In And 项目id + 0 = v_项目id And 医嘱id Is Null;
        If Sql%RowCount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 项目id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_项目id, v_医嘱id, 1);
        End If;
      Else
        Update 检验项目分布
        Set 医嘱id = Decode(v_医嘱id, Null, 医嘱id, v_医嘱id)
        Where 标本id = 检验标本id_In And 细菌id + 0 = v_项目id And 医嘱id Is Null;
        If Sql%RowCount = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 细菌id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_项目id, v_医嘱id, 1);
        End If;
      End If;
    
      v_Records := Replace('|' || v_Records, '|' || v_Currrec || '|');
    End Loop;
  Else
    If 医嘱id_In Is Not Null Then
      v_Records := 医嘱id_In || ',';
      While v_Records Is Not Null Loop
        v_医嘱id  := Substr(v_Records, 1, Instr(v_Records, ',') - 1);
        v_Records := Substr(v_Records, Instr(v_Records, ',') + 1);
        v_Pos1    := To_Number(v_医嘱id);
        Select Nvl(Max(1), 0) Into v_Pos2 From 检验项目分布 Where 标本id = 检验标本id_In And 医嘱id = v_Pos1;
        If v_Pos2 = 0 Then
          Insert Into 检验项目分布
            (ID, 标本id, 医嘱id, 范围)
          Values
            (检验项目分布_Id.Nextval, 检验标本id_In, v_医嘱id, 1);
        End If;
      End Loop;
    End If;
  End If;

  If 微生物_In = 0 Then
    --通过医嘱来自动合并糖耐量项目 
    Begin
      Select b.检验项目id
      Into v_糖耐量id
      From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
      Where a.Id = b.检验标本id And b.检验项目id = c.项目id And a.仪器id = c.仪器id And c.糖耐量项目 = -1 And a.Id = 检验标本id_In And
            b.检验结果 Is Not Null;
    
      Select e.项目id
      Into v_糖耐量id1
      From 检验标本记录 A, 检验项目分布 B, 病人医嘱记录 C, 检验报告项目 D, 检验仪器项目 E
      Where a.Id = b.标本id And b.医嘱id = c.相关id And c.诊疗项目id = d.诊疗项目id And a.仪器id = e.仪器id And d.报告项目id = e.项目id And
            e.糖耐量项目 = -1 And a.Id = 检验标本id_In;
    
      Update 检验普通结果 Set 检验项目id = v_糖耐量id1 Where 检验标本id = 检验标本id_In And 检验项目id = v_糖耐量id;
      Delete 检验普通结果
      Where 检验标本id = 检验标本id_In And 检验结果 Is Null And
            检验项目id In
            (Select b.检验项目id
             From 检验标本记录 A, 检验普通结果 B, 检验仪器项目 C
             Where a.Id = b.检验标本id And b.检验项目id = c.项目id And a.仪器id = c.仪器id And c.糖耐量项目 = -1 And a.Id = 检验标本id_In);
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]||v_Error||[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_检验普通结果_Write;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Apply
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  停诊号码_In 临床出诊停诊记录.停诊号码%Type := Null,
  开始时间_In 临床出诊停诊记录.开始时间%Type := Null,
  终止时间_In 临床出诊停诊记录.终止时间%Type := Null,
  停诊原因_In 临床出诊停诊记录.停诊原因%Type := Null,
  申请人_In   临床出诊停诊记录.申请人%Type := Null,
  申请时间_In 临床出诊停诊记录.申请时间%Type := Null,
  登记人_In   临床出诊停诊记录.登记人%Type := Null
) As
  --功能：退费申请以及取消申请 
  --参数： 
  --        操作类型_In：0-申请，else-取消申请 
  --说明： 
  n_Count    Number;
  v_已停号码 临床出诊停诊记录.停诊号码%Type;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If 操作类型_In = 0 Then
    --申请 
    If 开始时间_In <= Sysdate Then
      v_Error := '停诊时间的开始时间必须大于当前时间！';
      Raise Err_Custom;
    End If;
  
    If 开始时间_In >= 终止时间_In Then
      v_Error := '停诊时间的结束时间必须大于开始时间！';
      Raise Err_Custom;
    End If;
  
    Select Count(1)
    Into n_Count
    From 临床出诊停诊记录
    Where 记录id Is Null And Not (开始时间 > 终止时间_In Or Nvl(失效时间, 终止时间) < 开始时间_In) And 申请人 = 申请人_In And 停诊号码 Is Null And
          Rownum < 2;
    If n_Count <> 0 Then
      v_Error := '当前停诊时间与已申请停诊时间范围存在重叠，请检查！';
      Raise Err_Custom;
    End If;
  
    For c_已停号码 In (Select 停诊号码
                   From 临床出诊停诊记录
                   Where 记录id Is Null And Not (开始时间 > 终止时间_In Or Nvl(失效时间, 终止时间) < 开始时间_In) And 申请人 = 申请人_In And
                         停诊号码 Is Not Null) Loop
      If 停诊号码_In Is Null Then
        v_已停号码 := v_已停号码 || ',' || c_已停号码.停诊号码;
      Else
        For c_号码 In (Select Column_Value As 号码 From Table(f_Str2list(停诊号码_In))) Loop
          If Instr(',' || c_已停号码.停诊号码 || ',', ',' || c_号码.号码 || ',') > 0 Then
            v_已停号码 := v_已停号码 || ',' || c_号码.号码;
          End If;
        End Loop;
      End If;
    End Loop;
    If v_已停号码 Is Not Null Then
      v_已停号码 := Substr(v_已停号码, 2);
      v_Error    := ' 号码(' || v_已停号码 || ')当前停诊时间与已申请停诊时间范围存在重叠，请检查！';
      Raise Err_Custom;
    End If;
  
    Insert Into 临床出诊停诊记录
      (ID, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 登记人, 停诊号码)
    Values
      (临床出诊停诊记录_Id.Nextval, 开始时间_In, 终止时间_In, 停诊原因_In, 申请人_In, 申请时间_In, 登记人_In, 停诊号码_In);
  
    Return;
  End If;

  --取消申请 
  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该申请已被审批，不能取消申请。';
    Raise Err_Custom;
  End If;

  Delete 临床出诊停诊记录 Where ID = Id_In;
  If Sql%NotFound Then
    v_Error := '该申请可能已被他人取消申请，请刷新后查看...';
    Raise Err_Custom;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Apply;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Audit
(
  操作类型_In Number,
  Id_In       临床出诊停诊记录.Id%Type,
  审批人_In   临床出诊停诊记录.审批人%Type := Null,
  审批时间_In 临床出诊停诊记录.审批时间%Type := Null
) As
  --功能：审批停诊安排 
  --参数： 
  --       状态_In：1-审批，2-取消审批 
  n_Count Number;

  v_Error Varchar2(255);
  Err_Custom Exception;
Begin
  If Nvl(操作类型_In, 0) = 1 Then
    --审批 
    Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 审批人 Is Not Null;
    If n_Count <> 0 Then
      v_Error := '该申请已被审批，不能再次审批！';
      Raise Err_Custom;
    End If;
  
    Update 临床出诊停诊记录 Set 审批人 = 审批人_In, 审批时间 = 审批时间_In Where ID = Id_In;
    If Sql%NotFound Then
      v_Error := '该申请可能已被取消申请，请刷新后查看...';
      Raise Err_Custom;
    End If;
  
    --对出诊记录进行停诊标记 
    For c_记录 In (Select a.Id, Greatest(a.开始时间, b.开始时间) As 停诊开始时间, Least(a.终止时间, b.终止时间) As 停诊终止时间, b.停诊原因, c.号码, a.是否序号控制,
                        a.是否分时段
                 From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
                 Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                       (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                       b.Id = Id_In And Not (a.开始时间 > b.终止时间 Or a.终止时间 < b.开始时间) And Nvl(a.是否发布, 0) = 1 And
                       (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
    
      Update 临床出诊记录
      Set 停诊开始时间 = c_记录.停诊开始时间, 停诊终止时间 = c_记录.停诊终止时间, 停诊原因 = c_记录.停诊原因
      Where ID = c_记录.Id;
    
      --调整"临床出诊序号控制.是否停诊"为1 
      Update 临床出诊序号控制 A
      Set 是否停诊 = 1
      Where 记录id = c_记录.Id And 开始时间 Between c_记录.停诊开始时间 And c_记录.停诊终止时间 And Nvl(c_记录.是否序号控制, 0) = 1 And
            Nvl(c_记录.是否分时段, 0) = 1;
    
      Insert Into 病人服务信息记录
        (ID, 通知类型, 记录id, 挂号id, 号源id, 号码, 科室id, 项目id, 医生id, 医生姓名, 病人id, 登记人, 登记时间)
        Select 病人服务信息记录_Id.Nextval, 1, a.Id, b.Id, c.Id, c.号码, c.科室id, a.项目id, a.医生id, a.医生姓名, b.病人id, 审批人_In, 审批时间_In
        From 临床出诊记录 A, 病人挂号记录 B, 临床出诊号源 C
        Where a.Id = b.出诊记录id And a.号源id = c.Id And b.记录状态 = 1 And a.Id = c_记录.Id And
              (b.记录性质 = 1 And b.发生时间 Between a.停诊开始时间 And a.停诊终止时间 Or
              b.记录性质 = 2 And b.预约时间 Between a.停诊开始时间 And a.停诊终止时间);
    
      --消息推送 
      -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
      Begin
        Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
          Using 17, 1 || ',' || c_记录.Id || ',' || c_记录.号码;
      Exception
        When Others Then
          Null;
      End;
    End Loop;
    Return;
  End If;

  --取消审批 
  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 终止时间 < Sysdate;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已失效，不能取消审批！';
    Raise Err_Custom;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 失效时间 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已被终止，不能取消审批！';
    Raise Err_Custom;
  End If;

  Select Count(1)
  Into n_Count
  From 临床出诊记录 A, 临床出诊停诊记录 B, 病人服务信息记录 C
  Where Nvl(a.替诊医生姓名, a.医生姓名) = b.申请人 And Nvl(a.替诊医生id, a.医生id) Is Not Null And a.Id = c.记录id And
        (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And c.处理人 Is Not Null And b.Id = Id_In;
  If Nvl(n_Count, 0) <> 0 Then
    v_Error := '该停诊安排的部分停诊信息已被处理，不能取消审批！';
    Raise Err_Custom;
  End If;

  Update 临床出诊停诊记录 Set 审批人 = Null, 审批时间 = Null Where ID = Id_In And 审批时间 Is Not Null;
  If Sql%NotFound Then
    v_Error := '该安排可能已被他人取消审批，请刷新后查看...';
    Raise Err_Custom;
  End If;

  For c_记录 In (Select a.Id, c.号码
               From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
               Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                     (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                     b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                     Nvl(a.是否发布, 0) = 1 And (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
  
    Update 临床出诊记录 Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null Where ID = c_记录.Id;
  
    --调整"临床出诊序号控制.是否停诊"为0 
    Update 临床出诊序号控制 Set 是否停诊 = 0 Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1;
  
    Delete 病人服务信息记录 Where 记录id = c_记录.Id And 通知类型 = 1 And 处理人 Is Null;
  
    --消息推送 
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
    Exception
      When Others Then
        Null;
    End;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Audit;
/

--121369:冉俊明,2018-02-07,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_临床出诊停诊_Stop
(
  Id_In       临床出诊停诊记录.Id%Type,
  终止人_In   临床出诊停诊记录.取消人%Type,
  终止时间_In 临床出诊停诊记录.失效时间%Type := Null
) As
  --功能：终止停诊安排 
  --参数： 
  --       终止时间_In：Null-立即终止，其它-具体的终止时间 
  v_Error Varchar2(255);
  Err_Custom Exception;

  n_Count Number;
Begin
  If 终止时间_In Is Not Null Then
    If 终止时间_In < Sysdate Then
      v_Error := '终止时间必须大于当前时间！';
      Raise Err_Custom;
    End If;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 终止时间 < Sysdate;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已失效，不能终止！';
    Raise Err_Custom;
  End If;

  Select Count(1) Into n_Count From 临床出诊停诊记录 Where ID = Id_In And 失效时间 Is Not Null;
  If n_Count <> 0 Then
    v_Error := '该停诊安排已被终止，不能再终止！';
    Raise Err_Custom;
  End If;

  Update 临床出诊停诊记录
  Set 失效时间 = Nvl(终止时间_In, Sysdate), 取消人 = 终止人_In, 取消时间 = Sysdate
  Where ID = Id_In And 审批人 Is Not Null;
  If Sql%NotFound Then
    v_Error := '该停诊安排还未审批，不能终止！';
    Raise Err_Custom;
  End If;

  For c_记录 In (Select a.Id, c.号码, a.停诊终止时间, a.是否序号控制, a.是否分时段
               From 临床出诊记录 A, 临床出诊停诊记录 B, 临床出诊号源 C
               Where ((a.替诊医生姓名 Is Null And a.医生id Is Not Null And a.医生姓名 = b.申请人) Or
                     (a.替诊医生姓名 Is Not Null And a.替诊医生id Is Not Null And a.替诊医生姓名 = b.申请人)) And a.号源id = c.Id And
                     b.Id = Id_In And (a.开始时间 Between b.开始时间 And b.终止时间 Or a.终止时间 Between b.开始时间 And b.终止时间) And
                     Nvl(a.是否发布, 0) = 1 And a.停诊终止时间 > Nvl(终止时间_In, Sysdate) And
                     (b.停诊号码 Is Null Or Instr(',' || b.停诊号码 || ',', ',' || c.号码 || ',') > 0)) Loop
  
    Update 临床出诊记录
    Set 停诊开始时间 = Case
                   When 停诊开始时间 >= Nvl(终止时间_In, Sysdate) Then
                    Null
                   Else
                    停诊开始时间
                 End,
        停诊终止时间 = Case
                   When 停诊开始时间 >= Nvl(终止时间_In, Sysdate) Then
                    Null
                   Else
                    Nvl(终止时间_In, Sysdate)
                 End
    Where ID = c_记录.Id;
  
    --调整"临床出诊序号控制.是否停诊"为0 
    Update 临床出诊序号控制
    Set 是否停诊 = 0
    Where 记录id = c_记录.Id And Nvl(是否停诊, 0) = 1 And 开始时间 Between Nvl(终止时间_In, Sysdate) And c_记录.停诊终止时间 And
          Nvl(c_记录.是否序号控制, 0) = 1 And Nvl(c_记录.是否分时段, 0) = 1;
  
    --消息推送 
    -- 停诊类型(1-停诊,2-取消停诊),出诊记录ID,停诊号码 
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 17, 2 || ',' || c_记录.Id || ',' || c_记录.号码;
    Exception
      When Others Then
        Null;
    End;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊停诊_Stop;
/

--121369:冉俊明,2018-02-12,停诊安排可以对医生的多个号源进行选择停诊
Create Or Replace Procedure Zl_Clinicvisitmodify
(
  号源id_In     In 临床出诊记录.号源id%Type,
  安排id_In     In 临床出诊记录.号源id%Type,
  出诊日期_In   In 临床出诊记录.出诊日期%Type,
  登记人_In     In 临床出诊记录.登记人%Type,
  登记时间_In   In 临床出诊记录.登记时间%Type,
  是否已换休_In In Number := 0
) As
  --功能：根据停诊安排和法定节假日调整出诊记录的出诊/预约情况 
  --入参： 
  --     是否已换休_In 主要用于换休后进行停诊处理 
  --说明： 
  --     临床出诊号源.假日控制状态：0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制 
  --     1-停诊，在停诊安排时间范围内 
  --     2-停诊，在法定节假日内 
  --       2.1临床出诊号源.假日控制状态=0 
  --       2.2临床出诊号源.假日控制状态=3，且设置了允许预约/允许挂号，但该上班时段不在设置的允许预约/允许挂号的时间范围内 
  --     3-禁止预约，在法定节假日内， 
  --       3.1临床出诊号源.假日控制状态=2 
  --       3.3临床出诊号源.假日控制状态=3，设置了允许预约/允许挂号，且该上班时段在设置的允许挂号的时间范围内，但不在设置的允许预约时间范围内 
  --     else-正常出诊 

  n_假日控制状态 临床出诊号源.假日控制状态%Type;
  n_是否假日换休 临床出诊号源.是否假日换休%Type;
  v_号码         临床出诊号源.号码%Type;

  d_原上班日期 临床出诊记录.出诊日期%Type;
  d_调休日期   临床出诊记录.出诊日期%Type;

  d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
  d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
  v_停诊原因     临床出诊记录.停诊原因%Type;

  d_假日开始日期 法定假日表.开始日期%Type;
  d_假日终止日期 法定假日表.终止日期%Type;
  v_允许预约     法定假日表.允许预约日期%Type;
  v_允许挂号     法定假日表.允许挂号日期%Type;

  d_停止预约开始时间 临床出诊记录.停诊开始时间%Type;
  d_停止预约终止时间 临床出诊记录.停诊终止时间%Type;

  n_Count    Number(2);
  n_允许预约 Number(2);
  n_允许挂号 Number(2);

  Procedure Stopbespeak
  (
    记录id_In   In 临床出诊记录.Id%Type,
    开始时间_In In 临床出诊记录.开始时间%Type,
    终止时间_In In 临床出诊记录.终止时间%Type
  ) As
    --功能：禁止预约 
    --说明： 
    --      分时段且序号控制的，修改"临床出诊序号控制.是否预约"等于1的为0；取消发布时根据"预约顺序号"恢复 
    --      分时段且不序号控制的，修改"临床出诊序号控制.是否预约"为0；取消发布时根据恢复为1 
    --      不分时段的，提供公共函数在挂号预约时检查预约时间是否在不允许预约的时间范围内 
  Begin
    Update 临床出诊序号控制 Set 是否预约 = 0 Where 记录id = 记录id_In And 开始时间 Between 开始时间_In And 终止时间_In;
  End Stopbespeak;

  Procedure Stopvisit
  (
    记录id_In       In 临床出诊记录.Id%Type,
    停诊开始时间_In In 临床出诊记录.停诊开始时间%Type,
    停诊终止时间_In In 临床出诊记录.停诊终止时间%Type,
    停诊原因_In     In 临床出诊记录.停诊原因%Type
  ) As
    --功能：停诊 
    --说明： 
    --     同一条出诊记录可以存在多条停诊记录，临床出诊记录的停诊开始时间为多条停诊记录的最小开始时间，停诊终止时间为多条停诊记录的最大终止时间 
  
    d_停诊开始时间 临床出诊记录.停诊开始时间%Type;
    d_停诊终止时间 临床出诊记录.停诊终止时间%Type;
    v_停诊原因     临床出诊记录.停诊原因%Type;
  Begin
    If 停诊开始时间_In >= 停诊终止时间_In Then
      Return;
    End If;
  
    --产生停诊记录 
    Insert Into 临床出诊停诊记录
      (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
      Select 临床出诊停诊记录_Id.Nextval, ID, 停诊开始时间_In, 停诊终止时间_In, 停诊原因_In, Nvl(医生姓名, 登记人_In), 登记时间_In, 登记人_In, 登记时间_In, 登记人_In
      From 临床出诊记录
      Where ID = 记录id_In;
  
    Begin
      Select Min(a.开始时间), Max(a.终止时间), Max(a.停诊原因)
      Into d_停诊开始时间, d_停诊终止时间, v_停诊原因
      From 临床出诊停诊记录 A
      Where a.记录id = 记录id_In And a.取消时间 Is Null;
    Exception
      When Others Then
        d_停诊开始时间 := Null;
        d_停诊终止时间 := Null;
        v_停诊原因     := Null;
    End;
  
    Update 临床出诊记录
    Set 停诊开始时间 = d_停诊开始时间, 停诊终止时间 = d_停诊终止时间, 停诊原因 = v_停诊原因
    Where ID = 记录id_In;
  
    --调整"临床出诊序号控制.是否停诊"为1 
    Update 临床出诊序号控制 A
    Set 是否停诊 = 1
    Where 记录id = 记录id_In And 开始时间 Between 停诊开始时间_In And 停诊终止时间_In And Exists
     (Select 1 From 临床出诊记录 Where ID = a.记录id And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 1);
  End Stopvisit;

  Procedure Changedaysoff
  (
    号源id_In     In 临床出诊记录.号源id%Type,
    安排id_In     In 临床出诊记录.安排id%Type,
    出诊日期_In   In 临床出诊记录.出诊日期%Type,
    原上班日期_In In 临床出诊记录.出诊日期%Type,
    调休日期_In   In 临床出诊记录.出诊日期%Type
  ) As
    --功能：换休处理 
    n_安排id 临床出诊记录.安排id%Type;
    l_记录id t_Numlist := t_Numlist();
    n_Count  Number(2);
  Begin
    --1.前面的安排换到今日 
    If 原上班日期_In Is Not Null Then
      --1.1.前面的日期没有安排则不处理 
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --[1]删除今日现有的安排 
        Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In;
        Zl_临床出诊记录_Batchdelete(l_记录id);
      
        --[2]复制安排 
        For c_换休记录 In (Select ID, 是否发布 From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 原上班日期_In) Loop
          Zl_临床出诊记录_Copy(c_换休记录.Id, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, c_换休记录.是否发布);
        End Loop;
      
        --[3]重新对今日进行停诊安排和法定节假日调整 
        For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
          Zl_Clinicvisitmodify(号源id_In, 安排id_In, 出诊日期_In, 登记人_In, 登记时间_In, 1);
        End Loop;
      End If;
    End If;
  
    --2.今日的安排换到前面 
    If 调休日期_In Is Not Null Then
      --2.1.今日没有安排则不处理 
      Select Count(1)
      Into n_Count
      From 临床出诊记录
      Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And Rownum < 2;
    
      If Nvl(n_Count, 0) > 0 Then
        --2.2.前面那一天的安排已存在预约挂号记录则不替换(有漏洞) 
        Select Count(1)
        Into n_Count
        From 临床出诊记录 A, 病人挂号记录 B
        Where a.Id = b.出诊记录id And a.号源id = 号源id_In And a.出诊日期 = 调休日期_In And Rownum < 2;
      
        If Nvl(n_Count, 0) = 0 Then
          --[1]记录前面那一天的原安排ID,没有就不处理 
          Begin
            Select ID
            Into n_安排id
            From (Select Rownum As Rn, ID
                   From 临床出诊安排
                   Where 号源id = 号源id_In And 调休日期_In Between 开始时间 And 终止时间 And 审核时间 Is Not Null
                   Order By 登记时间 Desc)
            Where Rn < 2;
          Exception
            When Others Then
              n_安排id := 0;
          End;
        
          If Nvl(n_安排id, 0) <> 0 Then
            --[2]删除前面那一天现有的安排 
            Select ID Bulk Collect Into l_记录id From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In;
            Zl_临床出诊记录_Batchdelete(l_记录id);
          
            --[3]复制安排 
            For c_换休记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In) Loop
              --肯定是发布了的 
              Zl_临床出诊记录_Copy(c_换休记录.Id, n_安排id, 调休日期_In, 登记人_In, 登记时间_In, 1);
            
            End Loop;
          
            --[4]重新对前面那一天进行停诊安排和法定节假日调整 
            For c_记录 In (Select ID From 临床出诊记录 Where 号源id = 号源id_In And 出诊日期 = 调休日期_In) Loop
              Zl_Clinicvisitmodify(号源id_In, 安排id_In, 调休日期_In, 登记人_In, 登记时间_In, 1);
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End Changedaysoff;
Begin
  Begin
    Select Nvl(b.假日控制状态, 0), Nvl(b.是否假日换休, 0), 号码
    Into n_假日控制状态, n_是否假日换休, v_号码
    From 临床出诊号源 B
    Where b.Id = 号源id_In;
  Exception
    When Others Then
      --没有找到号源，直接退出 
      Return;
  End;

  --================================================================================ 
  --【1】假日换休处理 
  --说明：只能用后面的日期向前面检查，因为后面的日期可能还没有制定安排 
  --================================================================================ 
  If Nvl(是否已换休_In, 0) = 0 Then
    --确定法定节假日是否需要换休 
    If Nvl(n_是否假日换休, 0) = 1 Then
      --1.前面的安排换到今日 
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日) 
        Select a.终止日期
        Into d_原上班日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.开始日期 And a.终止日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_原上班日期 := Null;
      End;
    
      --2.今日的安排换到前面 
      Begin
        --开始日期：原本休息日(即调休日) ， 终止日期：原本上班日(即被调休日) 
        Select a.开始日期
        Into d_调休日期
        From 法定假日表 A
        Where a.性质 = 1 And 出诊日期_In = a.终止日期 And a.开始日期 < 出诊日期_In And Rownum < 2;
      Exception
        When Others Then
          d_调休日期 := Null;
      End;
    
      Changedaysoff(号源id_In, 安排id_In, 出诊日期_In, d_原上班日期, d_调休日期);
    End If;
  End If;

  For c_记录 In (Select ID, 出诊日期, 开始时间, 终止时间
               From 临床出诊记录
               Where 号源id = 号源id_In And 出诊日期 = 出诊日期_In And 上班时段 Is Not Null) Loop
    --================================================================================ 
    --【2】停诊安排停诊处理 
    --================================================================================ 
    For c_停诊 In (Select a.开始时间, Nvl(a.失效时间, a.终止时间) As 终止时间, a.停诊原因
                 From 临床出诊停诊记录 A, 临床出诊记录 B
                 Where a.申请人 = b.医生姓名 And a.记录id Is Null And a.审批时间 Is Not Null And b.医生id Is Not Null And
                       b.Id = c_记录.Id And c_记录.开始时间 < Nvl(a.失效时间, a.终止时间) And c_记录.终止时间 > a.开始时间 And
                       (a.停诊号码 Is Null Or Instr(',' || a.停诊号码 || ',', ',' || v_号码 || ',') > 0)
                 Order By a.审批时间) Loop
    
      d_停诊开始时间 := c_停诊.开始时间;
      d_停诊终止时间 := c_停诊.终止时间;
      If d_停诊开始时间 < c_记录.开始时间 Then
        d_停诊开始时间 := c_记录.开始时间;
      End If;
      If d_停诊终止时间 > c_记录.终止时间 Then
        d_停诊终止时间 := c_记录.终止时间;
      End If;
      Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, c_停诊.停诊原因);
    End Loop;
  
    --================================================================================ 
    --【3】法定节假日停诊及禁止预约处理 
    --================================================================================ 
    --1.查找含有上班时段时间的节假日，以第一个为准（开始时间升序排序），一般也只有一个 
    Begin
      Select 开始日期, 终止日期, 节日名称, 允许预约日期, 允许挂号日期
      Into d_假日开始日期, d_假日终止日期, v_停诊原因, v_允许预约, v_允许挂号
      From (Select a.开始日期, a.终止日期, a.节日名称, a.允许预约日期, a.允许挂号日期
             From 法定假日表 A
             Where a.性质 = 0 And c_记录.开始时间 < a.终止日期 And c_记录.终止时间 > a.开始日期
             Order By a.开始日期)
      Where Rownum < 2;
    Exception
      When Others Then
        d_假日开始日期 := Null;
        d_假日终止日期 := Null;
        v_停诊原因     := Null;
        v_允许预约     := Null;
        v_允许挂号     := Null;
    End;
  
    If v_停诊原因 Is Not Null Then
      --假日控制状态:0-不上班;1-上班且开放预约;2-上班但不开放预约;3-受节假日设置控制 
      If Nvl(n_假日控制状态, 0) = 0 Then
        --不上班，停诊 
        d_停诊开始时间 := d_假日开始日期;
        d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停诊开始时间 < c_记录.开始时间 Then
          d_停诊开始时间 := c_记录.开始时间;
        End If;
        If d_停诊终止时间 > c_记录.终止时间 Then
          d_停诊终止时间 := c_记录.终止时间;
        End If;
        Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
      Elsif Nvl(n_假日控制状态, 0) = 2 Then
        --允许挂号，但禁止预约 
        d_停止预约开始时间 := d_假日开始日期;
        d_停止预约终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
        If d_停止预约开始时间 < c_记录.开始时间 Then
          d_停止预约开始时间 := c_记录.开始时间;
        End If;
        If d_停止预约终止时间 > c_记录.终止时间 Then
          d_停止预约终止时间 := c_记录.终止时间;
        End If;
        Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
      Elsif Nvl(n_假日控制状态, 0) = 3 Then
        --没有"允许挂号"的就一定没有"允许预约"的 
        If v_允许挂号 Is Not Null Then
          --2.检查是否有包含上班时段时间的"允许挂号" 
          --因为上班时段最多24小时，所以查出的结果最多两天，且这两天一定是连续的 
          n_允许挂号 := 0;
          For c_允许挂号 In (With 临时表 As
                            (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                   To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                            From Table(f_Str2list(v_允许挂号, ';'))
                            Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                  c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                            Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                           Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                           From 临时表 A, 临时表 B
                           Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
          
            n_允许挂号 := 1;
            n_允许预约 := 0;
            --3.检查是否有包含上班时段时间的"允许预约" 
            For c_允许预约 In (With 临时表 As
                              (Select To_Date(Column_Value, 'yyyy-mm-dd') As 开始时间,
                                     To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 As 终止时间
                              From Table(f_Str2list(v_允许预约, ';'))
                              Where c_记录.开始时间 < To_Date(Column_Value, 'yyyy-mm-dd') + 1 - 1 / 24 / 60 / 60 And
                                    c_记录.终止时间 > To_Date(Column_Value, 'yyyy-mm-dd')
                              Order By To_Date(Column_Value, 'yyyy-mm-dd'))
                             Select a.开始时间, Nvl(b.终止时间, a.终止时间) As 终止时间
                             From 临时表 A, 临时表 B
                             Where a.终止时间 = b.开始时间(+) - 1 / 24 / 60 / 60 And Rownum < 2) Loop
            
              n_允许预约 := 1;
              --在"允许挂号","允许预约"时间范围内的不需要处理 
            
              --检查前后是否需要禁止预约 
              If c_记录.开始时间 < c_允许预约.开始时间 And c_允许挂号.开始时间 < c_允许预约.开始时间 Then
                If c_记录.开始时间 < c_允许挂号.开始时间 Then
                  d_停止预约开始时间 := c_允许挂号.开始时间;
                Else
                  d_停止预约开始时间 := c_记录.开始时间;
                End If;
                d_停止预约终止时间 := c_允许预约.开始时间;
                Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
              End If;
            
              If c_记录.终止时间 > c_允许预约.终止时间 And c_允许挂号.终止时间 > c_允许预约.终止时间 Then
                d_停止预约开始时间 := c_允许预约.终止时间;
                If c_记录.终止时间 > c_允许挂号.终止时间 Then
                  d_停止预约开始时间 := c_允许挂号.终止时间;
                Else
                  d_停止预约开始时间 := c_记录.终止时间;
                End If;
                Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
              End If;
            End Loop;
          
            --允许挂号，但禁止预约 
            If Nvl(n_允许预约, 0) = 0 Then
              d_停止预约开始时间 := c_允许挂号.开始时间;
              d_停止预约终止时间 := c_允许挂号.终止时间;
              If d_停止预约开始时间 < c_记录.开始时间 Then
                d_停止预约开始时间 := c_记录.开始时间;
              End If;
              If d_停止预约终止时间 > c_记录.终止时间 Then
                d_停止预约终止时间 := c_记录.终止时间;
              End If;
              Stopbespeak(c_记录.Id, d_停止预约开始时间, d_停止预约终止时间);
            End If;
          
            --检查前后是否需要停诊 
            If c_记录.开始时间 < c_允许挂号.开始时间 And d_假日开始日期 < c_允许挂号.开始时间 Then
              If c_记录.开始时间 < d_假日开始日期 Then
                d_停诊开始时间 := d_假日开始日期;
              Else
                d_停诊开始时间 := c_记录.开始时间;
              End If;
              d_停诊终止时间 := c_允许挂号.开始时间;
              Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
            End If;
          
            If c_记录.终止时间 > c_允许挂号.终止时间 And d_假日终止日期 > c_允许挂号.终止时间 Then
              d_停诊开始时间 := c_允许挂号.终止时间;
              If c_记录.终止时间 > d_假日终止日期 Then
                d_停诊终止时间 := d_停诊终止时间;
              Else
                d_停诊终止时间 := c_记录.终止时间;
              End If;
              Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
            End If;
          End Loop;
        
          --不在设置的允许挂号时间范围内，停诊 
          If Nvl(n_允许挂号, 0) = 0 Then
            d_停诊开始时间 := d_假日开始日期;
            d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
            If d_停诊开始时间 < c_记录.开始时间 Then
              d_停诊开始时间 := c_记录.开始时间;
            End If;
            If d_停诊终止时间 > c_记录.终止时间 Then
              d_停诊终止时间 := c_记录.终止时间;
            End If;
            Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
          End If;
        Else
          --未设置允许挂号/允许预约，则停诊 
          d_停诊开始时间 := d_假日开始日期;
          d_停诊终止时间 := d_假日终止日期 + 1 - 1 / 24 / 60 / 60;
          If d_停诊开始时间 < c_记录.开始时间 Then
            d_停诊开始时间 := c_记录.开始时间;
          End If;
          If d_停诊终止时间 > c_记录.终止时间 Then
            d_停诊终止时间 := c_记录.终止时间;
          End If;
          Stopvisit(c_记录.Id, d_停诊开始时间, d_停诊终止时间, v_停诊原因);
        End If;
      End If;
    End If;
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Clinicvisitmodify;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品库存_可用数量异常处理
(
  库房id_In In 药品库存.库房id%Type,
  药品id_In In 药品库存.药品id%Type,
  批次_In   In 药品库存.批次%Type := Null
) Is

Begin
  Update 药品库存
  Set 可用数量 = 实际数量
  Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And 批次 = Nvl(批次_In, 批次) And Nvl(可用数量, 0) > Nvl(实际数量, 0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_可用数量异常处理;
/

--121519:焦博,2018-02-07,调整Zl_病人预交记录_Delete,先作废回收票据,再打印预交红票
CREATE OR REPLACE Procedure Zl_病人预交记录_Delete
(
  Id_In         病人预交记录.Id%Type,
  摘要_In       病人预交记录.摘要%Type,
  操作员编号_In 病人预交记录.操作员编号%Type,
  操作员姓名_In 病人预交记录.操作员姓名%Type,
  帐户退费_In   Number := 1,
  冲预交id_In   病人预交记录.Id%Type := Null,
  票据号_In     病人预交记录.实际票号%Type := Null,
  领用id_In     票据领用记录.Id%Type := Null
) As
  Cursor c_Moneyinfo Is
    Select ID, NO, 金额, 结算方式, 病人id, 预交类别
    From 病人预交记录
    Where ID = Id_In And 记录性质 = 1 And 记录状态 = 1;
  r_Moneyrow c_Moneyinfo%RowType;

  v_打印id   票据打印内容.Id%Type;
  v_性质     结算方式.性质%Type;
  v_现金     结算方式.名称%Type;
  v_个人帐户 结算方式.名称%Type;
  n_返回值   病人余额.预交余额%Type;
  n_预交id   病人预交记录.Id%Type;
  v_Date     Date;
  Err_Custom Exception;
  n_组id 财务缴款分组.Id%Type;
  v_Msg  Varchar2(500);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --获取结算方式名称
  Begin
    Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_现金 := '现金';
  End;
  Begin
    Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3;
  Exception
    When Others Then
      v_个人帐户 := '个人帐户';
  End;

  Open c_Moneyinfo;
  Fetch c_Moneyinfo
    Into r_Moneyrow;

  --首先判断要退款的记录是否存在
  If c_Moneyinfo%RowCount = 0 Then
    Close c_Moneyinfo;
    Raise Err_Custom;
  Else
    Select Sysdate Into v_Date From Dual;
    If 冲预交id_In Is Not Null Then
      n_预交id := 冲预交id_In;
    Else
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
    End If;
  
    --预交退款
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持个人帐户退费,正常处理
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, 摘要_In, -1 * 金额, 结算方式, 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, 缴款单位,
               单位开户行, 单位帐号, n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    Else
      --不支持时,处理成现金,记录性质为2的摘要填标志,为3的更新新输入的摘要
      Insert Into 病人预交记录
        (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 摘要, 金额, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 缴款单位, 单位开户行, 单位帐号, 缴款组id,
         预交类别, 卡类别id, 卡号, 交易流水号, 交易说明, 合作单位, 结算卡序号)
        Select n_预交id, NO, 实际票号, 记录性质, 2, 病人id, 主页id, 科室id, Nvl(摘要_In, '个人帐户退款'), -1 * 金额,
               Decode(结算方式, v_个人帐户, v_现金, 结算方式), 结算号码, v_Date, 操作员编号_In, 操作员姓名_In, Decode(结算方式, v_个人帐户, Null, 缴款单位),
               Decode(结算方式, v_个人帐户, Null, 单位开户行), Decode(结算方式, v_个人帐户, Null, 单位帐号), n_组id, 预交类别, 卡类别id, 卡号, 交易流水号, 交易说明,
               合作单位, 结算卡序号
        From 病人预交记录
        Where ID = Id_In;
    End If;
  
    Update 病人预交记录 Set 记录状态 = 3, 摘要 = 摘要_In Where ID = Id_In;
  
    --处理相关汇总表
    --人员缴款余额(注意包括处理个人帐户的结算方式)
    If Nvl(帐户退费_In, 0) = 1 Then
      --支持退个人帐户时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    Else
      --不支持时的处理
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式)
      Returning 余额 Into n_返回值;
    
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式), 1, -r_Moneyrow.金额);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = Decode(r_Moneyrow.结算方式, v_个人帐户, v_现金, r_Moneyrow.结算方式) And
              Nvl(余额, 0) = 0;
      End If;
    End If;
  
    --病人(预交)余额(不管是退现金还是个人帐户都应该减少)
    --判断要退款的性质
    Select b.性质 Into v_性质 From 病人预交记录 A, 结算方式 B Where a.结算方式 = b.名称(+) And a.Id = Id_In;
    If Nvl(v_性质, 1) <> 5 Then
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - r_Moneyrow.金额
      Where 性质 = 1 And 病人id = r_Moneyrow.病人id And Nvl(类型, 2) = Nvl(r_Moneyrow.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 性质, 类型, 预交余额, 费用余额)
        Values
          (r_Moneyrow.病人id, 1, Nvl(r_Moneyrow.预交类别, 2), -r_Moneyrow.金额, 0);
        n_返回值 := -r_Moneyrow.金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额
        Where 病人id = r_Moneyrow.病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End If;
  
    --作废收回票据(可能以前没有使用票据,无法收回)
    Begin
      Select ID
      Into v_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And b.数据性质 = 2 And b.No = r_Moneyrow.No
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
  
    If v_打印id Is Not Null Then
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
        Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, v_Date, 操作员姓名_In
        From 票据使用明细
        Where 打印id = v_打印id And 票种 = 2 And 性质 = 1;
    End If;
  
    --处理票据
    If 票据号_In Is Not Null Then
      Select 票据打印内容_Id.Nextval Into v_打印id From Dual;
    
      --发出票据
      Insert Into 票据打印内容 (ID, 数据性质, NO) Values (v_打印id, 2, r_Moneyrow.No);
    
      Insert Into 票据使用明细
        (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
      Values
        (票据使用明细_Id.Nextval, 2, 票据号_In, 1, 6, 领用id_In, v_打印id, v_Date, 操作员姓名_In);
    
      --状态改动
      Update 票据领用记录
      Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
      Where ID = Nvl(领用id_In, 0);
    End If;
  
    Close c_Moneyinfo;
  End If;
  --消息推送;
  Select Id_In || ',' || 帐户退费_In Into v_Msg From Dual;
  Begin
    Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
      Using 12, v_Msg;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20999, '[ZLSOFT]没有发现要退款的预交记录,该记录可能已经退除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人预交记录_Delete;
/

--121587:冉俊明,2018-02-08,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_导入
(
  号码_In 挂号安排.号码%Type := Null,
  开始_In Number := 1
) As
  -------------------------------------------------------------------------
  --功能说明：导放临床出诊表,主要是根据挂号安排，挂号计划安排等表进行数据导入
  --入参：
  --    开始_In:传入号码时有效，表示第一个
  -------------------------------------------------------------------------
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  l_限制id t_Numlist := t_Numlist();
  n_Count  Number(18);

  v_时间段           Varchar2(4000);
  n_出诊id           临床出诊表.Id%Type;
  v_全院号源归属站点 部门表.站点%Type;

  Procedure Zl_Register_Import
  (
    号码_In             挂号安排.号码%Type,
    出诊id_In           临床出诊表.Id%Type,
    全院号源归属站点_In 部门表.站点%Type
  ) As
    n_号源id   临床出诊号源.Id%Type;
    d_建档时间 临床出诊号源.建档时间%Type;
  
    n_出诊id 临床出诊表.Id%Type;
    n_安排id 临床出诊安排.Id%Type;
  
    n_限制id 临床出诊号源限制.Id%Type;
    n_诊室id 门诊诊室.Id%Type;
  
    n_是否导入     Number(2);
    n_是否临时安排 临床出诊安排.是否临时安排%Type;
  
    n_Count  Number(18);
    l_限制id t_Numlist := t_Numlist();
  Begin
    For c_号源 In (Select a.Id, a.号类, a.号码, a.科室id, a.项目id, a.医生姓名, Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.序号, a.周日,
                        a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.病案必须, a.分诊方式, a.序号控制, a.开始时间, a.终止时间, a.执行时间, a.执行计划id,
                        a.默认时段间隔, a.预约天数, Nvl(a.是否删除, 0) As 是否删除,
                        Nvl(a.停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) As 停用日期, Nvl(b.站点, 全院号源归属站点_In) As 站点
                 From 挂号安排 A, 部门表 B
                 Where a.科室id = b.Id And a.号码 = 号码_In
                      --科室，项目，医生相同的已经导入了一个号别就不再导入
                       And Not Exists (Select 1
                        From 临床出诊号源
                        Where 科室id = a.科室id And 项目id = a.项目id And Nvl(医生姓名, '-') = Nvl(a.医生姓名, '-') And
                              Nvl(医生id, 0) = Nvl(a.医生id, 0))) Loop
    
      n_是否导入 := 1;
      --对于科室，项目，医生三者都相同的多个号别，首先考虑导入有效号别中的第一个，如果没有，则导入失效号别中的第一个
      Select Count(1)
      Into n_Count
      From 挂号安排
      Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And Nvl(医生姓名, '-') = Nvl(c_号源.医生姓名, '-') And
            Nvl(医生id, 0) = Nvl(c_号源.医生id, 0);
      If Nvl(n_Count, 0) = 1 Then
        --科室，项目，医生是唯一的
        n_是否导入 := 1;
      Else
        --是否存在未停用且未删除的号别
        Select Count(1)
        Into n_Count
        From 挂号安排
        Where 科室id = c_号源.科室id And 项目id = c_号源.项目id And Nvl(医生姓名, '-') = Nvl(c_号源.医生姓名, '-') And
              Nvl(医生id, 0) = Nvl(c_号源.医生id, 0) And c_号源.是否删除 = 0 And
              (停用日期 Is Null Or 停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd'));
        If Nvl(n_Count, 0) = 0 Then
          --不存在未停用且未删除的号别，直接导入当前号别，即失效号别中的第一个
          n_是否导入 := 1;
        Elsif Nvl(n_Count, 0) = 1 Then
          --只存在一个未停用且未删除的号别，检查是不是当前号别
          If c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd') Then
            n_是否导入 := 1;
          Else
            n_是否导入 := 0;
          End If;
        Else
          --检查当前号别是否已停用或已删除
          If Not (c_号源.是否删除 = 0 And c_号源.停用日期 = To_Date('3000-01-01', 'yyyy-mm-dd')) Then
            --已停用或已删除则不导入
            n_是否导入 := 0;
          Else
            --当前号别安排/计划是否有效
            Select Count(1)
            Into n_Count
            From 挂号安排计划
            Where 安排id = c_号源.Id And 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                  Rownum < 2;
            If Nvl(n_Count, 0) = 0 Then
              --无计划
              Select Count(1)
              Into n_Count
              From 挂号安排 A
              Where a.Id = c_号源.Id And Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            Else
              --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
              --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
              --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的

              Select Count(1)
              Into n_Count
              From 挂号安排计划 A
              Where a.审核时间 Is Not Null And Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                    a.安排id = c_号源.Id And
                    (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                    Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                     (Select 1
                      From 挂号安排计划
                      Where 安排id = a.安排id And 审核时间 Is Not Null And
                            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')))) And
                    Not (a.周日 Is Null And a.周一 Is Null And a.周二 Is Null And a.周三 Is Null And a.周四 Is Null And
                     a.周五 Is Null And a.周六 Is Null);
            End If;
          
            If Nvl(n_Count, 0) <> 0 Then
              --当前号别安排有效
              n_是否导入 := 1;
            Else
              --当前号别安排无效
              n_是否导入 := 0;
            End If;
          End If;
        End If;
      End If;
    
      If Nvl(n_是否导入, 0) = 1 Then
        Select 临床出诊号源_Id.Nextval Into n_号源id From Dual;
      
        Select Nvl(Min(开始时间), Sysdate)
        Into d_建档时间
        From (Select Min(开始时间) As 开始时间
               From 挂号安排
               Where ID = c_号源.Id
               Union All
               Select Min(生效时间) As 开始时间
               From 挂号安排计划
               Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And 安排id = c_号源.Id);
      
        --1.处理临床出诊号源
        Insert Into 临床出诊号源
          (ID, 号类, 号码, 科室id, 项目id, 医生id, 医生姓名, 是否建病案, 预约天数, 出诊频次, 假日控制状态, 是否临床排班, 排班方式, 是否删除, 建档时间, 撤档时间)
        Values
          (n_号源id, c_号源.号类, c_号源.号码, c_号源.科室id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, c_号源.病案必须, c_号源.预约天数, c_号源.默认时段间隔, 2,
           0, 0, c_号源.是否删除, d_建档时间, c_号源.停用日期);
      
        --2.处理临床出诊停诊记录
        --一个医生一个停诊计划只导入一个，可能存在一个医生多个号别的情况，他们的停诊计划一样
        Insert Into 临床出诊停诊记录
          (ID, 记录id, 开始时间, 终止时间, 停诊原因, 申请人, 申请时间, 审批人, 审批时间, 登记人)
          Select 临床出诊停诊记录_Id.Nextval, Null, a.开始停止时间, a.结束停止时间, a.备注, b.医生姓名, a.制订日期, a.制订人, a.制订日期, a.制订人
          From 挂号安排停用状态 A, 挂号安排 B
          Where a.安排id = b.Id And b.Id = c_号源.Id And b.医生id Is Not Null And Not Exists
           (Select 1
                 From 临床出诊停诊记录
                 Where 记录id Is Null And 申请人 = b.医生姓名 And 开始时间 = a.开始停止时间 And 终止时间 = a.结束停止时间);
      
        --3.处理相关的出诊表数据
        --3.1 固定出诊表
        If c_号源.站点 Is Null Then
          n_出诊id := 出诊id_In;
        Else
          Begin
            Select ID Into n_出诊id From 临床出诊表 Where 排班方式 = 0 And Nvl(站点, '-') = c_号源.站点;
          Exception
            When Others Then
              n_出诊id := 0;
          End;
          If n_出诊id = 0 Then
            Update 临床出诊表
            Set 站点 = c_号源.站点
            Where 排班方式 = 0 And Nvl(站点, '-') = '-'
            Returning ID Into n_出诊id;
            If Sql%NotFound Then
              Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
              Insert Into 临床出诊表
                (ID, 排班方式, 出诊表名, 年份, 站点)
              Values
                (n_出诊id, 0, '固定出诊表', To_Number(To_Char(Sysdate, 'yyyy')), c_号源.站点);
            End If;
          End If;
        End If;
      
        --3.2导入临床出诊安排
        --失效的安排和计划不导入
        --只要生效时间大于当前时间或者不存在大于其生效时间小于当前时间的都是有效的，
        --因为1.生效时间和号码是唯一的，2.是以生效时间最近的来确定是有效的，
        --     即如果当前计划的生效时间小于等于当前时间且是所有生效时间小于等于当前时间的计划中生效时间最大的，则当前计划是有效的

        For c_详情 In (
                     --1.无计划的安排
                     Select a.Id As 安排id, -1 * Null As 计划id, a.科室id, a.项目id, a.医生姓名,
                             Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日, a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式,
                             a.序号控制, Nvl(a.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                             Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排 A
                     Where a.Id = c_号源.Id And Not Exists (Select 1
                            From 挂号安排计划
                            Where 安排id = a.Id And 审核时间 Is Not Null And
                                  Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) And
                           Nvl(a.终止时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate
                     Union All
                     --有计划的安排,只导入有效的
                     Select a.安排id, a.Id As 计划id, b.科室id, a.项目id, a.医生姓名, Decode(a.医生id, 0, Null, a.医生id) As 医生id, a.周日,
                            a.周一, a.周二, a.周三, a.周四, a.周五, a.周六, a.分诊方式, a.序号控制,
                            Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) As 开始时间,
                            Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) As 终止时间
                     From 挂号安排计划 A, 挂号安排 B
                     Where a.安排id = b.Id And a.审核时间 Is Not Null And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And b.Id = c_号源.Id And
                           (Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >= Sysdate Or
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And Not Exists
                            (Select 1
                             From 挂号安排计划
                             Where 安排id = a.安排id And 审核时间 Is Not Null And
                                   Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) < Sysdate And
                                   Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) >
                                   Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd'))))) Loop
        
          Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
        
          n_诊室id := Null;
          If Nvl(c_详情.分诊方式, 0) = 1 Then
            Begin
              If Nvl(c_详情.计划id, 0) <> 0 Then
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号计划诊室 B
                Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id And Rownum < 2;
              Else
                Select a.Id
                Into n_诊室id
                From 门诊诊室 A, 挂号安排诊室 B
                Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id And Rownum < 2;
              End If;
            Exception
              When Others Then
                n_诊室id := Null;
            End;
          End If;
        
          --a.临床出诊安排
          Select Count(1)
          Into n_是否临时安排
          From 临床出诊安排
          Where 出诊id = n_出诊id And 号源id = n_号源id And Rownum < 2;
          Insert Into 临床出诊安排
            (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间, 是否临时安排)
          Values
            (n_安排id, n_出诊id, n_号源id, c_详情.项目id, c_详情.医生id, c_详情.医生姓名, c_详情.开始时间, c_详情.终止时间, Zl_Username, c_详情.开始时间,
             n_是否临时安排);
        
          --b.临床出诊限制
          --说明：限约数等于0表示禁止预约，限约数为空表示不限制预约
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Select Count(1) Into n_Count From 挂号计划限制 Where 计划id = c_详情.计划id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号计划限制
                            Where 计划id = c_详情.计划id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号计划限制 A, (Select Distinct 星期 From 挂号计划时段 Where 计划id = c_详情.计划id) B
                Where a.限制项目 = b.星期(+) And 计划id = c_详情.计划id;
            End If;
          Else
            Select Count(1) Into n_Count From 挂号安排限制 Where 安排id = c_详情.安排id And Rownum < 2;
            If n_Count = 0 Then
              Insert Into 临床出诊限制
                (ID, 安排id, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 限制项目, 上班时段, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, Null, Null, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), a.限制项目, a.上班时段,
                       c_详情.分诊方式, n_诊室id
                From (Select '周日' As 限制项目, c_详情.周日 As 上班时段
                       From Dual
                       Where c_详情.周日 Is Not Null
                       Union All
                       Select '周一', c_详情.周一
                       From Dual
                       Where c_详情.周一 Is Not Null
                       Union All
                       Select '周二', c_详情.周二
                       From Dual
                       Where c_详情.周二 Is Not Null
                       Union All
                       Select '周三', c_详情.周三
                       From Dual
                       Where c_详情.周三 Is Not Null
                       Union All
                       Select '周四', c_详情.周四
                       From Dual
                       Where c_详情.周四 Is Not Null
                       Union All
                       Select '周五', c_详情.周五
                       From Dual
                       Where c_详情.周五 Is Not Null
                       Union All
                       Select '周六', c_详情.周六 From Dual Where c_详情.周六 Is Not Null) A,
                     (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+);
            Else
              Insert Into 临床出诊限制
                (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 分诊方式, 诊室id)
                Select 临床出诊限制_Id.Nextval, n_安排id, 限制项目,
                       Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                               c_详情.周五, '周六', c_详情.周六, Null), 限号数, 限约数, c_详情.序号控制, Decode(b.星期, Null, 0, 1) As 是否分时段,
                       Nvl((Select 1
                            From 挂号安排限制
                            Where 安排id = c_详情.安排id And 限制项目 = a.限制项目 And 限约数 = 0 And Rownum < 2), 0), c_详情.分诊方式, n_诊室id
                From 挂号安排限制 A, (Select Distinct 星期 From 挂号安排时段 Where 安排id = c_详情.安排id) B
                Where a.限制项目 = b.星期(+) And 安排id = c_详情.安排id;
            End If;
          End If;
        
          --c.临床出诊诊室
          If Nvl(c_详情.分诊方式, 0) > 0 Then
            If Nvl(c_详情.计划id, 0) <> 0 Then
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号计划诊室 B
                       Where a.名称 = b.门诊诊室 And b.计划id = c_详情.计划id) B
                Where a.安排id = n_安排id;
            Else
              Insert Into 临床出诊诊室
                (限制id, 诊室id)
                Select a.Id, b.诊室id
                From 临床出诊限制 A,
                     (Select Distinct a.Id As 诊室id
                       From 门诊诊室 A, 挂号安排诊室 B
                       Where a.名称 = b.门诊诊室 And b.号表id = c_详情.安排id) B
                Where a.安排id = n_安排id;
            End If;
          End If;
        
          --D.临床出诊时段
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约

                     
                     From 挂号计划时段
                     Where 计划id = c_详情.计划id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          
          Else
            Insert Into 临床出诊时段
              (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
              Select a.Id, b.序号, b.开始时间, b.结束时间, b.限制数量, b.是否预约
              From 临床出诊限制 A,
                   (Select n_安排id As 安排id, 星期,
                            Decode(星期, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号, 开始时间, 结束时间, 限制数量, 是否预约

                     
                     From 挂号安排时段
                     Where 安排id = c_详情.安排id) B
              Where a.安排id = b.安排id And a.限制项目 = b.星期 And a.上班时段 = b.上班时段;
          End If;
        
          --不分时段的序号控制号先生成序号
          --开始时间、终止时间填写时间段的开始时间和结束时间
          For c_限制项目 In (Select ID, 限号数, 上班时段
                         From 临床出诊限制
                         Where 安排id = n_安排id And Nvl(限号数, 0) <> 0 And Nvl(是否序号控制, 0) = 1 And Nvl(是否分时段, 0) = 0) Loop
            For I In 1 .. c_限制项目.限号数 Loop
              Insert Into 临床出诊时段
                (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
                Select c_限制项目.Id, I, 开始时间, 终止时间, 1, 1
                From 时间段
                Where 站点 Is Null And 号类 Is Null And 时间段 = c_限制项目.上班时段;
            End Loop;
          End Loop;
        
          --任何一个都不允许预约时表示全部允许预约
          Update 临床出诊时段 A
          Set a.是否预约 = 1
          Where 限制id In (Select ID From 临床出诊限制 Where 安排id = n_安排id) And Not Exists
           (Select 1 From 临床出诊时段 B Where a.限制id = b.限制id And Nvl(b.是否预约, 0) = 1);
        
          --E.合作单位挂号控制
          If Nvl(c_详情.计划id, 0) <> 0 Then
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                               When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                                0
                               When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                                2
                               When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                                3
                               Else
                                4
                             End As 控制方式, 数量
                     From 合作单位计划控制
                     Where 计划id = c_详情.计划id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          Else
            Insert Into 临床出诊挂号控制
              (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
              Select a.Id, b.类型, b.性质, b.合作单位, b.序号, b.控制方式, b.数量
              From 临床出诊限制 A,
                   (Select 1 As 类型, 1 As 性质, 合作单位, n_安排id As 安排id, 限制项目,
                            Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                    c_详情.周五, '周六', c_详情.周六, Null) As 上班时段, 序号,
                            Case
                              When Nvl(序号, 0) = 0 And Nvl(数量, 0) = 0 Then
                               0
                              When 序号 = 0 And Nvl(数量, 0) <> 0 Then
                               2
                              When Nvl(序号, 0) <> 0 And Nvl(数量, 0) <> 0 Then
                               3
                              Else
                               4
                            End As 控制方式, 数量
                     From 合作单位安排控制
                     Where 安排id = c_详情.安排id And
                           Decode(限制项目, '周日', c_详情.周日, '周一', c_详情.周一, '周二', c_详情.周二, '周三', c_详情.周三, '周四', c_详情.周四, '周五',
                                  c_详情.周五, '周六', c_详情.周六, Null) Is Not Null) B
              Where a.安排id = b.安排id And a.限制项目 = b.限制项目 And a.上班时段 = b.上班时段;
          End If;
        End Loop;
      
        --4.停用没有有效安排的号源，并删除无效的安排
        --主要是处理所有计划已失效或者有效计划只有一个且这个计划周一到周日都没有上班时段的
        Select Count(1)
        Into n_Count
        From 临床出诊限制 A, 临床出诊安排 B, 临床出诊号源 C
        Where a.安排id = b.Id And b.号源id = c.Id And c.Id = n_号源id And a.上班时段 Is Not Null And Nvl(c.是否删除, 0) = 0 And
              Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And Rownum < 2;
        If n_Count = 0 Then
          --没有有效的安排，停用号源，删除安排
          Select a.Id Bulk Collect
          Into l_限制id
          From 临床出诊限制 A, 临床出诊安排 B
          Where a.安排id = b.Id And b.号源id = n_号源id;
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊时段 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
        
          Forall I In 1 .. l_限制id.Count
            Delete From 临床出诊限制 Where ID = l_限制id(I);
        
          Delete From 临床出诊安排 Where 号源id = n_号源id;
        
          Update 临床出诊号源 Set 撤档时间 = Sysdate Where ID = n_号源id;
        End If;
      
        --5.拷贝一份出诊信息作为号源控制信息
        --说明：上班时段按安排的登记时间倒序取第一个
        For c_限制 In (Select ID, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id
                     From (Select a.Id, a.上班时段, a.限号数, a.限约数, a.是否序号控制, a.是否分时段, a.预约控制, a.是否独占, a.分诊方式, a.诊室id,
                                   Row_Number() Over(Partition By a.上班时段 Order By b.登记时间 Desc) As 组号
                            From 临床出诊限制 A, 临床出诊安排 B
                            Where a.安排id = b.Id And b.号源id = n_号源id)
                     Where 组号 = 1) Loop
          --a.临床出诊号源限制
          Select 临床出诊号源限制_Id.Nextval Into n_限制id From Dual;
          Insert Into 临床出诊号源限制
            (ID, 号源id, 上班时段, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 是否独占, 分诊方式, 诊室id)
          Values
            (n_限制id, n_号源id, c_限制.上班时段, c_限制.限号数, c_限制.限约数, c_限制.是否序号控制, c_限制.是否分时段, c_限制.预约控制, c_限制.是否独占, c_限制.分诊方式,
             c_限制.诊室id);
          --b.临床出诊号源诊室
          Insert Into 临床出诊号源诊室
            (限制id, 诊室id)
            Select n_限制id, 诊室id From 临床出诊诊室 Where 限制id = c_限制.Id;
          --c.临床出诊号源时段
          Insert Into 临床出诊号源时段
            (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
            Select n_限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约 From 临床出诊时段 Where 限制id = c_限制.Id;
          --d.临床出诊号源控制
          Insert Into 临床出诊号源控制
            (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
            Select n_限制id, 类型, 性质, 名称, 序号, 控制方式, 数量 From 临床出诊挂号控制 Where 限制id = c_限制.Id;
        End Loop;
      End If;
    End Loop;
  End;
Begin
  If Nvl(开始_In, 0) = 1 Then
    Select Count(1) Into n_Count From 临床出诊表 A, 临床出诊安排 B Where a.Id = b.出诊id And Rownum < 2;
    If n_Count <> 0 Then
      v_Err_Msg := '当前已经存在临床出诊安排了，请先删除，否则不允许导入！';
      Raise Err_Item;
    End If;
  
    Begin
      Select f_List2str(Cast(Collect(s.时间段) As t_Strlist))
      Into v_时间段
      From (Select 时间段, Row_Number() Over(Partition By 时间段 Order By 时间段) As 组号
             From (Select Decode(b.行号, 1, a.周一, 2, a.周二, 3, a.周三, 4, a.周四, 5, a.周五, 6, a.周六, a.周日) As 时间段
                    From (Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排
                           Union All
                           Select 周一, 周二, 周三, 周四, 周五, 周六, 周日
                           From 挂号安排计划
                           Where 审核时间 Is Not Null And Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) > Sysdate) A,
                         (Select Level As 行号 From Dual Connect By Level <= 7) B)
             Where 时间段 Is Not Null) S, 时间段 T
      Where s.时间段 = t.时间段(+) And t.时间段 Is Null And s.组号 = 1;
    Exception
      When Others Then
        v_时间段 := Null;
    End;
  
    If v_时间段 Is Not Null Then
      v_Err_Msg := '原挂号安排中的上班时间段【' || v_时间段 || '】不存在，请先在“基础设置>上班时间管理”中添加！';
      Raise Err_Item;
    End If;
  
    --删除现有所有号源，在调用之前已进行了提示
    Select a.Id Bulk Collect Into l_限制id From 临床出诊号源限制 A, 临床出诊号源 B Where a.号源id = b.Id;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊号源限制 Where ID = l_限制id(I);
  
    Delete From 临床出诊号源;
  
    --删除所有停诊记录
    Delete From 临床出诊停诊记录;
  End If;

  --不分站点号源如果没有指定站点，则放入第一个出诊表中
  v_全院号源归属站点 := zl_GetSysParameter('未区分站点的号源的维护站点', 1114);
  Begin
    Select Min(ID) Into n_出诊id From 临床出诊表 Where 排班方式 = 0;
  Exception
    When Others Then
      n_出诊id := 0;
  End;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 站点)
    Values
      (n_出诊id, 0, '固定出诊表', To_Number(To_Char(Sysdate, 'yyyy')), Null);
  End If;

  If Not 号码_In Is Null Then
    Zl_Register_Import(号码_In, n_出诊id, v_全院号源归属站点);
    Return;
  End If;

  For c_号源 In (Select 号码 From 挂号安排 Order By ID Desc) Loop
    --删除以及停用的号源也全部导入
    Zl_Register_Import(c_号源.号码, n_出诊id, v_全院号源归属站点);
  End Loop;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_导入;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Totemplet
(
  出诊id_In   临床出诊表.Id%Type,
  模板id_In   临床出诊表.Id%Type,
  出诊表名_In 临床出诊表.出诊表名%Type,
  应用范围_In 临床出诊表.应用范围%Type,
  科室id_In   临床出诊表.科室id%Type,
  备注_In     临床出诊表.备注%Type,
  操作员_In   临床出诊安排.操作员姓名%Type,
  操作时间_In 临床出诊安排.登记时间%Type,
  站点_In     部门表.站点%Type,
  人员id_In   人员表.Id%Type := Null
) As
  --功能：由月/周出诊表生成模板 
  --参数： 
  --        出诊id_In 月/周出诊表的出诊ID 
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --说明： 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_模板id   临床出诊表.Id%Type;
  n_模板类型 临床出诊表.模板类型%Type;

  n_安排id 临床出诊安排.Id%Type;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 临床出诊安排 B, 临床出诊记录 C, 部门表 D, 人员表 E, 收费项目目录 F
  Where a.Id = b.号源id And b.Id = c.安排id And a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id And a.排班方式 In (1, 2) And
        Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In And Rownum < 2;
  If Nvl(n_Count, 0) = 0 Then
    v_Err_Msg := '当前出诊表中无有效的安排，不能另存为模板！';
    Raise Err_Item;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板 
  Select Count(1)
  Into n_Count
  From 临床出诊表
  Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
  If Nvl(n_Count, 0) > 0 Then
    v_Err_Msg := '当前院区已存在名为“' || 出诊表名_In || '”的模板！';
    Raise Err_Item;
  End If;

  Begin
    Select Decode(排班方式, 1, 2, 0)
    Into n_模板类型
    From 临床出诊表
    Where ID = 出诊id_In And 排班方式 In (1, 2) And Rownum < 2;
  Exception
    When Others Then
      v_Err_Msg := '未发现当前出诊表！';
      Raise Err_Item;
  End;

  n_模板id := 模板id_In;
  If Nvl(n_模板id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_模板id From Dual;
  End If;

  --模板，肯定是新出诊表 
  Insert Into 临床出诊表
    (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
  Values
    (n_模板id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, n_模板类型, 站点_In);

  --月/周出诊表保存为模板 
  For c_安排 In (Select b.Id As 安排id, b.号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 临床出诊安排 B, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.Id = b.号源id And a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id And a.排班方式 In (1, 2) And
                     Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And (d.站点 Is Null Or d.站点 = 站点_In) And b.出诊id = 出诊id_In) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = n_模板id And 号源id = c_安排.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      --1.临床出诊安排 
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期 
      If Nvl(n_模板类型, 0) = 2 Then
        --按天安排出诊的月出诊表保存为特定日期的规则 
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 6, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      Else
        Zl_临床出诊安排_Insert(n_安排id, n_模板id, c_安排.号源id, c_安排.项目id, c_安排.医生id, c_安排.医生姓名, 1, Null, Null, Null, Null, 操作员_In,
                         操作时间_In);
      End If;
    End If;
  
    For c_记录 In (Select 临床出诊限制_Id.Nextval As 限制id, Decode(b.Id, Null, a.Id, b.Id) As 记录id,
                        Decode(To_Char(a.出诊日期, 'D'), '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                                '1', '周日') As 限制项目, To_Number(To_Char(a.出诊日期, 'dd')) || '日' As 出诊日期, a.上班时段,
                        Decode(b.Id, Null, a.限号数, b.限号数) As 限号数, Decode(b.Id, Null, a.限约数, b.限约数) As 限约数,
                        Decode(b.Id, Null, a.是否分时段, b.是否分时段) As 是否分时段, Decode(b.Id, Null, a.是否序号控制, b.是否序号控制) As 是否序号控制,
                        Decode(b.Id, Null, a.预约控制, b.预约控制) As 预约控制, Decode(b.Id, Null, a.是否独占, b.是否独占) As 是否独占,
                        Decode(b.Id, Null, a.分诊方式, b.分诊方式) As 分诊方式
                 From 临床出诊记录 A, 临床出诊记录 B
                 Where a.Id = b.相关id(+) And a.安排id = c_安排.安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0) Loop
    
      --2.临床出诊限制 
      If Nvl(n_模板类型, 0) = 2 Then
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.出诊日期, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      Else
        Insert Into 临床出诊限制
          (ID, 安排id, 限制项目, 上班时段, 限号数, 限约数, 是否分时段, 是否序号控制, 预约控制, 是否独占, 分诊方式)
        Values
          (c_记录.限制id, n_安排id, c_记录.限制项目, c_记录.上班时段, c_记录.限号数, c_记录.限约数, c_记录.是否分时段, c_记录.是否序号控制, c_记录.预约控制, c_记录.是否独占,
           c_记录.分诊方式);
      End If;
    
      --3.临床出诊诊室 
      Insert Into 临床出诊诊室
        (限制id, 诊室id)
        Select c_记录.限制id, 诊室id From 临床出诊诊室记录 Where 记录id = c_记录.记录id;
    
      --4.临床出诊时段 
      --分时段不分序号的，在预约挂号时会新增记录，填写预约顺序号 
      If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id;
      Else
        Insert Into 临床出诊时段
          (限制id, 序号, 开始时间, 终止时间, 限制数量, 是否预约)
          Select c_记录.限制id, 序号, 开始时间, 终止时间, 数量, 是否预约
          From 临床出诊序号控制
          Where 记录id = c_记录.记录id And 预约顺序号 Is Null;
      End If;
    
      --5.临床出诊挂号控制 
      Insert Into 临床出诊挂号控制
        (限制id, 类型, 性质, 名称, 序号, 控制方式, 数量)
        Select c_记录.限制id, 类型, 性质, 名称, 序号, 控制方式, 数量
        From 临床出诊挂号控制记录
        Where 记录id = c_记录.记录id;
    End Loop;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Totemplet;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Delete
(
  Id_In     临床出诊表.Id%Type,
  人员id_In 人员表.Id%Type := Null,
  站点_In   部门表.站点%Type
) As
  --功能：删除临床出诊表
  --参数：
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在删除
  n_Count    Number;
  n_出诊id   临床出诊表.Id%Type;
  n_排班方式 临床出诊表.排班方式%Type;
  v_站点     临床出诊表.站点%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  l_记录id t_Numlist := t_Numlist();
  l_限制id t_Numlist := t_Numlist();
Begin
  Select Count(1) Into n_Count From 临床出诊表 Where 排班方式 <> 3 And 发布人 Is Not Null And ID = Id_In;
  If n_Count <> 0 Then
    v_Err_Msg := '当前出诊表已发布，不能删除！';
    Raise Err_Item;
  End If;

  Begin
    Select 排班方式, Nvl(站点, '-') Into n_排班方式, v_站点 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(n_排班方式, 0) In (0, 3) Then
    --固定安排/模板
    --删除临床出诊限制
    Select b.Id Bulk Collect
    Into l_限制id
    From 临床出诊安排 A, 临床出诊限制 B
    Where a.Id = b.安排id And a.出诊id = Id_In;
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊时段 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊诊室 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊挂号控制 Where 限制id = l_限制id(I);
  
    Forall I In 1 .. l_限制id.Count
      Delete From 临床出诊限制 Where ID = l_限制id(I);
  
    --删除临床出诊安排
    Delete From 临床出诊安排 Where 出诊id = Id_In;
  
    --删除临床出诊表
    Delete 临床出诊表 Where ID = Id_In;
  
    Return;
  End If;

  --========================================================================================================
  --月出诊表/周出诊表
  --月出诊表/周出诊表只能从最后一个开始删除
  Begin
    Select ID
    Into n_出诊id
    From (Select a.Id
           From 临床出诊表 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
           Where a.排班方式 = n_排班方式 And a.Id = b.出诊id(+) And b.号源id = c.Id(+) And c.科室id = d.Id(+)
                --当前人员可操作的号源
                 And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                  (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                --站点
                 And Nvl(a.站点, '-') = v_站点 And a.关联id Is Null
           Order By a.年份 Desc, a.月份 Desc, a.周数 Desc)
    Where Rownum < 2;
  Exception
    When Others Then
      n_出诊id := 0;
  End;
  If Nvl(n_出诊id, 0) <> 0 And Nvl(n_出诊id, 0) <> Id_In Then
    v_Err_Msg := '必须从最后一个出诊表开始删除！';
    Raise Err_Item;
  End If;

  If Nvl(人员id_In, 0) <> 0 Then
    --没有"所有科室"权限
    Select Count(1)
    Into n_Count
    From 临床出诊安排 A, 临床出诊号源 B
    Where a.号源id = b.Id And a.出诊id = Id_In And
          Not (Nvl(b.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)) And
          Rownum < 2;
    If n_Count <> 0 Then
      v_Err_Msg := '当前出诊表中含有其它人员已经制定的安排，不能删除！';
      Raise Err_Item;
    End If;
  End If;

  --删除临床出诊记录
  Select a.Id Bulk Collect
  Into l_记录id
  From 临床出诊记录 A, 临床出诊安排 B, 临床出诊号源 C, 部门表 D
  Where a.安排id = b.Id And a.号源id = c.Id And c.科室id = d.Id And b.出诊id = Id_In
       --当前人员可操作的号源
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(c.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where c.科室id = 部门id And 人员id = 人员id_In)))
       --站点
        And (d.站点 Is Null Or d.站点 = 站点_In);

  Zl_临床出诊记录_Batchdelete(l_记录id);

  --删除临床出诊安排
  Delete From 临床出诊安排 A
  Where a.出诊id = Id_In And Exists
   (Select 1
         From 临床出诊号源 B, 部门表 D
         Where a.号源id = b.Id And b.科室id = d.Id
              --当前人员可操作的号源
               And (Nvl(人员id_In, 0) = 0 Or (Nvl(b.是否临床排班, 0) = 1 And Exists
                (Select 1 From 部门人员 Where b.科室id = 部门id And 人员id = 人员id_In)))
              --站点
               And (d.站点 Is Null Or d.站点 = 站点_In));

  --删除临床出诊表
  Delete 临床出诊表 A
  Where (a.Id = Id_In Or a.关联id = Id_In) And Not Exists
   (Select 1 From 临床出诊安排 Where 出诊id = a.Id And 号源id Is Not Null);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Delete;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊安排_Publish
(
  Id_In       临床出诊表.Id%Type,
  发布人_In   临床出诊表.发布人%Type := Null,
  发布时间_In 临床出诊表.发布时间%Type := Null,
  取消发布_In Number := 0
) As
  --发布和取消发布安排 
  --参数： 
  --        取消发布_In 是否取消发布 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  n_Count    Number(2);
  n_排班方式 临床出诊表.排班方式%Type;
  v_站点     临床出诊表.站点%Type;
  l_记录id   t_Numlist := t_Numlist();

  d_开始时间 临床出诊安排.开始时间%Type;
  d_终止时间 临床出诊安排.终止时间%Type;
Begin
  Begin
    Select Nvl(排班方式, 0), Nvl(站点, '-') Into n_排班方式, v_站点 From 临床出诊表 Where ID = Id_In;
  Exception
    When Others Then
      v_Err_Msg := '出诊表信息未找到！';
      Raise Err_Item;
  End;

  If Nvl(取消发布_In, 0) = 0 Then
    --发布安排 
    If Nvl(n_排班方式, 0) = 0 Then
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊限制 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 = 0 And c.Id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    Else
      Select Max(1)
      Into n_Count
      From 临床出诊安排 A, 临床出诊记录 B, 临床出诊表 C
      Where a.Id = b.安排id And a.出诊id = c.Id And c.排班方式 In (1, 2) And c.Id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) = 0 Then
        v_Err_Msg := '当前出诊表无有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    
      Select Max(1)
      Into n_Count
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.号源id = b.号源id And a.出诊日期 Between b.开始时间 And b.终止时间 And a.安排id <> b.Id And b.出诊id = Id_In And Rownum < 2;
      If Nvl(n_Count, 0) <> 0 Then
        v_Err_Msg := '当前出诊表中的部分号源在当前出诊表的生效时间范围内已经存在有效的安排，不能发布！';
        Raise Err_Item;
      End If;
    End If;
  
    --如果存在多个未发布的安排表，则不允许发布后面日期的安排，必须按最小有效时间进行发布 
    Select Max(1)
    Into n_Count
    From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
           From 临床出诊表
           Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And Nvl(站点, '-') = v_站点 And 发布人 Is Null And 关联id Is Null) A,
         (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
    Where a.日期 < b.日期 And Rownum < 2;
    If Nvl(n_Count, 0) <> 0 Then
      If Nvl(n_排班方式, 0) = 0 Then
        v_Err_Msg := '当前出诊表前面还有未发布的固定出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 1 Then
        v_Err_Msg := '当前出诊表前面还有未发布的月出诊表，必须先将其发布或删除后才能发布该出诊表！';
      Elsif Nvl(n_排班方式, 0) = 2 Then
        v_Err_Msg := '当前出诊表前面还有未发布的周出诊表，必须先将其发布或删除后才能发布该出诊表！';
      End If;
      Raise Err_Item;
    End If;
  
    Update 临床出诊表 Set 发布人 = 发布人_In, 发布时间 = 发布时间_In Where (ID = Id_In Or 关联id = Id_In);
    Update 临床出诊安排 Set 审核人 = 发布人_In, 审核时间 = 发布时间_In Where 出诊id = Id_In;
  
    --删除发布时有安排，但是号源已被停用的记录 
    For c_安排 In (Select a.Id
                 From 临床出诊安排 A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
                 Where a.号源id = b.Id And b.科室id = c.Id And a.医生id = d.Id(+) And b.项目id = e.Id And a.出诊id = Id_In And
                       Not (Nvl(b.是否删除, 0) = 0 And (b.撤档时间 Is Null Or b.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                        Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      Zl_临床出诊安排_Delete(c_安排.Id, Nvl(n_排班方式, 0));
    End Loop;
  
    If Nvl(n_排班方式, 0) <> 0 Then
      --月安排/周安排根据停诊安排和法定节假日调整出诊记录的出诊/预约情况 
      Select 开始时间, 终止时间 Into d_开始时间, d_终止时间 From 临床出诊安排 Where 出诊id = Id_In And Rownum < 2;
      For c_安排 In (Select a.Id, a.号源id, b.日期
                   From 临床出诊安排 A,
                        (Select Trunc(d_开始时间) + Level - 1 As 日期
                          From Dual
                          Connect By Level <= Trunc(d_终止时间) - Trunc(d_开始时间) + 1) B
                   Where a.出诊id = Id_In
                   Order By 号源id, 日期) Loop
      
        Zl_Clinicvisitmodify(c_安排.号源id, c_安排.Id, c_安排.日期, 发布人_In, 发布时间_In);
      End Loop;
    
      --修改临床出诊记录中的"是否发布" 
      Select a.Id Bulk Collect
      Into l_记录id
      From 临床出诊记录 A, 临床出诊安排 B
      Where a.安排id = b.Id And b.出诊id = Id_In;
    
      Forall I In 1 .. l_记录id.Count
        Update 临床出诊记录 Set 是否发布 = 1 Where ID = l_记录id(I);
    End If;
    Return;
  End If;

  --================================================================================================================== 
  --取消发布 
  Select Max(1)
  Into n_Count
  From (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期
         From 临床出诊表
         Where Nvl(排班方式, 0) = Nvl(n_排班方式, 0) And Nvl(站点, '-') = v_站点 And 发布人 Is Not Null And 关联id Is Null) A,
       (Select ID, 年份 || LPad(月份, 2, '0') || 周数 As 日期 From 临床出诊表 Where ID = Id_In) B
  Where a.日期 > b.日期 And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    If Nvl(n_排班方式, 0) = 0 Then
      v_Err_Msg := '当前出诊后面还有已发布的固定出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 1 Then
      v_Err_Msg := '当前出诊后面还有已发布的月出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    Elsif Nvl(n_排班方式, 0) = 2 Then
      v_Err_Msg := '当前出诊后面还有已发布的周出诊表，必须先将其取消发布后才能取消发布该出诊表！';
    End If;
    Raise Err_Item;
  End If;

  Select Max(1)
  Into n_Count
  From 病人挂号记录 C, 临床出诊记录 A, 临床出诊安排 B
  Where c.出诊记录id = a.Id And a.安排id = b.Id And b.出诊id = Id_In And Rownum < 2;
  If Nvl(n_Count, 0) <> 0 Then
    v_Err_Msg := '当前出诊表的安排已被使用，不允许取消发布！';
    Raise Err_Item;
  End If;

  Update 临床出诊表 Set 发布人 = Null, 发布时间 = Null Where (ID = Id_In Or 关联id = Id_In);
  If Sql%NotFound Then
    v_Err_Msg := '出诊表信息未找到！';
    Raise Err_Item;
  End If;
  Update 临床出诊安排 Set 审核人 = Null, 审核时间 = Null Where 出诊id = Id_In;

  --固定安排取消发布时删除出诊记录 
  If Nvl(n_排班方式, 0) = 0 Then
    --删除出诊记录 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  Else
    --删除备份的出诊记录 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In And a.相关id Is Not Null;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
    --月安排/周安排清除停诊信息，并修改是否发布 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Delete From 临床出诊停诊记录 Where 记录id = l_记录id(I);
  
    --修改临床出诊记录中的"是否发布" 
    Select a.Id Bulk Collect
    Into l_记录id
    From 临床出诊记录 A, 临床出诊安排 B
    Where a.安排id = b.Id And b.出诊id = Id_In;
  
    Forall I In 1 .. l_记录id.Count
      Update 临床出诊记录
      Set 停诊开始时间 = Null, 停诊终止时间 = Null, 停诊原因 = Null, 是否发布 = 0
      Where ID = l_记录id(I);
  
    --恢复临床出诊序号控制的"是否预约"及"是否停诊" 
    For c_记录 In (Select a.Id, a.是否分时段, a.是否序号控制
                 From 临床出诊记录 A, 临床出诊安排 B
                 Where a.安排id = b.Id And b.出诊id = Id_In) Loop
      If Nvl(c_记录.是否分时段, 0) = 1 Then
        If Nvl(c_记录.是否序号控制, 0) = 0 Then
          Update 临床出诊序号控制 Set 是否预约 = 1 Where 记录id = c_记录.Id;
        Else
          Update 临床出诊序号控制 Set 是否预约 = Nvl(预约顺序号, 0), 是否停诊 = 0 Where 记录id = c_记录.Id;
        End If;
      End If;
    End Loop;
  
    --换休的不再恢复 
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊安排_Publish;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-08,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Add
(
  操作类型_In         Number,
  出诊id_In           临床出诊表.Id%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  操作员_In           临床出诊安排.操作员姓名%Type := Null,
  操作时间_In         临床出诊安排.登记时间%Type := Null,
  开始时间_In         临床出诊安排.开始时间%Type := Null,
  终止时间_In         临床出诊安排.终止时间%Type := Null,
  年份_In             临床出诊表.年份%Type := Null,
  月份_In             临床出诊表.月份%Type := Null,
  周数_In             临床出诊表.周数%Type := Null,
  应用范围_In         临床出诊表.应用范围%Type := Null,
  科室id_In           临床出诊表.科室id%Type := Null,
  备注_In             临床出诊表.备注%Type := Null,
  人员id_In           人员表.Id%Type := Null,
  删除安排_In         Number := 0,
  模板类型_In         临床出诊表.模板类型%Type := Null
) As
  --功能：增加出诊表或模板 
  --参数： 
  --        操作类型_In 1-模板，2-固定安排, 3-月安排，4-周安排 
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录 
  --说明： 
  v_Err_Msg Varchar2(255);
  Err_Item Exception;
  n_Count Number(8);

  n_出诊id 临床出诊表.Id%Type;

  l_记录id t_Numlist := t_Numlist();
Begin
  n_出诊id := 出诊id_In;
  If Nvl(n_出诊id, 0) = 0 Then
    Select 临床出诊表_Id.Nextval Into n_出诊id From Dual;
  End If;

  --排班方式：0-固定排班;1-按月排班;2-按周排班;3-模板 
  --============================================================================================================================================ 
  --1.模板 
  If Nvl(操作类型_In, 0) = 1 Then
    Select Count(1)
    Into n_Count
    From 临床出诊表
    Where 出诊表名 = 出诊表名_In And 排班方式 = 3 And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
    If n_Count > 0 Then
      v_Err_Msg := '当前院区已存在名为“' || 出诊表名_In || '”的模板！';
      Raise Err_Item;
    End If;
  
    --检查是否有可操作的有效号源 
    Select Count(1)
    Into n_Count
    From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
    Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id And a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And
          Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
          Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
          Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
          Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
         --当前人员可操作的号源 
          And (Nvl(人员id_In, 0) = 0 Or
          (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
         --站点 
          And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  
    If n_Count = 0 Then
      If Nvl(模板类型_In, 0) = 0 Then
        v_Err_Msg := '当前无可按周排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      Else
        v_Err_Msg := '当前无可按月排班的号源，不能新增模板，请先到“基础设置>临床号源管理”中添加出诊号源！';
      End If;
      Raise Err_Item;
    End If;
  
    --模板，肯定是新出诊表 
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 应用范围, 科室id, 备注, 发布人, 发布时间, 模板类型, 站点)
    Values
      (n_出诊id, 3, 出诊表名_In, 应用范围_In, 科室id_In, 备注_In, 操作员_In, 操作时间_In, 模板类型_In, 站点_In);
  
    --临床出诊安排 
    For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
                 From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
                 Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id And
                       a.排班方式 = Decode(Nvl(模板类型_In, 0), 0, 2, 1) And Nvl(a.是否删除, 0) = 0 And
                       (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                       Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                       Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd')
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                      --站点 
                       And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      If Nvl(模板类型_In, 0) = 2 Then
        --2-按天排班的月排班模板，排班规则缺省为6-特定日期 
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 6, 操作员_In, 操作时间_In);
      Else
        Insert Into 临床出诊安排
          (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 排班规则, 操作员姓名, 登记时间)
        Values
          (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 1, 操作员_In, 操作时间_In);
      End If;
    End Loop;
    Return;
  End If;

  --============================================================================================================================================ 
  --2.固定排班 
  If Nvl(操作类型_In, 0) = 2 Then
    --进入临床出诊安排模块前检查，如果登录站点无固定出诊表记录，则自动生成临床出诊表记录
    Select Count(1)
    Into n_Count
    From 临床出诊表
    Where 排班方式 = 0 And 出诊表名 = 出诊表名_In And Nvl(站点, '-') = Nvl(站点_In, '-') And Rownum < 2;
    If n_Count = 0 Then
      Update 临床出诊表 Set 站点 = 站点_In Where 排班方式 = 0 And 出诊表名 = 出诊表名_In And Nvl(站点, '-') = '-';
      If Sql%NotFound Then
        Insert Into 临床出诊表
          (ID, 排班方式, 出诊表名, 年份, 站点)
        Values
          (n_出诊id, 0, 出诊表名_In, To_Number(To_Char(Sysdate, 'yyyy')), 站点_In);
      End If;
    End If;
    Return;
  End If;

  --============================================================================================================================================ 
  --月排班、周排班 
  --检查是否有有效号源 
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源 
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班 
         Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
        --周排班 
         Or Nvl(操作类型_In, 0) = 4 And
         (
         --当前出诊表所在时间范围内不能有月排班 
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录 
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排 
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(操作类型_In, 0) = 3 Then
      v_Err_Msg := '当前无可按月排班的号源，不能新增月出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    Else
      v_Err_Msg := '当前无可按周排班的号源，不能新增周出诊表，请先到“基础设置>临床号源管理”中添加出诊号源！';
    End If;
    Raise Err_Item;
  End If;

  --出诊表存在，则不再新增出诊表，直接向该出诊表添加上次有效号源安排即可 
  --涉及到临床排班，当前操作员可能只能操作某一部分号源 
  Select Count(1) Into n_Count From 临床出诊表 Where ID = n_出诊id;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (n_出诊id,
       Case
          When Nvl(操作类型_In, 0) = 3 Then
           1
          Else
           2
        End, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  
    --检查是否跨月周出诊表， 如果是需要再新增一张周出诊表，并与原出诊表进行关联
    If Nvl(操作类型_In, 0) = 4 Then
      Zl_临床出诊表_新增跨月周出诊表(年份_In, 月份_In, 周数_In, 开始时间_In, 终止时间_In, 站点_In, n_出诊id);
    End If;
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)，程序中已询问 
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源 
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                      --安排有被使用了的出诊记录 
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  --缺省加入上一次有效的出诊安排 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, 原安排id, 号源id, 项目id, 医生id, 医生姓名, 原出诊id
               From (Select a.Id As 原安排id, b.Id As 号源id, b.项目id, b.医生id, b.医生姓名, c.Id As 原出诊id,
                             Row_Number() Over(Partition By b.Id Order By a.开始时间 Desc) As 组号
                      From 临床出诊安排 A, 临床出诊号源 B, 临床出诊表 C, 部门表 D, 人员表 E, 收费项目目录 F
                      Where a.号源id = b.Id And a.出诊id = c.Id And b.科室id = d.Id And b.医生id = e.Id(+) And b.项目id = f.Id
                           --有效号源 
                            And Nvl(b.是否删除, 0) = 0 And
                            Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                            (
                            --月排班 
                             Nvl(操作类型_In, 0) = 3 And b.排班方式 = 1
                            --周排班 
                             Or
                             Nvl(操作类型_In, 0) = 4 And
                             (
                             --当前出诊表所在时间范围内不能有月排班 
                              b.排班方式 = 2 And Not Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                             --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                              Or b.排班方式 = 1 And Exists
                              (Select 1
                               From 临床出诊安排 P, 临床出诊表 Q
                               Where p.出诊id = q.Id And p.号源id = b.Id And
                                     Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                           --上一次有效出诊安排 
                            And c.发布人 Is Not Null And c.排班方式 = Decode(Nvl(操作类型_In, 0), 3, 1, 2)
                           --号源在该出诊表时间范围内无出诊记录 
                            And Not Exists (Select 1
                             From 临床出诊记录 P
                             Where p.号源id = b.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                           --当前人员可操作的号源 
                            And (Nvl(人员id_In, 0) = 0 Or
                            (Nvl(b.是否临床排班, 0) = 1 And Exists
                             (Select 1 From 部门人员 Where 部门id = b.科室id And 人员id = 人员id_In)))
                           --站点 
                            And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-'))
               Where 组号 = 1) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  
    --复制出诊安排 
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班 
                       And (Nvl(操作类型_In, 0) = 3 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班 
                       Or Nvl(操作类型_In, 0) = 4 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, c_号源.安排id, c_记录.日期, 操作员_In, 操作时间_In);
    End Loop;
  End Loop;

  --加入无上一次有效出诊安排的号源 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 B, 收费项目目录 C
               Where a.科室id = d.Id And a.医生id = b.Id(+) And a.项目id = c.Id
                    --有效号源 
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(操作类型_In, 0) = 3 And a.排班方式 = 1
                     --周排班 
                      Or Nvl(操作类型_In, 0) = 4 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 操作时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Add;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Addbyrecord
(
  原出诊id_In         临床出诊表.Id%Type,
  新出诊id_In         临床出诊表.Id%Type,
  排班方式_In         临床出诊表.排班方式%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  年份_In             临床出诊表.年份%Type,
  月份_In             临床出诊表.月份%Type,
  周数_In             临床出诊表.周数%Type,
  开始时间_In         临床出诊安排.开始时间%Type,
  终止时间_In         临床出诊安排.终止时间%Type,
  操作员姓名_In       临床出诊安排.操作员姓名%Type,
  登记时间_In         临床出诊安排.登记时间%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  人员id_In           人员表.Id%Type := Null,
  删除安排_In         Number := 0
) As
  ------------------------------------------------------------------------- 
  --功能：根据出诊记录生成新的出诊记录（月安排/周安排） 
  --参数： 
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录 
  --说明： 
  ------------------------------------------------------------------------- 
  n_Count Number;

  l_记录id   t_Numlist := t_Numlist();
  n_安排id   临床出诊安排.Id%Type;
  n_新出诊id 临床出诊表.Id%Type;

  v_Err_Msg Varchar2(255);
  Err_Item Exception;
Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源 
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班 
         Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
        --周排班 
         Or Nvl(排班方式_In, 0) = 2 And
         (
         --当前出诊表所在时间范围内不能有月排班 
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录 
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排 
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在 
  n_新出诊id := 新出诊id_In;
  Select Count(1) Into n_Count From 临床出诊表 Where ID = n_新出诊id;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (n_新出诊id, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  
    --检查是否跨月周出诊表， 如果是需要再新增一张周出诊表，并与原出诊表进行关联
    If Nvl(排班方式_In, 0) = 2 Then
      Zl_临床出诊表_新增跨月周出诊表(年份_In, 月份_In, 周数_In, 开始时间_In, 终止时间_In, 站点_In, n_新出诊id);
    End If;
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)， 
  --并修改固定安排的终止时间，程序中已询问 
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源 
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录 
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  
  End If;

  For c_号源 In (Select n_新出诊id As 出诊id, b.Id As 原安排id, b.号源id, c.项目id, c.医生id, c.医生姓名
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D, 人员表 E, 收费项目目录 F
               Where b.号源id = c.Id And c.科室id = d.Id And b.医生id = e.Id(+) And c.项目id = f.Id And b.出诊id = 原出诊id_In
                    --有效号源 
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
  
    Begin
      Select ID Into n_安排id From 临床出诊安排 Where 出诊id = c_号源.出诊id And 号源id = c_号源.号源id;
    Exception
      When Others Then
        n_安排id := Null;
    End;
  
    If Nvl(n_安排id, 0) = 0 Then
      Select 临床出诊安排_Id.Nextval Into n_安排id From Dual;
    
      Insert Into 临床出诊安排
        (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
      Values
        (n_安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
    End If;
  
    --出诊记录 
    For c_记录 In (Select Decode(b.Id, Null, a.Id, b.Id) As ID, c.日期
                 From 临床出诊记录 A, 临床出诊记录 B,
                      (Select Trunc(开始时间_In) + Level - 1 As 日期
                        From Dual
                        Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) C
                 Where a.Id = b.相关id(+) And a.安排id = c_号源.原安排id And a.相关id Is Null And Nvl(a.是否临时出诊, 0) = 0
                      --月排班 
                       And (Nvl(排班方式_In, 0) = 1 And To_Char(a.出诊日期, 'dd') = To_Char(c.日期, 'dd')
                       --周排班 
                       Or Nvl(排班方式_In, 0) = 2 And To_Char(a.出诊日期, 'D') = To_Char(c.日期, 'D'))) Loop
      Zl_临床出诊记录_Copy(c_记录.Id, n_安排id, c_记录.日期, 操作员姓名_In, 登记时间_In);
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_新出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id
                    --有效号源 
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_新出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员姓名_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Addbyrecord;
/

--121585:冉俊明,2018-03-05,跨月的周出诊表调整到一起维护，而不是分为两个出诊表进行维护
--121587:冉俊明,2018-02-06,临床出诊号源安排分站点进行维护
Create Or Replace Procedure Zl_临床出诊表_Addbytemplet
(
  模板id_In           临床出诊表.Id%Type,
  人员id_In           人员表.Id%Type,
  出诊id_In           临床出诊表.Id%Type,
  排班方式_In         临床出诊表.排班方式%Type,
  出诊表名_In         临床出诊表.出诊表名%Type,
  年份_In             临床出诊表.年份%Type,
  月份_In             临床出诊表.月份%Type,
  周数_In             临床出诊表.周数%Type,
  开始时间_In         临床出诊安排.开始时间%Type,
  终止时间_In         临床出诊安排.终止时间%Type,
  操作员_In           临床出诊安排.操作员姓名%Type,
  登记时间_In         临床出诊安排.登记时间%Type,
  站点_In             部门表.站点%Type,
  全院号源归属站点_In 部门表.站点%Type,
  删除安排_In         Number := 0
) As
  ------------------------------------------------------------------------- 
  --功能说明：根据模板自动生成临床出诊记录 
  --参数： 
  --        全院号源归属站点_In 不区分站点的号源的归属站点
  --        人员id_In 除固定安排外有效，不为0或null表示临床科室人员在添加 
  --        删除安排_In 固定排班转为月排班/周排班时，在制定月排班/周排班时是否删除新出诊表时间内未使用的出诊记录 
  --说明： 
  ------------------------------------------------------------------------- 
  Err_Item Exception;
  v_Err_Msg Varchar2(200);
  n_Count   Number(18);

  d_轮询日期 Date;
  n_轮询天数 Number;
  v_限制项目 临床出诊限制.限制项目%Type;

  n_是否出诊 Number(2);
  d_开始时间 临床出诊记录.开始时间%Type;
  n_出诊id   临床出诊表.Id%Type;

  l_记录id t_Numlist := t_Numlist();

  Procedure Isvisit
  (
    安排id_In       临床出诊安排.Id%Type,
    排班规则_In     临床出诊安排.排班规则%Type,
    出诊日期_In     临床出诊记录.出诊日期%Type,
    轮询开始时间_In 临床出诊安排.开始时间%Type,
    限制项目_In     Out 临床出诊限制.限制项目%Type,
    是否出诊_In     Out Number
  ) As
    --判断是否出诊，并获取出诊项目 
    d_轮询日期 Date;
    n_轮询天数 Number;
  Begin
    是否出诊_In := 1;
    --检查这天是否出诊 
    If 排班规则_In = 1 Then
      --星期排班 
      Select Decode(To_Char(出诊日期_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                     Null)
      Into 限制项目_In
      From Dual;
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 2 Then
      --单日排班 
      限制项目_In := '单日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 1 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 3 Then
      --双日排班 
      限制项目_In := '双日';
      If Mod(To_Number(To_Char(出诊日期_In, 'dd')), 2) <> 0 Then
        是否出诊_In := 0;
      End If;
    Elsif 排班规则_In = 4 Or 排班规则_In = 5 Then
      --4-月内轮循,5-轮循不限制 
      If 排班规则_In = 4 Then
        d_轮询日期 := To_Date(To_Char(出诊日期_In, 'yyyy-mm') || To_Char(轮询开始时间_In, '-dd'), 'yyyy-mm-dd');
      Else
        d_轮询日期 := 轮询开始时间_In;
      End If;
      Begin
        Select To_Number(Substr(限制项目, 1, Instr(限制项目, '天') - 1))
        Into n_轮询天数
        From 临床出诊限制
        Where 安排id = 安排id_In And Rownum < 2;
      Exception
        When Others Then
          n_轮询天数 := 0;
      End;
      If Nvl(n_轮询天数, 0) > 0 Then
        限制项目_In := n_轮询天数 || '天';
        If Mod(Trunc(出诊日期_In) - Trunc(d_轮询日期), n_轮询天数 + 1) <> 0 Then
          是否出诊_In := 0;
        End If;
      End If;
    Elsif 排班规则_In = 6 Then
      --特定日期 
      限制项目_In := To_Number(To_Char(出诊日期_In, 'dd')) || '日';
      Select Count(1) Into n_Count From 临床出诊限制 Where 安排id = 安排id_In And 限制项目 = 限制项目_In;
      If Nvl(n_Count, 0) = 0 Then
        是否出诊_In := 0;
      End If;
    End If;
  End;

Begin
  Select Count(1)
  Into n_Count
  From 临床出诊号源 A, 部门表 B, 人员表 C, 收费项目目录 D
  Where a.科室id = b.Id And a.医生id = c.Id(+) And a.项目id = d.Id
       --有效号源 
        And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 Is Null Or a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
        Nvl(b.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(c.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
        (
        --月排班 
         Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
        --周排班 
         Or Nvl(排班方式_In, 0) = 2 And
         (
         --当前出诊表所在时间范围内不能有月排班 
          a.排班方式 = 2 And Not Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
         --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
          Or a.排班方式 = 1 And Exists
          (Select 1
              From 临床出诊安排 P, 临床出诊表 Q
              Where p.出诊id = q.Id And p.号源id = a.Id And
                    Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
       --号源在该出诊表时间范围内无出诊记录 
        And Not Exists
   (Select 1
         From 临床出诊记录 O, 临床出诊安排 P, 临床出诊表 Q
         Where o.安排id = p.Id And p.出诊id = q.Id And p.号源id = a.Id And o.出诊日期 Between 开始时间_In And 终止时间_In And
               (q.排班方式 In (1, 2)
               --原来为固定出诊安排 
               Or q.排班方式 = 0 And (Nvl(删除安排_In, 0) = 0 Or Nvl(删除安排_In, 0) = 1 And Exists
                (Select 1 From 病人挂号记录 Where 出诊记录id = a.Id))))
       --当前人员可操作的号源 
        And (Nvl(人员id_In, 0) = 0 Or
        (Nvl(a.是否临床排班, 0) = 1 And Exists (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
       --站点 
        And Nvl(Nvl(b.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-') And Rownum < 2;
  If n_Count = 0 Then
    If Nvl(排班方式_In, 0) = 1 Then
      v_Err_Msg := '当前出诊表中已无可按月排班的号源，不能生成新的出诊表！';
    Else
      v_Err_Msg := '当前出诊表中已无可按周排班的号源，不能生成新的出诊表！';
    End If;
    Raise Err_Item;
  End If;

  --检查出诊表是否存在 
  n_出诊id := 出诊id_In;
  Select Count(1) Into n_Count From 临床出诊表 Where ID = n_出诊id;
  If n_Count = 0 Then
    Insert Into 临床出诊表
      (ID, 排班方式, 出诊表名, 年份, 月份, 周数, 站点)
    Values
      (n_出诊id, 排班方式_In, 出诊表名_In, 年份_In, 月份_In, 周数_In, 站点_In);
  
    --检查是否跨月周出诊表， 如果是需要再新增一张周出诊表，并与原出诊表进行关联
    If Nvl(排班方式_In, 0) = 2 Then
      Zl_临床出诊表_新增跨月周出诊表(年份_In, 月份_In, 周数_In, 开始时间_In, 终止时间_In, 站点_In, n_出诊id);
    End If;
  End If;

  --如果当前出诊表时间范围内无挂号且无预约的出诊记录(固定安排)，则删除这部分出诊记录(在删除出诊表时可恢复)， 
  --并修改固定安排的终止时间，程序中已询问 
  If Nvl(删除安排_In, 0) = 1 Then
    For c_安排 In (Select b.Id As 安排id
                 From 临床出诊安排 B, 临床出诊表 C, 临床出诊号源 D, 部门表 E
                 Where b.出诊id = c.Id And b.号源id = d.Id And d.科室id = e.Id
                      --号源 
                       And Nvl(d.是否删除, 0) = 0 And (d.撤档时间 Is Null Or d.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd')) And
                       Nvl(d.排班方式, 0) = 排班方式_In
                      --安排有被使用了的出诊记录 
                       And c.排班方式 = 0 And b.终止时间 >= 开始时间_In And Not Exists
                  (Select 1
                        From 临床出诊记录 M, 病人挂号记录 N
                        Where m.安排id = b.Id And m.Id = n.出诊记录id And m.出诊日期 >= 开始时间_In)
                      --当前人员可操作的号源 
                       And (Nvl(人员id_In, 0) = 0 Or (Nvl(d.是否临床排班, 0) = 1 And Exists
                        (Select 1 From 部门人员 Where 部门id = d.科室id And 人员id = 人员id_In)))
                      --站点
                       And Nvl(Nvl(e.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
    
      For c_记录 In (Select ID As 记录id From 临床出诊记录 Where 安排id = c_安排.安排id And 出诊日期 >= 开始时间_In) Loop
        l_记录id.Extend();
        l_记录id(l_记录id.Count) := c_记录.记录id;
      End Loop;
    End Loop;
  
    Zl_临床出诊记录_Batchdelete(l_记录id);
  End If;

  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, b.Id As 原安排id, b.号源id, c.科室id, c.项目id, c.医生id, c.医生姓名,
                      b.排班规则, b.是否周六出诊, b.是否周日出诊, b.开始时间, c.号类, Nvl(d.站点, '-') As 站点
               From 临床出诊安排 B, 临床出诊号源 C, 部门表 D, 人员表 E, 收费项目目录 F
               Where b.号源id = c.Id And c.科室id = d.Id And c.医生id = e.Id(+) And c.项目id = f.Id And b.出诊id = 模板id_In
                    --有效号源 
                     And Nvl(c.是否删除, 0) = 0 And (c.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or c.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And c.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       c.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or c.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = c.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = c.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(c.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = c.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  
    --临床出诊记录 
    For c_日期 In (Select Trunc(开始时间_In) + Level - 1 As 日期,
                        Decode(To_Char(Trunc(开始时间_In) + Level - 1, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                '周四', '6', '周五', '7', '周六', Null) As 星期
                 From Dual
                 Connect By Level <= Trunc(终止时间_In) - Trunc(开始时间_In) + 1) Loop
    
      Isvisit(c_号源.原安排id, c_号源.排班规则, c_日期.日期, c_号源.开始时间, v_限制项目, n_是否出诊);
    
      --是否周六、周日不出诊 
      --排班规则:1-星期排班;2-单日排班;3-双日排班;4-月内轮循;5-轮循不限制;6-特定日期 
      If Instr(',2,3,4,5,', c_号源.排班规则) > 0 And
         (Nvl(c_号源.是否周六出诊, 0) = 0 And c_日期.星期 = '周六' Or Nvl(c_号源.是否周日出诊, 0) = 0 And c_日期.星期 = '周日') Then
        n_是否出诊 := 0;
      End If;
    
      If Nvl(n_是否出诊, 0) = 1 Then
        For c_记录 In (With c_时间段 As
                        (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间
                        From (Select 时间段, 开始时间, 终止时间, 号类, 站点, 缺省时间, 提前时间,
                                      Row_Number() Over(Partition By 时间段 Order By 时间段, 站点 Asc, 号类 Asc) As 组号
                               From 时间段
                               Where Nvl(站点, c_号源.站点) = c_号源.站点 And Nvl(号类, c_号源.号类) = c_号源.号类)
                        Where 组号 = 1)
                       Select 临床出诊记录_Id.Nextval As 记录id, m.Id As 限制id, m.上班时段,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(j.终止时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.终止时间 <= j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 终止时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.缺省时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.缺省时间 < j.开始时间 Then
                                  1
                                 Else
                                  0
                               End As 缺省预约时间,
                              To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(Nvl(j.提前时间, j.开始时间), 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') + Case
                                 When j.开始时间 < j.提前时间 Then
                                  -1
                                 Else
                                  0
                               End As 提前挂号时间, m.限号数, m.限约数, m.是否序号控制, m.是否分时段, m.预约控制, a.项目id, a.医生id, a.医生姓名, m.分诊方式,
                              m.诊室id, m.是否独占
                       From 临床出诊安排 A, 临床出诊限制 M, c_时间段 J
                       Where a.Id = m.安排id And m.上班时段 = j.时间段 And a.Id = c_号源.原安排id And m.限制项目 = v_限制项目) Loop
        
          Insert Into 临床出诊记录
            (ID, 安排id, 号源id, 出诊日期, 上班时段, 开始时间, 终止时间, 缺省预约时间, 提前挂号时间, 限号数, 限约数, 是否序号控制, 是否分时段, 预约控制, 项目id, 科室id, 医生id,
             医生姓名, 分诊方式, 诊室id, 登记人, 登记时间, 是否独占)
          Values
            (c_记录.记录id, c_号源.安排id, c_号源.号源id, c_日期.日期, c_记录.上班时段, c_记录.开始时间, c_记录.终止时间, c_记录.缺省预约时间, c_记录.提前挂号时间,
             c_记录.限号数, c_记录.限约数, c_记录.是否序号控制, c_记录.是否分时段, c_记录.预约控制, c_记录.项目id, c_号源.科室id, c_记录.医生id, c_记录.医生姓名,
             c_记录.分诊方式, c_记录.诊室id, 操作员_In, 登记时间_In, c_记录.是否独占);
        
          Begin
            Select 开始时间 Into d_开始时间 From 临床出诊时段 Where 限制id = c_记录.限制id And 序号 = 1;
          Exception
            When Others Then
              d_开始时间 := Null;
          End;
          --插入临床出诊序号控制 
          If Nvl(c_记录.是否分时段, 0) = 1 And Nvl(c_记录.是否序号控制, 0) = 1 Then
            --分时段且启用序号控制，使用"预约顺序号"记录"是否预约" 
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 预约顺序号)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                        When Trunc(开始时间) > Trunc(d_开始时间) Then
                         1
                        Else
                         0
                      End,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                        When Trunc(终止时间) > Trunc(d_开始时间) Then
                         1
                        Else
                         0
                      End, 限制数量, 是否预约, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          Else
            Insert Into 临床出诊序号控制
              (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约)
              Select c_记录.记录id, 序号,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                       When Trunc(开始时间) > Trunc(d_开始时间) Then
                        1
                       Else
                        0
                     End,
                     To_Date(To_Char(c_日期.日期, 'yyyy-mm-dd ') || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') + Case
                       When Trunc(终止时间) > Trunc(d_开始时间) Then
                        1
                       Else
                        0
                     End, 限制数量, 是否预约
              From 临床出诊时段
              Where 限制id = c_记录.限制id;
          End If;
        
          --插入合作单位挂号控制记录 
          Insert Into 临床出诊挂号控制记录
            (类型, 性质, 名称, 记录id, 序号, 控制方式, 数量)
            Select 类型, 性质, 名称, c_记录.记录id, 序号, 控制方式, 数量
            From 临床出诊挂号控制
            Where 限制id = c_记录.限制id;
        
          --插入临床出诊诊室记录 
          Insert Into 临床出诊诊室记录
            (记录id, 诊室id)
            Select c_记录.记录id, 诊室id From 临床出诊诊室 Where 限制id = c_记录.限制id;
        End Loop;
      End If;
    End Loop;
  End Loop;

  --加入没有的出诊安排的号源 
  For c_号源 In (Select 临床出诊安排_Id.Nextval As 安排id, n_出诊id As 出诊id, a.Id As 号源id, a.项目id, a.医生id, a.医生姓名
               From 临床出诊号源 A, 部门表 D, 人员表 E, 收费项目目录 F
               Where a.科室id = d.Id And a.医生id = e.Id(+) And a.项目id = f.Id
                    --有效号源 
                     And Nvl(a.是否删除, 0) = 0 And (a.撤档时间 = To_Date('3000-01-01', 'yyyy-mm-dd') Or a.撤档时间 Is Null) And
                     Nvl(d.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(e.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     Nvl(f.撤档时间, To_Date('3000-01-01', 'yyyy-mm-dd')) = To_Date('3000-01-01', 'yyyy-mm-dd') And
                     (
                     --月排班 
                      Nvl(排班方式_In, 0) = 1 And a.排班方式 = 1
                     -- 周排班 
                      Or Nvl(排班方式_In, 0) = 2 And
                      (
                      --当前出诊表所在时间范围内不能有月排班 
                       a.排班方式 = 2 And Not Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 1)
                      --当前已调整为了月排班,但是本月又用了周排班，则本月剩下的部分将继续按周进行排班 
                       Or a.排班方式 = 1 And Exists
                       (Select 1
                           From 临床出诊安排 P, 临床出诊表 Q
                           Where p.出诊id = q.Id And p.号源id = a.Id And
                                 Not (p.终止时间 < Trunc(开始时间_In, 'MONTH') Or p.开始时间 > Last_Day(开始时间_In)) And q.排班方式 = 2)))
                    --号源在该出诊表时间范围内无出诊记录 
                     And Not Exists
                (Select 1
                      From 临床出诊记录 P
                      Where p.号源id = a.Id And p.出诊日期 Between 开始时间_In And 终止时间_In)
                    --当前人员可操作的号源 
                     And (Nvl(人员id_In, 0) = 0 Or (Nvl(a.是否临床排班, 0) = 1 And Exists
                      (Select 1 From 部门人员 Where 部门id = a.科室id And 人员id = 人员id_In)))
                    --站点 
                     And Nvl(Nvl(d.站点, 全院号源归属站点_In), Nvl(站点_In, '-')) = Nvl(站点_In, '-')
                    
                     And Not Exists (Select 1 From 临床出诊安排 Where 出诊id = n_出诊id And 号源id = a.Id)) Loop
  
    Insert Into 临床出诊安排
      (ID, 出诊id, 号源id, 项目id, 医生id, 医生姓名, 开始时间, 终止时间, 操作员姓名, 登记时间)
    Values
      (c_号源.安排id, c_号源.出诊id, c_号源.号源id, c_号源.项目id, c_号源.医生id, c_号源.医生姓名, 开始时间_In, 终止时间_In, 操作员_In, 登记时间_In);
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_临床出诊表_Addbytemplet;
/

--117750:殷瑞,2018-02-01,新增按给药途径的配置费收取方式
Create Or Replace Procedure Zl_输液配药记录_发送
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_Error      Varchar2(255);
  n_操作状态   输液配药记录.操作状态%Type;
  n_People     Number(2);
  v_No         Varchar2(20);
  n_项目id     Number(18);
  v_收费项目id Varchar2(200);
  n_Row        Number(2);
  n_Out        Number(10);
  n_Outnum     Number(10);
  n_Count      Number(18);
  n_Packet     Number(2);
  v_Usercode   Varchar2(100);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id, f.配药类型,
           c.执行时间
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F, 配置收费方案 G
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And
          Substr(f.配药类型, Instr(f.配药类型, '-') + 1) = g.配药类型(+) And Nvl(c.是否打包, 0) <> 0 And c.Id = v_Tansid
    Order By g.序号;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People   := Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out      := Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);
  n_Packet   := Nvl(zl_GetSysParameter('打包药品在发送环节收取配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;
  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
  
    Begin
      Select 操作状态 Into n_操作状态 From 输液配药记录 Where ID = v_Tansid;
    
      If n_操作状态 > 4 Then
        v_Error := '该数据已被操作，不能进行发送操作！';
        Raise Err_Custom;
      End If;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
  
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
    Values
      (v_Tansid, 5, 操作人员_In, 操作时间_In, 操作说明_In);
    Update 输液配药记录 Set 操作状态 = 5, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
  
    --打包药品收费
    If n_Packet = 1 Then
      n_Count := 0;
      Select Nextno(14) Into v_No From Dual;
    
      For r_Bill In c_Bill Loop
        Select Count(病人id)
        Into n_Outnum
        From 病案主页
        Where 主页id = r_Bill.主页id And 病人id = r_Bill.病人id And (Nvl(状态, 0) = 3 Or 出院日期 Is Not Null);
        
        --先查询是否有按给药途径收取的配置费方案
        Select Nvl(Max(项目id), 0)
        Into n_项目id
        From 输液配药记录 A, 病人医嘱记录 B, 配置收费方案 C
        Where a.Id = v_Tansid And a.医嘱id = b.Id And b.诊疗项目id = c.诊疗id;
        If n_项目id = 0 Then
          --若无对应给药途径的配置费收取方案，则再查询是否有按配药类型收取的配置费方案
          Select Nvl(Max(项目id), 0)
          Into n_项目id
          From 配置收费方案
          Where 配药类型 = Substr(r_Bill.配药类型, Instr(r_Bill.配药类型, '-', 1, 1) + 1);
        End If;
        
        If n_项目id <> 0 Then
          n_Row := 0;

          If n_People = 1 Then
            Select Count(配药id)
            Into n_Row
            From 输液配药附费 A, 住院费用记录 B, 输液配药记录 C
            Where a.No = b.No And a.配药id = c.Id And b.病人id = r_Bill.病人id And b.记录状态 = 1 And b.收费细目id = n_项目id And
                  r_Bill.执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间 + 1) - 1 / 24 / 60 / 60;
          End If;
        Else
          n_Row := 1;
        End If;
      
        If n_Row = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = n_项目id And b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            If n_Count = 0 Then
              Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            End If;
          
            n_Count := n_Count + 1;
            Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                             r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                             操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null,
                             r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null,
                             Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
          End Loop;
        End If;
      
        If n_Row = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_发送;
/

--117750:殷瑞,2018-01-30,新增按给药途径的配置费收取方案
Create Or Replace Procedure Zl_输液配药记录_配药
(
  配药id_In   In Varchar2, --ID串:ID1,ID2....
  操作人员_In In 输液配药记录.操作人员%Type := Null,
  操作时间_In In 输液配药记录.操作时间%Type := Null,
  操作说明_In In 输液配药状态.操作说明%Type := Null,
  移动操作_In In Number := 0
) Is
  v_Tansid     Varchar2(20);
  v_Tmp        Varchar2(4000);
  v_No         Varchar2(20);
  v_Usercode   Varchar2(100);
  n_操作状态   输液配药记录.操作状态%Type;
  v_Error      Varchar2(255);
  n_People     Number(1);
  n_Row        Number(2);
  d_执行时间   Date;
  v_配药类型   Varchar2(50);
  n_项目id     Number(18);
  v_收费项目id Varchar2(200);
  v_Info       Varchar2(200);
  v_Id         Varchar2(20);
  n_数次       Number(2);
  n_Count      Number(18);
  n_Out        Number(10);
  n_Outnum     Number(10);
  n_打包状态   Number(1);
  Err_Custom Exception;

  Cursor c_Bill Is
    Select a.病人id, a.主页id, a.标识号, a.姓名, a.性别, a.年龄, a.床号, a.费别, a.病人病区id, a.病人科室id, a.婴儿费, e.药品id, b.库房id, f.配药类型
    From 住院费用记录 A, 药品收发记录 B, 输液配药记录 C, 输液配药内容 D, 药品规格 E, 输液药品属性 F, 配置收费方案 G
    Where a.Id = b.费用id And b.Id = d.收发id And d.记录id = c.Id And b.药品id = e.药品id And b.药品id = f.药品id And
          Substr(f.配药类型, Instr(f.配药类型, '-') + 1) = g.配药类型(+) And Nvl(c.是否打包, 0) <> 1 And c.Id = v_Tansid
    Order By g.序号;

Begin
  v_Usercode := Zl_Identity;
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ';') + 1);
  v_Usercode := Substr(v_Usercode, Instr(v_Usercode, ',') + 1);
  v_Usercode := Substr(v_Usercode, 1, Instr(v_Usercode, ',') - 1);
  n_People   := Nvl(zl_GetSysParameter('配置费按病人收取', 1345), 0);
  n_Out      := Nvl(zl_GetSysParameter('出院病人不收配置费', 1345), 0);

  If 配药id_In Is Null Then
    v_Tmp := Null;
  Else
    v_Tmp := 配药id_In || ',';
  End If;

  While v_Tmp Is Not Null Loop
    --分解单据ID串
    v_Tansid := Substr(v_Tmp, 1, Instr(v_Tmp, ',') - 1);
    v_Tmp    := Replace(',' || v_Tmp, ',' || v_Tansid || ',');
  
    --检查当前输液单的状态是否为待摆药状态
    Begin
      Select 操作状态, 执行时间, Nvl(是否打包, 0)
      Into n_操作状态, d_执行时间, n_打包状态
      From 输液配药记录
      Where ID = v_Tansid;
    
      If n_操作状态 > 3 Then
        v_Error := '该数据已被操作，不能进行发药！';
        Raise Err_Custom;
      End If;
    Exception
      When Others Then
        v_Error := '该数据已被操作！';
        Raise Err_Custom;
    End;
  
    Update 输液配药记录 Set 操作状态 = 4, 操作人员 = 操作人员_In, 操作时间 = 操作时间_In Where ID = v_Tansid;
    Insert Into 输液配药状态
      (配药id, 操作类型, 操作人员, 操作时间, 操作说明)
    Values
      (v_Tansid, 4, 操作人员_In, 操作时间_In, 操作说明_In);
  
    If n_打包状态 = 0 Then
      n_Count := 0;
      Select Nextno(14) Into v_No From Dual;
      For r_Bill In c_Bill Loop
        Select Count(病人id)
        Into n_Outnum
        From 病案主页
        Where 主页id = r_Bill.主页id And 病人id = r_Bill.病人id And (Nvl(状态, 0) = 3 Or 出院日期 Is Not Null);
        If n_Count = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          --收取材料费
          --v_收费项目id:='6970,2;6971,1;';
          Select Zl_Fun_Pivacustom(v_Tansid) Into v_收费项目id From Dual;
          While v_收费项目id Is Not Null Loop
            v_Info       := Substr(v_收费项目id, 1, Instr(v_收费项目id, ';') - 1);
            v_收费项目id := Replace(';' || v_收费项目id, ';' || v_Info || ';');
          
            v_Id   := Substr(v_Info, 1, Instr(v_Info, ',') - 1);
            v_Info := Replace(',' || v_Info, ',' || v_Id || ',');
          
            For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                           From 收费项目目录 A, 收费价目 B, 收入项目 D
                           Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = v_Id And b.执行日期 <= Sysdate And
                                 (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
              If n_Count = 0 Then
                Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
              End If;
            
              n_Count := n_Count + 1;
              Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                               r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                               操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, v_Info, Null,
                               r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价 * v_Info,
                               r_Item.现价 * v_Info, Null, Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
            End Loop;
          End Loop;
        End If;
      
        --先查询是否有按给药途径收取的配置费方案
        Select Nvl(Max(项目id), 0)
        Into n_项目id
        From 输液配药记录 A, 病人医嘱记录 B, 配置收费方案 C
        Where a.Id = v_Tansid And a.医嘱id = b.Id And b.诊疗项目id = c.诊疗id;
        If n_项目id = 0 Then
          --若无对应给药途径的配置费收取方案，则再查询是否有按配药类型收取的配置费方案
          Select Nvl(Max(项目id), 0)
          Into n_项目id
          From 配置收费方案
          Where 配药类型 = Substr(r_Bill.配药类型, Instr(r_Bill.配药类型, '-', 1, 1) + 1);
        End If;
      
        If n_项目id <> 0 Then
          n_Row := 0;
        
          If n_People = 1 Then
            Select Count(配药id)
            Into n_Row
            From 输液配药附费 A, 住院费用记录 B, 输液配药记录 C
            Where a.No = b.No And a.配药id = c.Id And b.病人id = r_Bill.病人id And b.记录状态 = 1 And b.收费细目id = n_项目id And
                  d_执行时间 Between Trunc(c.执行时间) And Trunc(c.执行时间 + 1) - 1 / 24 / 60 / 60;
          End If;
        Else
          n_Row := 1;
        End If;
      
        If n_Row = 0 And (n_Outnum = 0 Or n_Out = 0) Then
          For r_Item In (Select a.Id 收费细目id, a.类别 收费类别, a.计算单位, a.加班加价 加班标志, d.Id 收入项目id, d.收据费目, b.现价
                         From 收费项目目录 A, 收费价目 B, 收入项目 D
                         Where a.Id = b.收费细目id And b.收入项目id = d.Id And a.Id = n_项目id And b.执行日期 <= Sysdate And
                               (b.终止日期 >= Sysdate Or b.终止日期 Is Null)) Loop
            If n_Count = 0 Then
              Insert Into 输液配药附费 (配药id, NO, 病人id) Values (v_Tansid, v_No, r_Bill.病人id);
            End If;
          
            n_Count := n_Count + 1;
            Zl_住院记帐记录_Insert(v_No, n_Count, r_Bill.病人id, r_Bill.主页id, r_Bill.标识号, r_Bill.姓名, r_Bill.性别, r_Bill.年龄,
                             r_Bill.床号, r_Bill.费别, r_Bill.病人病区id, r_Bill.病人科室id, r_Item.加班标志, r_Bill.婴儿费, r_Bill.库房id,
                             操作人员_In, Null, r_Item.收费细目id, r_Item.收费类别, r_Item.计算单位, Null, Null, Null, 1, 1, Null,
                             r_Bill.库房id, Null, r_Item.收入项目id, r_Item.收据费目, r_Item.现价, r_Item.现价, r_Item.现价, Null,
                             Sysdate, Sysdate, Null, Null, v_Usercode, 操作人员_In);
          End Loop;
        End If;
      
        If n_Row = 0 Then
          Exit;
        End If;
      End Loop;
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_配药;
/

--117750:殷瑞,2018-02-05,新增按给药途径的配置费收取方式
Create Or Replace Procedure Zl_配置收费方案_设置
(
  序号_In     In 配置收费方案.序号%Type,
  配药类型_In In 配置收费方案.配药类型%Type,
  项目id_In   In 配置收费方案.项目id%Type,
  收费项目_In In 配置收费方案.收费项目%Type,
  诊疗id_In   In 配置收费方案.诊疗id%Type,
  n_First_In  In Number
) Is
Begin
  If n_First_In = 1 Then
    Delete From 配置收费方案;
  End If;

  Insert Into 配置收费方案
    (序号, 配药类型, 项目id, 收费项目, 诊疗id)
  Values
    (序号_In, 配药类型_In, 项目id_In, 收费项目_In, 诊疗id_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_配置收费方案_设置;
/

--122553:李南春,2018-03-20,预约方式不可用时，返回具体的原因
--120818:焦博,2018-01-25,新版出诊表模式下,调用zl_三方机构挂号_insert对当日以后的号源进行挂号会报错
Create Or Replace Procedure Zl_三方机构挂号_Insert
(
  操作方式_In     Integer,
  病人id_In       门诊费用记录.病人id%Type,
  号码_In         挂号安排.号码%Type,
  号序_In         挂号序号状态.序号%Type,
  单据号_In       门诊费用记录.No%Type,
  票据号_In       门诊费用记录.实际票号%Type,
  结算方式_In     Varchar2,
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
  发生时间_In     门诊费用记录.发生时间%Type,
  登记时间_In     门诊费用记录.登记时间%Type,
  合作单位_In     挂号合作单位.名称%Type,
  挂号金额合计_In 门诊费用记录.实收金额%Type,
  领用id_In       票据使用明细.领用id%Type,
  收费票据_In     Number := 0, --挂号是否使用收费票据
  交易流水号_In   病人预交记录.交易流水号%Type,
  交易说明_In     病人预交记录.交易说明%Type,
  预约方式_In     预约方式.名称%Type := Null,
  预交id_In       病人预交记录.Id%Type := Null,
  卡类别id_In     病人预交记录.卡类别id%Type := Null,
  加入序号状态_In Number := 0,
  是否自助设备_In Number := 0,
  结帐id_In       门诊费用记录.结帐id%Type := Null,
  锁定类型_In     Number := 0,
  保险结算_In     Varchar2 := Null,
  冲预交_In       Number := Null,
  支付卡号_In     病人预交记录.卡号%Type := Null,
  退号重用_In     Number := 1,
  费别_In         门诊费用记录.费别%Type := Null,
  机器名_In       挂号序号状态.机器名%Type := Null,
  更新年龄_In     Number := 0,
  购买病历_In     Number := 0,
  出诊记录id_In   临床出诊记录.Id%Type := Null
) As
  --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款)
  --入参:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
  --      结算方式_IN:支持多种结算方式,多种结算方式时，传入格式如下:结算方式名称1,金额,结算号码,三方卡标志|结算方式名称2,金额,结算号码,三方卡标志|...
  --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
  --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
  --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
  --      保险结算_IN:格式="结算方式|结算金额||....."
  Err_Item Exception;
  Err_Special Exception;
  v_Err_Msg            Varchar2(255);
  n_打印id             票据打印内容.Id%Type;
  n_返回值             病人预交记录.金额%Type;
  v_排队号码           Varchar2(20);
  v_队列名称           排队叫号队列.队列名称%Type;
  n_预交id             病人预交记录.Id%Type;
  n_挂号id             病人挂号记录.Id%Type;
  v_结算内容           Varchar2(3000);
  v_当前结算           Varchar2(150);
  d_发生时间           Date;
  v_结算方式           病人预交记录.结算方式%Type;
  n_结算金额           病人预交记录.冲预交%Type;
  n_结算合计           Number(16, 5);
  n_预交金额           病人预交记录.冲预交%Type;
  n_组id               财务缴款分组.Id%Type;
  d_排队时间           Date;
  n_锁定               Number;
  n_病人预约科室数     Number(18);
  n_已约科室           Number(18);
  n_合作单位限制       Number(18);
  n_是否开放           Number(1);
  n_Count              Number(18);
  n_行号               Number(18);
  n_序号               病人挂号记录.号序%Type;
  n_费用id             门诊费用记录.Id%Type;
  n_价格父号           Number(18);
  n_原项目id           收费项目目录.Id%Type;
  n_原收入项目id       收费项目目录.Id%Type;
  v_诊室               病人挂号记录.诊室%Type;
  n_安排id             挂号安排.Id%Type;
  n_实收金额合计       门诊费用记录.实收金额%Type;
  n_开单部门id         门诊费用记录.开单部门id%Type;
  n_实收金额           门诊费用记录.实收金额%Type;
  n_应收金额           门诊费用记录.实收金额%Type;
  n_结帐id             病人结帐记录.Id%Type;
  v_Temp               Varchar2(500);
  n_预约时段序号       Number;
  n_预约总数           Number;
  d_时段开始时间       Date;
  v_收费项目ids        Varchar2(300);
  n_预约数量           合作单位挂号汇总.已约数%Type;
  n_号序               病人挂号记录.号序%Type;
  d_登记时间           Date;
  v_操作员编号         人员表.编号%Type;
  v_操作员姓名         人员表.姓名%Type;
  n_预约               Integer;
  v_星期               挂号安排时段.星期%Type;
  n_启用分时段         Integer;
  n_已挂数             病人挂号汇总.已挂数%Type;
  n_已约数             病人挂号汇总.已约数%Type;
  n_其中已接收         病人挂号汇总.已约数%Type;
  n_预约生成队列       Number;
  d_Date               Date;
  n_挂号序号           Number;
  v_排队序号           排队叫号队列.排队序号%Type;
  v_机器名             挂号序号状态.机器名%Type;
  v_序号操作员         挂号序号状态.操作员姓名%Type;
  v_序号机器名         挂号序号状态.机器名%Type;
  n_序号锁定           Number := 0;
  n_病历费id           收费特定项目.收费细目id%Type;
  v_付款方式           病人挂号记录.医疗付款方式%Type;
  v_费别               门诊费用记录.费别%Type;
  n_屏蔽费别           Number(3) := 0;
  n_Tmp安排id          挂号安排.Id%Type;
  n_计划id             挂号安排计划.Id%Type;
  v_年龄               病人信息.年龄%Type;
  n_合作单位限数量模式 Number;
  n_出诊记录id         临床出诊记录.Id%Type;
  n_挂号模式           Number(3);
  n_同科限号数         Number;
  n_同科限约数         Number;
  n_病人挂号科室数     Number;
  n_分时点显示         Number;
  d_启用时间           Date;
  n_Exists             Number;
  v_Para               Varchar2(2000);
  n_专家号挂号限制     Number;
  n_专家号预约限制     Number;
  v_时间段             时间段.时间段%Type;
  d_检查开始时间       时间段.开始时间%Type;
  d_检查结束时间       时间段.终止时间%Type;

  Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
    Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
    From 病人信息 A, 医疗付款方式 C
    Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);

  r_Pati c_Pati%RowType;

  --该游标用于收费冲预交的可用预交列表
  --以ID排序，优先冲上次未冲完的。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
    From 病人预交记录
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
    Group By NO
    Order By 结帐id, NO;

  Cursor c_安排
  (
    v_号码        挂号安排.号码%Type,
    d_发生时间_In Date
  ) Is
    Select *
    From (With 安排时间段 As (Select 时间段
                         From (Select 时间段,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                       To_Date(Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                                       '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')), 'yyyy-mm-dd hh24:mi:ss') As 终止时间,
                                       To_Date('3000-01-10 ' || To_Char(d_发生时间_In, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 当前时间,
                                       To_Date('3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间1,
                                       To_Date('3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间1
                                From 时间段)
                         Where 当前时间 Between 开始时间 And 终止时间1 Or 当前时间 Between 开始时间1 And 终止时间)
           Select Distinct p.Id, p.号类, p.号码, p.科室id, b.编码 As 科室编码, b.名称 As 科室名称, p.项目id, c.编码 As 项目编码, c.名称 As 项目名称,
                           p.医生id, d.编号 As 医生编号, p.医生姓名, p.限号数, p.限约数, p.周日 As 日, p.周一 As 一, p.周二 As 二, p.周三 As 三,
                           p.周四 As 四, p.周五 As 五, p.周六 As 六, p.序号控制, p.计划id
           From (Select p.Id, p.号码, p.号类, p.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(p.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, Null As 计划id
                  From 挂号安排 P, 挂号安排限制 B
                  Where p.停用日期 Is Null And p.Id = b.安排id(+) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And
                        d_发生时间_In Between Nvl(p.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                        Nvl(p.终止时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Not Exists
                   (Select 1
                         From 挂号安排计划
                         Where 安排id = p.Id And (d_发生时间_In Between 生效时间 And 失效时间) And 审核时间 Is Not Null) And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = p.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码
                  Union All
                  Select c.Id, c.号码, c.号类, c.科室id, p.项目id, p.医生id, p.医生姓名, b.限号数, b.限约数, Nvl(c.病案必须, 0) As 病案必须, p.周日, p.周一,
                         p.周二, p.周三, p.周四, p.周五, p.周六, p.分诊方式, p.序号控制,
                         Decode(To_Char(d_发生时间_In, 'D'), '1', p.周日, '2', p.周一, '3', p.周二, '4', p.周三, '5', p.周四, '6', p.周五,
                                 '7', p.周六, Null) As 排班, p.Id As 计划id
                  From 挂号安排计划 P, 挂号安排 C, 挂号计划限制 B,
                       (Select Max(a.生效时间) As 生效, 安排id
                         From 挂号安排计划 A, 挂号安排 B
                         Where a.安排id = b.Id And a.审核时间 Is Not Null And
                               发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                               Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                         Group By 安排id) E
                  Where p.安排id = c.Id And p.Id = b.计划id(+) And p.生效时间 = e.生效 And p.安排id = e.安排id And
                        Nvl(p.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                        b.限制项目(+) = Decode(To_Char(d_发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四',
                                           '6', '周五', '7', '周六', Null) And (d_发生时间_In Between p.生效时间 And p.失效时间) And
                        p.审核时间 Is Not Null And Not Exists
                   (Select 1
                         From 挂号安排停用状态
                         Where 安排id = c.Id And d_发生时间_In Between 开始停止时间 And 结束停止时间) And p.号码 = v_号码) P, 部门表 B, 收费项目目录 C,
                人员表 D
           Where p.科室id = b.Id And p.医生id = d.Id(+) And p.项目id = c.Id And
                 (c.撤档时间 Is Null Or c.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD')) And
                 (Nvl(p.医生id, 0) = 0 Or Exists
                  (Select 1
                   From 人员表 Q
                   Where p.医生id = q.Id And (q.撤档时间 = To_Date('3000-01-01', 'YYYY-MM-DD') Or q.撤档时间 Is Null))) And Exists
            (Select 1 From 安排时间段 Where 时间段 = p.排班))
           Order By 号码;


  r_安排 c_安排%RowType;

  Function Zl_诊室(号码_In 挂号安排.号码%Type) Return Varchar2 As
    n_分诊方式 挂号安排.分诊方式%Type;
    n_安排id   挂号安排.Id%Type;
    v_诊室     病人挂号记录.诊室%Type;
    v_Rowid    Varchar2(500);
    n_Next     Integer;
    n_First    Integer;
  Begin
  
    If 锁定类型_In = 2 Then
      --对单据进行解锁,首先检查是否存在锁定
      Select Count(Rowid) Into n_锁定 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      If n_锁定 = 0 Then
        v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
        Raise Err_Item;
      End If;
      Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
    End If;
  
    Begin
      Select ID, Nvl(分诊方式, 0) Into n_安排id, n_分诊方式 From 挂号安排 Where 号码 = 号码_In;
    Exception
      When Others Then
        n_安排id := -1;
    End;
  
    If n_安排id = -1 Then
      v_Err_Msg := '号码(' || 号码_In || ')未找到!';
      Raise Err_Item;
    End If;
    --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
    v_诊室 := Null;
    If n_分诊方式 = 1 Then
      --1-指定诊室
      Begin
        Select 门诊诊室 Into v_诊室 From 挂号安排诊室 Where 号表id = n_安排id;
      Exception
        When Others Then
          v_诊室 := Null;
      End;
    End If;
    If n_分诊方式 = 2 Then
      --2-动态分诊:该个号别当天挂号未诊数最少的诊室
      For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                   From (Select 门诊诊室, 0 As Num
                          From 挂号安排诊室
                          Where 号表id = n_安排id
                          Union All
                          Select 诊室, Count(诊室) As Num
                          From 病人挂号记录
                          Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                诊室 In (Select 门诊诊室 From 挂号安排诊室 Where 号表id = n_安排id)
                          Group By 诊室)
                   Group By 门诊诊室
                   Order By Num) Loop
        v_诊室 := c_诊室.门诊诊室;
        Exit;
      End Loop;
    End If;
    If n_分诊方式 = 3 Then
    
      --平均分诊：当前分配=1表示下次应取的当前诊室
      n_Next  := 0;
      n_First := 1;
      For c_诊室 In (Select Rowid As Rid, 号表id, 门诊诊室, 当前分配 From 挂号安排诊室 Where 号表id = n_安排id) Loop
        If n_First = 1 Then
          v_Rowid := c_诊室.Rid;
        End If;
        If n_Next = 1 Then
          v_诊室 := c_诊室.门诊诊室;
          Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
          Exit;
        End If;
        If Nvl(c_诊室.当前分配, 0) = 1 Then
          Update 挂号安排诊室 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
          n_Next := 1;
        End If;
      End Loop;
      If v_诊室 Is Null Then
        Update 挂号安排诊室 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 门诊诊室 Into v_诊室;
      End If;
    End If;
  
    Return v_诊室;
  End;

  Function Zl_操作员
  (
    Type_In     Integer,
    Splitstr_In Varchar2
  ) Return Varchar2 As
    n_Step Number(18);
    v_Sub  Varchar2(1000);
    --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
    -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
  Begin
    If Type_In = 0 Then
      --缺省部门
      n_Step := Instr(Splitstr_In, ',');
      v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 1 Then
      --操作员编码
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, 1, n_Step - 1);
      Return v_Sub;
    End If;
    If Type_In = 2 Then
      --操作员姓名
      n_Step := Instr(Splitstr_In, ';');
      v_Sub  := Substr(Splitstr_In, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      n_Step := Instr(v_Sub, ',');
      v_Sub  := Substr(v_Sub, n_Step + 1);
      Return v_Sub;
    End If;
  End;

  Procedure Zl_三方机构挂号_出诊_Insert
  (
    记录id_In       临床出诊记录.Id%Type,
    操作方式_In     Integer,
    病人id_In       门诊费用记录.病人id%Type,
    号码_In         挂号安排.号码%Type,
    号序_In         挂号序号状态.序号%Type,
    单据号_In       门诊费用记录.No%Type,
    票据号_In       门诊费用记录.实际票号%Type,
    结算方式_In     Varchar2,
    摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息
    发生时间_In     门诊费用记录.发生时间%Type,
    登记时间_In     门诊费用记录.登记时间%Type,
    合作单位_In     挂号合作单位.名称%Type,
    挂号金额合计_In 门诊费用记录.实收金额%Type,
    领用id_In       票据使用明细.领用id%Type,
    收费票据_In     Number := 0, --挂号是否使用收费票据
    交易流水号_In   病人预交记录.交易流水号%Type,
    交易说明_In     病人预交记录.交易说明%Type,
    预约方式_In     预约方式.名称%Type := Null,
    预交id_In       病人预交记录.Id%Type := Null,
    卡类别id_In     病人预交记录.卡类别id%Type := Null,
    加入序号状态_In Number := 0,
    是否自助设备_In Number := 0,
    结帐id_In       门诊费用记录.结帐id%Type := Null,
    锁定类型_In     Number := 0,
    保险结算_In     Varchar2 := Null,
    冲预交_In       Number := Null,
    支付卡号_In     病人预交记录.卡号%Type := Null,
    退号重用_In     Number := 1,
    费别_In         门诊费用记录.费别%Type := Null,
    机器名_In       挂号序号状态.机器名%Type := Null,
    更新年龄_In     Number := 0,
    购买病历_In     Number := 0
  ) As
    --功能：三方机构进行挂号(包含预约;预约挂号不扣款;预约挂号扣款),出诊表排班模式下使用
    --入参: 操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
    --      加入序号状态_In:1-表示强制加入挂号序号状态表中;否则根据启用序号或启用时段时才加入.
    --      是否自助设备_In:1-表示是医院的自助设备进行此函数的调用,自助设备调用此函数 允许加号,否则不允许
    --      锁定类型_In :0-产生正常数据 1-表示对单据进行锁定,产生未生效的单据信息;2-对锁定的记录进行解锁-生成正常数据:未生效的单据在银行扣款完成后进行解锁
    --      保险结算_IN:格式="结算方式|结算金额||....."
    --      冲预交病人ids_In:多个用逗分分离,冲预交时有效(冲预交类别与业务操作保持一致),主要是使用家属的预交款
    Err_Item Exception;
    Err_Special Exception;
    v_Err_Msg            Varchar2(255);
    n_打印id             票据打印内容.Id%Type;
    n_返回值             病人预交记录.金额%Type;
    v_排队号码           Varchar2(20);
    v_队列名称           排队叫号队列.队列名称%Type;
    n_预交id             病人预交记录.Id%Type;
    n_挂号id             病人挂号记录.Id%Type;
    v_结算内容           Varchar2(3000);
    v_当前结算           Varchar2(150);
    v_结算方式           病人预交记录.结算方式%Type;
    n_结算金额           病人预交记录.冲预交%Type;
    n_结算合计           Number(16, 5);
    n_预交金额           病人预交记录.冲预交%Type;
    n_组id               财务缴款分组.Id%Type;
    d_排队时间           Date;
    n_锁定               Number;
    n_病人预约科室数     Number(18);
    n_已约科室           Number(18);
    d_发生时间           Date;
    n_合作单位限制       Number(18);
    n_是否开放           Number(1);
    n_Count              Number(18);
    n_行号               Number(18);
    n_序号               病人挂号记录.号序%Type;
    n_费用id             门诊费用记录.Id%Type;
    n_价格父号           Number(18);
    n_原项目id           收费项目目录.Id%Type;
    n_原收入项目id       收费项目目录.Id%Type;
    v_诊室               病人挂号记录.诊室%Type;
    n_实收金额合计       门诊费用记录.实收金额%Type;
    n_开单部门id         门诊费用记录.开单部门id%Type;
    n_实收金额           门诊费用记录.实收金额%Type;
    n_应收金额           门诊费用记录.实收金额%Type;
    n_结帐id             病人结帐记录.Id%Type;
    v_Temp               Varchar2(500);
    v_结算方式记录       Varchar2(1000);
    n_预约时段序号       Number;
    n_序号控制           临床出诊记录.是否序号控制%Type;
    n_限约数             临床出诊记录.限约数%Type;
    n_项目id             临床出诊记录.项目id%Type;
    n_科室id             临床出诊记录.科室id%Type;
    d_终止时间           临床出诊记录.终止时间%Type;
    v_医生姓名           临床出诊记录.医生姓名%Type;
    n_医生id             临床出诊记录.医生id%Type;
    n_预约顺序号         临床出诊序号控制.预约顺序号%Type;
    n_预约总数           Number;
    d_时段开始时间       Date;
    d_时段终止时间       Date;
    v_收费项目ids        Varchar2(300);
    n_三方卡标志         Number;
    n_号序               病人挂号记录.号序%Type;
    d_登记时间           Date;
    n_单笔金额           病人预交记录.冲预交%Type;
    v_结算号码           病人预交记录.结算号码%Type;
    v_操作员编号         人员表.编号%Type;
    v_操作员姓名         人员表.姓名%Type;
    n_预约               Integer;
    v_现金               病人预交记录.结算方式%Type;
    n_启用分时段         Integer;
    n_已挂数             病人挂号汇总.已挂数%Type;
    n_已约数             病人挂号汇总.已约数%Type;
    n_其中已接收         病人挂号汇总.已约数%Type;
    n_预约生成队列       Number;
    n_限号数             临床出诊记录.限号数%Type;
    d_Date               Date;
    n_挂号序号           Number;
    v_排队序号           排队叫号队列.排队序号%Type;
    v_机器名             挂号序号状态.机器名%Type;
    v_序号操作员         挂号序号状态.操作员姓名%Type;
    v_序号机器名         挂号序号状态.机器名%Type;
    n_序号锁定           Number := 0;
    n_病历费id           收费特定项目.收费细目id%Type;
    v_付款方式           病人挂号记录.医疗付款方式%Type;
    v_费别               门诊费用记录.费别%Type;
    n_屏蔽费别           Number(3) := 0;
    v_年龄               病人信息.年龄%Type;
    n_合作单位限数量模式 Number;
    n_同科限号数         Number;
    n_分时点显示         Number;
    n_同科限约数         Number;
    n_病人挂号科室数     Number;
    n_Exists             Number(5);
    n_替诊医生id         临床出诊记录.替诊医生id%Type;
    v_替诊医生姓名       临床出诊记录.替诊医生姓名%Type;
    d_替诊开始时间       临床出诊记录.替诊开始时间%Type;
    d_替诊终止时间       临床出诊记录.替诊终止时间%Type;
    n_专家号挂号限制     Number;
    n_专家号预约限制     Number;
  
    Cursor c_Pati(n_病人id 病人信息.病人id%Type) Is
      Select a.病人id, a.姓名, a.性别, a.年龄, a.住院号, a.门诊号, a.费别, a.险类, c.编码 As 付款方式
      From 病人信息 A, 医疗付款方式 C
      Where a.病人id = n_病人id And a.医疗付款方式 = c.名称(+);
  
    r_Pati c_Pati%RowType;
  
    --该游标用于收费冲预交的可用预交列表
    --以ID排序，优先冲上次未冲完的。
    Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
      Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id,
             Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id
      From 病人预交记录
      Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0
      Group By NO
      Order By 结帐id, NO;
  
    Function Zl_诊室(记录id_In 临床出诊记录.Id%Type) Return Varchar2 As
      n_分诊方式 临床出诊记录.分诊方式%Type;
      v_诊室     病人挂号记录.诊室%Type;
      v_Rowid    Varchar2(500);
      n_Next     Integer;
      n_First    Integer;
    Begin
    
      If 锁定类型_In = 2 Then
        --对单据进行解锁,首先检查是否存在锁定
        Select Count(Rowid)
        Into n_锁定
        From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
        If n_锁定 = 0 Then
          v_Err_Msg := '单据号为(' || 单据号_In || ')的单据,不存在或者已经被解锁!';
          Raise Err_Item;
        End If;
        Select Max(号序) Into n_号序 From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      End If;
    
      Begin
        Select Nvl(分诊方式, 0) Into n_分诊方式 From 临床出诊记录 Where ID = 记录id_In;
      Exception
        When Others Then
          v_Err_Msg := '出诊记录(' || 记录id_In || ')未找到!';
          Raise Err_Item;
      End;
    
      --0-不分诊、1-指定诊室、2-动态分诊、3-平均分诊,对应门诊诊室设置
      v_诊室 := Null;
      If n_分诊方式 = 1 Then
        --1-指定诊室
        Begin
          Select b.名称 Into v_诊室 From 临床出诊诊室记录 A, 门诊诊室 B Where a.诊室id = b.Id And a.记录id = 记录id_In;
        Exception
          When Others Then
            v_诊室 := Null;
        End;
      End If;
      If n_分诊方式 = 2 Then
        --2-动态分诊:该个号别当天挂号未诊数最少的诊室
        For c_诊室 In (Select 门诊诊室, Sum(Num) As Num
                     From (Select b.名称 As 门诊诊室, 0 As Num
                            From 临床出诊诊室记录 A, 门诊诊室 B
                            Where a.诊室id = b.Id And a.记录id = 记录id_In
                            Union All
                            Select 诊室, Count(诊室) As Num
                            From 病人挂号记录
                            Where Nvl(执行状态, 0) = 0 And 发生时间 Between Trunc(Sysdate) And Sysdate And 号别 = 号码_In And
                                  诊室 In (Select d.名称
                                         From 临床出诊诊室记录 C, 门诊诊室 D
                                         Where c.诊室id = d.Id And c.记录id = 记录id_In)
                            Group By 诊室)
                     Group By 门诊诊室
                     Order By Num) Loop
          v_诊室 := c_诊室.门诊诊室;
          Exit;
        End Loop;
      End If;
      If n_分诊方式 = 3 Then
        --平均分诊：当前分配=1表示下次应取的当前诊室
        n_Next  := 0;
        n_First := 1;
        For c_诊室 In (Select a.Rowid As Rid, b.名称 As 门诊诊室, a.当前分配
                     From 临床出诊诊室记录 A, 门诊诊室 B
                     Where a.诊室id = b.Id And a.记录id = 记录id_In) Loop
          If n_First = 1 Then
            v_Rowid := c_诊室.Rid;
          End If;
          If n_Next = 1 Then
            v_诊室 := c_诊室.门诊诊室;
            Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = c_诊室.Rid;
            Exit;
          End If;
          If Nvl(c_诊室.当前分配, 0) = 1 Then
            Update 临床出诊诊室记录 Set 当前分配 = 0 Where Rowid = c_诊室.Rid;
            n_Next := 1;
          End If;
        End Loop;
        If v_诊室 Is Null Then
          Update 临床出诊诊室记录 Set 当前分配 = 1 Where Rowid = v_Rowid Returning 诊室id Into v_诊室;
          Select 名称 Into v_诊室 From 门诊诊室 Where ID = v_诊室;
        End If;
      End If;
      Return v_诊室;
    End;
  
    Function Zl_操作员
    (
      Type_In     Integer,
      Splitstr_In Varchar2
    ) Return Varchar2 As
      n_Step Number(18);
      v_Sub  Varchar2(1000);
      --Type_In:0-获取缺省部门ID;1-获取操作员编号;2-获取操作员姓名
      -- SplitStr:格式为:部门ID,部门名称;人员ID,人员编号,人员姓名(用Zl_Identity获取的)
    Begin
      If Type_In = 0 Then
        --缺省部门
        n_Step := Instr(Splitstr_In, ',');
        v_Sub  := Substr(Splitstr_In, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 1 Then
        --操作员编码
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, 1, n_Step - 1);
        Return v_Sub;
      End If;
      If Type_In = 2 Then
        --操作员姓名
        n_Step := Instr(Splitstr_In, ';');
        v_Sub  := Substr(Splitstr_In, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        n_Step := Instr(v_Sub, ',');
        v_Sub  := Substr(v_Sub, n_Step + 1);
        Return v_Sub;
      End If;
    End;
  
  Begin
    d_发生时间 := 发生时间_In;
  
    If d_发生时间 Is Null Then
      d_发生时间 := Sysdate;
    End If;
  
    Begin
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_现金 := '现金';
    End;
  
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
  
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 出诊记录id = 记录id_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
  
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(记录id_In, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select 1
        Into n_合作单位限制
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 类型 = 1 And 性质 = 1 And 控制方式 <> 4 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限制 := 0;
      End;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(记录id_In);
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Begin
      Select Nvl(是否分时段, 0), 限号数, 已挂数, 其中已接收, 已约数, 是否序号控制, 限约数, 项目id, 科室id, 医生id, 医生姓名, 替诊医生id, 替诊医生姓名, 替诊开始时间, 替诊终止时间
      Into n_启用分时段, n_限号数, n_已挂数, n_其中已接收, n_已约数, n_序号控制, n_限约数, n_项目id, n_科室id, n_医生id, v_医生姓名, n_替诊医生id, v_替诊医生姓名,
           d_替诊开始时间, d_替诊终止时间
      From 临床出诊记录
      Where ID = 记录id_In And Nvl(是否锁定, 0) = 0;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    If 发生时间_In Between Nvl(d_替诊开始时间, Sysdate) And Nvl(d_替诊终止时间, Sysdate - 1) And v_替诊医生姓名 Is Not Null Then
      n_医生id   := n_替诊医生id;
      v_医生姓名 := v_替诊医生姓名;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> n_科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = n_科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 出诊记录id = 记录id_In;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(n_限号数, 0) >= 0 Or n_限号数 Is Null Then
      If n_启用分时段 = 1 Then
        If Nvl(n_序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            Select Count(*), Max(开始时间)
            Into n_Count, d_时段开始时间
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0);
          
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
        
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 终止时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                         To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 终止时间, 数量, 是否预约
                         From 临床出诊序号控制
                         Where 记录id = 记录id_In And 序号 = Nvl(号序_In, 0)) Loop
              If Sysdate > v_时段.终止时间 Then
                v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                Raise Err_Item;
              End If;
            End Loop;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          For v_时段 In (Select 序号, 开始时间, 终止时间, 数量, 是否预约
                       From 临床出诊序号控制
                       Where 记录id = 记录id_In And
                             (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                             '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                             ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                             '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                             Decode(Sign(开始时间 - 终止时间 - 1 / 24 / 60 / 60), 1,
                                      '3000-01-11 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                      '3000-01-10 ' || To_Char(终止时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
            n_预约时段序号 := v_时段.序号;
            d_时段开始时间 := v_时段.开始时间;
            d_时段终止时间 := v_时段.终止时间;
          
            Select Count(*), Max(序号), Max(预约顺序号) + 1
            Into n_Count, n_预约总数, n_预约顺序号
            From 临床出诊序号控制
            Where 记录id = 记录id_In And Nvl(挂号状态, 0) Not In (0, 4, 5);
          
            If Nvl(n_Count, 0) > Nvl(v_时段.数量, 0) And 锁定类型_In <> 2 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                           To_Char(v_时段.终止时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.数量, 0) || '人,不能再进行预约挂号！';
              Raise Err_Item;
            End If;
            n_Count := 1;
          End Loop;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(n_限号数, 0) And n_限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(n_限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(n_限约数, 0) And Nvl(n_限约数, 0) <> 0 And n_限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(n_限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
      If 预约方式_In Is Not Null Then
        Select To_Number(Substr(Zl_Fun_Get临床出诊预约状态(记录id_In, 发生时间_In, 号序_In, 预约方式_In, NULL, 0, v_操作员姓名, v_机器名), 1, 1))
        Into n_Exists
        From Dual;
        If n_Exists <> 0 Then
          v_Err_Msg := '传入的预约方式' || 预约方式_In || '不可用,原因:'|| substr(n_Exists,3);
          Raise Err_Item;
        End If;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
      If Nvl(n_序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(n_序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位控制模式
      Begin
        Select Nvl(控制方式, 0)
        Into n_合作单位限数量模式
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And Rownum < 2;
      Exception
        When Others Then
          n_合作单位限数量模式 := 4;
      End;
    
      If n_合作单位限数量模式 = 0 Then
        v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '未开放' || 合作单位_In || '的预约,不能继续。';
        Raise Err_Item;
      End If;
      If n_合作单位限数量模式 = 1 Or n_合作单位限数量模式 = 2 Then
        Select 数量
        Into n_Count
        From 临床出诊挂号控制记录
        Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1;
        If n_合作单位限数量模式 = 1 Then
          n_Count := Round(Nvl(n_限约数, n_限号数) * n_Count / 100);
        End If;
        Select Count(1)
        Into n_Exists
        From 病人挂号记录
        Where 记录状态 = 1 And 出诊记录id = 记录id_In And 合作单位 = 合作单位_In;
        If n_Exists >= n_Count Then
          v_Err_Msg := '当前号码(' || Nvl(号码_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
          Raise Err_Item;
        End If;
      End If;
      --开放序号检查
      If n_合作单位限数量模式 = 3 Then
        For c_合作单位 In (Select 序号, 数量
                       From 临床出诊挂号控制记录
                       Where 记录id = 记录id_In And 名称 = 合作单位_In And 类型 = 1 And 性质 = 1 And 序号 = 号序_In) Loop
          If n_序号控制 = 1 Then
            Begin
              Select 1
              Into n_Count
              From 临床出诊序号控制
              Where 记录id = 记录id_In And 序号 = 号序_In And Nvl(挂号状态, 0) = 0;
            Exception
              When Others Then
                n_Count := 0;
            End;
            If n_Count = 1 Then
              n_是否开放 := 1;
            Else
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            End If;
          Else
            Select Count(1)
            Into n_Count
            From 临床出诊序号控制
            Where 记录id = 记录id_In And 序号 = 号序_In And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
            If n_Count >= c_合作单位.数量 Then
              v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '已经超过' || 合作单位_In || '的预约限制,不能继续。';
              Raise Err_Item;
            Else
              n_是否开放 := 1;
            End If;
          End If;
        End Loop;
      
        If Nvl(n_是否开放, 0) = 0 Then
          v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := n_项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := n_项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_项目id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, n_科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), n_科室id, v_医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null, Null,
           摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 临床出诊序号控制
      Where 记录id = 记录id_In And 序号 = n_号序 And Nvl(挂号状态, 0) Not In (0, 5);
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(n_序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
  
    If n_启用分时段 = 0 And Nvl(n_序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      Select Nvl(Min(序号), 0)
      Into n_号序
      From 临床出诊序号控制
      Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
      If n_号序 = 0 Then
        Select Nvl(Min(序号), 0) Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In And Nvl(挂号状态, 0) = 0;
        If n_号序 = 0 Then
          Select Nvl(Max(序号), 0) + 1 Into n_号序 From 临床出诊序号控制 Where 记录id = 记录id_In;
        End If;
      End If;
    End If;
  
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
      If 操作方式_In > 1 And Nvl(n_序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(n_限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(n_序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 工作站名称
        Into v_序号操作员, v_序号机器名
        From 临床出诊序号控制
        Where 挂号状态 = 5 And 记录id = 记录id_In And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        If n_启用分时段 = 1 And n_序号控制 = 0 Then
          Insert Into 临床出诊序号控制
            (记录id, 序号, 预约顺序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名, 备注)
            Select 记录id_In, n_预约时段序号, n_预约顺序号, d_时段开始时间, d_时段终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1),
                   1, 合作单位_In, v_操作员姓名, n_号序
            From Dual;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
          Where 记录id = 记录id_In And 序号 = n_号序;
        End If;
        If Sql%RowCount = 0 Then
          Begin
            If n_启用分时段 = 1 Then
              --分时段
              If n_序号控制 = 1 Then
                --序号控制
                Select Max(终止时间) Into d_终止时间 From 临床出诊序号控制 Where 记录id = 记录id_In;
                If Sysdate > d_终止时间 Then
                  d_终止时间 := Sysdate;
                End If;
                Insert Into 临床出诊序号控制
                  (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                  Select 记录id_In, n_号序, d_终止时间, d_终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1,
                         合作单位_In, v_操作员姓名
                  From Dual;
              Else
                --分时段,非序号控制
                Null;
              End If;
            Else
              --不分时段
              Insert Into 临床出诊序号控制
                (记录id, 序号, 开始时间, 终止时间, 数量, 是否预约, 挂号状态, 类型, 名称, 操作员姓名)
                Select 记录id_In, n_号序, 开始时间, 终止时间, 1, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 2, 2, 1), 1, 合作单位_In,
                       v_操作员姓名
                From 临床出诊序号控制
                Where 记录id = 记录id_In And 序号 = 1;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被机器' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 临床出诊序号控制
          Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 锁号时间 = Null
          Where 记录id = 记录id_In And 序号 = n_号序 And 挂号状态 = 5 And 操作员姓名 = v_操作员姓名 And 工作站名称 = v_机器名;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
    
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
        If Instr(结算方式_In, ',') = 0 Then
          --只传入一种结算方式的
          Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          Insert Into 病人预交记录
            (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
             合作单位, 结算性质, 结算号码)
          Values
            (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(n_结算金额, 0), 登记时间_In,
             v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
        Else
          v_结算内容     := 结算方式_In || '|'; --以空格分开以|结尾,没有结算号码的
          n_Exists       := 0;
          v_结算方式记录 := '';
          While v_结算内容 Is Not Null Loop
            v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '|') - 1);
            v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_单笔金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1));
          
            v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            v_结算号码 := Substr(v_当前结算, 1, Instr(v_当前结算, ',') - 1);
          
            v_当前结算   := Substr(v_当前结算, Instr(v_当前结算, ',') + 1);
            n_三方卡标志 := To_Number(v_当前结算);
          
            If Instr('|' || v_结算方式记录 || '|', '|' || Nvl(v_结算方式, v_现金) || '|') <> 0 Then
              v_Err_Msg := '使用了重复的结算方式,请检查!';
              Raise Err_Item;
            Else
              v_结算方式记录 := v_结算方式记录 || '|' || Nvl(v_结算方式, v_现金);
            End If;
          
            If n_三方卡标志 = 0 Then
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, Null, Null, Null, Null, Null, 合作单位_In, 4, v_结算号码);
            Else
              If n_Exists = 1 Then
                v_Err_Msg := '目前挂号仅支持一种三方结算方式,不能继续操作！';
                Raise Err_Item;
              End If;
              Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
              Insert Into 病人预交记录
                (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号,
                 交易说明, 合作单位, 结算性质, 结算号码)
              Values
                (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(v_结算方式, v_现金), Nvl(n_单笔金额, 0), 登记时间_In,
                 v_操作员编号, v_操作员姓名, n_结帐id, '挂号收费', n_组id, 卡类别id_In, Null, 支付卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4, v_结算号码);
              n_Exists := 1;
            End If;
          
            v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '|') + 1);
          End Loop;
        End If;
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = v_缴款.结算方式 And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      End Loop;
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号)), 出诊记录id = 记录id_In
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号, 出诊记录id)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, n_科室id, v_医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号), 记录id_In);
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := n_科室id;
            v_排队号码 := Zlgetnextqueue(n_科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, n_科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, v_医生姓名, d_排队时间,
                             预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(v_医生姓名, n_医生id, n_项目id, n_科室id, 发生时间_In, n_预约, 号码_In, 0, 记录id_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  Exception
    When Err_Item Then
      Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Err_Special Then
      Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End;

Begin
  n_出诊记录id := 出诊记录id_In;
  v_Para       := zl_GetSysParameter(256);
  n_挂号模式   := Substr(v_Para, 1, 1);
  Begin
    d_启用时间 := To_Date(Substr(v_Para, 3), 'yyyy-mm-dd hh24:mi:ss');
  Exception
    When Others Then
      d_启用时间 := Null;
  End;

  d_发生时间 := 发生时间_In;
  If d_发生时间 Is Null Then
    d_发生时间 := Sysdate;
  End If;

  If Sysdate - 10 > Nvl(d_启用时间, Sysdate - 30) Then
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
      Raise Err_Item;
    End If;
  Else
    If n_挂号模式 = 1 And Nvl(发生时间_In, Sysdate) > Nvl(d_启用时间, Sysdate - 30) And n_出诊记录id Is Null Then
      Begin
        Select a.Id
        Into n_出诊记录id
        From 临床出诊记录 A, 临床出诊号源 B
        Where a.号源id = b.Id And b.号码 = 号码_In And Nvl(发生时间_In, Sysdate) Between a.开始时间 And a.终止时间;
      Exception
        When Others Then
          v_Err_Msg := '系统当前处于出诊表排班模式，传入的参数无法确定挂号安排，请重试！';
          Raise Err_Item;
      End;
    End If;
  End If;

  If n_出诊记录id Is Not Null Then
    --出诊表排班模式
    Zl_三方机构挂号_出诊_Insert(n_出诊记录id, 操作方式_In, 病人id_In, 号码_In, 号序_In, 单据号_In, 票据号_In, 结算方式_In, 摘要_In, 发生时间_In, 登记时间_In,
                        合作单位_In, 挂号金额合计_In, 领用id_In, 收费票据_In, 交易流水号_In, 交易说明_In, 预约方式_In, 预交id_In, 卡类别id_In, 加入序号状态_In,
                        是否自助设备_In, 结帐id_In, 锁定类型_In, 保险结算_In, 冲预交_In, 支付卡号_In, 退号重用_In, 费别_In, 机器名_In, 更新年龄_In, 购买病历_In);
  Else
    v_Temp := zl_GetSysParameter(256);
    If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then
      Null;
    Else
      Begin
        d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss');
      Exception
        When Others Then
          Null;
      End;
      If 发生时间_In > d_启用时间 Then
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!';
        Raise Err_Item;
      End If;
    End If;
    If 费别_In Is Null Then
      Select Zl_Custom_Getpatifeetype(1, 病人id_In) Into v_费别 From Dual;
    Else
      v_费别 := 费别_In;
    End If;
    If v_费别 Is Null Then
      n_屏蔽费别 := 1;
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2;
    End If;
    Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In;
  
    If 更新年龄_In = 1 Then
      Select Zl_Age_Calc(病人id_In) Into v_年龄 From Dual;
      If v_年龄 Is Not Null Then
        Update 病人信息 Set 年龄 = v_年龄 Where 病人id = 病人id_In;
      End If;
    End If;
    --获取当前机器名称
    If 机器名_In Is Not Null Then
      v_机器名 := 机器名_In;
    Else
      Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid');
    End If;
    n_实收金额合计 := 0;
    Select Count(*) + 1
    Into n_挂号序号
    From 病人挂号记录
    Where 号别 = 号码_In And 登记时间 Between Trunc(发生时间_In) And Trunc(发生时间_In + 1) - 1 / 24 / 60 / 60;
    --Begin
    v_Temp           := Nvl(zl_GetSysParameter('病人同科限挂N个号', 1111), '0|0') || '|';
    n_同科限号数     := To_Number(Substr(v_Temp, 1, Instr(v_Temp, '|') - 1));
    n_同科限约数     := To_Number(Nvl(zl_GetSysParameter('病人同科限约N个号', 1111), '0'));
    n_病人预约科室数 := To_Number(Nvl(zl_GetSysParameter('病人预约科室数', 1111), '0'));
    n_病人挂号科室数 := To_Number(Nvl(zl_GetSysParameter('病人挂号科室限制', 1111), '0'));
    n_专家号挂号限制 := To_Number(Nvl(zl_GetSysParameter('专家号挂号限制'), '0'));
    n_专家号预约限制 := To_Number(Nvl(zl_GetSysParameter('专家号预约限制'), '0'));
  
    --部门ID,部门名称;人员ID,人员编号,人员姓名
    v_Temp := Zl_Identity(0);
    If Nvl(v_Temp, ' ') = ' ' Then
      v_Err_Msg := '当前操作人员未设置对应的人员关系,不能继续。';
      Raise Err_Item;
    End If;
  
    If 登记时间_In Is Null Then
      d_登记时间 := Sysdate;
    Else
      d_登记时间 := 登记时间_In;
    End If;
    If Trunc(Sysdate) > Trunc(发生时间_In) Then
      v_Err_Msg := '不能挂以前的号(' || To_Char(发生时间_In, 'yyyy-mm-dd') || ')。';
      Raise Err_Item;
    End If;
    n_开单部门id := To_Number(Zl_操作员(0, v_Temp));
    v_操作员编号 := Zl_操作员(1, v_Temp);
    v_操作员姓名 := Zl_操作员(2, v_Temp);
    n_组id       := Zl_Get组id(v_操作员姓名);
  
    --支付宝并发提交检查
    Select Nvl(Max(1), 0)
    Into n_Exists
    From 病人挂号记录
    Where 病人id = 病人id_In And 号别 = 号码_In And 号序 = 号序_In And 操作员姓名 = v_操作员姓名 And Nvl(n_出诊记录id, 0) = Nvl(出诊记录id, 0) And
          登记时间 > Sysdate - 0.01 And 记录状态 = 1 And 发生时间 = 发生时间_In;
    If n_Exists = 1 Then
      v_Err_Msg := '病人已经挂号,不能重复挂相同的号！';
      Raise Err_Special;
    End If;
  
    If 操作方式_In <> 1 Then
      --预约检查是否添加合作单位控制
      --如果设置了合作单位控制 则
      Begin
        Select ID
        Into n_计划id
        From 挂号安排计划
        Where 号码 = 号码_In And 发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
              Nvl(失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Rownum < 2
        Order By 生效时间 Desc;
      Exception
        When Others Then
          Select ID Into n_Tmp安排id From 挂号安排 Where 号码 = 号码_In;
      End;
      If Nvl(n_计划id, 0) <> 0 Then
        Select Count(0)
        Into n_合作单位限制
        From 合作单位计划控制
        Where 合作单位 = 合作单位_In And 计划id = n_计划id And Rownum < 2;
      Else
        Select Count(0)
        Into n_合作单位限制
        From 合作单位安排控制
        Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And Rownum < 2;
      End If;
    End If;
  
    If 操作方式_In <> 2 Then
      v_诊室 := Zl_诊室(号码_In);
    End If;
    If 操作方式_In <> 2 And 结算方式_In Is Not Null Then
      --检查结算方式是否完备
      Select Count(*) Into n_Count From 结算方式 Where 名称 = Nvl(结算方式_In, 'Lxh') And 性质 In (2, 7, 8);
      If Nvl(卡类别id_In, 0) <> 0 And n_Count = 0 Then
        Select Count(1)
        Into n_Count
        From 医疗卡类别
        Where ID = Nvl(卡类别id_In, 0) And 结算方式 = Nvl(结算方式_In, 'lxh');
      End If;
      If n_Count = 0 Then
        v_Err_Msg := '结算方式(' || 结算方式_In || ')未设置,请在结算方式管理中设置。';
        Raise Err_Item;
      End If;
    End If;
  
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。
    Select Count(*) Into n_Count From 门诊费用记录 Where 记录性质 = 4 And 记录状态 In (1, 3) And NO = 单据号_In;
    If n_Count <> 0 Then
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。';
      Raise Err_Item;
    End If;
  
    Open c_Pati(病人id_In);
    n_Count := 0;
    Begin
      Fetch c_Pati
        Into r_Pati;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '病人未找到，不能继续。';
      Raise Err_Item;
    End If;
  
    Open c_安排(号码_In, 发生时间_In);
    Begin
      Fetch c_安排
        Into r_安排;
    Exception
      When Others Then
        n_Count := -1;
    End;
    If n_Count = -1 Then
      v_Err_Msg := '该号别没有在' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '中进行安排。';
      Raise Err_Item;
    End If;
  
    Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六',
                   '周日')
    Into v_星期
    From Dual;
    Begin
      If r_安排.计划id Is Null Then
        Select Max(1) Into n_启用分时段 From 挂号安排时段 Where 安排id = r_安排.Id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排
        Where ID = r_安排.Id;
      Else
        Select Max(1)
        Into n_启用分时段
        From 挂号计划时段
        Where 计划id = r_安排.计划id And 星期 = v_星期 And Rownum < 2;
        Select Decode(To_Char(发生时间_In, 'D'), '1', 周日, '2', 周一, '3', 周二, '4', 周三, '5', 周四, '6', 周五, '7', 周六, Null)
        Into v_时间段
        From 挂号安排计划
        Where ID = r_安排.计划id;
      End If;
    Exception
      When Others Then
        n_启用分时段 := 0;
    End;
  
    If v_时间段 Is Not Null And d_启用时间 Is Not Null Then
      --检查是否跨模式挂号安排
      Select To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'),
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(终止时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
      Into d_检查开始时间, d_检查结束时间
      From 时间段
      Where 时间段 = v_时间段 And 站点 Is Null And 号类 Is Null;
      If d_检查开始时间 > d_检查结束时间 Then
        d_检查结束时间 := d_检查结束时间 + 1;
      End If;
      If d_检查结束时间 > d_启用时间 Then
        --获取出诊记录id
        Begin
          Select a.Id
          Into n_出诊记录id
          From 临床出诊记录 A, 临床出诊号源 B
          Where a.号源id = b.Id And b.号码 = 号码_In And 上班时段 = v_时间段 And 发生时间_In Between 开始时间 And 终止时间;
        Exception
          When Others Then
            n_出诊记录id := Null;
        End;
      End If;
    End If;
  
    --对参数控制进行检查
    --仅在预约不扣款时进行检查
    If 操作方式_In = 2 Then
      If Nvl(n_同科限约数, 0) <> 0 Or Nvl(n_病人预约科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人预约科室数, 0) And Nvl(n_病人预约科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能预约[' || Nvl(n_病人预约科室数, 0) || ']个科室,不能再预约！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限约数, 0) And Nvl(n_同科限约数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室预约了' || n_Count || '次,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号预约限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 2 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号预约限制, 0) And Nvl(n_专家号预约限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号预约限制,不能再预约！';
          Raise Err_Item;
        End If;
      End If;
    Else
      If Nvl(n_同科限号数, 0) <> 0 Or Nvl(n_病人挂号科室数, 0) <> 0 Then
        n_已约科室 := 0;
        For c_Chkitem In (Select Distinct 执行部门id
                          From 病人挂号记录
                          Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
                                Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id <> r_安排.科室id) Loop
          n_已约科室 := n_已约科室 + 1;
        End Loop;
        If n_已约科室 >= Nvl(n_病人挂号科室数, 0) And Nvl(n_病人挂号科室数, 0) > 0 Then
          v_Err_Msg := '同一病人最多同时能挂号[' || Nvl(n_病人挂号科室数, 0) || ']个科室,不能再挂号！';
          Raise Err_Item;
        End If;
      
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 发生时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 执行部门id = r_安排.科室id;
        If n_Count >= Nvl(n_同科限号数, 0) And Nvl(n_同科限号数, 0) > 0 Then
          v_Err_Msg := '该病人已经在该科室挂号了' || n_Count || '次,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
      If Nvl(n_专家号挂号限制, 0) <> 0 Then
        Select Count(1)
        Into n_Count
        From 病人挂号记录
        Where 病人id = 病人id_In And 记录状态 = 1 And 记录性质 = 1 And 预约时间 Between Trunc(发生时间_In) And
              Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 号别 = r_安排.号码;
        If n_Count >= Nvl(n_专家号挂号限制, 0) And Nvl(n_专家号挂号限制, 0) > 0 Then
          v_Err_Msg := '该病人已经超过本号挂号限制,不能再挂号！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  
    d_Date         := Null;
    d_时段开始时间 := Null;
  
    If Nvl(r_安排.限号数, 0) >= 0 Or r_安排.限号数 Is Null Then
    
      Select Nvl(Sum(Nvl(b.已挂数, 0)), 0), Nvl(Sum(Nvl(b.其中已接收, 0)), 0), Nvl(Sum(Nvl(b.已约数, 0)), 0)
      Into n_已挂数, n_其中已接收, n_已约数
      From 挂号安排 A, 病人挂号汇总 B
      Where a.科室id = b.科室id And a.项目id = b.项目id And a.号码 = 号码_In And b.日期 Between Trunc(发生时间_In) And
            Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And (a.号码 = b.号码 Or b.号码 Is Null) And Nvl(a.医生id, 0) = Nvl(b.医生id, 0) And
            Nvl(a.医生姓名, '医生') = Nvl(b.医生姓名, '医生');
    
      If n_启用分时段 = 1 Then
        If Nvl(r_安排.序号控制, 0) = 1 Then
          If Nvl(是否自助设备_In, 0) = 0 Then
            If r_安排.计划id Is Null Then
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号安排时段
              Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            Else
              Select Count(*), Max(开始时间)
              Into n_Count, d_时段开始时间
              From 挂号计划时段
              Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0);
            End If;
            v_Temp := '挂号';
            If 操作方式_In > 1 Then
              v_Temp := '预约挂号';
            End If;
          
            If n_Count = 0 Then
              v_Err_Msg := '号别为' || 号码_In || '的挂号安排中不存在序号为' || Nvl(号序_In, 0) || '的安排,不能再' || v_Temp || '！';
              Raise Err_Item;
            End If;
          End If;
          --过点的,不能选择挂号
          If Trunc(Sysdate) = Trunc(发生时间_In) Then
            --挂当天的号
            v_Temp := To_Char(Sysdate, 'yyyy-mm-dd') || ' ';
            If r_安排.计划id Is Null Then
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号安排时段
                           Where 安排id = r_安排.Id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            Else
              For v_时段 In (Select To_Date(v_Temp || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                  To_Date(To_Char(Sysdate + Decode(Sign(开始时间 - 结束时间), 1, 1, 0), 'yyyy-mm-dd') || ' ' ||
                                           To_Char(结束时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 结束时间, 限制数量, 是否预约
                           From 挂号计划时段
                           Where 计划id = r_安排.计划id And 星期 = v_星期 And 序号 = Nvl(号序_In, 0)) Loop
                If Sysdate > v_时段.结束时间 Then
                  v_Err_Msg := '号别为' || 号码_In || '及号序为' || Nvl(号序_In, 0) || '的安排,已经超过时点,不能再' || v_Temp || '！';
                  Raise Err_Item;
                End If;
              End Loop;
            End If;
          End If;
        Elsif 操作方式_In > 1 Then
          --未启用序号的,需要检查预约的情况
          n_Count := 0;
          If r_安排.计划id Is Null Then
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号安排时段
                         Where 安排id = r_安排.Id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          Else
            For v_时段 In (Select 序号, 开始时间, 结束时间, 限制数量, 是否预约
                         From 挂号计划时段
                         Where 计划id = r_安排.计划id And 星期 = v_星期 And
                               (('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-09 ' || To_Char(开始时间, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS')) And
                               '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS')) Or
                               ('3000-01-10 ' || To_Char(发生时间_In, 'HH24:MI:SS') Between
                               '3000-01-10 ' || To_Char(开始时间, 'HH24:MI:SS') And
                               Decode(Sign(开始时间 - 结束时间 - 1 / 24 / 60 / 60), 1,
                                        '3000-01-11 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'),
                                        '3000-01-10 ' || To_Char(结束时间 - 1 / 24 / 60 / 60, 'HH24:MI:SS'))))) Loop
              n_预约时段序号 := v_时段.序号;
              d_时段开始时间 := v_时段.开始时间;
            
              Select Count(*), Max(序号)
              Into n_Count, n_预约总数
              From 挂号序号状态
              Where 号码 = 号码_In And 日期 = 发生时间_In And 状态 Not In (4, 5);
            
              If Nvl(n_Count, 0) > Nvl(v_时段.限制数量, 0) And 锁定类型_In <> 2 Then
                v_Err_Msg := '号别为' || 号码_In || '的挂号安排中在' || To_Char(v_时段.开始时间, 'hh24:mi:ss') || '至' ||
                             To_Char(v_时段.结束时间, 'hh24:mi:ss') || '最多只能预约' || Nvl(v_时段.限制数量, 0) || '人,不能再进行预约挂号！';
                Raise Err_Item;
              End If;
              n_Count := 1;
            End Loop;
          End If;
        
          If n_Count = 0 Then
            v_Err_Msg := '号别为' || 号码_In || '的挂号安排中没有相关的安排计划(' || To_Char(发生时间_In, 'YYYY-mm-dd HH24:MI:SS') ||
                         '),不能进行预约挂号！';
            Raise Err_Item;
          End If;
        End If;
      End If;
    End If;
  
    If 操作方式_In = 1 And 锁定类型_In <> 2 Then
      --挂号规则:
      --  已挂数不能大于限号数
      If n_已挂数 >= Nvl(r_安排.限号数, 0) And r_安排.限号数 Is Not Null Then
        v_Err_Msg := '该号别今天已达到限号数 ' || Nvl(r_安排.限号数, 0) || '不能再挂号！';
        Raise Err_Item;
      End If;
    End If;
  
    If 操作方式_In > 1 Then
      --预约的相关检查
      --规则:
      --   1.已限约不能超过限约数
      --   2.检查是否启用时段的
      If n_已约数 >= Nvl(r_安排.限约数, 0) And Nvl(r_安排.限约数, 0) <> 0 And r_安排.限约数 Is Not Null And 锁定类型_In <> 2 Then
        v_Err_Msg := '该号别已达到限约数 ' || Nvl(r_安排.限约数, 0) || '不能再预约挂号！';
        Raise Err_Item;
      End If;
    End If;
    If n_合作单位限制 > 0 And 操作方式_In <> 1 And 合作单位_In Is Not Null Then
    
      If Nvl(r_安排.序号控制, 0) = 1 And Nvl(号序_In, 0) = 0 Then
        v_Err_Msg := '当前安排使用了序号控制,请确认所需要预约的序号,不能继续。';
        Raise Err_Item;
      End If; --Nvl(r_安排.序号控制, 0) =0
    
      n_序号 := Case
                When Nvl(r_安排.序号控制, 0) = 1 Or n_启用分时段 = 1 And 操作方式_In > 1 Then
                 Nvl(号序_In, 0)
                Else
                 0
              End;
    
      --合作单位限数量模式
      Begin
        If Nvl(n_计划id, 0) <> 0 Then
          Select 0
          Into n_序号
          From 合作单位计划控制
          Where 合作单位 = 合作单位_In And 计划id = n_计划id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        Else
          Select 0
          Into n_序号
          From 合作单位安排控制
          Where 合作单位 = 合作单位_In And 安排id = n_Tmp安排id And
                限制项目 = Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                              '7', '周六', Null) And 数量 <> 0 And 序号 = 0 And Rownum < 2;
        End If;
        n_合作单位限数量模式 := 1;
      Exception
        When Others Then
          n_合作单位限数量模式 := 0;
      End;
      --开放序号检查
      For c_合作单位 In (Select c.序号, 数量
                     From 挂号安排 A, 合作单位安排控制 C
                     Where a.号码 = 号码_In And Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null) = c.限制项目(+) And a.Id = c.安排id And
                           c.合作单位 = 合作单位_In And c.序号 = n_序号 And Not Exists
                      (Select 1
                            From 挂号安排计划 D
                            Where d.安排id = a.Id And d.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(d.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(d.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')))
                     Union All
                     Select c.序号, 数量
                     From 挂号安排计划 A, 挂号安排 D, 合作单位计划控制 C,
                          (Select Max(a.生效时间) As 生效, 安排id
                            From 挂号安排计划 A, 挂号安排 B
                            Where a.安排id = b.Id And a.审核时间 Is Not Null And
                                  发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                                  Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And b.号码 = 号码_In
                            Group By 安排id) E
                     Where a.安排id = d.Id And a.审核时间 Is Not Null And d.号码 = 号码_In And a.安排id = e.安排id And
                           Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) =
                           Nvl(e.生效, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) = c.限制项目(+) And a.Id = c.计划id And c.合作单位 = 合作单位_In And c.序号 = n_序号 And
                           发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And
                           Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd'))) Loop
      
        If Nvl(r_安排.序号控制, 0) = 1 And c_合作单位.序号 = n_序号 And n_合作单位限数量模式 = 0 Then
          n_是否开放 := 1;
          Exit;
        Elsif (Nvl(r_安排.序号控制, 0) = 0 And c_合作单位.序号 = n_序号) Or n_合作单位限数量模式 = 1 Then
          Begin
            Select Nvl(已约数, 0)
            Into n_预约数量
            From 合作单位挂号汇总
            Where 合作单位 = 合作单位_In And 日期 = Trunc(发生时间_In) And 号码 = 号码_In;
          Exception
            When Others Then
              n_预约数量 := 0;
          End;
          If c_合作单位.数量 <= n_预约数量 And Nvl(c_合作单位.数量, 0) > 0 And 锁定类型_In <> 2 Then
            v_Err_Msg := '该号别已达到限约数 ' || Nvl(c_合作单位.数量, 0) || '不能再预约挂号！';
            Raise Err_Item;
          End If;
          n_是否开放 := 1;
          Exit;
        End If;
      
      End Loop;
    
      If Nvl(n_是否开放, 0) = 0 Then
        v_Err_Msg := '当前序号(' || Nvl(号序_In, 0) || '未开放,不能继续。';
        Raise Err_Item;
      End If;
    End If;
  
    --检查限号数和限约数
    n_行号         := 1;
    n_原项目id     := 0;
    n_原收入项目id := 0;
    n_实收金额合计 := 0;
    If 锁定类型_In <> 1 Then
      If 操作方式_In <> 2 Then
        If Nvl(结帐id_In, 0) = 0 Then
          --这里应该程序传入
          Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
        Else
          n_结帐id := 结帐id_In;
        End If;
      Else
        n_结帐id := Null;
      End If;
    End If;
  
    If Nvl(购买病历_In, 0) = 1 Then
      Begin
        Select 收费细目id Into n_病历费id From 收费特定项目 Where 特定项目 = '病历费';
        v_收费项目ids := r_安排.项目id || ',' || n_病历费id;
      Exception
        When Others Then
          v_Err_Msg := '不能确定病历费,挂号失败!';
          Raise Err_Item;
      End;
    Else
      v_收费项目ids := r_安排.项目id;
    End If;
  
    For c_Item In (Select 1 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = r_安排.项目id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 2 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, 1 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, Null As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = n_病历费id And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Union All
                   Select 3 As 性质, a.类别, a.Id As 项目id, a.名称 As 项目名称, a.编码 As 项目编码, a.计算单位, a.屏蔽费别, d.从项数次 As 数次,
                          c.Id As 收入项目id, c.名称 As 收入项目, c.编码 As 收入编码, c.收据费目, b.现价 As 单价, 1 As 从属父号
                   From 收费项目目录 A, 收费价目 B, 收入项目 C, 收费从属项目 D
                   Where b.收费细目id = a.Id And b.收入项目id = c.Id And a.Id = d.从项id And
                         d.主项id In (Select Column_Value From Table(f_Str2list(v_收费项目ids))) And d_发生时间 Between b.执行日期 And
                         Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                   Order By 性质, 项目编码, 收入编码) Loop
      n_价格父号 := Null;
      If n_原项目id = c_Item.项目id Then
        If n_原收入项目id <> c_Item.收入项目id Then
          n_价格父号 := n_行号;
        End If;
        n_原收入项目id := c_Item.收入项目id;
      End If;
      n_原项目id := c_Item.项目id;
      n_应收金额 := Round(c_Item.数次 * c_Item.单价, 5);
      n_实收金额 := n_应收金额;
      If Nvl(c_Item.屏蔽费别, 0) <> 1 And n_屏蔽费别 = 0 Then
        --打折:
        v_Temp     := Zl_Actualmoney(r_Pati.费别, c_Item.项目id, c_Item.收入项目id, n_应收金额);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ':') + 1);
        n_实收金额 := Zl_To_Number(v_Temp);
      End If;
      n_实收金额合计 := Nvl(n_实收金额合计, 0) + n_实收金额;
    
      --锁定单据不产生费用
      If 锁定类型_In <> 1 Then
        --产生病人挂号费用(可能单独是或包括病历费用)
        Select 病人费用记录_Id.Nextval Into n_费用id From Dual;
        --:操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
        Insert Into 门诊费用记录
          (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id,
           收费类别, 计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人,
           操作员编号, 操作员姓名, 发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id)
        Values
          (n_费用id, 4, Decode(操作方式_In, 2, 0, 1), n_行号, n_价格父号, c_Item.从属父号, 单据号_In, 票据号_In, 1, Null, Null,
           Decode(操作方式_In, 2, To_Char(号序_In), v_诊室), r_Pati.病人id, r_Pati.门诊号, r_Pati.付款方式, r_Pati.姓名, r_Pati.性别,
           r_Pati.年龄, r_Pati.费别, r_安排.科室id, c_Item.类别, 号码_In, c_Item.项目id, c_Item.收入项目id, c_Item.收据费目, 1, c_Item.数次,
           c_Item.单价, n_应收金额, n_实收金额, Decode(操作方式_In, 2, Null, n_实收金额), n_结帐id, 0, n_开单部门id, v_操作员姓名,
           Decode(操作方式_In, 2, v_操作员姓名, Null), r_安排.科室id, r_安排.医生姓名, v_操作员编号, v_操作员姓名, 发生时间_In, d_登记时间, Null, 0, Null,
           Null, 摘要_In, 预约方式_In, Decode(操作方式_In, 2, Null, n_组id));
      End If;
      n_行号 := n_行号 + 1;
    
    End Loop;
  
    If Round(Nvl(挂号金额合计_In, 0), 5) <> Round(Nvl(n_实收金额合计, 0), 5) Then
      v_Err_Msg := '本次挂号金额不正确,可能是因为医院调整了价格,请重新获取挂号收费项目的价格,不能继续。';
      Raise Err_Item;
    End If;
  
    If n_启用分时段 = 1 Then
      d_Date := To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(d_时段开始时间, 'hh24:mi:ss'),
                        'yyyy-mm-dd hh24:mi:ss');
    Else
      d_Date := Trunc(发生时间_In);
    End If;
  
    --更新挂号序号状态
    If 锁定类型_In <> 2 Then
      n_号序 := 号序_In;
    End If;
    Begin
      Select 1
      Into n_Count
      From 挂号序号状态
      Where Trunc(日期) = Trunc(发生时间_In) And 号码 = 号码_In And 序号 = n_号序 And 状态 <> 5;
    Exception
      When Others Then
        n_Count := 0;
    End;
    If n_Count = 1 Then
      If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 Then
        n_号序 := Null;
      End If;
      If n_启用分时段 = 1 And Nvl(r_安排.序号控制, 0) = 1 Then
        v_Err_Msg := '当前序号已被使用，请重新选择一个序号！';
        Raise Err_Item;
      End If;
    End If;
    n_Count := 0;
    If n_启用分时段 = 0 And Nvl(r_安排.序号控制, 0) = 1 And n_号序 Is Null And 锁定类型_In <> 2 Then
      If 退号重用_In = 1 Then
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 Not In (4, 5);
      Else
        Select Nvl(Max(序号), 0) + 1
        Into n_号序
        From 挂号序号状态
        Where 日期 = Trunc(发生时间_In) And 号码 = r_安排.号码 And 状态 <> 5;
      End If;
    End If;
    If n_启用分时段 = 1 And 锁定类型_In <> 2 Then
    
      If 操作方式_In > 1 And Nvl(r_安排.序号控制, 0) = 0 Then
        --规则:预约时段序号||预约数
        If Nvl(n_预约总数, 0) = 0 Then
          v_Temp := Nvl(r_安排.限约数, 0);
          v_Temp := LTrim(RTrim(v_Temp));
          v_Temp := LPad(Nvl(n_预约总数, 0) + 1, Length(v_Temp), '0');
          v_Temp := n_预约时段序号 || v_Temp;
          n_号序 := To_Number(v_Temp);
        Else
          n_号序 := n_预约总数 + 1;
        End If;
      End If;
    End If;
  
    If Nvl(r_安排.序号控制, 0) = 1 Or (操作方式_In > 1 And n_启用分时段 = 1) Or 加入序号状态_In = 1 Then
      --锁定序号的处理
      Begin
        Select 操作员姓名, 机器名
        Into v_序号操作员, v_序号机器名
        From 挂号序号状态
        Where 状态 = 5 And 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序;
        n_序号锁定 := 1;
      Exception
        When Others Then
          v_序号操作员 := Null;
          v_序号机器名 := Null;
          n_序号锁定   := 0;
      End;
      If n_序号锁定 = 0 Then
        Update 挂号序号状态
        Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
        Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 操作员姓名 = v_操作员姓名;
        If Sql%RowCount = 0 Then
          Begin
            Insert Into 挂号序号状态
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间)
            Values
              (号码_In, d_Date, n_号序, Decode(操作方式_In, 2, 2, 1), v_操作员姓名, Decode(操作方式_In, 1, 0, 1), Sysdate);
          
            If n_合作单位限制 > 0 And 操作方式_In > 1 And Nvl(n_是否开放, 0) = 1 Then
              Update 合作单位挂号汇总
              Set 已约数 = 已约数 + Decode(操作方式_In, 2, 1, 0), 已接数 = 已接数 + Decode(操作方式_In, 3, 1, 0)
              Where 号码 = 号码_In And 日期 = d_Date And 序号 = n_号序 And 合作单位 = 合作单位_In;
              If Sql%NotFound Then
                Insert Into 合作单位挂号汇总
                  (号码, 日期, 序号, 合作单位, 已约数, 已接数)
                Values
                  (号码_In, d_Date, n_号序, 合作单位_In, Decode(操作方式_In, 1, 0, 1), Decode(操作方式_In, 3, 1, 0));
              End If;
            End If;
          Exception
            When Others Then
              v_Err_Msg := '序号' || n_号序 || '已被使用,请重新选择一个序号.';
              Raise Err_Item;
          End;
        End If;
      Else
        If v_操作员姓名 <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then
          v_Err_Msg := '序号' || n_号序 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.';
          Raise Err_Item;
        Else
          Update 挂号序号状态
          Set 状态 = Decode(操作方式_In, 2, 2, 1), 预约 = Decode(操作方式_In, 1, 0, 1), 登记时间 = Sysdate
          Where 号码 = 号码_In And Trunc(日期) = Trunc(d_Date) And 序号 = n_号序 And 状态 = 5 And 操作员姓名 = v_操作员姓名 And 机器名 = v_机器名;
        End If;
      End If;
    End If;
  
    If n_出诊记录id Is Not Null Then
      Update 临床出诊序号控制
      Set 挂号状态 = Decode(操作方式_In, 2, 2, 1), 操作员姓名 = v_操作员姓名
      Where 记录id = n_出诊记录id And 序号 = n_序号;
      If 操作方式_In = 2 Then
        Update 临床出诊记录 Set 已约数 = 已约数 + 1 Where ID = n_出诊记录id;
      Else
        If 操作方式_In <> 1 Then
          Update 临床出诊记录
          Set 已约数 = 已约数 + 1, 已挂数 = 已挂数 + 1, 其中已接收 = 其中已接收 + 1
          Where ID = n_出诊记录id;
        Else
          Update 临床出诊记录 Set 已挂数 = 已挂数 + 1 Where ID = n_出诊记录id;
        End If;
      End If;
    End If;
  
    --锁定单据不产生任何 费用
    If 操作方式_In <> 2 And 锁定类型_In <> 1 Then
      --挂号,预约挂号已经扣款部分
      n_预交id := 预交id_In;
      If Nvl(n_预交id, 0) = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      End If;
      n_结算合计 := 0;
      If 保险结算_In Is Not Null Then
        --各个保险结算
        v_结算内容 := 保险结算_In || '||';
        n_结算合计 := 0;
        While v_结算内容 Is Not Null Loop
          v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
          v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
          n_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
          If Nvl(n_结算金额, 0) <> 0 Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算序号, 结算性质)
            Values
              (n_预交id, 4, 单据号_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, d_登记时间, v_操作员编号, v_操作员姓名,
               n_结算金额, n_结帐id, n_组id, n_结帐id, 4);
            Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
          End If;
          n_结算合计 := Nvl(n_结算合计, 0) + Nvl(n_结算金额, 0);
          v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
        End Loop;
      End If;
    
      If Nvl(冲预交_In, 0) <> 0 Then
        --处理总预交
        n_结算合计 := n_结算合计 + Nvl(冲预交_In, 0);
        n_预交金额 := 冲预交_In;
        For r_Deposit In c_Deposit(病人id_In) Loop
          n_结算金额 := Case
                      When r_Deposit.金额 - n_预交金额 < 0 Then
                       r_Deposit.金额
                      Else
                       n_预交金额
                    End;
          If r_Deposit.结帐id = 0 Then
            --第一次冲预交(填上结帐ID,金额为0)
            Update 病人预交记录 Set 冲预交 = 0, 结帐id = n_结帐id, 结算性质 = 4 Where ID = r_Deposit.原预交id;
          End If;
          --冲上次剩余额
          Insert Into 病人预交记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名,
             操作员编号, 冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算序号, 结算性质)
            Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行,
                   单位帐号, d_登记时间, v_操作员姓名, v_操作员编号, n_结算金额, n_结帐id, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, n_结帐id, 4
            From 病人预交记录
            Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        
          --更新病人预交余额
          Update 病人余额
          Set 预交余额 = Nvl(预交余额, 0) - n_结算金额
          Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2)
          Returning 预交余额 Into n_返回值;
          If Sql%RowCount = 0 Then
            Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -1 * n_结算金额, 1, 1);
            n_返回值 := -1 * n_结算金额;
          End If;
          If Nvl(n_返回值, 0) = 0 Then
            Delete From 病人余额
            Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
          End If;
        
          --检查是否已经处理完
          If r_Deposit.金额 <= n_结算金额 Then
            n_预交金额 := n_预交金额 - r_Deposit.金额;
          Else
            n_预交金额 := 0;
          End If;
          If n_预交金额 = 0 Then
            Exit;
          End If;
        End Loop;
        If n_预交金额 > 0 Then
          v_Err_Msg := '预交余额不够支付本次支付金额,不能继续操作！';
          Raise Err_Item;
        End If;
      End If;
      --剩余款项,用指定结算方支付
      n_结算金额 := Nvl(n_实收金额合计, 0) - Nvl(n_结算合计, 0);
      If Nvl(n_结算金额, 0) < 0 Then
        v_Err_Msg := '挂号的相关结算金额超出了当前实结金额,不能继续操作！';
        Raise Err_Item;
      End If;
      If Nvl(n_结算金额, 0) <> 0 Or (Nvl(n_结算金额, 0) = 0 And Nvl(冲预交_In, 0) = 0) Then
        If 结算方式_In Is Null Then
          v_Err_Msg := '未传入指定的结算方式,不能继续操作！';
          Raise Err_Item;
        End If;
      
        If Nvl(预交id_In, 0) <> 0 Then
          --传入的预交ID_In主要是为了解决三方交易,如果医保结算站用了该ID,需要用新的ID进行更新,三方交易用转入的ID
          Update 病人预交记录 Set ID = n_预交id Where ID = Nvl(预交id_In, 0);
          n_预交id := Nvl(预交id_In, 0);
        End If;
      
        Insert Into 病人预交记录
          (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 交易流水号, 交易说明, 结算序号, 合作单位, 卡类别id, 卡号,
           结算性质)
        Values
          (n_预交id, 4, 1, 单据号_In, r_Pati.病人id, 结算方式_In, Nvl(n_结算金额, 0), d_登记时间, v_操作员编号, v_操作员姓名, n_结帐id,
           合作单位_In || '缴款', n_组id, 交易流水号_In, 交易说明_In, n_结帐id, 合作单位_In, 卡类别id_In, 支付卡号_In, 4);
      End If;
    
      --更新人员缴款数据
    
      For v_缴款 In (Select 结算方式, Sum(Nvl(a.冲预交, 0)) As 冲预交
                   From 病人预交记录 A
                   Where a.结帐id = n_结帐id And Mod(a.记录性质, 10) <> 1 And Nvl(病人id, 0) = Nvl(病人id_In, 0)
                   Group By 结算方式) Loop
      
        Update 人员缴款余额
        Set 余额 = Nvl(余额, 0) + Nvl(v_缴款.冲预交, 0)
        Where 收款员 = v_操作员姓名 And 性质 = 1 And 结算方式 = v_缴款.结算方式
        Returning 余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 人员缴款余额
            (收款员, 结算方式, 性质, 余额)
          Values
            (v_操作员姓名, v_缴款.结算方式, 1, Nvl(v_缴款.冲预交, 0));
          n_返回值 := Nvl(v_缴款.冲预交, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 人员缴款余额
          Where 收款员 = v_操作员姓名 And 结算方式 = 结算方式_In And 性质 = 1 And Nvl(余额, 0) = 0;
        End If;
      
      End Loop;
    
    End If;
  
    --处理挂号记录
    If 锁定类型_In = 2 Then
      Begin
        Select ID Into n_挂号id From 病人挂号记录 Where　记录状态 = 0 And NO = 单据号_In And 病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    Else
      Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual;
    End If;
  
    Update 病人挂号记录
    Set 记录性质 = Decode(操作方式_In, 2, 2, 1), 记录状态 = Decode(锁定类型_In, 1, 0, 1), 门诊号 = r_Pati.门诊号, 操作员姓名 = v_操作员姓名,
        操作员编号 = v_操作员编号, 预约 = Decode(操作方式_In, 1, 0, 1),
        接收人 = Decode(锁定类型_In, 1, Null, Decode(操作方式_In, 2, Null, v_操作员姓名)),
        接收时间 = Case 锁定类型_In
                  When 1 Then
                   Null
                  Else
                   Case 操作方式_In
                     When 2 Then
                      Null
                     Else
                      d_登记时间
                   End
                End, 交易流水号 = Nvl(交易流水号_In, 交易流水号), 交易说明 = Nvl(交易说明_In, 交易说明), 合作单位 = Nvl(合作单位_In, 合作单位),
        预约操作员 = Decode(操作方式_In, 1, Nvl(预约操作员, Null), Nvl(预约操作员, v_操作员姓名)),
        预约操作员编号 = Decode(操作方式_In, 1, Nvl(预约操作员编号, Null), Nvl(预约操作员编号, v_操作员编号))
    Where ID = n_挂号id;
    If Sql%NotFound Then
      Begin
        Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = r_Pati.付款方式 And Rownum < 2;
      Exception
        When Others Then
          v_付款方式 := Null;
      End;
      Insert Into 病人挂号记录
        (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号,
         操作员姓名, 复诊, 号序, 预约, 接收人, 接收时间, 交易流水号, 交易说明, 合作单位, 医疗付款方式, 预约操作员, 预约操作员编号)
      Values
        (n_挂号id, 单据号_In, Decode(操作方式_In, 2, 2, 1), Decode(锁定类型_In, 1, 0, 1), r_Pati.病人id, r_Pati.门诊号, r_Pati.姓名,
         r_Pati.性别, r_Pati.年龄, 号码_In, 0, v_诊室, Null, r_安排.科室id, r_安排.医生姓名, 0, Null, d_登记时间, 发生时间_In,
         Case When(Nvl(操作方式_In, 0)) = 1 Then Null Else 发生时间_In End, v_操作员编号, v_操作员姓名, 0, n_号序, Decode(操作方式_In, 1, 0, 1),
         Decode(操作方式_In, 2, Null, v_操作员姓名), Decode(操作方式_In, 2, To_Date(Null), d_登记时间), 交易流水号_In, 交易说明_In, 合作单位_In,
         v_付款方式, Decode(操作方式_In, 1, Null, v_操作员姓名), Decode(操作方式_In, 1, Null, v_操作员编号));
    End If;
    --锁定单据不能产生队列
    If 锁定类型_In <> 1 Then
      n_预约生成队列 := 0;
      If 操作方式_In > 1 Then
        n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113));
      End If;
      --挂号和收费的预约都直接进入队列(收费预约缺少接收过程,所以直接和挂号一样直接进入队列)
      If 操作方式_In <> 2 Or n_预约生成队列 = 1 Then
        If Zl_To_Number(zl_GetSysParameter('排队叫号模式', 1113)) <> 0 Then
          --排队叫号模式:-0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站
          If Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)) = 0 Or n_预约生成队列 = 1 Then
            n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0);
            If Nvl(操作方式_In, 0) > 1 And n_分时点显示 = 1 And n_启用分时段 = 1 Then
              n_分时点显示 := 1;
            Else
              n_分时点显示 := Null;
            End If;
            --产生队列
            --.按”执行部门” 的方式生成队列
            v_队列名称 := r_安排.科室id;
            v_排队号码 := Zlgetnextqueue(r_安排.科室id, n_挂号id, 号码_In || '|' || 号序_In);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0);
            --挂号id_In,号码_In,号序_In,缺省日期_In,扩展_In(暂无用)
            d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号码_In, 号序_In, d_Date);
            --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,v_排队标记,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In
            Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, r_安排.科室id, v_排队号码, Null, r_Pati.姓名, r_Pati.病人id, v_诊室, r_安排.医生姓名,
                             d_排队时间, 预约方式_In, n_分时点显示, v_排队序号);
          End If;
        End If;
      End If;
    
      If Nvl(操作方式_In, 0) = 1 Then
        --处理票据使用情况
        If 票据号_In Is Not Null Then
          Select 票据打印内容_Id.Nextval Into n_打印id From Dual;
          --发出票据
          Insert Into 票据打印内容 (ID, 数据性质, NO) Values (n_打印id, 4, 单据号_In);
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Values
            (票据使用明细_Id.Nextval, Decode(收费票据_In, 1, 1, 4), 票据号_In, 1, 1, 领用id_In, n_打印id, d_登记时间, v_操作员姓名);
          --状态改动
          Update 票据领用记录
          Set 当前号码 = 票据号_In, 剩余数量 = Decode(Sign(剩余数量 - 1), -1, 0, 剩余数量 - 1), 使用时间 = Sysdate
          Where ID = Nvl(领用id_In, 0);
        End If;
        --病人本次就诊(以发生时间为准)
        If Nvl(r_Pati.病人id, 0) <> 0 Then
          Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = v_诊室 Where 病人id = r_Pati.病人id;
        End If;
      End If;
    End If;
    --病人挂号汇总
    --解锁单据时不用再对汇总单据进行统计了 在锁定单据时已经进行了汇总
    If 锁定类型_In <> 2 Then
      --操作方式_IN:1-表示挂号,2-表示预约挂号不扣款,3-表示预约挂号,扣款
      --是否为预约接收:0-非预约挂号; 1-预约挂号,2-预约接收;3-收费预约
      n_预约 := Case
                When Nvl(操作方式_In, 0) = 1 Then
                 0
                When Nvl(操作方式_In, 0) = 2 Then
                 1
                When Nvl(操作方式_In, 0) = 3 Then
                 3
                Else
                 0
              End;
      Zl_病人挂号汇总_Update(r_安排.医生姓名, r_安排.医生id, r_安排.项目id, r_安排.科室id, 发生时间_In, n_预约, 号码_In);
    End If;
    --消息推送
    Begin
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;'
        Using 1, n_挂号id;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Err_Special Then
    Raise_Application_Error(-20105, '[ZLSOFT]+' || v_Err_Msg || '+[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_三方机构挂号_Insert;
/

--110000:曾杰,2018-01-18,变更影像检查记录待处理人
Create Or Replace Procedure Zl_影像检查记录_变更待处理人
(
  医嘱id_In   In 影像检查记录.医嘱id%Type,
  待处理人_In In 影像检查记录.待处理人%Type
) Is
Begin
  Update 影像检查记录 Set 待处理人 = 待处理人_In Where 医嘱id = 医嘱id_In;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl_影像检查记录_变更待处理人;
/

--119386:殷瑞,2018-01-18,自动排批时剔除未启用的批次
CREATE OR REPLACE Procedure Zl_输液配药记录_自动排批
(
 病人id_In In number,
 科室id_In In number,
 部门id_In In number,
 执行日期_In in date
) Is
v_批次串 varchar2(500);
n_总量 number(5);
v_配药id  varchar2(500);
v_batch varchar2(20);
v_Fields varchar2(100);
v_Tansid varchar(18);
n_科室id number(18);
v_批次   varchar2(10);
v_Id     varchar2(200);
n_自动排批模式  number(1);
n_打包    number(2);
v_配药类型  Varchar2(20);
v_历史批次  Varchar2(20);
Begin
  n_自动排批模式:=Zl_To_Number(Nvl(zl_GetSysParameter('自动排批时输液单的批次只往后面批次变动', 1345), 0));
  --该科室各个批次对应的容量
  select max(批次) into v_批次 from 配药工作批次 where 配置中心id=部门id_In and 药品类型 is  null and 启用 = 1;
  for R_Batch in (select B.批次 配药批次,A.容量,A.科室id from 科室容量设置 A,配药工作批次 B where A.配置中心ID=B.配置中心ID And A.配药批次=(B.批次 || '#') and b.启用 = 1 and (A.科室id=科室id_In or A.科室ID=0) and A.配置中心id=部门id_In order by A.科室id desc, A.配药批次 asc) loop

    n_科室id:=R_Batch.科室id;

  --该病人按批次排序，执行时间，优先级排序,各个批次现有的容量，优先级在产生输液配药记录的时候写入
    n_总量:=0;
    for r_item in (Select a.Id 配药id, d.单量,A.瓶签号,A.配药批次
    From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
    Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In and G.配置中心ID=a.部门id And
          a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and g.启用 = 1 and G.药品类型 is null And f.溶媒 = 1 And a.执行时间 Between Trunc(执行日期_In ) And
          Trunc(执行日期_In+1) - 1 / 24 / 60 / 60 And A.操作状态<2 and A.配药批次<=decode(n_自动排批模式,1,R_Batch.配药批次,100)
    Order By a.配药批次,to_number(a.优先级), a.执行时间, d.单量 desc) loop

      if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1 then
        --当该配药id首次循环的时候对其单量进行累计
        v_配药id:=v_配药id || r_item.配药id || ',';
        n_总量:=n_总量+r_item.单量;
        v_批次串:=v_批次串 || r_item.配药id || ',' || R_Batch.配药批次 || '|';
      elsif instr('|'|| v_批次串,'|'|| r_item.配药id || ',' || R_Batch.配药批次 || '|',1)>0 and n_总量<>0 then
        --当该配药id及批次出现过，则累计该单量
        n_总量:=n_总量+r_item.单量;
      end if;

      if n_总量>=R_Batch.容量 then
        exit;
      end if;

    end loop;
  end loop;

  --如果该科室设置了单独的容量信息则不考虑所有科室的模式
  for r_item in (Select a.Id 配药id, d.单量,A.瓶签号
  From 输液配药记录 A, 病人医嘱记录 B, 输液配药内容 C, 药品收发记录 D, 药品规格 E, 药品特性 F,配药工作批次 G
  Where a.Id = c.记录id And c.收发id = d.Id And d.药品id = e.药品id And e.药名id = f.药名id And a.部门id = 部门id_In  And
        a.医嘱id = b.Id And b.病人id = 病人id_In And A.配药批次=G.批次 And G.批次<>0 and g.启用 = 1 and G.配置中心ID=a.部门id and G.药品类型 is null And f.溶媒 = 1  
        And A.操作状态<2 And a.执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In+1) - 1 / 24 / 60 / 60
  Order By a.配药批次,to_number(a.优先级),a.执行时间, d.单量) loop
    if instr(','|| v_配药id,','|| r_item.配药id || ',',1)<1then
      --没有进行自动分批的输液单直接在最后一个批次
      v_配药id:=v_配药id || r_item.配药id || ',';
      v_批次串:=v_批次串 || r_item.配药id || ',' || v_批次 || '|';
    end if;
  end loop;


  --根据自动调批修正数据
  while v_批次串 is not null loop
    --分解单据ID串
    v_Fields := Substr(v_批次串, 1, Instr(v_批次串, '|') - 1);
    v_Tansid := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    v_batch   := Substr(v_Fields, Instr(v_Fields, ',') + 1);


    v_批次串 := Replace('|' || v_批次串, '|' || v_Fields || '|');

    Select Nvl(max(打包), 0),max(药品类型) Into n_打包,v_配药类型 From 配药工作批次 Where 批次 = v_batch And 配置中心id=部门id_In;

    Select 配药批次 Into v_历史批次 From 输液配药记录 Where id=v_Tansid;
    update 输液配药记录 set 配药批次=v_batch,是否确认调整=0 where id=v_Tansid;

    Update 输液配药记录 Set 是否确认调整 = 0
    Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = 病人id_In)
    And 执行时间 Between Trunc(执行日期_In) And Trunc(执行日期_In + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;

    If n_打包<>0 And v_配药类型 is Null Then
      update 输液配药记录 Set 是否打包=n_打包 where id=v_Tansid;
    Else
      Select Nvl(max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_历史批次 And 配置中心id=部门id_In;
      If n_打包<>0 Then
        Update 输液配药记录 Set 是否打包=0 where id=v_Tansid And trunc(执行时间)>trunc(Sysdate) ;
      End If;
    End If;
  end loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_自动排批;
/

--119864:秦龙,2018-01-16,实际数量不足提示
Create Or Replace Procedure Zl_材料移库_Verify
(
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type,
  出批次_In     In 药品收发记录.批次%Type,
  填写数量_In   In 药品收发记录.填写数量%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  出类别id_In   In 药品收发记录.入出类别id%Type,
  入类别id_In   In 药品收发记录.入出类别id%Type,
  No_In         In 药品收发记录.No%Type,
  审核人_In     In 药品收发记录.审核人%Type,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  审核日期_In   In 药品收发记录.审核日期%Type := Null,
  移库单_In     In Number := 1,
  零售价_In     In 药品收发记录.零售价%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg    Varchar2(500);
  v_编码       收费项目目录.编码%Type;
  v_负成本计算 Zlparameters.参数值%Type;
  v_批准文号   药品库存.批准文号%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  n_入批次       药品收发记录.批次%Type := Null;
  n_实际库存金额 药品库存.实际金额%Type;
  n_实际库存差价 药品库存.实际差价%Type;
  n_出库差价     药品库存.实际差价%Type;
  n_成本价       药品收发记录.成本价%Type;
  n_成本金额     药品收发记录.成本金额%Type;
  n_实际数量     药品库存.实际数量%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次生产日期 药品库存.上次生产日期%Type;
  n_零售价       药品收发记录.零售价%Type;
  n_小数         Number;
  v_上次扣率     药品库存.上次扣率%Type;
  v_商品条码     药品库存.商品条码%Type;
  v_内部条码     药品库存.内部条码%Type;
  n_平均成本价   药品库存.平均成本价%Type;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into n_小数 From 药品卫材精度 Where 类别 = 2 And 内容 = 4 And 单位 = 5;
  Select zl_GetSysParameter(120) Into v_负成本计算 From Dual;

  --由于移库处理允许在审核时改变实际数量，
  --所以首先对实际数量和其他相应的字段进行更新。
  Begin
    Select Nvl(实际金额, 0), Nvl(实际差价, 0), Nvl(实际数量, 0), Nvl(上次扣率, 100), 商品条码, 内部条码
    Into n_实际库存金额, n_实际库存差价, n_实际数量, v_上次扣率, v_商品条码, v_内部条码
    From 药品库存
    Where 药品id = 材料id_In And Nvl(批次, 0) = 出批次_In And 库房id = 库房id_In And 性质 = 1 And Rownum = 1;
  Exception
    When Others Then
      n_实际库存金额 := 0;
      n_实际数量     := 0;
      v_上次扣率     := 100;
      v_商品条码     := Null;
      v_内部条码     := Null;
  End;
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = 材料id_In;

  If 成本价_In Is Null Then
    --成本价为空
    n_成本价   := Round(Zl_Fun_Getoutcost(材料id_In, 出批次_In, 库房id_In), 7);
    n_成本金额 := Round(n_成本价 * 实际数量_In, n_小数);
    n_出库差价 := Round(零售金额_In - n_成本金额, n_小数);
  Else
    n_成本价   := 成本价_In;
    n_成本金额 := 成本金额_In;
    n_出库差价 := 差价_In;
  End If;

  Update 药品收发记录
  Set 审核人 = Nvl(审核人_In, 审核人), 审核日期 = 审核日期_In, 实际数量 = 实际数量_In, 成本价 = n_成本价, 成本金额 = n_成本金额, 零售价 = 零售价_In, 零售金额 = 零售金额_In,
      差价 = n_出库差价, 扣率 = v_上次扣率, 商品条码 = v_商品条码, 内部条码 = v_内部条码
  Where NO = No_In And 单据 = 19 And 药品id = 材料id_In And 记录状态 = 1 And 序号 In (序号_In, 序号_In + 1) And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  If 出批次_In > 0 Then
    If n_实际数量 < 实际数量_In Then
      Select 编码 Into v_编码 From 收费项目目录 Where ID = 材料id_In;
      v_Err_Msg := '[ZLSOFT]编码为' || v_编码 || ',批号为' || 批号_In || '的库房分批材料' || Chr(10) || Chr(13) || '实际库存数量不够！[ZLSOFT]';
      Raise Err_Item;
    End If;
  End If;

  --取入类别的批次和上次供应商
  Select 批次, 供药单位id, 生产日期, 批准文号, 零售价
  Into n_入批次, n_上次供应商id, n_上次生产日期, v_批准文号, n_零售价
  From 药品收发记录
  Where NO = No_In And 单据 = 19 And 记录状态 = 1 And 序号 = 序号_In + 1;

  --更改入类别的材料库存的相应数据

  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) + 实际数量_In, 实际数量 = Nvl(实际数量, 0) + 实际数量_In, 实际金额 = Nvl(实际金额, 0) + 零售金额_In,
      实际差价 = Nvl(实际差价, 0) + n_出库差价, 上次采购价 = Decode(上次采购价, Null, n_成本价, 0, n_成本价, 上次采购价), 上次批号 = Nvl(批号_In, 上次批号),
      上次产地 = Nvl(产地_In, 上次产地), 灭菌效期 = Nvl(灭菌效期_In, 灭菌效期), 商品条码 = v_商品条码, 内部条码 = v_内部条码
  Where 库房id = 对方部门id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次采购价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次生产日期, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (对方部门id_In, 材料id_In, n_入批次, 1, 实际数量_In, 实际数量_In, 零售金额_In, n_出库差价, n_成本价, 批号_In, 产地_In, 效期_In, 灭菌效期_In, n_上次供应商id,
       n_上次生产日期, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(n_入批次, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  Delete From 药品库存
  Where 库房id = 对方部门id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --重新计算平均成本价
  Update 药品库存
  Set 平均成本价 = Decode(Nvl(批次, 0),
                      0,
                      Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量),
                      上次采购价)
  Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 库房id = 对方部门id_In And Nvl(实际数量, 0) <> 0 And 性质 = 1;
  If Sql%NotFound Then
    Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = 材料id_In;
    Update 药品库存
    Set 平均成本价 = n_平均成本价
    Where 药品id = 材料id_In And 库房id = 对方部门id_In And Nvl(批次, 0) = Nvl(n_入批次, 0) And 性质 = 1;
  End If;

  --更改出类别的材料库存的相应数据

  Update 药品库存
  Set 实际数量 = Nvl(实际数量, 0) - 实际数量_In, 实际金额 = Nvl(实际金额, 0) - 零售金额_In, 实际差价 = Nvl(实际差价, 0) - n_出库差价
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(出批次_In, 0) And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 零售价, 上次扣率, 商品条码,
       内部条码, 平均成本价)
    Values
      (库房id_In, 材料id_In, 出批次_In, 1, 0, -实际数量_In, -零售金额_In, -n_出库差价, 批号_In, 产地_In, 效期_In, 灭菌效期_In, n_上次供应商id, n_成本价,
       n_上次生产日期, v_批准文号, Decode(n_实价卫材, 1, Decode(Nvl(出批次_In, 0), 0, Null, n_零售价), Null), v_上次扣率, v_商品条码, v_内部条码, n_成本价);
  End If;

  --出库房，平均成本价为空时需要重新计算库存表中的平均成本价
  Update 药品库存
  Set 平均成本价 = Decode(Nvl(批次, 0),
                      0,
                      Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量),
                      上次采购价)
  Where 药品id = 材料id_In And Nvl(批次, 0) = Nvl(出批次_In, 0) And 库房id = 库房id_In And Nvl(实际数量, 0) <> 0 And 性质 = 1 And
        Nvl(平均成本价, 0) = 0;

  Delete From 药品库存
  Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料移库_Verify;
/

--119856:胡俊勇,2018-01-15,回退自动执行的跟踪在用卫材医嘱
Create Or Replace Procedure Zl_材料收发记录_部门退料
(
  收发id_In   In 药品收发记录.Id%Type,
  审核人_In   In 药品收发记录.审核人%Type,
  审核日期_In In 药品收发记录.审核日期%Type,
  批号_In     In 药品库存.上次批号%Type := Null,
  效期_In     In 药品库存.效期%Type := Null,
  产地_In     In 药品库存.上次产地%Type := Null,
  退料数量_In In 药品收发记录.实际数量%Type := Null,
  自动销帐_In In Integer := 0,
  退料人_In   In 药品收发记录.领用人%Type := Null,
  是否销帐_In In Integer := 1
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);
  v_No      药品收发记录.No%Type;

  n_记录状态   药品收发记录.记录状态%Type;
  n_执行状态   住院费用记录.执行状态%Type;
  n_部分退料   Number;
  n_入出类别id Number(18);
  n_单据       药品收发记录.单据%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_药品id     药品收发记录.药品id%Type;
  n_实际数量   药品收发记录.实际数量%Type;
  n_实际金额   药品收发记录.零售金额%Type;
  n_实际成本   药品收发记录.成本金额%Type;
  n_实际差价   药品收发记录.差价%Type;
  n_费用id     药品收发记录.费用id%Type;
  n_零售价     药品收发记录.零售价%Type;
  n_实价卫材   收费项目目录.是否变价%Type;

  --处理退料时，分批核算性质改变后的处理
  n_新批次       药品收发记录.批次%Type;
  n_批次         药品收发记录.批次%Type;
  n_分批         材料特性.在用分批%Type;
  n_小数         Number(2);
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_成本价       药品收发记录.成本价%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  d_灭菌效期     药品库存.灭菌效期%Type;
  v_批准文号     药品库存.批准文号%Type;
  v_产地         药品收发记录.产地%Type;
  v_费用no       住院费用记录.No%Type;
  v_Temp         Varchar2(255);
  v_人员编号     人员表.编号%Type;
  v_人员姓名     人员表.姓名%Type;
  n_主页id       住院费用记录.主页id%Type;
  n_序号         住院费用记录.序号%Type;

  v_备货id     药品收发记录.Id%Type;
  v_入库no     药品收发记录.No%Type;
  v_入库序号   Number(5) := 0;
  n_冲销记录id 药品收发记录.Id%Type;
  n_移库       Number(1) := 0;
  v_商品条码   药品库存.商品条码%Type;
  v_内部条码   药品库存.内部条码%Type;
  v_批号       药品库存.上次批号%Type;
  d_效期       药品库存.效期%Type;
Begin
  v_Temp     := Zl_Identity;
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
  v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
  v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);

  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_小数 From Dual;

  If 退料数量_In Is Not Null Then
    If 退料数量_In = 0 Then
      Return;
    End If;
  End If;

  --1、判断当前数据是否是备货卫材
  Begin
    Select 汇总发药号
    Into v_备货id
    From 药品收发记录
    Where 单据 = 21 And 审核日期 Is Not Null And
          汇总发药号 = (Select Max(a.Id)
                   From 药品收发记录 A, 药品收发记录 B
                   Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And a.审核人 Is Not Null And b.Id = 收发id_In And
                         (Mod(a.记录状态, 3) = 1 Or a.记录状态 = 1)) And Rownum = 1;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  Begin
    If v_备货id = 0 Then
      Select 汇总发药号
      Into v_备货id
      From 药品收发记录
      Where 单据 = 21 And 审核日期 Is Not Null And
            汇总发药号 = (Select Max(a.Id)
                     From 药品收发记录 A, 药品收发记录 B
                     Where a.单据 = b.单据 And a.No = b.No And a.序号 = b.序号 And a.审核人 Is Not Null And b.Id = 收发id_In And
                           (Mod(a.记录状态, 3) = 0)) And Rownum = 1;
    End If;
  Exception
    When Others Then
      v_备货id := 0;
  End;

  --获取该收发记录的单据、药品ID、库房ID
  Select 单据, NO, 库房id, 药品id, 费用id, 入出类别id, 记录状态, Nvl(批次, 0), 生产日期, 灭菌效期, 批准文号, 供药单位id, 成本价, 产地, 零售价, 商品条码, 内部条码, 效期, 批号
  Into n_单据, v_No, n_库房id, n_药品id, n_费用id, n_入出类别id, n_记录状态, n_批次, d_上次生产日期, d_灭菌效期, v_批准文号, n_上次供应商id, n_成本价, v_产地,
       n_零售价, v_商品条码, v_内部条码, d_效期, v_批号
  From 药品收发记录
  Where ID = 收发id_In;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into n_实际数量, n_实际金额, n_实际成本, n_实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = v_No And 单据 = n_单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = 收发id_In);

  --如果允许退药数为零，表示已退药
  If n_实际数量 = 0 Then
    v_Err_Msg := '该单据已被其他操作员退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  If Nvl(退料数量_In, 0) > n_实际数量 Then
    v_Err_Msg := '该单据已被其他操作员部分退料，请刷新后再试！';
    Raise Err_Item;
  End If;

  --获取该材料当前是否分批的信息
  Select Nvl(在用分批, 0) Into n_分批 From 材料特性 Where 材料id = n_药品id;

  --如果是部分退料，则重新计算零售金额及差价
  n_部分退料 := 0;
  If Not (退料数量_In Is Null Or Nvl(退料数量_In, 0) = n_实际数量) Then
    n_部分退料 := 1;
  End If;

  If n_部分退料 = 1 Then
    n_实际金额 := Round(n_实际金额 * 退料数量_In / n_实际数量, n_小数);
    n_实际成本 := Round(n_实际成本 * 退料数量_In / n_实际数量, n_小数);
    n_实际差价 := Round(n_实际差价 * 退料数量_In / n_实际数量, n_小数);
    n_实际数量 := 退料数量_In;
  End If;

  --n_分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If n_分批 = 0 And n_批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    n_分批 := 2;
  Elsif n_分批 <> 0 And n_批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    n_分批 := 3;
  Else
    If n_批次 = 0 Then
      n_分批 := 0;
    Else
      n_分批 := 1;
    End If;
  End If;

  If 产地_In Is Not Null Then
    v_产地 := 产地_In;
  End If;

  If 批号_In Is Not Null Then
    v_批号 := 批号_In;
  End If;
  If 效期_In Is Not Null Then
    d_效期 := 效期_In;
  End If;

  --记录状态的含义有所变化
  --冲销的记录状态        :iif(n_记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(n_记录状态=1,0,1)+2
  --等待发料的记录状态    :iif(n_记录状态=1,0,1)+3
  Select 药品收发记录_Id.Nextval Into n_冲销记录id From Dual;
  --产生冲销记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 领用人, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_冲销记录id, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 1, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号,
           效期, 灭菌效期, 1, -n_实际数量, -n_实际数量, 成本价, -n_实际成本, 扣率, 零售价, -n_实际金额, -n_实际差价, 摘要, 审核人_In, 审核日期_In, 配药人, 审核人_In,
           审核日期_In, 费用id, 单量, 频次, 用法, 发药窗口, 退料人_In, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发料
  Select 药品收发记录_Id.Nextval Into n_新批次 From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 灭菌效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
    Select n_新批次, n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 3, n_单据, v_No, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(n_分批, 1, 批次, 3, n_新批次, Null), Decode(n_分批, 3, 产地_In, 1, 产地, Null), Decode(n_分批, 3, v_批号, 1, 批号, Null),
           Decode(n_分批, 3, d_效期, 1, 效期, Null), 灭菌效期, 1, n_实际数量, n_实际数量, 成本价, n_实际成本, 扣率, 零售价, n_实际金额, n_实际差价, 摘要, 填制人,
           填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码
    From 药品收发记录
    Where ID = 收发id_In;

  --更新病人费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into n_执行状态
  From 药品收发记录
  Where 单据 = n_单据 And NO = v_No And 费用id = n_费用id And 审核人 Is Not Null;

  If n_执行状态 = 0 Then
    Update 住院费用记录 Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态, 执行人 = Null, 执行时间 = Null
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  Else
    Update 住院费用记录 Set 执行状态 = n_执行状态 Where ID = n_费用id;
    Update 门诊费用记录
    Set 执行状态 = n_执行状态
    Where NO = v_No And
          序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = 收发id_In)) And
          (Mod(记录性质, 10) = 1 Or Mod(记录性质, 10) = 2) And 记录状态 <> 2 And 执行部门id = n_库房id;
  End If;

  --插入未发药品记录
  Begin
    Insert Into 未发药品记录
      (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
      Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
      From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费, b.对方部门id,
                    b.库房id, b.发药窗口, b.填制日期, c.身份
             From 住院费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)
             Union All
             Select b.单据, b.No, a.病人id, Null As 主页id, a.姓名, Decode(a.记录性质, 1, Decode(a.操作员姓名, Null, 0, 1), 1) 已收费,
                    b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
             From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
             Where b.Id = 收发id_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
      Where b.名称(+) = a.身份;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = n_记录状态 + Decode(n_记录状态, 1, 0, 1) + 2 Where ID = 收发id_In;

  --修改药品库存(反冲库存)
  Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = n_药品id;

  If n_分批 <> 3 Then
  
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_实际金额, 实际差价 = Nvl(实际差价, 0) + n_实际差价,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, n_零售价, 零售价)), Null)
    Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(批次, 0) = n_批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码,
         内部条码)
      Values
        (n_库房id, n_药品id, Decode(n_分批, 2, Null, n_批次), 1, n_实际数量, n_实际金额, n_实际差价, Decode(n_分批, 1, d_效期, Null), d_灭菌效期,
         n_上次供应商id, n_成本价, Decode(n_分批, 1, v_批号, Null), d_上次生产日期, v_产地, v_批准文号,
         Decode(n_实价卫材, 1, Decode(Nvl(n_批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
    End If;
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价, 平均成本价, 商品条码, 内部条码)
    Values
      (n_库房id, n_药品id, n_新批次, 1, n_实际数量, n_实际金额, n_实际差价, d_效期, d_灭菌效期, n_上次供应商id, n_成本价, v_批号, d_上次生产日期, v_产地, v_批准文号,
       Decode(n_实价卫材, 1, Decode(Nvl(n_新批次, 0), 0, Null, n_零售价), Null), n_成本价, v_商品条码, v_内部条码);
  End If;

  Delete 药品库存
  Where 库房id + 0 = n_库房id And 药品id = n_药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  If (自动销帐_In = 1 And n_单据 <> 24) Or (v_备货id > 1 And n_单据 <> 24 And Not (退料数量_In Is Null) And 是否销帐_In = 1) Then
    Begin
      Select 主页id, NO, 序号 Into n_主页id, v_费用no, n_序号 From 住院费用记录 Where ID = n_费用id;
    Exception
      When Others Then
        Begin
          Select Null, NO, 序号 Into n_主页id, v_费用no, n_序号 From 门诊费用记录 Where ID = n_费用id;
        Exception
          When Others Then
            n_主页id := Null;
        End;
    End;
    If n_主页id Is Null Then
      Zl_门诊记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    Else
      Zl_住院记帐记录_Delete(v_费用no, n_序号, v_人员编号, v_人员姓名);
    End If;
  End If;

  If Not (退料数量_In Is Null) Then
    --备货卫材处理
    If v_备货id > 0 Then
      --2、自动冲销已审核的其他出库单据
      Begin
        Select 1
        Into n_移库
        From 药品收发记录
        Where 单据 = 15 And 审核日期 Is Null And
              费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
      Exception
        When Others Then
          n_移库 := 0;
      End;
    
      If n_移库 <> 0 Then
        For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                       From 药品收发记录
                       Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
          Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In);
        End Loop;
      
        --3、删除未审核的外购入库单据（已审核则不管）
        If n_部分退料 = 1 Then
          Update 药品收发记录
          Set 填写数量 = 填写数量 - 退料数量_In, 实际数量 = 实际数量 - 退料数量_In, 零售金额 = 零售金额 - n_实际金额, 成本金额 = 成本金额 - n_实际成本, 差价 = 差价 - n_实际差价
          Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
        Else
          Delete 药品收发记录
          Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
        End If;
      End If;
    End If;
  Else
    --备货卫材处理
    If v_备货id > 0 Then
      --2、自动冲销已审核的其他出库单据
      Begin
        Select 1
        Into n_移库
        From 药品收发记录
        Where 单据 = 15 And 审核日期 Is Null And
              费用id In (Select Distinct 费用id From 药品收发记录 Where NO = v_No And 药品id = n_药品id And 批次 = n_批次);
      Exception
        When Others Then
          n_移库 := 0;
      End;
    
      If n_移库 <> 0 Then
        For v_出库冲销 In (Select 1 行次, 记录状态, NO, 序号, 药品id
                       From 药品收发记录
                       Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
          Zl_材料其他出库_Strike(v_出库冲销.行次, v_出库冲销.记录状态, v_出库冲销.No, v_出库冲销.序号, v_出库冲销.药品id, 退料数量_In, 审核人_In, 审核日期_In, 1);
        End Loop;
      
        --3、产生新的其他出库单据
        If v_入库no Is Null Then
          v_入库no := Nextno(74, n_库房id);
        End If;
        v_入库序号 := v_入库序号 + 1;
      
        For v_入库 In (Select 入出类别id, 库房id, 药品id, 批次, 填写数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 产地, 批号, 效期, 灭菌效期, 摘要, 单量, 发药窗口
                     From 药品收发记录
                     Where 单据 = 21 And 审核日期 Is Not Null And 汇总发药号 = v_备货id) Loop
        
          Zl_材料其他出库_Insert(v_入库.入出类别id, v_入库no, v_入库序号, v_入库.库房id, v_入库.药品id, v_入库.批次, v_入库.填写数量, v_入库.成本价, v_入库.成本金额,
                           v_入库.零售价, v_入库.零售金额, v_入库.差价, 审核人_In, 审核日期_In, v_入库.产地, v_入库.批号, v_入库.效期, v_入库.灭菌效期, v_入库.摘要,
                           v_入库.单量, v_入库.发药窗口);
        
          Update 药品收发记录
          Set 费用id = n_费用id, 汇总发药号 = n_新批次
          Where 单据 = 21 And NO = v_入库no And 序号 = v_入库序号;
        End Loop;
      
        --4、删除未审核的外购入库单据（已审核则不管）
        Delete 药品收发记录
        Where 单据 = 15 And 药品id = n_药品id And Nvl(批次, 0) = n_批次 And 费用id = n_费用id And 审核日期 Is Null;
      End If;
    End If;
  End If;
  --处理调价修正单据
  Zl_材料收发记录_调价修正(n_冲销记录id);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_部门退料;
/

--120058:刘兴洪,2018-01-15,序号判断 错误
CREATE OR REPLACE Procedure Zl_病人挂号记录_Insert
( 
  病人id_In       门诊费用记录.病人id%Type, 
  门诊号_In       门诊费用记录.标识号%Type, 
  姓名_In         门诊费用记录.姓名%Type, 
  性别_In         门诊费用记录.性别%Type, 
  年龄_In         门诊费用记录.年龄%Type, 
  付款方式_In     门诊费用记录.付款方式%Type, --用于存放病人的医疗付款方式编号 
  费别_In         门诊费用记录.费别%Type, 
  单据号_In       门诊费用记录.No%Type, 
  票据号_In       门诊费用记录.实际票号%Type, 
  序号_In         门诊费用记录.序号%Type, 
  价格父号_In     门诊费用记录.价格父号%Type, 
  从属父号_In     门诊费用记录.从属父号%Type, 
  收费类别_In     门诊费用记录.收费类别%Type, 
  收费细目id_In   门诊费用记录.收费细目id%Type, 
  数次_In         门诊费用记录.数次%Type, 
  标准单价_In     门诊费用记录.标准单价%Type, 
  收入项目id_In   门诊费用记录.收入项目id%Type, 
  收据费目_In     门诊费用记录.收据费目%Type, 
  结算方式_In     病人预交记录.结算方式%Type, --现金的结算名称 
  应收金额_In     门诊费用记录.应收金额%Type, 
  实收金额_In     门诊费用记录.实收金额%Type, 
  病人科室id_In   门诊费用记录.病人科室id%Type, 
  开单部门id_In   门诊费用记录.开单部门id%Type, 
  执行部门id_In   门诊费用记录.执行部门id%Type, 
  操作员编号_In   门诊费用记录.操作员编号%Type, 
  操作员姓名_In   门诊费用记录.操作员姓名%Type, 
  发生时间_In     门诊费用记录.发生时间%Type, 
  登记时间_In     门诊费用记录.登记时间%Type, 
  医生姓名_In     挂号安排.医生姓名%Type, 
  医生id_In       挂号安排.医生id%Type, 
  病历费_In       Number, --该条记录是否病历工本费 
  急诊_In         Number, 
  号别_In         挂号安排.号码%Type, 
  诊室_In         门诊费用记录.发药窗口%Type, 
  结帐id_In       门诊费用记录.结帐id%Type, 
  领用id_In       票据使用明细.领用id%Type, 
  预交支付_In     病人预交记录.冲预交%Type, --刷卡挂号时使用的预交金额,序号为1传入. 
  现金支付_In     病人预交记录.冲预交%Type, --挂号时现金支付部份金额,序号为1传入. 
  个帐支付_In     病人预交记录.冲预交%Type, --挂号时个人帐户支付金额,,序号为1传入. 
  保险大类id_In   门诊费用记录.保险大类id%Type, 
  保险项目否_In   门诊费用记录.保险项目否%Type, 
  统筹金额_In     门诊费用记录.统筹金额%Type, 
  摘要_In         门诊费用记录.摘要%Type, --预约挂号摘要信息 
  预约挂号_In     Number := 0, --预约挂号时用(记录状态=0,发生时间为预约时间),此时不需要传入结算相关参数 
  收费票据_In     Number := 0, --挂号是否使用收费票据 
  保险编码_In     门诊费用记录.保险编码%Type, 
  复诊_In         病人挂号记录.复诊%Type := 0, 
  号序_In         挂号序号状态.序号%Type := Null, --预约时填入费用记录的发药窗口字段,挂号时填入挂号记录 
  社区_In         病人挂号记录.社区%Type := Null, 
  预约接收_In     Number := 0, 
  预约方式_In     预约方式.名称%Type := Null, 
  生成队列_In     Number := 0, 
  卡类别id_In     病人预交记录.卡类别id%Type := Null, 
  结算卡序号_In   病人预交记录.结算卡序号%Type := Null, 
  卡号_In         病人预交记录.卡号%Type := Null, 
  交易流水号_In   病人预交记录.交易流水号%Type := Null, 
  交易说明_In     病人预交记录.交易说明%Type := Null, 
  合作单位_In     病人预交记录.合作单位%Type := Null, 
  操作类型_In     Number := 0, 
  险类_In         病人挂号记录.险类%Type := Null, 
  结算模式_In     Number := 0, 
  记帐费用_In     Number := 0, 
  退号重用_In     Number := 1, 
  修正病人费别_In Number := 0, 
  更新交款余额_In Number := 0, --是否更新人员交款余额，主要是处理统一操作员登录多台自助机的情况 
  修正病人年龄_In Number := 0, 
  收费单_In       病人挂号记录.收费单%Type := Null 
) As 
  --------------------------------------------------------------------------- 
  -- 
  --参数: 
  --     操作类型_in:0-正常挂号或者预约 1-操作员拥有加号权限加号 
  --     修正病人费别_In:0-不修改病人费别 1-修改病人费别 
  ---------------------------------------------------------------------------- 
  --该游标用于收费冲预交的可用预交列表 
  --以ID排序，优先冲上次未冲完的。 
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is 
    Select NO, Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) As 金额, Min(记录状态) As 记录状态, Nvl(Max(结帐id), 0) As 结帐id, 
           Max(Decode(记录性质, 1, ID, 0) * Decode(记录状态, 2, 0, 1)) As 原预交id 
    From 病人预交记录 
    Where 记录性质 In (1, 11) And 病人id = v_病人id And Nvl(预交类别, 2) = 1 Having Sum(Nvl(金额, 0) - Nvl(冲预交, 0)) <> 0 
    Group By NO 
    Order By 结帐id, NO; 
  --功能：新增一行病人挂号费用，并将结算汇总到病人预交记录 
  --       同时汇总相关的汇总表(病人挂号汇总、费用汇总) 
  --       第一行费用处理票据使用情况(领用ID_IN>0) 
 
  v_Err_Msg Varchar2(255); 
  Err_Item Exception; 
 
  v_排队号码 排队叫号队列.排队号码%Type; 
  v_现金     结算方式.名称%Type; 
  v_个人帐户 结算方式.名称%Type; 
  v_队列名称 排队叫号队列.队列名称%Type; 
 
  n_分时段       Number; 
  n_时段限号     Number; 
  n_时段限约     Number; 
  d_时段时间     Date; 
  d_最大序号时间 Date; 
  n_追加号       Number := 0; --处理时段过期 追加挂号的情况 
  n_已约数       病人挂号汇总.已约数%Type; 
  n_已接收       病人挂号汇总.其中已接收%Type; 
  n_预约有效时间 Number; 
  n_失效数       Number; 
  n_失约挂号     Number := 0; 
  n_已用数量     Number; 
  n_锁定         Number := 0; 
 
  n_打印id   票据打印内容.Id%Type; 
  n_费用id   门诊费用记录.Id%Type; 
  n_预交金额 病人预交记录.金额%Type; 
  n_当前金额 病人预交记录.金额%Type; 
  n_返回值   病人预交记录.金额%Type; 
  n_预交id   病人预交记录.Id%Type; 
  n_消费卡id 消费卡目录.Id%Type; 
  n_挂号id   病人挂号记录.Id%Type; 
 
  n_组id           财务缴款分组.Id%Type; 
  n_序号           挂号序号状态.序号%Type; 
  n_已用序号       挂号序号状态.序号%Type; 
  n_序号控制       挂号安排.序号控制%Type; 
  n_分诊台签到排队 Number; 
  n_Count          Number; 
  n_限号数         Number(18); 
  n_自制卡         Number; 
  d_排队时间       Date; 
  d_序号时间       Date; 
  v_费别           费别.名称%Type; 
  n_时段序号       Number := -1; 
  n_预约生成队列   Number; 
  n_安排id         挂号安排.Id%Type; 
  n_计划id         挂号安排计划.Id%Type := 0; 
  v_星期           挂号安排限制.限制项目%Type; 
  n_限约数         Number(18); 
  n_已挂数         Number(4) := 0; 
 
  n_挂出的最大序号 Number(4) := 0; 
  n_结算模式       病人信息.结算模式%Type; 
  v_排队序号       排队叫号队列.排队序号%Type; 
  v_机器名         挂号序号状态.机器名%Type; 
  v_序号操作员     挂号序号状态.操作员姓名%Type; 
  v_序号机器名     挂号序号状态.机器名%Type; 
  v_付款方式       病人挂号记录.医疗付款方式%Type; 
  v_Temp           Varchar2(3000); 
  n_分时点显示     Number(3); 
  n_号序使用否     Number(3); 
  d_启用时间       Date; 
Begin 
  --获取当前机器名称 
  Select Terminal Into v_机器名 From V$session Where Audsid = Userenv('sessionid'); 
  n_组id := Zl_Get组id(操作员姓名_In); 
  If 费别_In Is Null Then 
    Begin 
      Select 名称 Into v_费别 From 费别 Where 缺省标志 = 1 And Rownum < 2; 
      Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In; 
    Exception 
      When Others Then 
        v_Err_Msg := '无法确定病人费别，请检查缺省费别是否正确设置！'; 
        Raise Err_Item; 
    End; 
  Else 
    v_费别 := 费别_In; 
    If Nvl(修正病人费别_In, 0) = 1 Then 
      Begin 
        Update 病人信息 Set 费别 = v_费别 Where 病人id = 病人id_In; 
      Exception 
        When Others Then 
          v_Err_Msg := '没有找到对应的病人！'; 
          Raise Err_Item; 
      End; 
    End If; 
  End If; 
 
  If Nvl(修正病人年龄_In, 0) = 1 Then 
    Begin 
      Update 病人信息 Set 年龄 = 年龄_In Where 病人id = 病人id_In; 
    Exception 
      When Others Then 
        v_Err_Msg := '没有找到对应的病人！'; 
        Raise Err_Item; 
    End; 
  End If; 
 
  Begin 
    Delete From 挂号序号状态 
    Where 号码 = 号别_In And 日期 = 发生时间_In And 序号 = 号序_In And 状态 = 3 And 操作员姓名 = 操作员姓名_In; 
  Exception 
    When Others Then 
      Null; 
  End; 
  v_Temp := zl_GetSysParameter(256); 
  If v_Temp Is Null Or Substr(v_Temp, 1, 1) = '0' Then 
    Null; 
  Else 
    Begin 
      d_启用时间 := To_Date(Substr(v_Temp, 3), 'YYYY-MM-DD hh24:mi:ss'); 
    Exception 
      When Others Then 
        d_启用时间 := Null; 
    End; 
    If d_启用时间 Is Not Null Then 
      If 发生时间_In > d_启用时间 Then 
        v_Err_Msg := '当前挂号的发生时间' || To_Char(发生时间_In, 'yyyy-mm-dd hh24:mi:ss') || '已经启用了出诊表排班模式,不能再使用计划排班模式挂号!'; 
        Raise Err_Item; 
      End If; 
    End If; 
  End If; 
 
  If Nvl(预约挂号_In, 0) = 0 Then 
    --挂号或者预约接收 
    --因为现在有按日编单据号规则,日挂号量不能超过10000次,所以要检查唯一约束。 
    Select Count(*) 
    Into n_Count 
    From 门诊费用记录 
    Where 记录性质 = 4 And 记录状态 In (1, 3) And 序号 = 序号_In And NO = 单据号_In; 
    If n_Count <> 0 Then 
      v_Err_Msg := '挂号单据号重复,不能保存！' || Chr(13) || '如果使用了按日顺序编号,当日挂号量不能超过10000人次。'; 
      Raise Err_Item; 
    End If; 
 
    --获取结算方式名称 
    Begin 
      Select 名称 Into v_现金 From 结算方式 Where 性质 = 1; 
    Exception 
      When Others Then 
        v_现金 := '现金'; 
    End; 
    Begin 
      Select 名称 Into v_个人帐户 From 结算方式 Where 性质 = 3; 
    Exception 
      When Others Then 
        v_个人帐户 := '个人帐户'; 
    End; 
  End If; 
 
  n_序号 := 号序_In; 
  Select Decode(To_Char(发生时间_In, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null) 
  Into v_星期 
  From Dual; 
 
  --挂号获取安排 
  Begin 
    Select a.Id, a.序号控制, Nvl(b.限号数, 0), Nvl(b.限约数, 0) 
    Into n_安排id, n_序号控制, n_限号数, n_限约数 
    From 挂号安排 A, 挂号安排限制 B 
    Where a.Id = b.安排id(+) And b.限制项目(+) = v_星期 And a.号码 = 号别_In; 
 
  Exception 
    When Others Then 
      n_安排id := -1; 
  End; 
 
  --如果是病历费或者号别为空时不检查 
  If Nvl(病历费_In, 0) = 0 Or 号别_In Is Not Null Then 
    If n_安排id = -1 Then 
      v_Err_Msg := '不存在相应的挂号安排数据,请检查'; 
      Raise Err_Item; 
    End If; 
  End If; 
 
  If Nvl(预约挂号_In, 0) = 1 Then 
    --首先获取计划 
    Begin 
      Select ID 
      Into n_计划id 
      From 挂号安排计划 
      Where 安排id = n_安排id And 审核时间 Is Not Null And 
            Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) = 
            (Select Max(a.生效时间) As 生效 
             From 挂号安排计划 A 
             Where a.审核时间 Is Not Null And 发生时间_In Between Nvl(a.生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And 
                   Nvl(a.失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')) And a.安排id = n_安排id) And 
            发生时间_In Between Nvl(生效时间, To_Date('1900-01-01', 'yyyy-mm-dd')) And 
            Nvl(失效时间, To_Date('3000-01-01', 'yyyy-mm-dd')); 
 
    Exception 
      When Others Then 
        n_计划id := 0; 
    End; 
    If Nvl(n_计划id, 0) <> 0 Then 
      Begin 
        --获取计划的限制 
        Select a.Id, a.序号控制, Nvl(b.限号数, 0) As 限号数, Nvl(b.限约数, 0) As 限约数 
        Into n_计划id, n_序号控制, n_限号数, n_限约数 
        From 挂号安排计划 A, 挂号计划限制 B 
        Where a.号码 = 号别_In And a.Id = n_计划id And a.审核时间 Is Not Null And a.Id = b.计划id(+) And b.限制项目(+) = v_星期; 
      Exception 
        When Others Then 
          v_Err_Msg := '不存相应的挂号安排或计划数据,请检查'; 
          Raise Err_Item; 
      End; 
    End If; 
  End If; 
 
  --获取是否分时段 
  If Nvl(n_计划id, 0) = 0 Then 
    Select Count(Rownum) Into n_分时段 From 挂号安排时段 Where 星期 = v_星期 And 安排id = n_安排id And Rownum <= 1; 
  Else 
    Select Count(Rownum) Into n_分时段 From 挂号计划时段 Where 星期 = v_星期 And 计划id = n_计划id And Rownum <= 1; 
  End If; 
 
  --分时段挂号时判断是否是过期挂号 也就是追加号的情况 目前只针对专家号分时段进行处理 
  If Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 And Nvl(n_序号控制, 0) = 1 And 号序_In Is Null And Nvl(操作类型_In, 0) = 0 Then 
    --发生时间_in>Sysdate 发生时间>最大的时段时间--号序_in is null 
    Begin 
      Select Max(To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')) 
      Into d_最大序号时间 
      From 挂号安排时段 
      Where 安排id = n_安排id And 星期 = v_星期 And Nvl(限制数量, 0) <> 0; 
      n_追加号 := Case Sign(发生时间_In - d_最大序号时间) 
                 When -1 Then 
                  0 
                 Else 
                  1 
               End; 
    Exception 
      When Others Then 
        n_追加号 := 0; 
    End; 
  End If; 
  d_时段时间 := 发生时间_In; 
 
  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 0 And n_分时段 > 0 Then 
    --挂号时检查 是否分了时段,分了时段,把时段的限制条件给取出来 
    Begin 
      Select Nvl(序号, 0), 
             To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss'), 
             限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量) 
      Into n_时段序号, d_时段时间, n_时段限号, n_时段限约 
      From 挂号安排时段 
      Where 安排id = n_安排id And 星期 = v_星期 And 
            (序号, 安排id, 星期) In (Select Nvl(Max(序号), -1), 安排id, 星期 
                               From 挂号安排时段 
                               Where 安排id = n_安排id And 星期 = v_星期 And 
                                     Decode(操作类型_In + n_追加号, 0, To_Char(发生时间_In, 'hh24:mi'), 
                                            To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi')) = 
                                     To_Char(Nvl(开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi') 
                               Group By 安排id, 星期); 
    Exception 
      When Others Then 
        n_时段序号 := -1; 
        n_分时段   := 0; 
        d_时段时间 := 发生时间_In; 
        n_时段限号 := 0; 
        n_时段限约 := 0; 
    End; 
  End If; 
 
  If 序号_In = 1 And Nvl(预约挂号_In, 0) = 1 And n_分时段 > 0 Then 
    --预约号,取计划 
    Begin 
      If Nvl(n_计划id, 0) = 0 Then 
        --没计划生效,取安排的数据 
        Select Nvl(序号, 0), 
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间, 
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量) 
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约 
        From 挂号安排时段 C 
        Where 安排id = n_安排id And 星期 = v_星期 And 
              (序号, 安排id, 星期) In 
              (Select Nvl(Max(c.序号), -1), 安排id, 星期 
               From 挂号安排时段 C 
               Where 安排id = n_安排id And c.星期 = v_星期 And 
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'), 
                            To_Char(发生时间_In, 'hh24:mi')) = 
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi') 
               Group By 安排id, 星期); 
      Else 
        --有计划生效取计划 
        --没生效，代表是从挂号计划时段查询 
        Select Nvl(序号, -1), 
               To_Date(To_Char(发生时间_In, 'yyyy-mm-dd') || ' ' || To_Char(c.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') As 时段时间, 
               限制数量, Decode(Nvl(是否预约, 0), 0, 0, 限制数量) 
        Into n_时段序号, d_时段时间, n_时段限号, n_时段限约 
        From 挂号计划时段 C 
        Where 计划id = n_计划id And 星期 = v_星期 And 
              (序号, 计划id, 星期) In 
              (Select Nvl(Max(c.序号), -1), 计划id, 星期 
               From 挂号计划时段 C 
               Where 计划id = n_计划id And c.星期 = v_星期 And 
                     Decode(操作类型_In, 1, To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi'), 
                            To_Char(发生时间_In, 'hh24:mi')) = 
                     To_Char(Nvl(c.开始时间, To_Date('1900-01-01', 'yyyy-mm-dd')), 'hh24:mi') 
               Group By 计划id, 星期); 
      End If; 
    Exception 
      When Others Then 
        n_时段序号 := -1; 
        n_分时段   := 0; 
        d_时段时间 := 发生时间_In; 
        n_时段限号 := 0; 
        n_时段限约 := 0; 
    End; 
  End If; 
 
  If 序号_In = 1 Then 
 
    --获取当前未使用的序号 
    If Nvl(n_序号控制, 0) = 1 And n_分时段 = 0 Then 
      --<序号控制 未设置时段 获取可用的最大序号,以及已经使用的数量> 
      Begin 
        --最大序号 
        If 退号重用_In = 1 Then 
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0)) 
          Into n_已用序号, n_已用数量, n_已约数 
          From 挂号序号状态 
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5); 
        Else 
          Select Max(Nvl(序号, 0)), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Nvl(预约, 0)) 
          Into n_已用序号, n_已用数量, n_已约数 
          From 挂号序号状态 
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5; 
        End If; 
      Exception 
        When Others Then 
          n_已用序号 := 0; 
          n_已用数量 := 0; 
      End; 
      If n_序号 Is Null Then 
        n_序号 := Nvl(n_已用序号, 0) + 1; 
      End If; 
      --<序号控制 未设置时段 获取可用的最大序号 以及已经使用的数量 --end> 
 
      --非加号的情况需要检查是否超过了限制 
      If 操作类型_In = 0 Then 
        If Nvl(预约挂号_In, 0) = 0 Then 
          --挂号时检查 ，非加号的情况下，检测当前号序是否被使用，防止并发情况下导致序号重复的可能。
          --启用序号控制未分时段 达到了限制 
          --检测挂号记录中当前序号是否已经使用，若未使用则不检测挂号数量
          Select Count(1)
          Into n_号序使用否
          From 挂号序号状态 
          Where 号码 = 号别_In And 序号= nvl(号序_In,0) And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 操作员姓名 <> 操作员姓名_In; 
          if nvl(号序_In,0)>0 And n_号序使用否=1 then
              v_Err_Msg := '号别' || 号别_In || '号序' || to_char(n_号序使用否) || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd ') || '已被其它用户使用！'; 
              Raise Err_Item; 
          end if;
        Else 
          --预约时检查 
          If n_限约数 = 0 Then 
            n_限约数 := n_限号数; 
          End If; 
 
          If n_限约数 <= n_已约数 And n_限约数 > 0 Then 
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(Trunc(发生时间_In), 'yyyy-mm-dd') || '已达到最大限约数！'; 
            Raise Err_Item; 
          End If; 
        End If; 
 
      Else 
        Null; 
        --启用序号控制,未分时段 加号情况   不处理,如果以后有限制条件以后补充 
      End If; 
 
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 0 Then 
      --<--普通号分时段 这里只有预约一种情况--> 
      If 操作类型_In = 0 Then 
        --<正常预约挂号--> 
        Begin 
          Select Count(0) As 已挂数, Nvl(Sum(Decode(Nvl(Sign(a.日期 - d_时段时间), 0), 0, 1, 0)), 0) As 已约数 
          Into n_已挂数, n_已约数 
          From 挂号序号状态 A 
          Where a.号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 
                状态 Not In (4, 5); 
        Exception 
          When Others Then 
            n_已挂数 := 0; 
            n_已约数 := 0; 
        End; 
 
        n_时段限约 := n_时段限号; --普通号分时段的情况,29中n_时段限约始终是0 这里特殊处理 
        --检查限制数量 
        If n_限约数 = 0 Then 
          n_限约数 := n_限号数; 
        End If; 
        If n_时段限约 <= n_已约数 Or n_限约数 <= n_已约数 Then 
          v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限约数！'; 
          Raise Err_Item; 
        End If; 
        If n_限号数 <= n_已挂数 Then 
          v_Err_Msg := '号别' || 号别_In || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！'; 
          Raise Err_Item; 
        End If; 
      End If; 
 
      --没有达到时段的限号数 号码在当前时段往后追加 
 
      --获取当天挂出的最大号序 
      If 退号重用_In = 1 Then 
        Select Nvl(Max(序号), 0) 
        Into n_挂出的最大序号 
        From 挂号序号状态 A 
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 Not In (4, 5); 
      Else 
        Select Nvl(Max(序号), 0) 
        Into n_挂出的最大序号 
        From 挂号序号状态 A 
        Where a.日期 = d_时段时间 And 号码 = 号别_In And 状态 <> 5; 
      End If; 
 
      --设置序号 
      n_序号 := RPad(Nvl(n_时段序号, 0), Length(n_限号数) + Length(Nvl(n_时段序号, 0)), 0) + n_已约数 + 1; 
      If n_序号 <= Nvl(n_挂出的最大序号, 0) Then 
        n_序号 := Nvl(n_挂出的最大序号, 0) + 1; 
      End If; 
 
      --<--普通号分时段--End> 
    Elsif Nvl(n_分时段, 0) > 0 And Nvl(n_序号控制, 0) = 1 Then 
      --<启用序号控制 设置时段 
      --专家号分时段 
      Begin 
        If 退号重用_In = 1 Then 
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0)) 
          Into n_已用序号, n_已挂数, n_已用数量 
          From 挂号序号状态 
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 Not In (4, 5); 
        Else 
          Select Max(序号), Sum(Decode(序号, Nvl(号序_In, 0), 0, 1)), Sum(Decode(Sign(日期 - d_时段时间), 0, 1, 0)) 
          Into n_已用序号, n_已挂数, n_已用数量 
          From 挂号序号状态 
          Where 号码 = 号别_In And 日期 Between Trunc(发生时间_In) And Trunc(发生时间_In) + 1 - 1 / 24 / 60 / 60 And 状态 <> 5; 
        End If; 
      Exception 
        When Others Then 
          n_已用序号 := 0; 
          n_已用数量 := 0; 
          n_已挂数   := 0; 
      End; 
 
      n_失效数 := 0; 
      If Nvl(预约挂号_In, 0) = 0 Then 
        n_预约有效时间 := Zl_To_Number(zl_GetSysParameter('预约有效时间', 1111)); 
        n_失约挂号     := Zl_To_Number(zl_GetSysParameter('失约用于挂号', 1111)); 
        If Nvl(n_预约有效时间, 0) <> 0 And Nvl(n_失约挂号, 0) > 0 Then 
          Begin 
            Select Sum(Decode(Sign((Sysdate - n_预约有效时间 / 24 / 60) - 日期), 1, 1, 0)) 
            Into n_失效数 
            From 挂号序号状态 
            Where 号码 = 号别_In And 日期 Between Trunc(Sysdate) And Sysdate And Nvl(预约, 0) = 1 And 状态 = 2; 
          Exception 
            When Others Then 
              n_失效数 := 0; 
          End; 
        End If; 
      End If; 
 
      If 操作类型_In = 0 Then 
        If Nvl(预约挂号_In, 0) = 0 Then 
 
          --挂号 追加号码时不检查时段限号数 
          If n_时段限号 <= n_已用数量 And Nvl(n_追加号, 0) = 0 Then 
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
          If n_限号数 <= n_已挂数 - n_失效数 Then 
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
 
        Else 
          --挂号 
          If n_限约数 = 0 Then 
            n_限约数 := n_限号数; 
          End If; 
          If n_限约数 <= n_已用数量 Then 
            v_Err_Msg := '号别' || 号别_In || '在时段' || To_Char(d_时段时间, 'hh24:mi') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
          If n_限号数 <= n_已挂数 Then 
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
        End If; 
      End If; 
      If n_序号 Is Null Then 
        --设置序号 
        If Nvl(n_已用序号, 0) < Nvl(n_时段序号, 0) Then 
          n_已用序号 := Nvl(n_时段序号, 0); 
        End If; 
        n_序号 := Nvl(n_已用序号, 0) + 1; 
      End If; 
    Elsif Nvl(n_分时段, 0) = 0 And Nvl(n_序号控制, 0) = 0 And Nvl(病历费_In, 0) = 0 And Nvl(号别_In, 0) > 0 Then 
      ---<--普通号  --> 
      Begin 
        Select 已挂数, 已约数 
        Into n_已用数量, n_已约数 
        From 病人挂号汇总 
        Where 日期 = Trunc(发生时间_In) And 号码 = 号别_In; 
      Exception 
        When Others Then 
          n_已用数量 := 0; 
          n_已约数   := 0; 
      End; 
      If Nvl(操作类型_In, 0) = 0 Then 
        If Nvl(预约挂号_In, 0) = 0 Then 
          --挂号 
          If Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0 Then 
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
        Else 
          --预约 
          If (Nvl(n_限约数, 0) > 0 And Nvl(n_已约数, 0) >= Nvl(n_限约数, 0)) Or 
             (Nvl(n_已用数量, 0) >= Nvl(n_限号数, 0) And Nvl(n_限号数, 0) > 0) Then 
            v_Err_Msg := '号别' || 号别_In || '在' || To_Char(发生时间_In, 'yyyy-mm-dd') || '已达到最大限制数！'; 
            Raise Err_Item; 
          End If; 
        End If; 
      End If; 
      ---<--普通号  --> 
    End If; 
  End If; 
 
  --更新挂号序号状态 
  If 序号_In = 1 And Not n_序号 Is Null Then 
    If n_分时段 = 1 Then 
      d_序号时间 := 发生时间_In; 
    Else 
      d_序号时间 := Trunc(发生时间_In); 
    End If; 
    --锁定序号的处理 
    Begin 
      Select 操作员姓名, 机器名 
      Into v_序号操作员, v_序号机器名 
      From 挂号序号状态 
      Where 状态 = 5 And 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号; 
      n_锁定 := 1; 
    Exception 
      When Others Then 
        v_序号操作员 := Null; 
        v_序号机器名 := Null; 
        n_锁定       := 0; 
    End; 
    If n_锁定 = 0 Then 
      Update 挂号序号状态 
      Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate 
      Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 3 And 操作员姓名 = 操作员姓名_In; 
      If Sql%RowCount = 0 Then 
        Begin 
          If Nvl(n_分时段, 0) = 0 Or Nvl(预约挂号_In, 0) = 1 Or (Nvl(n_序号控制, 0) = 0 And Nvl(号序_In, 0) = 0) Then 
            Insert Into 挂号序号状态 
              (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间) 
            Values 
              (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate); 
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then 
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号; 
            End If; 
          Elsif Nvl(n_分时段, 0) > 0 Then 
            --分时段后专家号 失约的预约号允许挂号 
            Update 挂号序号状态 
            Set 状态 = Decode(预约挂号_In, 1, 2, 1), 操作员姓名 = 操作员姓名_In, 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate 
            Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 2; 
            If Sql%NotFound Then 
              Insert Into 挂号序号状态 
                (号码, 日期, 序号, 状态, 操作员姓名, 预约, 登记时间) 
              Values 
                (号别_In, d_序号时间, n_序号, Decode(预约挂号_In, 1, 2, 1), 操作员姓名_In, Decode(预约接收_In, 1, 1, 0), Sysdate); 
            End If; 
            If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then 
              Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号; 
            End If; 
          End If; 
        Exception 
          When Others Then 
            v_Err_Msg := '序号' || n_序号 || '已被使用,请重新选择一个序号.'; 
            Raise Err_Item; 
        End; 
      End If; 
    Else 
      If 操作员姓名_In <> v_序号操作员 Or v_机器名 <> v_序号机器名 Then 
        v_Err_Msg := '序号' || n_序号 || '已被自助机' || v_机器名 || '锁定,请重新选择一个序号.'; 
        Raise Err_Item; 
      Else 
        Update 挂号序号状态 
        Set 状态 = Decode(预约挂号_In, 1, 2, 1), 预约 = Decode(预约接收_In, 1, 1, 0), 登记时间 = Sysdate 
        Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号 And 状态 = 5 And 操作员姓名 = 操作员姓名_In And 机器名 = v_机器名; 
        If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then 
          Update 挂号序号状态 Set 预约 = 1 Where 号码 = 号别_In And 日期 = d_序号时间 And 序号 = n_序号; 
        End If; 
      End If; 
    End If; 
  End If; 
 
  --产生病人挂号费用(可能单独是或包括病历费用) 
  Select 病人费用记录_Id.Nextval Into n_费用id From Dual; --应该通过程序得到 
 
  Insert Into 门诊费用记录 
    (ID, 记录性质, 记录状态, 序号, 价格父号, 从属父号, NO, 实际票号, 门诊标志, 加班标志, 附加标志, 发药窗口, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 费别, 病人科室id, 收费类别, 
     计算单位, 收费细目id, 收入项目id, 收据费目, 付数, 数次, 标准单价, 应收金额, 实收金额, 结帐金额, 结帐id, 记帐费用, 开单部门id, 开单人, 划价人, 执行部门id, 执行人, 操作员编号, 操作员姓名, 
     发生时间, 登记时间, 保险大类id, 保险项目否, 保险编码, 统筹金额, 摘要, 结论, 缴款组id) 
  Values 
    (n_费用id, 4, Decode(预约挂号_In, 1, 0, 1), 序号_In, Decode(价格父号_In, 0, Null, 价格父号_In), 从属父号_In, 单据号_In, 票据号_In, 1, 急诊_In, 
     病历费_In, Decode(预约挂号_In, 1, To_Char(n_序号), 诊室_In), Decode(病人id_In, 0, Null, 病人id_In), 
     Decode(门诊号_In, 0, Null, 门诊号_In), 付款方式_In, 姓名_In, Decode(姓名_In, Null, Null, 性别_In), Decode(姓名_In, Null, Null, 年龄_In), 
     v_费别, 病人科室id_In, 收费类别_In, 号别_In, 收费细目id_In, 收入项目id_In, 收据费目_In, 1, 数次_In, 标准单价_In, 应收金额_In, 实收金额_In, 
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 实收金额_In)), 
     Decode(预约挂号_In, 1, Null, Decode(Nvl(记帐费用_In, 0), 1, Null, 结帐id_In)), Decode(Nvl(记帐费用_In, 0), 1, 1, 0), 开单部门id_In, 
     操作员姓名_In, Decode(预约挂号_In, 1, 操作员姓名_In, Null), 执行部门id_In, 医生姓名_In, 操作员编号_In, 操作员姓名_In, 发生时间_In, 登记时间_In, 保险大类id_In, 
     保险项目否_In, 保险编码_In, 统筹金额_In, 摘要_In, 预约方式_In, Decode(预约挂号_In, 1, Null, n_组id)); 
 
  --汇总结算到病人预交记录 
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 0 Then 
 
    If (Nvl(现金支付_In, 0) <> 0 Or (Nvl(现金支付_In, 0) = 0 And Nvl(个帐支付_In, 0) = 0 And Nvl(预交支付_In, 0) = 0)) And 序号_In = 1 Then 
      Select 病人预交记录_Id.Nextval Into n_预交id From Dual; 
      Insert Into 病人预交记录 
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 
         结算性质) 
      Values 
        (n_预交id, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), Nvl(结算方式_In, v_现金), Nvl(现金支付_In, 0), 登记时间_In, 
         操作员编号_In, 操作员姓名_In, 结帐id_In, '挂号收费', n_组id, 卡类别id_In, 结算卡序号_In, 卡号_In, 交易流水号_In, 交易说明_In, 合作单位_In, 4); 
 
      If Nvl(结算卡序号_In, 0) <> 0 And Nvl(现金支付_In, 0) <> 0 Then 
 
        n_消费卡id := Null; 
        Begin 
          Select Nvl(自制卡, 0), 1 Into n_自制卡, n_Count From 卡消费接口目录 Where 编号 = 结算卡序号_In; 
        Exception 
          When Others Then 
            n_Count := 0; 
        End; 
        If n_Count = 0 Then 
          v_Err_Msg := '没有发现原结算卡的相应类别,不能继续操作！'; 
          Raise Err_Item; 
        End If; 
        If n_自制卡 = 1 Then 
          Select ID 
          Into n_消费卡id 
          From 消费卡目录 
          Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In And 
                序号 = (Select Max(序号) From 消费卡目录 Where 接口编号 = 结算卡序号_In And 卡号 = 卡号_In); 
        End If; 
        Zl_病人卡结算记录_Insert(结算卡序号_In, n_消费卡id, 结算方式_In, 现金支付_In, 卡号_In, Null, 登记时间_In, Null, 结帐id_In, n_预交id); 
      End If; 
 
    End If; 
 
    --对于医保挂号 
    If Nvl(个帐支付_In, 0) <> 0 And 序号_In = 1 Then 
      Insert Into 病人预交记录 
        (ID, 记录性质, 记录状态, NO, 病人id, 结算方式, 冲预交, 收款时间, 操作员编号, 操作员姓名, 结帐id, 摘要, 缴款组id, 结算性质) 
      Values 
        (病人预交记录_Id.Nextval, 4, 1, 单据号_In, Decode(病人id_In, 0, Null, 病人id_In), v_个人帐户, 个帐支付_In, 登记时间_In, 操作员编号_In, 
         操作员姓名_In, 结帐id_In, '医保挂号', n_组id, 4); 
    End If; 
 
    --对于就诊卡通过预交金挂号 
    If Nvl(预交支付_In, 0) <> 0 And 序号_In = 1 Then 
      n_预交金额 := 预交支付_In; 
      For r_Deposit In c_Deposit(病人id_In) Loop 
        n_当前金额 := Case 
                    When r_Deposit.金额 - n_预交金额 < 0 Then 
                     r_Deposit.金额 
                    Else 
                     n_预交金额 
                  End; 
 
        If r_Deposit.结帐id = 0 Then 
          --第一次冲预交(82592,将第一次标上结帐ID,冲预交标记为0) 
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 4 Where ID = r_Deposit.原预交id; 
        End If; 
        --冲上次剩余额 
        Insert Into 病人预交记录 
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 预交类别, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 
           冲预交, 结帐id, 缴款组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质) 
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 预交类别, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 
                 登记时间_In, 操作员姓名_In, 操作员编号_In, n_当前金额, 结帐id_In, n_组id, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 4 
          From 病人预交记录 
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1; 
 
        --更新病人预交余额 
        Update 病人余额 
        Set 预交余额 = Nvl(预交余额, 0) - n_当前金额 
        Where 病人id = 病人id_In And 性质 = 1 And 类型 = Nvl(1, 2); 
        --检查是否已经处理完 
        If r_Deposit.金额 < n_预交金额 Then 
          n_预交金额 := n_预交金额 - r_Deposit.金额; 
        Else 
          n_预交金额 := 0; 
        End If; 
 
        If n_预交金额 = 0 Then 
          Exit; 
        End If; 
      End Loop; 
      If n_预交金额 > 0 Then 
        v_Err_Msg := '预交余不够支付本次支付金额,不能继续操作！'; 
        Raise Err_Item; 
      End If; 
      Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0; 
    End If; 
 
    --相关汇总表的处理 
    --人员缴款余额 
    If 序号_In = 1 And Nvl(更新交款余额_In, 0) = 0 Then 
      If Nvl(现金支付_In, 0) <> 0 Then 
        Update 人员缴款余额 
        Set 余额 = Nvl(余额, 0) + 现金支付_In 
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) 
        Returning 余额 Into n_返回值; 
 
        If Sql%RowCount = 0 Then 
          Insert Into 人员缴款余额 
            (收款员, 结算方式, 性质, 余额) 
          Values 
            (操作员姓名_In, Nvl(结算方式_In, v_现金), 1, 现金支付_In); 
          n_返回值 := 现金支付_In; 
        End If; 
        If Nvl(n_返回值, 0) = 0 Then 
          Delete From 人员缴款余额 
          Where 收款员 = 操作员姓名_In And 结算方式 = Nvl(结算方式_In, v_现金) And 性质 = 1 And Nvl(余额, 0) = 0; 
        End If; 
      End If; 
 
      If Nvl(个帐支付_In, 0) <> 0 Then 
        Update 人员缴款余额 
        Set 余额 = Nvl(余额, 0) + 个帐支付_In 
        Where 性质 = 1 And 收款员 = 操作员姓名_In And 结算方式 = v_个人帐户 
        Returning 余额 Into n_返回值; 
 
        If Sql%RowCount = 0 Then 
          Insert Into 人员缴款余额 (收款员, 结算方式, 性质, 余额) Values (操作员姓名_In, v_个人帐户, 1, 个帐支付_In); 
          n_返回值 := 个帐支付_In; 
        End If; 
        If Nvl(n_返回值, 0) = 0 Then 
          Delete From 人员缴款余额 
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_个人帐户 And Nvl(余额, 0) = 0; 
        End If; 
      End If; 
    End If; 
  End If; 
 
  --病人挂号汇总(只处理一次,且单独收取病历费不处理) 
  If Nvl(预约挂号_In, 0) = 0 Then 
    --病人本次就诊(以发生时间为准) 
    If Nvl(病人id_In, 0) <> 0 And 序号_In = 1 Then 
      Update 病人信息 Set 就诊时间 = 发生时间_In, 就诊状态 = 1, 就诊诊室 = 诊室_In Where 病人id = 病人id_In; 
    End If; 
  End If; 
 
  If Nvl(预约挂号_In, 0) = 0 And Nvl(记帐费用_In, 0) = 1 Then 
    --记帐 
    If Nvl(病人id_In, 0) = 0 Then 
      v_Err_Msg := '要针对病人的挂号费进行记帐，必须是建档病人才能记帐挂号。'; 
      Raise Err_Item; 
    End If; 
 
    --病人余额 
    Update 病人余额 
    Set 费用余额 = Nvl(费用余额, 0) + Nvl(实收金额_In, 0) 
    Where 病人id = Nvl(病人id_In, 0) And 性质 = 1 And 类型 = 1; 
 
    If Sql%RowCount = 0 Then 
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, Nvl(实收金额_In, 0), 0); 
    End If; 
 
    --病人未结费用 
    Update 病人未结费用 
    Set 金额 = Nvl(金额, 0) + Nvl(实收金额_In, 0) 
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And 
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 
          来源途径 + 0 = 1; 
 
    If Sql%RowCount = 0 Then 
      Insert Into 病人未结费用 
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额) 
      Values 
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 1, Nvl(实收金额_In, 0)); 
    End If; 
  End If; 
 
  --病人挂号记录 
  If 号别_In Is Not Null And 序号_In = 1 Then 
    --And Nvl(预约挂号_In, 0) = 0 
    Select 病人挂号记录_Id.Nextval Into n_挂号id From Dual; 
    Begin 
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In And Rownum < 2; 
    Exception 
      When Others Then 
        v_付款方式 := Null; 
    End; 
    Insert Into 病人挂号记录 
      (ID, NO, 记录性质, 记录状态, 病人id, 门诊号, 姓名, 性别, 年龄, 号别, 急诊, 诊室, 附加标志, 执行部门id, 执行人, 执行状态, 执行时间, 登记时间, 发生时间, 预约时间, 操作员编号, 
       操作员姓名, 复诊, 号序, 社区, 预约, 预约方式, 摘要, 交易流水号, 交易说明, 合作单位, 接收时间, 接收人, 预约操作员, 预约操作员编号, 险类, 医疗付款方式, 收费单) 
    Values 
      (n_挂号id, 单据号_In, Decode(Nvl(预约挂号_In, 0), 1, 2, 1), 1, 病人id_In, 门诊号_In, 姓名_In, 性别_In, 年龄_In, 号别_In, 急诊_In, 诊室_In, 
       Null, 执行部门id_In, 医生姓名_In, 0, Null, 登记时间_In, 发生时间_In, Decode(Nvl(预约挂号_In, 0), 1, 发生时间_In, Null), 操作员编号_In, 
       操作员姓名_In, 复诊_In, n_序号, 社区_In, Decode(预约接收_In, 1, 1, 0), 预约方式_In, 摘要_In, 交易流水号_In, 交易说明_In, 合作单位_In, 
       Decode(Nvl(预约挂号_In, 0), 0, 登记时间_In, Null), Decode(Nvl(预约挂号_In, 0), 0, 操作员姓名_In, Null), 
       Decode(Nvl(预约挂号_In, 0), 1, 操作员姓名_In, Null), Decode(Nvl(预约挂号_In, 0), 1, 操作员编号_In, Null), 
       Decode(Nvl(险类_In, 0), 0, Null, 险类_In), v_付款方式, 收费单_In); 
    If Nvl(预约挂号_In, 0) = 0 And 预约方式_In Is Not Null Then 
      Update 病人挂号记录 
      Set 预约 = 1, 预约时间 = 发生时间_In, 预约操作员 = 操作员姓名_In, 预约操作员编号 = 操作员编号_In 
      Where ID = n_挂号id; 
    End If; 
    n_预约生成队列 := 0; 
    If Nvl(预约挂号_In, 0) = 1 Then 
      n_预约生成队列 := Zl_To_Number(zl_GetSysParameter('预约生成队列', 1113)); 
    End If; 
 
    --0-不产生队列;1-按医生或分诊台排队;2-先分诊,后医生站 
    If Nvl(生成队列_In, 0) <> 0 And Nvl(预约挂号_In, 0) = 0 Or n_预约生成队列 = 1 Then 
      n_分诊台签到排队 := Zl_To_Number(zl_GetSysParameter('分诊台签到排队', 1113)); 
      If Nvl(n_分诊台签到排队, 0) = 0 Or n_预约生成队列 = 1 Then 
        n_分时点显示 := Nvl(Zl_To_Number(zl_GetSysParameter(270)), 0); 
        If Nvl(预约挂号_In, 0) = 1 And n_分时点显示 = 1 And n_分时段 = 1 Then 
          n_分时点显示 := 1; 
        Else 
          n_分时点显示 := Null; 
        End If; 
        --产生队列 
        --.按”执行部门” 的方式生成队列 
        v_队列名称 := 执行部门id_In; 
        v_排队号码 := Zlgetnextqueue(执行部门id_In, n_挂号id, 号别_In || '|' || n_序号); 
        v_排队序号 := Zlgetsequencenum(0, n_挂号id, 0); 
        d_排队时间 := Zl_Get_Queuedate(n_挂号id, 号别_In, n_序号, 发生时间_In); 
        --  队列名称_In , 业务类型_In, 业务id_In,科室id_In,排队号码_In,排队标记_In,患者姓名_In,病人ID_IN, 诊室_In, 医生姓名_In, 排队时间_In 
        Zl_排队叫号队列_Insert(v_队列名称, 0, n_挂号id, 执行部门id_In, v_排队号码, Null, 姓名_In, 病人id_In, 诊室_In, 医生姓名_In, d_排队时间, 预约方式_In, 
                         n_分时点显示, v_排队序号); 
      End If; 
    End If; 
  End If; 
  --病人担保信息 
  If 病人id_In Is Not Null And 序号_In = 1 Then 
    --取参数: 
    If Nvl(n_结算模式, 0) <> Nvl(结算模式_In, 0) Then 
      --结算模式的确定 
 
      v_Err_Msg := Null; 
      Begin 
        Select Nvl(结算模式, 0) Into n_结算模式 From 病人信息 Where 病人id = 病人id_In; 
      Exception 
        When Others Then 
          v_Err_Msg := '未找到指定的病人信息,不允许挂号'; 
      End; 
 
      If v_Err_Msg Is Not Null Then 
        Raise Err_Item; 
      End If; 
      If n_结算模式 = 1 And Nvl(结算模式_In, 0) = 0 Then 
        --病人已经是"先诊疗后结算的",本次是"先结算后诊疗的",则检查是否存在未结数据 
        Select Count(1) 
        Into n_Count 
        From 病人未结费用 
        Where 病人id = 病人id_In And (来源途径 In (1, 4) Or 来源途径 = 3 And Nvl(主页id, 0) = 0) And Nvl(金额, 0) <> 0 And Rownum < 2; 
        If Nvl(n_Count, 0) <> 0 Then 
          --存在未结算数据，必须先结算后才允许执行 
          v_Err_Msg := '当前病人的就诊模式为先诊疗后结算且存在未结费用，不允许调整该病人的就诊模式,你可以先对未结费用结帐后再挂号或不调整病人的就诊模式!'; 
          Raise Err_Item; 
        End If; 
        --检查 
        --未发生医嘱业务的（即当时就挂号的,需要保证同一次的就诊模式是一至的(程序已经检查，不用再处理) 
      End If; 
      Update 病人信息 Set 结算模式 = 结算模式_In Where 病人id = 病人id_In; 
    End If; 
 
    Update 病人信息 
    Set 担保人 = Null, 担保额 = Null, 担保性质 = Null 
    Where 病人id = 病人id_In And Nvl(在院, 0) = 0 And Exists 
     (Select 1 
           From 病人担保记录 
           Where 病人id = 病人id_In And 主页id Is Not Null And 
                 登记时间 = (Select Max(登记时间) From 病人担保记录 Where 病人id = 病人id_In)); 
 
    If Sql%RowCount > 0 Then 
      Update 病人担保记录 
      Set 到期时间 = Sysdate 
      Where 病人id = 病人id_In And 主页id Is Not Null And Nvl(到期时间, Sysdate) >= Sysdate; 
    End If; 
  End If; 
  If 序号_In = 1 Then 
    --消息推送 
    Begin 
      Execute Immediate 'Begin ZL_服务窗消息_发送(:1,:2); End;' 
        Using 1, n_挂号id; 
    Exception 
      When Others Then 
        Null; 
    End; 
  End If; 
Exception 
  When Err_Item Then 
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]'); 
  When Others Then 
    zl_ErrorCenter(SQLCode, SQLErrM); 
End Zl_病人挂号记录_Insert;
/

--119413:秦龙,2018-01-12,外观字段的处理
Create Or Replace Procedure Zl_药品其他入库_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  摘要_In       In 药品收发记录.摘要%Type,
  冲销数量_In   In 药品收发记录.实际数量%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type
) Is
  Err_Isstriked  Exception;
  Err_Isoutstock Exception;
  Err_Isnonum    Exception;
  Err_Isbatch    Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_库房id       药品收发记录.库房id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     药品收发记录.实际数量%Type;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  v_剩余金额差   药品收发记录.零售金额%Type;
  v_冲销金额差   药品收发记录.零售金额%Type;
  v_外观         药品收发记录.外观%Type;
  v_收发id       药品收发记录.Id%Type;

  v_药库分批 Integer;
  v_药房分批 Integer;
  Intdigit   Number;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3)
    Where NO = No_In And 单据 = 4 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 4 And
          Mod(a.记录状态, 3) = 0 And a.药品id + 0 = 药品id_In And Nvl(a.批次, 0) = 0 And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, Sum(To_Number(Nvl(用法, 0))) As 金额差, a.库房id,
         a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.生产日期, a.批准文号, a.供药单位id,
         a.外观
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_剩余金额差, v_库房id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率, v_零售价, v_药库分批,
       v_药房分批, v_生产日期, v_批准文号, n_上次供应商id, v_外观
  From 药品收发记录 A, 药品规格 B
  Where a.No = No_In And a.单据 = 4 And a.药品id = b.药品id And a.药品id = 药品id_In And a.序号 = 序号_In
  Group By a.库房id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.生产日期, a.批准文号,
           a.供药单位id, a.外观;

  --冲销数量大于剩余数量，不允许
  If Abs(v_剩余数量) < Abs(冲销数量_In) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(冲销数量_In / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(冲销数量_In / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  --如果有金额差，则要冲销金额差
  v_冲销金额差 := 0;
  If v_剩余金额差 <> 0 Then
    v_冲销金额差 := Round(冲销数量_In / v_剩余数量 * v_剩余金额差, Intdigit);
  End If;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 审核人, 审核日期, 生产日期, 批准文号, 供药单位id, 用法, 外观)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 4, No_In, 序号_In, v_库房id, v_入出类别id, v_入出系数, 药品id_In, v_批次, v_产地, v_批号,
     v_效期, -冲销数量_In, -冲销数量_In, v_成本价, -v_成本金额, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In, v_生产日期,
     v_批准文号, n_上次供应商id, Decode(v_冲销金额差, 0, Null, -v_冲销金额差), v_外观);

  --更新库存
  Zl_药品库存_Update(v_收发id, 0);

  --处理调价后冲销
  Zl_药品收发记录_调价修正(v_收发id);

Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isoutstock Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中有一笔分批药品已出库，不能冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中包含有一条原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品冲销的数量大于了剩余的数据，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Strike;
/

--122673:殷瑞,2018-03-23,清除过程中无效的变量
--122403:殷瑞,2018-03-13,修正医嘱不能正常发送到静配的错误
--119333:殷瑞,2018-01-12,修正肿瘤药、抗生素和营养药不受表[输液不配置药品]限制的情况
Create Or Replace Procedure Zl_输液配药记录_核查
(
  部门id_In   In 输液配药记录.部门id%Type,
  医嘱id_In   In Varchar2, --输液医嘱给药途径对应的医嘱ID:医嘱ID1,医嘱ID2...
  发送号_In   In 病人医嘱发送.发送号%Type,
  核查人_In   In 输液配药状态.操作人员%Type,
  核查时间_In In 输液配药状态.操作时间%Type
) Is
  v_Count    Number;
  v_序号     Number;
  v_执行时间 Date;

  v_相关id      Number;
  v_New相关id   Number;
  v_Old相关id   Number;
  v_发送号      Number;
  v_Tmp         Varchar2(200);
  I             Number;
  v_配药id      Number;
  v_批次        Number;
  v_Maxno       Varchar2(4000);
  v_Maxbatch    Number;
  v_Currdate    Date;
  n_Lngid       药品收发记录.Id%Type;
  n_Count       Number(3);
  n_单据        药品收发记录.单据%Type;
  v_No          药品收发记录.No%Type;
  n_发送次数    Number(5);
  n_病人id      病人信息.病人id%Type := 0;
  b_Change      Boolean := True;
  n_Sum         Number;
  n_调整批次    Number(1);
  n_Cur         Number(5);
  v_医嘱ids     Varchar2(4000);
  v_Tansid      Varchar2(12);
  v_当前病人    Varchar2(20);
  n_Num         Number(8);
  d_Old执行时间 Date;
  n_是否打包    Number(1);
  n_打包        Number(1);
  n_摆药单      Number(2);
  --控制参数
  v_医嘱类型       Number;
  v_大输液给药途径 Varchar2(2000);
  v_来源科室       Varchar2(4000);
  v_Continue       Number := 1;
  v_Nodosage       Number := 0;
  v_保持上次批次   Number := 0;
  d_手工打包时间   Date;
  v_药品类型       Varchar2(20);
  n_打包药品批次   Number(1);
  n_特殊药品批次   Number(1);
  n_优先级         Number := 999;
  n_自动排批       Number := 0;
  n_科室id         Number := 0;
  n_Row            Number(2);
  n_备用批次       Number := 0;
  n_剩余数量       Number := 0;
  n_单次数量       Number := 0;
  n_累计数量       Number := 0;
  n_医嘱id         Number := 0;
  n_填写数量       Number := 0;
  v_配药类型       Varchar2(20);
  v_时间串         Varchar2(100);
  v_时间值         Date;
  v_Fields         Varchar2(100);
  v_是否改变       Varchar2(20);
  v_时间串1        Varchar2(100);
  Err_Item Exception;

  Cursor c_医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id As 相关id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id, Nvl(c.执行标记, 0) As 是否tpn
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C, Table(f_Num2list(医嘱id_In)) D
    Where e.医嘱id = b.Id And b.病人id = a.病人id And c.类别 = 'E' And c.操作类型 = '2' And c.执行分类 = 1 And b.诊疗项目id = c.Id And
          e.医嘱id = d.Column_Value And e.发送号 = 发送号_In
    Order By b.病人id, e.医嘱id, e.发送号;

  Cursor c_单个医嘱记录 Is
    Select /*+rule */
    Distinct e.医嘱id, e.发送号, b.频率间隔, b.间隔单位, b.执行时间方案, a.姓名, a.性别, a.年龄, a.住院号, a.当前床号 As 床号, a.当前病区id As 病人病区id,
             a.当前科室id As 病人科室id, e.首次时间, e.末次时间, b.开始执行时间, Nvl(e.发送数次, 0) As 次数, e.发送时间, Decode(b.医嘱期效, 0, 1, 2) As 医嘱类型,
             b.诊疗项目id As 给药途径, b.病人id
    From 病人医嘱发送 E, 病人医嘱记录 B, 病人信息 A, 诊疗项目目录 C
    Where e.医嘱id = b.Id And b.病人id = a.病人id And b.诊疗项目id = c.Id And b.相关id = v_相关id And e.发送号 = 发送号_In
    Order By e.医嘱id, e.发送号;

  Cursor c_收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_原始收发记录 Is
    Select Distinct c.Id As 收发id, c.序号, c.实际数量 As 数量, Nvl(e.是否不予配置, 0) As 是否不予配置, c.单据, c.No
    From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, 输液药品属性 E
    Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And c.药品id = e.药品id(+) And
          b.执行部门id + 0 = 部门id_In And c.单据 = 9 And c.审核日期 Is Null And a.相关id = v_相关id And b.发送号 = 发送号_In And c.序号 < 1000
    Order By c.No, c.序号;

  Cursor c_输液单记录 Is
    Select a.Id, a.执行时间, a.配药批次, a.医嘱id, d.发送时间
    From 输液配药记录 A, 病人医嘱记录 B, 配药工作批次 C, 病人医嘱发送 D
    Where a.医嘱id = b.Id And a.配药批次 = c.批次 And d.医嘱id = a.医嘱id And a.发送号 = d.发送号 And c.批次 <> 0 And c.药品类型 Is Null And
          b.病人id = n_病人id And a.操作状态 < 2 And a.执行时间 Between Trunc(v_时间值) And Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60;

  v_输液单记录   c_输液单记录%RowType;
  v_医嘱记录     c_医嘱记录%RowType;
  v_收发记录     c_收发记录%RowType;
  v_单个医嘱记录 c_单个医嘱记录%RowType;

  Function Zl_Getpivaworkbatch
  (
    执行时间_In In Date,
    发送时间_In In Date,
    药品类型_In In Varchar2 := Null
  ) Return Number As
  
    v_Exetime   Date;
    v_Starttime Date;
    v_Endtime   Date;
    v_Maxbatch  Number(2);
    v_Batch     Number;
    Cursor c_配药批次 Is
      Select 批次, 配药时间, 给药时间, 打包, 药品类型
      From 配药工作批次
      Where 启用 = 1 And 配置中心id = 部门id_In
      Order By 药品类型, 批次;
  
    v_配药批次 c_配药批次%RowType;
  Begin
    v_Exetime := To_Date(Substr(To_Char(执行时间_In, 'yyyy-mm-dd hh24:mi'), 12), 'hh24:mi');
  
    Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次 Where 启用 = 1 And 配置中心id = 部门id_In;
  
    For v_配药批次 In c_配药批次 Loop
      v_Batch := 0;
    
      --当天发送的医嘱发送到备用批次
      If (Trunc(执行时间_In) >= Trunc(v_Currdate) And Trunc(发送时间_In) < Trunc(执行时间_In)) Or n_备用批次 = 0 Then
        If v_配药批次.批次 <> '0' And
           ((Nvl(v_配药批次.药品类型, '0') <> '0' And v_配药批次.药品类型 = 药品类型_In) Or Nvl(v_配药批次.药品类型, '0') = '0') Then
          v_Starttime := To_Date(Substr(v_配药批次.给药时间, 1, Instr(v_配药批次.给药时间, '-') - 1), 'hh24:mi');
          v_Endtime   := To_Date(Substr(v_配药批次.给药时间, Instr(v_配药批次.给药时间, '-') + 1), 'hh24:mi');
        
          If v_Exetime >= v_Starttime And v_Exetime <= v_Endtime Then
            v_Batch := v_配药批次.批次;
            n_打包  := v_配药批次.打包;
            Exit When v_Batch > 0;
          End If;
        End If;
      End If;
    End Loop;
  
    If v_Batch = 0 And (n_打包药品批次 <> 1 Or n_备用批次 = 1) Then
      v_Batch := v_Maxbatch;
    End If;
    Return(v_Batch);
  End;

  Function Zl_Getfirst
  (
    配药id_In In Number,
    科室id_In In Number
  ) Return Number As
    n_First  Number;
    n_科室id Number;
    Cursor c_优先级 Is
      Select 科室id, 配药类型, 优先级, 频次
      From 输液药品优先级
      Where (科室id = 科室id_In Or 科室id = 0)
      Order By 科室id, 优先级 Desc;
  
    r_优先级 c_优先级%RowType;
  Begin
    n_First := 0;
    For r_优先级 In c_优先级 Loop
      If n_科室id <> 0 And r_优先级.科室id = 0 Then
        Exit;
      End If;
      n_科室id := r_优先级.科室id;
    
      For r_配药记录 In (Select Distinct d.配药类型, e.执行频次
                     From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C, 输液药品属性 D, 病人医嘱记录 E
                     Where a.医嘱id = e.Id And a.Id = b.记录id And b.收发id = c.Id And c.药品id = d.药品id And a.Id = 配药id_In) Loop
        If Instr(r_配药记录.配药类型, r_优先级.配药类型, 1) > 0 And (Instr(r_优先级.频次, r_配药记录.执行频次, 1) > 0 Or r_优先级.频次 = '所有频次') Then
          n_First := r_优先级.优先级;
          Exit;
        End If;
      End Loop;
    End Loop;
  
    If n_First = 0 Then
      n_First := 999;
    End If;
    Return(n_First);
  End;
Begin
  n_Count          := 0;
  v_医嘱类型       := Zl_To_Number(Nvl(zl_GetSysParameter('医嘱类型', 1345), 1));
  v_大输液给药途径 := Nvl(zl_GetSysParameter('输液给药途径', 1345), '');
  v_来源科室       := Nvl(zl_GetSysParameter('来源科室', 1345), '');
  v_保持上次批次   := Zl_To_Number(Nvl(zl_GetSysParameter('保持上次批次', 1345), 0));
  n_打包药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('单个药品，不予配置药品及根据给药时间没有配药批次的输液单默认为0批次并打包', 1345), 0));
  n_特殊药品批次   := Zl_To_Number(Nvl(zl_GetSysParameter('特殊药品按药品类型指定批次', 1345), 0));
  n_自动排批       := Zl_To_Number(Nvl(zl_GetSysParameter('启动自动排批', 1345), 0));
  n_备用批次       := Zl_To_Number(Nvl(zl_GetSysParameter('当天发送的医嘱产生的输液单全部到备用批次', 1345), 0));
  v_医嘱ids        := 医嘱id_In;
  v_当前病人       := '';
  n_发送次数       := 0;

  Select Trunc(Sysdate) Into v_Currdate From Dual;

  Select Max(Nvl(批次, 0)) + 1 Into v_Maxbatch From 配药工作批次;

  --检查当前病人的医嘱是否有今天需要执行的输液单是锁定状态的
  If Instr(v_医嘱ids, ',') = 0 Then
    v_Tansid := v_医嘱ids;
  Else
    v_Tansid := Substr(v_Tmp, 1, Instr(v_医嘱ids, ',') - 1);
  End If;

  Select Count(ID)
  Into n_Num
  From 输液配药记录
  Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
        医嘱id In
        (Select 相关id
         From 病人医嘱记录
         Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
        Rownum < 2;

  If n_Num > 0 Then
    Select 姓名
    Into v_当前病人
    From 输液配药记录
    Where 是否锁定 = 1 And 执行时间 Between Trunc(v_Currdate) And Trunc(v_Currdate + 1) - 1 / 24 / 60 / 60 And
          医嘱id In
          (Select 相关id
           From 病人医嘱记录
           Where 病人id = (Select 病人id From 病人医嘱记录 Where 相关id = v_Tansid And Rownum < 2) And (诊疗类别 = '5' Or 诊疗类别 = '6')) And
          Rownum < 2;
    Raise Err_Item;
  End If;

  --先将原收发记录的序号增大，新的收发记录产生后再删除
  --Update 药品收发记录
  --Set 序号 = 序号 + 10000
  --Where ID In (Select \*+rule *\
  --             Distinct c.Id
  --             From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D, Table(f_Num2list(医嘱id_In)) F
  --             Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
  --                   c.单据 = 9 And c.审核日期 Is Null And a.相关id = f.Column_Value And b.发送号 = 发送号_In And c.序号 < 10000);

  For v_医嘱记录 In c_医嘱记录 Loop
    v_Continue := 1;
    n_病人id   := v_医嘱记录.病人id;
    n_科室id   := v_医嘱记录.病人科室id;
  
    Select Count(1)
    Into v_Continue
    From 病人医嘱记录 A, 输液不配置药品 B, 住院费用记录 C
    Where c.收费细目id = b.药品id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id;
    If v_Continue = 0 Then
      v_Continue := 1;
    Else
      v_Continue := 0;
    End If;
  
    --参数控制产生输液单
    If (v_医嘱类型 = 1 And v_医嘱记录.医嘱类型 <> 1) Or (v_医嘱类型 = 2 And v_医嘱记录.医嘱类型 <> 2) Then
      v_Continue := 0;
    End If;
  
    If Not v_大输液给药途径 Is Null Then
      If Instr(',' || v_大输液给药途径 || ',', ',' || v_医嘱记录.给药途径 || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    If Not v_来源科室 Is Null Then
      If Instr(',' || v_来源科室 || ',', ',' || v_医嘱记录.病人科室id || ',') = 0 Then
        v_Continue := 0;
      End If;
    End If;
  
    v_药品类型 := Null;
    For r_药品类型 In (Select Decode(Nvl(d.抗生素, 0), 0, Decode(Nvl(d.是否肿瘤药, 0), 0, '', '肿瘤药'), '抗生素') 药品类型
                   From 病人医嘱记录 A, 药品规格 B, 住院费用记录 C, 药品特性 D
                   Where c.收费细目id = b.药品id And b.药名id = d.药名id And c.医嘱序号 = a.Id And a.相关id = v_医嘱记录.相关id) Loop
      If r_药品类型.药品类型 Is Not Null Then
        v_药品类型 := r_药品类型.药品类型;
      End If;
    End Loop;
  
    If v_药品类型 Is Null Then
      If v_医嘱记录.是否tpn = 2 Then
        v_药品类型 := '营养药';
      End If;
    End If;
  
    If v_Continue = 1 Then
      v_Old相关id := v_New相关id;
      v_相关id    := v_医嘱记录.相关id;
      v_New相关id := v_相关id;
      v_发送号    := v_医嘱记录.发送号;
      v_序号      := 0;
    
      If v_Continue = 1 Then
        --v_Count := Zl_Gettransexenumber(v_医嘱记录.开始执行时间, v_医嘱记录.首次时间, v_医嘱记录.末次时间, v_医嘱记录.频率间隔, v_医嘱记录.间隔单位, v_医嘱记录.执行时间方案);
        Select Count(医嘱id)
        Into v_Count
        From 医嘱执行时间
        Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号;
      
        v_Nodosage := 0;
      
        For I In 1 .. v_Count Loop
          Select 输液配药记录_Id.Nextval Into v_配药id From Dual;
          v_序号 := v_序号 + 1;
        
          If I > 1 Then
            --从医嘱执行时间表中取医嘱的执行时间
            Select 要求时间
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 要求时间 > v_执行时间 And Rownum = 1
            Order By 要求时间;
          Else
            Select Min(要求时间)
            Into v_执行时间
            From 医嘱执行时间
            Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And Rownum = 1
            Order By 要求时间;
          End If;
        
          v_批次 := 0;
        
          If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
            b_Change := True;
          End If;
        
          If b_Change = True Then
            If d_Old执行时间 <> Trunc(v_执行时间) Or d_Old执行时间 Is Null Then
              d_Old执行时间 := v_执行时间;
            
              Select Count(Distinct a.摆药单号)
              Into n_摆药单
              From 输液配药记录 A
              Where a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = v_医嘱记录.病人id And 相关id Is Null) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And 操作状态 >= 2 And 操作状态 < 9;
            
              If n_摆药单 > 1 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                     
                      执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              
              End If;
            End If;
          End If;
        
          If b_Change = True Then
            n_病人id := v_医嘱记录.病人id;
            Select Count(ID)
            
            Into n_Sum
            From 输液配药记录
            Where 医嘱id = v_医嘱记录.相关id And 执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            If n_Sum = 0 Then
              Update 输液配药记录
              Set 是否调整批次 = 1
              Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And
                   
                    执行时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
              b_Change := False;
            
            End If;
          
            If b_Change = True Then
              --检查输液单是否调整到打包状态
              Select Count(a.Id)
              Into n_Sum
              From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
              Where a.Id = b.记录id And b.收发id = c.Id And
                    a.医嘱id In (Select ID
                               From 病人医嘱记录
                               Where 病人id = (Select 病人id From 病人医嘱记录 Where ID = v_医嘱记录.相关id And Rownum < 2)) And
                    a.执行时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60 And a.打包时间 Is Not Null;
              If n_Sum <> 0 Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            
              Select Count(医嘱id)
              Into n_Cur
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间) And Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60;
            
              Select Count(医嘱id)
              Into n_Sum
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 Between Trunc(v_执行时间 - 1) And Trunc(v_执行时间) - 1 / 24 / 60 / 60;
            
              If n_Sum <> n_Cur Then
                Update 输液配药记录
                Set 是否调整批次 = 1
                Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_执行时间) And
                      Trunc(v_执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
                b_Change := False;
              End If;
            End If;
          End If;
        
          If v_时间串 <> Trunc(Sysdate) || ';false\' Or v_时间串 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate) Then
              If b_Change = False Then
                v_时间串 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_时间串1 <> Trunc(Sysdate + 1) || ';false\' Or v_时间串1 Is Null Then
            If Trunc(v_执行时间) = Trunc(Sysdate + 1) Then
              If b_Change = False Then
                v_时间串1 := Trunc(v_执行时间) || ';false\';
              Else
                v_时间串1 := Trunc(v_执行时间) || ';true\';
              End If;
            End If;
          End If;
        
          If v_药品类型 Is Null Or n_特殊药品批次 = 0then v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate) ; Else
          --药品类型不为空，直接根据药品类型匹配批次
           v_批次 := Zl_Getpivaworkbatch(v_执行时间, Sysdate, v_药品类型) ; End If ;
          
            Select Count(医嘱id)
              Into n_发送次数
              From 医嘱执行时间
              Where 医嘱id = v_医嘱记录.相关id And 要求时间 <= v_执行时间
              Order By 要求时间;
              
              If n_发送次数 > 99
           Then
            n_发送次数 := Mod(n_发送次数, 99);
          End If;
        
          If Length(v_医嘱记录.相关id) > 9 Then
            If n_发送次数 < 10 Then
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr(To_Char(v_医嘱记录.相关id), Length(v_医嘱记录.相关id) - 8) || To_Char(v_医嘱记录.相关id) ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          Else
            If n_发送次数 < 10 Then
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || '0' ||
                      To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            Else
              Select '91' || Substr('000000000', Length(v_医嘱记录.相关id) + 1) || To_Char(v_医嘱记录.相关id) || To_Char(n_发送次数)
              Into v_Maxno
              From Dual;
            End If;
          End If;
          n_调整批次 := 0;
          If b_Change = False Then
            n_调整批次 := 1;
          End If;
        
          If v_批次 <> 0 Then
            Select Nvl(Max(打包), 0), Max(药品类型)
            Into n_打包, v_配药类型
            From 配药工作批次
            Where 批次 = v_批次 And 配置中心id = 部门id_In;
          End If;
        
          If (Trunc(v_执行时间) <= v_Currdate Or n_打包 <> 0) And v_配药类型 Is Null Then
            n_是否打包     := 1;
            d_手工打包时间 := Null;
          Else
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          --如果是TPN不管其他条件如何都设置为配置
          If v_医嘱记录.是否tpn = 2 Then
            n_是否打包     := 0;
            d_手工打包时间 := Null;
          End If;
        
          If v_批次 = 0 Then
            n_是否打包 := 1;
          End If;
          --产生配药记录
          Insert Into 输液配药记录
            (ID, 部门id, 序号, 姓名, 性别, 年龄, 住院号, 床号, 病人病区id, 病人科室id, 执行时间, 医嘱id, 发送号, 配药批次, 瓶签号, 是否调整批次, 是否打包, 打包时间, 操作状态,
             操作人员, 操作时间)
          Values
            (v_配药id, 部门id_In, v_序号, v_医嘱记录.姓名, v_医嘱记录.性别, v_医嘱记录.年龄, v_医嘱记录.住院号, v_医嘱记录.床号, v_医嘱记录.病人病区id,
             v_医嘱记录.病人科室id, v_执行时间, v_医嘱记录.相关id, v_医嘱记录.发送号, v_批次, v_Maxno, n_调整批次, n_是否打包, d_手工打包时间, 1, 核查人_In, 核查时间_In);
        
          Insert Into 输液配药状态 (配药id, 操作类型, 操作人员, 操作时间) Values (v_配药id, 1, 核查人_In, 核查时间_In);
        
          For v_单个医嘱记录 In c_单个医嘱记录 Loop
            n_医嘱id   := v_单个医嘱记录.医嘱id;
            n_累计数量 := 0;
            n_剩余数量 := 0;
          
            Select Sum(c.实际数量)
            Into n_Sum
            From 病人医嘱记录 A, 病人医嘱发送 B, 药品收发记录 C, 住院费用记录 D
            Where a.Id = b.医嘱id And c.费用id = d.Id And a.Id = d.医嘱序号 And b.No = c.No And b.执行部门id + 0 = 部门id_In And
                  c.单据 = 9 And c.审核日期 Is Null And a.Id = n_医嘱id And b.发送号 = v_医嘱记录.发送号 And c.序号 < 1000;
          
            --产生配药记录对应的药品记录
            For v_收发记录 In c_收发记录 Loop
              If v_收发记录.是否不予配置 = 1 Then
                v_Nodosage := 1;
              End If;
            
              Select 药品收发记录_Id.Nextval Into n_Lngid From Dual;
              n_累计数量 := n_累计数量 + v_收发记录.数量;
            
              If n_剩余数量 = 0 Then
                n_剩余数量 := n_Sum / v_Count;
              End If;
              n_单次数量 := n_Sum / v_Count;
            
              If n_累计数量 >= n_Sum / v_Count * I Then
                n_Count := n_Count + 1;
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_剩余数量, n_剩余数量, 成本价, 成本价 * n_剩余数量, 扣率, 零售价, 零售价 * n_剩余数量, 差价 * (实际数量 / n_剩余数量),
                         '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式,
                         发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_剩余数量);
              
                n_剩余数量 := 0;
                Exit;
              Elsif n_累计数量 > (n_Sum / v_Count * (I - 1)) Then
                n_Count    := n_Count + 1;
                n_填写数量 := n_累计数量 - (n_Sum / v_Count * (I - 1)) - (n_单次数量 - n_剩余数量);
                Insert Into 药品收发记录
                  (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 付数, 填写数量, 实际数量,
                   成本价, 成本金额, 扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期,
                   灭菌效期, 产品合格证, 发药方式, 发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间)
                  Select n_Lngid, 记录状态, 单据, NO, n_Count + 1000, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号,
                         生产日期, 效期, 付数, n_填写数量, n_填写数量, 成本价, 成本价 * n_填写数量, 扣率, 零售价, 零售价 * n_填写数量, 差价 * (实际数量 / n_填写数量),
                         '复制', 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 价格id, 费用id, 单量, 频次, 用法, 外观, 灭菌日期, 灭菌效期, 产品合格证, 发药方式,
                         发药窗口, 领用人, 批准文号, 汇总发药号, 注册证号, 库房货位, 商品条码, 内部条码, 核查人, 核查日期, 签到确认人, 签到时间
                  
                  From 药品收发记录
                  Where ID = v_收发记录.收发id;
              
                Insert Into 输液配药内容 (记录id, 收发id, 数量) Values (v_配药id, n_Lngid, n_填写数量);
              
                n_剩余数量 := n_剩余数量 - n_填写数量;
              End If;
            End Loop;
          End Loop;
          n_优先级 := Zl_Getfirst(v_配药id, v_医嘱记录.病人科室id);
          Update 输液配药记录 Set 优先级 = n_优先级 Where ID = v_配药id;
        
        End Loop;
      
        For v_收发记录 In c_原始收发记录 Loop
          n_单据 := v_收发记录.单据;
        
          v_No := v_收发记录.No;
          Delete From 药品收发记录 Where ID = v_收发记录.收发id;
        End Loop;
      
        --单个药品或者不予配置的药品默认为0批次
        Select Count(收发id) Into n_Row From 输液配药内容 Where 记录id = v_配药id;
        If (v_Nodosage = 1 Or n_Row = 1) And n_打包药品批次 = 1 Then
          Update 输液配药记录
          Set 配药批次 = 0, 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
        --如果存在“不予配置”属性的药品，也设置为打包
        If v_Nodosage = 1 Then
          Update 输液配药记录
          Set 是否打包 = 1
          Where 医嘱id = v_医嘱记录.相关id And 发送号 = v_医嘱记录.发送号 And 操作状态 < 2;
        End If;
      End If;
    End If;
  End Loop;

  For v_收发记录 In (Select ID From 药品收发记录 Where 序号 < 1000 And 单据 = n_单据 And NO = v_No) Loop
    n_Count := n_Count + 1;
    Update 药品收发记录 Set 序号 = n_Count + 1000, 摘要 = '复制' Where ID = v_收发记录.Id;
  End Loop;

  Update 药品收发记录
  Set 序号 = 序号 - 1000, 摘要 = '医嘱发送'
  Where 摘要 = '复制' And 序号 > 1000 And 单据 = n_单据 And NO = v_No;

  If n_备用批次 = 1 Then
  
    Select Count(a.Id)
    Into n_Sum
    From 输液配药记录 A, 病人医嘱发送 B
    Where a.医嘱id = b.医嘱id And a.发送号 = b.发送号 And
          a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null) And b.发送时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And a.执行时间 Between Trunc(Sysdate) And
          Trunc(Sysdate + 1) - 1 / 24 / 60 / 60 And 操作状态 < 9;
    If n_Sum <> 0 Then
      b_Change  := False;
      v_时间串1 := Trunc(Sysdate + 1) || ';false\';
    
      Update 输液配药记录
      Set 是否调整批次 = 1
      Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(Sysdate + 1) And
            Trunc(Sysdate + 2) - 1 / 24 / 60 / 60 And 操作状态 < 2;
    End If;
  End If;
  If v_时间串 Is Null Then
    v_时间串 := v_时间串1;
  Else
    v_时间串 := v_时间串 || v_时间串1;
  End If;

  While v_时间串 Is Not Null Loop
    --分解单据ID串
    v_Fields   := Substr(v_时间串, 1, Instr(v_时间串, '\') - 1);
    v_时间值   := Substr(v_Fields, 1, Instr(v_Fields, ';') - 1);
    v_是否改变 := Substr(v_Fields, Instr(v_Fields, ';') + 1);
  
    v_时间串 := Replace('\' || v_时间串, '\' || v_Fields || '\');
  
    If v_是否改变 = 'true' Then
      b_Change := True;
    Else
      b_Change := False;
    End If;
  
    If b_Change = True Then
      Select Count(医嘱id)
      Into n_Cur
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值) And
                   Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
      Select Count(医嘱id)
      Into n_Sum
      From (Select Distinct a.要求时间, a.医嘱id
             From 医嘱执行时间 A, 输液配药记录 B
             Where a.要求时间 = b.执行时间 And a.医嘱id = b.医嘱id And a.要求时间 Between Trunc(v_时间值 - 1) And
                   Trunc(v_时间值) - 1 / 24 / 60 / 60 And
                   a.医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id And 相关id Is Null));
    
      If n_Cur <> n_Sum Then
        Update 输液配药记录
        Set 是否调整批次 = 1
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_时间值) And
              Trunc(v_时间值 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
        b_Change := False;
      End If;
    End If;
  
    If v_保持上次批次 = 1 And b_Change = True Then
      For v_输液单记录 In c_输液单记录 Loop
        Begin
          Select Distinct 配药批次
          Into v_批次
          From 输液配药记录 A, 输液配药内容 B, 药品收发记录 C
          Where a.Id = b.记录id And b.收发id = c.Id And a.医嘱id = v_输液单记录.医嘱id And
                To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_输液单记录.执行时间, 'hh24:mi:ss') And
                a.执行时间 Between Trunc(v_输液单记录.执行时间 - 1) And Trunc(v_输液单记录.执行时间) - 1 / 24 / 60 / 60 And Rownum = 1;
        Exception
          When Others Then
            Begin
              Select Distinct 配药批次
              Into v_批次
              From 输液配药记录 A
              Where a.医嘱id = v_输液单记录.医嘱id And To_Char(a.执行时间, 'hh24:mi:ss') = To_Char(v_输液单记录.执行时间, 'hh24:mi:ss') And
                    a.操作状态 <> 12 And a.执行时间 Between Trunc(v_输液单记录.执行时间 - 1) And Trunc(v_输液单记录.执行时间) - 1 / 24 / 60 / 60 And
                    Rownum = 1;
            Exception
              When Others Then
                v_批次 := v_输液单记录.配药批次;
            End;
        End;
      
        Update 输液配药记录
        Set 是否确认调整 = 0, 是否调整批次 = 0
        Where 医嘱id In (Select ID From 病人医嘱记录 Where 病人id = n_病人id) And 执行时间 Between Trunc(v_输液单记录.执行时间) And
              Trunc(v_输液单记录.执行时间 + 1) - 1 / 24 / 60 / 60 And 操作状态 < 2;
      
        If v_输液单记录.配药批次 <> v_批次 Then
          Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
          Select Nvl(Max(打包), 0) Into n_打包 From 配药工作批次 Where 批次 = v_批次 And 配置中心id = 部门id_In;
          If n_打包 <> 0 Then
            Update 输液配药记录 Set 是否打包 = n_打包 Where ID = v_输液单记录.Id;
          Else
            Select Nvl(Max(打包), 0)
            Into n_打包
            From 配药工作批次
            Where 批次 = v_输液单记录.配药批次 And 配置中心id = 部门id_In;
          
            If n_打包 <> 0 Then
              Update 输液配药记录 Set 是否打包 = 0 Where ID = v_输液单记录.Id;
            End If;
          End If;
        End If;
      End Loop;
    End If;
  
    If n_自动排批 = 1 And (b_Change = False Or v_保持上次批次 = 0) Then
      For v_输液单记录 In c_输液单记录 Loop
        v_批次 := Zl_Getpivaworkbatch(v_输液单记录.执行时间, v_输液单记录.发送时间);
        Update 输液配药记录 Set 配药批次 = v_批次 Where ID = v_输液单记录.Id;
      End Loop;
      Zl_输液配药记录_自动排批(n_病人id, n_科室id, 部门id_In, v_时间值);
    End If;
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]病人' || v_当前病人 || '在输液配置中心有被锁定的输液单，发送失败！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_输液配药记录_核查;
/

--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品盘点_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  批次_In       In 药品收发记录.批次%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  入出系数_In   In 药品收发记录.入出系数%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  帐面数量_In   In 药品收发记录.填写数量%Type,
  实盘数量_In   In 药品收发记录.扣率%Type,
  数量差_In     In 药品收发记录.实际数量%Type,
  售价_In       In 药品收发记录.零售价%Type,
  金额差_In     In 药品收发记录.零售金额%Type,
  差价差_In     In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  盘点时间_In   In 药品收发记录.频次%Type := Null,
  库存金额_In   In 药品收发记录.成本价%Type := Null,
  库存差价_In   In 药品收发记录.成本金额%Type := Null,
  成本价_In     In 药品收发记录.单量%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  新批次_In     In Number := 0,
  库房货位_In   In 药品收发记录.库房货位%Type := Null
) Is
  v_Lngid        Number(18);
  n_上次供应商id 药品库存.上次供应商id%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_批次         药品收发记录.批次%Type;
  n_药库分批     Integer; --是否药库分批    1:分批;0：不分批
  n_药房分批     Integer; --是否药库分批    1:分批;0：不分批
Begin
  --如果批次_IN为-1,则表示新产生一个批次药品
  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Begin
    Select 上次供应商id, 上次生产日期
    Into n_上次供应商id, d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      n_上次供应商id := Null;
      d_上次生产日期 := Null;
  End;
  If 批次_In = -1 Then
    --判断分批属性，根据分批属性生成对应批次
    Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into n_药库分批, n_药房分批 From 药品规格 Where 药品id = 药品id_In;
    If n_药房分批 = 0 Then
      If n_药库分批 = 1 Then
        Begin
          Select Distinct 0
          Into n_药库分批
          From 部门性质说明
          Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
        Exception
          When Others Then
            n_药库分批 := 1;
        End;
      
        If n_药库分批 = 1 Then
          n_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 售价_In, v_Lngid, n_上次供应商id);
        Else
          n_批次 := 0;
        End If;
      End If;
    Else
      n_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 售价_In, v_Lngid, n_上次供应商id);
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 扣率, 实际数量, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 频次,
     成本价, 成本金额, 单量, 批准文号, 供药单位id, 生产日期, 发药方式, 库房货位)
  Values
    (v_Lngid, 1, 12, No_In, 序号_In, 库房id_In, 入出类别id_In, 入出系数_In, 药品id_In, n_批次, 产地_In, 批号_In, 效期_In, 帐面数量_In, 实盘数量_In,
     数量差_In, 售价_In, 金额差_In, 差价差_In, 摘要_In, 填制人_In, 填制日期_In, 盘点时间_In, 库存金额_In, 库存差价_In, 成本价_In, 批准文号_In, n_上次供应商id,
     d_上次生产日期, 新批次_In, 库房货位_In);

  --入出系数=-1的需要下库存
  Zl_药品库存_Update(v_Lngid, 0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点_Insert;
/

--109990:刘涛,2018-01-12,药品批号对照
Create Or Replace Procedure Zl_药品盘点记录单_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  批次_In       In 药品收发记录.批次%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  入出系数_In   In 药品收发记录.入出系数%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  帐面数量_In   In 药品收发记录.填写数量%Type,
  实盘数量_In   In 药品收发记录.扣率%Type,
  数量差_In     In 药品收发记录.实际数量%Type,
  售价_In       In 药品收发记录.零售价%Type,
  金额差_In     In 药品收发记录.零售金额%Type,
  差价差_In     In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  盘点时间_In   In 药品收发记录.频次%Type := Null,
  库存金额_In   In 药品收发记录.成本价%Type := Null,
  库存差价_In   In 药品收发记录.成本金额%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  成本价_In     In 药品收发记录.单量%Type := Null,
  库房货位_In   In 药品收发记录.库房货位%Type := Null
) Is
  v_批次 药品收发记录.批次%Type;
Begin
  v_批次 := 批次_In;
  If v_批次 < 0 Then
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 售价_In, 批次_In, Null);
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 扣率, 实际数量, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 频次,
     成本价, 成本金额, 批准文号, 单量, 库房货位)
  Values
    (药品收发记录_Id.Nextval, 1, 14, No_In, 序号_In, 库房id_In, 入出类别id_In, 入出系数_In, 药品id_In, v_批次, 产地_In, 批号_In, 效期_In, 帐面数量_In,
     实盘数量_In, 数量差_In, 售价_In, 金额差_In, 差价差_In, 摘要_In, 填制人_In, 填制日期_In, 盘点时间_In, 库存金额_In, 库存差价_In, 批准文号_In, 成本价_In, 库房货位_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品盘点记录单_Insert;
/

--119508:刘涛,2018-03-14,提示出哪个药品不允许负数出库
--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品移库_Insert
(
  No_In           In 药品收发记录.No%Type,
  序号_In         In 药品收发记录.序号%Type,
  库房id_In       In 药品收发记录.库房id%Type,
  对方部门id_In   In 药品收发记录.对方部门id%Type,
  药品id_In       In 药品收发记录.药品id%Type,
  批次_In         In 药品收发记录.批次%Type,
  填写数量_In     In 药品收发记录.填写数量%Type,
  实际数量_In     In 药品收发记录.实际数量%Type,
  成本价_In       In 药品收发记录.成本价%Type,
  成本金额_In     In 药品收发记录.成本金额%Type,
  零售价_In       In 药品收发记录.零售价%Type,
  零售金额_In     In 药品收发记录.零售金额%Type,
  差价_In         In 药品收发记录.差价%Type,
  填制人_In       In 药品收发记录.填制人%Type,
  产地_In         In 药品收发记录.产地%Type := Null,
  批号_In         In 药品收发记录.批号%Type := Null,
  效期_In         In 药品收发记录.效期%Type := Null,
  摘要_In         In 药品收发记录.摘要%Type := Null,
  填制日期_In     In 药品收发记录.填制日期%Type := Null,
  上次供应商id_In In 药品收发记录.供药单位id%Type := Null,
  批准文号_In     In 药品收发记录.批准文号%Type := Null,
  申领方式_In     In 药品收发记录.单量%Type := Null,
  结束时间_In     In 药品收发记录.频次%Type := Null
) Is
  v_Lngid        药品收发记录.Id%Type; --收发ID
  n_出库收发id   药品收发记录.Id%Type; --出库库房收发id
  v_入的类别id   药品收发记录.入出类别id%Type; --入出类别ID
  v_出的类别id   药品收发记录.入出类别id%Type; --入出类别ID
  v_批次         药品收发记录.批次%Type := Null; --主要针对入库中实行药库分批的药品
  v_是否分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  v_药库分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  v_药房分批     Integer; --判断入库是否药库分批   1:分批；0：不分批
  d_上次生产日期 药品库存.上次生产日期%Type;
  n_检查方式     药品出库检查.检查方式%Type;
  n_可用数量     药品库存.可用数量%Type;
  v_Error        Varchar2(255);
  Err_Custom Exception;
  v_下可用库存 Zlparameters.参数值%Type;
  v_药品信息   Varchar2(255);
Begin
  Select Nvl(检查方式, 0) Into n_检查方式 From 药品出库检查 Where 库房id = 库房id_In;

  Select b.Id
  Into v_入的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = 1 And Rownum < 2;
  Select b.Id
  Into v_出的类别id
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 6 And b.系数 = -1 And Rownum < 2;

  Begin
    Select 上次生产日期
    Into d_上次生产日期
    From 药品库存
    Where 性质 = 1 And 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(批次_In, 0);
  Exception
    When Others Then
      d_上次生产日期 := Null;
  End;
  Select 药品收发记录_Id.Nextval Into n_出库收发id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次)
  Values
    (n_出库收发id, 1, 6, No_In, 序号_In, 库房id_In, 对方部门id_In, v_出的类别id, -1, 药品id_In, 批次_In, 产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In);

  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_药库分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  v_是否分批 := 0;
  If v_药房分批 = 0 Then
    If v_药库分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_是否分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 对方部门id_In;
      Exception
        When Others Then
          v_是否分批 := 1;
      End;
    End If;
  Else
    v_是否分批 := 1;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  If v_是否分批 = 1 And Nvl(批次_In, 0) = 0 Then
    --入库分批且出库不分批
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 上次供应商id_In);
  Elsif v_是否分批 = 0 Then
    --入库不分批
    v_批次 := 0;
  Elsif Nvl(批次_In, 0) <> 0 Then
    --入库分批且出库也分批
    v_批次 := 批次_In;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要,
     填制人, 填制日期, 供药单位id, 批准文号, 生产日期, 单量, 频次)
  Values
    (v_Lngid, 1, 6, No_In, 序号_In + 1, 对方部门id_In, 库房id_In, v_入的类别id, 1, 药品id_In, v_批次, 产地_In, 批号_In, 效期_In, 填写数量_In,
     实际数量_In, 成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 上次供应商id_In, 批准文号_In, d_上次生产日期, 申领方式_In,
     结束时间_In);
  --处理库存
  Zl_药品库存_Update(n_出库收发id, 0);

  --根据参数决定是否下发药库房的可用库存
  Select Zl_Getsysparameter(96) Into v_下可用库存 From Dual;

  If v_下可用库存 = '1' Then
    If n_检查方式 = 2 Then
      --只有参数明确禁止时才不让负数的通过
      Select 可用数量
      Into n_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
      If n_可用数量 < 0 Then
        Select '[' || 编码 || ']' || 名称 Into v_药品信息 From 收费项目目录 Where ID = 药品id_In;
        v_Error := '库存检查情况下，不允许负库存出库(' || v_药品信息 || ')！';
        Raise Err_Custom;
      End If;
    End If;
  End If;

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品移库_Insert;
/

--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品其他入库_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  入出类别id_In In 药品收发记录.入出类别id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  实际数量_In   In 药品收发记录.实际数量%Type,
  成本价_In     In 药品收发记录.成本价%Type,
  成本金额_In   In 药品收发记录.成本金额%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  零售金额_In   In 药品收发记录.零售金额%Type,
  差价_In       In 药品收发记录.差价%Type,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  外观_In       In 药品收发记录.外观%Type := Null,
  金额差_In     In 药品收发记录.零售金额%Type := Null
) Is
  v_Lngid    药品收发记录.Id%Type; --收发ID
  v_入出系数 药品收发记录.入出系数%Type;
  v_批次     药品收发记录.批次%Type := Null; --批次
  v_药库分批 Integer; --是否药库分批    1:分批;0：不分批
  v_药房分批 Integer; --是否药库分批    1:分批;0：不分批
  v_时价分批 Number(1);

Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 药品id_In And 厂家名称 = 产地_In;
  End If;
  If Sql%RowCount = 0 And Not 产地_In Is Null And Not 批准文号_In Is Null Then
    Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (药品id_In, 产地_In, 批准文号_In);
  End If;

  v_入出系数 := 1;
  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
  Select Nvl(药库分批, 0), Nvl(药房分批, 0) Into v_药库分批, v_药房分批 From 药品规格 Where 药品id = 药品id_In;

  If v_药房分批 = 0 Then
    If v_药库分批 = 1 Then
      Begin
        Select Distinct 0
        Into v_药库分批
        From 部门性质说明
        Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
      Exception
        When Others Then
          v_药库分批 := 1;
      End;
    
      If v_药库分批 = 1 Then
        v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In,v_Lngid, Null);
      End If;
    End If;
  Else
    v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In,v_Lngid, Null);
  End If;

  Select Nvl(是否变价, 0) Into v_时价分批 From 收费项目目录 Where ID = 药品id_In;

  If v_时价分批 = 1 And v_批次 > 0 Then
    v_时价分批 := 1;
  Else
    v_时价分批 := 0;
  End If;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 零售金额, 差价, 摘要, 填制人,
     填制日期, 生产日期, 批准文号, 外观, 用法)
  Values
    (v_Lngid, 1, 4, No_In, 序号_In, 库房id_In, 入出类别id_In, v_入出系数, 药品id_In, v_批次, 产地_In, 批号_In, 效期_In, 实际数量_In, 实际数量_In,
     成本价_In, 成本金额_In, 零售价_In, 零售金额_In, 差价_In, 摘要_In, 填制人_In, 填制日期_In, 生产日期_In, 批准文号_In, 外观_In,
     Decode(v_时价分批, 1, 金额差_In, Null));
  --更新库存
  Zl_药品库存_Update(v_Lngid, 0);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品其他入库_Insert;
/

--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Procedure Zl_药品外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  对方部门id_In In 药品收发记录.对方部门id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  外观_In       In 药品收发记录.外观%Type := Null,
  产品合格证_In In 药品收发记录.产品合格证%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  金额差_In     In 药品收发记录.零售金额%Type := Null,
  加成率_In     In 药品收发记录.频次%Type := Null,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  计划id_In     In 药品收发记录.计划id%Type := Null,
  财务审核_In   In Number := 0,
  验收结论_In   In 药品收发记录.验收结论%Type := Null
) Is
  v_No         应付记录.No%Type; --应付记录的NO
  v_商品名     收费项目目录.名称%Type; --通用名称
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID
  v_应付id     应付记录.Id%Type; --应付记录的ID
  v_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID
  v_入出系数   药品收发记录.入出系数%Type; --入出系数
  v_批次       药品收发记录.批次%Type := Null; --批次
  v_药库分批   Integer; --是否药库分批    1:分批；0：不分批
  v_药房分批   Integer; --是否药房分批       1:分批；0：不分批
  v_指导批价   药品规格.指导批发价%Type;
  v_时价分批   Number(1);

  Err_Msg Varchar2(255);
  Err_Noenough Exception;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 药品id_In And 厂家名称 = 产地_In;
  End If;
  If Sql%RowCount = 0 And Not 产地_In Is Null And Not 批准文号_In Is Null Then
    Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (药品id_In, 产地_In, 批准文号_In);
  End If;

  --取该药品的商品名
  v_产地 := '';
  Select 名称, 规格, 计算单位, Nvl(是否变价, 0)
  Into v_商品名, v_规格, v_单位, v_时价分批
  From 收费项目目录
  Where ID = 药品id_In;
  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;
  Select Nvl(药库分批, 0), Nvl(药房分批, 0), Nvl(指导批发价, 0)
  Into v_药库分批, v_药房分批, v_指导批价
  From 药品规格
  Where 药品id = 药品id_In;

  --财务审核_in=0表示普通入库，财务审核_in=1表示是财务审核产生新单据，如果是财务审核模式不需要重新产生批次
  If 财务审核_In = 0 Then
    If v_药房分批 = 0 Then
      If v_药库分批 = 1 Then
        Begin
          Select Distinct 0
          Into v_药库分批
          From 部门性质说明
          Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
        Exception
          When Others Then
            v_药库分批 := 1;
        End;
      
        If v_药库分批 = 1 Then
          v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 供药单位id_In);
        End If;
      End If;
    Else
      v_批次 := Zl_Fun_Getbatchnum(药品id_In, 产地_In, 批号_In, 成本价_In, 零售价_In, v_Lngid, 供药单位id_In);
    End If;
  Else
    v_批次 := 批次_In;
  End If;

  If v_时价分批 = 1 And v_批次 > 0 Then
    v_时价分批 := 1;
  Else
    v_时价分批 := 0;
  End If;

  Select b.Id, b.系数
  Into v_入出类别id, v_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 1 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 对方部门id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价,
     零售金额, 差价, 摘要, 填制人, 填制日期, 配药人, 配药日期, 发药方式, 单量, 外观, 产品合格证, 生产日期, 批准文号, 用法, 频次, 计划id, 验收结论)
  Values
    (v_Lngid, 1, 1, No_In, 序号_In, 库房id_In, 供药单位id_In, v_入出类别id, 对方部门id_In, v_入出系数, 药品id_In,
     Decode(退货_In, -1, 批次_In, v_批次), 产地_In, 批号_In, 效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In,
     扣率_In, 零售价_In, 退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, 核查人_In, 核查日期_In, Decode(退货_In, -1, 1, 0),
     v_指导批价, 外观_In, 产品合格证_In, 生产日期_In, 批准文号_In, Decode(退货_In, -1, Null, Decode(v_时价分批, 1, 金额差_In, Null)), 加成率_In,
     计划id_In, 验收结论_In);
  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
    --如果是第一笔明细,则产生应付记录的NO
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 1 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
    Select 应付记录_Id.Nextval Into v_应付id From Dual;
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人,
       填制日期, 审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 库房id, 发票修改时间, 发票代码)
    Values
      (v_应付id, 0, 1, 供药单位id_In, v_No, 1, v_Lngid, No_In, 退货_In * 零售金额_In, 发票号_In, 发票日期_In,
       退货_In * Decode(Nvl(发票金额_In, 0), 0, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 药品id_In, 序号_In, 随货单号_In, 库房id_In, Sysdate, 发票代码_In);
  End If;
  --调用库存更新过程
  Zl_药品库存_Update(v_Lngid, 0);
Exception
  When Err_Noenough Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Insert;
/

--109990:刘涛,2018-01-12,药品批号对照修改
Create Or Replace Function Zl_Fun_Getbatchnum
(
  药品id_In   药品批号对照.药品id%Type,
  生产厂家_In 药品批号对照.生产厂家%Type,
  批号_In     药品批号对照.批号%Type,
  成本价_In   药品批号对照.成本价%Type,
  售价_In     药品批号对照.售价%Type,
  新批次_In   药品批号对照.批次%Type,
  供应商ID_In   药品批号对照.供应商ID%Type
) Return Number Is
  --功能：药品入库产生入库记录时根据传递过来的参数找对应的批次
  --返回值：查询到的批次，如果批次>0则说明找到了批次,如果批次=0则说明没有找到
  --参数：
  --     生产厂家_in：入库传递过来的生产商
  --     批号_in：入库时录入的批号
  --     成本价_in 入库时的成本价
  --     售价_in  入库时的售价
  --
  n_批次     药品批号对照.批次%Type;
  n_药库包装 药品规格.药库包装%Type;
  n_是否变价 收费项目目录.是否变价%Type;
  n_Count    Number(1);
Begin
  --只处理生产厂家和批号不为空的情况
  If 生产厂家_In Is Not Null And 批号_In Is Not Null Then
    Begin
      Select 批次
      Into n_批次
      From 药品批号对照
      Where 药品id = 药品id_In And Nvl(生产厂家, 'a') = Nvl(生产厂家_In, 'a') And Nvl(批号, 'b') = Nvl(批号_In, 'b') And 成本价 = 成本价_In And
            售价 = 售价_In And Nvl(供应商id, 0) = Nvl(供应商id_In, 0);
    Exception
      When Others Then
        n_批次 := 新批次_In;
      
        If n_批次 > 0 Then
          --检查有无重复记录
          Begin
            Select 1
            Into n_Count
            From 药品批号对照
            Where 药品id = 药品id_In And Nvl(生产厂家, 'a') = Nvl(生产厂家_In, 'a') And Nvl(批号, 'b') = Nvl(批号_In, 'b') And
                  批次 = n_批次;
          Exception
            When Others Then
              n_Count := 0;
          End;
        
          --没有重复记录才能插入
          If n_Count = 0 Then
            Insert Into 药品批号对照
              (药品id, 生产厂家, 批号, 批次, 成本价, 售价,供应商ID)
            Values
              (药品id_In, 生产厂家_In, 批号_In, 新批次_In, 成本价_In, 售价_In,供应商ID_In);
          End If;
        End If;
    End;
  End If;

  Return(n_批次);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Fun_Getbatchnum;
/

--113721:刘涛,2018-01-11,材料盘点分批信息处理
Create Or Replace Procedure Zl_材料盘点_Verify
(
  No_In     In 药品收发记录.No%Type := Null,
  审核人_In In 药品收发记录.审核人%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  n_成本价     药品收发记录.成本价%Type;
  n_材料id     药品收发记录.药品id%Type;
  n_实价卫材   收费项目目录.是否变价%Type;
  n_平均成本价 药品库存.平均成本价%Type;

  n_Batch_Count Integer; --原不分批现在分批的材料的数量

Begin
  Update 药品收发记录
  Set 审核人 = 审核人_In, 审核日期 = Sysdate
  Where NO = No_In And 单据 = 22 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该单据已经被他人审核！[ZLSOFT]';
    Raise Err_Item;
  End If;

  For c_单据 In (Select ID, 实际数量, 零售价, 零售金额, 差价, 库房id, 药品id 材料id, 批次, 批号, 效期, 灭菌效期, 产地, 入出类别id, 入出系数, 供药单位id, 生产日期, 批准文号
               From 药品收发记录
               Where NO = No_In And 单据 = 22 And 记录状态 = 1
               Order By 材料id, 批次) Loop
  
    Select 是否变价 Into n_实价卫材 From 收费项目目录 Where ID = c_单据.材料id;
  
    --更改药品库存表的相应数据
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Decode(c_单据.入出系数, 1, Nvl(c_单据.实际数量, 0), 0),
        实际数量 = Nvl(实际数量, 0) + Nvl(c_单据.实际数量, 0) * c_单据.入出系数, 实际金额 = Nvl(实际金额, 0) + Nvl(c_单据.零售金额, 0) * c_单据.入出系数,
        实际差价 = Nvl(实际差价, 0) + Nvl(c_单据.差价, 0) * c_单据.入出系数,
        零售价 = Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, Decode(Nvl(零售价, 0), 0, c_单据.零售价, 零售价)), Null),
        上次批号 = c_单据.批号, 上次产地 = c_单据.产地, 效期 = c_单据.效期
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1;
  
    If Sql%NotFound Then
      If Nvl(c_单据.实际数量, 0) <> 0 Then
        n_成本价 := Round((Nvl(c_单据.零售金额, 0) - Nvl(c_单据.差价, 0)) / c_单据.实际数量, 7);
      Else
        n_成本价 := 0;
      End If;
    
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 效期, 灭菌效期, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 批准文号, 零售价,平均成本价)
      
      Values
        (c_单据.库房id, c_单据.材料id, c_单据.批次, 1, Decode(c_单据.入出系数, 1, Nvl(c_单据.实际数量, 0), 0), c_单据.实际数量 * c_单据.入出系数,
         c_单据.零售金额 * c_单据.入出系数, c_单据.差价 * c_单据.入出系数, c_单据.效期, c_单据.灭菌效期, c_单据.供药单位id, n_成本价, c_单据.批号, c_单据.生产日期, c_单据.产地,
         c_单据.批准文号, Decode(n_实价卫材, 1, Decode(Nvl(c_单据.批次, 0), 0, Null, c_单据.零售价), Null),n_成本价);
    End If;
  
    Delete From 药品库存
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  
    --重新计算平均成本价
    Update 药品库存
    Set 平均成本价 = Decode(Nvl(批次, 0), 0, decode((实际金额 - 实际差价) / 实际数量,0,上次采购价,(实际金额 - 实际差价) / 实际数量), 上次采购价)
    Where 库房id = c_单据.库房id And 药品id = c_单据.材料id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) And 性质 = 1 And Nvl(实际数量, 0) <> 0;
    If Sql%NotFound Then
      Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = c_单据.材料id;
      Update 药品库存
      Set 平均成本价 = n_平均成本价
      Where 药品id = c_单据.材料id And 库房id = c_单据.库房id And Nvl(批次, 0) = Nvl(c_单据.批次, 0) and 性质=1;
    End If;
  
  End Loop;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料盘点_Verify;
/

--119290:廖思奇,2018-01-09,Pacs排队叫号增加预呼功能。微调呼叫语句构成
Create Or Replace Function Zl_排队叫号队列_获取呼叫内容
(
  队列id_In   In 排队叫号队列.Id%Type,
  呼叫方式_In In Number
  --功能：获取语音播放时的播放内容 
  --参数： 
  --    呼叫方式_In:0-顺乎，1-直呼,2-广播,3-候诊呼叫 
) Return Varchar2 Is
  v_姓名     排队叫号队列.患者姓名%Type;
  v_诊室     排队叫号队列.诊室%Type;
  v_呼叫内容 Varchar2(1000);
Begin
  Select Zl_排队语音呼叫_多音字处理(a.患者姓名), a.诊室 Into v_姓名, v_诊室 From 排队叫号队列 A Where a.Id = 队列id_In;

  If 呼叫方式_In <> 3 Then
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '就诊';
  Else
    v_呼叫内容 := '  请、' || v_姓名 || '、  ' || v_姓名 || '  、到' || v_诊室 || '准备检查';
  End If;

  Return v_呼叫内容;
Exception
  When Others Then
    Return Null;
End Zl_排队叫号队列_获取呼叫内容;
/

--119475:刘鹏飞,2017-01-09,输血申请单预览打印调用
Create Or Replace Function Zl1_Fun_Bloodapplyprint
(
  医嘱id_In   病人医嘱记录.Id%Type,
  调用场合_In Number,
  申请类型_In Number,
  模式_In     Number
) Return Varchar2 As
  v_Return Varchar2(200);
Begin
  --功能说明:申请单预览打印时对医嘱的相关内容进行检查，并返回提示及处理结果。
  --入参说明：
  ----医嘱id_In=输血医嘱ID
  ----调用场合_in=1-门诊,2-住院
  ----申请类型_In=1-输血申请单;2-取血通知单(便于医院根据申请类型控制)
  ----模式_in:0=预览是调用；1-打印是调用
  --函数返回："处理结果|提示信息",处理结果=0-正常,1-询问提示,2-禁止；处理结果为0时，无需返回提示信息及分隔符。

  v_Return := Null;
  Return v_Return;
Exception
  When Others Then
    Zl_Errorcenter(Sqlcode, Sqlerrm);
End Zl1_Fun_Bloodapplyprint;
/

--118402:秦龙,2018-01-09,增加传参加成率
Create Or Replace Procedure Zl_卫生材料_Update
(
  诊疗id_In         In 材料特性.诊疗id%Type,
  材料id_In         In 材料特性.材料id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  标识主码_In       In 收费项目目录.标识主码%Type := Null,
  标识子码_In       In 收费项目目录.标识子码%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  材料来源_In       In 材料特性.材料来源%Type := Null,
  货源情况_In       In 材料特性.货源情况%Type := Null,
  散装单位_In       In 收费项目目录.计算单位%Type := Null,
  包装单位_In       In 材料特性.包装单位%Type := Null,
  换算系数_In       In 材料特性.换算系数%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 材料特性.指导批发价%Type := Null,
  扣率_In           In 材料特性.扣率%Type := 95,
  指导零售价_In     In 材料特性.指导零售价%Type := Null,
  指导差价率_In     In 材料特性.指导差价率%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  库房分批_In       In 材料特性.库房分批%Type := Null,
  在用分批_In       In 材料特性.在用分批%Type := Null,
  最大效期_In       In 材料特性.最大效期%Type := Null,
  灭菌效期_In       In 材料特性.灭菌效期%Type := Null,
  无菌性材料_In     In 材料特性.无菌性材料%Type := Null,
  一次性材料_In     In 材料特性.一次性材料%Type := Null,
  原材料_In         In 材料特性.原材料%Type := Null,
  差价让利比_In     In 材料特性.差价让利比%Type := 0,
  成本价_In         In 材料特性.成本价%Type := 0,
  跟踪在用_In       In 材料特性.跟踪在用%Type := Null,
  核算材料_In       In 材料特性.核算材料%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  批准文号_In       In 材料特性.批准文号%Type := Null,
  注册商标_In       In 材料特性.注册商标%Type := Null,
  注册证号_In       In 材料特性.注册证号%Type := Null,
  许可证号_In       In 材料特性.许可证号%Type := Null,
  许可证有效期_In   In 材料特性.许可证有效期%Type := Null,
  材质分类_In       In 材料特性.材质分类%Type := Null,
  存储条件_In       In 材料特性.存储条件%Type := Null,
  跟踪病人_In       In 材料特性.跟踪病人%Type := 0,
  站点_In           In 收费项目目录.站点%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  增值税率_In       In 材料特性.增值税率%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  高值材料_In       In 材料特性.高值材料%Type := Null,
  条码管理_In       In 材料特性.是否条码管理%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  器械包卫材单件_In In 材料特性.器械包卫材单件%Type := 0,
  注册证有效期_In   In 材料特性.注册证有效期%Type := Null,
  是否植入耗材_In   In 材料特性.是否植入耗材%Type := 0,
  加成率_In         In 材料特性.加成率%Type := Null
) Is
  v_Err_Msg Varchar2(200);
  Err_Item Exception;
  v_发生     Integer;
  v_跟踪在用 Integer;
  v_Count    Integer;
  v_No       收费价目.No%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_Temp     收费项目目录.病案费目%Type;
  v_病案费目 收费项目目录.病案费目%Type;

Begin
  v_Err_Msg := '无';

  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --修改诊疗项目 
  Begin
    Select 跟踪在用 Into v_跟踪在用 From 材料特性 Where 材料id = 材料id_In;
  Exception
    When Others Then
      v_Err_Msg := '[ZLSOFT]不存在规格材料,可能被其他用户删除了,请检查![ZLSOFT]';
  End;
  If v_Err_Msg <> '无' Then
    Raise Err_Item;
  End If;

  Begin
    Select 名称 Into v_名称 From 诊疗项目目录 Where ID = 诊疗id_In;
  Exception
    When Others Then
      v_Err_Msg := 'Err';
  End;

  If v_Err_Msg = 'Err' Then
    v_Err_Msg := '[ZLSOFT]未找到指定的材料品种，可能已被其他用户删除！[ZLSOFT]';
    Raise Err_Item;
  End If;

  --如果更新前的材料为跟踪在用,如果改为了不跟踪则需判断库存 
  If v_跟踪在用 = 1 And 跟踪在用_In <> 1 Then
    Begin
      Select Count(*)
      Into v_Count
      From 药品库存
      Where 药品id = 材料id_In And (Nvl(可用数量, 0) <> 0 Or Nvl(实际数量, 0) <> 0 Or Nvl(实际金额, 0) <> 0 Or Nvl(实际差价, 0) <> 0);
      If v_Count <> 0 Then
        v_Err_Msg := '[ZLSOFT]该卫生材料存在库存,不能取消跟踪在用属性,请检查![ZLSOFT]';
      End If;
    Exception
      When Others Then
        Null;
    End;
  End If;

  If v_Err_Msg <> '无' Then
    Raise Err_Item;
  End If;

  --规格信息 
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 标识主码 = 标识主码_In, 标识子码 = 标识子码_In, 备选码 = 备选码_In, 产地 = 产地_In, 是否变价 = 是否变价_In,
      计算单位 = 散装单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In, 站点 = 站点_In, 说明 = 说明_In, 病案费目 = v_病案费目
  Where ID = 材料id_In;

  If Sql%RowCount = 0 Then
    v_Err_Msg := '[ZLSOFT]该卫生材料可能被其他用户删除了,请检查![ZLSOFT]';
    Raise Err_Item;
  End If;

  --材料特性 
  Update 材料特性
  Set 最大效期 = 最大效期_In, 灭菌效期 = 灭菌效期_In, 无菌性材料 = 无菌性材料_In, 一次性材料 = 一次性材料_In, 原材料 = 原材料_In, 货源情况 = 货源情况_In, 包装单位 = 包装单位_In,
      换算系数 = 换算系数_In, 指导批发价 = 指导批发价_In, 指导零售价 = 指导零售价_In, 指导差价率 = 指导差价率_In, 扣率 = 扣率_In, 库房分批 = 库房分批_In, 在用分批 = 在用分批_In,
      材料来源 = 材料来源_In, 差价让利比 = 差价让利比_In, 成本价 = 成本价_In, 跟踪在用 = 跟踪在用_In, 核算材料 = 核算材料_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In,
      注册证号 = 注册证号_In, 注册证有效期 = 注册证有效期_In, 材质分类 = 材质分类_In, 存储条件 = 存储条件_In, 许可证号 = 许可证号_In, 许可证有效期 = 许可证有效期_In,
      诊疗id = 诊疗id_In, 跟踪病人 = 跟踪病人_In, 增值税率 = 增值税率_In, 高值材料 = 高值材料_In, 是否条码管理 = 条码管理_In, 器械包卫材单件 = 器械包卫材单件_In,
      是否植入耗材 = 是否植入耗材_In, 加成率=加成率_In
  Where 材料id = 材料id_In;

  --别名的处理 
  Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 1;

  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 材料id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 诊疗id_In And 性质 = 1;

  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 材料id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息 
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 材料id_In And Rownum < 2;

  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 材料id_In;
    Update 材料特性 Set 成本价 = 成本价_In Where 材料id = 材料id_In;
  
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 缺省价格 = Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, 缺省价格), 缺省价格), 收入项目id = 收入id_In, 变动原因 = 1,
          调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 材料id_In
           --And (终止日期 Is Null Or 终止日期=to_date('3000-01-01','YYYY-MM-DD')); 
            And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
    
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 材料id_In, 0, 当前售价_In,
           Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, Null), Null), 收入id_In, 1, '新增定价', User, Sysdate,
           To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --有业务单据后不能直接修改价格，但是可以修改收入项目 
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 材料id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --材料生产商比较增加 
  If 产地_In Is Not Null Then
    Update 材料生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 材料生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In) From 材料生产商;
    End If;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_卫生材料_Update;
/

--118402:秦龙,2018-01-09,增加传参加成率
Create Or Replace Procedure Zl_卫生材料_Insert
(
  诊疗id_In         In 材料特性.诊疗id%Type,
  材料id_In         In 材料特性.材料id%Type,
  编码_In           In 收费项目目录.编码%Type,
  规格_In           In 收费项目目录.规格%Type,
  产地_In           In 收费项目目录.产地%Type := Null,
  标识主码_In       In 收费项目目录.标识主码%Type := Null,
  标识子码_In       In 收费项目目录.标识子码%Type := Null,
  备选码_In         In 收费项目目录.备选码%Type := Null,
  材料来源_In       In 材料特性.材料来源%Type := Null,
  货源情况_In       In 材料特性.货源情况%Type := Null,
  散装单位_In       In 收费项目目录.计算单位%Type := Null,
  包装单位_In       In 材料特性.包装单位%Type := Null,
  换算系数_In       In 材料特性.换算系数%Type := Null,
  是否变价_In       In 收费项目目录.是否变价%Type := Null,
  指导批发价_In     In 材料特性.指导批发价%Type := Null,
  扣率_In           In 材料特性.扣率%Type := 95,
  指导零售价_In     In 材料特性.指导零售价%Type := Null,
  指导差价率_In     In 材料特性.指导差价率%Type := Null,
  费用类型_In       In 收费项目目录.费用类型%Type := Null,
  服务对象_In       In 收费项目目录.服务对象%Type := Null,
  屏蔽费别_In       In 收费项目目录.屏蔽费别%Type := 0,
  库房分批_In       In 材料特性.库房分批%Type := Null,
  在用分批_In       In 材料特性.在用分批%Type := Null,
  最大效期_In       In 材料特性.最大效期%Type := Null,
  灭菌效期_In       In 材料特性.灭菌效期%Type := Null,
  无菌性材料_In     In 材料特性.无菌性材料%Type := Null,
  一次性材料_In     In 材料特性.一次性材料%Type := Null,
  原材料_In         In 材料特性.原材料%Type := Null,
  差价让利比_In     In 材料特性.差价让利比%Type := 0,
  成本价_In         In 材料特性.成本价%Type := 0,
  跟踪在用_In       In 材料特性.跟踪在用%Type := Null,
  核算材料_In       In 材料特性.核算材料%Type := 0,
  当前售价_In       In 收费价目.现价%Type := 0,
  收入id_In         In 收费价目.收入项目id%Type := Null,
  批准文号_In       In 材料特性.批准文号%Type := Null,
  注册商标_In       In 材料特性.注册商标%Type := Null,
  注册证号_In       In 材料特性.注册证号%Type := Null,
  许可证号_In       In 材料特性.许可证号%Type := Null,
  许可证有效期_In   In 材料特性.许可证有效期%Type := Null,
  材质分类_In       In 材料特性.材质分类%Type := Null,
  存储条件_In       In 材料特性.存储条件%Type := Null,
  跟踪病人_In       In 材料特性.跟踪病人%Type := 0,
  站点_In           In 收费项目目录.站点%Type := Null,
  品名_In           In 收费项目别名.名称%Type := Null,
  拼音_In           In 收费项目别名.简码%Type := Null,
  五笔_In           In 收费项目别名.简码%Type := Null,
  增值税率_In       In 材料特性.增值税率%Type := Null,
  说明_In           In 收费项目目录.说明%Type := Null,
  高值材料_In       In 材料特性.高值材料%Type := Null,
  条码管理_In       In 材料特性.是否条码管理%Type := Null,
  病案费目_In       In 收费项目目录.病案费目%Type := Null,
  器械包卫材单件_In In 材料特性.器械包卫材单件%Type := 0,
  注册证有效期_In   In 材料特性.注册证有效期%Type := Null,
  是否植入耗材_In   In 材料特性.是否植入耗材%Type := 0,
  加成率_In         In 材料特性.加成率%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(100);

  v_No       收费价目.No%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_Temp     收费项目目录.病案费目%Type;
  v_病案费目 收费项目目录.病案费目%Type;

  Cursor c_Item Is
    Select ID
    From 部门表 D
    Where ID In (Select Distinct 部门id
                 From 部门性质说明 A
                 Where 工作性质 In ('发料部门', '物资库房', '卫材库', '制剂室', '虚拟库房'));
Begin
  v_Err_Msg := 'NO';

  v_病案费目 := 病案费目_In;
  --判断病案费目 
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  Begin
    Select 名称
    Into v_名称
    From 诊疗项目目录
    Where ID = 诊疗id_In And (撤档时间 Is Null Or To_Char(撤档时间, 'yyyy-mm-dd') = '3000-01-01');
  Exception
    When Others Then
      v_Err_Msg := 'Err';
  End;
  If v_Err_Msg = 'Err' Then
    v_Err_Msg := '[ZLSOFT]未找到指定的材料品种，可能该品种已被其他用户删除或停用！[ZLSOFT]';
    Raise Err_Item;
  End If;
  --规格信息 
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 标识主码, 标识子码, 备选码, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 站点, 建档时间, 撤档时间, 说明, 病案费目)
  Values
    (4, 材料id_In, 编码_In, v_名称, 规格_In, 产地_In, 标识主码_In, 标识子码_In, 备选码_In, 散装单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In,
     站点_In, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, v_病案费目);

  --材料特性 
  Insert Into 材料特性
    (材料id, 诊疗id, 最大效期, 灭菌效期, 无菌性材料, 一次性材料, 原材料, 货源情况, 包装单位, 换算系数, 指导批发价, 指导零售价, 指导差价率, 扣率, 库房分批, 在用分批, 材料来源, 差价让利比, 成本价,
     跟踪在用, 核算材料, 批准文号, 注册商标, 注册证号, 注册证有效期, 许可证号, 许可证有效期, 材质分类, 存储条件, 跟踪病人, 增值税率, 高值材料, 是否条码管理, 器械包卫材单件, 是否植入耗材, 加成率)
  Values
    (材料id_In, 诊疗id_In, 最大效期_In, 灭菌效期_In, 无菌性材料_In, 一次性材料_In, 原材料_In, 货源情况_In, 包装单位_In, 换算系数_In, 指导批发价_In, 指导零售价_In,
     指导差价率_In, 扣率_In, 库房分批_In, 在用分批_In, 材料来源_In, 差价让利比_In, 成本价_In, 跟踪在用_In, 核算材料_In, 批准文号_In, 注册商标_In, 注册证号_In,
     注册证有效期_In, 许可证号_In, 许可证有效期_In, 材质分类_In, 存储条件_In, 跟踪病人_In, 增值税率_In, 高值材料_In, 条码管理_In, 器械包卫材单件_In, 是否植入耗材_In, 加成率_In);

  --别名的处理 
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 材料id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 诊疗id_In;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (材料id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  For r_Item In c_Item Loop
    Insert Into 材料储备限额 (库房id, 材料id, 上限, 下限, 盘点属性) Values (r_Item.Id, 材料id_In, 0, 0, '1111');
  End Loop;
  --定价信息 
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    --非跟踪在用的时价卫材，在销售时相当于一般的收费项目，在调价时应按”最低限价、最高限价、缺省价格”进行设置。 
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 缺省价格, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 材料id_In, 0, 当前售价_In, Decode(跟踪在用_In, 0, Decode(是否变价_In, 1, 当前售价_In, Null), Null), 收入id_In,
       1, '新增定价', User, Sysdate, To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --材料生产商比较增加 
  If 产地_In Is Not Null Then
    Update 材料生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 材料生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In) From 材料生产商;
    End If;
  End If;

  --插入材料的服务科室 
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 材料id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 诊疗id_In;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_卫生材料_Insert;
/

--118402:秦龙,2018-01-08,修改传参加成率
Create Or Replace Procedure Zl_成药规格_Update
(
  药品id_In       In 药品规格.药品id%Type,
  编码_In         In 收费项目目录.编码%Type,
  规格_In         In 收费项目目录.规格%Type,
  产地_In         In 收费项目目录.产地%Type := Null,
  品名_In         In 收费项目别名.名称%Type := Null,
  拼音_In         In 收费项目别名.简码%Type := Null,
  五笔_In         In 收费项目别名.简码%Type := Null,
  数字码_In       In 收费项目别名.简码%Type := Null,
  标识码_In       In 药品规格.标识码%Type := Null,
  药品来源_In     In 药品规格.药品来源%Type := Null,
  批准文号_In     In 药品规格.批准文号%Type := Null,
  注册商标_In     In 药品规格.注册商标%Type := Null,
  售价单位_In     In 收费项目目录.计算单位%Type := Null,
  剂量系数_In     In 药品规格.剂量系数%Type := Null,
  门诊单位_In     In 药品规格.门诊单位%Type := Null,
  门诊包装_In     In 药品规格.门诊包装%Type := Null,
  住院单位_In     In 药品规格.住院单位%Type := Null,
  住院包装_In     In 药品规格.住院包装%Type := Null,
  药库单位_In     In 药品规格.药库单位%Type := Null,
  药库包装_In     In 药品规格.药库包装%Type := Null,
  申领单位_In     In 药品规格.申领单位%Type := 1,
  申领阀值_In     In 药品规格.申领阀值%Type := Null,
  是否变价_In     In 收费项目目录.是否变价%Type := Null,
  指导批发价_In   In 药品规格.指导批发价%Type := Null,
  扣率_In         In 药品规格.扣率%Type := 95,
  指导零售价_In   In 药品规格.指导零售价%Type := Null,
  加成率_In       In 药品规格.加成率%Type := Null,
  管理费比例_In   In 药品规格.管理费比例%Type := Null,
  药价级别_In     In 药品规格.药价级别%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  服务对象_In     In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In      In 药品规格.Gmp认证%Type := 0,
  招标药品_In     In 药品规格.招标药品%Type := 0,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In In 药品规格.住院可否分零%Type := 0,
  药库分批_In     In 药品规格.药库分批%Type := Null,
  药房分批_In     In 药品规格.药房分批%Type := Null,
  最大效期_In     In 药品规格.最大效期%Type := Null,
  差价让利比_In   In 药品规格.差价让利比%Type := 0,
  成本价_In       In 药品规格.成本价%Type := 0,
  当前售价_In     In 收费价目.现价%Type := 0,
  收入id_In       In 收费价目.收入项目id%Type := Null,
  合同单位id_In   In 药品规格.合同单位id%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  动态分零_In     In 药品规格.动态分零%Type := 0,
  发药类型_In     In 药品规格.发药类型%Type := Null,
  备选码_In       In 收费项目目录.备选码%Type := Null,
  增值税率_In     In 药品规格.增值税率%Type := Null,
  基本药物_In     In 药品规格.基本药物%Type := Null,
  站点_In         In 收费项目目录.站点%Type := Null,
  是否常备_In     In 药品规格.是否常备%Type := Null,
  存储温度_In     In 输液药品属性.存储温度%Type := Null,
  存储条件_In     In 输液药品属性.存储条件%Type := Null,
  配药类型_In     In 输液药品属性.配药类型%Type := Null,
  是否不予配置_In In 输液药品属性.是否不予配置%Type := Null,
  容量_In         In 药品规格.容量%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In In 药品规格.门诊可否分零%Type := 0,
  Ddd值_In        In 药品规格.Ddd值%Type := 0,
  高危药品_In     药品规格.高危药品%Type := Null,
  送货单位_In     In 药品规格.送货单位%Type := Null,
  送货包装_In     In 药品规格.送货包装%Type := Null,
  输液注意事项_In In 输液药品属性.输液注意事项%Type := Null,
  本位码_In       In 药品规格.本位码%Type := Null
) Is
  v_药名id   诊疗项目目录.Id%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_是否变价 收费项目目录.是否变价%Type; --允许定价药品随时改为时价，时价药品只能在未发生的情况下修改为定价，其它情况不允许修改定价属性 
  v_发生     Number(2);
  Err_Notfind Exception;
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --通用名称
  Select ID, 名称
  Into v_药名id, v_名称
  From 诊疗项目目录
  Where ID = (Select 药名id From 药品规格 Where 药品id = 药品id_In);
  --取原始的定价属性
  Select 是否变价 Into v_是否变价 From 收费项目目录 Where ID = 药品id_In;
  --规格信息
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 产地 = 产地_In, 计算单位 = 售价单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In,
      病案费目 = v_病案费目, 说明 = 说明_In, 备选码 = 备选码_In, 站点 = 站点_In
  Where ID = 药品id_In;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  Update 药品规格
  Set 标识码 = 标识码_In, 药品来源 = 药品来源_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In, 剂量系数 = 剂量系数_In, 门诊单位 = 门诊单位_In, 门诊包装 = 门诊包装_In,
      住院单位 = 住院单位_In, 住院包装 = 住院包装_In, 药库单位 = 药库单位_In, 药库包装 = 药库包装_In, 申领单位 = 申领单位_In, 申领阀值 = 申领阀值_In, 指导批发价 = 指导批发价_In,
      扣率 = 扣率_In, 指导零售价 = 指导零售价_In, 指导差价率 = n_指导差价率, 管理费比例 = 管理费比例_In, 药价级别 = 药价级别_In, 住院可否分零 = 住院可否分零_In,
      药库分批 = 药库分批_In, 药房分批 = 药房分批_In, 最大效期 = 最大效期_In, 招标药品 = 招标药品_In, Gmp认证 = Gmp认证_In, 差价让利比 = 差价让利比_In,
      合同单位id = 合同单位id_In, 动态分零 = 动态分零_In, 发药类型 = 发药类型_In, 增值税率 = 增值税率_In, 基本药物 = 基本药物_In, 是否常备 = 是否常备_In, 容量 = 容量_In,
      门诊可否分零 = 门诊可否分零_In, Ddd值 = Ddd值_In, 高危药品 = 高危药品_In, 送货单位 = 送货单位_In, 送货包装 = 送货包装_In, 本位码 = 本位码_In, 加成率 = 加成率_In
  Where 药品id = 药品id_In;

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此修改规格药品时，不再根据规格药品的服务对象更新药品的服务对象
  --诊疗项目服务对象的更改
  --select nvl(sum(distinct I.服务对象),0) into v_对象
  --from 收费项目目录 I,药品规格 S
  --where I.ID=S.药品ID and S.药名ID=v_药名ID;
  --update 诊疗项目目录
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3)
  --where ID=v_药名ID;

  --别名的处理
  If 数字码_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
  Else
    Update 收费项目别名 Set 名称 = v_名称, 简码 = 数字码_In Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
    If Sql%RowCount = 0 Then
      Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
    End If;
  End If;
  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 药品id_In And Rownum < 2;
  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    Update 药品规格 Set 成本价 = 成本价_In Where 药品id = 药品id_In;
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 收入项目id = 收入id_In, 变动原因 = 1, 调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
           To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --定价药品随时可改为时价
    If v_是否变价 = 0 And 是否变价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    End If;
    --发生业务数据时，不能修改价格但是可以修改收入项目
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --药品生产商比较增加
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --修改输液药品属性
  Update 输液药品属性
  Set 存储温度 = 存储温度_In, 存储条件 = 存储条件_In, 配药类型 = 配药类型_In, 是否不予配置 = 是否不予配置_In, 输液注意事项 = 输液注意事项_In
  Where 药品id = 药品id_In;

  If Sql%NotFound Then
    Insert Into 输液药品属性
      (药品id, 存储温度, 存储条件, 配药类型, 是否不予配置, 输液注意事项)
    Values
      (药品id_In, 存储温度_In, 存储条件_In, 配药类型_In, 是否不予配置_In, 输液注意事项_In);
  End If;
Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该规格不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药规格_Update;
/
--118402:秦龙,2018-01-08,修改传参加成率
Create Or Replace Procedure Zl_成药规格_Insert
(
  药名id_In       In 药品规格.药名id%Type,
  药品id_In       In 药品规格.药品id%Type,
  编码_In         In 收费项目目录.编码%Type,
  规格_In         In 收费项目目录.规格%Type,
  产地_In         In 收费项目目录.产地%Type := Null,
  品名_In         In 收费项目别名.名称%Type := Null,
  拼音_In         In 收费项目别名.简码%Type := Null,
  五笔_In         In 收费项目别名.简码%Type := Null,
  数字码_In       In 收费项目别名.简码%Type := Null,
  标识码_In       In 药品规格.标识码%Type := Null,
  药品来源_In     In 药品规格.药品来源%Type := Null,
  批准文号_In     In 药品规格.批准文号%Type := Null,
  注册商标_In     In 药品规格.注册商标%Type := Null,
  售价单位_In     In 收费项目目录.计算单位%Type := Null,
  剂量系数_In     In 药品规格.剂量系数%Type := Null,
  门诊单位_In     In 药品规格.门诊单位%Type := Null,
  门诊包装_In     In 药品规格.门诊包装%Type := Null,
  住院单位_In     In 药品规格.住院单位%Type := Null,
  住院包装_In     In 药品规格.住院包装%Type := Null,
  药库单位_In     In 药品规格.药库单位%Type := Null,
  药库包装_In     In 药品规格.药库包装%Type := Null,
  申领单位_In     In 药品规格.申领单位%Type := 1,
  申领阀值_In     In 药品规格.申领阀值%Type := Null,
  是否变价_In     In 收费项目目录.是否变价%Type := Null,
  指导批发价_In   In 药品规格.指导批发价%Type := Null,
  扣率_In         In 药品规格.扣率%Type := 95,
  指导零售价_In   In 药品规格.指导零售价%Type := Null,
  加成率_In       In 药品规格.加成率%Type := Null,
  管理费比例_In   In 药品规格.管理费比例%Type := Null,
  药价级别_In     In 药品规格.药价级别%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  服务对象_In     In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In      In 药品规格.Gmp认证%Type := 0,
  招标药品_In     In 药品规格.招标药品%Type := 0,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In In 药品规格.住院可否分零%Type := 0,
  药库分批_In     In 药品规格.药库分批%Type := Null,
  药房分批_In     In 药品规格.药房分批%Type := Null,
  最大效期_In     In 药品规格.最大效期%Type := Null,
  差价让利比_In   In 药品规格.差价让利比%Type := 0,
  成本价_In       In 药品规格.成本价%Type := 0,
  当前售价_In     In 收费价目.现价%Type := 0,
  收入id_In       In 收费价目.收入项目id%Type := Null,
  合同单位id_In   In 药品规格.合同单位id%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  动态分零_In     In 药品规格.动态分零%Type := 0,
  发药类型_In     In 药品规格.发药类型%Type := Null,
  备选码_In       In 收费项目目录.备选码%Type := Null,
  增值税率_In     In 药品规格.增值税率%Type := Null,
  基本药物_In     In 药品规格.基本药物%Type := Null,
  站点_In         In 收费项目目录.站点%Type := Null,
  是否常备_In     In 药品规格.是否常备%Type := Null,
  存储温度_In     In 输液药品属性.存储温度%Type := Null,
  存储条件_In     In 输液药品属性.存储条件%Type := Null,
  配药类型_In     In 输液药品属性.配药类型%Type := Null,
  是否不予配置_In In 输液药品属性.是否不予配置%Type := Null,
  容量_In         In 药品规格.容量%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In In 药品规格.门诊可否分零%Type := 0,
  Ddd值_In        In 药品规格.Ddd值%Type := 0,
  高危药品_In     In 药品规格.高危药品%Type := Null,
  送货单位_In     In 药品规格.送货单位%Type := Null,
  送货包装_In     In 药品规格.送货包装%Type := Null,
  输液注意事项_In In 输液药品属性.输液注意事项%Type := Null,
  本位码_In       In 药品规格.本位码%Type := Null
) Is

  v_类别       诊疗项目目录.类别%Type;
  v_名称       诊疗项目目录.名称%Type;
  v_Kind       Varchar2(20);
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;

  --盘点库房的工作性质
  Cursor c_Storageid Is
    Select Distinct 部门id From 部门性质说明 Where 工作性质 Like v_Kind Or 工作性质 = '制剂室';
  r_Storageid c_Storageid%RowType;

Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --类别和名称
  Select 类别, 名称 Into v_类别, v_名称 From 诊疗项目目录 Where ID = 药名id_In;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  --规格信息
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 建档时间, 撤档时间, 说明, 备选码, 站点, 病案费目)
  Values
    (v_类别, 药品id_In, 编码_In, v_名称, 规格_In, 产地_In, 售价单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, 备选码_In, 站点_In, v_病案费目);
  Insert Into 药品规格
    (药名id, 药品id, 标识码, 药品来源, 批准文号, 注册商标, 剂量系数, 门诊单位, 门诊包装, 住院单位, 住院包装, 药库单位, 药库包装, 申领单位, 申领阀值, 指导批发价, 扣率, 指导零售价, 指导差价率,
     管理费比例, 药价级别, 成本价, Gmp认证, 招标药品, 差价让利比, 住院可否分零, 药库分批, 药房分批, 最大效期, 合同单位id, 动态分零, 发药类型, 增值税率, 基本药物, 是否常备, 容量, 门诊可否分零,
     Ddd值, 高危药品, 送货单位, 送货包装, 本位码, 加成率)
  Values
    (药名id_In, 药品id_In, 标识码_In, 药品来源_In, 批准文号_In, 注册商标_In, 剂量系数_In, 门诊单位_In, 门诊包装_In, 住院单位_In, 住院包装_In, 药库单位_In, 药库包装_In,
     申领单位_In, 申领阀值_In, 指导批发价_In, 扣率_In, 指导零售价_In, n_指导差价率, 管理费比例_In, 药价级别_In, 成本价_In, Gmp认证_In, 招标药品_In, 差价让利比_In,
     住院可否分零_In, 药库分批_In, 药房分批_In, 最大效期_In, 合同单位id_In, 动态分零_In, 发药类型_In, 增值税率_In, 基本药物_In, 是否常备_In, 容量_In, 门诊可否分零_In,
     Ddd值_In, 高危药品_In, 送货单位_In, 送货包装_In, 本位码_In, 加成率_In);

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此建立规格药品时，不再根据规格药品的服务对象更新药品的服务对象
  --诊疗项目服务对象的更改
  --select nvl(sum(distinct I.服务对象),0) into v_对象
  --from 收费项目目录 I,药品规格 S
  --where I.ID=S.药品ID and S.药名ID=药名ID_IN;
  --update 诊疗项目目录
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3)
  --where ID=药名ID_IN;

  --别名的处理
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 药品id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 药名id_In;
  If 数字码_In Is Not Null Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
  End If;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  --定价信息
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
       To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --药品生产商比较增加
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --插入该规格的服务科室
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 药品id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 药名id_In;

  --插入盘点属性

  If v_类别 = 5 Then
    v_Kind := '西药%';
  Else
    v_Kind := '成药%';
  End If;

  For r_Storageid In c_Storageid Loop
    Insert Into 药品储备限额
      (库房id, 药品id, 上限, 下限, 盘点属性, 库房货位)
    Values
      (r_Storageid.部门id, 药品id_In, 0, 0, '1111', Null);
  End Loop;

  --插入输液药品属性
  Insert Into 输液药品属性
    (药品id, 存储温度, 存储条件, 配药类型, 是否不予配置, 输液注意事项)
  Values
    (药品id_In, 存储温度_In, 存储条件_In, 配药类型_In, 是否不予配置_In, 输液注意事项_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_成药规格_Insert;
/
--118402:秦龙,2018-01-08,修改传参加成率
Create Or Replace Procedure Zl_草药规格_Insert
(
  药名id_In       In 药品规格.药名id%Type,
  药品id_In       In 药品规格.药品id%Type,
  编码_In         In 收费项目目录.编码%Type,
  规格_In         In 收费项目目录.规格%Type,
  产地_In         In 收费项目目录.产地%Type := Null,
  品名_In         In 收费项目别名.名称%Type := Null,
  拼音_In         In 收费项目别名.简码%Type := Null,
  五笔_In         In 收费项目别名.简码%Type := Null,
  数字码_In       In 收费项目别名.简码%Type := Null,
  标识码_In       In 药品规格.标识码%Type := Null,
  药品来源_In     In 药品规格.药品来源%Type := Null,
  批准文号_In     In 药品规格.批准文号%Type := Null,
  注册商标_In     In 药品规格.注册商标%Type := Null,
  售价单位_In     In 收费项目目录.计算单位%Type := Null,
  剂量系数_In     In 药品规格.剂量系数%Type := Null,
  门诊单位_In     In 药品规格.门诊单位%Type := Null,
  门诊包装_In     In 药品规格.门诊包装%Type := Null,
  药库单位_In     In 药品规格.药库单位%Type := Null,
  药库包装_In     In 药品规格.药库包装%Type := Null,
  申领单位_In     In 药品规格.申领单位%Type := 1,
  申领阀值_In     In 药品规格.申领阀值%Type := Null,
  是否变价_In     In 收费项目目录.是否变价%Type := Null,
  指导批发价_In   In 药品规格.指导批发价%Type := Null,
  扣率_In         In 药品规格.扣率%Type := 95,
  指导零售价_In   In 药品规格.指导零售价%Type := Null,
  加成率_In       In 药品规格.加成率%Type := Null,
  管理费比例_In   In 药品规格.管理费比例%Type := Null,
  药价级别_In     In 药品规格.药价级别%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  服务对象_In     In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In      In 药品规格.Gmp认证%Type := 0,
  招标药品_In     In 药品规格.招标药品%Type := 0,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In In 药品规格.住院可否分零%Type := 0,
  药库分批_In     In 药品规格.药库分批%Type := Null,
  药房分批_In     In 药品规格.药房分批%Type := Null,
  最大效期_In     In 药品规格.最大效期%Type := Null,
  差价让利比_In   In 药品规格.差价让利比%Type := 0,
  成本价_In       In 药品规格.成本价%Type := 0,
  当前售价_In     In 收费价目.现价%Type := 0,
  收入id_In       In 收费价目.收入项目id%Type := Null,
  合同单位id_In   In 药品规格.合同单位id%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  动态分零_In     In 药品规格.动态分零%Type := 0,
  发药类型_In     In 药品规格.发药类型%Type := Null,
  备选码_In       In 收费项目目录.备选码%Type := Null,
  增值税率_In     In 药品规格.增值税率%Type := Null,
  基本药物_In     In 药品规格.基本药物%Type := Null,
  中药形态_In     In 药品规格.中药形态%Type := Null,
  站点_In         In 收费项目目录.站点%Type := Null,
  是否常备_In     In 药品规格.是否常备%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In In 药品规格.门诊可否分零%Type := 0,
  送货单位_In     In 药品规格.送货单位%Type := Null,
  送货包装_In     In 药品规格.送货包装%Type := Null,
  本位码_In       In 药品规格.本位码%Type := Null
) Is

  v_类别       诊疗项目目录.类别%Type;
  v_名称       诊疗项目目录.名称%Type;
  v_Kind       Varchar2(20);
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
  --盘点库房的工作性质
  Cursor c_Storageid Is
    Select Distinct 部门id From 部门性质说明 Where 工作性质 Like v_Kind Or 工作性质 = '制剂室';
  r_Storageid c_Storageid%RowType;

Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --类别和名称
  Select 类别, 名称 Into v_类别, v_名称 From 诊疗项目目录 Where ID = 药名id_In;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  --规格信息
  Insert Into 收费项目目录
    (类别, ID, 编码, 名称, 规格, 产地, 计算单位, 费用类型, 服务对象, 屏蔽费别, 是否变价, 建档时间, 撤档时间, 说明, 备选码, 站点, 病案费目)
  Values
    (v_类别, 药品id_In, 编码_In, v_名称, 规格_In, 产地_In, 售价单位_In, 费用类型_In, 服务对象_In, 屏蔽费别_In, 是否变价_In, Sysdate,
     To_Date('3000-01-01', 'YYYY-MM-DD'), 说明_In, 备选码_In, 站点_In, v_病案费目);
  Insert Into 药品规格
    (药名id, 药品id, 标识码, 药品来源, 批准文号, 注册商标, 剂量系数, 门诊单位, 门诊包装, 住院单位, 住院包装, 药库单位, 药库包装, 申领单位, 申领阀值, 指导批发价, 扣率, 指导零售价, 指导差价率,
     管理费比例, 药价级别, 成本价, Gmp认证, 招标药品, 差价让利比, 住院可否分零, 药库分批, 药房分批, 最大效期, 合同单位id, 动态分零, 发药类型, 增值税率, 基本药物, 中药形态, 是否常备, 门诊可否分零,
     送货单位, 送货包装, 本位码, 加成率)
  Values
    (药名id_In, 药品id_In, 标识码_In, 药品来源_In, 批准文号_In, 注册商标_In, 剂量系数_In, 门诊单位_In, 门诊包装_In, 门诊单位_In, 门诊包装_In, 药库单位_In, 药库包装_In,
     申领单位_In, 申领阀值_In, 指导批发价_In, 扣率_In, 指导零售价_In, n_指导差价率, 管理费比例_In, 药价级别_In, 成本价_In, Gmp认证_In, 招标药品_In, 差价让利比_In,
     住院可否分零_In, 药库分批_In, 药房分批_In, 最大效期_In, 合同单位id_In, 动态分零_In, 发药类型_In, 增值税率_In, 基本药物_In, 中药形态_In, 是否常备_In, 门诊可否分零_In,
     送货单位_In, 送货包装_In, 本位码_In, 加成率_In);

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此建立规格药品时，不再根据规格药品的服务对象更新药品的服务对象
  --诊疗项目服务对象的更改
  --select nvl(sum(distinct I.服务对象),0) into v_对象
  --from 收费项目目录 I,药品规格 S
  --where I.ID=S.药品ID and S.药名ID=药名ID_IN;
  --update 诊疗项目目录
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3)
  --where ID=药名ID_IN;

  --别名的处理
  Insert Into 收费项目别名
    (收费细目id, 名称, 性质, 简码, 码类)
    Select 药品id_In, 名称, 性质, 简码, 码类 From 诊疗项目别名 Where 诊疗项目id = 药名id_In;
  If 数字码_In Is Not Null Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
  End If;
  If (品名_In Is Not Null) And (拼音_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
  End If;
  If (品名_In Is Not Null) And (五笔_In Is Not Null) Then
    Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
  End If;

  --定价信息
  If 收入id_In Is Not Null Then
    v_No := Nextno(9);
    Insert Into 收费价目
      (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
    Values
      (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
       To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
  End If;

  --药品生产商比较增加
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

  --插入该规格的服务科室
  Insert Into 收费执行科室
    (收费细目id, 病人来源, 开单科室id, 执行科室id)
    Select 药品id_In, 病人来源, 开单科室id, 执行科室id From 诊疗执行科室 Where 诊疗项目id = 药名id_In;

  --插入盘点属性
  v_Kind := '中药%';

  For r_Storageid In c_Storageid Loop
    Insert Into 药品储备限额
      (库房id, 药品id, 上限, 下限, 盘点属性, 库房货位)
    Values
      (r_Storageid.部门id, 药品id_In, 0, 0, '1111', Null);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药规格_Insert;
/
--118402:秦龙,2018-01-08,修改传参加成率
Create Or Replace Procedure Zl_草药规格_Update
(
  药品id_In       In 药品规格.药品id%Type,
  编码_In         In 收费项目目录.编码%Type,
  规格_In         In 收费项目目录.规格%Type,
  产地_In         In 收费项目目录.产地%Type := Null,
  品名_In         In 收费项目别名.名称%Type := Null,
  拼音_In         In 收费项目别名.简码%Type := Null,
  五笔_In         In 收费项目别名.简码%Type := Null,
  数字码_In       In 收费项目别名.简码%Type := Null,
  标识码_In       In 药品规格.标识码%Type := Null,
  药品来源_In     In 药品规格.药品来源%Type := Null,
  批准文号_In     In 药品规格.批准文号%Type := Null,
  注册商标_In     In 药品规格.注册商标%Type := Null,
  售价单位_In     In 收费项目目录.计算单位%Type := Null,
  剂量系数_In     In 药品规格.剂量系数%Type := Null,
  门诊单位_In     In 药品规格.门诊单位%Type := Null,
  门诊包装_In     In 药品规格.门诊包装%Type := Null,
  药库单位_In     In 药品规格.药库单位%Type := Null,
  药库包装_In     In 药品规格.药库包装%Type := Null,
  申领单位_In     In 药品规格.申领单位%Type := 1,
  申领阀值_In     In 药品规格.申领阀值%Type := Null,
  是否变价_In     In 收费项目目录.是否变价%Type := Null,
  指导批发价_In   In 药品规格.指导批发价%Type := Null,
  扣率_In         In 药品规格.扣率%Type := 95,
  指导零售价_In   In 药品规格.指导零售价%Type := Null,
  加成率_In       In 药品规格.加成率%Type := Null,
  管理费比例_In   In 药品规格.管理费比例%Type := Null,
  药价级别_In     In 药品规格.药价级别%Type := Null,
  费用类型_In     In 收费项目目录.费用类型%Type := Null,
  服务对象_In     In 收费项目目录.服务对象%Type := Null,
  Gmp认证_In      In 药品规格.Gmp认证%Type := 0,
  招标药品_In     In 药品规格.招标药品%Type := 0,
  屏蔽费别_In     In 收费项目目录.屏蔽费别%Type := 0,
  住院可否分零_In In 药品规格.住院可否分零%Type := 0,
  药库分批_In     In 药品规格.药库分批%Type := Null,
  药房分批_In     In 药品规格.药房分批%Type := Null,
  最大效期_In     In 药品规格.最大效期%Type := Null,
  差价让利比_In   In 药品规格.差价让利比%Type := 0,
  成本价_In       In 药品规格.成本价%Type := 0,
  当前售价_In     In 收费价目.现价%Type := 0,
  收入id_In       In 收费价目.收入项目id%Type := Null,
  合同单位id_In   In 药品规格.合同单位id%Type := Null,
  说明_In         In 收费项目目录.说明%Type := Null,
  动态分零_In     In 药品规格.动态分零%Type := 0,
  发药类型_In     In 药品规格.发药类型%Type := Null,
  备选码_In       In 收费项目目录.备选码%Type := Null,
  增值税率_In     In 药品规格.增值税率%Type := Null,
  基本药物_In     In 药品规格.基本药物%Type := Null,
  中药形态_In     In 药品规格.中药形态%Type := Null,
  站点_In         In 收费项目目录.站点%Type := Null,
  是否常备_In     In 药品规格.是否常备%Type := Null,
  病案费目_In     In 收费项目目录.病案费目%Type := Null,
  门诊可否分零_In In 药品规格.门诊可否分零%Type := 0,
  送货单位_In     药品规格.送货单位%Type := Null,
  送货包装_In     药品规格.送货包装%Type := Null,
  本位码_In       In 药品规格.本位码%Type := Null
) Is
  v_药名id   诊疗项目目录.Id%Type;
  v_名称     诊疗项目目录.名称%Type;
  v_是否变价 收费项目目录.是否变价%Type; --允许定价药品随时改为时价，时价药品只能在未发生的情况下修改为定价，其它情况不允许修改定价属性 
  v_发生     Number(2);
  Err_Notfind Exception;
  v_No         收费价目.No%Type;
  v_Temp       收费项目目录.病案费目%Type;
  v_病案费目   收费项目目录.病案费目%Type;
  n_指导差价率 药品规格.指导差价率%Type;
Begin
  v_病案费目 := 病案费目_In;
  --判断病案费目
  If v_病案费目 Is Null Then
    If 收入id_In Is Not Null Then
      Begin
        Select 病案费目 Into v_Temp From 收入项目 Where ID = 收入id_In;
      Exception
        When Others Then
          v_Temp := Null;
      End;
      If v_Temp Is Not Null Then
        v_病案费目 := v_Temp;
      End If;
    End If;
  End If;
  --通用名称
  Select ID, 名称
  Into v_药名id, v_名称
  From 诊疗项目目录
  Where ID = (Select 药名id From 药品规格 Where 药品id = 药品id_In);
  --取原始的定价属性
  Select 是否变价 Into v_是否变价 From 收费项目目录 Where ID = 药品id_In;
  --规格信息
  Update 收费项目目录
  Set 编码 = 编码_In, 名称 = v_名称, 规格 = 规格_In, 产地 = 产地_In, 计算单位 = 售价单位_In, 费用类型 = 费用类型_In, 服务对象 = 服务对象_In, 屏蔽费别 = 屏蔽费别_In,
      病案费目 = v_病案费目, 说明 = 说明_In, 备选码 = 备选码_In, 站点 = 站点_In
  Where ID = 药品id_In;
  If Sql%RowCount = 0 Then
    Raise Err_Notfind;
  End If;
  n_指导差价率 := (1 - 1 / (1 + 加成率_In / 100)) * 100;
  Update 药品规格
  Set 标识码 = 标识码_In, 药品来源 = 药品来源_In, 批准文号 = 批准文号_In, 注册商标 = 注册商标_In, 剂量系数 = 剂量系数_In, 门诊单位 = 门诊单位_In, 门诊包装 = 门诊包装_In,
      住院单位 = 门诊单位_In, 住院包装 = 门诊包装_In, 药库单位 = 药库单位_In, 药库包装 = 药库包装_In, 申领单位 = 申领单位_In, 申领阀值 = 申领阀值_In, 指导批发价 = 指导批发价_In,
      扣率 = 扣率_In, 指导零售价 = 指导零售价_In, 指导差价率 = n_指导差价率, 管理费比例 = 管理费比例_In, 药价级别 = 药价级别_In, 住院可否分零 = 住院可否分零_In,
      药库分批 = 药库分批_In, 药房分批 = 药房分批_In, 最大效期 = 最大效期_In, 招标药品 = 招标药品_In, Gmp认证 = Gmp认证_In, 差价让利比 = 差价让利比_In,
      合同单位id = 合同单位id_In, 动态分零 = 动态分零_In, 发药类型 = 发药类型_In, 增值税率 = 增值税率_In, 基本药物 = 基本药物_In, 中药形态 = 中药形态_In, 是否常备 = 是否常备_In,
      门诊可否分零 = 门诊可否分零_In, 送货单位 = 送货单位_In, 送货包装 = 送货包装_In, 本位码 = 本位码_In, 加成率 = 加成率_In
  Where 药品id = 药品id_In;

  --朱玉宝修改：建立药品（西成药、中成药）时，缺省服务对象为门诊和住院，因此修改规格药品时，不再根据规格药品的服务对象更新药品的服务对象
  --诊疗项目服务对象的更改
  --select nvl(sum(distinct I.服务对象),0) into v_对象
  --from 收费项目目录 I,药品规格 S
  --where I.ID=S.药品ID and S.药名ID=v_药名ID;
  --update 诊疗项目目录
  --set 服务对象=decode(v_对象,0,0,1,1,2,2,3)
  --where ID=v_药名ID;

  --别名的处理
  If 数字码_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
  Else
    Update 收费项目别名 Set 名称 = v_名称, 简码 = 数字码_In Where 收费细目id = 药品id_In And 性质 = 1 And 码类 = 3;
    If Sql%RowCount = 0 Then
      Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, v_名称, 1, 数字码_In, 3);
    End If;
  End If;
  If 品名_In Is Null Then
    Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3;
  Else
    If 拼音_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 拼音_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 拼音_In, 1);
      End If;
    End If;
    If 五笔_In Is Null Then
      Delete 收费项目别名 Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
    Else
      Update 收费项目别名 Set 名称 = 品名_In, 简码 = 五笔_In Where 收费细目id = 药品id_In And 性质 = 3 And 码类 = 2;
      If Sql%RowCount = 0 Then
        Insert Into 收费项目别名 (收费细目id, 名称, 性质, 简码, 码类) Values (药品id_In, 品名_In, 3, 五笔_In, 2);
      End If;
    End If;
  End If;

  --定价信息：如果已经有发生，则不允许直接更改这些信息
  Select Nvl(Count(*), 0) Into v_发生 From 药品收发记录 Where 药品id = 药品id_In And Rownum < 2;
  If v_发生 = 0 Then
    Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    Update 药品规格 Set 成本价 = 成本价_In Where 药品id = 药品id_In;
    If 收入id_In Is Not Null Then
      Update 收费价目
      Set 现价 = 当前售价_In, 收入项目id = 收入id_In, 变动原因 = 1, 调价说明 = '修改定价', 调价人 = User
      Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
      If Sql%RowCount = 0 Then
        v_No := Nextno(9);
        Insert Into 收费价目
          (ID, 原价id, 收费细目id, 原价, 现价, 收入项目id, 变动原因, 调价说明, 调价人, 执行日期, 终止日期, NO, 序号)
        Values
          (收费价目_Id.Nextval, Null, 药品id_In, 0, 当前售价_In, 收入id_In, 1, '新增定价', User, Sysdate,
           To_Date('3000-01-01', 'YYYY-MM-DD'), v_No, 1);
      End If;
    End If;
  Else
    --定价药品随时可改为时价
    If v_是否变价 = 0 And 是否变价_In = 1 Then
      Update 收费项目目录 Set 是否变价 = 是否变价_In Where ID = 药品id_In;
    End If;
    --发生业务数据时，不能修改价格但是可以修改收入项目
    Update 收费价目
    Set 收入项目id = 收入id_In
    Where 收费细目id = 药品id_In And (Sysdate Between 执行日期 And 终止日期 Or Sysdate >= 执行日期 And 终止日期 Is Null) And 变动原因 = 1;
  End If;

  --药品生产商比较增加
  If 产地_In Is Not Null Then
    Update 药品生产商 Set 名称 = 产地_In Where 名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商
        (编码, 名称, 简码)
        Select Nvl(Max(To_Number(编码)), 0) + 1, 产地_In, zlSpellCode(产地_In, 10) From 药品生产商;
    End If;
  End If;

Exception
  When Err_Notfind Then
    Raise_Application_Error(-20101, '[ZLSOFT]该规格不存在，可能已被其他用户删除！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_草药规格_Update;
/

--119490:刘涛,2018-01-05,药品留存可用数量处理
Create Or Replace Procedure Zl_药品领用_Delete(
                                            --删除药品收发记录及恢复相应的表：药品库存
                                            No_In In 药品收发记录.No%Type) Is
  Err_Isverified Exception;

  Cursor c_药品收发记录 Is
    Select ID, 填写数量, 库房id, 批次, 药品id, 批号, 效期, 产地, 批准文号, 对方部门id, 发药方式
    From 药品收发记录
    Where NO = No_In And 单据 = 7
    Order By 药品id, 批次;
  v_按月留存领用 Varchar2(4000);
  v_下可用数量   药品库存.可用数量%Type;
  v_下可用库存   Zlparameters.参数值%Type;
Begin
  Select zl_GetSysParameter(96) Into v_下可用库存 From Dual;
  Select zl_GetSysParameter('按月留存领用', 1305) Into v_按月留存领用 From Dual;
  --通过循环，恢复原来的可用数量
  For v_药品收发记录 In c_药品收发记录 Loop
    Zl_药品库存_Update(v_药品收发记录.Id, 1);
  
    If v_药品收发记录.发药方式 = 1 Then
      --如果填单时已下可用库存，处理可用数量 
      If v_下可用库存 = '1' Then
        v_下可用数量 := v_药品收发记录.填写数量;
      Else
        v_下可用数量 := 0;
      End If;
    
      Update 药品留存
      Set 可用数量 = Nvl(可用数量, 0) + v_下可用数量
      Where 期间 = To_Char(Sysdate, Decode(v_按月留存领用, '1', 'yyyymm', 'yyyy')) And 科室id = v_药品收发记录.对方部门id And
            库房id = v_药品收发记录.库房id And 药品id = v_药品收发记录.药品id;
    End If;
  End Loop;

  Delete From 药品收发记录 Where NO = No_In And 单据 = 7 And 记录状态 = 1 And 审核人 Is Null;

  If Sql%RowCount = 0 Then
    Raise Err_Isverified;
  End If;
Exception
  When Err_Isverified Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人删除或已被人审核！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品领用_Delete;
/

--123451:黄捷,2018-03-28,RIS接口预约增加打印人和打印时间
--116073:黄捷,2018-01-03,RIS接口支持多HIS库

CREATE OR REPLACE Package b_Zlxwinterface Is
  Type t_Refcur Is Ref Cursor;

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  );

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  );

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  );

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  );

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  );

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  );

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  );

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  );

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type);

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  );

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2;

  --14、删除RIS分院设置参数
  Procedure Ris分院设置_Delete;

  --15、更新RISRis分院设置参数
  Procedure Ris分院设置_Update
  (
    Id_In           Ris分院设置.Id%Type,
    医院名称_In     Ris分院设置.医院名称%Type,
    医院代码_In     Ris分院设置.医院代码%Type,
    用户名_In       Ris分院设置.用户名%Type,
    密码_In         Ris分院设置.密码%Type,
    数据库服务名_In Ris分院设置.数据库服务名%Type
  );
End b_Zlxwinterface;
/

CREATE OR REPLACE Package Body b_Zlxwinterface Is

  --1、接收RIS状态改变
  Procedure Receiverisstate
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    状态_In     Number,
    操作人员_In 病人医嘱发送.完成人%Type,
    执行时间_In 病人医嘱发送.完成时间%Type := Null,
    执行说明_In 病人医嘱发送.执行说明%Type := Null,
    单独执行_In Number := 0
  ) Is
  
    --参数：医嘱ID_IN - 单独执行的医嘱ID。
    --      状态_IN - -1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；15-发放
    --     单独执行_In -0-全部执行；1-单独执行；检查医嘱组合是否采用对每个项目分散单独执行的方式
  
    Cursor c_Adviceinfo Is
      Select a.Id, a.相关id, Nvl(a.相关id, a.Id) As 组id, a.诊疗类别, a.病人来源, a.执行科室id, b.执行过程
      From 病人医嘱记录 A, 病人医嘱发送 B
      Where a.Id = b.医嘱id And ID = 医嘱id_In;
    r_Adviceinfo c_Adviceinfo%RowType;
  
    v_执行状态 病人医嘱发送.执行状态%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    n_执行     Number; --标记是否需要更新状态，1：需要更新，其他不需要更新
    v_Count    Number;
    v_完成人   病人医嘱发送.完成人%Type;
    v_完成时间 病人医嘱发送.完成时间%Type;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    v_执行状态 := 0;
    v_执行过程 := 0;
  
    --提取医嘱的主医嘱ID，及组ID
    Open c_Adviceinfo;
    Fetch c_Adviceinfo
      Into r_Adviceinfo;
    Close c_Adviceinfo;
  
    --根据状态_IN执行医嘱
    ---1-删除；0-预约；1-登记；3-检查完成；4-检查中止；9-初步报告；12-报告审核；13-取消审核；14-报告删除；15-发放
  
    If 状态_In = -1 Or 状态_In = 0 Then
      v_执行状态 := 0; --未执行
      v_执行过程 := 0;
    Elsif 状态_In = 1 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 2; --已报到
    Elsif 状态_In = 3 Or 状态_In = 14 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 3; --已检查
    Elsif 状态_In = 4 Then
      --不改变
      v_执行状态 := v_执行状态;
    Elsif 状态_In = 9 Or 状态_In = 13 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 4; --已报告
    Elsif 状态_In = 12 Then
      v_执行状态 := 3; --正在执行
      v_执行过程 := 5; --已审核
    Elsif 状态_In = 15 Then
      v_执行状态 := 1; --完全执行
      v_执行过程 := 6; --已完成
      v_完成人   := 操作人员_In;
      v_完成时间 := 执行时间_In;
    End If;
  
    n_执行 := 1; --默认都要更新状态
  
    If 状态_In = 13 Or 状态_In = 14 Then
      --删除对应报告数据
      Delete From 电子病历记录
      Where ID = (Select 病历id From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Risid = Risid_In);
      Delete From 病人医嘱报告 Where 医嘱id = 医嘱id_In And Risid = Risid_In;
    
      --删除后判断是否还存在报告，若存在则医嘱状态保持不变，若报告全部删除则更新医嘱状态
      Select Count(1) Into v_Count From 病人医嘱报告 Where 医嘱id = 医嘱id_In;
    
      If v_Count > 0 Then
        n_执行 := 0; --若存在则医嘱状态保持不变
      End If;
    End If;
  
    --如果是登记，先判断此检查是否未执行
    If 状态_In = 1 Then
      If r_Adviceinfo.执行过程 >= 3 Then
        v_Error := '患者已经做过检查了，不能重复登记。';
        Raise Err_Custom;
      End If;
    End If;
  
    --开始执行医嘱
    If n_执行 = 1 Then
      If Nvl(单独执行_In, 0) = 1 Then
        -- 单个部位医嘱单独执行
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id = 医嘱id_In;
      Else
        Update 病人医嘱发送
        Set 执行状态 = v_执行状态, 执行过程 = v_执行过程, 执行说明 = 执行说明_In, 完成人 = v_完成人, 完成时间 = v_完成时间
        Where 医嘱id In (Select ID From 病人医嘱记录 Where (ID = r_Adviceinfo.组id Or 相关id = r_Adviceinfo.组id));
      End If;
    End If;
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receiverisstate;

  --2、费用确认
  Procedure 影像费用执行
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id, 诊疗类别, 病人来源 From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_Temp     Varchar2(255);
    v_人员编号 人员表.编号%Type;
    v_人员姓名 人员表.姓名%Type;
    v_部门id   部门表.Id%Type;
    v_费用性质 病人医嘱发送.记录性质%Type;
    v_发送号   病人医嘱发送.发送号%Type;
    v_执行过程 病人医嘱发送.执行过程%Type;
    v_Count    Number;
    v_Error    Varchar2(255);
    Err_Custom Exception;
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    Select 发送号, 执行过程 Into v_发送号, v_执行过程 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --登记和完成才执行费用  2-登记，3-检查，4-报告，5-审核，6-完成
    If v_执行过程 >= 2 Or v_执行过程 <= 6 Then
    
      --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
      Select Count(*)
      Into v_Count
      From 病人医嘱记录 A, 病案主页 B
      Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Advice.组id;
    
      If v_Count > 0 Then
        --已经出院、预出院或转院，需要判断先是否死亡
        Select Count(*)
        Into v_Count
        From 病人医嘱记录 A, 诊疗项目目录 B, 病人医嘱发送 C
        Where a.Id = c.医嘱id And a.诊疗项目id = b.Id And b.类别 = 'Z' And b.操作类型 = 11 And
              a.病人id = (Select d.病人id From 病人医嘱记录 D Where d.Id = r_Advice.组id);
        If v_Count > 0 Then
          v_Error := '已经对患者下达死亡医嘱，不能执行费用。';
          Raise Err_Custom;
        End If;
        --再判断是否已经预约，已经预约可执行
        Select Count(*) Into v_Count From Ris检查预约 Where 医嘱id = r_Advice.组id;
        If v_Count = 0 Then
          --已经出院或者预出院，未预约，如果在旧版PACS已经报到，也可以执行
          Select Count(*) Into v_Count From 影像检查记录 Where 医嘱id = r_Advice.组id;
          If v_Count = 0 Then
            v_Error := '住院病人已经出院或者预出院，不能执行费用。';
            Raise Err_Custom;
          End If;
        End If;
      End If;
    
      --取当前操作人员
      If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null And 执行部门id_In Is Not Null Then
        v_人员编号 := 操作员编号_In;
        v_人员姓名 := 操作员姓名_In;
        v_部门id   := 执行部门id_In;
      Else
        v_Temp     := Zl_Identity;
        v_部门id   := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
        v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
        v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
        v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      End If;
    
      If r_Advice.病人来源 = 2 Then
        Select Decode(记录性质, 1, 1, Decode(门诊记帐, 1, 1, 2))
        Into v_费用性质
        From 病人医嘱发送
        Where 发送号 = v_发送号 And 医嘱id = 医嘱id_In;
      Else
        v_费用性质 := 1;
      End If;
    
      --执行费用和自动发料
      If v_费用性质 = 1 Then
        Zl_门诊医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      Else
        Zl_住院医嘱执行_Finish(医嘱id_In, v_发送号, 单独执行_In, v_人员编号, v_人员姓名, r_Advice.组id, r_Advice.诊疗类别, v_部门id);
      End If;
    End If;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行;

  --3、取消费用确认
  Procedure 影像费用执行_Cancel
  (
    医嘱id_In     影像检查记录.医嘱id%Type,
    单独执行_In   Number := 0,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := Null
  ) Is
    --参数：
    --      医嘱ID_IN=单独执行的医嘱ID。
    --      单独执行_In=检查医嘱组合是否采用对每个项目分散单独执行的方式,0-不单独执行
  
    Cursor c_Advice Is
      Select ID, 相关id, Nvl(相关id, ID) As 组id From 病人医嘱记录 Where ID = 医嘱id_In;
    r_Advice c_Advice%RowType;
  
    v_发送号 病人医嘱发送.发送号%Type;
    v_Count  Number;
    v_Error  Varchar2(255);
    Err_Custom Exception;
  
  Begin
  
    --取主医嘱ID
    Open c_Advice;
    Fetch c_Advice
      Into r_Advice;
    Close c_Advice;
  
    --先检查是否已经出院的住院病人，已经预出院或者出院的检查申请，不允执行费用
    Select Count(*)
    Into v_Count
    From 病人医嘱记录 A, 病案主页 B
    Where a.病人id = b.病人id And a.主页id = b.主页id And (b.出院日期 Is Not Null Or b.状态 = 3) And a.Id = r_Advice.组id;
  
    If v_Count > 0 Then
      v_Error := '住院病人已经出院或者预出院，不能取消费用。';
      Raise Err_Custom;
    End If;
  
    Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = r_Advice.组id;
  
    --调用统一的医嘱执行Cancel过程
    Zl_病人医嘱执行_Cancel(医嘱id_In, v_发送号, Null, 单独执行_In, 执行部门id_In, 操作员编号_In, 操作员姓名_In);
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像费用执行_Cancel;

  --4、接收RIS的报告
  Procedure Receivereport
  (
    医嘱id_In   病人医嘱发送.医嘱id%Type,
    Risid_In    病人医嘱报告.Risid%Type,
    报告所见_In 电子病历内容.内容文本%Type,
    报告意见_In 电子病历内容.内容文本%Type,
    报告建议_In 电子病历内容.内容文本%Type,
    报告医生_In 电子病历记录.创建人%Type
  ) Is
    --提取病人医嘱及报告的相关信息
    Cursor c_Advice
    (
      v_组id  Number,
      v_Risid Number
    ) Is
      Select e.Id, e.病人来源, e.病人id, e.主页id, e.婴儿, e.病人科室id, e.文件id, e.病历种类, e.病历名称, f.病历id, e.执行科室id
      From (Select c.Id, c.病人来源, c.病人id, c.主页id, c.婴儿, c.病人科室id, c.文件id, d.种类 病历种类, d.名称 病历名称, c.执行科室id
             From (Select a.Id, a.病人来源, a.病人id, a.主页id, a.婴儿, a.病人科室id, b.病历文件id 文件id, a.执行科室id
                    From 病人医嘱记录 A, 病历单据应用 B
                    Where a.Id = v_组id And a.诊疗项目id = b.诊疗项目id(+) And b.应用场合(+) = Decode(a.病人来源, 2, 2, 4, 4, 1)) C,
                  病历文件列表 D
             Where c.文件id = d.Id(+)) E, 病人医嘱报告 F
      Where e.Id = f.医嘱id(+) And f.Risid(+) = v_Risid;
  
    --查找文件的组成元素
    Cursor c_File(v_File Number) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where a.文件id = v_File
      Order By a.对象序号;
  
    Cursor c_Report(v_电子病历记录id Number) Is
      Select b.Id, a.内容文本
      From 电子病历内容 A, 电子病历内容 B
      Where a.对象类型 = 3 And a.Id = b.父id And b.对象类型 = 2 And b.终止版 = 0 And a.文件id = v_电子病历记录id;
  
    Cursor c_Content
    (
      v_文件id Number,
      v_表格id Number
    ) Is
      Select a.Id, a.文件id, a.父id, a.对象序号, a.对象类型, a.对象标记, a.保留对象, a.对象属性, a.内容行次, a.内容文本, a.是否换行, a.预制提纲id, a.复用提纲,
             a.使用时机, a.诊治要素id, a.替换域, a.要素名称, a.要素类型, a.要素长度, a.要素小数, a.要素单位, a.要素表示, a.输入形态, a.要素值域
      From 病历文件结构 A
      Where 文件id = v_文件id And 父id = v_表格id;
  
    r_Advice        c_Advice%RowType;
    v_病历id        电子病历内容.文件id%Type;
    v_病历内容id    电子病历内容.Id%Type;
    v_病历内容idnew 电子病历内容.Id%Type;
    v_对象序号      电子病历内容.对象序号%Type;
    v_父id          电子病历内容.父id%Type;
    v_内容文本      电子病历内容.内容文本%Type;
    v_定义提纲id    电子病历内容.定义提纲id%Type;
    --v_格式内容    电子病历格式.内容%Type;
    v_Error Varchar2(255);
    Err_Custom Exception;
    v_主医嘱id 病人医嘱发送.医嘱id%Type;
    v_表格     Varchar2(300);
    n_数量     Number;
    n_Rptcount Number;
    v_病历名称 电子病历记录.病历名称%Type;
    v_挂号单id 病人挂号记录.Id%Type;
  
    Function Getrptno
    (
      v_医嘱idin   病人医嘱发送.医嘱id%Type,
      v_病历名称in 电子病历记录.病历名称%Type
    ) Return Varchar As
      v_Return Number;
      v_No     Number;
      v_Count  Number;
    Begin
      Select Count(医嘱id) + 1 Into v_No From 病人医嘱报告 Where 医嘱id = v_医嘱idin;
      v_Count := 1;
      While v_Count = 1 Loop
        Select Count(ID)
        Into v_Count
        From 病人医嘱报告 A, 电子病历记录 B
        Where a.医嘱id = v_医嘱idin And a.病历id = b.Id And b.病历名称 = v_病历名称in || v_No;
        If v_Count = 1 Then
          v_No := v_No + 1;
        End If;
      End Loop;
      v_Return := v_No;
      Return v_Return;
    End Getrptno;
  
  Begin
  
    -- 提取主医嘱ID ，防止因为传入部位医嘱，导致报告保存出错
    Select Nvl(相关id, ID) As 组id Into v_主医嘱id From 病人医嘱记录 Where ID = 医嘱id_In;
  
    Open c_Advice(v_主医嘱id, Nvl(Risid_In, 0));
    Fetch c_Advice
      Into r_Advice;
  
    If Nvl(r_Advice.文件id, 0) = 0 Then
      v_Error := '本次检查项目没有对应相关的检查报告，请与管理员联系！';
      Raise Err_Custom;
    Else
      If Nvl(r_Advice.病历id, 0) > 0 Then
        ----产生过报告
        --找出检查已填写的报告提纲中含有"%所见%","%描述%","%建议%","%意见%",并用传入的参数更新
        For r_Report In c_Report(r_Advice.病历id) Loop
          If r_Report.内容文本 Like '%所见%' Then
            Update 电子病历内容 Set 内容文本 = 报告所见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%意见%' Then
            Update 电子病历内容 Set 内容文本 = 报告意见_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          Elsif r_Report.内容文本 Like '%建议%' Then
            Update 电子病历内容 Set 内容文本 = 报告建议_In || Chr(13) || Chr(13) Where ID = r_Report.Id;
          End If;
        End Loop;
        --更新保存时间
        Update 电子病历记录
        Set 完成时间 = Sysdate, 保存人 = 报告医生_In, 保存时间 = Sysdate
        Where ID = r_Advice.病历id;
      Else
        --先判断单据中是否有对应的提纲和表格
        If Nvl(报告所见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%所见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【所见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告意见_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%意见%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【意见】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
        If Nvl(报告建议_In, ' ') <> ' ' Then
          Select Count(1)
          Into n_数量
          From 病历文件结构 A, 病历文件结构 B
          Where a.父id = b.Id And a.对象类型 = 3 And b.对象类型 = 1 And a.内容文本 Like '%建议%' And a.文件id = r_Advice.文件id;
        
          If n_数量 <= 0 Then
            v_Error := '在诊疗单据中没有找到【建议】对应的提纲或表格，请联系管理员设置！';
            Raise Err_Custom;
          End If;
        End If;
      
        If r_Advice.病人来源 = 1 Then
          --门诊，提取挂号单ID
          Select Nvl(c.Id, 0)
          Into v_挂号单id
          From 病人医嘱记录 B, 病人挂号记录 C
          Where b.挂号单 = c.No(+) And c.记录状态 In (1, 3) And b.Id = v_主医嘱id;
        Else
          --体检或者外诊，无挂号单ID，直接设置为0
          v_挂号单id := 0;
        End If;
      
        --产生电子病历记录
        Select 电子病历记录_Id.Nextval Into v_病历id From Dual;
        n_Rptcount := Getrptno(医嘱id_In, r_Advice.病历名称);
        If n_Rptcount > 1 Then
          v_病历名称 := r_Advice.病历名称 || n_Rptcount;
        Else
          v_病历名称 := r_Advice.病历名称;
        End If;
        Insert Into 电子病历记录
          (ID, 病人来源, 病人id, 主页id, 婴儿, 科室id, 病历种类, 文件id, 病历名称, 创建人, 创建时间, 完成时间, 保存人, 保存时间, 最后版本, 签名级别)
        Values
          (v_病历id, r_Advice.病人来源, r_Advice.病人id, Decode(r_Advice.病人来源, 2, r_Advice.主页id, v_挂号单id), r_Advice.婴儿,
           r_Advice.病人科室id, r_Advice.病历种类, r_Advice.文件id, v_病历名称, 报告医生_In, Sysdate, Sysdate, 报告医生_In, Sysdate, 1, 2);
      
        --产生医嘱报告记录
        Insert Into 病人医嘱报告 (医嘱id, 病历id, Risid) Values (v_主医嘱id, v_病历id, Risid_In);
      
        v_对象序号 := 0;
      
        --新产生报告内容
        For r_File In c_File(r_Advice.文件id) Loop
          Select 电子病历内容_Id.Nextval Into v_病历内容id From Dual;
          v_内容文本   := r_File.内容文本;
          v_定义提纲id := 0;
        
          If Nvl(r_File.对象类型, 0) = 1 And Nvl(r_File.父id, 0) = 0 Then
            --提纲
            v_定义提纲id := r_File.Id;
            v_父id       := v_病历内容id;
          End If;
        
          If Nvl(r_File.对象类型, 0) = 4 And r_File.要素名称 Is Not Null Then
            --元素
            v_内容文本 := Zl_Replace_Element_Value(r_File.要素名称, r_Advice.病人id, r_Advice.主页id, r_Advice.病人来源, r_Advice.Id);
          End If;
        
          If Nvl(r_File.父id, 0) <> 0 Then
            v_定义提纲id := 0;
          End If;
        
          v_对象序号 := v_对象序号 + 1;
        
          If Instr(v_表格, '|' || r_File.父id || '|') > 0 Then
            Null;
          Else
            Insert Into 电子病历内容
              (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id, 替换域,
               要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
            Values
              (v_病历内容id, v_病历id, 1, 0, Decode(v_定义提纲id, 0, v_父id, Null), v_对象序号, r_File.对象类型, r_File.对象标记, r_File.保留对象,
               r_File.对象属性, Null, v_内容文本, r_File.是否换行, r_File.预制提纲id, r_File.复用提纲, r_File.使用时机, r_File.诊治要素id,
               r_File.替换域, r_File.要素名称, r_File.要素类型, r_File.要素长度, r_File.要素小数, r_File.要素单位, r_File.要素表示, r_File.输入形态,
               r_File.要素值域, Decode(v_定义提纲id, 0, Null, v_定义提纲id));
          End If;
        
          --为表格时，插入文本内容
          If Nvl(r_File.对象类型, 0) = 3 And Nvl(r_File.父id, 0) <> 0 Then
            v_表格 := v_表格 || ',|' || r_File.Id || '|';
          
            If r_File.内容文本 Like '%所见%' Then
              v_内容文本 := 报告所见_In || Chr(13) || Chr(13);
            Elsif r_File.内容文本 Like '%意见%' Then
              v_内容文本 := 报告意见_In || Chr(13) || Chr(13);
            Else
              v_内容文本 := 报告建议_In || Chr(13) || Chr(13);
            End If;
          
            For r_Con In c_Content(r_Advice.文件id, r_File.Id) Loop
              Select 电子病历内容_Id.Nextval Into v_病历内容idnew From Dual;
              v_对象序号 := v_对象序号 + 1;
            
              Insert Into 电子病历内容
                (ID, 文件id, 开始版, 终止版, 父id, 对象序号, 对象类型, 对象标记, 保留对象, 对象属性, 内容行次, 内容文本, 是否换行, 预制提纲id, 复用提纲, 使用时机, 诊治要素id,
                 替换域, 要素名称, 要素类型, 要素长度, 要素小数, 要素单位, 要素表示, 输入形态, 要素值域, 定义提纲id)
              Values
                (v_病历内容idnew, v_病历id, 1, 0, v_病历内容id, v_对象序号, 2, r_Con.对象标记, r_Con.保留对象, r_Con.对象属性, Null, v_内容文本,
                 r_Con.是否换行, r_Con.预制提纲id, r_Con.复用提纲, r_Con.使用时机, r_Con.诊治要素id, r_Con.替换域, r_Con.要素名称, r_Con.要素类型,
                 r_Con.要素长度, r_Con.要素小数, r_Con.要素单位, r_Con.要素表示, r_Con.输入形态, r_Con.要素值域,
                 Decode(v_定义提纲id, 0, Null, v_定义提纲id));
            End Loop;
          End If;
        End Loop;
      
        --因电子病历格式中含了内容文字格式，此种方法导入之后内容文字将不可见
        --Select 内容 Into v_格式内容 From 病历文件格式 Where 文件ID=r_Advice.文件ID;
        --Insert Into 电子病历格式 (文件ID,内容) Values (v_病历id,v_格式内容);
      
      End If;
    End If;
    Close c_Advice;
  
  Exception
    When Err_Custom Then
      Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Receivereport;

  --5、修改申请单信息
  Procedure 影像病人信息_修改
  (
    医嘱id_In       病人医嘱记录.Id%Type,
    姓名_In         病人信息.姓名%Type,
    性别_In         病人信息.性别%Type,
    年龄_In         病人信息.年龄%Type,
    费别_In         病人信息.费别%Type,
    医疗付款方式_In 病人信息.医疗付款方式%Type,
    民族_In         病人信息.民族%Type,
    婚姻_In         病人信息.婚姻状况%Type,
    职业_In         病人信息.职业%Type,
    身份证号_In     病人信息.身份证号%Type,
    家庭地址_In     病人信息.家庭地址%Type,
    家庭电话_In     病人信息.家庭电话%Type,
    家庭地址邮编_In 病人信息.家庭地址邮编%Type,
    出生日期_In     病人信息.出生日期%Type := Null
  ) As
  
    v_年龄     Varchar2(20);
    v_年龄单位 Varchar2(20);
    v_出生日期 Date;
    v_病人来源 病人医嘱记录.病人来源%Type;
    v_病人id   病人医嘱记录.病人id%Type;
  Begin
    Begin
      Select 病人来源, 病人id Into v_病人来源, v_病人id From 病人医嘱记录 Where ID = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    If 出生日期_In Is Null And 年龄_In Is Not Null Then
      --根据年龄求出生日期
      v_年龄单位 := Substr(年龄_In, Length(年龄_In), 1);
      If Instr('岁,月,天', v_年龄单位) <= 0 Then
        v_年龄单位 := Null;
      Else
        v_年龄 := Replace(年龄_In, v_年龄单位, '');
      End If;
      Begin
        v_年龄 := To_Number(v_年龄);
      Exception
        When Others Then
          v_年龄 := Null;
      End;
      If v_年龄 Is Not Null And v_年龄单位 Is Not Null Then
        Select Decode(v_年龄单位, '岁', Add_Months(Sysdate, -12 * v_年龄), '月', Add_Months(Sysdate, -1 * v_年龄), '天',
                       Sysdate - v_年龄)
        Into v_出生日期
        From Dual;
      End If;
    Else
      v_出生日期 := 出生日期_In;
    End If;
  
    If v_病人来源 = 3 Then
      Update 病人信息
      Set 姓名 = 姓名_In, 性别 = Nvl(性别_In, 性别), 年龄 = 年龄_In, 出生日期 = v_出生日期, 费别 = Nvl(费别_In, 费别),
          医疗付款方式 = Nvl(医疗付款方式_In, 医疗付款方式), 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业),
          身份证号 = 身份证号_In, 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In, 家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    
      --修改对应的医嘱记录
      Update 病人医嘱记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where ID = 医嘱id_In Or 相关id = 医嘱id_In;
    Else
      Update 病人信息
      Set 民族 = Nvl(民族_In, 民族), 婚姻状况 = Nvl(婚姻_In, 婚姻状况), 职业 = Nvl(职业_In, 职业), 家庭地址 = 家庭地址_In, 家庭电话 = 家庭电话_In,
          家庭地址邮编 = 家庭地址邮编_In
      Where 病人id = v_病人id;
    End If;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 影像病人信息_修改;

  --6、取消申请单信息
  Procedure 取消检查申请单
  (
    医嘱id_In     病人医嘱执行.医嘱id%Type,
    操作员编号_In 人员表.编号%Type := Null,
    操作员姓名_In 人员表.姓名%Type := Null,
    执行部门id_In 门诊费用记录.执行部门id%Type := 0,
    拒绝原因_In   病人医嘱发送.执行说明%Type := Null
  ) As
    --参数：医嘱ID_IN=单独执行的医嘱ID
  
    v_发送号 病人医嘱执行.发送号%Type;
  
  Begin
  
    Begin
      Select 发送号 Into v_发送号 From 病人医嘱发送 Where 医嘱id = 医嘱id_In;
    Exception
      When Others Then
        Return;
    End;
  
    Zl_病人医嘱执行_拒绝执行(医嘱id_In, v_发送号, 操作员编号_In, 操作员姓名_In, 执行部门id_In, 拒绝原因_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 取消检查申请单;

  --7、插入医嘱操作失败记录
  Procedure Ris医嘱失败记录_Insert
  (
    病人来源_In   In Ris医嘱失败记录.病人来源%Type,
    病人id_In     In Ris医嘱失败记录.病人id%Type,
    主页id_In     In Ris医嘱失败记录.主页id%Type,
    挂号单号_In   In Ris医嘱失败记录.挂号单号%Type,
    发送号_In     In Ris医嘱失败记录.发送号%Type,
    体检任务id_In In Ris医嘱失败记录.体检任务id%Type,
    体检报到号_In In Ris医嘱失败记录.体检报到号%Type,
    发送类型_In   In Ris医嘱失败记录.发送类型%Type
  ) Is
  Begin
    Insert Into Ris医嘱失败记录
      (ID, 病人来源, 病人id, 主页id, 挂号单号, 发送号, 体检任务id, 体检报到号, 发送类型, 发送时间, 重发次数)
    Values
      (Ris医嘱失败记录_Id.Nextval, 病人来源_In, 病人id_In, 主页id_In, 挂号单号_In, 发送号_In, 体检任务id_In, 体检报到号_In, 发送类型_In, Sysdate, 0);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris医嘱失败记录_Insert;

  --8、更新医嘱操作失败记录
  Procedure Ris医嘱失败记录_重发
  (
    Id_In       In Ris医嘱失败记录.Id%Type,
    操作类型_In In Number
  ) Is
    v_重发次数 Ris医嘱失败记录.重发次数%Type;
  Begin
    --操作类型_In -- 1 重发成功，删除记录；2--重发失败
  
    If 操作类型_In = 1 Then
      Delete From Ris医嘱失败记录 Where ID = Id_In;
    Else
      Select 重发次数 Into v_重发次数 From Ris医嘱失败记录 Where ID = Id_In;
      If v_重发次数 >= 99 Then
        v_重发次数 := 99;
      Else
        v_重发次数 := v_重发次数 + 1;
      End If;
      Update Ris医嘱失败记录 Set 发送时间 = Sysdate, 重发次数 = v_重发次数 Where ID = Id_In;
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris医嘱失败记录_重发;

  --9、销账后新建住院记账单据
  Procedure 病人医嘱_重建单据
  (
    医嘱id_In In 病人医嘱发送.医嘱id%Type,
    No_In     In 病人医嘱发送.No%Type,
    Action_In In Number
  ) Is
    -- Action_In: 1 重建单据；2 取消重建单据
    v_No 病人医嘱发送.No%Type;
  Begin
    If Action_In = 1 Then
      Select Nextno(14) Into v_No From Dual;
    
      Update 病人医嘱发送
      Set NO = v_No, 计费状态 = 0
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
      Update 住院费用记录 Set 医嘱序号 = Null Where NO = No_In;
    Elsif Action_In = 2 Then
      Update 住院费用记录 Set 医嘱序号 = 医嘱id_In Where NO = No_In;
      Update 病人医嘱发送
      Set NO = No_In, 计费状态 = 4
      Where 医嘱id In (Select ID From 病人医嘱记录 Where ID = 医嘱id_In Or 相关id = 医嘱id_In);
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End 病人医嘱_重建单据;

  --10、打印RIS检查预约通知单
  Procedure Ris检查预约_打印(医嘱id_In In Ris检查预约.医嘱id%Type) Is
    v_Temp     Varchar2(255);
    v_人员姓名 人员表.姓名%Type;
  Begin
    --取当前操作人员  
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  
    Update Ris检查预约 Set 是否打印 = 1, 打印人 = v_人员姓名, 打印时间 = Sysdate Where 医嘱id = 医嘱id_In;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris检查预约_打印;

  --11、更新RIS分科室启用参数
  Procedure Ris启用控制_Update
  (
    检查类型_In Ris启用控制.检查类型%Type,
    场合_In     Ris启用控制.场合%Type,
    部门ids_In  Varchar2,
    启用类型_In Number
  ) Is
  
    l_部门id   t_Numlist := t_Numlist();
    v_启用ris  Ris启用控制.是否启用ris%Type;
    v_启用预约 Ris启用控制.是否启用预约%Type;
  
    Cursor c_Dept(Dept_In Varchar2) Is
      Select Column_Value From Table(f_Num2list(Dept_In));
  Begin
  
    If 启用类型_In = 1 Then
      v_启用ris  := 1;
      v_启用预约 := Null;
      Delete From Ris启用控制 Where 检查类型 = 检查类型_In And 场合 = 场合_In And 是否启用ris = 1;
    Else
      v_启用ris  := Null;
      v_启用预约 := 1;
      Delete From Ris启用控制 Where 检查类型 = 检查类型_In And 场合 = 场合_In And 是否启用预约 = 1;
    End If;
  
    If 部门ids_In Is Null Then
      Insert Into Ris启用控制
        (ID, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
      Values
        (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, Null, v_启用ris, v_启用预约);
    Else
      Open c_Dept(部门ids_In);
      Fetch c_Dept Bulk Collect
        Into l_部门id;
      Close c_Dept;
    
      Forall I In 1 .. l_部门id.Count
        Insert Into Ris启用控制
          (ID, 检查类型, 场合, 部门id, 是否启用ris, 是否启用预约)
        Values
          (Ris启用控制_Id.Nextval, 检查类型_In, 场合_In, l_部门id(I), v_启用ris, v_启用预约);
    End If;
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris启用控制_Update;

  --12、删除RIS分科室启用参数
  Procedure Ris启用控制_Delete Is
  
  Begin
    Delete From Ris启用控制;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris启用控制_Delete;

  --13、根据元素名提取信息
  Function Ris_Replace_Element_Value
  (
    元素名_In   In 诊治所见项目.中文名%Type,
    病人id_In   In 电子病历记录.病人id%Type,
    就诊id_In   In 电子病历记录.主页id%Type,
    病人来源_In In 电子病历记录.病人来源%Type,
    医嘱id_In   In 病人医嘱发送.医嘱id%Type
  ) Return Varchar2 Is
    v_Return Varchar2(4000) := Null;
    Cursor c_Patient Is
      Select 姓名, 性别, Decode(性别, '男', 'M', '女', 'F', 'O') As 性别编码, 出生日期, 病人id, 联系人地址, 家庭电话, 联系人电话, 婚姻状况, 身份证号, 当前科室id,
             当前病区id, 当前床号 As 床号, 就诊卡号, 入院时间, 出院时间
      From 病人信息
      Where 病人id = 病人id_In;
    r_Patient c_Patient%RowType;
  
    Cursor c_Order Is
      Select 主页id, 婴儿, Decode(病人来源, 1, 'OUTPAT', 2, 'INPAT', 'UNK') As 病人来源, 开嘱医生, 开嘱时间, 校对护士, 医嘱内容, 紧急标志, 执行科室id
      From 病人医嘱记录
      Where ID = 医嘱id_In;
    r_Order c_Order%RowType;
  
    Cursor c_Diagnose Is
      Select 诊断描述 || Decode(Nvl(是否疑诊, 0), 0, '', ' (？)') As 临床诊断
      From 病人诊断医嘱 A, 病人诊断记录 B
      Where a.医嘱id = 医嘱id_In And a.诊断id = b.Id;
    r_Diagnose c_Diagnose%RowType;
  
    --获取指定表的行类型
    Procedure p_Get_Rowtype(Table_In In Varchar2) Is
    Begin
      If Table_In = '病人信息' Then
        Open c_Patient;
        Fetch c_Patient
          Into r_Patient;
      Elsif Table_In = '病人医嘱记录' Then
        Open c_Order;
        Fetch c_Order
          Into r_Order;
      Elsif Table_In = '病人诊断记录' Then
        Open c_Diagnose;
        Fetch c_Diagnose
          Into r_Diagnose;
      End If;
    Exception
      When Others Then
        Null;
    End p_Get_Rowtype;
  
  Begin
    Case
    --直接返回的输入元素
      When 元素名_In = '医嘱ID' Then
        v_Return := 医嘱id_In;
      When 元素名_In = '病人ID' Then
        v_Return := 病人id_In;
      
    --姓名，性别单独处理，可能是婴儿
      When Instr(',姓名,性别,性别编码,出生日期,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        p_Get_Rowtype('病人信息');
        If Nvl(r_Order.婴儿, 0) = 0 Then
          If 元素名_In = '姓名' Then
            v_Return := r_Patient.姓名;
          Elsif 元素名_In = '性别' Then
            v_Return := r_Patient.性别;
          Elsif 元素名_In = '性别编码' Then
            v_Return := r_Patient.性别编码;
          Elsif 元素名_In = '出生日期' Then
            v_Return := To_Char(r_Patient.出生日期, 'YYYYMMDDMISS');
          End If;
        Else
          If 元素名_In = '姓名' Then
            Select Decode(婴儿姓名, Null, r_Patient.姓名 || '之婴' || Trim(To_Char(序号, '9')), 婴儿姓名) As 婴儿姓名
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
          Elsif Instr('性别', 元素名_In) > 0 Then
            Select 婴儿性别
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
            If 元素名_In = '性别编码' Then
              Select Decode(v_Return, '男', 'M', '女', 'F', 'O') Into v_Return From Dual;
            End If;
          Elsif 元素名_In = '出生日期' Then
            Select 出生时间
            Into v_Return
            From 病人新生儿记录
            Where 病人id = 病人id_In And 主页id = r_Order.主页id And 序号 = Nvl(r_Order.婴儿, 0);
            v_Return := To_Char(v_Return, 'YYYYMMDDMISS');
          End If;
        End If;
      
    --查询病人信息表返回的元素
      When Instr(',联系人地址,家庭电话,联系人电话,婚姻状况,身份证号,床号,就诊卡号,入院时间,出院时间,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人信息');
        Case 元素名_In
          When '联系人地址' Then
            v_Return := r_Patient.联系人地址;
          When '家庭电话' Then
            v_Return := r_Patient.家庭电话;
          When '联系人电话' Then
            v_Return := r_Patient.联系人电话;
          When '婚姻状况' Then
            v_Return := r_Patient.婚姻状况;
          When '身份证号' Then
            v_Return := r_Patient.身份证号;
          When '床号' Then
            v_Return := r_Patient.床号;
          When '就诊卡号' Then
            v_Return := r_Patient.就诊卡号;
          When '入院时间' Then
            v_Return := To_Char(r_Patient.入院时间, 'YYYYMMDDMISS');
          When '出院时间' Then
            v_Return := To_Char(r_Patient.出院时间, 'YYYYMMDDMISS');
          Else
            v_Return := '';
        End Case;
        --查询医嘱表返回的元素
      When Instr(',病人来源,开嘱医生,开嘱时间,校对护士,医嘱内容,紧急标志,紧急标志对码,', ',' || 元素名_In || ',') > 0 Then
        p_Get_Rowtype('病人医嘱记录');
        Case 元素名_In
          When '病人来源' Then
            v_Return := r_Order.病人来源;
          When '开嘱医生' Then
            v_Return := r_Order.开嘱医生;
          When '开嘱时间' Then
            v_Return := To_Char(r_Order.开嘱时间, 'YYYYMMDDMISS');
          When '校对护士' Then
            v_Return := r_Order.校对护士;
          When '医嘱内容' Then
            v_Return := r_Order.医嘱内容;
          When '紧急标志' Then
            v_Return := r_Order.紧急标志;
        End Case;
        --查询诊断记录返回的元素
      When 元素名_In = '临床诊断' Then
        p_Get_Rowtype('病人诊断记录');
        v_Return := r_Diagnose.临床诊断;
      
      Else
        --自行查询SQL返回值的元素
        If 元素名_In = '执行站点' Then
          p_Get_Rowtype('病人医嘱记录');
          Select Decode(站点, 1, 'SITE0002', 2, 'SITE0001', 3, 'SITE0003', 'SITE0001')
          Into v_Return
          From 部门表
          Where ID = r_Order.执行科室id;
        End If;
        If 元素名_In = '当前科室名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where ID = r_Patient.当前科室id;
        End If;
        If 元素名_In = '病区名称' Then
          p_Get_Rowtype('病人信息');
          Select 名称 Into v_Return From 部门表 Where ID = r_Patient.当前病区id;
        End If;
        If 元素名_In = '标识号' Then
          Select Decode(a.病人来源, 1, c.门诊号, 2, Decode(c.住院号, Null, c.门诊号, c.住院号), 4, c.健康号, c.门诊号)
          Into v_Return
          From 病人医嘱记录 A, 病人信息 C
          Where a.病人id = c.病人id And a.Id = 医嘱id_In;
        End If;
    End Case;
  
    Return Trim(v_Return);
  Exception
    When Others Then
      Return Null;
  End Ris_Replace_Element_Value;

  --14、删除RIS分院设置参数
  Procedure Ris分院设置_Delete Is
  Begin
    Delete From Ris分院设置;
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris分院设置_Delete;

  --15、更新RISRis分院设置参数
  Procedure Ris分院设置_Update
  (
    Id_In           Ris分院设置.Id%Type,
    医院名称_In     Ris分院设置.医院名称%Type,
    医院代码_In     Ris分院设置.医院代码%Type,
    用户名_In       Ris分院设置.用户名%Type,
    密码_In         Ris分院设置.密码%Type,
    数据库服务名_In Ris分院设置.数据库服务名%Type
  ) Is
  
  Begin
  
    Insert Into Ris分院设置
      (ID, 医院名称, 医院代码, 用户名, 密码, 数据库服务名)
    Values
      (Id_In, 医院名称_In, 医院代码_In, 用户名_In, 密码_In, 数据库服务名_In);
  
  Exception
    When Others Then
      zl_ErrorCenter(SQLCode, SQLErrM);
  End Ris分院设置_Update;

End b_Zlxwinterface;
/
--119413:秦龙,2018-01-12,修正外观字段无值
--118294:刘涛,2018-01-03,外购退库冲销差价调整处理
Create Or Replace Procedure Zl_药品外购_Strike
(
  行次_In       In Integer,
  原记录状态_In In 药品收发记录.记录状态%Type,
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  冲销数量_In   Number,
  填制人_In     In 药品收发记录.填制人%Type,
  填制日期_In   In 药品收发记录.填制日期%Type,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  全部冲销_In   In 药品收发记录.实际数量%Type := 0, --用于财务审核
  财务审核_In   In Number := 0, --财务审核标志
  摘要_In       In 药品收发记录.摘要%Type,
  发票代码_In   In 应付记录.发票代码%Type := Null
) Is
  Err_Isstriked Exception;
  Err_Isoutstock Exception;
  Err_Isbatch Exception;
  Err_Isnonum Exception;
  v_Druginf Varchar2(50); --原不分批现在分批的药品信息

  v_应付id       应付记录.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_供药单位id   药品收发记录.供药单位id%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_产地         药品收发记录.产地%Type;
  v_批次         药品收发记录.批次%Type;
  v_批号         药品收发记录.批号%Type;
  v_效期         药品收发记录.效期%Type;
  v_成本价       药品收发记录.成本价%Type;
  v_成本金额     药品收发记录.成本金额%Type;
  v_扣率         药品收发记录.扣率%Type;
  v_零售价       药品收发记录.零售价%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_剩余数量     Number;
  v_剩余成本金额 药品收发记录.成本金额%Type;
  v_剩余零售金额 药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_冲销数量     Number;
  v_单量         药品收发记录.单量%Type;
  v_生产日期     药品收发记录.生产日期%Type;
  v_批准文号     药品收发记录.批准文号%Type;
  v_剩余金额差   药品收发记录.零售金额%Type;
  v_冲销金额差   药品收发记录.零售金额%Type;
  v_加成率       药品收发记录.频次%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_计划id       药品收发记录.计划id%Type;

  v_外观     药品收发记录.外观%Type;
  v_核查人   药品收发记录.配药人%Type;
  v_核查日期 药品收发记录.配药日期%Type;
  v_发药方式 Number;
  v_收发id   药品收发记录.Id%Type;

  v_药库分批         Integer;
  v_药房分批         Integer;
  v_分批属性         Integer;
  v_药库             Integer;
  v_分批             Number;
  v_入库id           Number;
  v_差价修正金额     药品收发记录.零售金额%Type;
  v_差价修正冲销金额 药品收发记录.零售金额%Type;
  v_原成本价         药品收发记录.成本价%Type;
  n_收发id           药品收发记录.Id%Type;

  Intdigit   Number;
  v_发票金额 Number;
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;
  --取核查人
  Select Min(配药人) 配药人, Min(配药日期) 配药日期, Sum(实际数量) 实际数量
  Into v_核查人, v_核查日期, v_冲销数量
  From 药品收发记录
  Where NO = No_In And 单据 = 1 And 序号 = 序号_In
  Group By 配药人, 配药日期;

  If 行次_In = 1 Then
    Update 药品收发记录
    Set 记录状态 = Decode(原记录状态_In, 1, 3, 原记录状态_In + 3), 费用id = 财务审核_In
    Where NO = No_In And 单据 = 1 And 记录状态 = 原记录状态_In;
  
    If Sql%RowCount = 0 Then
      Raise Err_Isstriked;
    End If;
  End If;

  --主要针对原不分批现在分批的药品，不能对其审核
  Begin
    Select Distinct '(' || i.编码 || ')' || Nvl(n.名称, i.名称) As 药品信息
    Into v_Druginf
    From 药品收发记录 A, 药品规格 B, 收费项目目录 I, 收费项目别名 N
    Where a.药品id = b.药品id And a.药品id = i.Id And a.药品id = n.收费细目id(+) And n.性质(+) = 3 And a.No = No_In And a.单据 = 1 And
          Mod(a.记录状态, 3) = 0 And Nvl(a.批次, 0) = 0 And a.药品id + 0 = 药品id_In And
          ((Nvl(b.药库分批, 0) = 1 And
          a.库房id Not In (Select 部门id From 部门性质说明 Where (工作性质 Like '%药房') Or (工作性质 Like '制剂室'))) Or Nvl(b.药房分批, 0) = 1) And
          Rownum = 1;
  Exception
    When Others Then
      v_Druginf := '';
  End;

  If v_Druginf Is Not Null Then
    Raise Err_Isbatch;
  End If;

  Select Sum(a.实际数量) As 剩余数量, Sum(a.成本金额) As 剩余成本金额, Sum(a.零售金额) As 剩余零售金额, Sum(To_Number(Nvl(a.用法, 0))) As 金额差, a.库房id,
         a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批, a.发药方式, a.单量,
         a.生产日期, a.批准文号, a.频次, a.计划id, a.外观
  Into v_剩余数量, v_剩余成本金额, v_剩余零售金额, v_剩余金额差, v_库房id, v_供药单位id, v_入出类别id, v_入出系数, v_批次, v_产地, v_批号, v_效期, v_成本价, v_扣率,
       v_零售价, v_药库分批, v_药房分批, v_发药方式, v_单量, v_生产日期, v_批准文号, v_加成率, n_计划id,v_外观
  From 药品收发记录 A, 药品规格 B
  Where a.No = No_In And a.药品id = b.药品id And a.单据 = 1 And a.药品id = 药品id_In And a.序号 = 序号_In
  Group By a.库房id, a.供药单位id, a.入出类别id, a.入出系数, Nvl(a.批次, 0), a.产地, a.批号, a.效期, a.成本价, a.扣率, a.零售价, b.药库分批, b.药房分批,
           a.发药方式, a.单量, a.生产日期, a.批准文号, a.频次, a.计划id, a.外观;

  --如果是退库单据，并且是分批药品时，提取原始入库单据的ID
  If Nvl(v_发药方式, 0) = 1 Then
    Begin
      Select ID
      Into v_入库id
      From 药品收发记录
      Where NO = No_In And 单据 = 1 And 药品id = 药品id_In And 序号 = 序号_In And (记录状态 = 1 Or Mod(记录状态, 3) = 0);
    Exception
      When Others Then
        v_入库id := 0;
    End;
  End If;

  --判断该部门是药库还是药房
  Begin
    Select Distinct 0
    Into v_药库
    From 部门性质说明
    Where ((工作性质 Like '%药房') Or (工作性质 Like '制剂室')) And 部门id = v_库房id;
  Exception
    When Others Then
      v_药库 := 1;
  End;

  --根据部门性质,判断分批特性
  If v_药库 = 0 Then
    v_分批属性 := v_药房分批;
  Else
    v_分批属性 := v_药库分批;
  End If;

  --V_分批:(原分批,现分批为批次;否则为零)原不分批,现分批,本过程不考虑
  v_分批 := 0;
  If v_分批属性 = 1 And v_批次 <> 0 Then
    v_分批 := v_批次;
  End If;

  --全部冲销或者财务审核时，冲销数量等于剩余数量；其他情况冲销数量等于传入的冲销数量
  If 全部冲销_In = 1 Or 财务审核_In = 1 Then
    v_冲销数量 := v_剩余数量;
  Else
    v_冲销数量 := 冲销数量_In;
  End If;

  --冲销数量不能大于剩余数量（主要防止并发）
  If Abs(v_剩余数量) < Abs(v_冲销数量) Then
    Raise Err_Isnonum;
  End If;

  v_成本金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余成本金额, Intdigit);
  v_零售金额 := Round(v_冲销数量 / v_剩余数量 * v_剩余零售金额, Intdigit);
  v_差价     := v_零售金额 - v_成本金额;

  --如果有金额差，则要冲销金额差
  v_冲销金额差 := 0;
  If v_剩余金额差 <> 0 Then
    If 全部冲销_In = 1 Or 财务审核_In = 1 Then
      v_冲销金额差 := v_剩余金额差;
    Else
      v_冲销金额差 := Round(v_冲销数量 / v_剩余数量 * v_剩余金额差, Intdigit);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_收发id From Dual;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额, 差价,
     摘要, 填制人, 填制日期, 配药人, 配药日期, 审核人, 审核日期, 发药方式, 单量, 生产日期, 批准文号, 用法, 频次, 费用id, 计划id, 外观)
  Values
    (v_收发id, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 1, No_In, 序号_In, v_库房id, v_供药单位id, v_入出类别id, 1, 药品id_In, v_批次, v_产地,
     v_批号, v_效期, -v_冲销数量, -v_冲销数量, v_成本价, -v_成本金额, v_扣率, v_零售价, -v_零售金额, -v_差价, 摘要_In, 填制人_In, 填制日期_In, v_核查人, v_核查日期,
     填制人_In, 填制日期_In, v_发药方式, v_单量, v_生产日期, v_批准文号, Decode(v_冲销金额差, 0, Null, -v_冲销金额差), v_加成率, 财务审核_In, n_计划id, v_外观);

  --冲销单据如果计划id不为空则需要处理计划单据的执行数量
  If n_计划id Is Not Null Then
    Update 药品计划内容 Set 执行数量 = Nvl(执行数量, 0) - v_冲销数量 Where 计划id = n_计划id And 药品id = 药品id_In;
  End If;
  --调用库存更新过程
  If 财务审核_In = 0 Then
    Zl_药品库存_Update(v_收发id, 0);
  Else
    --财务审核时，为了保证以前的价格不变则必须保证库存表数据即使为0也不能删掉
    Zl_药品库存_Update(v_收发id, 0, 0, 0, 1);
  End If;

  --对于冲销的单据也应该对应付余额表进行处理
  --只对填了发票号的记录进行处理
  v_发票金额 := Nvl(发票金额_In, 0);
  If Nvl(发票号_In, ' ') <> ' ' Or Nvl(发票金额_In, 0) <> 0 Then
    --对于财务审核的，要将剩余的发票金额全部冲销
    If 全部冲销_In = 1 Then
      Select Sum(b.发票金额)
      Into v_发票金额
      From (Select ID From 药品收发记录 Where 单据 = 1 And NO = No_In And 序号 = 序号_In) A, 应付记录 B
      Where a.Id = b.收发id And b.系统标识 = 1 And b.记录性质 <> -1;
    End If;
  
    Update 应付余额 Set 金额 = Nvl(金额, 0) - Nvl(v_发票金额, 0) Where 单位id = v_供药单位id And 性质 = 1;
  
    If Sql%NotFound Then
      Insert Into 应付余额 (单位id, 性质, 金额) Values (v_供药单位id, 1, -nvl(v_发票金额, 0));
    End If;
  
    Delete From 应付余额 Where 单位id = v_供药单位id And 金额 = 0;
  End If;

  --产生应付记录的冲销记录(先判断应付记录中是否已存在该记录对应的冲销记录,是则更新;否则新增)
  Select 应付记录_Id.Nextval Into v_应付id From Dual;
  Insert Into 应付记录
    (ID, 记录性质, 记录状态, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量, 采购价, 采购金额, 填制人, 填制日期,
     审核人, 审核日期, 摘要, 项目id, 序号, 随货单号, 库房id, 发票修改时间, 发票代码)
    Select v_应付id, 记录性质, Decode(原记录状态_In, 1, 2, 原记录状态_In + 2), 单位id, NO, 1, v_收发id, 入库单据号, -v_零售金额, 发票号, 发票日期, -v_发票金额,
           品名, 规格, 产地, 批号, 计量单位, -v_冲销数量, 采购价, -采购价 * v_冲销数量, 填制人_In, 填制日期_In, 填制人_In, 填制日期_In, 摘要, 项目id, 序号, 随货单号, 库房id,
           Sysdate, 发票代码
    From 应付记录
    Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
          记录性质 = 0;

  Update 应付记录
  Set 记录状态 = 3
  Where 收发id = (Select ID From 药品收发记录 Where NO = No_In And 单据 = 1 And 序号 = 序号_In And Mod(记录状态, 3) = 0) And 系统标识 = 1 And
        记录性质 = 0;

  --处理调价后冲销（财务审核时不需要处理）
  If 财务审核_In = 0 Then
    Zl_药品收发记录_调价修正(v_收发id);
  End If;

Exception
  When Err_Isstriked Then
    Raise_Application_Error(-20101, '[ZLSOFT]该单据已经被他人冲销！[ZLSOFT]');
  When Err_Isbatch Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品原来不分批，现在分批的药品[' || v_Druginf || ']，不能冲销！[ZLSOFT]');
  When Err_Isnonum Then
    Raise_Application_Error(-20102, '[ZLSOFT]该单据中第' || 序号_In || '行的药品冲销的数量大于了剩余数量，不能冲销！[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品外购_Strike;
/

--122143:冉俊明,2018-02-26,修正当日已部分停诊且当前在停诊时间范围内时号源在支付宝仍能够看到并挂号问题
--118848:冉俊明,2017-12-29,获取预约号源时，启用分时段序号控制的不返回不允许预约的序号时段
Create Or Replace Procedure Zl_Third_Getnolist
(
  Xml_In  In Xmltype,
  Xml_Out Out Xmltype
) Is
  --------------------------------------------------------------------------------------------------
  --功能:获取号源列表(简易模式)
  --入参:Xml_In:
  --<IN>
  --  <RQ>日期</RQ>
  --  <KSID>科室ID</KSID>
  --  <YSID>医生ID</YSID>
  --  <YSXM>医生姓名</YSXM>
  --  <HZDW>支付宝</HZDW>    //合作单位，传入了的时候，只取合作单位的号;为空时，只取非合作单位的号
  --  <SJJG>60</SJJG>     //时间间隔,不传则返回序号时段
  --</IN>

  --出参:Xml_Out
  --<OUTPUT>
  --  <GROUP>
  --    <RQ>日期</RQ>
  --    <HBLIST>
  --     <HB>
  --        <CZJLID>1</CZJLID>     //出诊记录ID
  --        <HM>235</HM>       //号码
  --        <YSID>549</YSID>      //医生ID
  --        <YS>张锐</YS>       //医生姓名
  --        <KSID>123</KSID>   //科室ID
  --        <KSMC>内科</KSMC>   //科室名称
  --        <ZC>主治医师</ZC> //职称
  --        <XMID>10086<XMID> //挂号项目的ID
  --        <XMMC>挂号费</XMMC> //挂号项目的名称
  --        <YGHS>0</YGHS>      //已挂号数
  --        <SYHS>99</SYHS>   //剩余号数
  --        <PRICE>15</PRICE>      //价格
  --        <HL>普通</HL>       //挂号类型
  --        <HCXH>1</HCXH>    //是否存在缓冲序号时间段，1-存在 0或者空-不存在
  --        <FSD>0</FSD>      //是否分时段
  --        <FWMC>白天</FWMC>     //号别时段
  --        <HBTIME>(08:00-17:59)</HBTIME> //可挂时间
  --     <SPANLIST>
  --            <SPAN>
  --                  <SJD></SJD>          //时间段,格式:hh24:mi-hh24:mi
  --                  <GHZS></GHZS>      //时段挂号总数
  --                  <SL></SL>      //剩余数量
  --            </SPAN>
  --            ……
  --          </SPANLIST>
  --      </HB>
  --      <HB>
  --      ……
  --      </HB>
  --    </HBLIST>
  --  </GROUP>
  --</OUTPUT>
  --
  --“序号时段”<SPANLIST>和“剩余号数”<SYHS>节点说明：
  --  1.出诊表排班模式：
  --    1.1启用分时段，同时启用序号控制
  --      1.1.1传入合作单位
  --          1）当日：
  --                  序号时段：按比例或按总量时，号源剩余的可挂号时段；按序号时，分配给该合作单位剩余的可预约时段
  --                  剩余号数：分配给该合作单位剩余的可预约数量
  --          2）当日以后：
  --                  序号时段：按比例或按总量时，号源剩余的可预约时段；按序号时，分配给该合作单位剩余的可预约时段
  --                  剩余号数：分配给该合作单位剩余的可预约数量
  --      1.1.2不传入合作单位
  --          1）当日：
  --                  序号时段：号源剩余的可挂号时段
  --                  剩余号数：号源剩余的可挂号数量
  --          2）当日以后：
  --                  序号时段：号源剩余的可预约时段
  --                  剩余号数：号源剩余的可预约数量
  --------------------------------------------------------------------------------------------------
  x_Templet Xmltype; --模板XML

  d_日期     临床出诊记录.出诊日期%Type;
  n_科室id   挂号安排.科室id%Type;
  n_医生id   挂号安排.医生id%Type;
  v_医生姓名 挂号安排.医生姓名%Type;
  v_合作单位 挂号合作单位.名称%Type;
  n_时间间隔 挂号安排.默认时段间隔%Type;

  v_挂号模式 Varchar2(500);
  n_挂号模式 Number(3);
  d_启用时间 Date;
  n_预约天数 挂号安排.预约天数%Type;
  n_补充天数 挂号安排.预约天数%Type;

  v_剩余数量 挂号安排时段.限制数量%Type;
  n_禁用     Number(3);
  v_Temp     Varchar2(32767); --临时XML
  c_Xmlmain  Clob; --临时XML 
  v_Xmlmain  Clob; --临时XML 

  d_时段开始 挂号安排时段.开始时间%Type;
  d_时段结束 挂号安排时段.结束时间%Type;
  n_时段总数 挂号安排时段.限制数量%Type;
  n_时段剩余 挂号安排时段.限制数量%Type;
  n_时段已挂 挂号安排时段.限制数量%Type;

  v_星期         挂号安排限制.限制项目%Type;
  v_时间段       Varchar2(100);
  n_分时段       Number(3);
  n_单个剩余     Number(5);
  n_已挂数       Number(5);
  n_合约已挂数   Number(5);
  n_合计金额     收费价目.现价%Type;
  n_合约总数量   Number(5);
  n_合约剩余数量 Number(5);
  n_最大可用数量 Number(5);
  n_合约模式     Number(3); --合约模式:1-合约单位限数量模式 0-合约单位指定序号模式
  n_非合约       Number(3);
  n_是否预留     Number(3);

  d_开始时间 临床出诊记录.开始时间%Type;
  d_终止时间 临床出诊记录.终止时间%Type;
  d_加号时间 临床出诊记录.开始时间%Type;

  n_缓冲序号 Number(3);
  n_时段数量 Number(5);
  n_预留数量 Number(5);
  n_特殊预约 Number(3);
  v_Timetemp Varchar2(100);
  n_Exists   Number(5);

  v_Err_Msg Varchar2(200);
  Err_Item Exception;

  --获取序号时段XML
  Function Gettimexml
  (
    时段开始_In 临床出诊序号控制.开始时间%Type,
    时段结束_In 临床出诊序号控制.终止时间%Type,
    时段总数_In 临床出诊序号控制.数量%Type,
    时段剩余_In 临床出诊序号控制.数量%Type
  ) Return Varchar2 Is
    v_Temp Varchar2(4000);
  Begin
    v_Temp := '';
    v_Temp := v_Temp || '<SPAN>';
    v_Temp := v_Temp || '<SJD>' || To_Char(时段开始_In, 'hh24:mi:ss') || '-' || To_Char(时段结束_In, 'hh24:mi:ss') || '</SJD>';
    v_Temp := v_Temp || '<GHZS>' || 时段总数_In || '</GHZS>';
    v_Temp := v_Temp || '<SL>' || 时段剩余_In || '</SL>';
    v_Temp := v_Temp || '</SPAN>';
    Return v_Temp;
  End;
Begin
  x_Templet := Xmltype('<OUTPUT></OUTPUT>');

  Select To_Date(Extractvalue(Value(A), 'IN/RQ'), 'YYYY-MM-DD hh24:mi:ss'), Extractvalue(Value(A), 'IN/KSID'),
         Extractvalue(Value(A), 'IN/YSID'), Extractvalue(Value(A), 'IN/YSXM'), Extractvalue(Value(A), 'IN/HZDW'),
         Extractvalue(Value(A), 'IN/SJJG')
  Into d_日期, n_科室id, n_医生id, v_医生姓名, v_合作单位, n_时间间隔
  From Table(Xmlsequence(Extract(Xml_In, 'IN'))) A;

  --日期节点为空的情况
  d_日期 := Nvl(d_日期, Trunc(Sysdate));

  v_挂号模式 := zl_GetSysParameter('挂号排班模式') || '|||';
  n_挂号模式 := To_Number(Substr(v_挂号模式, 1, Instr(v_挂号模式, '|') - 1));
  If n_挂号模式 = 1 Then
    v_挂号模式 := Substr(v_挂号模式, Instr(v_挂号模式, '|') + 1);
    v_Temp     := Substr(v_挂号模式, 1, Instr(v_挂号模式, '|') - 1);
    d_启用时间 := To_Date(Nvl(v_Temp, '1900-01-01'), 'yyyy-mm-dd hh24:mi:ss');
    If d_日期 < d_启用时间 Then
      n_挂号模式 := 0;
    End If;
  End If;

  n_预约天数 := Nvl(zl_GetSysParameter(66), 7);
  c_Xmlmain  := '';

  --===========================================================================================
  --计划排班模式 
  --===========================================================================================
  If n_挂号模式 = 0 Then
    Select Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7', '周六', Null)
    Into v_星期
    From Dual;
    n_合约剩余数量 := 0;
  
    For r_No In (Select a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                        a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0) As 已挂数, Nvl(Hz.已约数, 0) As 已约数, Nvl(Hz.其中已接收, 0) As 已接收,
                        Sum(b.现价) As 价格
                 From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Nvl(Ap.医生id, 0) As 医生id, Ry.专业技术职务 As 职称, Ap.号码,
                               Ap.安排id, Ap.计划id, Ap.排班, Ap.项目id, Fy.名称 As 项目名称, Ap.序号控制, Ap.限号数, Ap.限约数, Ap.预约天数
                        From (Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Ap.医生姓名, Ap.医生id, Ap.号码, Ap.Id As 安排id, 0 As 计划id,
                                      Ap.项目id, Nvl(Ap.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Ap.周日, '2', Ap.周一, '3', Ap.周二, '4', Ap.周三, '5', Ap.周四,
                                              '6', Ap.周五, '7', Ap.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排 Ap, 部门表 Bm, 挂号安排限制 Xz
                               Where Ap.科室id = Bm.Id(+) And Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Ap.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Ap.医生姓名) = Nvl(v_医生姓名, '-') And Ap.停用日期 Is Null And
                                     d_日期 Between Nvl(Ap.开始时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Ap.终止时间, To_Date('3000 - 01 - 01', 'YYYY-MM-DD')) And Xz.安排id(+) = Ap.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And Not Exists
                                (Select Rownum
                                      From 挂号安排计划 Jh
                                      Where Jh.安排id = Ap.Id And Jh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')))
                               Union All
                               Select Ap.科室id, Ap.号类, Bm.名称 As 科室名称, Jh.医生姓名, Jh.医生id, Ap.号码, Ap.Id As 安排id, Jh.Id As 计划id,
                                      Jh.项目id, Nvl(Jh.序号控制, 0) As 序号控制,
                                      Decode(To_Char(d_日期, 'D'), '1', Jh.周日, '2', Jh.周一, '3', Jh.周二, '4', Jh.周三, '5', Jh.周四,
                                              '6', Jh.周五, '7', Jh.周六, Null) As 排班, Xz.限约数, Xz.限号数,
                                      Nvl(Ap.预约天数, n_预约天数) As 预约天数
                               From 挂号安排计划 Jh, 挂号安排 Ap, 部门表 Bm, 挂号计划限制 Xz
                               Where Jh.安排id = Ap.Id And Ap.科室id = Bm.Id(+) And Ap.停用日期 Is Null And
                                     Decode(Nvl(n_科室id, 0), 0, 0, Ap.科室id) = Nvl(n_科室id, 0) And
                                     Decode(Nvl(n_医生id, 0), 0, 0, Jh.医生id) = Nvl(n_医生id, 0) And
                                     Decode(Nvl(v_医生姓名, '-'), '-', '-', Jh.医生姓名) = Nvl(v_医生姓名, '-') And
                                     d_日期 Between Nvl(Jh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                     Nvl(Jh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Xz.计划id(+) = Jh.Id And
                                     Xz.限制项目(+) = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                         '周四', '6', '周五', '7', '周六', Null) And Not Exists
                                (Select Rownum
                                      From 挂号安排停用状态 Ty
                                      Where Ty.安排id = Ap.Id And d_日期 Between Ty.开始停止时间 And Ty.结束停止时间) And
                                     (Jh.生效时间, Jh.安排id) =
                                     (Select Max(Sxjh.生效时间) As 生效时间, 安排id
                                      From 挂号安排计划 Sxjh
                                      Where Sxjh.审核时间 Is Not Null And
                                            d_日期 Between Nvl(Sxjh.生效时间, To_Date('1900-01-01', 'YYYY-MM-DD')) And
                                            Nvl(Sxjh.失效时间, To_Date('3000-01-01', 'YYYY-MM-DD')) And Sxjh.安排id = Jh.安排id
                                      Group By Sxjh.安排id)) Ap, 部门表 Bm, 人员表 Ry, 收费项目目录 Fy
                        Where Ap.科室id = Bm.Id(+) And Ap.医生id = Ry.Id(+) And Ap.项目id = Fy.Id And 排班 Is Not Null) A,
                      病人挂号汇总 Hz, 收费价目 B
                 Where a.号码 = Hz.号码(+) And Hz.日期(+) = Trunc(d_日期) And a.项目id = b.收费细目id And
                       Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-Mm-DD')) > d_日期 And b.执行日期 <= d_日期
                 Group By a.科室id, a.号类, a.科室名称, a.医生姓名, a.医生id, a.职称, a.号码, a.安排id, a.计划id, a.排班, a.项目id, a.项目名称, a.序号控制,
                          a.限号数, a.限约数, a.预约天数, Nvl(Hz.已挂数, 0), Nvl(Hz.已约数, 0), Nvl(Hz.其中已接收, 0)) Loop
      Zl_挂号序号状态_Delete(1, r_No.号码);
      If Sysdate + Nvl(r_No.预约天数, n_预约天数) >= d_日期 Then
        If r_No.计划id <> 0 Then
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排计划 Jh, 挂号计划时段 Sd
          Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        Else
          Select Sign(Count(Rownum))
          Into n_分时段
          From 挂号安排 Ap, 挂号安排时段 Sd
          Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五', '7',
                               '周六', Null) And Rownum < 2;
        End If;
        --分时段不序号控制当天号为普通号
        If Trunc(Sysdate) = Trunc(d_日期) And n_分时段 = 1 And r_No.序号控制 = 0 Then
          n_分时段 := 0;
        End If;
        If n_分时段 = 0 Then
          v_Temp := '';
          If v_合作单位 Is Not Null And r_No.序号控制 = 1 Then
            If r_No.计划id <> 0 Then
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            Else
              Select Nvl(Sum(数量), 0)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
              Select Count(1)
              Into n_合约模式
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 序号 = 0;
            End If;
            If n_合约模式 = 0 Then
              If r_No.计划id <> 0 Then
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位计划控制
                       Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              Else
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录 A
                Where 号别 = r_No.号码 And 记录状态 = 1 And 发生时间 Between Trunc(d_日期) And Trunc(d_日期 + 1) - 1 / 60 / 60 / 24 And
                      Exists
                 (Select 1
                       From 合作单位安排控制
                       Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And
                             限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                           '周五', '7', '周六', Null) And 序号 = a.号序 And 数量 <> 0);
              End If;
            Else
              Select Count(1)
              Into n_合约已挂数
              From 病人挂号记录
              Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                    Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            End If;
            If n_合约总数量 = 0 Then
              n_合约剩余数量 := 0;
            Else
              n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              If n_合约剩余数量 > (Nvl(r_No.限号数, 0) - r_No.已挂数) Then
                n_合约剩余数量 := Nvl(r_No.限号数, 0) - r_No.已挂数;
              End If;
            End If;
          End If;
        Else
          v_Temp := '<SPANLIST>';
          If r_No.计划id <> 0 Then
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号计划时段
            Where 计划id = r_No.计划id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Jh.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排计划 Jh, 挂号计划时段 Sd
                       Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号 And
                      Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) <> 1;
              End If;
            
              d_时段开始 := Null;
              d_时段结束 := Null;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Zt.日期(+) = Jh.开始时间 And Zt.号码(+) = Jh.号码 And Zt.序号(+) = Jh.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + 1;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Jh.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Jh.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.计划id, Sd.序号, Sd.星期, Jh.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排计划 Jh, 挂号计划时段 Sd
                                    Where Jh.Id = Sd.计划id And Jh.Id = r_No.计划id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Jh.安排id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Jh, 挂号序号状态 Zt
                             Where Jh.号码 = Zt.号码(+) And Jh.开始时间 = Zt.日期(+)
                             Group By Jh.号码, Jh.序号, Jh.星期, Jh.开始时间, Jh.结束时间, Jh.限制数量, Jh.是否预约
                             Order By Jh.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位计划控制
                  Where 限制项目 = r_Time.星期 And 计划id = r_No.计划id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位计划控制
                    Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          Else
            Select To_Date(To_Char(d_日期, 'yyyy-mm-dd') || To_Char(Max(结束时间), 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss')
            Into d_加号时间
            From 挂号安排时段
            Where 安排id = r_No.安排id And 星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                   '周四', '6', '周五', '7', '周六', Null);
            If r_No.序号控制 = 1 Then
              If Trunc(d_日期) = Trunc(Sysdate) Then
                n_特殊预约 := 0;
              Else
                Select Nvl(Max(Ap.是否预约), 0)
                Into n_特殊预约
                From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                              To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                       'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                       From 挂号安排 Ap, 挂号安排时段 Sd
                       Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And
                             Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6',
                                            '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号 And
                      Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) <> 1;
              End If;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约, 0 As 已约数,
                                    Decode(Nvl(Zt.序号, 0), 0, 1, 0) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Zt.日期(+) = Ap.开始时间 And Zt.号码(+) = Ap.号码 And Zt.序号(+) = Ap.序号
                             Order By 序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Begin
                    Select 1
                    Into n_合约模式
                    From 合作单位安排控制
                    Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                  Exception
                    When Others Then
                      n_合约模式 := 0;
                  End;
                Else
                  n_合约模式 := 0;
                End If;
                If r_Time.剩余数 = 0 Then
                  n_单个剩余 := 0;
                Else
                  n_单个剩余 := r_Time.限制数量;
                End If;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                      End If;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_特殊预约 = 1 And r_Time.是否预约 = 0 Then
                      Null;
                    Else
                      Select Nvl(Max(1), 0)
                      Into n_是否预留
                      From 挂号序号状态
                      Where 状态 In (3, 4) And 号码 = r_No.号码 And 序号 = r_Time.序号 And Trunc(日期) = Trunc(d_日期);
                      If n_是否预留 = 0 Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                    To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                    '</SPAN>';
                        Else
                          n_时段剩余 := n_时段剩余 + n_单个剩余;
                        End If;
                        n_合约剩余数量 := n_合约剩余数量 + n_单个剩余;
                      End If;
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            Else
              n_最大可用数量 := Nvl(r_No.限约数, Nvl(r_No.限号数, 0)) - Nvl(r_No.已约数, 0);
              n_时段总数     := 0;
              n_时段剩余     := 0;
              d_时段开始     := Null;
              d_时段结束     := Null;
              For r_Time In (Select Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约,
                                    Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 已约数,
                                    Ap.限制数量 - Sum(Decode(Nvl(Zt.序号, 0), 0, 0, 1)) As 剩余数,
                                    Decode(Sign(Sysdate - Ap.开始时间), -1, 0, 1) As 失效时段
                             From (Select Sd.安排id, Sd.序号, Sd.星期, Ap.号码,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.开始时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 开始时间,
                                           To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' || To_Char(Sd.结束时间, 'hh24:mi:ss'),
                                                    'yyyy-mm-dd hh24:mi:ss') As 结束时间, Sd.限制数量, Sd.是否预约
                                    From 挂号安排 Ap, 挂号安排时段 Sd
                                    Where Ap.Id = Sd.安排id And Ap.Id = r_No.安排id And Not Exists
                                     (Select 1
                                           From 挂号安排停用状态
                                           Where 安排id = Ap.Id And
                                                 To_Date(To_Char(d_日期, 'yyyy-mm-dd') || ' ' ||
                                                         To_Char(Sd.开始时间, 'hh24:mi:ss'), 'yyyy-mm-dd hh24:mi:ss') Between
                                                 开始停止时间 And 结束停止时间) And
                                          Sd.星期 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三',
                                                         '5', '周四', '6', '周五', '7', '周六', Null)) Ap, 挂号序号状态 Zt
                             Where Ap.号码 = Zt.号码(+) And Ap.开始时间 = Zt.日期(+)
                             Group By Ap.号码, Ap.序号, Ap.星期, Ap.开始时间, Ap.结束时间, Ap.限制数量, Ap.是否预约
                             Order By Ap.序号) Loop
                If Nvl(n_时间间隔, 0) <> 0 Then
                  If d_时段开始 Is Null Then
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    n_时段总数 := n_时段总数 + r_Time.限制数量;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                                    To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' ||
                                    '<SL>' || n_时段剩余 || '</SL>' || '</SPAN>';
                      n_时段总数 := r_Time.限制数量;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + r_Time.限制数量;
                    End If;
                  End If;
                End If;
                If v_合作单位 Is Not Null Then
                  Select Nvl(Max(1), 0)
                  Into n_合约模式
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
                Else
                  n_合约模式 := 0;
                End If;
                n_单个剩余 := r_Time.剩余数;
                If v_合作单位 Is Null Or n_合约模式 = 1 Then
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And Rownum < 2;
                  If n_Exists = 0 And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_最大可用数量;
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_时段数量 := Nvl(n_时段数量, 0) + n_单个剩余;
                    End If;
                  End If;
                Else
                  Select Nvl(Max(1), 0)
                  Into n_Exists
                  From 合作单位安排控制
                  Where 限制项目 = r_Time.星期 And 安排id = r_No.安排id And 序号 = r_Time.序号 And 合作单位 = v_合作单位 And Rownum < 2;
                  Begin
                    Select 0
                    Into n_非合约
                    From 合作单位安排控制
                    Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
                  Exception
                    When Others Then
                      n_非合约 := 1;
                  End;
                  If (n_Exists = 1 Or n_非合约 = 1) And r_Time.失效时段 <> 1 Then
                    If n_最大可用数量 < n_单个剩余 Then
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_最大可用数量 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_最大可用数量;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_最大可用数量, 0);
                    Else
                      If Nvl(n_时间间隔, 0) = 0 Then
                        v_Temp := v_Temp || '<SPAN>' || '<SJD>' || To_Char(r_Time.开始时间, 'hh24:mi:ss') || '-' ||
                                  To_Char(r_Time.结束时间, 'hh24:mi:ss') || '</SJD>' || '<SL>' || n_单个剩余 || '</SL>' ||
                                  '</SPAN>';
                      Else
                        n_时段剩余 := n_时段剩余 + n_单个剩余;
                      End If;
                      n_合约剩余数量 := n_合约剩余数量 + Nvl(n_单个剩余, 0);
                    End If;
                  End If;
                End If;
              End Loop;
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_时段开始, 'hh24:mi:ss') || '-' ||
                              To_Char(d_时段结束, 'hh24:mi:ss') || '</SJD>' || '<GHZS>' || n_时段总数 || '</GHZS>' || '<SL>' ||
                              n_时段剩余 || '</SL>' || '</SPAN>';
                n_时段总数 := 0;
                n_时段剩余 := 0;
                d_时段开始 := Null;
                d_时段结束 := Null;
              End If;
            End If;
          End If;
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Begin
              Select 0
              Into n_非合约
              From 合作单位计划控制
              Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          Else
            Begin
              Select 0
              Into n_非合约
              From 合作单位安排控制
              Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And Rownum < 2;
            Exception
              When Others Then
                n_非合约 := 1;
            End;
          End If;
        End If;
        If v_合作单位 Is Null Or n_非合约 = 1 Then
          If r_No.限号数 = 0 Then
            v_剩余数量 := '';
          Else
            If Nvl(r_No.计划id, 0) <> 0 Then
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位计划控制
              Where 计划id = r_No.计划id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            Else
              Select Sum(数量)
              Into n_合约总数量
              From 合作单位安排控制
              Where 安排id = r_No.安排id And
                    限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null);
            End If;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 Is Not Null And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            Select Count(1)
            Into n_预留数量
            From 挂号序号状态
            Where 状态 = 3 And 号码 = r_No.号码 And Trunc(日期) = Trunc(d_日期);
            If Trunc(d_日期) = Trunc(Sysdate) Then
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
              Else
                v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
              End If;
              n_已挂数 := r_No.已挂数;
              If Nvl(n_时段数量, 0) < v_剩余数量 And n_分时段 <> 0 Then
                n_缓冲序号 := 1;
                v_Temp     := v_Temp || '<SPAN>' || '<SJD>' || To_Char(d_加号时间, 'hh24:mi:ss') || '-' || '</SJD>' ||
                              '<SL>' || To_Number(v_剩余数量 - Nvl(n_时段数量, 0) - Nvl(n_合约剩余数量, 0)) || '</SL>' || '</SPAN>';
              Else
                n_缓冲序号 := 0;
              End If;
            Else
              If Nvl(n_合约总数量, 0) = 0 Then
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_预留数量;
                End If;
              Else
                v_剩余数量 := r_No.限约数 - r_No.已约数 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                If v_剩余数量 Is Null Then
                  v_剩余数量 := r_No.限号数 - r_No.已挂数 - r_No.已约数 + r_No.已接收 - n_合约总数量 + n_合约已挂数 - n_预留数量;
                End If;
              End If;
              n_已挂数 := r_No.已挂数;
            End If;
          End If;
        Else
          If Nvl(r_No.计划id, 0) <> 0 Then
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位计划控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 计划id = r_No.计划id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          Else
            If v_合作单位 Is Not Null Then
              Select Nvl(Max(1), 0)
              Into n_合约模式
              From 合作单位安排控制
              Where 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5', '周四', '6', '周五',
                                  '7', '周六', Null) And 安排id = r_No.安排id And 序号 = 0 And 合作单位 = v_合作单位;
            Else
              n_合约模式 := 0;
            End If;
            Select Sum(数量)
            Into n_合约总数量
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 限制项目 = Decode(To_Char(d_日期, 'D'), '1', '周日', '2', '周一', '3', '周二', '4', '周三', '5',
                                                     '周四', '6', '周五', '7', '周六', Null) And 合作单位 = v_合作单位;
          End If;
          If n_合约模式 = 0 Then
            v_剩余数量   := n_合约剩余数量;
            n_已挂数     := r_No.已挂数;
            n_合约已挂数 := Nvl(n_合约总数量, 0) - n_合约剩余数量;
          Else
            n_已挂数 := r_No.已挂数;
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            If Nvl(n_合约总数量, 0) = 0 Then
              v_剩余数量 := '0';
            Else
              v_剩余数量 := n_合约总数量 - n_合约已挂数;
            End If;
          End If;
        End If;
        Select To_Char(开始时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_Timetemp || '-';
        Select To_Char(终止时间, 'hh24:mi') Into v_Timetemp From 时间段 Where 时间段 = r_No.排班;
        v_时间段 := v_时间段 || v_Timetemp;
        If v_Temp Is Not Null Then
          v_Temp := v_Temp || '</SPANLIST>';
        End If;
        If v_合作单位 Is Not Null Then
          If Nvl(r_No.计划id, 0) <> 0 Then
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位计划控制
            Where 计划id = r_No.计划id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          Else
            Select Nvl(Max(1), 0)
            Into n_禁用
            From 合作单位安排控制
            Where 安排id = r_No.安排id And 合作单位 = v_合作单位 And 数量 = 0 And Rownum < 2;
          End If;
        End If;
        --限约数=0的预约禁止
        If Trunc(d_日期) <> Trunc(Sysdate) Then
          If r_No.限约数 = 0 Then
            n_禁用 := 1;
          End If;
        End If;
        If Nvl(n_禁用, 0) = 0 Then
          --从项金额计算
          n_合计金额 := r_No.价格;
          For r_Subfee In (Select 现价, 从项数次
                           From 收费从属项目 A, 收费价目 B
                           Where a.主项id = r_No.项目id And a.从项id = b.收费细目id And Sysdate Between b.执行日期 And
                                 Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
            n_合计金额 := n_合计金额 + r_Subfee.现价 * r_Subfee.从项数次;
          End Loop;
          If Trunc(Sysdate) = Trunc(d_日期) Then
            Select Nvl(Max(1), 0)
            Into n_Exists
            From (Select 时间段
                   From 时间段
                   Where ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') < '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS')) Or
                         ('3000-01-10 ' || To_Char(Sysdate, 'HH24:MI:SS') <
                         Decode(Sign(开始时间 - 终止时间), 1, '3000-01-11 ' || To_Char(终止时间, 'HH24:MI:SS'),
                                 '3000-01-10 ' || To_Char(终止时间, 'HH24:MI:SS'))))
            Where 时间段 = r_No.排班;
          Else
            n_Exists := 1;
          End If;
          If n_Exists = 1 Then
            If v_剩余数量 > 0 Then
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HCXH>' || n_缓冲序号 || '</HCXH>' || '<HL>' || r_No.号类 ||
                           '</HL>' || '<FSD>' || n_分时段 || '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' ||
                           r_No.排班 || '</FWMC>' || v_Temp || '</HB>';
            Else
              c_Xmlmain := '<HB>' || '<HM>' || r_No.号码 || '</HM>' || '<YSID>' || r_No.医生id || '</YSID>' || '<YS>' ||
                           r_No.医生姓名 || '</YS>' || '<KSID>' || r_No.科室id || '</KSID>' || '<KSMC>' || r_No.科室名称 ||
                           '</KSMC>' || '<ZC>' || r_No.职称 || '</ZC>' || '<XMID>' || r_No.项目id || '</XMID>' || '<XMMC>' ||
                           r_No.项目名称 || '</XMMC>' || '<YGHS>' || n_已挂数 || '</YGHS>' || '<SYHS>' || v_剩余数量 || '</SYHS>' ||
                           '<PRICE>' || n_合计金额 || '</PRICE>' || '<HL>' || r_No.号类 || '</HL>' || '<FSD>' || n_分时段 ||
                           '</FSD>' || '<HBTIME>' || v_时间段 || '</HBTIME>' || '<FWMC>' || r_No.排班 || '</FWMC>' ||
                           '</HB>';
            End If;
            v_Xmlmain := v_Xmlmain || c_Xmlmain;
          End If;
        End If;
      End If;
      n_合约剩余数量 := 0;
      n_合约总数量   := 0;
      n_时段数量     := 0;
      n_禁用         := 0;
      n_非合约       := 0;
    End Loop;
  
    v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain ||
                 '</HBLIST>' || '</GROUP>';
    Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
    Xml_Out := x_Templet;
    Return;
  End If;

  --===========================================================================================
  --出诊表排班模式 
  --===========================================================================================
  n_合约剩余数量 := 0;
  n_补充天数     := Zl_Fun_Getappointmentdays;
  --注意出诊记录停用了，但可能启用了部分时段
  --临床出诊序号控制 中，开始时间与终止时间相等的是加号的序号
  --记录性质：1-正常出诊记录,2-替诊出诊记录
  For r_No In (Select a.记录性质, a.记录id, a.号源id, b.号类, b.号码, a.科室id, c.名称 As 科室名称, a.项目id, e.名称 As 项目名称, a.医生id, a.医生姓名,
                      d.专业技术职务 As 职称, a.排班, a.开始时间, a.终止时间, a.序号控制, a.分时段, a.预约控制, a.限号数, a.限约数, a.已挂数, a.已约数, a.已接收,
                      a.替诊开始时间, a.替诊终止时间, a.停诊开始时间, a.停诊终止时间, Nvl(b.预约天数, n_预约天数) + n_补充天数 As 预约天数
               From (Select 1 As 记录性质, a.Id As 记录id, a.号源id, a.科室id, a.项目id, a.医生id, a.医生姓名, a.上班时段 As 排班, a.开始时间, a.终止时间,
                             Nvl(a.是否序号控制, 0) As 序号控制, Nvl(a.是否分时段, 0) As 分时段, a.预约控制, a.限号数, Nvl(a.限约数, a.限号数) As 限约数,
                             Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收, a.替诊开始时间, a.替诊终止时间,
                             a.停诊开始时间, a.停诊终止时间
                      From 临床出诊记录 A
                      Where Nvl(a.是否发布, 0) = 1 And Nvl(a.是否锁定, 0) = 0 And
                            (a.开始时间 < Nvl(a.替诊开始时间, a.终止时间) Or a.终止时间 > Nvl(a.替诊终止时间, a.开始时间)) And a.开始时间 > Trunc(d_启用时间) And
                            a.终止时间 > Sysdate And
                            (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                             a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                             (Select 1
                              From 临床出诊序号控制
                              Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 1 And
                                    开始时间 <> 终止时间 And 开始时间 >= Sysdate)) And
                            Decode(Nvl(n_医生id, 0), 0, 0, a.医生id) = Nvl(n_医生id, 0) And
                            Decode(Nvl(v_医生姓名, '-'), '-', '-', a.医生姓名) = Nvl(v_医生姓名, '-') And
                            Decode(Nvl(n_科室id, 0), 0, 0, a.科室id) = Nvl(n_科室id, 0) And a.出诊日期 = Trunc(d_日期)
                      Union All
                      Select 2 As 记录性质, a.Id As 记录id, a.号源id, a.科室id, a.项目id, a.替诊医生id As 医生id, a.替诊医生姓名 As 医生姓名,
                             a.上班时段 As 排班, a.开始时间, a.终止时间, Nvl(a.是否序号控制, 0) As 序号控制, Nvl(a.是否分时段, 0) As 分时段, a.预约控制, a.限号数,
                             Nvl(a.限约数, a.限号数) As 限约数, Nvl(a.已挂数, 0) As 已挂数, Nvl(a.已约数, 0) As 已约数, Nvl(a.其中已接收, 0) As 已接收,
                             a.替诊开始时间, a.替诊终止时间, a.停诊开始时间, a.停诊终止时间
                      From 临床出诊记录 A
                      Where Nvl(a.是否发布, 0) = 1 And Nvl(a.是否锁定, 0) = 0 And a.开始时间 > Trunc(d_启用时间) And a.终止时间 > Sysdate And
                            (a.开始时间 < Nvl(a.停诊开始时间, a.终止时间) And Nvl(a.停诊开始时间, a.终止时间) > Sysdate Or
                             a.终止时间 > Nvl(a.停诊终止时间, a.开始时间) And a.终止时间 > Sysdate Or Exists
                             (Select 1
                              From 临床出诊序号控制
                              Where 记录id = a.Id And Nvl(是否停诊, 0) = 0 And Nvl(a.是否序号控制, 0) = 1 And Nvl(a.是否分时段, 0) = 1 And
                                    开始时间 <> 终止时间 And 开始时间 >= Sysdate)) And
                            Decode(Nvl(n_医生id, 0), 0, 0, a.替诊医生id) = Nvl(n_医生id, 0) And
                            Decode(Nvl(v_医生姓名, '-'), '-', '-', a.替诊医生姓名) = Nvl(v_医生姓名, '-') And
                            Decode(Nvl(n_科室id, 0), 0, 0, a.科室id) = Nvl(n_科室id, 0) And a.替诊医生姓名 Is Not Null And
                            a.出诊日期 = Trunc(d_日期)) A, 临床出诊号源 B, 部门表 C, 人员表 D, 收费项目目录 E
               Where a.号源id = b.Id And a.科室id = c.Id And a.项目id = e.Id And a.医生id = d.Id(+)) Loop
  
    Zl_挂号序号状态_出诊_Delete(r_No.记录id);
    v_Temp := '';
    n_禁用 := 0;
    If Sysdate + Nvl(r_No.预约天数, n_预约天数) + n_补充天数 >= d_日期 Then
      If Trunc(d_日期) = Trunc(Sysdate) Then
        --当日
        If v_合作单位 Is Null Then
          --未传入合作单位
          n_已挂数   := r_No.已挂数;
          v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
          If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
            v_Temp     := '<SPANLIST>';
            n_Exists   := 0;
            n_时段总数 := 0;
            n_时段剩余 := 0;
            d_时段开始 := Null;
            d_时段结束 := Null;
            Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
            For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                           From 临床出诊序号控制
                           Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                 Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                 r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                 Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              If r_Time.开始时间 > Sysdate Then
                If Nvl(n_时间间隔, 0) = 0 Then
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    n_时段剩余 := 1;
                    n_Exists   := n_Exists + 1;
                  Else
                    n_时段剩余 := 0;
                  End If;
                  v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                Else
                  If d_时段开始 Is Null Then
                    n_时段总数 := 1;
                    n_时段剩余 := 0;
                    d_时段开始 := r_Time.开始时间;
                    d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                    If d_加号时间 < d_时段结束 Then
                      d_时段结束 := d_加号时间;
                    End If;
                  Else
                    If r_Time.开始时间 >= d_时段结束 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      n_时段总数 := n_时段总数 + 1;
                    End If;
                  End If;
                
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    n_时段剩余 := n_时段剩余 + 1;
                    n_Exists   := n_Exists + 1;
                  End If;
                End If;
              End If;
            End Loop;
          
            If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
            End If;
          
            If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
              v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
            End If;
            v_Temp := v_Temp || '</SPANLIST>';
          End If;
        Else
          --传入合作单位
          n_已挂数 := r_No.已挂数;
          Begin
            Select 控制方式
            Into n_合约模式
            From 临床出诊挂号控制记录
            Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
          Exception
            When Others Then
              n_合约模式 := 4;
          End;
        
          If n_合约模式 = 0 Then
            n_禁用 := 1;
          Elsif n_合约模式 = 1 Or n_合约模式 = 2 Then
            Select 数量
            Into n_合约总数量
            From 临床出诊挂号控制记录
            Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位;
            If n_合约模式 = 1 Then
              n_合约总数量 := Floor(r_No.限约数 * n_合约总数量 / 100);
            End If;
          
            Select Count(1)
            Into n_合约已挂数
            From 病人挂号记录
            Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                  Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
            n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
          
            If r_No.限号数 - Nvl(r_No.已挂数, 0) < n_合约剩余数量 Then
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0);
            Else
              v_剩余数量 := n_合约剩余数量;
            End If;
          
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                   r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := 1;
                      n_Exists   := n_Exists + 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
            
              If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
                v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Elsif n_合约模式 = 3 Then
            If r_No.序号控制 = 0 Then
              n_已挂数   := r_No.已挂数;
              v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            Else
              v_Temp     := '<SPANLIST>';
              n_已挂数   := 0;
              v_剩余数量 := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              For r_合作 In (Select 序号
                           From 临床出诊挂号控制记录
                           Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
              
                Begin
                  Select 1, 开始时间, 终止时间
                  Into n_Exists, d_开始时间, d_终止时间
                  From 临床出诊序号控制
                  Where 记录id = r_No.记录id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And
                        (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                        r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                        Nvl(是否停诊, 0) = 0;
                Exception
                  When Others Then
                    n_Exists := 0;
                End;
              
                If n_Exists = 1 Then
                  v_剩余数量 := v_剩余数量 + 1;
                Else
                  n_已挂数 := n_已挂数 + 1;
                End If;
              
                If d_开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If n_Exists = 1 Then
                      n_时段剩余 := 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(d_开始时间, d_终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := d_开始时间;
                      d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                    Else
                      If d_开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := d_开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If n_Exists = 1 Then
                      n_时段剩余 := n_时段剩余 + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Elsif n_合约模式 = 4 Then
            n_已挂数   := r_No.已挂数;
            v_剩余数量 := r_No.限号数 - Nvl(r_No.已挂数, 0) - (Nvl(r_No.已约数, 0) - Nvl(r_No.已接收, 0));
            If r_No.分时段 = 1 And r_No.序号控制 = 1 Then
              v_Temp     := '<SPANLIST>';
              n_Exists   := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                             From 临床出诊序号控制
                             Where 记录id = r_No.记录id And (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                   r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                   Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
              
                If r_Time.开始时间 > Sysdate Then
                  If Nvl(n_时间间隔, 0) = 0 Then
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := 1;
                      n_Exists   := n_Exists + 1;
                    Else
                      n_时段剩余 := 0;
                    End If;
                    v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                  Else
                    If d_时段开始 Is Null Then
                      n_时段总数 := 1;
                      n_时段剩余 := 0;
                      d_时段开始 := r_Time.开始时间;
                      d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                      If d_加号时间 < d_时段结束 Then
                        d_时段结束 := d_加号时间;
                      End If;
                    Else
                      If r_Time.开始时间 >= d_时段结束 Then
                        v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                      
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        n_时段总数 := n_时段总数 + 1;
                      End If;
                    End If;
                  
                    If Nvl(r_Time.挂号状态, 0) = 0 Then
                      n_时段剩余 := n_时段剩余 + 1;
                      n_Exists   := n_Exists + 1;
                    End If;
                  End If;
                End If;
              End Loop;
            
              If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
              End If;
            
              If r_No.记录性质 = 1 And n_Exists < To_Number(v_剩余数量) Then
                v_Temp := v_Temp || Gettimexml(d_加号时间, '', v_剩余数量, To_Number(v_剩余数量) - n_Exists);
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          End If;
        End If;
      Else
        --预约挂号
        If r_No.预约控制 = 1 Then
          n_禁用 := 1;
        Else
          --不限制预约
          If v_合作单位 Is Null Then
            If r_No.分时段 = 0 Then
              n_已挂数   := r_No.已约数;
              v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
            Else
              --分时段
              v_Temp     := '<SPANLIST>';
              n_已挂数   := 0;
              v_剩余数量 := 0;
              n_时段总数 := 0;
              n_时段剩余 := 0;
              d_时段开始 := Null;
              d_时段结束 := Null;
              Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
              If r_No.序号控制 = 0 Then
                --非序号控制分时段预约
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                     (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                     r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                     Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                
                  Select Count(1)
                  Into n_时段已挂
                  From 临床出诊序号控制
                  Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                
                  n_已挂数   := n_已挂数 + n_时段已挂;
                  v_剩余数量 := v_剩余数量 + (r_Time.数量 - n_时段已挂);
                
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      n_时段剩余 := r_Time.数量 - n_时段已挂;
                      v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                    Else
                      If d_时段开始 Is Null Then
                        n_时段总数 := r_Time.数量;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                        
                          n_时段总数 := r_Time.数量;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + r_Time.数量;
                        End If;
                      End If;
                    
                      n_时段剩余 := n_时段剩余 + r_Time.数量 - n_时段已挂;
                    End If;
                  End If;
                End Loop;
              
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                End If;
              Else
                --序号控制分时段预约
                For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                               From 临床出诊序号控制
                               Where 记录id = r_No.记录id And 是否预约 = 1 And
                                     (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                     r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                     Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                
                  If Nvl(r_Time.挂号状态, 0) = 0 Then
                    v_剩余数量 := v_剩余数量 + 1;
                  Else
                    n_已挂数 := n_已挂数 + 1;
                  End If;
                
                  If r_Time.开始时间 > Sysdate Then
                    If Nvl(n_时间间隔, 0) = 0 Then
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := 1;
                      Else
                        n_时段剩余 := 0;
                      End If;
                      v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                    Else
                      If d_时段开始 Is Null Then
                        n_时段总数 := 1;
                        n_时段剩余 := 0;
                        d_时段开始 := r_Time.开始时间;
                        d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                        If d_加号时间 < d_时段结束 Then
                          d_时段结束 := d_加号时间;
                        End If;
                      Else
                        If r_Time.开始时间 >= d_时段结束 Then
                          v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                        
                          n_时段总数 := 1;
                          n_时段剩余 := 0;
                          d_时段开始 := r_Time.开始时间;
                          d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                          If d_加号时间 < d_时段结束 Then
                            d_时段结束 := d_加号时间;
                          End If;
                        Else
                          n_时段总数 := n_时段总数 + 1;
                        End If;
                      End If;
                    
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        n_时段剩余 := n_时段剩余 + 1;
                      End If;
                    End If;
                  End If;
                End Loop;
              
                If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                  v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                End If;
              End If;
              v_Temp := v_Temp || '</SPANLIST>';
            End If;
          Else
            --合作单位预约挂号
            If r_No.预约控制 = 2 Then
              n_禁用 := 1;
            Else
              Begin
                Select 控制方式
                Into n_合约模式
                From 临床出诊挂号控制记录
                Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位 And Rownum < 2;
              Exception
                When Others Then
                  n_合约模式 := 4;
              End;
            
              If n_合约模式 = 0 Then
                n_禁用 := 1;
              Elsif n_合约模式 = 1 Or n_合约模式 = 2 Then
                Select 数量
                Into n_合约总数量
                From 临床出诊挂号控制记录
                Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位;
                If n_合约模式 = 1 Then
                  n_合约总数量 := Floor(r_No.限约数 * n_合约总数量 / 100);
                End If;
              
                Select Count(1)
                Into n_合约已挂数
                From 病人挂号记录
                Where 号别 = r_No.号码 And 记录状态 = 1 And 合作单位 = v_合作单位 And 发生时间 Between Trunc(d_日期) And
                      Trunc(d_日期 + 1) - 1 / 60 / 60 / 24;
              
                n_合约剩余数量 := n_合约总数量 - n_合约已挂数;
              
                If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < n_合约剩余数量 Then
                  v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                Else
                  v_剩余数量 := n_合约剩余数量;
                End If;
                n_已挂数 := r_No.已约数;
              
                If r_No.分时段 = 1 Then
                  v_Temp     := '<SPANLIST>';
                  n_Exists   := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 1 Then
                    --分时段,序号控制
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                            n_Exists   := n_Exists + 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                            n_Exists   := n_Exists + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  
                    If n_Exists < To_Number(v_剩余数量) Then
                      v_剩余数量 := n_Exists;
                    End If;
                  Else
                    --分时段,非序号控制
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                         Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                    
                      Select Count(1)
                      Into n_时段已挂
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_Time.数量 - n_时段已挂;
                          n_Exists   := n_Exists + n_时段剩余;
                          v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_Time.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                          n_Exists   := n_Exists + (r_Time.数量 - n_时段已挂);
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  
                    If n_Exists < To_Number(v_剩余数量) Then
                      v_剩余数量 := n_Exists;
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              Elsif n_合约模式 = 3 Then
                If r_No.分时段 = 0 Then
                  If r_No.序号控制 = 0 Then
                    n_禁用 := 1;
                  Else
                    --序号控制不分时段
                    n_已挂数   := 0;
                    v_剩余数量 := 0;
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Count(1)
                      Into n_Exists
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 是否预约 = 1 And Nvl(挂号状态, 0) = 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                            Nvl(是否停诊, 0) = 0;
                    
                      If n_Exists = 1 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    End Loop;
                  
                    If Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0) < v_剩余数量 Then
                      v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                    End If;
                  End If;
                Else
                  v_Temp     := '<SPANLIST>';
                  n_已挂数   := 0;
                  v_剩余数量 := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 0 Then
                    --分时段,非序号控制
                    For r_合作 In (Select 序号, 数量
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Count(1), Max(开始时间), Max(终止时间)
                      Into n_时段已挂, d_开始时间, d_终止时间
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1));
                    
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + r_合作.数量 - n_时段已挂;
                    
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_合作.数量 - n_时段已挂;
                          v_Temp     := v_Temp || Gettimexml(d_开始时间, d_终止时间, r_合作.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_合作.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_合作.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_合作.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + r_合作.数量 - n_时段已挂;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  Else
                    --分时段,序号控制
                    For r_合作 In (Select 序号
                                 From 临床出诊挂号控制记录
                                 Where 记录id = r_No.记录id And 类型 = 1 And 性质 = 1 And 名称 = v_合作单位) Loop
                    
                      Select Max(1), Max(开始时间), Max(终止时间)
                      Into n_Exists, d_开始时间, d_终止时间
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_合作.序号 And Nvl(挂号状态, 0) = 0 And
                            (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                            Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                            r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1)) And
                            Nvl(是否停诊, 0) = 0;
                    
                      If n_Exists = 1 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    
                      If d_开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If n_Exists = 1 Then
                            n_时段剩余 := 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(d_开始时间, d_终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := d_开始时间;
                            d_时段结束 := d_开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If d_开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := d_开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If n_Exists = 1 Then
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              Elsif n_合约模式 = 4 Then
                If r_No.分时段 = 0 Then
                  n_已挂数   := r_No.已约数;
                  v_剩余数量 := Nvl(r_No.限约数, r_No.限号数) - Nvl(r_No.已约数, 0);
                Else
                  --分时段
                  v_Temp     := '<SPANLIST>';
                  n_已挂数   := 0;
                  v_剩余数量 := 0;
                  n_时段总数 := 0;
                  n_时段剩余 := 0;
                  d_时段开始 := Null;
                  d_时段结束 := Null;
                  Select Max(终止时间) Into d_加号时间 From 临床出诊序号控制 Where 记录id = r_No.记录id;
                  If r_No.序号控制 = 0 Then
                    --非序号控制分时段预约
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态, 数量
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 预约顺序号 Is Null And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.停诊开始时间, Sysdate) And
                                         Nvl(r_No.停诊终止时间, Sysdate - 1))) Loop
                    
                      Select Count(1)
                      Into n_时段已挂
                      From 临床出诊序号控制
                      Where 记录id = r_No.记录id And 序号 = r_Time.序号 And 预约顺序号 Is Not Null And Nvl(挂号状态, 0) <> 0;
                    
                      n_已挂数   := n_已挂数 + n_时段已挂;
                      v_剩余数量 := v_剩余数量 + n_时段剩余;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          n_时段剩余 := r_Time.数量 - n_时段已挂;
                          v_Temp     := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, r_Time.数量, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := r_Time.数量;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := r_Time.数量;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + r_Time.数量;
                            End If;
                          End If;
                        
                          n_时段剩余 := n_时段剩余 + (r_Time.数量 - n_时段已挂);
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  Else
                    For r_Time In (Select 序号, 开始时间, 终止时间, 挂号状态
                                   From 临床出诊序号控制
                                   Where 记录id = r_No.记录id And 是否预约 = 1 And
                                         (r_No.记录性质 = 1 And 开始时间 Not Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1) Or
                                         r_No.记录性质 = 2 And 开始时间 Between Nvl(r_No.替诊开始时间, Sysdate) And
                                         Nvl(r_No.替诊终止时间, Sysdate - 1)) And Nvl(是否停诊, 0) = 0) Loop
                    
                      If Nvl(r_Time.挂号状态, 0) = 0 Then
                        v_剩余数量 := v_剩余数量 + 1;
                      Else
                        n_已挂数 := n_已挂数 + 1;
                      End If;
                    
                      If r_Time.开始时间 > Sysdate Then
                        If Nvl(n_时间间隔, 0) = 0 Then
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := 1;
                          Else
                            n_时段剩余 := 0;
                          End If;
                          v_Temp := v_Temp || Gettimexml(r_Time.开始时间, r_Time.终止时间, 1, n_时段剩余);
                        Else
                          If d_时段开始 Is Null Then
                            n_时段总数 := 1;
                            n_时段剩余 := 0;
                            d_时段开始 := r_Time.开始时间;
                            d_时段结束 := r_Time.开始时间 + n_时间间隔 / 24 / 60;
                            If d_加号时间 < d_时段结束 Then
                              d_时段结束 := d_加号时间;
                            End If;
                          Else
                            If r_Time.开始时间 >= d_时段结束 Then
                              v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                            
                              n_时段总数 := 1;
                              n_时段剩余 := 0;
                              d_时段开始 := r_Time.开始时间;
                              d_时段结束 := d_时段开始 + n_时间间隔 / 24 / 60;
                              If d_加号时间 < d_时段结束 Then
                                d_时段结束 := d_加号时间;
                              End If;
                            Else
                              n_时段总数 := n_时段总数 + 1;
                            End If;
                          End If;
                        
                          If Nvl(r_Time.挂号状态, 0) = 0 Then
                            n_时段剩余 := n_时段剩余 + 1;
                          End If;
                        End If;
                      End If;
                    End Loop;
                  
                    If Nvl(n_时间间隔, 0) <> 0 And n_时段总数 <> 0 Then
                      v_Temp := v_Temp || Gettimexml(d_时段开始, d_时段结束, n_时段总数, n_时段剩余);
                    End If;
                  End If;
                  v_Temp := v_Temp || '</SPANLIST>';
                End If;
              End If;
            End If;
          End If;
        End If;
      End If;
    
      If Not (r_No.分时段 = 1 And r_No.序号控制 = 1) Then
        If d_日期 Between Nvl(r_No.替诊开始时间, Sysdate) And Nvl(r_No.替诊终止时间, Sysdate - 1) Then
          n_禁用 := 1;
        End If;
        If d_日期 Between Nvl(r_No.停诊开始时间, Sysdate) And Nvl(r_No.停诊终止时间, Sysdate - 1) Then
          n_禁用 := 1;
        End If;
      End If;
    
      If Nvl(n_禁用, 0) = 0 Then
        n_合计金额 := 0;
        For r_Fee In (Select b.现价, a.从项数次
                      From 收费从属项目 A, 收费价目 B
                      Where a.从项id = b.收费细目id And a.主项id = r_No.项目id And Sysdate Between b.执行日期 And
                            Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))
                      Union
                      Select b.现价, 1 As 从项数次
                      From 收费项目目录 A, 收费价目 B
                      Where a.Id = b.收费细目id And a.Id = r_No.项目id And Sysdate Between b.执行日期 And
                            Nvl(b.终止日期, To_Date('3000-1-1', 'YYYY-MM-DD'))) Loop
          n_合计金额 := n_合计金额 + r_Fee.现价 * r_Fee.从项数次;
        End Loop;
      
        v_时间段  := To_Char(r_No.开始时间, 'HH24:MI') || '-' || To_Char(r_No.终止时间, 'HH24:MI');
        c_Xmlmain := '<HB>';
        c_Xmlmain := c_Xmlmain || '<CZJLID>' || r_No.记录id || '</CZJLID>';
        c_Xmlmain := c_Xmlmain || '<HM>' || r_No.号码 || '</HM>';
        c_Xmlmain := c_Xmlmain || '<YSID>' || r_No.医生id || '</YSID>';
        c_Xmlmain := c_Xmlmain || '<YS>' || r_No.医生姓名 || '</YS>';
        c_Xmlmain := c_Xmlmain || '<KSID>' || r_No.科室id || '</KSID>';
        c_Xmlmain := c_Xmlmain || '<KSMC>' || r_No.科室名称 || '</KSMC>';
        c_Xmlmain := c_Xmlmain || '<ZC>' || r_No.职称 || '</ZC>';
        c_Xmlmain := c_Xmlmain || '<XMID>' || r_No.项目id || '</XMID>';
        c_Xmlmain := c_Xmlmain || '<XMMC>' || r_No.项目名称 || '</XMMC>';
        c_Xmlmain := c_Xmlmain || '<PRICE>' || n_合计金额 || '</PRICE>';
        c_Xmlmain := c_Xmlmain || '<HL>' || r_No.号类 || '</HL>';
        c_Xmlmain := c_Xmlmain || '<FSD>' || r_No.分时段 || '</FSD>';
        c_Xmlmain := c_Xmlmain || '<HBTIME>' || v_时间段 || '</HBTIME>';
        c_Xmlmain := c_Xmlmain || '<FWMC>' || r_No.排班 || '</FWMC>';
        If Trunc(Sysdate) = Trunc(d_日期) Or r_No.已约数 < r_No.限约数 Then
          c_Xmlmain := c_Xmlmain || '<YGHS>' || n_已挂数 || '</YGHS>';
          c_Xmlmain := c_Xmlmain || '<SYHS>' || v_剩余数量 || '</SYHS>';
          c_Xmlmain := c_Xmlmain || v_Temp;
        Else
          c_Xmlmain := c_Xmlmain || '<YGHS>' || r_No.已约数 || '</YGHS>';
          c_Xmlmain := c_Xmlmain || '<SYHS>' || 0 || '</SYHS>';
        End If;
        c_Xmlmain := c_Xmlmain || '</HB>';
        v_Xmlmain := v_Xmlmain || c_Xmlmain;
      End If;
    End If;
  End Loop;
  v_Xmlmain := '<GROUP>' || '<RQ>' || To_Char(d_日期, 'yyyy-mm-dd') || '</RQ>' || '<HBLIST>' || v_Xmlmain || '</HBLIST>' ||
               '</GROUP>';
  Select Appendchildxml(x_Templet, '/OUTPUT', Xmltype(v_Xmlmain)) Into x_Templet From Dual;
  Xml_Out := x_Templet;
Exception
  When Err_Item Then
    v_Temp := '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]';
    Raise_Application_Error(-20101, v_Temp);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Third_Getnolist;
/


--109325:李业庆,2018-01-03,可用数量异常数据处理
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品结存记录_Verify
(
  结存id_In In 药品结存记录.Id%Type,
  审核人_In In 药品结存记录.审核人%Type := Null
) Is
  v_Id    药品结存记录.Id%Type;
  Err_Msg Varchar2(255);
  Err_Find Exception;

  Cursor c_Mistake Is
    Select a.Id, a.结存id, a.库房id, a.药品id, Nvl(a.批次, 0) 批次, a.数量差, a.金额差, a.差价差
    From 药品结存误差 A, 药品规格 B
    Where a.药品id = b.药品id And a.结存id = 结存id_In;
Begin
  --并发检查 
  Begin
    Select ID Into v_Id From 药品结存记录 Where 审核人 Is Null And ID = 结存id_In;
  Exception
    When Others Then
      Err_Msg := '该结存记录已被其他操作员审核，请查看！';
      Raise Err_Find;
  End;

  --审核药品结存主表 
  Update 药品结存记录
  Set 审核人 = Nvl(审核人_In, Zl_Username), 审核日期 = Sysdate
  Where 审核人 Is Null And ID = 结存id_In;

  --根据误差数据修正库存数据 
  For r_Mistake In c_Mistake Loop
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + r_Mistake.数量差, 实际数量 = Nvl(实际数量, 0) + r_Mistake.数量差, 实际金额 = Nvl(实际金额, 0) + r_Mistake.金额差,
        实际差价 = Nvl(实际差价, 0) + r_Mistake.差价差
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0);
  
    If Sql%RowCount = 0 Then
      Begin
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 效期, 上次供应商id, 上次采购价, 上次产地, 上次生产日期, 批准文号)
          Select 库房id, 药品id, Nvl(批次, 0) As 批次, 1, r_Mistake.数量差, r_Mistake.数量差, r_Mistake.金额差, r_Mistake.差价差, 批号, 效期,
                 供药单位id, 成本价, 产地, 生产日期, 批准文号
          From 药品收发记录
          Where ID = (Select Max(ID)
                      From 药品收发记录
                      Where 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(批次, 0) = Nvl(r_Mistake.批次, 0) And
                            审核日期 Is Not Null And 单据 In (1, 2, 3, 4, 6, 7, 8, 9, 10, 11));
      
      Exception
        When Others Then
          Null;
      End;
    End If;
  
    Delete From 药品库存
    Where 性质 = 1 And 库房id = r_Mistake.库房id And 药品id = r_Mistake.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    
    Zl_药品库存_可用数量异常处理(r_Mistake.库房id, r_Mistake.药品id, Nvl(r_Mistake.批次, 0));
  End Loop;

Exception
  When Err_Find Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品结存记录_Verify;
/

--119720:李业庆,2018-03-07,按批号先进先出
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_病人门诊收费_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  保险大类id_In 门诊费用记录.保险大类id%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  摘要_In       门诊费用记录.摘要%Type := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  中药形态_In   门诊费用记录.结论%Type := Null
) As
  --功能：新收一张门诊收费单据
  --参数：
  --  病人来源_IN:1-门诊;2-住院  住院病人收费时用。
  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --以ID排序，优先冲上次未冲完的。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock(n_Outmode Number) Is
    Select *
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = 执行部门id_In And 性质 = 1 And (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And
          Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  v_分批 药品规格.药房分批%Type;
  v_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  v_总数量   Number;
  v_当前数量 Number;
  v_总金额   Number;
  v_当前单价 Number;
  --药品收发记录
  v_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_序号       药品收发记录.序号%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_灭菌日期   药品收发记录.灭菌日期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;

  v_煎法 药品收发记录.外观%Type;
  ------------------------------------------------------------
  --结算方式串
  v_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;

  --临时变量
  n_Outmode Number(1);
  v_Count   Number;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_单价小数 Number;
  n_出库检查 Number(1);
Begin
  Zl_药品库存_可用数量异常处理(执行部门id_In, 收费细目id_In);

  n_组id := Zl_Get组id(操作员姓名_In);

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
     保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
     执行状态, 费用状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 结论, 缴款组id)
  Values
    (v_费用id, 1, No_In, 1, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In),
     Decode(病人来源_In, 1, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 付款方式_In, 姓名_In, 性别_In,
     年龄_In, 病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 保险项目否_In, 保险大类id_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In,
     收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 0, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In,
     0, 1, 结帐id_In, 实收金额_In, 操作员编号_In, 操作员姓名_In, 摘要_In, 是否急诊_In, 中药形态_In, n_组id);

  --药品和卫生材料部分
  v_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    
      --卫材分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    v_总数量 := 付数_In * 数次_In;
    v_总金额 := 0;
    Open c_Stock(n_Outmode);
  
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = 执行部门id_In;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = 执行部门id_In;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
  
    While v_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If v_分批 = 1 Or v_时价 = 1 Then
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
          Else
            v_Error := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
          End If;
          Raise Err_Custom;
        End If;
      Elsif (v_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (v_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
        Else
          v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
        End If;
        Raise Err_Custom;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (v_总数量 > 0 Or v_时价 = 1) And n_出库检查 = 2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
          Else
            v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
          End If;
          Raise Err_Custom;
        End If;
      End If;
    
      --确定本次分解数量
      If v_分批 = 1 Or v_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If v_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          v_当前数量 := v_总数量;
        Else
          v_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If v_时价 = 1 Then
          v_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif v_分批 = 1 Then
          v_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        v_当前数量 := v_总数量;
        v_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * v_当前数量);
        End If;
      End If;
    
      --药品收发记录
      v_批次       := Null;
      v_批号       := Null;
      v_效期       := Null;
      v_产地       := Null;
      v_灭菌效期   := Null;
      v_灭菌日期   := Null;
      v_供药单位id := Null;
      v_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        v_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        v_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        v_供药单位id := r_Stock.上次供应商id;
        v_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            v_灭菌效期 := r_Stock.灭菌效期;
            v_灭菌日期 := v_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into v_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If v_分批 = 1 And v_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      --注意卫材单据与药品单据不同
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 灭菌效期, 灭菌日期, 外观, 供药单位id, 生产日期, 批准文号)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, v_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         v_批次, v_产地, v_批号, v_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In),
         Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In), v_当前单价, Round(v_当前单价 * v_当前数量, v_Dec), Null, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, v_灭菌效期, v_灭菌日期, v_煎法, v_供药单位id, v_生产日期, v_批准文号);
    
      v_总数量 := v_总数量 - v_当前数量;
      v_总金额 := v_总金额 + Round(v_当前数量 * v_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录:可能同一个库房,但一个为药品,一个为卫材,插入两条记录。
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 发药窗口 = Nvl(发药窗口_In, 发药窗口) --可能药品和材料用同一个库房,但材料无发药窗口
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), Null, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 1, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If v_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If v_当前数量 <> 付数_In * 数次_In Then
        v_当前单价 := Round(v_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If v_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        Else
          v_Error := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And Nvl(病人来源_In, 1) = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人门诊收费_Insert;
/

--119720:李业庆,2018-03-07,按批号先进先出
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊划价记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  主页id_In     住院费用记录.主页id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  病人来源_In   Number := 1,
  保险编码_In   门诊费用记录.保险编码%Type := Null,
  费用类型_In   门诊费用记录.费用类型%Type := Null,
  保险项目否_In 门诊费用记录.保险项目否%Type := Null,
  保险大类id_In 门诊费用记录.保险大类id%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
  
) As
  --功能：新收一张门诊划价单据
  --参数：
  --   病人来源_IN:1-门诊病人,2-住院病人
  --     主页ID_IN:住院病人划价时用。
  --   药品摘要_IN:修改保存新单据时用。目前仅存放在药品收发记录的摘要中。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In, 0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  v_其他出库no 药品收发记录.No%Type;
  v_部门名称   部门表.名称%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  n_Aval       药品库存.可用数量%Type;
  n_修正库房id 药品库存.库房id%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;
  n_单价小数   Number;
  n_Outmode    Number(1);
  n_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库检查 Number(1);
Begin
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In, 0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额及单价小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Select Nvl(Max(急诊), 0)
    Into n_急诊
    From 病人挂号记录
    Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 发药窗口,
     加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 摘要, 医嘱序号, 保险项目否, 保险编码,
     保险大类id, 费用类型, 结论, 是否急诊)
  Values
    (v_费用id, 1, No_In, 0, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In), Nvl(病人来源_In, 1),
     Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In, 病人科室id_In, 费别_In, 收费类别_In,
     收费细目id_In, 计算单位_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 0,
     操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, 费用摘要_In, 医嘱序号_In, 保险项目否_In, 保险编码_In, 保险大类id_In,
     费用类型_In, 中药形态_In, Nvl(n_急诊, 0));

  --药品和卫生材料部分
  n_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into n_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    
      --卫材分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
      Else
        n_库房id := 执行部门id_In;
      End If;
    End If;
  
    Open c_Stock(n_Outmode, n_库房id);
  
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货收费！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货收费！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫行材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) And n_出库检查 = 2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;

	Zl_药品库存_可用数量异常处理(n_库房id, 收费细目id_In, Nvl(r_Stock.批次, 0));
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;

	Zl_药品库存_可用数量异常处理(n_库房id, 收费细目id_In, 0);
      End If;
    
      --高值卫材模式减少发料部门可用数量
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And b.记录性质 = 1 And Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 发药窗口, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 发药窗口_In, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码,
           v_内部条码);
      
      End If;
      v_Err_Msg := '';
    
      n_总数量 := n_总数量 - n_当前数量;
      n_总金额 := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), 主页id_In, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 0, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
  
    If 付款方式_In Is Not Null And 病人来源_In = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
  
    If 费别_In Is Not Null Then
      Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
    End If;
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
  
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Insert;
/

--119720:李业庆,2018-03-07,按批号先进先出
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊收费记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  病人来源_In   Number,
  标识号_In     门诊费用记录.标识号%Type,
  付款方式_In   门诊费用记录.付款方式%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  保险项目否_In 门诊费用记录.保险项目否%Type,
  保险大类id_In 门诊费用记录.保险大类id%Type,
  发药窗口_In   门诊费用记录.发药窗口%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  统筹金额_In   门诊费用记录.统筹金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  原no_In       门诊费用记录.No%Type,
  结帐id_In     门诊费用记录.结帐id%Type,
  收费结算_In   Varchar2,
  冲预交额_In   病人预交记录.冲预交%Type,
  保险结算_In   Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  摘要_In       门诊费用记录.摘要%Type := Null,
  是否急诊_In   门诊费用记录.是否急诊%Type := 0,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  缴款_In       病人预交记录.缴款%Type := Null,
  找补_In       病人预交记录.找补%Type := Null,
  中药形态_In   门诊费用记录.结论%Type := Null
) As
  --功能：新收一张门诊收费单据
  --参数：
  --  病人来源_IN:1-门诊;2-住院  住院病人收费时用。
  --  原NO_IN:修改保存新单据时用。目前用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  -- 收费结算_IN:格式="结算方式|结算金额|结算号码|结算摘要||.....",注意无结算号码和摘要时要用空格填充
  -- 保险结算_IN:格式="结算方式|结算金额||....."

  --该游标用于收费冲预交的可用预交列表(该SQL参考住院结帐)
  --先缴先用
  --不包含结算方式为代收款项的预交款。
  Cursor c_Deposit(v_病人id 病人信息.病人id%Type) Is
    Select a.No, Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) As 金额, Nvl(Max(a.结帐id), 0) As 结帐id,
           Max(Decode(a.记录性质, 1, a.记录状态, 1)) As 记录状态,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.Id, 3, a.Id, 0), 0)) As ID,
           Max(Decode(a.记录性质, 1, Decode(a.记录状态, 1, a.收款时间, 3, a.收款时间, Null, Null))) As 收款时间
    From 病人预交记录 A
    Where a.记录性质 In (1, 11) And a.病人id = v_病人id And Nvl(a.预交类别, 2) = 1 And
          a.结算方式 Not In (Select 名称 From 结算方式 Where 性质 = 5)
    Group By a.No
    Having Sum(Nvl(a.金额, 0) - Nvl(a.冲预交, 0)) <> 0
    Order By 收款时间;

  v_费用id   门诊费用记录.Id%Type;
  v_优先级   未发药品记录.优先级%Type;
  v_预交金额 病人预交记录.冲预交%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock(n_Outmode Number) Is
    Select *
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = 执行部门id_In And 性质 = 1 And (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And
          Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  v_分批 药品规格.药房分批%Type;
  v_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  v_总数量   Number;
  v_当前数量 Number;
  v_总金额   Number;
  v_当前单价 Number;
  --药品收发记录
  v_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_序号       药品收发记录.序号%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_灭菌日期   药品收发记录.灭菌日期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;

  v_煎法 药品收发记录.外观%Type;
  ------------------------------------------------------------
  --结算方式串
  v_结算内容 Varchar2(3000);
  v_当前结算 Varchar2(150);
  v_结算方式 病人预交记录.结算方式%Type;
  v_结算金额 病人预交记录.冲预交%Type;
  v_结算号码 病人预交记录.结算号码%Type;
  v_结算摘要 病人预交记录.摘要%Type;
  n_返回值   病人余额.费用余额%Type;

  v_Dec        Number;
  v_付款方式   医疗付款方式.名称%Type;
  v_费别性质   费别.属性%Type;
  n_新病人模式 Number;

  --临时变量
  n_Outmode Number(1);
  v_Count   Number;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  n_组id     财务缴款分组.Id%Type;
  n_单价小数 Number;
  n_出库检查 Number(1);
Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 付款方式, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 保险项目否,
     保险大类id, 付数, 数次, 发药窗口, 加班标志, 附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id,
     执行状态, 结帐id, 结帐金额, 操作员编号, 操作员姓名, 摘要, 是否急诊, 结论, 缴款组id)
  Values
    (v_费用id, 1, No_In, 1, 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In), Decode(价格父号_In, 0, Null, 价格父号_In),
     Decode(病人来源_In, 1, 1, 2), Decode(病人id_In, 0, Null, 病人id_In), Decode(标识号_In, 0, Null, 标识号_In), 付款方式_In, 姓名_In, 性别_In,
     年龄_In, 病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 保险项目否_In, 保险大类id_In, 付数_In, 数次_In, 发药窗口_In, 加班标志_In, 附加标志_In,
     收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 0, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In,
     0, 结帐id_In, 实收金额_In, 操作员编号_In, 操作员姓名_In, 摘要_In, 是否急诊_In, 中药形态_In, n_组id);

  If 序号_In = 1 Then
    --病人预交记录(第一行时处理)
    --正常结算
    If 收费结算_In Is Not Null Then
      --各个收费结算
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
      
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算号码 := LTrim(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
        v_结算摘要 := LTrim(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款, 找补, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), Null, v_结算摘要, v_结算方式, v_结算号码, 登记时间_In,
             操作员编号_In, 操作员姓名_In, v_结算金额, 结帐id_In, Decode(v_结算内容, 收费结算_In || '||', 缴款_In, Null),
             Decode(v_结算内容, 收费结算_In || '||', 找补_In, Null), n_组id, 3);
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 结算性质)
          Values
            (病人预交记录_Id.Nextval, 3, No_In, 1, Decode(病人id_In, 0, Null, 病人id_In), '保险结算', v_结算方式, 登记时间_In, 操作员编号_In,
             操作员姓名_In, v_结算金额, 结帐id_In, n_组id, 3);
        End If;
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --预交结算
    If Nvl(冲预交额_In, 0) <> 0 Then
      If Nvl(病人id_In, 0) = 0 Then
        v_Error := '不能确定病人病人ID,收费使用预交款结算失败！';
        Raise Err_Custom;
      End If;
    
      v_预交金额 := 冲预交额_In;
      For r_Deposit In c_Deposit(病人id_In) Loop
        If r_Deposit.结帐id = 0 Then
          --第一次冲预交(将第一次标上结帐ID,冲预交标记为0)
          Update 病人预交记录 Set 冲预交 = 0, 结帐id = 结帐id_In, 结算性质 = 3 Where ID = r_Deposit.Id;
        End If;
        --冲上次剩余额
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 登记时间_In, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - v_预交金额), -1, r_Deposit.金额, v_预交金额), 结帐id_In,
                 n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 3
          From 病人预交记录
          Where NO = r_Deposit.No And 记录状态 = r_Deposit.记录状态 And 记录性质 In (1, 11) And Rownum = 1;
        --检查是否已经处理完
        If r_Deposit.金额 < v_预交金额 Then
          v_预交金额 := v_预交金额 - r_Deposit.金额;
        Else
          v_预交金额 := 0;
        End If;
        If v_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      --检查金额是否足够
      If v_预交金额 > 0 Then
        v_Error := '病人的当前预交余额不足金额 ' || LTrim(To_Char(冲预交额_In, '9999999990.00')) || ' ！';
        Raise Err_Custom;
      End If;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) - 冲预交额_In
      Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 预交余额, 性质, 类型) Values (病人id_In, -冲预交额_In, 1, 1);
        n_返回值 := -冲预交额_In;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = 病人id_In And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;

  --相关汇总表的处理
  --汇总"人员缴款余额"(注意要处理个人帐户的结算)
  n_返回值 := 0;
  If 序号_In = 1 Then
    --各个收费结算
    If 收费结算_In Is Not Null Then
      v_结算内容 := 收费结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        v_结算金额 := To_Number(Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
  
    --各个保险结算
    If 保险结算_In Is Not Null Then
      v_结算内容 := 保险结算_In || '||';
      While v_结算内容 Is Not Null Loop
        v_当前结算 := Substr(v_结算内容, 1, Instr(v_结算内容, '||') - 1);
      
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_结算金额 := To_Number(Substr(v_当前结算, Instr(v_当前结算, '|') + 1));
      
        If Nvl(v_结算金额, 0) <> 0 Then
          Update 人员缴款余额
          Set 余额 = Nvl(余额, 0) + Nvl(v_结算金额, 0)
          Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = v_结算方式
          Returning 余额 + n_返回值 Into n_返回值;
        
          If Sql%RowCount = 0 Then
            Insert Into 人员缴款余额
              (收款员, 结算方式, 性质, 余额)
            Values
              (操作员姓名_In, v_结算方式, 1, Nvl(v_结算金额, 0));
            n_返回值 := n_返回值 + Nvl(v_结算金额, 0);
          End If;
        End If;
      
        v_结算内容 := Substr(v_结算内容, Instr(v_结算内容, '||') + 2);
      End Loop;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额 Where 性质 = 1 And 收款员 = 操作员姓名_In And Nvl(余额, 0) = 0;
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    
      --卫材分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into v_分批, v_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    v_总数量 := 付数_In * 数次_In;
    v_总金额 := 0;
    Open c_Stock(n_Outmode);
  
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = 执行部门id_In;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = 执行部门id_In;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
  
    While v_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If v_分批 = 1 Or v_时价 = 1 Then
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有可用的库存！';
          Else
            v_Error := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有可用的药品库存！';
          End If;
          Raise Err_Custom;
        End If;
      Elsif (v_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (v_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的在用分批属性与库存记录不相符,请检查材料数据的正确性！';
        Else
          v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
        End If;
        Raise Err_Custom;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (v_总数量 > 0 Or v_时价 = 1) And n_出库检查 = 2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 收费类别_In = '4' Then
            v_Error := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
          Else
            v_Error := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
          End If;
          Raise Err_Custom;
        End If;
      End If;
    
      --确定本次分解数量
      If v_分批 = 1 Or v_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If v_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          v_当前数量 := v_总数量;
        Else
          v_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If v_时价 = 1 Then
          v_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif v_分批 = 1 Then
          v_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        v_当前数量 := v_总数量;
        v_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;

	Zl_药品库存_可用数量异常处理(执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0));
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - v_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * v_当前数量);
        End If;

	Zl_药品库存_可用数量异常处理(执行部门id_In, 收费细目id_In, 0);
      End If;
    
      --药品收发记录
      v_批次       := Null;
      v_批号       := Null;
      v_效期       := Null;
      v_产地       := Null;
      v_灭菌效期   := Null;
      v_灭菌日期   := Null;
      v_供药单位id := Null;
      v_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        v_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        v_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        v_供药单位id := r_Stock.上次供应商id;
        v_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            v_灭菌效期 := r_Stock.灭菌效期;
            v_灭菌日期 := v_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into v_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 24, 8) And 记录状态 = 1 And NO = No_In;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If v_分批 = 1 And v_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      --注意卫材单据与药品单据不同
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 发药窗口, 灭菌效期, 灭菌日期, 外观, 供药单位id, 生产日期, 批准文号)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 24, 8), No_In, v_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         v_批次, v_产地, v_批号, v_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In),
         Decode(v_Count, 1, v_当前数量, v_当前数量 / 付数_In), v_当前单价, Round(v_当前单价 * v_当前数量, v_Dec), 原no_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 发药窗口_In, v_灭菌效期, v_灭菌日期, v_煎法, v_供药单位id, v_生产日期, v_批准文号);
    
      v_总数量 := v_总数量 - v_当前数量;
      v_总金额 := v_总金额 + Round(v_当前数量 * v_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录:可能同一个库房,但一个为药品,一个为卫材,插入两条记录。
    Update 未发药品记录
    Set 病人id = Decode(病人id_In, 0, Null, 病人id_In), 姓名 = 姓名_In, 发药窗口 = Nvl(发药窗口_In, 发药窗口) --可能药品和材料用同一个库房,但材料无发药窗口
    Where 单据 = Decode(收费类别_In, '4', 24, 8) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      If Nvl(病人id_In, 0) <> 0 And v_优先级 Is Null Then
        Begin
          Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
        Exception
          When Others Then
            Null;
        End;
      End If;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 打印状态)
      Values
        (Decode(收费类别_In, '4', 24, 8), No_In, Decode(病人id_In, 0, Null, 病人id_In), Null, 姓名_In, v_优先级, 开单部门id_In,
         执行部门id_In, 发药窗口_In, 登记时间_In, 1, 0);
    End If;
    Zl_Prescription_Type_Update(No_In, 1, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If v_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If v_当前数量 <> 付数_In * 数次_In Then
        v_当前单价 := Round(v_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If v_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 收费类别_In = '4' Then
          v_Error := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        Else
          v_Error := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
        End If;
        Raise Err_Custom;
      End If;
    End If;
  
    Close c_Stock;
  End If;

  --更新部份病人信息
  If 序号_In = 1 And 病人id_In Is Not Null Then
    If 付款方式_In Is Not Null And Nvl(病人来源_In, 1) = 1 Then
      Select 名称 Into v_付款方式 From 医疗付款方式 Where 编码 = 付款方式_In;
    End If;
    Select Max(属性) Into v_费别性质 From 费别 Where 名称 = 费别_In; --2-动态费别不更新
  
    Update 病人信息
    Set 性别 = Decode(姓名, '新病人', Nvl(性别_In, 性别), 性别), 年龄 = Decode(姓名, '新病人', Nvl(年龄_In, 年龄), 年龄),
        姓名 = Decode(姓名, '新病人', 姓名_In, 姓名), 医疗付款方式 = Nvl(v_付款方式, 医疗付款方式), 费别 = Decode(v_费别性质, 1, 费别_In, 费别)
    Where 病人id = 病人id_In;
    Select Zl_To_Number(Nvl(zl_GetSysParameter('自动产生姓名', '1111'), '0')) Into n_新病人模式 From Dual;
    If n_新病人模式 = 1 Then
      Update 病人挂号记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
      Update 门诊费用记录
      Set 姓名 = 姓名_In, 性别 = 性别_In, 年龄 = 年龄_In, 付款方式 = 付款方式_In
      Where 病人id = 病人id_In And 姓名 = '新病人';
    End If;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Insert;
/

--119720:李业庆,2018-03-07,按批号先进先出
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊记帐记录_Insert
(
  No_In         门诊费用记录.No%Type,
  序号_In       门诊费用记录.序号%Type,
  病人id_In     门诊费用记录.病人id%Type,
  标识号_In     门诊费用记录.标识号%Type,
  姓名_In       门诊费用记录.姓名%Type,
  性别_In       门诊费用记录.性别%Type,
  年龄_In       门诊费用记录.年龄%Type,
  费别_In       门诊费用记录.费别%Type,
  加班标志_In   门诊费用记录.加班标志%Type,
  婴儿费_In     门诊费用记录.婴儿费%Type,
  病人科室id_In 门诊费用记录.病人科室id%Type,
  开单部门id_In 门诊费用记录.开单部门id%Type,
  开单人_In     门诊费用记录.开单人%Type,
  从属父号_In   门诊费用记录.从属父号%Type,
  收费细目id_In 门诊费用记录.收费细目id%Type,
  收费类别_In   门诊费用记录.收费类别%Type,
  计算单位_In   门诊费用记录.计算单位%Type,
  付数_In       门诊费用记录.付数%Type,
  数次_In       门诊费用记录.数次%Type,
  附加标志_In   门诊费用记录.附加标志%Type,
  执行部门id_In 门诊费用记录.执行部门id%Type,
  价格父号_In   门诊费用记录.价格父号%Type,
  收入项目id_In 门诊费用记录.收入项目id%Type,
  收据费目_In   门诊费用记录.收据费目%Type,
  标准单价_In   门诊费用记录.标准单价%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  实收金额_In   门诊费用记录.实收金额%Type,
  发生时间_In   门诊费用记录.发生时间%Type,
  登记时间_In   门诊费用记录.登记时间%Type,
  药品摘要_In   药品收发记录.摘要%Type,
  划价_In       Number,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  类别id_In     药品单据性质.类别id%Type := Null,
  记帐单id_In   门诊费用记录.记帐单id%Type := Null,
  费用摘要_In   门诊费用记录.摘要%Type := Null,
  医嘱序号_In   门诊费用记录.医嘱序号%Type := Null,
  频次_In       药品收发记录.频次%Type := Null,
  单量_In       药品收发记录.单量%Type := Null,
  用法_In       药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In       药品收发记录.扣率%Type := Null,
  计价特性_In   药品收发记录.扣率%Type := Null,
  门诊标志_In   门诊费用记录.门诊标志%Type := 1,
  中药形态_In   门诊费用记录.结论%Type := Null,
  备货材料_In   Number := 0,
  批次_In       药品收发记录.批次%Type := Null
) As
  --功能：新收一张门诊记帐单据
  --参数：
  --   药品摘要_IN:修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  v_费用id 门诊费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;
  n_急诊   病人挂号记录.急诊%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
           商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In, 0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0);
  r_Stock      c_Stock%RowType;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_库房id     药品库存.库房id%Type;
  n_出库序号   药品收发记录.序号%Type;
  v_部门名称   部门表.名称%Type;
  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  d_效期       药品收发记录.效期%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_Aval       药品库存.可用数量%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_单价小数   Number;

  n_Outmode Number(1);
  n_Dec     Number;
  n_Count   Number;
  v_Err_Msg Varchar2(255);
  Err_Item Exception;

  v_发药窗口 药品收发记录.发药窗口%Type;
  n_跟踪在用 材料特性.跟踪在用%Type;
  n_出库检查 Number(1);
Begin
  n_跟踪在用 := 0;
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select Nvl(跟踪在用, 0) Into n_跟踪在用 From 材料特性 Where 材料id = 收费细目id_In;
  End If;

  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In, 0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into n_Dec, n_单价小数
  From Dual;

  If (收费类别_In In ('5', '6', '7') Or 收费类别_In = '4' And n_跟踪在用 = 1) And Nvl(划价_In, 0) = 0 Then
    --同一张单据,满足同一药房同一窗口
    Begin
      Select 发药窗口
      Into v_发药窗口
      From 门诊费用记录
      Where 收费类别 In ('5', '6', '7', '4') And NO = No_In And 记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And
            Rownum <= 1;
    Exception
      When Others Then
        v_发药窗口 := Null;
    End;
    If v_发药窗口 Is Null Then
      --同一病人在普通号挂号有效挂号天数内且未发药的且上班的,以最近一次记账窗口为准
      n_Count := To_Number(Substr(Nvl(zl_GetSysParameter(21), '11') || '11', 1, 1));
      If n_Count = 0 Then
        n_Count := 1;
      End If;
    
      Begin
        Select 发药窗口
        Into v_发药窗口
        From (Select 登记时间, 发药窗口
               From 门诊费用记录 A
               Where 收费类别 In ('5', '6', '7', '4') And 病人id = 病人id_In And 登记时间 Between Sysdate - n_Count And Sysdate And
                     记录性质 = 2 And 执行部门id = 执行部门id_In And 发药窗口 Is Not Null And Exists
                (Select 1
                      From 未发药品记录
                      Where a.No = NO And 单据 In (9, 26) And 库房id + 0 = 执行部门id_In And 病人id + 0 = 病人id_In) And Exists
                (Select 1
                      From 发药窗口
                      Where Nvl(上班否, 0) = 1 And 名称 = a.发药窗口 And Nvl(专家, 0) = 0 And 药房id = 执行部门id_In)
               Order By 登记时间 Desc)
        Where Rownum <= 1;
      
      Exception
        When Others Then
          v_发药窗口 := Null;
      End;
      If v_发药窗口 Is Null Then
        v_发药窗口 := Zl_Get发药窗口(执行部门id_In);
      End If;
    End If;
  End If;
  --门诊费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;

  --是否是急诊挂号单
  If Nvl(医嘱序号_In, 0) <> 0 Then
    Select Nvl(Max(急诊), 0)
    Into n_急诊
    From 病人挂号记录
    Where NO In (Select 挂号单 From 病人医嘱记录 Where ID = Nvl(医嘱序号_In, 0)) And 病人id = 病人id_In;
  End If;

  Insert Into 门诊费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 门诊标志, 病人id, 标识号, 姓名, 性别, 年龄, 病人科室id, 费别, 收费类别, 收费细目id, 计算单位, 付数, 数次, 加班标志,
     附加标志, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 记帐费用, 划价人, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 操作员编号, 操作员姓名, 婴儿费, 记帐单id,
     摘要, 医嘱序号, 结论, 发药窗口, 是否急诊)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 门诊标志_In, 病人id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In, 年龄_In,
     病人科室id_In, 费别_In, 收费类别_In, 收费细目id_In, 计算单位_In, 付数_In, 数次_In, 加班标志_In, 附加标志_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In,
     实收金额_In, 1, 操作员姓名_In, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In, 执行部门id_In, 0, Decode(划价_In, 1, Null, 操作员编号_In),
     Decode(划价_In, 1, Null, 操作员姓名_In), 婴儿费_In, 记帐单id_In, 费用摘要_In, 医嘱序号_In, 中药形态_In, v_发药窗口, Nvl(n_急诊, 0));

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 性质 = 1 And 类型 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 性质, 类型, 费用余额, 预交余额) Values (病人id_In, 1, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And Nvl(病人科室id, 0) = Nvl(病人科室id_In, 0) And
          Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And
          来源途径 + 0 = 门诊标志_In;
  
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, Null, Null, 病人科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 门诊标志_In, 实收金额_In);
    End If;
  
  End If;

  --药品和卫生材料部分

  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(n_跟踪在用, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    
      --卫材分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
      Else
        n_库房id := 执行部门id_In;
      End If;
    End If;
    Open c_Stock(n_Outmode, n_库房id);
  
    Begin
      If 收费类别_In In ('5', '6', '7') Then
        Select 检查方式 Into n_出库检查 From 药品出库检查 Where 库房id = n_库房id;
      Else
        Select 检查方式 Into n_出库检查 From 材料出库检查 Where 库房id = n_库房id;
      End If;
    Exception
      When Others Then
        n_出库检查 := 0;
    End;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) And n_出库检查 = 2 Then
          --实际数量为零时，如果严格控制库存，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;

	Zl_药品库存_可用数量异常处理(n_库房id, 收费细目id_In, Nvl(r_Stock.批次, 0));
      Elsif 执行部门id_In Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (执行部门id_In, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;

	Zl_药品库存_可用数量异常处理(n_库房id, 收费细目id_In, 0);
      End If;
    
      --高值卫材模式减少发料部门可用数量
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
    
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          n_Count := 0;
          Begin
            Select 灭菌效期 Into n_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(n_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - n_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where 单据 = Decode(收费类别_In, '4', 25, 9) And 记录状态 = 1 And NO = No_In;
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        n_Count := 1;
      Else
        n_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(收费类别_In, '4', 25, 9), No_In, n_序号, 执行部门id_In, 开单部门id_In, 类别id_In, -1, 收费细目id_In,
         n_批次, v_产地, v_批号, d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
         Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), 药品摘要_In, 操作员姓名_In, 登记时间_In,
         v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And b.No = No_In And 记录性质 = 2 And b.门诊标志 = 门诊标志_In And
                Instr(',8,9,10,21,24,25,26,', ',' || a.单据 || ',') > 0;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(病人科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 病人科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '门诊号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1, 100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
      
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, 开单部门id_In, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(n_Count, 1, 1, 付数_In), Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(n_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, n_Dec), v_Err_Msg, 操作员姓名_In,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, n_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 姓名 = 姓名_In, 发药窗口 = v_发药窗口
    Where 单据 = Decode(收费类别_In, '4', 25, 9) And NO = No_In And Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态, 发药窗口)
      Values
        (Decode(收费类别_In, '4', 25, 9), No_In, 病人id_In, 姓名_In, v_优先级, 开单部门id_In, 执行部门id_In, 登记时间_In,
         Decode(划价_In, 1, 0, 1), 0, v_发药窗口);
    End If;
    Zl_Prescription_Type_Update(No_In, 2, 收费细目id_In, 收费类别_In);
  
    --可能分批时价药品分解的批次变了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
  
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Insert;
/

--119720:李业庆,2018-03-07,按批号先进先出
--120256:李业庆,2018-01-16,增加卫材出库顺序参数
--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_住院记帐记录_Insert
(
  No_In             住院费用记录.No%Type,
  序号_In           住院费用记录.序号%Type,
  病人id_In         住院费用记录.病人id%Type,
  主页id_In         住院费用记录.主页id%Type,
  标识号_In         住院费用记录.标识号%Type,
  姓名_In           住院费用记录.姓名%Type,
  性别_In           住院费用记录.性别%Type,
  年龄_In           住院费用记录.年龄%Type,
  床号_In           住院费用记录.床号%Type,
  费别_In           住院费用记录.费别%Type,
  病区id_In         住院费用记录.病人病区id%Type,
  科室id_In         住院费用记录.病人科室id%Type,
  加班标志_In       住院费用记录.加班标志%Type,
  婴儿费_In         住院费用记录.婴儿费%Type,
  开单部门id_In     住院费用记录.开单部门id%Type,
  开单人_In         住院费用记录.开单人%Type,
  从属父号_In       住院费用记录.从属父号%Type,
  收费细目id_In     住院费用记录.收费细目id%Type,
  收费类别_In       住院费用记录.收费类别%Type,
  计算单位_In       住院费用记录.计算单位%Type,
  保险项目否_In     住院费用记录.保险项目否%Type,
  保险大类id_In     住院费用记录.保险大类id%Type,
  保险编码_In       住院费用记录.保险编码%Type,
  付数_In           住院费用记录.付数%Type,
  数次_In           住院费用记录.数次%Type,
  附加标志_In       住院费用记录.附加标志%Type,
  执行部门id_In     住院费用记录.执行部门id%Type,
  价格父号_In       住院费用记录.价格父号%Type,
  收入项目id_In     住院费用记录.收入项目id%Type,
  收据费目_In       住院费用记录.收据费目%Type,
  标准单价_In       住院费用记录.标准单价%Type,
  应收金额_In       住院费用记录.应收金额%Type,
  实收金额_In       住院费用记录.实收金额%Type,
  统筹金额_In       住院费用记录.统筹金额%Type,
  发生时间_In       住院费用记录.发生时间%Type,
  登记时间_In       住院费用记录.登记时间%Type,
  药品摘要_In       药品收发记录.摘要%Type,
  划价_In           Number,
  操作员编号_In     住院费用记录.操作员编号%Type,
  操作员姓名_In     住院费用记录.操作员姓名%Type,
  多病人单_In       Number := 0,
  类别id_In         药品单据性质.类别id%Type := Null,
  记帐单id_In       住院费用记录.记帐单id%Type := Null,
  费用摘要_In       住院费用记录.摘要%Type := Null,
  是否急诊_In       住院费用记录.是否急诊%Type := 0,
  医嘱序号_In       住院费用记录.医嘱序号%Type := Null,
  频次_In           药品收发记录.频次%Type := Null,
  单量_In           药品收发记录.单量%Type := Null,
  用法_In           药品收发记录.用法%Type := Null, --用法[|煎法]
  期效_In           药品收发记录.扣率%Type := Null,
  计价特性_In       药品收发记录.扣率%Type := Null,
  简单记帐_In       Number := 0,
  费用类型_In       住院费用记录.费用类型%Type := Null,
  医技补临床费用_In Number := 0,
  领药部门id_In     药品收发记录.对方部门id%Type := Null,
  中药形态_In       住院费用记录.结论%Type := Null,
  医疗小组id_In     住院费用记录.医疗小组id%Type := -1,
  备货材料_In       Number := 0,
  批次_In           药品收发记录.批次%Type := Null
) As
  --功能：新收一张住院记帐单据
  --参数：
  --   药品摘要_IN:存放医嘱中的附加说明或修改保存新单据时用。目前仅用于存放于药品收发记录的摘要中。
  --         原单据(记录状态=2)记录修改产生的新单据号。
  --         新单据(记录状态=1)记录所修改的原单据号。
  --   划价-是否属于住院划价。
  --   医技补临床费用_in:医技站补费时,如果开单科室为临床科室则划价人和记帐人填写为不同,用于销帐申请时区分填写审核科室
  --   备货材料_IN: 医技站的卫生材料备货处理方式:0-正常记帐单;1-备货材料记帐
  --   批次_In:当备货材料_IN=1时有效.传入指定的卫生材料的批次
  v_费用id 住院费用记录.Id%Type;
  v_优先级 未发药品记录.优先级%Type;

  --药房分批、时价药品--
  ------------------------------------------------------------
  --该游标用于分批药品数量分解
  Cursor c_Stock
  (
    n_Outmode Number,
    n_库房id  药品收发记录.库房id%Type
  ) Is
    Select 库房id, 药品id, 批次, 上次批号, 可用数量, 实际数量, 实际金额, 上次供应商id, 批准文号, 上次产地, 上次生产日期, 灭菌效期, 效期, 零售价, 商品条码, 内部条码
    From 药品库存
    Where 药品id = 收费细目id_In And 库房id = n_库房id And 性质 = 1 And (Nvl(批次, 0) = Nvl(批次_In, 0) Or Nvl(批次_In, 0) = 0) And
          (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate)) And Nvl(可用数量, 0) > 0
    Order By Decode(n_Outmode, 1, 效期, Null), Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0);
  r_Stock c_Stock%RowType;

  --属性
  n_分批 药品规格.药房分批%Type;
  n_时价 收费项目目录.是否变价%Type;
  v_名称 收费项目目录.名称%Type;
  --临时变量
  n_总数量   Number;
  n_当前数量 Number;
  n_总金额   Number;
  n_当前单价 Number;
  --药品收发记录
  n_批次       药品收发记录.批次%Type;
  n_序号       药品收发记录.序号%Type;
  n_扣率       药品收发记录.扣率%Type;
  n_领药部门id 药品收发记录.对方部门id%Type;
  n_供药单位id 药品收发记录.供药单位id%Type;
  v_商品条码   药品收发记录.商品条码%Type;
  v_内部条码   药品收发记录.内部条码%Type;
  d_效期       药品收发记录.效期%Type;
  d_灭菌效期   药品收发记录.灭菌效期%Type;
  d_灭菌日期   药品收发记录.灭菌日期%Type;
  d_生产日期   药品收发记录.生产日期%Type;
  n_虚拟库房id 药品收发记录.库房id%Type;
  v_产地       药品收发记录.产地%Type;
  v_批号       药品收发记录.批号%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_其他出库no 药品收发记录.No%Type;
  n_Aval       药品库存.可用数量%Type;
  v_部门名称   部门表.名称%Type;
  ------------------------------------------------------------
  v_用法       药品收发记录.用法%Type;
  v_煎法       药品收发记录.外观%Type;
  n_单价小数   Number;
  n_医疗小组id 住院费用记录.医疗小组id%Type;
  n_库房id     药品库存.库房id%Type;
  n_修正库房id 药品库存.库房id%Type;
  n_Outmode    Number(1);
  v_Dec        Number;
  v_Count      Number;
  v_Err_Msg    Varchar2(255);
  Err_Item Exception;
  n_出库序号       药品收发记录.序号%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_操作员编号     人员表.编号%Type;
  v_操作员姓名     人员表.姓名%Type;
  v_Temp           Varchar2(255);
Begin
  v_操作员编号 := 操作员编号_In;
  v_操作员姓名 := 操作员姓名_In;
  If v_操作员编号 Is Null Then
    v_Temp := Zl_Identity(1);
    If Not (Nvl(v_Temp, '0') = '0' Or Nvl(v_Temp, '_') = '_') Then
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ';') + 1);
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_操作员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
      v_Temp       := Substr(v_Temp, Instr(v_Temp, ',') + 1);
      v_操作员姓名 := v_Temp;
    End If;
  End If;
  --根据执行库房取虚拟库房ID
  Begin
    Select 虚拟库房id Into n_虚拟库房id From 虚拟库房对照 Where 科室id = 执行部门id_In And Rownum <= 1;
  Exception
    When Others Then
      n_虚拟库房id := 0;
  End;
  If Nvl(批次_In, 0) <> 0 Then
    Select Nvl(Sum(可用数量), 0)
    Into n_Aval
    From 药品库存
    Where 药品id = 收费细目id_In And 批次 = 批次_In And 库房id = 执行部门id_In;
    If n_Aval <= 0 Then
      n_修正库房id := n_虚拟库房id;
    End If;
  End If;

  If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
    If Nvl(n_虚拟库房id, 0) = 0 Then
      Begin
        Select 名称 Into v_Err_Msg From 部门表 Where ID = 执行部门id_In;
      Exception
        When Others Then
          v_Err_Msg := '';
      End;
      v_Err_Msg := '执行部门"' || Nvl(v_Err_Msg, '') || '"未设置虚拟部门,请在卫材参数设置中设置.';
      Raise Err_Item;
    End If;
  End If;
  If Nvl(多病人单_In, 0) = 1 Or Nvl(序号_In, 0) = 1 Then
    --记帐表,全部检查,如果是记帐单只检查第一条,其他不检查
  
    n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
    n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
    If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
      Begin
        Select 审核标志, 状态
        Into n_审核标志, n_住院状态
        From 病案主页
        Where 病人id = Nvl(病人id_In, 0) And 主页id = Nvl(主页id_In, 0);
      Exception
        When Others Then
          n_审核标志 := 0;
          n_住院状态 := 0;
      End;
      If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
        v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
        Raise Err_Item;
      End If;
    
      If n_病人审核方式 = 1 Then
      
        If Nvl(n_审核标志, 0) = 1 Then
          v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
        If Nvl(n_审核标志, 0) = 2 Then
          v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  --领药部门确认规则:
  -- 1.传入 :领药部门ID_IN,直接以传入的为准
  -- 2.领药部门ID_IN=NULL的情况, 如果”开单科室=病人科室”，则填为”病人病区”，如果”开单科室<>病人科室”，则填写为”开单科室”
  If Nvl(领药部门id_In, 0) = 0 Then
    If Nvl(科室id_In, 0) = Nvl(开单部门id_In, 0) Then
      --如果”开单科室=病人科室”，则填为”病人病区”(如果没有入科,即病匹为空这种情况,则以病人科室为准,由于一般这种情况较少(护土开单),因此,这种情况应该不会存在)
      n_领药部门id := Nvl(病区id_In, 0);
      If Nvl(n_领药部门id, 0) = 0 Then
        n_领药部门id := 科室id_In;
      End If;
    Else
      --如果”开单科室<>病人科室”，则填写为”开单科室”
      n_领药部门id := 开单部门id_In;
    End If;
  Else
    n_领药部门id := 领药部门id_In;
  End If;
  --需要检查0这种情况,回为有关联
  If Nvl(n_领药部门id, 0) = 0 Then
    n_领药部门id := Null;
  End If;
  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

  --药品用法煎法分解
  If 用法_In Is Not Null Then
    If Instr(用法_In, '|') > 0 Then
      v_用法 := Substr(用法_In, 1, Instr(用法_In, '|') - 1);
      v_煎法 := Substr(用法_In, Instr(用法_In, '|') + 1);
    Else
      v_用法 := 用法_In;
    End If;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')), Zl_To_Number(Nvl(zl_GetSysParameter(157), '5'))
  Into v_Dec, n_单价小数
  From Dual;

  --住院费用记录
  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
  n_医疗小组id := 医疗小组id_In;

  If Nvl(医疗小组id_In, 0) < 0 Then
    n_医疗小组id := Zl_医疗小组_Get(开单部门id_In, 开单人_In, 病人id_In, 主页id_In, 发生时间_In);
  End If;

  Insert Into 住院费用记录
    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别, 收费细目id,
     计算单位, 保险项目否, 保险大类id, 保险编码, 费用类型, 发药窗口, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额, 统筹金额, 记帐费用, 开单部门id,
     开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 划价人, 操作员编号, 操作员姓名, 记帐单id, 摘要, 是否急诊, 医嘱序号, 结论, 医疗小组id)
  Values
    (v_费用id, 2, No_In, Decode(划价_In, 1, 0, 1), 序号_In, Decode(从属父号_In, 0, Null, 从属父号_In),
     Decode(价格父号_In, 0, Null, 价格父号_In), 多病人单_In, 2, 病人id_In, 主页id_In, Decode(标识号_In, 0, Null, 标识号_In), 姓名_In, 性别_In,
     年龄_In, 床号_In, Decode(病区id_In, 0, Null, 病区id_In), Decode(科室id_In, 0, Null, 科室id_In), 费别_In, 收费类别_In, 收费细目id_In,
     计算单位_In, 保险项目否_In, 保险大类id_In, 保险编码_In, 费用类型_In, Decode(Nvl(简单记帐_In, 0), 0, Null, 收费类别_In), 付数_In, 数次_In, 加班标志_In,
     附加标志_In, 婴儿费_In, 收入项目id_In, 收据费目_In, 标准单价_In, 应收金额_In, 实收金额_In, 统筹金额_In, 1, 开单部门id_In, 开单人_In, 发生时间_In, 登记时间_In,
     执行部门id_In, 0, Decode(划价_In, 1, v_操作员姓名, Decode(医技补临床费用_In, 1, '补临床费', Null)), Decode(划价_In, 1, Null, v_操作员编号),
     Decode(划价_In, 1, Null, v_操作员姓名), 记帐单id_In, 费用摘要_In, 是否急诊_In, 医嘱序号_In, 中药形态_In, n_医疗小组id);

  Select Max(使用限量 - Nvl(已用数量, 0))
  Into n_当前数量
  From 病人审批项目
  Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  If 付数_In * 数次_In <= Nvl(n_当前数量, 0) Then
    Update 病人审批项目
    Set 已用数量 = Nvl(已用数量, 0) + 付数_In * 数次_In
    Where 病人id = 病人id_In And 主页id = 主页id_In And 项目id = 收费细目id_In And Nvl(使用限量, 0) <> 0;
  Elsif Not n_当前数量 Is Null Then
    v_Err_Msg := '第 ' || 序号_In || ' 行输入的数次超过了批准的可用数量' || n_当前数量 || '.'; --简化为不转换,直接以售价单位提示.
    Raise Err_Item;
  End If;

  --相关汇总表的处理
  If Nvl(划价_In, 0) = 0 Then
    --病人余额
    Update 病人余额 Set 费用余额 = Nvl(费用余额, 0) + 实收金额_In Where 病人id = 病人id_In And 类型 = 2 And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 病人余额 (病人id, 类型, 性质, 费用余额, 预交余额) Values (病人id_In, 2, 1, 实收金额_In, 0);
    End If;
  
    --病人未结费用
    Update 病人未结费用
    Set 金额 = Nvl(金额, 0) + 实收金额_In
    Where 病人id = 病人id_In And Nvl(主页id, 0) = Nvl(主页id_In, 0) And Nvl(病人病区id, 0) = Nvl(病区id_In, 0) And
          Nvl(病人科室id, 0) = Nvl(科室id_In, 0) And Nvl(开单部门id, 0) = Nvl(开单部门id_In, 0) And
          Nvl(执行部门id, 0) = Nvl(执行部门id_In, 0) And 收入项目id + 0 = 收入项目id_In And 来源途径 + 0 = 2;
    If Sql%RowCount = 0 Then
      Insert Into 病人未结费用
        (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
      Values
        (病人id_In, 主页id_In, 病区id_In, 科室id_In, 开单部门id_In, 执行部门id_In, 收入项目id_In, 2, 实收金额_In);
    End If;
  End If;

  --药品和卫生材料部分
  v_Count := 0; --@@@
  If 收费类别_In = '4' Then
    --跟踪在用的卫材才处理
    Select 跟踪在用 Into v_Count From 材料特性 Where 材料id = 收费细目id_In;
  End If;
  If 收费类别_In In ('5', '6', '7') Or (收费类别_In = '4' And Nvl(v_Count, 0) = 1) Then
    If 收费类别_In = '4' Then
      Select Nvl(a.在用分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 材料特性 A, 收费项目目录 B
      Where a.材料id = b.Id And b.Id = 收费细目id_In;
    
      --卫材分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(156), 0)) Into n_Outmode From Dual;
    Else
      Select Nvl(a.药房分批, 0), Nvl(b.是否变价, 0), b.名称
      Into n_分批, n_时价, v_名称
      From 药品规格 A, 收费项目目录 B
      Where a.药品id = b.Id And b.Id = 收费细目id_In;
    
      --药品分批出库方式
      Select Zl_To_Number(Nvl(zl_GetSysParameter(150), 0)) Into n_Outmode From Dual;
    End If;
  
    n_总数量 := 付数_In * 数次_In;
    n_总金额 := 0;
    If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
      n_库房id := n_虚拟库房id;
      Open c_Stock(n_Outmode, n_虚拟库房id);
    Else
      If Nvl(n_修正库房id, 0) <> 0 Then
        n_库房id := n_修正库房id;
        Open c_Stock(n_Outmode, n_修正库房id);
      Else
        n_库房id := 执行部门id_In;
        Open c_Stock(n_Outmode, 执行部门id_In);
      End If;
    End If;
  
    While n_总数量 <> 0 Loop
      Fetch c_Stock
        Into r_Stock;
      If c_Stock%NotFound Then
        --第一次就没有库存,分批或时价都不允许(包含备货卫材)。
        --分批药品数量分解不完,也就是库存不足。
        If n_分批 = 1 Or n_时价 = 1 Or (Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4') Then
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行的分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          Else
            If 收费类别_In = '4' Then
              If Nvl(备货材料_In, 0) = 1 And Not (n_分批 = 1 Or n_时价 = 1) Then
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
              Else
                v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价卫生材料"' || v_名称 || '"没有足够的材料库存' || Case
                               When Nvl(备货材料_In, 0) = 0 Then
                                '！'
                               Else
                                ',不能进行备货记帐！'
                             End;
              End If;
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现分批或时价药品"' || v_名称 || '"没有足够的药品库存！';
            End If;
          End If;
          Raise Err_Item;
        End If;
      Elsif (n_分批 = 1 And Nvl(r_Stock.批次, 0) = 0) Or (n_分批 = 0 And Nvl(r_Stock.批次, 0) <> 0) Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        Else
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"的分批属性与库存记录不相符,请检查材料数据的正确性！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"的分批属性与库存记录不相符,请检查药品数据的正确性！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    
      If c_Stock%Found Then
        If Nvl(r_Stock.实际数量, 0) = 0 And (n_总数量 > 0 Or n_时价 = 1) Then
          --实际数量为零时，不正常，不允许出库
          --实际数量不为零，金额为零，可能是正常的零价格管理。
          --负数的情况相当于入库,这种情况应是允许的；但时价需要计算价格，必须要有实际数量。
          Close c_Stock;
          If 医嘱序号_In Is Null Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '第 ' || 序号_In || ' 行药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          Else
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前无库存实际数量，可能存在尚未退料的记录，当前不能出库。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前无库存实际数量，可能存在尚未退药的记录，当前不能出库。';
            End If;
          End If;
          Raise Err_Item;
        End If;
      End If;
    
      --确定本次分解数量
      If n_分批 = 1 Or n_时价 = 1 Then
        --对于不分批的时价只可能分解一次,分解不完上面判断了.它分解是为了计算单价.
        --每次分解取小者,库存不够分解不完在上面判断.
        If n_总数量 <= Nvl(r_Stock.可用数量, 0) Then
          n_当前数量 := n_总数量;
        Else
          n_当前数量 := Nvl(r_Stock.可用数量, 0);
        End If;
        If n_时价 = 1 Then
          n_当前单价 := Round(Nvl(r_Stock.零售价, Nvl(r_Stock.实际金额 / r_Stock.实际数量, 0)), n_单价小数);
        Elsif n_分批 = 1 Then
          n_当前单价 := 标准单价_In;
        End If;
      Else
        --普通药品
        --不管够不够,程序中已根据参数判断
        If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
          If n_总数量 > Nvl(r_Stock.可用数量, 0) Then
            --不分批, 但又是备货卫材方式出库的,则需要检查当前库存是否充足.
            v_Err_Msg := '第 ' || 序号_In || ' 行的卫生材料"' || v_名称 || '"没有足够的材料库存,不能进行备货记帐！';
            Raise Err_Item;
          End If;
        End If;
        n_当前数量 := n_总数量;
        n_当前单价 := 标准单价_In;
      End If;
    
      --药品库存(普通情况可能没有记录)
      If c_Stock%Found Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1
        Returning 可用数量 Into v_Count;

	Zl_药品库存_可用数量异常处理(n_库房id,收费细目id_In,Nvl(r_Stock.批次, 0));

        If n_分批 = 1 Or n_时价 = 1 Then
          If v_Count < 0 Then
            If 收费类别_In = '4' Then
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现卫生材料"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            Else
              v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现药品"' || v_名称 || '"当前库存实际数量不足，当前不能出库，可能是由于网络并发操作引起，请刷新后再试！。';
            End If;
            Raise Err_Item;
          End If;
        End If;
      Elsif n_库房id Is Not Null Then
        --只有不分批非时价药品可能库存不足出库
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = n_库房id And 药品id = 收费细目id_In And Nvl(批次, 0) = 0 And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 可用数量, 商品条码, 内部条码)
          Values
            (n_库房id, 收费细目id_In, 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码);
        End If;

	Zl_药品库存_可用数量异常处理(n_库房id,收费细目id_In,0);
      End If;
    
      If Nvl(备货材料_In, 0) = 1 And 收费类别_In = '4' Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - n_当前数量
        Where 库房id = 执行部门id_In And 药品id = 收费细目id_In And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 商品条码, 内部条码, 效期, 上次批号, 上次产地, 上次供应商id, 上次生产日期, 批准文号)
          Values
            (执行部门id_In, 收费细目id_In, Nvl(r_Stock.批次, 0), 1, -1 * n_当前数量, r_Stock.商品条码, r_Stock.内部条码, r_Stock.效期,
             r_Stock.上次批号, r_Stock.上次产地, r_Stock.上次供应商id, r_Stock.上次生产日期, r_Stock.批准文号);
        End If;
      End If;
    
      --药品收发记录
      n_批次       := Null;
      v_批号       := Null;
      d_效期       := Null;
      v_产地       := Null;
      d_灭菌效期   := Null;
      d_灭菌日期   := Null;
      n_供药单位id := Null;
      d_生产日期   := Null;
      v_批准文号   := Null;
      If c_Stock%Found Then
        n_批次       := r_Stock.批次;
        v_批号       := r_Stock.上次批号;
        d_效期       := r_Stock.效期;
        v_产地       := r_Stock.上次产地;
        n_供药单位id := r_Stock.上次供应商id;
        d_生产日期   := r_Stock.上次生产日期;
        v_批准文号   := r_Stock.批准文号;
        v_商品条码   := r_Stock.商品条码;
        v_内部条码   := r_Stock.内部条码;
      
        --卫材灭菌效期:一次性材料且有效期
        If 收费类别_In = '4' Then
          v_Count := 0;
          Begin
            Select 灭菌效期 Into v_Count From 材料特性 Where Nvl(一次性材料, 0) = 1 And 材料id = 收费细目id_In;
          Exception
            When Others Then
              Null;
          End;
          If Nvl(v_Count, 0) > 0 Then
            d_灭菌效期 := r_Stock.灭菌效期;
            d_灭菌日期 := d_灭菌效期 - v_Count * 30;
          End If;
        End If;
      End If;
    
      Select Nvl(Max(序号), 0) + 1
      Into n_序号
      From 药品收发记录
      Where NO = No_In And 记录状态 = 1 And 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0);
    
      n_扣率 := Null;
      If 期效_In Is Not Null Or 计价特性_In Is Not Null Then
        n_扣率 := Nvl(期效_In, 0) || Nvl(计价特性_In, 0);
      End If;
    
      --分批药品,如果是只使用了一个批次,则要填写付数
      If n_分批 = 1 And n_当前数量 <> 付数_In * 数次_In Then
        v_Count := 1;
      Else
        v_Count := 0;
      End If;
    
      --修改的原单据号存放在摘要中
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
         填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
      Values
        (药品收发记录_Id.Nextval, 1, Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, n_序号, 执行部门id_In,
         n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号, d_效期, Decode(v_Count, 1, 1, 付数_In),
         Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价,
         Round(n_当前单价 * n_当前数量, v_Dec), 药品摘要_In, v_操作员姓名, 登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期,
         d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
    
      --产生其他出库单
      If 收费类别_In = '4' And (Nvl(备货材料_In, 0) = 1 Or Nvl(n_修正库房id, 0) <> 0) Then
        Begin
          Select Max(a.No), Max(a.序号)
          Into v_其他出库no, n_出库序号
          From 药品收发记录 A, 住院费用记录 B
          Where a.费用id = b.Id And a.单据 = 21 And b.No = No_In And b.记录性质 = 2;
        Exception
          When Others Then
            v_其他出库no := Null;
        End;
        If v_其他出库no Is Null Then
          v_其他出库no := Nextno(74, n_虚拟库房id, Null, 1);
        End If;
        If v_其他出库no Is Null Then
          v_Err_Msg := '在生成卫生材料的其他出库单时,获取相关的出库NO有误,请检查出库单的规则是否有误!';
          Raise Err_Item;
        End If;
        If Nvl(科室id_In, 0) <> 0 Then
          Select 名称 Into v_部门名称 From 部门表 Where ID = 科室id_In;
        End If;
        v_Err_Msg := LPad(' ', 4);
        v_Err_Msg := Substr('病人姓名:' || 姓名_In || v_Err_Msg || '性别:' || 性别_In || v_Err_Msg || '年龄' || 年龄_In || v_Err_Msg ||
                            '床号:' || 床号_In || v_Err_Msg || '住院号:' || Nvl(标识号_In, '') || v_Err_Msg || '病人科室:' || v_部门名称, 1,
                            100);
      
        n_出库序号 := Nvl(n_出库序号, 0) + 1;
        Insert Into 药品收发记录
          (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人,
           填制日期, 费用id, 频次, 单量, 用法, 外观, 扣率, 灭菌效期, 灭菌日期, 供药单位id, 生产日期, 批准文号, 商品条码, 内部条码)
        Values
          (药品收发记录_Id.Nextval, 1, 21, v_其他出库no, n_出库序号, n_虚拟库房id, n_领药部门id, 类别id_In, -1, 收费细目id_In, n_批次, v_产地, v_批号,
           d_效期, Decode(v_Count, 1, 1, 付数_In), Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In),
           Decode(v_Count, 1, n_当前数量, n_当前数量 / 付数_In), n_当前单价, Round(n_当前单价 * n_当前数量, v_Dec), v_Err_Msg, v_操作员姓名,
           登记时间_In, v_费用id, 频次_In, 单量_In, v_用法, v_煎法, n_扣率, d_灭菌效期, d_灭菌日期, n_供药单位id, d_生产日期, v_批准文号, v_商品条码, v_内部条码);
      End If;
      v_Err_Msg := '';
      n_总数量  := n_总数量 - n_当前数量;
      n_总金额  := n_总金额 + Round(n_当前数量 * n_当前单价, v_Dec);
    End Loop;
  
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0) And NO = No_In And
          Nvl(库房id, 0) = Nvl(执行部门id_In, 0);
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (Decode(多病人单_In, 1, 10, 9) + Decode(收费类别_In, '4', 16, 0), No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, n_领药部门id,
         执行部门id_In, 登记时间_In, Decode(划价_In, 1, 0, 1), 0);
    End If;
    Zl_Prescription_Type_Zy_Update(No_In, 2, 收费细目id_In, 收费类别_In);
    --可能时价药品的库存金额和数量变化了
    If n_时价 = 1 Then
      --只有一个批次时,直接取该批次的单价
      If n_当前数量 <> 付数_In * 数次_In Then
        n_当前单价 := Round(n_总金额 / (付数_In * 数次_In), n_单价小数);
      End If;
      If n_当前单价 <> 标准单价_In Then
        Close c_Stock;
        If 医嘱序号_In Is Null Then
          If 收费类别_In = '4' Then
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价卫生材料"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          Else
            v_Err_Msg := '第 ' || 序号_In || ' 行的时价药品"' || v_名称 || '"当前计算单价不一致,请重新输入数量计算！';
          End If;
        Else
          --医嘱摆药时是按病人分次计算并提交数据库,因此不同病人使用相同实价药品没有问题。
          --但同一病人同时使用两笔以上相同实价药品则会有问题。
          If 收费类别_In = '4' Then
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价卫生材料"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          Else
            v_Err_Msg := '在处理病人"' || 姓名_In || '"时发现时价药品"' || v_名称 || '"当前计算的单价发生变化。' || Chr(13) || Chr(10) ||
                         '请检查该病人是否同时使用了两笔相同的"' || v_名称 || '"！';
          End If;
        End If;
        Raise Err_Item;
      End If;
    End If;
    Close c_Stock;
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Insert;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_病人医嘱记录_收回
(
  --功能：将指定医嘱超期发送部分收回。如果上次发送没有产生费用，则仅收回医嘱的上次执行时间。
  --参数：
  --      收回量_IN=对西药、中成药为按住院单位的收回量,对中药为收回付数,对其它医嘱为收回总量或次数。
  --      医嘱ID_IN=每条要收回的医嘱记录的ID(明细存储的ID),对成药或配方,不一定包含给药途径或用法煎法(可能为叮嘱而未读取)
  --      上次时间_IN=医嘱超期发送部分收回后应该还原的上次执行时间(严格按频率计算得来),为空时表示被全部收回了。
  --      NO_IN=当收回要产生负数费用记录时，为新生成记录的单据号(供费用及药品使用),当前处理的只是新NO的一部份。
  --            因为药品可能分批,所以序号在处理时取。
  --            如果全是划价单（传入值为：调整划价单），则不产生负数单据，直接修改或删除划价单
  收回量_In     病人医嘱发送.发送数次%Type,
  医嘱id_In     病人医嘱记录.Id%Type,
  上次时间_In   病人医嘱记录.上次执行时间%Type,
  收回时间_In   Date,
  No_In         住院费用记录.No%Type := Null,
  操作员编号_In 人员表.编号%Type := Null,
  操作员姓名_In 人员表.姓名%Type := Null
) Is
  --收回医嘱对应的发送费用明细的剩余数量,按后产生的费用先收回
  --剩余数量没有排开已申请的数量部份，在产生新申请时覆盖原来的申请
  --对药品和卫材，对一个数量，可能存在未执行和已执行部分，需分别填写申请记录，且以未执行优先
  --执行标志=0-未执行,1-已执行；药品的有部分执行，以收发记录中的明细量区分为准；非药品的只优先处理未执行的
  Cursor c_Detail Is
    Select *
    From (With 医嘱费用记录 As (Select Max(Decode(b.记录状态, 2, 0, b.Id)) As 费用id, b.No, Nvl(b.价格父号, b.序号) As 序号, b.收费细目id,
                                 b.病人病区id, Sum(Nvl(b.付数, 1) * b.数次) As 剩余数量, b.收费类别, Max(Nvl(b.执行状态, 0)) As 执行状态, d.跟踪在用,
                                 c.诊疗类别, c.医嘱内容, c.单次用量, Max(b.记录状态) As 记录状态, Max(b.登记时间) As 登记时间, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 材料特性 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.材料id(+) And c.Id = 医嘱id_In And e.医嘱id(+) = b.医嘱序号 And
                                e.收费细目id(+) = b.收费细目id
                          Group By b.No, b.记录性质, Nvl(b.价格父号, b.序号), b.收费细目id, b.病人病区id, b.收费类别, d.跟踪在用, c.诊疗类别, c.医嘱内容,
                                   c.单次用量, e.收费方式
                          Having Sum(Nvl(b.付数, 1) * b.数次) > 0)
           Select 费用id, NO, 序号, 收费细目id, 病人病区id, 收费类别, 跟踪在用, 诊疗类别, 医嘱内容, 单次用量, 剩余数量, Null As 已执行量, Null As 未执行量,
                  执行状态 As 执行标志, 记录状态, 登记时间, 收费方式
           From 医嘱费用记录
           Where 收费类别 Not In ('5', '6', '7') And Not (收费类别 = '4' And Nvl(跟踪在用, 0) = 1)
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 0 As 已执行量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 未执行量, 0 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Mod(b.记录状态, 3) = 1 And b.审核人 Is Null
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0
           Union All
           Select a.费用id, a.No, a.序号, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量,
                  Sum(Nvl(b.付数, 1) * b.实际数量) As 已执行量, 0 As 未执行量, 1 As 执行标志, a.记录状态, Max(a.登记时间) As 登记时间, 收费方式
           From 医嘱费用记录 A, 药品收发记录 B
           Where (a.收费类别 In ('5', '6', '7') Or (a.收费类别 = '4' And Nvl(a.跟踪在用, 0) = 1)) And a.费用id = b.费用id And
                 a.No = b.No And b.单据 In (9, 10, 25, 26) And Not (Mod(b.记录状态, 3) = 1 And b.审核人 Is Null)
           Group By a.费用id, a.No, a.序号, a.记录状态, a.收费细目id, a.病人病区id, a.收费类别, a.跟踪在用, a.诊疗类别, a.医嘱内容, a.单次用量, a.剩余数量, 收费方式
           Having Sum(Nvl(b.付数, 1) * b.实际数量) > 0)
           Order By Decode(诊疗类别, '5', 0, '6', 0, '7', 0, 收费细目id), 执行标志, 登记时间 Desc;


  Cursor c_Applay(v_费用ids Varchar2) Is
    Select a.费用id, b.No, b.序号, a.数量, a.申请时间, a.申请类别
    From 病人费用销帐 A, 住院费用记录 B
    Where a.费用id = b.Id And a.申请部门id = a.审核部门id And a.申请时间 = 收回时间_In And
          a.费用id In (Select * From Table(Cast(f_Num2list(v_费用ids) As Zltools.t_Numlist)))
    Order By NO, 序号;

  --包含指定药品长嘱发送时产生的相关费用及药品/卫材记录信息(因多次发送有多条记录,分批的已在界面禁止)
  --药品医嘱填写了"病人医嘱发送"记录,对应的给药途径不一定填写了的(可能为叮嘱),且NO不同。
  --因为要收回的次数可能包含了多次发送的内容,所以要将多次发送的收发记录都取出来，多次发送时，划价的先收回（修改或删除）
  Cursor c_Drug Is
    Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装, x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量,
           b.Id As 收发id, b.单据, b.药品id, b.对方部门id, b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No,
           a.序号, a.收费细目id, a.执行状态 As 执行标志
    From 住院费用记录 A, 药品收发记录 B, 病人医嘱发送 C, 病人信息 D, 药品规格 X
    Where c.医嘱id = 医嘱id_In And a.No = c.No And a.记录性质 = c.记录性质 And a.记录状态 In (0, 1, 3) And a.医嘱序号 + 0 = 医嘱id_In And
          a.No = b.No And a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And
          a.病人id = d.病人id And b.药品id = x.药品id(+)
    Order By a.记录状态, b.No Desc, b.Id Desc;

  --包含非药长嘱(含给药途径)发送时所产生的费用(因多个收入而有多条记录)
  --对非药医嘱,直接收回指定量,不管多次发送(如果多次发送价格不同,则收回的价格是以最后次的；不然就要根据多个收入依次减收回量)。
  --卫材本身是售价单位，无需住院单位转换
  --非药长嘱都填写了发送记录(除开了叮嘱及护理等级)
  --一天只收一次或一次发送只收一次的项目暂时不支持负数申请
  Cursor c_Other Is
    With 医嘱费用记录 As
     (Select a.No, a.序号, a.记录状态, a.收费细目id, a.Id As 费用id, a.数次 As 剩余数量, Nvl(a.执行状态, 0) As 执行状态, a.医嘱序号, b.发送号,
             c.数量 As 对照数量, Nvl(c.收费方式, 0) As 收费方式, a.收费类别
      From 住院费用记录 A, 病人医嘱发送 B, 病人医嘱计价 C
      Where a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱序号 + 0 = b.医嘱id And b.医嘱id = 医嘱id_In And a.医嘱序号 = c.医嘱id(+) And
            a.收费细目id = c.收费细目id(+))
    Select a.No, a.序号, a.费用id, a.剩余数量, a.收费细目id, a.记录状态, a.执行状态, a.对照数量, a.收费方式, a.收费类别
    From (Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 In (1, 3) And a.发送号 = (Select Max(发送号) From 医嘱费用记录 Where 记录状态 In (1, 3))
           Union All
           Select a.No, a.序号, a.记录状态, a.收费细目id, a.费用id, a.剩余数量, a.对照数量, a.执行状态, a.医嘱序号, a.收费方式, a.收费类别
           From 医嘱费用记录 A
           Where a.记录状态 = 0) A
    Order By a.收费细目id, a.序号, a.记录状态;

  --按序号排序是为了产生新记录时,填写同一收费细目的不同收入项目的价格父号

  --该游标用于处理费用相关汇总表
  Cursor c_Money
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, Sum(Nvl(应收金额, 0)) As 应收金额, Sum(Nvl(实收金额, 0)) As 实收金额
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 1 And NO = No_In And 序号 Between v_Start And v_End
    Group By 病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id;

  --系统参数指定执行后需要自动审核的划价费用：用于非药医嘱，包含对应的药品及卫材费用
  Cursor c_Verify
  (
    v_Start 住院费用记录.序号%Type,
    v_End   住院费用记录.序号%Type
  ) Is
    Select NO, 序号
    From 住院费用记录
    Where 记录性质 = 2 And 记录状态 = 0 And NO = No_In And 价格父号 Is Null And 序号 Between v_Start And v_End;

  Cursor c_Compound
  (
    相关id_In       病人医嘱记录.相关id%Type,
    执行终止时间_In 病人医嘱记录.执行终止时间%Type,
    配药id_In       输液配药记录.Id%Type
  ) Is
    Select b.费用id, b.药品id As 收费细目id, Sum(a.数量) As 数量, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id As 配药id, f.No,
           Nvl(f.价格父号, f.序号) As 序号, f.记录状态 As 记录状态, f.执行状态 As 执行标志
    From 输液配药内容 A, 药品收发记录 B, 药品规格 C, 收费项目目录 D, 输液配药记录 E, 住院费用记录 F
    Where a.收发id = b.Id And b.药品id = c.药品id And c.药品id = d.Id And e.Id = a.记录id And f.No = b.No And f.Id = b.费用id And
          e.医嘱id = 相关id_In And e.执行时间 > 执行终止时间_In And e.Id = 配药id_In
    Group By b.费用id, b.药品id, c.住院包装, c.住院单位, d.名称, e.病人病区id, e.操作状态, e.Id, f.No, f.价格父号, f.序号, f.记录状态, f.执行状态;

  v_Dec      Number;
  v_First    Number;
  v_划价类别 Varchar2(255);

  v_诊疗类别 病人医嘱记录.诊疗类别%Type;
  v_单次用量 病人医嘱记录.单次用量%Type;
  v_跟踪在用 材料特性.跟踪在用%Type;

  v_费用序号 住院费用记录.序号%Type;
  v_收发序号 药品收发记录.序号%Type;
  v_费用id   住院费用记录.Id%Type;
  v_实收金额 住院费用记录.实收金额%Type;

  v_开始序号 住院费用记录.序号%Type;
  v_结束序号 住院费用记录.序号%Type;

  v_医嘱执行 病人医嘱发送.执行状态%Type;

  v_剂量系数 药品规格.剂量系数%Type;
  v_住院包装 药品规格.住院包装%Type;
  v_医嘱内容 病人医嘱记录.医嘱内容%Type;

  v_结帐参数       Zlparameters.参数值%Type;
  v_配液药销帐申请 Zlparameters.参数值%Type;
  v_结帐金额       住院费用记录.结帐金额%Type;

  v_收费细目id   住院费用记录.收费细目id%Type;
  v_剩余数量     住院费用记录.数次%Type;
  v_收回数量     住院费用记录.数次%Type;
  v_当前数量     住院费用记录.数次%Type;
  v_当前付数     住院费用记录.付数%Type;
  v_费用ids      Varchar2(4000);
  v_组id         病人医嘱记录.Id%Type;
  v_对照数量     病人医嘱计价.数量%Type;

  v_Delno    Varchar2(4000);
  v_Temp     Varchar2(4000);
  v_收费内容 Varchar2(4000);
  v_No       住院费用记录.No%Type;
  v_人员编号 住院费用记录.操作员编号%Type;
  v_人员姓名 住院费用记录.操作员姓名%Type;

  n_相关id       病人医嘱记录.相关id%Type;
  d_执行终止时间 病人医嘱记录.执行终止时间%Type;
  n_药品id       病人医嘱记录.收费细目id%Type;
  b_输液配药记录 Boolean;
  d_收回时间     病人医嘱记录.执行终止时间%Type;
  n_申请类别     病人费用销帐.申请类别%Type;
  n_Count        Number;

  v_Error Varchar2(255);
  Err_Custom Exception;

  Procedure 负数收发记录_Insert
  (
    费用id_In     Number,
    批次_In       药品收发记录.批次%Type,
    分批_In       药品规格.药房分批%Type,
    批号_In       药品收发记录.批号%Type,
    效期_In       药品收发记录.效期%Type,
    最大效期_In   药品规格.最大效期%Type,
    收发id_In     药品收发记录.Id%Type,
    病人id_In     住院费用记录.病人id%Type,
    主页id_In     住院费用记录.主页id%Type,
    药品id_In     药品收发记录.药品id%Type,
    库房id_In     药品收发记录.库房id%Type,
    单据_In       药品收发记录.单据%Type,
    姓名_In       病人信息.姓名%Type,
    对方部门id_In 药品收发记录.对方部门id%Type,
    收费类别_In   住院费用记录.收费类别%Type,
    划价类别_In   Varchar
  ) Is
    v_批次   药品收发记录.批次%Type;
    v_效期   药品收发记录.效期%Type;
    v_批号   药品收发记录.批号%Type;
    v_优先级 身份.优先级%Type;
  Begin
    --确定批次
    If Nvl(批次_In, 0) <> 0 And 分批_In = 0 Then
      --原分批,现不分批
      v_批次 := Null;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    Elsif Nvl(批次_In, 0) = 0 And 分批_In = 1 Then
      --原不分批,现分批
      Select 药品收发记录_Id.Nextval Into v_批次 From Dual;
      Select To_Char(Sysdate, 'YYYYMMDD') Into v_批号 From Dual;
      If 最大效期_In Is Not Null Then
        v_效期 := Trunc(Sysdate + 最大效期_In * 30);
      Else
        v_效期 := Null;
      End If;
    Else
      v_批次 := 批次_In;
      v_批号 := 批号_In;
      v_效期 := 效期_In;
    End If;
  
    Insert Into 药品收发记录
      (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 零售价, 零售金额, 摘要, 填制人, 填制日期,
       费用id, 单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期)
      Select 药品收发记录_Id.Nextval, 1, 单据, No_In, v_收发序号, 库房id, 对方部门id, 入出类别id, -1, 药品id, v_批次, 产地, v_批号, v_效期, v_当前付数,
             -1 * v_当前数量, -1 * v_当前数量, 零售价, Round(-1 * v_当前付数 * v_当前数量 * 零售价, v_Dec), '超期发送收回', v_人员姓名, 收回时间_In, 费用id_In,
             单量, 频次, 用法, 供药单位id, 生产日期, 批准文号, 灭菌效期
      From 药品收发记录
      Where ID = 收发id_In;
  
    --药品库存
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - (-1 * v_当前付数 * v_当前数量)
    Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = Nvl(v_批次, 0) And 性质 = 1;
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 性质, 可用数量, 批次, 效期)
      Values
        (库房id_In, 药品id_In, 1, v_当前付数 * v_当前数量, v_批次, v_效期);
    End If;
    
    Zl_药品库存_可用数量异常处理(库房id_In, 药品id_In, v_批次);
    
    --未发药品记录
    Update 未发药品记录
    Set 病人id = 病人id_In, 主页id = 主页id_In, 姓名 = 姓名_In
    Where 单据 = 单据_In And NO = No_In And 库房id + 0 = 库房id_In;
  
    If Sql%RowCount = 0 Then
      --取身份优先级
      Begin
        Select b.优先级 Into v_优先级 From 病人信息 A, 身份 B Where a.身份 = b.名称(+) And a.病人id = 病人id_In;
      Exception
        When Others Then
          Null;
      End;
    
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 填制日期, 已收费, 打印状态)
      Values
        (单据_In, No_In, 病人id_In, 主页id_In, 姓名_In, v_优先级, 对方部门id_In, 库房id_In, 收回时间_In,
         Decode(Nvl(Instr(划价类别_In, Decode(收费类别_In, '4', '4', '5')), 0), 0, 1, 0), 0);
    End If;
  
    v_收发序号 := v_收发序号 + 1;
  End;
Begin
  --取操作员信息(部门ID,部门名称;人员ID,人员编号,人员姓名)
  If 操作员编号_In Is Not Null And 操作员姓名_In Is Not Null Then
    v_人员编号 := 操作员编号_In;
    v_人员姓名 := 操作员姓名_In;
  Else
    v_Temp     := Zl_Identity;
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ';') + 1);
    v_Temp     := Substr(v_Temp, Instr(v_Temp, ',') + 1);
    v_人员编号 := Substr(v_Temp, 1, Instr(v_Temp, ',') - 1);
    v_人员姓名 := Substr(v_Temp, Instr(v_Temp, ',') + 1);
  End If;
  --检查是否是输液配液记录，并是否已经锁定
  Select 医嘱内容 Into v_医嘱内容 From 病人医嘱记录 Where ID = 医嘱id_In;
  Select Count(1)
  Into n_Count
  From 输液配药记录 A, 病人医嘱记录 B
  Where a.医嘱id = b.Id And 医嘱id = 医嘱id_In And a.执行时间 > b.执行终止时间 And a.是否锁定 = 1;

  If n_Count > 0 Then
    v_Error := '医嘱"' || v_医嘱内容 || '"是输液药品，已经被输液配置中心锁定，不能超期收回。';
    Raise Err_Custom;
  End If;

  If Nvl(收回量_In, 0) > 0 Then
    --判断是否是输液配药药品(输液配制中心药品统一走销帐申请)
    b_输液配药记录 := False;
    Select a.相关id, a.执行终止时间, Max(b.收费细目id)
    Into n_相关id, d_执行终止时间, n_药品id
    From 病人医嘱记录 A, 住院费用记录 B
    Where a.Id = 医嘱id_In And a.Id = b.医嘱序号(+)
    Group By a.相关id, a.执行终止时间;
    If n_相关id Is Not Null Then
      If d_执行终止时间 Is Not Null Then
        d_收回时间       := 收回时间_In;
        v_配液药销帐申请 := zl_GetSysParameter('配液输液单配药后允许销帐申请', 1345);
        Select Count(1) Into n_Count From 输液配药记录 E Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间;
        If n_Count > 0 Then
          b_输液配药记录 := True;
          For X In (Select e.Id As 配药id, e.操作状态
                    From 输液配药记录 E
                    Where e.医嘱id = n_相关id And e.执行时间 > d_执行终止时间 And Nvl(e.操作状态, 0) In (1, 2, 3, 4, 5, 6, 7, 8)) Loop
            If Not (x.操作状态 In (4, 5, 6, 7, 8) And Nvl(v_配液药销帐申请, '0') = '0') Then
              For r_Compound In c_Compound(n_相关id, d_执行终止时间, x.配药id) Loop
                If x.操作状态 = 1 Then
                  n_申请类别 := 0;
                Else
                  n_申请类别 := 1;
                End If;
                Select Count(1)
                Into n_Count
                From 病人费用销帐
                Where 费用id = r_Compound.费用id And 收费细目id = r_Compound.收费细目id And
                      申请时间 =
                      (Select Max(操作时间) From 输液配药状态 A Where a.配药id = r_Compound.配药id And a.操作类型 = 9);
                If n_Count = 0 Then
                  Zl_病人费用销帐_Insert(r_Compound.费用id, r_Compound.收费细目id, r_Compound.病人病区id, r_Compound.数量, v_人员姓名, d_收回时间,
                                   n_申请类别, Null, r_Compound.配药id);
                  If x.操作状态 = 1 Then
                    --未发药的，自动审核。
                    Zl_病人费用销帐_Audit(r_Compound.费用id, d_收回时间, v_人员姓名, d_收回时间, 1, 1, n_申请类别);
                    Zl_住院记帐记录_Delete(r_Compound.No, r_Compound.序号 || ':' || r_Compound.数量 || ':' || r_Compound.配药id,
                                     v_人员编号, v_人员姓名, 2, Null, Null, d_收回时间);
                  End If;
                End If;
              End Loop;
              --由于不同批次（执行时间）申请时，申请时间和费用ID有唯一约束，所以同时销帐多个批次时，依次加一秒
              d_收回时间 := d_收回时间 + 1 / 24 / 60 / 60;
            End If;
          End Loop;
        End If;
      End If;
    End If;
    --a.销帐申请收回模式
    --输液配药记录单独进行销帐
    If b_输液配药记录 = False Then
      If No_In Is Null Then
        v_结帐参数 := zl_GetSysParameter(23);
        --根据收回数量对照原始费用进行分摊申请
        For r_Detail In c_Detail Loop
          --确定该收费细目ID的收回总数量
          If Nvl(v_收费细目id, 0) <> r_Detail.收费细目id And (r_Detail.诊疗类别 Not In ('5', '6', '7') Or Nvl(v_收费细目id, 0) = 0) Then
            --数量未分摊完成
            If v_收费细目id Is Not Null And v_收回数量 > 0 Then
              v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
              Raise Err_Custom;
            End If;
            --药品收回总量是以最后发送规格为准计算的，以此计算出收回售价数量
            Begin
              Select 剂量系数, 住院包装 Into v_剂量系数, v_住院包装 From 药品规格 Where 药品id = r_Detail.收费细目id;
            Exception
              When Others Then
                Null;
            End;
            --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
            If r_Detail.收费方式 = 0 Then
              If r_Detail.诊疗类别 = '7' Then
                --中药配方药品：付数*单量
                v_收回数量 := Round(收回量_In * r_Detail.单次用量 / Nvl(v_剂量系数, 1), 5);
              Else
                If r_Detail.诊疗类别 Not In ('5', '6') Then
                  Select Nvl(Max(数量), 1)
                  Into v_对照数量
                  From 病人医嘱计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id;
                Else
                  v_对照数量 := 1;
                End If;
                v_收回数量 := Round(收回量_In * Nvl(v_住院包装, 1), 5) * v_对照数量;
              End If;
            Else
              Select Nvl(Sum(数量), 0)
              Into v_收回数量
              From 医嘱执行计价
              Where 医嘱id = 医嘱id_In And 收费细目id = r_Detail.收费细目id And
                    要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
            
              v_收回数量 := Round(v_收回数量, 5);
            
            End If;
            v_医嘱内容 := r_Detail.医嘱内容;
          End If;
        
          --该收费细目的每个费用明细分摊收回
          If v_收回数量 > 0 Then
            --检查对应费用是否已结帐，当禁止时
            v_结帐金额 := 0;
            If v_结帐参数 = '2' And r_Detail.记录状态 <> 0 Then
              Select Sum(结帐金额)
              Into v_结帐金额
              From 住院费用记录
              Where NO = r_Detail.No And 记录性质 In (2, 12) And Nvl(价格父号, 序号) = r_Detail.序号;
            End If;
          
            If Nvl(v_结帐金额, 0) = 0 Then
              If r_Detail.收费类别 In ('5', '6', '7') Or r_Detail.收费类别 = '4' And r_Detail.跟踪在用 = 1 Then
                --药品和跟踪在用的卫材
                If r_Detail.执行标志 = 0 Then
                  v_剩余数量 := r_Detail.未执行量;
                Elsif r_Detail.执行标志 = 1 Then
                  v_剩余数量 := r_Detail.已执行量;
                End If;
              Else
                --普通费用
                v_剩余数量 := r_Detail.剩余数量;
              End If;
              If v_收回数量 > v_剩余数量 Then
                v_当前数量 := v_剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              --系统参数决定执行后是否审核划价单，所以，已执行的仍然可能是划价单
              If r_Detail.执行标志 = 0 And r_Detail.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Detail.No || ',' || r_Detail.序号 || ':' || v_当前数量;
              Else
                If Not (r_Detail.收费类别 = '7' And r_Detail.执行标志 <> 0) Then
                  Zl_病人费用销帐_Insert(r_Detail.费用id, r_Detail.收费细目id, r_Detail.病人病区id, v_当前数量, v_人员姓名, 收回时间_In,
                                   r_Detail.执行标志);
                End If;
              End If;
              v_费用ids := v_费用ids || ',' || r_Detail.费用id;
            End If;
          End If;
          v_收费细目id := r_Detail.收费细目id;
        End Loop;
      
        --数量未分摊完成
        If v_收回数量 > 0 Then
          v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能存在手工销帐或已结帐的费用，或相应的划价单已被删除。';
          Raise Err_Custom;
        End If;
        --本科的销帐申请自动审核
        If zl_GetSysParameter('超期收回费用本科自动审核', 1254) = '1' And v_费用ids Is Not Null Then
          For r_Applay In c_Applay(Substr(v_费用ids, 2)) Loop
            Zl_病人费用销帐_Audit(r_Applay.费用id, r_Applay.申请时间, v_人员姓名, 收回时间_In, 1, 1, r_Applay.申请类别);
            v_Delno := v_Delno || '|' || r_Applay.No || ',' || r_Applay.序号 || ':' || r_Applay.数量;
          End Loop;
        End If;
      Else
        ---b.负数收回模式-------------------------------------------------------------------------------------------------------
        --如果全是划价单，就不用产生负数冲销单据
        If No_In = '调整划价单' Then
          --未审核的划价单，先进行修改或删除，可能多次发送为不同的NO,为了计算每次的收回量，需要按收费细目ID排序
          For r_Price In (Select c.诊疗类别, b.No, b.序号, b.收费细目id, Nvl(b.付数, 1) * b.数次 As 剩余数量, c.单次用量, d.剂量系数, d.住院包装,
                                 c.医嘱内容, Nvl(e.收费方式, 0) As 收费方式
                          From 病人医嘱发送 A, 住院费用记录 B, 病人医嘱记录 C, 药品规格 D, 病人医嘱计价 E
                          Where a.医嘱id = 医嘱id_In And a.No = b.No And a.记录性质 = b.记录性质 And a.医嘱id = b.医嘱序号 And
                                b.价格父号 Is Null And b.收费细目id = d.药品id(+) And b.记录状态 = 0 And c.Id = a.医嘱id And
                                b.医嘱序号 = e.医嘱id(+) And b.收费细目id = e.收费细目id(+)
                          Order By 收费细目id, NO Desc) Loop
            If Nvl(v_收费细目id, 0) <> r_Price.收费细目id Then
              --数量未分摊完成
              If v_收费细目id Is Not Null And v_收回数量 > 0 Then
                v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
                Raise Err_Custom;
              End If;
              --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
              If r_Price.收费方式 = 0 Then
                If r_Price.诊疗类别 = '7' Then
                  --中药配方药品：付数*单量
                  v_收回数量 := Round(收回量_In * r_Price.单次用量 / Nvl(r_Price.剂量系数, 1), 5);
                Else
                  If r_Price.诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(收回量_In * Nvl(r_Price.住院包装, 1), 5) * v_对照数量;
                End If;
              Else
                Select Nvl(Sum(数量), 0)
                Into v_收回数量
                From 医嘱执行计价
                Where 医嘱id = 医嘱id_In And 收费细目id = r_Price.收费细目id And
                      要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
              
                v_收回数量 := Round(v_收回数量, 5);
              End If;
              v_医嘱内容 := r_Price.医嘱内容;
            End If;
            If v_收回数量 > 0 Then
              If v_收回数量 > r_Price.剩余数量 Then
                v_当前数量 := r_Price.剩余数量;
              Else
                v_当前数量 := v_收回数量;
              End If;
              v_收回数量 := v_收回数量 - v_当前数量;
              v_Delno    := v_Delno || '|' || r_Price.No || ',' || r_Price.序号 || ':' || v_当前数量;
            End If;
            v_收费细目id := r_Price.收费细目id;
          End Loop;
          --数量未分摊完成
          If v_收回数量 > 0 Then
            v_Error := '医嘱"' || v_医嘱内容 || '"对应的费用剩余数量不足收回数量，可能相关划价单已被删除或审核。';
            Raise Err_Custom;
          End If;
        Else
          --负数冲销，可能存在划价单与记帐单混合的情况
          --金额小数位数
          Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;
          --生成划价单系统参数
          Select zl_GetSysParameter(80) Into v_划价类别 From Dual;
          v_开始序号 := Null;
          v_结束序号 := Null;
        
          Select a.诊疗类别, a.单次用量, b.跟踪在用
          Into v_诊疗类别, v_单次用量, v_跟踪在用
          From 病人医嘱记录 A, 材料特性 B
          Where ID = 医嘱id_In And a.收费细目id = b.材料id(+);
        
          If v_诊疗类别 In ('5', '6', '7') Or (v_诊疗类别 = '4' And Nvl(v_跟踪在用, 0) = 1) Then
            --药品、卫材
            -----------------------------------------------------------------------------------------------------
            v_收回数量 := Null;
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            --一条医嘱的药品只有一行，这里的循环是为了处理多次发送的情况，分批药品在界面已禁用负数收回
            For r_Drug In c_Drug Loop
              --初始化要收回的总数量(零售数量)
              v_First := 0;
              If v_收回数量 Is Null Then
                If v_诊疗类别 = '7' Then
                  v_收回数量 := Round(收回量_In * v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  If v_诊疗类别 Not In ('5', '6') Then
                    Select Nvl(Max(数量), 1)
                    Into v_对照数量
                    From 病人医嘱计价
                    Where 医嘱id = 医嘱id_In And 收费细目id = r_Drug.收费细目id;
                  Else
                    v_对照数量 := 1;
                  End If;
                  v_收回数量 := Round(收回量_In * r_Drug.住院包装, 5) * v_对照数量;
                End If;
                v_First := 1;
              End If;
            
              --如果第一次数量就足够，则按付数处理，否则付数不好处理
              If v_收回数量 > r_Drug.数量 Then
                v_当前付数 := 1;
                v_当前数量 := r_Drug.数量;
                v_收回数量 := v_收回数量 - r_Drug.数量;
              Else
                If v_First = 1 And v_诊疗类别 = '7' Then
                  v_当前付数 := 收回量_In;
                  v_当前数量 := Round(v_单次用量 / r_Drug.剂量系数, 5);
                Else
                  v_当前付数 := 1;
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := 0;
              End If;
            
              If r_Drug.记录状态 = 0 Then
                v_Delno := v_Delno || '|' || r_Drug.No || ',' || r_Drug.序号 || ':' || v_当前数量 * v_当前付数;
              Else
                If Not (v_诊疗类别 = '7' And r_Drug.执行标志 <> 0) Then
                
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  负数收发记录_Insert(v_费用id, r_Drug.批次, r_Drug.分批, r_Drug.批号, r_Drug.效期, r_Drug.最大效期, r_Drug.收发id,
                                r_Drug.病人id, r_Drug.主页id, r_Drug.药品id, r_Drug.库房id, r_Drug.单据, r_Drug.姓名, r_Drug.对方部门id,
                                v_诊疗类别, v_划价类别);
                
                  --住院费用记录
                  -------------------------------------------------------------------------------------
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, 1, 0),
                           v_费用序号, Null, Null, 多病人单, 2, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id, 费别, 收费类别,
                           收费细目id, 计算单位, 保险项目否, 保险大类id, v_当前付数, -1 * v_当前数量, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价,
                           Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Round(-1 * v_当前付数 * v_当前数量 * 标准单价, v_Dec), Null, 1,
                           开单部门id, 开单人, 收回时间_In, 收回时间_In, 执行部门id, 0, 医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, Decode(v_诊疗类别, '4', '4', '5')), 0), 0, v_人员姓名, Null)
                    From 住院费用记录
                    Where ID = r_Drug.费用id;
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                End If;
                If v_收回数量 <= 0 Then
                  Exit;
                End If;
              End If;
            End Loop;
          
            If v_收回数量 <> 0 Then
              --没有收回所有数量,收发记录本身有问题(如记录不全或数量为负)
              Null;
            End If;
          Else
            --其它非药医嘱(包括给药途径，及绑定的卫材等)
            -----------------------------------------------------------------------------------------------------
            Select Nvl(Max(序号), 0) + 1
            Into v_收发序号
            From 药品收发记录
            Where 单据 In (9, 10, 25, 26) And 记录状态 = 1 And NO = No_In;
            --取费用序号
            Select Nvl(Max(序号), 0) + 1
            Into v_费用序号
            From 住院费用记录
            Where 记录性质 = 2 And 记录状态 In (0, 1) And NO = No_In;
          
            For r_Other In c_Other Loop
              If Nvl(v_收费内容, '0') <> r_Other.收费细目id || ',' || r_Other.序号 Then
                --根据最近一次发送的费用记录，按需要收回的数量全部收回
                --计算收回数量，如果收费方式不是0正常收取，则使用特殊的方法进行计算
                If r_Other.收费方式 = 0 Then
                  v_收回数量 := 收回量_In * Nvl(r_Other.对照数量, 1);
                Else
                  Select Nvl(Sum(数量), 0)
                  Into v_收回数量
                  From 医嘱执行计价
                  Where 医嘱id = 医嘱id_In And 收费细目id = r_Other.收费细目id And
                        要求时间 > Nvl(上次时间_In, To_Date('1900-01-01', 'yyyy-MM-dd'));
                End If;
              End If;
            
              If v_收回数量 > 0 Then
                If r_Other.记录状态 = 0 Then
                  If v_收回数量 > r_Other.剩余数量 Then
                    v_当前数量 := r_Other.剩余数量;
                  Else
                    v_当前数量 := v_收回数量;
                  End If;
                Else
                  v_当前数量 := v_收回数量;
                End If;
                v_收回数量 := v_收回数量 - v_当前数量;
                v_当前付数 := 1;
              
                If r_Other.记录状态 = 0 Then
                  v_Delno := v_Delno || '|' || r_Other.No || ',' || r_Other.序号 || ':' || v_当前数量;
                Else
                  --记录序号范围以处理汇总表
                  If v_开始序号 Is Null Then
                    v_开始序号 := v_费用序号;
                  End If;
                  v_结束序号 := v_费用序号;
                
                  --住院费用记录:按理如果收回量大于了上次发送量,则不正确
                  Select 病人费用记录_Id.Nextval Into v_费用id From Dual;
                  If r_Other.收费类别 In ('4', '5', '6', '7') Then
                    For r_Otherdrug In (Select a.病人id, a.主页id, d.姓名, Nvl(x.剂量系数, 1) As 剂量系数, Nvl(x.住院包装, 1) As 住院包装,
                                               x.最大效期, Nvl(b.付数, 1) * b.实际数量 As 数量, b.Id As 收发id, b.单据, b.药品id, b.对方部门id,
                                               b.库房id, b.费用id, Nvl(x.药房分批, 0) As 分批, b.批次, b.批号, b.效期, a.记录状态, a.No, a.序号,
                                               a.收费细目id
                                        From 住院费用记录 A, 药品收发记录 B, 病人信息 D, 药品规格 X
                                        Where a.Id = r_Other.费用id And a.记录状态 In (0, 1, 3) And a.No = b.No And
                                              a.Id = b.费用id + 0 And b.单据 In (9, 10, 25, 26) And
                                              (b.记录状态 = 1 Or Mod(b.记录状态, 3) = 0) And a.病人id = d.病人id And
                                              b.药品id = x.药品id(+)
                                        Order By a.记录状态, b.No Desc, b.Id Desc) Loop
                      负数收发记录_Insert(v_费用id, r_Otherdrug.批次, r_Otherdrug.分批, r_Otherdrug.批号, r_Otherdrug.效期,
                                    r_Otherdrug.最大效期, r_Otherdrug.收发id, r_Otherdrug.病人id, r_Otherdrug.主页id,
                                    r_Otherdrug.药品id, r_Otherdrug.库房id, r_Otherdrug.单据, r_Otherdrug.姓名,
                                    r_Otherdrug.对方部门id, r_Other.收费类别, v_划价类别);
                    End Loop;
                  End If;
                  --医嘱已执行，收回的费用也填为已执行：不包含药品和跟踪在用的卫材，因为实际发放表示执行
                  Insert Into 住院费用记录
                    (ID, 记录性质, NO, 记录状态, 序号, 从属父号, 价格父号, 多病人单, 门诊标志, 病人id, 主页id, 标识号, 姓名, 性别, 年龄, 床号, 病人病区id, 病人科室id,
                     费别, 收费类别, 收费细目id, 计算单位, 保险项目否, 保险大类id, 付数, 数次, 加班标志, 附加标志, 婴儿费, 收入项目id, 收据费目, 标准单价, 应收金额, 实收金额,
                     统筹金额, 记帐费用, 开单部门id, 开单人, 发生时间, 登记时间, 执行部门id, 执行状态, 执行时间, 执行人, 医嘱序号, 划价人, 操作员编号, 操作员姓名)
                    Select v_费用id, 2, No_In, Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, 1, 0), v_费用序号, Null,
                           Decode(a.价格父号, Null, Null, v_费用序号 + a.价格父号 - a.序号), a.多病人单, 2, a.病人id, a.主页id, a.标识号, a.姓名,
                           a.性别, a.年龄, a.床号, a.病人病区id, a.病人科室id, a.费别, a.收费类别, a.收费细目id, a.计算单位, a.保险项目否, a.保险大类id, 1,
                           -1 * v_当前数量, a.加班标志, a.附加标志, a.婴儿费, a.收入项目id, a.收据费目, a.标准单价,
                           Round(-1 * v_当前数量 * a.标准单价, v_Dec), Round(-1 * v_当前数量 * a.标准单价, v_Dec), Null, 1, a.开单部门id,
                           a.开单人, 收回时间_In, 收回时间_In, a.执行部门id,
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, 0, 1), Decode(Instr(',5,6,7,', a.收费类别), 0, 1, 0)),
                                   0),
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, 收回时间_In),
                                           Decode(Instr(',5,6,7,', a.收费类别), 0, 收回时间_In, Null)), Null),
                           Decode(r_Other.执行状态, 1,
                                   Decode(a.收费类别, '4', Decode(b.跟踪在用, 1, Null, v_人员姓名),
                                           Decode(Instr(',5,6,7,', a.收费类别), 0, v_人员姓名, Null)), Null), a.医嘱序号, v_人员姓名,
                           Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员编号, Null),
                           Decode(Nvl(Instr(v_划价类别, r_Other.收费类别), 0), 0, v_人员姓名, Null)
                    From 住院费用记录 A, 材料特性 B
                    Where a.Id = r_Other.费用id And a.收费细目id = b.材料id(+);
                
                  Select Zl_Actualmoney(费别, 收费细目id, 收入项目id, 应收金额, 数次, 执行部门id)
                  Into v_Temp
                  From 住院费用记录
                  Where ID = v_费用id;
                  v_实收金额 := Round(Substr(v_Temp, Instr(v_Temp, ':') + 1), v_Dec);
                  Update 住院费用记录 A Set 实收金额 = v_实收金额 Where ID = v_费用id;
                
                  v_费用序号 := v_费用序号 + 1;
                  v_医嘱执行 := r_Other.执行状态; --多个收费项目的执行状态是一样的
                End If;
              
                v_收费内容 := r_Other.收费细目id || ',' || r_Other.序号;
              End If;
            End Loop;
          
            --如果医嘱已执行，则按系统参数执行后自动审核费用：包含已执行医嘱对应的药品和卫材费用。
            -----------------------------------------------------------------------------------------------------
            If Nvl(v_医嘱执行, 0) = 1 And v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
              If zl_GetSysParameter(81) = '1' Then
                For r_Verify In c_Verify(v_开始序号, v_结束序号) Loop
                  Zl_住院记帐记录_Verify(r_Verify.No, v_人员编号, v_人员姓名, r_Verify.序号, Null, 收回时间_In);
                End Loop;
              End If;
            End If;
          End If;
        
          --处理费用汇总表
          -----------------------------------------------------------------------------------------------------
          If v_开始序号 Is Not Null And v_结束序号 Is Not Null Then
            --最后统一处理费用相关汇总表
            For r_Money In c_Money(v_开始序号, v_结束序号) Loop
              --病人余额
              Update 病人余额
              Set 费用余额 = Nvl(费用余额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 性质 = 1 And 类型 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人余额
                  (病人id, 性质, 类型, 费用余额, 预交余额)
                Values
                  (r_Money.病人id, 1, 2, r_Money.实收金额, 0);
              End If;
            
              --病人未结费用
              Update 病人未结费用
              Set 金额 = Nvl(金额, 0) + r_Money.实收金额
              Where 病人id = r_Money.病人id And 主页id = r_Money.主页id And Nvl(病人病区id, 0) = Nvl(r_Money.病人病区id, 0) And
                    Nvl(病人科室id, 0) = Nvl(r_Money.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Money.开单部门id, 0) And
                    Nvl(执行部门id, 0) = Nvl(r_Money.执行部门id, 0) And 收入项目id + 0 = r_Money.收入项目id And 来源途径 + 0 = 2;
            
              If Sql%RowCount = 0 Then
                Insert Into 病人未结费用
                  (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
                Values
                  (r_Money.病人id, r_Money.主页id, r_Money.病人病区id, r_Money.病人科室id, r_Money.开单部门id, r_Money.执行部门id,
                   r_Money.收入项目id, 2, r_Money.实收金额);
              End If;
            End Loop;
          End If;
        End If;
      End If;
    End If;
  End If;

  --过程Zl_住院记帐记录_Delete，不支持每次删除一行的循环处理（序号重整），必须把一个单据要删除的序号一次性传入
  If Not v_Delno Is Null Then
    v_Temp := '';
    v_No   := '';
    For r_Price In (Select /*+ rule*/
                     C1 As NO, C2 As 序号数量
                    From Table(f_Str2list2(Substr(v_Delno, 2), '|', ','))
                    Order By NO) Loop
      If v_No Is Not Null And v_No <> r_Price.No Then
        Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
        v_No := '';
      End If;
      If v_No Is Null Then
        v_No   := r_Price.No;
        v_Temp := r_Price.序号数量;
      Else
        v_Temp := v_Temp || ',' || r_Price.序号数量;
      End If;
    End Loop;
    If Not v_No Is Null Then
      Zl_住院记帐记录_Delete(v_No, v_Temp, v_人员编号, v_人员姓名, 2);
    End If;
  End If;

  --处理医嘱的上次执行时间:给药途径等可能因为未发送而没调用收回过程。
  -----------------------------------------------------------------------------------------------------
  Select Nvl(相关id, ID) Into v_组id From 病人医嘱记录 Where ID = 医嘱id_In;
  Update 病人医嘱记录 Set 上次执行时间 = 上次时间_In Where ID = v_组id Or 相关id = v_组id;

  --删除医嘱执行时间
  If 上次时间_In Is Null Then
    --全部收回
    Delete From 医嘱执行时间 Where 医嘱id = v_组id;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In;
  Else
    --可能收回多次发送的数据
    Delete From 医嘱执行时间 Where 医嘱id = v_组id And 要求时间 > 上次时间_In;
    Delete From 医嘱执行计价 Where 医嘱id = 医嘱id_In And 要求时间 > 上次时间_In;
  End If;
  --处理输液配液记录的批次问题，每个医嘱都进行调用，在过程里面只处理了输液配液的医嘱
  Zl_输液配药记录_批次调整(医嘱id_In);

Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_病人医嘱记录_收回;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_不发药处方标记_Checked
(
  Billid_In         In 药品收发记录.Id%Type,
  收费与发药分离_In Integer
) Is
  v_单据       药品收发记录.单据%Type;
  v_No         药品收发记录.No%Type;
  v_库房id     药品收发记录.库房id%Type;
  v_药品id     药品收发记录.药品id%Type;
  v_实际数量   药品收发记录.实际数量%Type;
  v_批次       药品收发记录.批次%Type;
  v_效期       药品收发记录.效期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_成本价     药品收发记录.成本价%Type;
  v_批号       药品收发记录.批号%Type;
  v_产地       药品收发记录.产地%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_Haverow    Integer;
Begin
  --1、更新药品收发记录
  --2、清除未发药记录
  --3、修改药品库存

  Select 单据, NO, 库房id, 药品id, 实际数量, Nvl(批次, 0) 批次, Nvl(效期, Null) 效期, Nvl(供药单位id, Null) 供药单位id, Nvl(成本价, Null) 成本价,
         Nvl(批号, Null) 批号, Nvl(产地, Null) 产地, Nvl(灭菌效期, Null) 灭菌效期
  Into v_单据, v_No, v_库房id, v_药品id, v_实际数量, v_批次, v_效期, v_供药单位id, v_成本价, v_批号, v_产地, v_灭菌效期
  From 药品收发记录
  Where ID = Billid_In;

  Update 药品收发记录 Set 发药方式 = -1 Where ID = Billid_In;

  Select Count(ID)
  Into v_Haverow
  From 药品收发记录
  Where 单据 = v_单据 And NO = v_No And 库房id + 0 = v_库房id And Nvl(发药方式, -999) <> -1;

  If v_Haverow = 0 Then
    Delete From 未发药品记录 Where 单据 = v_单据 And NO = v_No And 库房id = v_库房id;
  End If;

  If 收费与发药分离_In = 0 Then
    Update 药品库存
    Set 可用数量 = 可用数量 + v_实际数量
    Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 效期, 上次供应商id, 上次采购价, 上次批号, 上次产地, 灭菌效期)
      Values
        (v_库房id, v_药品id, v_批次, 1, v_实际数量, v_效期, v_供药单位id, v_成本价, v_批号, v_产地, v_灭菌效期);
    End If;
  
    Zl_药品库存_可用数量异常处理(v_库房id, v_药品id, v_批次);
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_不发药处方标记_Checked;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_不发药处方标记_Unchecked
(
  Billid_In         In 药品收发记录.Id%Type,
  收费与发药分离_In Integer,
  门诊_In           In Number := 2
) Is
  v_单据       药品收发记录.单据%Type;
  v_No         药品收发记录.No%Type;
  v_库房id     药品收发记录.库房id%Type;
  v_药品id     药品收发记录.药品id%Type;
  v_实际数量   药品收发记录.实际数量%Type;
  v_批次       药品收发记录.批次%Type;
  v_效期       药品收发记录.效期%Type;
  v_供药单位id 药品收发记录.供药单位id%Type;
  v_成本价     药品收发记录.成本价%Type;
  v_批号       药品收发记录.批号%Type;
  v_产地       药品收发记录.产地%Type;
  v_灭菌效期   药品收发记录.灭菌效期%Type;
  v_Haverow    Integer;
Begin
  --1、更新药品收发记录
  --2、插入未发药记录
  --3、修改药品库存

  Select 单据, NO, 库房id, 药品id, 实际数量, Nvl(批次, 0) 批次, Nvl(效期, Null) 效期, Nvl(供药单位id, Null) 供药单位id, Nvl(成本价, Null) 成本价,
         Nvl(批号, Null) 批号, Nvl(产地, Null) 产地, Nvl(灭菌效期, Null) 灭菌效期
  Into v_单据, v_No, v_库房id, v_药品id, v_实际数量, v_批次, v_效期, v_供药单位id, v_成本价, v_批号, v_产地, v_灭菌效期
  From 药品收发记录
  Where ID = Billid_In;

  Update 药品收发记录 Set 发药方式 = Null Where ID = Billid_In;

  Select Count(单据) Into v_Haverow From 未发药品记录 Where 单据 = v_单据 And NO = v_No And 库房id = v_库房id;

  If v_Haverow = 0 Then
    If 门诊_In = 1 Then
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
        Select a.单据, a.No, a.病人id, Null, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
        From (Select b.单据, b.No, a.病人id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份
               From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    Else
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
        Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
        From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                      c.身份
               From 住院费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    End If;
  End If;

  If 收费与发药分离_In = 0 Then
    Update 药品库存
    Set 可用数量 = 可用数量 - v_实际数量
    Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 效期, 上次供应商id, 上次采购价, 上次批号, 上次产地, 灭菌效期)
      Values
        (v_库房id, v_药品id, v_批次, 1, 0 - v_实际数量, v_效期, v_供药单位id, v_成本价, v_批号, v_产地, v_灭菌效期);
    End If;
  
    Zl_药品库存_可用数量异常处理(v_库房id, v_药品id, v_批次);
  End If;

Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_不发药处方标记_Unchecked;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊划价记录_Delete
(
  No_In       门诊费用记录.No%Type,
  序号_In     Varchar2 := Null,
  自动清除_In Number := 0
) As
  --功能：删除一张门诊划价单据
  --入参：
  --       序号_In：主要用于门诊医生站作废单个药品
  --      自动清除_in：是否自动清除划价单 zl_门诊划价记录_clear 在调用
  --该光标用于处理药品库存可用数量
  Cursor c_Stock Is
    Select 发药方式, 库房id, 批次, 药品id, 实际数量, 付数, 灭菌效期, 产地, 批号, 效期, ID, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where 单据 In (8, 24) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 收费类别 In ('4', '5', '6', '7') And
                         (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;
  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select ID, 价格父号 From 门诊费用记录 Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 Order By 序号;

  v_医嘱ids  Varchar2(4000);
  l_医嘱id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  v_医嘱id   病人医嘱记录.Id%Type;
  l_费用id   t_Numlist := t_Numlist();

  n_父号         门诊费用记录.序号%Type;
  n_Count        Number;
  n_医嘱数       Number(5);
  n_已执行_Count Number;

  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin

  --是否已经删除或收费
  Select Nvl(Count(ID), 0), Sum(Decode(医嘱序号, Null, 0, 1)), Max(医嘱序号), Sum(Decode(Nvl(执行状态, 0), 1, 1, 2, 1, 0))
  Into n_Count, n_医嘱数, v_医嘱id, n_已执行_Count
  From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And
        (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);

  If n_Count = 0 Then
    If Nvl(自动清除_In, 0) = 1 Then
      --自动清除划价单调用时不报错，直接退出
      Return;
    Else
      v_Err_Msg := '要删除的费用记录不存在，可能已经删除或已经收费。';
      Raise Err_Item;
    End If;
  End If;
  --是否已经执行
  If Nvl(n_已执行_Count, 0) > 0 Then
    v_Err_Msg := '要删除的费用记录中包含已执行的内容！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  --自动清除划价单调用时，由于只会传入药品卫材的对应序号，所以不用检查医嘱；
  --如果检查医嘱，可能同一个医嘱中既有药品，也有其它项目，而其它项目正在执行或已执行时该药品划价记录将删除不掉
  If Nvl(自动清除_In, 0) = 0 Then
    Select Nvl(Count(*), 0)
    Into n_Count
    From 病人医嘱发送
    Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
          (Select NO, 记录性质, 医嘱序号
                        From 门诊费用记录
                        Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 医嘱序号 Is Not Null And
                              (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null));
    If n_Count > 0 Then
      v_Err_Msg := '要删除的费用中存在对应的医嘱正在执行的情况，不能删除！';
      Raise Err_Item;
    End If;
  End If;

  --药品相关内容
  --先处理备货材料
  For v_出库 In (Select 发药方式, 库房id, 批次, 药品id, 实际数量, 付数, 灭菌效期, 产地, 批号, 效期, ID, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 = 0 And 收费类别 = '4' And
                                    (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
  
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
  End Loop;

  For r_Stock In c_Stock Loop
  
    If r_Stock.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
      Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
        Values
          (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
           Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
           r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
      End If;
    
      Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I);

  ------------------------------------------------------------------------------------------------------------------------
  --批量删未发药品记录
  Delete From 未发药品记录 A
  Where NO = No_In And 单据 In (8, 24) And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null);
  ------------------------------------------------------------------------------------------------------------------------

  --删除病人医嘱附费(最后一次删除时)
  If 序号_In Is Null Then
    --Begin
    --  Select 医嘱序号
    --  Into v_医嘱id
    --  From 门诊费用记录
    --  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And Rownum = 1;
    -- Exception
    --  When Others Then
    --    Null;
    -- End;
  
    If v_医嘱id Is Not Null Then
      Delete From 病人医嘱附费 Where 医嘱id = v_医嘱id And NO = No_In And 记录性质 = 1;
    End If;
  End If;

  If n_医嘱数 > 0 Then
    If n_医嘱数 = 1 Then
      l_医嘱id.Extend;
      l_医嘱id(l_医嘱id.Count) := v_医嘱id;
    Else
      Select Distinct 医嘱序号 Bulk Collect
      Into l_医嘱id
      From 门诊费用记录
      Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And 医嘱序号 Is Not Null And
            (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);
    End If;
  End If;

  --门诊费用记录
  Delete From 门诊费用记录
  Where 记录性质 = 1 And 记录状态 = 0 And NO = No_In And
        (Instr(',' || 序号_In || ',', ',' || Nvl(价格父号, 序号) || ',') > 0 Or 序号_In Is Null);
  If Sql%RowCount = 0 Then
    If Nvl(自动清除_In, 0) = 1 Then
      --自动清除划价单调用时不报错，直接退出
      Return;
    Else
      v_Err_Msg := '要删除的费用记录不存在，可能已经删除或已经收费。';
      Raise Err_Item;
    End If;
  End If;

  If 序号_In Is Not Null Then
    --重新调整剩余费用费用记录的序号
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        n_父号 := n_Count;
      End If;
      Update 门诊费用记录 Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, n_父号) Where ID = r_Serial.Id;
    
      n_Count := n_Count + 1;
    End Loop;
  End If;
  v_医嘱ids := Null;
  For I In 1 .. l_医嘱id.Count Loop
    v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || l_医嘱id(I);
  End Loop;
  If v_医嘱ids Is Not Null Then
    v_医嘱ids := Substr(v_医嘱ids, 2);
    --场合_In    Integer, --0:门诊;1-住院
    --性质_In    Integer, --1-收费单;2-记帐单
    --操作_In    Integer, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2
    Zl_医嘱发送_计费状态_Update(0, 1, 0, No_In, v_医嘱ids);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊划价记录_Delete;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊记帐记录_Delete
(
  No_In         门诊费用记录.No%Type,
  序号_In       Varchar2,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：冲销一张门诊记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",为空表示冲销所有可冲销行
  --该光标用于销帐指定费用行

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill(n_标志 Number) Is
    Select a.Id, a.价格父号, a.序号, a.执行状态, a.收费类别, a.医嘱序号, a.病人id, a.收入项目id, a.开单部门id, a.执行部门id, a.病人科室id, a.实收金额,
           Decode(a.记录状态, 0, 1, 0) As 划价, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.收费细目id + 0 = m.材料id(+) And a.No = No_In And a.记录性质 = 2 And a.记录状态 In (0, 1, 3) And
          a.门诊标志 = n_标志
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock(n_标志 Number) Is
    Select ID, 库房id, 药品id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (9, 25) And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = n_标志 And
                         (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号 From 门诊费用记录 Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) Order By 序号;
  l_药品收发 t_Numlist := t_Numlist();
  l_划价     t_Numlist := t_Numlist();
  l_费用id   t_Numlist := t_Numlist();
  n_备货卫材 Number;

  v_医嘱ids Varchar2(4000);

  n_医嘱id   病人医嘱记录.Id%Type;
  n_父号     门诊费用记录.价格父号%Type;
  n_门诊标志 门诊费用记录.门诊标志%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;

  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;

  n_Dec Number;

  n_Count   Number;
  d_Curdate Date;
  Err_Item Exception;
  v_Err_Msg Varchar2(255);
Begin
  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Max(Nvl(门诊标志, 1))
  Into n_Count, n_门诊标志
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  If Nvl(n_门诊标志, 0) = 0 Then
    n_门诊标志 := 1;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 2 And 门诊标志 = n_门诊标志 And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
    
      If r_Bill.划价 = 0 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          --求剩余数量,剩余应收,剩余实收
          Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
          Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
          From 门诊费用记录
          Where NO = No_In And 记录性质 = 2 And 序号 = r_Bill.序号;
        
          If n_剩余数量 = 0 Then
            If 序号_In Is Not Null Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
              Raise Err_Item;
            End If;
            --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
          Else
            --准销数量(非药品项目为剩余数量,原始数量)
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            
              --@@@
              --非药品部分(以具体医嘱执行为准进行检查)
              --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
              --: 2.对于病人医吃计价中的收费方式为:0-正常收取 的,才支持部分退;如果是其他的,则只能全退
              --: 3.不存在医嘱的,则以剩余数量为准
              n_Count := 0;
              If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select j.医嘱序号 As 医嘱id, j.收费细目id, Nvl(j.付数, 1) * Nvl(j.数次, 1) As 数量
                       From 门诊费用记录 J, 病人医嘱记录 M
                       Where j.医嘱序号 = m.Id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             Exists
                        (Select 1
                              From 病人医嘱发送 A
                              Where a.医嘱id = j.医嘱序号 And Nvl(a.执行状态, 0) <> 1 And a.No || '' = No_In) And Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And j.价格父号 Is Null And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             (j.记录状态 In (1, 3) And Not Exists
                              (Select 1
                               From 药品收发记录
                               Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Or
                              j.记录状态 = 2 And Not Exists
                              (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = j.收费细目id))
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And Nvl(a.收费方式, 0) = 0 And b.发送号 = c.发送号 And
                             a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 2 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱id, a.收费细目id, 0 As 数量
                       From 病人医嘱计价 A, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = m.Id And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) <> 0 And
                             j.No = No_In And j.记录性质 = 2 And Nvl(j.执行状态, 0) = 2 And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1) And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0);
              
              End If;
            
              If Nvl(n_Count, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            
            Else
              Select Sum(Nvl(付数, 1) * 实际数量)
              Into n_准退数量
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 25) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            
              --不跟踪在用的卫生材料
              If r_Bill.收费类别 = '4' And Nvl(n_准退数量, 0) = 0 Then
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
            --处理门诊费用记录
          
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 2 And 记录状态 = 2 And 序号 = r_Bill.序号;
          
            --金额=剩余金额*(准退数/剩余数)
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          
            --插入退费记录
            Insert Into 门诊费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
               收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人,
               执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 婴儿费, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                     病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, d_Curdate, 保险项目否, 保险大类id, -1 * n_统筹金额, 记帐单id, 摘要, 保险编码, 是否急诊, 结论
              From 门诊费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) - n_实收金额
            Where 病人id = r_Bill.病人id And 性质 = 1 And 类型 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 性质, 类型, 费用余额, 预交余额)
              Values
                (r_Bill.病人id, 1, 1, -1 * n_实收金额, 0);
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - n_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = 0 And Nvl(病人病区id, 0) = 0 And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = n_门诊标志;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, Null, Null, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, n_门诊标志,
                 -1 * n_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1
            Update 门诊费用记录
            Set 记录状态 = 3, 执行状态 = Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1)
            Where ID = r_Bill.Id;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  ------------------------------------------------------------------------------------------------------------------------
  --先处理备货材料
  For v_出库 In (Select ID, 库房id, 药品id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 2 And 记录状态 In (0, 1, 3) And 收费类别 = '4' And 门诊标志 = n_门诊标志 And
                                    (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  For r_Stock In c_Stock(n_门诊标志) Loop
  
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
      Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
        Values
          (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
           Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
           r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
      End If;
    
      Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
    End If;
  
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I);

  ------------------------------------------------------------------------------------------------------------------------
  --批量删未发药品记录

  Delete From 未发药品记录 A
  Where NO = No_In And 单据 In (9, 25) And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null);
  ------------------------------------------------------------------------------------------------------------------------

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count   := 0;
  v_医嘱ids := Null;
  For r_Bill In c_Bill(n_门诊标志) Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If r_Bill.划价 = 1 Then
        If Nvl(r_Bill.执行状态, 0) <> 1 Then
          l_划价.Extend;
          l_划价(l_划价.Count) := r_Bill.Id;
        
          --Delete From 门诊费用记录 Where ID = r_Bill.ID;
          n_Count := n_Count + 1; --记录是否有删除行
        
          If r_Bill.医嘱序号 Is Not Null Then
            If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
              v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
            End If;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If n_医嘱id Is Null Then
              n_医嘱id := r_Bill.医嘱序号;
            End If;
          End If;
        Else
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
            Raise Err_Item;
          End If;
          --情况:没限定行号,原始单据中包括已经完全执行的
        End If;
      End If;
    End If;
  End Loop;

  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 门诊费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        n_父号 := n_Count;
      End If;
    
      Update 门诊费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, n_父号)
      Where NO = No_In And 记录性质 = 2 And 序号 = r_Serial.序号;
    
      Update 门诊费用记录 Set 从属父号 = n_Count Where NO = No_In And 记录性质 = 2 And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  
  End If;

  --整张单据全部冲完时，删除病人医嘱附费
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 2 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 2 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 2 And NO = No_In;
    End If;
  End Loop;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(0, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(0, 2, 2, No_In, v_医嘱ids);
  End If;
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊记帐记录_Delete;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊简单收费_Delete
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type
) As
  --功能：删除一张门诊简单收费单据

  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7'))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  Select Sysdate Into d_Date From Dual;
  Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  n_结算序号 := Null;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  Begin
    Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
  Exception
    When Others Then
      v_退费结算 := '现金';
  End;

  ---------------------------------------------------------------------------------
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Nvl(r_Bill.执行状态, 0) <> 1 Then
      --求剩余数量,剩余应收,剩余实收
      Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
      Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
      From 门诊费用记录
      Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
    
      If n_剩余数量 = 0 Then
        --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
        n_正常退费 := 0;
      Else
        --准退数量(非药品项目为剩余数量,原始数量)
        If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
          --@@@
          --非药品部分(以具体医嘱执行为准进行检查)
          --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
          --: 2.不存在医嘱的,则以剩余数量为准
          n_Count := 0;
          If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
            If n_医属执行计价 = 1 Then
              Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
              Into n_准退数量, n_Count
              From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                            Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                            Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                           Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                           a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                     Group By a.序号
                     Union All
                     Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                     From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                     Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                           (Exists
                            (Select 1
                             From 病人医嘱执行
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                            (Select 1
                             From 病人医嘱发送
                             Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                      (Select 1
                            From 病人医嘱附费
                            Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                           a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
              Where Not Exists (Select 1 From 药品收发记录 Where 费用id = Q1.Id) Having Max(ID) <> 0;
            Else
              Select Nvl(Sum(数量), 0), Count(*)
              Into n_准退数量, n_Count
              From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                           a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                           j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Exists
                      (Select 1
                            From 病人医嘱计价 A
                            Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id)
                     Union All
                     Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                     From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                     Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And Nvl(c.执行结果, 1) = 1 And
                           Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And j.No = No_In And
                           j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And j.价格父号 Is Null And
                           Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                      (Select 1 From 药品收发记录 Where 费用id = j.Id) And Not Exists
                      (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                     Union All
                     Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                     From 门诊费用记录 A, 病人医嘱记录 M
                     Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                           a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                      (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
            End If;
          End If;
          If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
            Raise Err_Item;
          End If;
        
          If Nvl(n_Count, 0) = 0 Then
            n_准退数量 := n_剩余数量;
          End If;
        
        Else
          Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
          Into n_准退数量, n_Count
          From 药品收发记录
          Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                And 审核人 Is Null And 费用id = r_Bill.Id;
        
          --有剩余数量无准退数量的有两种情况：
          --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
          --2.并发操作,此时已发药或发料
          If n_准退数量 = 0 Then
            If r_Bill.收费类别 = '4' Then
              If n_Count > 0 Then
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            Else
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
              Raise Err_Item;
            End If;
          End If;
        End If;
      
        --是否部分退费
        If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
          n_正常退费 := 0;
        End If;
      
        --处理门诊费用记录
        n_费用状态 := 0;
        --该笔项目第几次退费
        Select Nvl(Max(Abs(执行状态)), 0) + 1
        Into n_退费次数
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
      
        n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
        n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
        n_总金额   := n_总金额 + n_实收金额;
      
        --插入退费记录
        Insert Into 门诊费用记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别, 收费细目id,
           计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, 执行状态,
           费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论, 缴款组id)
          Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                 Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                 -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In, 操作员姓名_In,
                 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, 摘要, Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码,
                 费用类型, 结论, n_组id
          From 门诊费用记录
          Where ID = r_Bill.Id;
      
        --标记原费用记录
        --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
        Update 门诊费用记录
        Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
        Where ID = r_Bill.Id;
      End If;
    Else
      --情况:没限定行号,原始单据中包括已经完全执行的
      n_正常退费 := 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --处理病人预交记录
  --自动产生误差费,默认保留一位
  n_总金额 := Round(n_总金额, 1);
  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    --处理病人预交余额
    For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                 From 病人预交记录
                 Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                 Group By 预交类别
                 Having Sum(Nvl(冲预交, 0)) <> 0) Loop
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
      Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额
          (病人id, 类型, 预交余额, 性质)
        Values
          (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
        n_返回值 := n_预交金额;
      End If;
      If n_返回值 = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
      End If;
    End Loop;
  
    --原样退回(冲预交在前面已处理)
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
       卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
             -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
           (Select m.Id As 预交id From 病人预交记录 M Where m.结帐id = n_原结帐id And m.记录性质 = 3 And m.记录状态 = 1) Q
      Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+);
  Else
    --部分退费直接退为指定结算方式
    Insert Into 病人预交记录
      (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
       结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
      Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In, 操作员姓名_In,
             -1 * n_总金额, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
      
      From 病人预交记录
      Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
  
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 Then
      n_预交金额 := n_总金额;
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 0, n_结算序号, 3
          From 病人预交记录
          Where ID = r_Deposit.Id;
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
    
      --更新病人预交余额
      Update 病人余额
      Set 预交余额 = Nvl(预交余额, 0) + n_总金额
      Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
      Returning 预交余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额, 1);
        n_返回值 := n_总金额;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
      End If;
    End If;
  End If;
  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
  Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;

  n_实收金额 := n_实收金额 - n_返回值;

  If n_实收金额 <> 0 Then
    --未找到，新产生误差项
    Zl_简单收费误差_Insert(No_In, n_病人id, n_结帐id, n_实收金额, d_Date, 操作员编号_In, 操作员姓名_In, 1);
  End If;

  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  For r_Moneyrow In c_Money(n_结帐id) Loop
    Update 人员缴款余额
    Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
    Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
    Returning 余额 Into n_返回值;
    If Sql%RowCount = 0 Then
      Insert Into 人员缴款余额
        (收款员, 结算方式, 性质, 余额)
      Values
        (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
      n_返回值 := r_Moneyrow.冲预交;
    End If;
    If Nvl(n_返回值, 0) = 0 Then
      Delete From 人员缴款余额
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
    End If;
  End Loop;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
  v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
  n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
  If n_启用模式 <> 0 Then
    --收回票据
    Select 使用id Bulk Collect
    Into l_使用id
    From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
  
    n_启用模式 := l_使用id.Count;
    If l_使用id.Count <> 0 Then
      --插入回收记录
      Forall I In 1 .. l_使用id.Count
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
          From 票据使用明细 A
          Where ID = l_使用id(I) And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
    
      Forall I In 1 .. l_使用id.Count
        Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
    
    End If;
  End If;
  If n_启用模式 = 0 Then
    --获取单据最后一次的打印ID(可能是多张单据收费打印)
    Begin
      --性质=1，原因=6为退费打印票据(红票)，不回收
      Select ID
      Into n_打印id
      From (Select b.Id
             From 票据使用明细 A, 票据打印内容 B
             Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
             Order By a.使用时间 Desc)
      Where Rownum < 2;
    Exception
      When Others Then
        Null;
    End;
    --可能以前没有打印,无收回
    If n_打印id Is Not Null Then
      --a.多张单据循环调用时只能收回一次
      Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
      If n_Count = 0 Then
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
      Else
        --b.部分退费多次收回时,最后一次全退收回要排开已收回的
        Insert Into 票据使用明细
          (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
          Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
          From 票据使用明细 A
          Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
           (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4')
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  ---------------------------------------------------------------------------------
  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      
        Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊简单收费_Delete;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊收费记录_Delete
(
  No_In           门诊费用记录.No%Type,
  操作员编号_In   门诊费用记录.操作员编号%Type,
  操作员姓名_In   门诊费用记录.操作员姓名%Type,
  医保结算方式_In Varchar2 := Null,
  序号_In         Varchar2 := Null,
  结算方式_In     病人预交记录.结算方式%Type := Null,
  误差_In         门诊费用记录.实收金额%Type := 0,
  退费时间_In     门诊费用记录.登记时间%Type := Null,
  回收票据_In     Number := 0,
  退费摘要_In     门诊费用记录.摘要%Type := Null,
  校对标志_In     Number := 0,
  结帐id_In       病人预交记录.结帐id%Type := Null,
  结算序号_In     病人预交记录.结算序号%Type := Null,
  一卡通结算_In   Varchar2 := Null,
  退款操作_In     Number := 0,
  多单据全退_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        医保结算方式_IN   =医保退费时,不支持结算作废的结算方式,如果为空表示非医保退费或医保退费全部结算允许作废。
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        结算方式_IN       =当为部分退费时,退费金额的结算方式。
  --        误差_IN           =指退费时新产生的误差金额,部份退费或医保全退但某种结算退现金时才会产生新的误差。
  --                           此时传入仅用于计算本次退费的结算金额,误差费用记录的处理在本过程执行完后调用Zl_门诊收费误差_Insert产生
  --        回收票据_In       =0:单张全退或多张一起全退时收回票据,注意,多张单据退费循环调本过程时只收回一次。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --        校对标志_IN:0-不需要较对;1-需较对(不处理人员缴款余额,不回收票据,不处理预交余额)
  --        一卡通结算_In 全退时传入不原样退回的结算方式；医疗卡部分退费时，传入"结算方式|金额"
  --        退款操作_In:1-进行部分退(将退款方式退到指定的结算方式<结算方式_In>中,0-不指定退款方式)
  --        多单据全退_IN=1-多单据全退(多张单据全退,原样退);0-非原样退
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+) And
          Nvl(a.附加标志, 0) <> Decode(多单据全退_In, 1, 999, 9)
    Order By a.收费细目id, a.序号;
  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额
  Cursor c_Money(冲销id_In 病人预交记录.结帐id%Type) Is
    Select 结算方式, 冲预交
    From 病人预交记录
    Where 记录性质 = 3 And 记录状态 = 2 And 结帐id = 冲销id_In And 结算方式 Is Not Null And Nvl(冲预交, 0) <> 0 And Nvl(校对标志, 0) = 0;

  --该游标用于查找收费时使用过的冲预交款记录
  Cursor c_Deposit(V结帐id 病人预交记录.结帐id%Type) Is
    Select ID, 冲预交 As 金额, 预交类别
    From 病人预交记录
    Where 记录性质 In (1, 11) And 记录状态 In (1, 3) And 结帐id = V结帐id And Nvl(冲预交, 0) <> 0
    Order By ID Desc;

  n_病人id   病人信息.病人id%Type;
  n_结帐id   门诊费用记录.结帐id%Type;
  n_结算序号 病人预交记录.结算序号%Type;
  n_打印id   票据打印内容.Id%Type;

  n_已退金额 病人预交记录.冲预交%Type;
  n_预交金额 病人预交记录.冲预交%Type;
  n_返回值   病人预交记录.冲预交%Type;
  n_原误差费 门诊费用记录.实收金额%Type;
  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_费用状态 门诊费用记录.费用状态%Type;
  n_正常退费 Number; --是否第一次退费且全部退费,在每行退费过程中判断得到。
  n_组id     财务缴款分组.Id%Type;

  v_退费结算 结算方式.名称%Type;
  v_结算内容 Varchar2(500);
  n_部分退   Number(2);
  v_当前结算 Varchar2(50);
  v_结算方式 病人预交记录.结算方式%Type;
  n_结算金额 病人预交记录.冲预交%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();
  n_Dec      Number;
  d_Date     Date;
  n_Count    Number;
  n_原结帐id Number;

  Err_Item Exception;
  v_Err_Msg      Varchar2(255);
  n_启用模式     Number(3);
  v_Para         Varchar2(1000);
  n_医属执行计价 Number;
  n_会话号       病人预交记录.会话号%Type; --格式：SID+'_'+SERIAL#

  Procedure Zl_Square_Update
  (
    原结帐id_In 病人预交记录.结帐id%Type,
    现结帐id_In 病人预交记录.结帐id%Type,
    缴款组id_In 病人预交记录.缴款组id%Type,
    退款时间_In 病人预交记录.收款时间%Type,
    结算序号_In 病人预交记录.结算序号%Type,
    结算内容_In Varchar2 := Null
  ) As
    n_记录状态 病人卡结算记录.记录状态%Type;
    n_预交id   病人预交记录.Id%Type;
    v_卡号     病人卡结算记录.卡号%Type;
    n_存在卡片 Number;
    d_停用日期 消费卡目录.停用日期%Type;
    n_最大序号 病人卡结算记录.序号%Type;
    n_序号     病人卡结算记录.序号%Type;
    n_余额     消费卡目录.余额%Type;
    n_接口编号 病人卡结算记录.接口编号%Type;
    d_回收时间 消费卡目录.回收时间%Type;
    n_Id       病人预交记录.Id%Type;
  Begin
    n_预交id := 0;
    --处理消费卡,结算卡在上面就已经处理了
    For v_校对 In (Select a.Id As 预交id, c.消费卡id, c.结算金额, c.接口编号, c.卡号, c.序号, c.Id
                 From 病人预交记录 A, 病人卡结算对照 B, 病人卡结算记录 C
                 Where a.Id = b.预交id And b.卡结算id = c.Id And a.记录性质 = 3 And a.记录状态 = 1 And
                       Instr(Nvl(结算内容_In, '_LXH'), ',' || a.结算方式 || ',') = 0 And a.结帐id = 原结帐id_In) Loop
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id = Nvl(v_校对.消费卡id, 0) And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      Else
        Select Max(记录状态)
        Into n_记录状态
        From 病人卡结算记录
        Where 接口编号 = v_校对.接口编号 And 消费卡id Is Null And 卡号 = v_校对.卡号 And Nvl(序号, 0) = Nvl(v_校对.序号, 0);
      End If;
    
      If n_记录状态 = 1 Then
        n_记录状态 := 2;
      Else
        n_记录状态 := n_记录状态 + 2;
      End If;
      --多条时,只更新一条
      If n_预交id = 0 Then
        Select 病人预交记录_Id.Nextval Into n_预交id From Dual;
      
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id,
           预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select n_预交id, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, 退款时间_In, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
                 -1 * 冲预交, 现结帐id_In, 缴款组id_In, 预交类别, 卡类别id, Nvl(结算卡序号, v_校对.接口编号), 卡号, 交易流水号, 交易说明, 合作单位,
                 Decode(Nvl(校对标志_In, 0), 0, 0, Decode(Nvl(v_校对.消费卡id, 0), 0, 1, 2)), 结算序号_In, 3, n_会话号
          From 病人预交记录 A
          Where ID = v_校对.预交id;
      End If;
    
      If Nvl(v_校对.消费卡id, 0) <> 0 Then
        --消费卡,直接退回卡数据中
        Begin
          Select 卡号, 1, 停用日期, (Select Max(序号) From 消费卡目录 B Where a.卡号 = b.卡号 And a.接口编号 = b.接口编号), 序号, 余额, 接口编号, 回收时间
          Into v_卡号, n_存在卡片, d_停用日期, n_最大序号, n_序号, n_余额, n_接口编号, d_回收时间
          From 消费卡目录 A
          Where ID = v_校对.消费卡id;
        Exception
          When Others Then
            n_存在卡片 := 0;
        End;
      
        --取消停用
        If n_存在卡片 = 0 Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡被他人删除，不能再启用该卡片,请检查！';
          Raise Err_Item;
        End If;
        If Nvl(n_序号, 0) < Nvl(n_最大序号, 0) Then
          v_Err_Msg := '不能启用历史发卡记录(卡号为"' || v_卡号 || '"),请检查！';
          Raise Err_Item;
        End If;
        If Nvl(d_停用日期, To_Date('3000-01-01', 'yyyy-mm-dd')) < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经被他人停用，不能再进行退费,请检查！';
          Raise Err_Item;
        End If;
      
        If d_回收时间 < To_Date('3000-01-01', 'yyyy-mm-dd') Then
          v_Err_Msg := '卡号为"' || v_卡号 || '"的消费卡已经回收，不能退费,请检查！';
          Raise Err_Item;
        End If;
        Update 消费卡目录 Set 余额 = Nvl(余额, 0) + v_校对.结算金额 Where ID = Nvl(v_校对.消费卡id, 0);
      End If;
    
      Select 病人卡结算记录_Id.Nextval Into n_Id From Dual;
      Insert Into 病人卡结算记录
        (ID, 接口编号, 消费卡id, 序号, 记录状态, 结算方式, 结算金额, 卡号, 交易流水号, 交易时间, 备注, 结算标志)
        Select n_Id, 接口编号, 消费卡id, 序号, n_记录状态, 结算方式, -1 * v_校对.结算金额, 卡号, 交易流水号, 交易时间, 备注,
               Decode(消费卡id, Null, 0, 0, 0, 1) As 标志
        From 病人卡结算记录
        Where ID = v_校对.Id;
      Insert Into 病人卡结算对照 (预交id, 卡结算id) Values (n_预交id, n_Id);
    
      If n_记录状态 <> 2 And n_记录状态 <> 1 Then
        Update 病人卡结算记录 Set 记录状态 = 3 Where ID = v_校对.Id;
      End If;
    End Loop;
  End;

Begin
  n_组id := Zl_Get组id(操作员姓名_In);

  Begin
    Select Sid || '_' || Serial# Into n_会话号 From V$session Where Audsid = Userenv('sessionid');
  Exception
    When Others Then
      n_会话号 := Null;
  End;

  n_部分退 := 0;
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 门诊费用记录
                Where NO = No_In And 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;
  --确定是否在医嘱执行计价中存在数据,如果存在数据,则根据医嘱执行计价进行退费,否则按旧方式进行处理
  Select Count(1)
  Into n_医属执行计价
  From 门诊费用记录 A, 医嘱执行计价 B
  Where a.医嘱序号 = b.医嘱id And a.记录性质 = 1 And a.No = No_In And a.记录状态 In (1, 3) And Rownum = 1;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;
  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;
  n_结算序号 := 结算序号_In;
  If n_结算序号 Is Null Then
    n_结算序号 := 结帐id_In;
  End If;
  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --获取结算方式名称
  v_退费结算 := 结算方式_In;
  If v_退费结算 Is Null Then
    Begin
      Select 名称 Into v_退费结算 From 结算方式 Where 性质 = 1;
    Exception
      When Others Then
        v_退费结算 := '现金';
    End;
  End If;
  --循环处理每行费用(收入项目行)
  n_总金额   := 0;
  n_正常退费 := 1;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And 记录性质 = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部退费(执行状态=0的一种可能)
          n_正常退费 := 0;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱发送的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血)
            --: 2.不存在医嘱的,则以剩余数量为准
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null Then
              If n_医属执行计价 = 1 Then
                Select Decode(Sign(Sum(数量)), -1, 0, Sum(数量)), Count(*)
                Into n_准退数量, n_Count
                From (Select Max(Decode(a.记录状态, 2, 0, a.Id)) As ID, Max(a.医嘱序号) As 医嘱id, Max(a.收费细目id) As 收费细目id,
                              Sum(Nvl(a.付数, 1) * Nvl(a.数次, 1)) As 数量,
                              Sum(Decode(a.记录状态, 2, 0, Nvl(a.付数, 1) * Nvl(a.数次, 1))) As 原始数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Instr('5,6,7', a.收费类别) = 0 And a.No = No_In And a.序号 = r_Bill.序号 And a.记录性质 = 1 And
                             a.记录状态 In (1, 2, 3) And a.价格父号 Is Null
                       Group By a.序号
                       Union All
                       Select a.Id, a.医嘱序号 As 医嘱id, a.收费细目id, -1 * b.数量 As 已执行, 0 原始数量
                       From 门诊费用记录 A, 医嘱执行计价 B, 病人医嘱记录 M
                       Where a.医嘱序号 = b.医嘱id And a.收费细目id = b.收费细目id + 0 And a.医嘱序号 = m.Id And
                             Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Instr('5,6,7', a.收费类别) = 0 And
                             (Exists
                              (Select 1
                               From 病人医嘱执行
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And b.要求时间 = 要求时间 And Nvl(执行结果, 0) = 1) Or Exists
                              (Select 1
                               From 病人医嘱发送
                               Where b.医嘱id = 医嘱id And b.发送号 = 发送号 And Nvl(执行状态, 0) = 1)) And Not Exists
                        (Select 1
                              From 病人医嘱附费
                              Where a.医嘱序号 = 医嘱id And a.No = NO And Mod(a.记录性质, 10) = 记录性质) And a.No = No_In And
                             a.序号 = r_Bill.序号 And a.记录性质 = 1 And a.记录状态 In (1, 3) 　and a.价格父号 Is Null) Q1
                Where Not Exists (Select 1
                       From 药品收发记录
                       Where 费用id = Q1.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) Having
                 Max(ID) <> 0;
              Else
              
                Select Nvl(Sum(数量), 0), Count(*)
                Into n_准退数量, n_Count
                From (Select a.医嘱id, a.收费细目id, Nvl(a.数量, 1) * Nvl(b.发送数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And a.医嘱id = m.Id And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And
                             a.收费细目id = j.收费细目id And j.No = No_In And j.记录性质 = 1 And j.序号 = r_Bill.序号 And
                             j.记录状态 In (1, 3) And j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And
                             Exists
                        (Select 1
                              From 病人医嘱计价 A
                              Where a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And Nvl(a.收费方式, 0) = 0) And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0)
                       Union All
                       Select a.医嘱id, a.收费细目id, -1 * Nvl(a.数量, 1) * Nvl(c.本次数次, 1) As 数量
                       From 病人医嘱计价 A, 病人医嘱发送 B, 病人医嘱执行 C, 门诊费用记录 J, 病人医嘱记录 M
                       Where a.医嘱id = b.医嘱id And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And a.医嘱id = m.Id And
                             Nvl(c.执行结果, 1) = 1 And Nvl(b.执行状态, 0) <> 1 And a.医嘱id = j.医嘱序号 And a.收费细目id = j.收费细目id And
                             j.No = No_In And j.记录性质 = 1 And Nvl(a.收费方式, 0) = 0 And j.序号 = r_Bill.序号 And j.记录状态 In (1, 3) And
                             j.价格父号 Is Null And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And Not Exists
                        (Select 1
                              From 药品收发记录
                              Where 费用id = j.Id And Instr(',8,9,10,21,24,25,26,', ',' || 单据 || ',') > 0) And Not Exists
                        (Select 1 From 材料特性 Where 材料id = j.收费细目id And Nvl(跟踪在用, 0) = 1)
                       Union All
                       Select a.医嘱序号 As 医嘱id, a.收费细目id, Nvl(a.付数, 1) * a.数次 As 数量
                       From 门诊费用记录 A, 病人医嘱记录 M
                       Where a.医嘱序号 = m.Id And Instr(',C,D,F,G,K,', ',' || m.诊疗类别 || ',') = 0 And a.No = No_In And
                             a.记录性质 = 1 And a.序号 = r_Bill.序号 And a.记录状态 = 2 And a.价格父号 Is Null And Not Exists
                        (Select 1 From 药品收发记录 Where NO = No_In And 单据 In (8, 24) And 药品id = a.收费细目id));
              End If;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行,不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              n_准退数量 := n_剩余数量;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --是否部分退费
          If r_Bill.执行状态 = 2 Or n_准退数量 <> Nvl(r_Bill.付数, 1) * r_Bill.数次 Then
            n_正常退费 := 0;
          End If;
        
          --处理门诊费用记录
          n_费用状态 := 0;
          --该笔项目第几次退费
          If Nvl(校对标志_In, 0) <> 0 Then
            n_退费次数 := -9; --先标明,固定为9
            n_费用状态 := 1;
          Else
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into n_退费次数
            From 门诊费用记录
            Where NO = No_In And 记录性质 = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          If Nvl(r_Bill.误差, 0) = 9 Then
            --误差可以超过设置的小数位(比如:医保结算超过小数位后,误差就可能超过小数位
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), 5);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), 5);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), 5);
          Else
            n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
            n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          End If;
          n_总金额 := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, n_费用状态, 执行时间, 操作员编号_In,
                   操作员姓名_In, 发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          --执行状态:全部退完(准退数=剩余数)标记为0,否则标记为1,异常收费单,还是标明9
          Update 门诊费用记录
          Set 记录状态 = 3, 执行状态 = Decode(Nvl(执行状态, 0), 9, 9, Decode(Sign(n_准退数量 - n_剩余数量), 0, 0, 1))
          Where ID = r_Bill.Id;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
        n_正常退费 := 0;
      End If;
    Else
      n_正常退费 := 0; --未指定该笔,属于部分退费
    End If;
  End Loop;
  ---------------------------------------------------------------------------------
  --处理病人预交记录

  --原单据的结帐ID
  Select 结帐id, 病人id
  Into n_原结帐id, n_病人id
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Rownum = 1;

  If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
    --单据第一次退费且全部退完
    --冲预交部分记录
    Insert Into 病人预交记录
      (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交, 结帐id,
       缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
      Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, d_Date,
             操作员姓名_In, 操作员编号_In, -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
             Decode(校对标志_In, 1, 2, 校对标志_In), n_结算序号, 3, n_会话号
      From 病人预交记录
      Where 记录性质 In (1, 11) And 结帐id = n_原结帐id And Nvl(冲预交, 0) <> 0;
    If Nvl(校对标志_In, 0) = 0 Then
      --处理病人预交余额
      For v_预交 In (Select 预交类别, Nvl(Sum(Nvl(冲预交, 0)), 0) As 预交金额
                   From 病人预交记录
                   Where 记录性质 In (1, 11) And 结帐id = n_原结帐id
                   Group By 预交类别
                   Having Sum(Nvl(冲预交, 0)) <> 0) Loop
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + Nvl(v_预交.预交金额, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = Nvl(v_预交.预交类别, 2)
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额
            (病人id, 类型, 预交余额, 性质)
          Values
            (n_病人id, Nvl(v_预交.预交类别, 2), Nvl(v_预交.预交金额, 0), 1);
          n_返回值 := n_预交金额;
        End If;
        If n_返回值 = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(预交余额, 0) = 0 And Nvl(费用余额, 0) = 0;
        End If;
      End Loop;
    End If;
    --非医保全退,和医保所有结算方式都允许回退,原样退回(冲预交在前面已处理)
    If 医保结算方式_In Is Null Then
      v_结算内容 := ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || Nvl(一卡通结算_In, 'Lxh') || ',';
    
      --一卡通或消费卡或银行卡的相关数据需要特殊处理,需要最后较对.
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
         卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 缴款单位, 单位开户行, 单位帐号, 操作员编号_In, 操作员姓名_In,
               -1 * 冲预交, n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结帐id = n_原结帐id And a.Id = q.预交id(+) And a.结算方式 = j.名称(+) And
              Instr(v_结算内容, ',' || 结算方式 || ',') = 0 And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
      --b.余下的就是三方接口支持的退现了,不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      If 一卡通结算_In Is Not Null Then
        Begin
          Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
        Exception
          When Others Then
            n_已退金额 := 0;
        End;
      
        If (n_总金额 - n_已退金额) <> 0 Then
          --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
             交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, '门诊退费结算', v_退费结算, d_Date, 操作员编号_In, 操作员姓名_In,
                   -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
          n_部分退 := 1;
        End If;
      End If;
      --医保按允许作废的结算方式退,不允许的,退到指定的结算方式上
      --需要处理误差金额
    Else
      --a.原样退回
      v_结算内容 := ',' || 医保结算方式_In || ',' || Nvl(一卡通结算_In, '-Lxh') || ',' || v_退费结算 || ',';
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 结算号码, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
         交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 记录性质, NO, 2, 病人id, 主页id, 摘要, 结算方式, 结算号码, d_Date, 操作员编号_In, 操作员姓名_In, -1 * 冲预交, n_结帐id,
               n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               
               Case
                 When Nvl(卡类别id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(结算卡序号, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(q.预交id, 0) <> 0 Then
                  Decode(校对标志_In, 1, 1, 0) * 1
                 When Nvl(j.名称, '-') <> '-' Then
                  Decode(校对标志_In, 1, 1, 0)
                 Else
                  Decode(校对标志_In, 1, 2, 0)
               End As 校对标志, n_结算序号, 3, n_会话号
        From 病人预交记录 A, (Select 名称 From 结算方式 Where 性质 In (3, 4)) J,
             (Select m.Id As 预交id
               From 病人预交记录 M, 一卡通目录 C
               Where m.结帐id = n_原结帐id And m.结算方式 = c.结算方式 And m.记录性质 = 3 And m.记录状态 = 1) Q
        Where a.记录性质 = 3 And a.记录状态 = 1 And a.结算方式 = j.名称(+) And a.结帐id = n_原结帐id And
              Instr(v_结算内容, ',' || a.结算方式 || ',') = 0 And a.Id = q.预交id(+) And
              (Not Exists (Select 1 From 病人卡结算对照 Where a.Id = 预交id) Or Nvl(结算卡序号, 0) = 0);
    
      --处理消费卡,结算卡在上面就已经处理了
      Zl_Square_Update(n_原结帐id, n_结帐id, n_组id, d_Date, n_结算序号, v_结算内容);
    
      --b.余下的就是医保不允许作废的结算方式,加上到指定的结算方式上,加上误差(因为界面程序会在这之后退误差)
      Begin
        Select -1 * Nvl(Sum(冲预交), 0) Into n_已退金额 From 病人预交记录 Where 结帐id = n_结帐id;
      Exception
        When Others Then
          n_已退金额 := 0;
      End;
    
      If (n_总金额 - n_已退金额) <> 0 Then
        --此时的总金额还没有包含误差,因为界面程序中在调用本过程后才产生误差费用记录
        Insert Into 病人预交记录
          (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号,
           交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, 3, NO, 2, 病人id, 主页id, Decode(一卡通结算_In, Null, '门诊医保接口退费', '门诊医保接口和三方接口退费'), v_退费结算,
                 d_Date, 操作员编号_In, 操作员姓名_In, -1 * (n_总金额 - n_已退金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明,
                 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where 记录性质 = 3 And 记录状态 = 1 And 结帐id = n_原结帐id And Rownum = 1;
        n_部分退 := 1;
      End If;
    
    End If;
  Else
    -------------------------------------------------
    --部分退费
    n_已退金额 := 0;
    --医疗卡部分退费时，传入:结算方式|金额
    If 一卡通结算_In Is Not Null Then
      If Instr(一卡通结算_In, '|') > 0 Then
        v_当前结算 := 一卡通结算_In;
        v_结算方式 := Substr(v_当前结算, 1, Instr(v_当前结算, '|') - 1);
        v_当前结算 := Substr(v_当前结算, Instr(v_当前结算, '|') + 1);
        n_结算金额 := Nvl(To_Number(v_当前结算), 0);
        If Not Nvl(v_结算方式, 'TMP') = 'TMP' Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '三方接口部分退费', v_结算方式, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, -1 * (n_结算金额), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
                   Decode(校对标志_In, 1, 1, 0), n_结算序号, 3, n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum < 2;
        End If;
        n_已退金额 := n_结算金额;
      End If;
    End If;
    --其它直接退为指定结算方式
    If (n_总金额 - n_已退金额 + Nvl(误差_In, 0)) <> 0 Then
      Insert Into 病人预交记录
        (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别, 卡类别id,
         结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
        Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '部分退费结算', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
               操作员姓名_In, -1 * (n_总金额 - n_已退金额 + Nvl(误差_In, 0)), n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位,
               Decode(校对标志, 1, 2, 0), n_结算序号, 3, n_会话号
        From 病人预交记录
        Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
    End If;
    --如果收费时只使用了预交款,则要退预交,并且可能有多笔冲预交
    If Sql%RowCount = 0 And 一卡通结算_In Is Null Then
      n_预交金额 := n_总金额 - n_已退金额 + Nvl(误差_In, 0);
    
      For r_Deposit In c_Deposit(n_原结帐id) Loop
        Insert Into 病人预交记录
          (ID, NO, 实际票号, 记录性质, 记录状态, 病人id, 主页id, 科室id, 金额, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号, 收款时间, 操作员姓名, 操作员编号, 冲预交,
           结帐id, 缴款组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
          Select 病人预交记录_Id.Nextval, NO, 实际票号, 11, 记录状态, 病人id, 主页id, 科室id, Null, 结算方式, 结算号码, 摘要, 缴款单位, 单位开户行, 单位帐号,
                 d_Date, 操作员姓名_In, 操作员编号_In, Decode(Sign(r_Deposit.金额 - n_预交金额), -1, -1 * r_Deposit.金额, -1 * n_预交金额),
                 n_结帐id, n_组id, 预交类别, 卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, Decode(校对标志_In, 1, 2, 0), n_结算序号, 3, n_会话号
          From 病人预交记录
          Where ID = r_Deposit.Id;
      
        --检查是否已经处理完
        If r_Deposit.金额 < n_预交金额 Then
          n_预交金额 := n_预交金额 - r_Deposit.金额;
        Else
          n_预交金额 := 0;
        End If;
        If n_预交金额 = 0 Then
          Exit;
        End If;
      End Loop;
      If Nvl(校对标志_In, 0) = 0 Then
        --更新病人预交余额
        Update 病人余额
        Set 预交余额 = Nvl(预交余额, 0) + n_总金额 + Nvl(误差_In, 0)
        Where 病人id = n_病人id And 性质 = 1 And 类型 = 1
        Returning 预交余额 Into n_返回值;
        If Sql%RowCount = 0 Then
          Insert Into 病人余额 (病人id, 类型, 预交余额, 性质) Values (n_病人id, 1, n_总金额 + Nvl(误差_In, 0), 1);
          n_返回值 := n_总金额 + Nvl(误差_In, 0);
        End If;
        If Nvl(n_返回值, 0) = 0 Then
          Delete From 病人余额 Where 病人id = n_病人id And 性质 = 1 And Nvl(费用余额, 0) = 0 And Nvl(预交余额, 0) = 0;
        End If;
      End If;
    End If;
  End If;

  --更新原记录
  Update 病人预交记录 Set 记录状态 = 3 Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id;

  If 多单据全退_In <> 1 Then
    --处理误差项,多单据全退时 ,按原样退无误差处理
    --将误差项的记录状态调整为3
    If Nvl(误差_In, 0) <> 0 Then
      n_Count := 1;
      If n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
        n_原误差费 := 0;
        --原样退,但存在误差
        If n_部分退 = 0 Then
          Select -1 * Nvl(Sum(实收金额), 0)
          Into n_原误差费
          From 门诊费用记录 A
          Where NO = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And Nvl(a.附加标志, 0) = 9;
        End If;
        If Nvl(n_原误差费, 0) <> 0 Or Nvl(误差_In, 0) <> 0 Then
          Update 病人预交记录
          Set 冲预交 = 冲预交 - n_原误差费 - Nvl(误差_In, 0)
          Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
          If Sql%NotFound Then
            Insert Into 病人预交记录
              (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
               卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
              Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                     操作员姓名_In, -1 * n_原误差费 - Nvl(误差_In, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0,
                     n_结算序号, 3, n_会话号
              From 病人预交记录
              Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
          End If;
        End If;
      End If;
    Elsif n_正常退费 = 1 And Nvl(退款操作_In, 0) = 0 Then
      --原样退时,需要处理预交记录不足的情况
      Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
      Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
      If Abs(n_实收金额) <> Abs(n_返回值) Then
        n_实收金额 := n_实收金额 - n_返回值;
        Update 病人预交记录 Set 冲预交 = 冲预交 + Nvl(n_实收金额, 0) Where 结算方式 = v_退费结算 And 结帐id = n_结帐id;
        If Sql%NotFound Then
          Insert Into 病人预交记录
            (ID, 记录性质, NO, 记录状态, 病人id, 主页id, 摘要, 结算方式, 收款时间, 缴款单位, 单位开户行, 单位帐号, 操作员编号, 操作员姓名, 冲预交, 结帐id, 缴款组id, 预交类别,
             卡类别id, 结算卡序号, 卡号, 交易流水号, 交易说明, 合作单位, 校对标志, 结算序号, 结算性质, 会话号)
            Select 病人预交记录_Id.Nextval, 3, No_In, 2, 病人id, 主页id, '误差费', v_退费结算, d_Date, Null, Null, Null, 操作员编号_In,
                   操作员姓名_In, Nvl(n_实收金额, 0), n_结帐id, n_组id, 预交类别, Null, Null, Null, Null, Null, Null, 0, n_结算序号, 3,
                   n_会话号
            From 病人预交记录
            Where 记录性质 = 3 And 记录状态 In (1, 3) And 结帐id = n_原结帐id And Rownum = 1;
        End If;
      End If;
    End If;
  
    Select Nvl(Sum(Nvl(结帐金额, 0)), 0) Into n_实收金额 From 门诊费用记录 Where 结帐id = n_结帐id;
    Select Nvl(Sum(Nvl(冲预交, 0)), 0) Into n_返回值 From 病人预交记录 Where 结帐id = n_结帐id;
  
    n_实收金额 := n_实收金额 - n_返回值;
  
    If n_实收金额 <> 0 Then
      --未找到，新产生误差项
      Zl_门诊收费误差_Insert(No_In, n_实收金额, 1);
    End If;
  End If;
  ---------------------------------------------------------------------------------
  --人员缴款余额(注意是预交记录处理后才处理，包括个人帐户等的结算金额,不含退冲预交款)
  --如果是需要校对的,暂不处理人员缴款余额
  If Nvl(校对标志_In, 0) = 0 Then
    For r_Moneyrow In c_Money(n_结帐id) Loop
      Update 人员缴款余额
      Set 余额 = Nvl(余额, 0) + r_Moneyrow.冲预交
      Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式
      Returning 余额 Into n_返回值;
      If Sql%RowCount = 0 Then
        Insert Into 人员缴款余额
          (收款员, 结算方式, 性质, 余额)
        Values
          (操作员姓名_In, r_Moneyrow.结算方式, 1, r_Moneyrow.冲预交);
        n_返回值 := r_Moneyrow.冲预交;
      End If;
      If Nvl(n_返回值, 0) = 0 Then
        Delete From 人员缴款余额
        Where 收款员 = 操作员姓名_In And 性质 = 1 And 结算方式 = r_Moneyrow.结算方式 And Nvl(余额, 0) = 0;
      End If;
    End Loop;
  End If;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 0 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      
        Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And 记录性质 = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where 记录性质 = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_Delete;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_门诊收费记录_销帐
(
  No_In         门诊费用记录.No%Type,
  操作员编号_In 门诊费用记录.操作员编号%Type,
  操作员姓名_In 门诊费用记录.操作员姓名%Type,
  序号_In       Varchar2 := Null,
  退费时间_In   门诊费用记录.登记时间%Type := Null,
  退费摘要_In   门诊费用记录.摘要%Type := Null,
  结帐id_In     病人预交记录.结帐id%Type := Null,
  回收票据_In   Number := 0
) As
  --功能：删除一张门诊收费单据
  --参数：
  --        序号_IN           =要退费的项目序号,格式为"1,3,5,6...",缺省NULL表示退"未退的"所有行。
  --        回收票据_In       =0:全退或最后一次全退时,收回票据。
  --                           1:部份退费不处理票据,通过重打调用单独处理。
  --该游标为要退费单据的所有原始记录

  --医保全退但某种结算退现金从而产生了新的误差时,排开此处的误差处理,执行完本过程后,界面程序中单独处理新误差
  Cursor c_Bill Is
    Select a.Id, a.No, a.附加标志, a.收费细目id, a.序号, a.价格父号, a.执行状态, a.收费类别, a.付数, a.数次, a.医嘱序号, j.诊疗类别, m.跟踪在用,
           Nvl(a.附加标志, 0) As 误差, Nvl(j.医嘱状态, 0) As 医嘱状态
    From 门诊费用记录 A, 病人医嘱记录 J, 材料特性 M
    Where a.医嘱序号 = j.Id(+) And a.No = No_In And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.收费细目id + 0 = m.材料id(+)
    Order By a.收费细目id, a.序号;

  --:不管原始单据误差,都应该根据当前退费产生的误差项进行处理
  -- Decode(Sign(误差_In), 0, 999, 9)

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock Is
    Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
    From 药品收发记录
    Where NO = No_In And 单据 In (8, 24) --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 门诊费用记录
                   Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 In ('4', '5', '6', '7') --@@@
                         And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
    Order By 药品id;

  --该游标用于处理未发药品记录
  Cursor c_Spare Is
    Select NO, 库房id, 单据 From 未发药品记录 Where NO = No_In And 单据 In (8, 24); --@@@

  --该光标用于处理人员缴款余额中退的不同结算方式的金额

  n_结帐id 门诊费用记录.结帐id%Type;
  n_打印id 票据打印内容.Id%Type;

  --部分退费计算变量
  n_剩余数量 Number;
  n_剩余应收 Number;
  n_剩余实收 Number;
  n_剩余统筹 Number;
  n_备货卫材 Number;
  n_准退数量 Number;
  n_退费次数 Number;

  n_应收金额 Number;
  n_实收金额 Number;
  n_统筹金额 Number;
  n_总金额   Number;
  n_组id     财务缴款分组.Id%Type;

  l_费用id   t_Numlist := t_Numlist();
  l_药品收发 t_Numlist := t_Numlist();
  l_使用id   t_Numlist := t_Numlist();

  l_序号     t_Numlist := t_Numlist();
  l_执行状态 t_Numlist := t_Numlist();

  n_Dec   Number;
  d_Date  Date;
  n_Count Number;

  Err_Item Exception;
  v_Err_Msg  Varchar2(255);
  n_启用模式 Number(3);
  v_Para     Varchar2(1000);

Begin
  n_组id := Zl_Get组id(操作员姓名_In);
  --是否已经全部完全执行(只是该单据整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From 门诊费用记录
  Where NO = No_In And 记录性质 = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  --执行状态在原始记录上判断
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量, 结帐id
                From 门诊费用记录
                Where NO = No_In And Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 门诊费用记录
                       Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号), 结帐id)
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以退费的费用！';
    Raise Err_Item;
  End If;

  ---------------------------------------------------------------------------------
  --公用变量
  If 退费时间_In Is Not Null Then
    d_Date := 退费时间_In;
  Else
    Select Sysdate Into d_Date From Dual;
  End If;

  If 结帐id_In Is Null Then
    Select 病人结帐记录_Id.Nextval Into n_结帐id From Dual;
  Else
    n_结帐id := 结帐id_In;
  End If;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into n_Dec From Dual;

  --循环处理每行费用(收入项目行)
  n_总金额 := 0;
  For r_Bill In c_Bill Loop
    If Instr(',' || 序号_In || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or 序号_In Is Null Then
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into n_剩余数量, n_剩余应收, n_剩余实收, n_剩余统筹
        From 门诊费用记录
        Where NO = No_In And Mod(记录性质, 10) = 1 And 序号 = r_Bill.序号;
      
        If n_剩余数量 = 0 Then
          If 序号_In Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部退费！';
            Raise Err_Item;
          End If;
        Else
          --准退数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Or (r_Bill.收费类别 = '4' And Nvl(r_Bill.跟踪在用, 0) = 0) Then
            --@@@
            --非药品部分(以具体医嘱执行为准进行检查)
            --: 1.存在医嘱执行计价的,则以医嘱执行为准(但不能包含:检查;检验;手术;麻醉及输血),已执行的不允许退费
            --: 2.不存在医嘱执行计价的,则以剩余数量为准
            --: 3.医嘱作废了的,则以剩余数量为准(病人医嘱记录.医嘱状态=4表示作废医嘱，会删除"病人医嘱发送",门诊药嘱先作废后退药)
            n_Count := 0;
            If Instr(',C,D,F,G,K,', ',' || r_Bill.诊疗类别 || ',') = 0 And r_Bill.诊疗类别 Is Not Null And r_Bill.医嘱状态 <> 4 Then
              Select Nvl(Sum(Decode(c.执行状态, 0, 1, 0) * c.数量), 0), Count(1)
              Into n_准退数量, n_Count
              From 病人医嘱发送 B, 医嘱执行计价 C
              Where b.医嘱id = r_Bill.医嘱序号 And b.No = r_Bill.No And b.医嘱id = c.医嘱id And b.发送号 = c.发送号 And
                    c.收费细目id + 0 = r_Bill.收费细目id And b.记录性质 = 1;
            End If;
            If Nvl(n_Count, 0) <> 0 And n_准退数量 = 0 Then
              v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已执行，不允许退费！';
              Raise Err_Item;
            End If;
          
            If Nvl(n_Count, 0) = 0 Then
              If r_Bill.执行状态 = 2 Then
                --无医嘱执行计价的部分退费无法判断准退数量，不允许退费
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已部分执行，无法判断准退数量，不允许退费！';
                Raise Err_Item;
              Else
                n_准退数量 := n_剩余数量;
              End If;
            End If;
          
          Else
            Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
            Into n_准退数量, n_Count
            From 药品收发记录
            Where NO = No_In And 单据 In (8, 24) And Mod(记录状态, 3) = 1 --@@@
                  And 审核人 Is Null And 费用id = r_Bill.Id;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If n_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  n_准退数量 := n_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          If n_准退数量 > n_剩余数量 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')大于了剩余数量(' || n_剩余数量 || ')，不允许退费！';
            Raise Err_Item;
          End If;
          --收费的时候是负数数量的不检查准退数量是否小于零
          If n_准退数量 < 0 And Nvl(r_Bill.付数, 1) * r_Bill.数次 > 0 Then
            v_Err_Msg := '单据[' || No_In || '] 中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用的退费数量(' || n_准退数量 ||
                         ')小于了零，不允许退费！';
            Raise Err_Item;
          End If;
        
          --该笔项目第几次退费
          Select Nvl(Max(Abs(执行状态)), 0) + 1
          Into n_退费次数
          From 门诊费用记录
          Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 2 And Nvl(执行状态, 0) < 0 And 序号 = r_Bill.序号;
        
          --金额=剩余金额*(准退数/剩余数)
          n_应收金额 := Round(n_剩余应收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_实收金额 := Round(n_剩余实收 * (n_准退数量 / n_剩余数量), n_Dec);
          n_统筹金额 := Round(n_剩余统筹 * (n_准退数量 / n_剩余数量), n_Dec);
          n_总金额   := n_总金额 + n_实收金额;
        
          --插入退费记录
          Insert Into 门诊费用记录
            (ID, NO, 实际票号, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别, 病人科室id, 收费类别,
             收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人,
             执行状态, 费用状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 结帐id, 结帐金额, 保险项目否, 保险大类id, 统筹金额, 摘要, 是否上传, 保险编码, 费用类型, 结论,
             缴款组id)
            Select 病人费用记录_Id.Nextval, NO, 实际票号, 记录性质, 2, 序号, 从属父号, 价格父号, 病人id, 医嘱序号, 门诊标志, 姓名, 性别, 年龄, 标识号, 付款方式, 费别,
                   病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                   Decode(Sign(n_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * n_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价,
                   -1 * n_应收金额, -1 * n_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * n_退费次数, 1, 执行时间, 操作员编号_In, 操作员姓名_In,
                   发生时间, d_Date, n_结帐id, -1 * n_实收金额, 保险项目否, 保险大类id, -1 * n_统筹金额, Nvl(退费摘要_In, 摘要),
                   Decode(Nvl(附加标志, 0), 9, 1, 0), 保险编码, 费用类型, 结论, n_组id
            From 门诊费用记录
            Where ID = r_Bill.Id;
        
          --标记原费用记录
          l_序号.Extend;
          l_序号(l_序号.Count) := r_Bill.序号;
          l_执行状态.Extend;
          l_执行状态(l_执行状态.Count) := Case
                                    When Sign(n_准退数量 - n_剩余数量) = 0 Then
                                     0
                                    Else
                                     1
                                  End;
        End If;
      Else
        If 序号_In Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能退费！';
          Raise Err_Item;
        End If;
      End If;
    End If;
  End Loop;
  --标记原费用记录
  Forall I In 1 .. l_序号.Count
    Update 门诊费用记录
    Set 记录状态 = 3, 执行状态 = l_执行状态(I)
    Where Mod(记录性质, 10) = 1 And NO = No_In And 序号 = l_序号(I) And 记录状态 In (1, 3);

  l_序号.Delete;
  For c_结帐 In (Select Distinct b.结帐id
               From 门诊费用记录 A, 病人预交记录 B
               Where a.结帐id = b.结帐id And a.No = No_In And Mod(a.记录性质, 10) = 1 And a.记录状态 In (1, 3) And
                     Nvl(b.记录状态, 0) = 1) Loop
    l_序号.Extend;
    l_序号(l_序号.Count) := c_结帐.结帐id;
  End Loop;

  Forall I In 1 .. l_序号.Count
    Update 病人预交记录 Set 记录状态 = 3 Where 结帐id = l_序号(I) And Mod(记录性质, 10) <> 1;

  ---------------------------------------------------------------------------------
  --退费票据回收(仅全退时才回退,部分退是在重打过程中回收)
  If 回收票据_In = 1 Then
  
    --启用标志||NO;执行科室(条数);收据费目(首页汇总,条数);收费细目(条数)
    v_Para     := Nvl(zl_GetSysParameter('票据分配规则', 1121), '0||0;0;0,0;0');
    n_启用模式 := Zl_To_Number(Substr(v_Para, 1, 1));
    If n_启用模式 <> 0 Then
      --收回票据
      Select 使用id Bulk Collect
      Into l_使用id
      From (Select Distinct b.使用id From 票据打印明细 B Where b.No = No_In And Nvl(b.票种, 0) = 1);
    
      n_启用模式 := l_使用id.Count;
      If l_使用id.Count <> 0 Then
        --插入回收记录
        Forall I In 1 .. l_使用id.Count
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用人, 使用时间)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, 操作员姓名_In, d_Date
            From 票据使用明细 A
            Where ID = l_使用id(I) And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 Where 号码 = a.号码 And 票种 = a.票种 And Nvl(性质, 0) <> 1);
      
        Forall I In 1 .. l_使用id.Count
          Update 票据打印明细 Set 是否回收 = 1 Where 使用id = l_使用id(I) And Nvl(是否回收, 0) = 0;
      
      End If;
    End If;
    If n_启用模式 = 0 Then
      --获取单据最后一次的打印ID(可能是多张单据收费打印)
      Begin
        --性质=1，原因=6为退费打印票据(红票)，不回收
        Select ID
        Into n_打印id
        From (Select b.Id
               From 票据使用明细 A, 票据打印内容 B
               Where a.打印id = b.Id And a.性质 = 1 And a.原因 In (1, 3) And b.数据性质 = 1 And b.No = No_In
               Order By a.使用时间 Desc)
        Where Rownum < 2;
      Exception
        When Others Then
          Null;
      End;
      --可能以前没有打印,无收回
      If n_打印id Is Not Null Then
        --a.多张单据循环调用时只能收回一次
        Select Count(*) Into n_Count From 票据使用明细 Where 票种 = 1 And 性质 = 2 And 打印id = n_打印id;
        If n_Count = 0 Then
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1;
        Else
          --b.部分退费多次收回时,最后一次全退收回要排开已收回的
          Insert Into 票据使用明细
            (ID, 票种, 号码, 性质, 原因, 领用id, 打印id, 使用时间, 使用人)
            Select 票据使用明细_Id.Nextval, 票种, 号码, 2, 2, 领用id, 打印id, d_Date, 操作员姓名_In
            From 票据使用明细 A
            Where 打印id = n_打印id And 票种 = 1 And 性质 = 1 And Not Exists
             (Select 1 From 票据使用明细 B Where a.号码 = b.号码 And 打印id = n_打印id And 票种 = 1 And 性质 = 2);
        End If;
      End If;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --卫生材料
  For v_出库 In (Select ID, 药品id, 库房id, 批次, 批号, 产地, 实际数量, 付数, 发药方式, 灭菌效期, 效期, 商品条码, 内部条码, 费用id
               From 药品收发记录
               Where 单据 = 21 --@@@
                     And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                     费用id In (Select ID
                              From 门诊费用记录
                              Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 In (1, 3) And 收费类别 = '4' --@@@
                                    And (Instr(',' || 序号_In || ',', ',' || 序号 || ',') > 0 Or 序号_In Is Null))
               Order By 药品id) Loop
    --处理药品库存
    If v_出库.库房id Is Not Null Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
      Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
      If Sql%RowCount = 0 Then
        Insert Into 药品库存
          (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
        Values
          (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
           Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
           v_出库.商品条码, v_出库.内部条码);
      End If;
    End If;
  
    l_费用id.Extend;
    l_费用id(l_费用id.Count) := v_出库.费用id;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := v_出库.Id;
  End Loop;

  --药品相关内容
  For r_Stock In c_Stock Loop
    --处理药品库存
    If r_Stock.库房id Is Not Null Then
    
      Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
      Into n_备货卫材
      From Table(l_费用id)
      Where Column_Value = r_Stock.费用id;
      If Nvl(n_备货卫材, 0) = 0 Then
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码) --@@@
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期, r_Stock.商品条码, r_Stock.内部条码);
        End If;
      
        Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
      End If;
    End If;
    l_药品收发.Extend;
    l_药品收发(l_药品收发.Count) := r_Stock.Id;
  End Loop;

  --删除药品收发记录
  Forall I In 1 .. l_药品收发.Count
    Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;

  --未发药品记录
  For r_Spare In c_Spare Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From 药品收发记录
    Where NO = No_In And 单据 = r_Spare.单据 --@@@
          And Mod(记录状态, 3) = 1 And 审核人 Is Null And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
  
    If n_Count = 0 Then
      Delete From 未发药品记录
      Where 单据 = r_Spare.单据 --@@@
            And NO = No_In And Nvl(库房id, 0) = Nvl(r_Spare.库房id, 0);
    End If;
  End Loop;

  --医嘱处理
  --删除病人医嘱附费(最后一次删除时)
  For c_医嘱 In (Select Distinct 医嘱序号
               From 门诊费用记录
               Where NO = No_In And Mod(记录性质, 10) = 1 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, 执行状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 门诊费用记录
                  Where Mod(记录性质, 10) = 1 And Nvl(附加标志, 0) <> 9 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, 执行状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 1 And NO = No_In;
    End If;
  End Loop;

  --调整医嘱执行计价.执行状态 NULL-历史数据；0-未执行；1-已执行；2-已退费
  For c_费用 In (Select Distinct a.医嘱序号 As 医嘱id, a.收费细目id, b.发送号
               From 门诊费用记录 A, 病人医嘱发送 B
               Where a.医嘱序号 = b.医嘱id And a.No = b.No And a.记录性质 = 1 And a.记录状态 In (1, 3) And a.No = No_In And
                     (Instr(',' || 序号_In || ',', ',' || a.序号 || ',') > 0 Or 序号_In Is Null) And a.价格父号 Is Null And
                     b.记录性质 = 1) Loop
    Update 医嘱执行计价
    Set 执行状态 = 2
    Where 医嘱id = c_费用.医嘱id And 发送号 = c_费用.发送号 And 收费细目id = c_费用.收费细目id And 执行状态 = 0;
  End Loop;

  --场合_In    Integer:=0, --0:门诊;1-住院
  --性质_In    Integer:=1, --1-收费单;2-记帐单
  --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
  --No_In      门诊费用记录.No%Type,
  --医嘱ids_In Varchar2 := Null
  Zl_医嘱发送_计费状态_Update(0, 1, 2, No_In);
Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_门诊收费记录_销帐;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品库存_Update
(
  Id_In       In 药品收发记录.Id%Type,
  Delete_In   In Number := 0,
  冲销方式_In In Number := 0,
  发药标志_In In Number := 0,
  财务审核_In In Number := 0
) Is
  ----------------------------------------------------------------------------------------
  --功能:根据明细数据更新库存
  --关键：根据下可用库存参数决定是否处理可用数量
  --业务规则：按照模块分开处理数据，便于后期维护
  --过程适用范围：药品流通业务，涉及到产生药品收发记录明细后再更新库存表并重算库存表平均成本价的业务，该过程
  --只能由其他过程内部调用，不能作为单独过程直接执行
  --参数:
  --     Id_In:药品业务新增、删除、审核、冲销时产生收发记录明细的id
  --     Delete_in: 0--非删除操作业务（新增、审核、冲销） 1--删除操作业务
  --     冲销方式_In: 0--正常冲销方式 1-产生冲销申请单据 2-发送 3-回退 目前只有移库模块有效
  --     发药标志_in: 0--不标记  1--标记  此参数只有药品处方、部门发药模块有效
  --     财务审核_in:0,财务审核单据,1-其他业务
  ----------------------------------------------------------------------------------------
  v_下可用数量 Zlparameters.参数值%Type;
  n_可用数量   药品库存.实际数量%Type;
  n_实际数量   药品库存.实际数量%Type;
  n_零售金额   药品库存.实际金额%Type;
  n_差价       药品库存.实际差价%Type;
  n_时价分批   Number(1);
  n_成本价     药品收发记录.成本价%Type;
  n_零售价     药品库存.零售价%Type;

  n_库存数量   药品库存.实际数量%Type;
  n_库存平均价 药品库存.平均成本价%Type;
  n_总数量     药品收发记录.实际数量%Type;
  n_总成本价   药品收发记录.成本价%Type;

  --业务明细数据，把库存数据更新需要的数据都列出来
  Cursor c_Detail Is
    Select a.Id, a.记录状态, a.单据, a.No, a.序号, a.库房id, a.供药单位id, a.入出类别id, a.对方部门id, a.入出系数, Nvl(a.发药方式, 0) As 发药方式, a.药品id,
           Nvl(a.批次, 0) 批次, a.产地, a.批号, a.生产日期, a.效期, a.付数, Nvl(a.填写数量, 0) As 填写数量, a.实际数量, a.成本价, a.成本金额, a.扣率, a.零售价,
           Nvl(a.零售金额, 0) As 零售金额, Nvl(a.差价, 0) As 差价, a.配药人, a.配药日期, a.审核人, a.审核日期, a.灭菌日期, a.灭菌效期, a.批准文号, a.商品条码,
           a.内部条码, b.是否变价, a.单量, a.频次, a.摘要, Nvl(a.费用id, 0) As 费用id
    From 药品收发记录 A, 收费项目目录 B
    Where a.药品id = b.Id And a.Id = Id_In;

  v_Detail c_Detail%RowType;
Begin
  --取下可用库存参数
  Select zl_GetSysParameter(96) Into v_下可用数量 From Dual;

  For v_Detail In c_Detail Loop
    n_实际数量 := v_Detail.入出系数 * v_Detail.实际数量 * Nvl(v_Detail.付数, 1);
    If n_实际数量 Is Null Then
      n_实际数量 := 0;
    End If;
    n_零售金额 := v_Detail.入出系数 * v_Detail.零售金额;
    n_差价     := v_Detail.入出系数 * v_Detail.差价;
  
    --先取库存和单据的数量和成本价
    Begin
      Select Nvl(实际数量, 0), 平均成本价
      Into n_库存数量, n_库存平均价
      From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
    Exception
      When Others Then
        n_库存数量 := 0;
    End;
  
    If n_库存平均价 Is Null Or n_库存平均价 < 0 Then
      Select 成本价 Into n_库存平均价 From 药品规格 Where 药品id = v_Detail.药品id;
    
      If n_库存平均价 Is Null Or n_库存平均价 < 0 Then
        n_库存平均价 := 0;
      End If;
    End If;
  
    --外购入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，退库模式时在填单时要根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --冲销时直接按数量加减库存可用数量
    --用数量判断是入库还是退库
    If v_Detail.单据 = 1 Then
      If v_Detail.审核日期 Is Null Then
        --未审核单据，填单或删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --已审核或已冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            --退库要考虑填单时已经处理了可用数量
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --自制入库：对于自制药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于原料药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 2 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --协定入库：对于协定药品来说是入库，在填单时不处理可用数量，在审核时处理。特殊的，对于组成药来说是出库，在填单时根据参数处理可用数量，在审核则相反处理可用数量
    --删除单据时要把原料药预减的数量加回去
    --用入出系数判断是入库还是退库
    If v_Detail.单据 = 3 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.入出系数 < 0 Then
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --其他入库：正常业务是入库，在填单时不处理可用数量，在审核时处理。特殊的，负数入库模式时要根据参数处理可用数量，在审核时则相反处理可用数量
    --删除单据时要把填单时预减的加回去
    --用数量判断是入库还是退库
    If v_Detail.单据 = 4 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If n_实际数量 < 0 Then
            If v_下可用数量 = '1' Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          Else
            --普通入库
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --差价调整，成本价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 5 Then
      n_可用数量 := 0;
    End If;
  
    --移库：移库有两条单据，一条出库单据，一条入库单据；出库单据需要根据下可用库存参数决定是否下可用库存，如果是冲销则可用库存则相反处理
    --在填单不减可用数量时，在发送时预减可用数量，审核时不处理可用数量
    --申请冲销模式时也要根据参数来处理可用数量
    --填单时出库业务根据参数决定是否下库存，入库业务不下库存；删除时出库业务更加参数要把库存还回去，入库业务不还库存
    If v_Detail.单据 = 6 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          --新增、修改、发送、回退、冲销申请
          If v_Detail.记录状态 = 1 Then
            If 冲销方式_In = 2 Then
              --发送
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Elsif 冲销方式_In = 3 Then
              --回退
              If v_下可用数量 = '0' And v_Detail.入出系数 = -1 Then
                n_可用数量 := -1 * n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            Else
              --新增
              If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
                n_可用数量 := n_实际数量;
              Else
                n_可用数量 := 0;
              End If;
            End If;
          Else
            --申请冲销
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        Else
          --删除
          If v_Detail.记录状态 = 1 Then
            If v_下可用数量 = '1' And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Elsif v_Detail.配药日期 Is Not Null And v_Detail.入出系数 = -1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          Else
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := -1 * n_实际数量;
            Else
              n_可用数量 := 0;
            End If;
          End If;
        End If;
      Else
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = -1 Then
            --出的那笔
            n_可用数量 := 0;
          Else
            --入的那笔
            n_可用数量 := n_实际数量;
          End If;
        Else
          If 冲销方式_In = 0 Then
            --正常冲销审核
            n_可用数量 := n_实际数量;
          Else
            --申请冲销审核
            If v_下可用数量 = '1' And v_Detail.入出系数 = 1 Then
              n_可用数量 := 0;
            Else
              n_可用数量 := n_实际数量;
            End If;
          End If;
        End If;
      End If;
    End If;
  
    --领用：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 7 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --发药业务：在填单时固定处理可用数量，在审核时不处理
    --删除单据时要把填单时预减的加回去
    --不再发药标记的可用数量处理等同于删除，填单操作
    If v_Detail.单据 = 8 Or v_Detail.单据 = 9 Or v_Detail.单据 = 10 Then
      If v_Detail.审核日期 Is Null Then
        If Delete_In = 0 Then
          If 发药标志_In = 0 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := -1 * n_实际数量;
          End If;
        Else
          n_可用数量 := -1 * n_实际数量;
        End If;
      Else
        n_可用数量 := 0;
      End If;
    End If;
  
    --其他出库：正常业务是出库，在填单时根据参数处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    If v_Detail.单据 = 11 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_下可用数量 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_下可用数量 = '1' Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --冲销和审核
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_下可用数量 = '1' Then
            n_可用数量 := 0;
          Else
            n_可用数量 := n_实际数量;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --盘点：填单时盘盈业务不处理可用数量，盘亏业务固定处理可用数量，在审核时相反处理
    --删除单据时要把填单时预减的加回去
    --用入出系数区分盘盈盘亏业务
    If v_Detail.单据 = 12 Then
      If v_Detail.审核日期 Is Null Then
        --填单和删除
        If Delete_In = 0 Then
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          If v_Detail.入出系数 = -1 Then
            n_可用数量 := -1 * n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        End If;
      Else
        --审核和冲销
        If v_Detail.记录状态 = 1 Then
          --审核
          If v_Detail.入出系数 = '1' Then
            n_可用数量 := n_实际数量;
          Else
            n_可用数量 := 0;
          End If;
        Else
          --冲销
          n_可用数量 := n_实际数量;
        End If;
      End If;
    End If;
  
    --售价调价：不涉及库存数量变化，在填单时不处理，在审核时只处理金额，差价等数据
    If v_Detail.单据 = 13 Then
      n_可用数量 := 0;
    End If;
  
    --药品留存：产生发药单据时，已经下了库存，部门发药时，需要将库存加回去
    If v_Detail.单据 = 27 Then
      n_可用数量 := n_实际数量;
    End If;
  
    If v_Detail.批次 > 0 And v_Detail.是否变价 = 1 Then
      n_时价分批 := 1;
    Else
      n_时价分批 := 0;
    End If;
  
    n_零售价 := v_Detail.零售价;
    --特殊单据需要处理成本价 特殊单据有单据=5 单据=12
    If v_Detail.单据 = 5 Or v_Detail.单据 = 12 Then
      If v_Detail.单据 = 5 Then
        If v_Detail.填写数量 <> 0 Then
          n_零售价 := Nvl(v_Detail.零售价, 0) / v_Detail.填写数量;
        Else
          n_零售价 := 0;
        End If;
        --审核
        If v_Detail.记录状态 = 1 Then
          --差价调整发药方式=0；主动调价、退货、发药产生的调价修正发药方式=1
          n_成本价 := v_Detail.单量;
        Else
          --冲销 还原原始成本价
          Begin
            --成本价=(金额-差价)/数量
            n_成本价 := (Nvl(v_Detail.零售价, 0) - Nvl(v_Detail.成本价, 0)) / v_Detail.填写数量;
          Exception
            When Others Then
              Select 成本价 Into n_成本价 From 药品规格 Where 药品id = v_Detail.药品id;
          End;
        End If;
      Else
        n_成本价 := v_Detail.单量;
      End If;
    Else
      If v_Detail.单据 = 13 Then
        n_成本价 := Nvl(v_Detail.单量, 0) - Nvl(v_Detail.频次, 0);
      Else
        n_成本价 := v_Detail.成本价;
      End If;
    End If;
  
    --根据业务数据更新库存记录
    If v_Detail.审核日期 Is Null Then
      If n_可用数量 <> 0 Then
        --填单，删除时只更新可用数量
        Update 药品库存
        Set 可用数量 = 可用数量 + n_可用数量
        Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
      
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, 0, 0, 0, v_Detail.供药单位id, n_成本价,
             v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号, Decode(n_时价分批, 1, n_零售价, Null),
             v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    Else
      --审核时更新库存可用数量，实际数量，库存金额，库存差价等数据
      If v_Detail.单据 = 5 Then
        --单据=5 的成本价修正记录 平均成本价不需要重算，因为保存了最新价格的
        If v_Detail.摘要 = '外购退库差价误差自动修正' Or v_Detail.摘要 = '财务审核价格变动修正' Then
          --这一步肯定是外购退库，外购退库只更新成本价,且肯定有库存
          Update 药品库存
          Set 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        Else
          Update 药品库存
          Set 平均成本价 = n_成本价, 上次采购价 = n_成本价, 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          If Sql%NotFound Then
            Insert Into 药品库存
              (库房id, 药品id, 批次, 性质, 实际差价, 上次批号, 效期, 上次产地, 上次供应商id, 上次生产日期, 批准文号, 实际金额, 上次采购价, 平均成本价)
            Values
              (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, n_差价, v_Detail.批号, v_Detail.效期, v_Detail.产地,
               v_Detail.供药单位id, v_Detail.生产日期, v_Detail.批准文号, n_零售金额, n_成本价, n_成本价);
          
            Insert Into 药品入库信息
              (药品id, 库房id, 批次, 入库日期)
              Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
              From Dual
              Where Not Exists (Select 1
                     From 药品入库信息
                     Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
          End If;
        
          --调整药品批号对照表中的价格
          If v_Detail.摘要 = '成本价调价' Then
            Update 药品批号对照 Set 成本价 = n_成本价 Where 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
          End If;
        End If;
      Elsif v_Detail.单据 = 13 Then
        --单据=13 的售价修正记录 同步更新的金额和差价，所以不需要重算平均成本价
        If v_Detail.费用id = 0 Then
          Update 药品库存
          Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null), 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        Else
          --调价修正时不更新零售价
          Update 药品库存
          Set 实际金额 = Nvl(实际金额, 0) + n_零售金额, 实际差价 = Nvl(实际差价, 0) + n_差价
          Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        End If;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 零售价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, 1, 0, 0, n_零售金额, n_零售金额, Decode(n_时价分批, 1, n_零售价, Null));
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      
        --调整药品批号对照表中的价格
        If v_Detail.摘要 = '药品调价' Then
          Update 药品批号对照 Set 售价 = n_零售价 Where 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
        End If;
      Else
        --按入库和出库 状态分解
        --入库业务,出库冲销，不分批多种价格入库冲销需要更新库存表所有信息
        If (v_Detail.入出系数 = 1 And v_Detail.记录状态 = 1) Or (v_Detail.入出系数 = -1 And Mod(v_Detail.记录状态, 3) = 2) Or
           (v_Detail.入出系数 = 1 And Mod(v_Detail.记录状态, 3) = 2) Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 上次供应商id = v_Detail.供药单位id,
              上次采购价 = Decode(v_Detail.单据, 1, Decode(v_Detail.发药方式, 1, 上次采购价, n_成本价), n_成本价),
              上次批号 = Nvl(v_Detail.批号, 上次批号), 上次生产日期 = Nvl(v_Detail.生产日期, 上次生产日期), 上次产地 = Nvl(v_Detail.产地, 上次产地),
              灭菌效期 = Nvl(v_Detail.灭菌效期, 灭菌效期), 效期 = Nvl(v_Detail.效期, 效期), 批准文号 = Nvl(v_Detail.批准文号, 批准文号),
              上次扣率 = Decode(v_Detail.单据, 1, v_Detail.扣率, 上次扣率), 商品条码 = Nvl(v_Detail.商品条码, 商品条码),
              内部条码 = Nvl(v_Detail.内部条码, 内部条码)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        
          --104843：34版本入库时不更新零售价（如果是无库存的是通过插入新库存记录产生了价格，如果已存在了就不更新）
          /*          --外购入库和其他入库审核时
          If (v_Detail.单据 = 1 And v_Detail.记录状态 = 1 And 财务审核_In = 0) Or (v_Detail.单据 = 4 And v_Detail.记录状态 = 1) Then
            Update 药品库存
            Set 零售价 = Decode(n_时价分批, 1, n_零售价, Null)
            Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
          End If;*/
        
          --不分批入库需要重算成本价
          --外购退货、财务审核和所有冲销业务不更新平均成本价，保持当前价格
          If (v_Detail.单据 = 1 And v_Detail.发药方式 = 1) Or Mod(v_Detail.记录状态, 3) = 2 Or (v_Detail.单据 = 1 And 财务审核_In = 1) Then
            Null;
          Else
            --按总金额/总数量方式计算平均成本价而不用（金额-差价）/数量是为了数据的准确性
            n_总数量 := (n_库存数量 + n_实际数量);
            If n_总数量 <> 0 And v_Detail.批次 = 0 Then
              --104843：不分批的才重算，分批的不处理
              n_总成本价 := (n_库存数量 * n_库存平均价 + n_实际数量 * n_成本价) / n_总数量;
              Update 药品库存
              Set 平均成本价 = n_总成本价
              Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次;
            End If;
          End If;
        Else
          --出库业务只需要更新数量、金额、差价
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_可用数量, 实际数量 = Nvl(实际数量, 0) + n_实际数量, 实际金额 = Nvl(实际金额, 0) + n_零售金额,
              实际差价 = Nvl(实际差价, 0) + n_差价, 平均成本价 = Decode(平均成本价, Null, n_成本价, 平均成本价),
              上次采购价 = Decode(上次采购价, Null, n_成本价, 上次采购价)
          Where 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And 性质 = 1;
        End If;
        --库存表未找到数据则需要产生库存表所有信息
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 效期, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次生产日期, 上次产地, 灭菌效期, 批准文号, 零售价, 上次扣率,
             商品条码, 内部条码, 平均成本价)
          Values
            (v_Detail.库房id, v_Detail.药品id, v_Detail.批次, v_Detail.效期, 1, n_可用数量, n_实际数量, n_零售金额, n_差价, v_Detail.供药单位id,
             n_成本价, v_Detail.批号, v_Detail.生产日期, v_Detail.产地, v_Detail.灭菌效期, v_Detail.批准文号,
             Decode(n_时价分批, 1, n_零售价, Null), v_Detail.扣率, v_Detail.商品条码, v_Detail.内部条码, n_成本价);
        
          Insert Into 药品入库信息
            (药品id, 库房id, 批次, 入库日期)
            Select v_Detail.药品id, v_Detail.库房id, v_Detail.批次, v_Detail.审核日期
            From Dual
            Where Not Exists (Select 1
                   From 药品入库信息
                   Where 药品id = v_Detail.药品id And 库房id = v_Detail.库房id And 批次 = v_Detail.批次);
        End If;
      End If;
    End If;
  
    --删除多余的库存数据
    If 财务审核_In = 0 Then
      Delete From 药品库存
      Where 性质 = 1 And 库房id = v_Detail.库房id And 药品id = v_Detail.药品id And Nvl(批次, 0) = v_Detail.批次 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  
    Zl_药品库存_可用数量异常处理(v_Detail.库房id, v_Detail.药品id, v_Detail.批次);
  End Loop;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品库存_Update;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品留存记录_Insert
(
  期间_In       In 药品留存.期间%Type,
  汇总发药号_In In 药品收发记录.汇总发药号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  药品id_In     In 药品收发记录.药品id%Type,
  批次_In       In 药品收发记录.批次%Type := Null,
  实际数量_In   药品收发记录.实际数量%Type,
  零售价_In     In 药品收发记录.零售价%Type,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  Date_In       In 药品收发记录.审核日期%Type,
  领药部门id_In In 药品收发记录.对方部门id%Type
) Is
  Intdigit     Number(1);
  Nextid       Number;
  v_实际数量   药品收发记录.实际数量%Type;
  v_成本价     药品收发记录.成本价%Type;
  v_成本金额   药品收发记录.成本金额%Type;
  v_零售金额   药品收发记录.零售金额%Type;
  v_差价       药品收发记录.差价%Type;
  v_批号       药品收发记录.批号%Type;
  v_效期       药品收发记录.效期%Type;
  v_产地       药品收发记录.产地%Type;
  v_批准文号   药品收发记录.批准文号%Type;
  v_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID
  v_入出系数   药品收发记录.入出系数%Type; --入出系数
  v_零售价     药品收发记录.零售价%Type; --零售价
Begin
  --获取金额小数位数
  Select Nvl(精度, 2) Into Intdigit From 药品卫材精度 Where 性质 = 0 And 类别 = 1 And 内容 = 4 And 单位 = 5;

  Select Sum(实际数量 * 付数) 实际数量, Avg(成本价) 成本价, Sum(零售金额) 零售金额, Sum(成本金额) 成本金额, Sum(差价) 差价, Max(批号) 批号, Max(效期) 效期,
         Max(产地) 产地, Max(批准文号) 批准文号
  Into v_实际数量, v_成本价, v_零售金额, v_成本金额, v_差价, v_批号, v_效期, v_产地, v_批准文号
  From 药品收发记录
  Where 汇总发药号 = 汇总发药号_In And 单据 In (8, 9, 10) And 库房id = 库房id_In And 对方部门id = 领药部门id_In And 药品id = 药品id_In And
        Nvl(批次, 0) = 批次_In;

  Select 药品收发记录_Id.Nextval Into Nextid From Dual;

  v_差价     := Round((实际数量_In / v_实际数量) * v_差价, Intdigit);
  v_成本金额 := Round((实际数量_In / v_实际数量) * v_成本金额, Intdigit);
  v_零售金额 := Round((实际数量_In / v_实际数量) * v_零售金额, Intdigit);
  v_零售价   := Round(v_零售金额 / 实际数量_In, Intdigit);
  --取药品留存记录的入出类别
  Select b.Id, b.系数
  Into v_入出类别id, v_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 27 And Rownum < 2;

  --增加药品留存记录
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 汇总发药号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 填写数量, 实际数量, 零售价, 零售金额, 成本价, 成本金额, 差价, 填制日期, 填制人,
     审核日期, 审核人, 批号, 效期, 产地, 批准文号)
  Values
    (Nextid, 1, 27, Nextid, 汇总发药号_In, 库房id_In, 领药部门id_In, v_入出类别id, v_入出系数, 药品id_In, 批次_In, 实际数量_In, 实际数量_In, v_零售价,
     v_零售金额, v_成本价, v_成本金额, v_差价, Date_In, 填制人_In, Date_In, 填制人_In, v_批号, v_效期, v_产地, v_批准文号);

  --修改药品留存计划
  Update 药品留存计划
  Set 留存id = Nextid, 状态 = 1
  Where 部门id = 领药部门id_In And 库房id = 库房id_In And 药品id = 药品id_In And 状态 = 0;

  --更新药品留存
  Update 药品留存
  Set 可用数量 = 可用数量 + 实际数量_In, 实际数量 = 实际数量 + 实际数量_In, 实际金额 = 实际金额 + v_零售金额
  Where 期间 = 期间_In And 科室id = 领药部门id_In And 库房id = 库房id_In And 药品id = 药品id_In;

  --如果没有库存则增加
  If Sql%NotFound Then
    Insert Into 药品留存
      (期间, 科室id, 库房id, 药品id, 可用数量, 实际数量, 实际金额)
    Values
      (期间_In, 领药部门id_In, 库房id_In, 药品id_In, 实际数量_In, 实际数量_In, v_零售金额);
  End If;

  --清除数量金额为零的记录
  Delete From 药品留存 Where 实际数量 = 0 And 实际金额 = 0;

  --增加药品库存
  Update 药品库存
  Set 可用数量 = Nvl(可用数量, 0) + Nvl(实际数量_In, 0), 实际数量 = Nvl(实际数量, 0) + Nvl(实际数量_In, 0), 实际金额 = Nvl(实际金额, 0) + Nvl(v_零售金额, 0),
      实际差价 = Nvl(实际差价, 0) + Nvl(v_差价, 0)
  Where 库房id = 库房id_In And 药品id = 药品id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;

  If Sql%NotFound Then
    Insert Into 药品库存
      (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 效期, 上次产地, 批准文号)
    Values
      (库房id_In, 药品id_In, 批次_In, 1, 实际数量_In, 实际数量_In, v_零售金额, v_差价, v_批号, v_效期, v_产地, v_批准文号);
  End If;

  Zl_药品库存_可用数量异常处理(库房id_In, 药品id_In, 批次_In);
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品留存记录_Insert;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品收发记录_部门发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Billid_In        In 药品收发记录.Id%Type,
  People_In        In 药品收发记录.审核人%Type,
  Date_In          In 药品收发记录.审核日期%Type,
  批次_In          In 药品收发记录.批次%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 3,
  领药人_In        In 药品收发记录.领用人%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0
) Is
  --只读变量
  Lng入出类别id Number(18);
  Int入出系数   Number;
  Int执行状态   Number;
  Int单据       药品收发记录.单据%Type;
  Strno         药品收发记录.No%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Lng费用id     药品收发记录.费用id%Type;
  v_零售价      药品收发记录.零售价%Type;
  Dbl差价率     Number;
  Int未发数     未发药品记录.未发数%Type;
  n_药品id      药品收发记录.药品id%Type;
  --可写变量
  Dbl实际数量 药品收发记录.实际数量%Type;
  Dbl实际金额 药品收发记录.零售金额%Type;
  Dbl成本金额 药品收发记录.成本金额%Type;
  Dbl实际差价 药品收发记录.差价%Type;
  --2002-07-31朱玉宝
  --LNGLAST批次 发药前确定的批次(已减可用数量)
  Str药名           Varchar2(200);
  Dbl可用数量       药品收发记录.填写数量%Type;
  Lnglast批次       药品收发记录.批次%Type;
  Lngcur批次        药品收发记录.批次%Type;
  Bln收费与发药分离 Number(1);
  v_Error           Varchar2(255);
  Err_Custom Exception;

  Str批号        药品收发记录.批号%Type;
  Str效期        药品收发记录.效期%Type;
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次采购价   药品库存.上次采购价%Type;
  v_上次产地     药品库存.上次产地%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_批准文号     药品库存.批准文号%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_记录状态     药品收发记录.记录状态%Type;

  --自动审核费用
  Int序号   住院费用记录.序号%Type;
  Lng病人id 住院费用记录.病人id%Type;
Begin
  --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
  Begin
    Select a.单据, a.No, a.药品id, a.库房id, a.费用id, Nvl(a.零售价, 0), Nvl(a.零售金额, 0), Nvl(a.实际数量, 0) * Nvl(a.付数, 1), a.入出类别id,
           a.入出系数, Nvl(a.批次, 0), a.药品id, a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, a.记录状态
    Into Int单据, Strno, Lng药品id, Lng库房id, Lng费用id, v_零售价, Dbl实际金额, Dbl实际数量, Lng入出类别id, Int入出系数, Lnglast批次, n_药品id, Str批号,
         Str效期, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_记录状态
    From 药品收发记录 A
    Where a.Id = Billid_In And a.审核日期 Is Null
    For Update Nowait;
  
    Select '[' || 编码 || ']' || 名称 Into Str药名 From 收费项目目录 Where ID = n_药品id;
  Exception
    When Others Then
      Int单据 := 0;
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  If Int单据 > 0 Then
    If Nvl(批次_In, 0) = 0 Then
      Lngcur批次 := Lnglast批次;
    Else
      Lngcur批次 := Nvl(批次_In, 0);
    End If;
  
    --检查是否已经填写库房
    Bln收费与发药分离 := 0;
    If Lng库房id Is Null Then
      Bln收费与发药分离 := 1;
    End If;
    Lng库房id := Partid_In;
  
    --取该批药品的批号
    Begin
      Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价
      Into Str批号, Str效期, Dbl可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价
      From 药品库存
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    Exception
      When Others Then
        Dbl可用数量  := 0;
        n_上次采购价 := 0;
    End;
  
    --可用数量不足则退出
    If Lngcur批次 <> Nvl(Lnglast批次, 0) Then
      If Dbl可用数量 < Dbl实际数量 And Lngcur批次 <> 0 Then
        v_Error := Str药名 || '的可用数量不足，操作中止！';
        Raise Err_Custom;
      End If;
    End If;
  
    --计算该药品收发记录的成本价、成本金额、零售金额及差价(先计算零售金额，再计算差价，最后计算成本金额及成本价)
    If n_记录状态 = 1 Then
      --原始发药记录，取最新价格
      n_平均成本价 := Round(Zl_Fun_Getoutcost(Lng药品id, Lngcur批次, Lng库房id), 5);
    Else
      --退药再发记录，取原始单据价格
      Select a.成本价
      Into n_平均成本价
      From 药品收发记录 A, 药品收发记录 B
      Where b.Id = Billid_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
            a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
    End If;
  
    Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), Intdigit_In);
    Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
  
    --更新药品收发记录的零售金额、成本金额及差价
    Update 药品收发记录
    Set 库房id = Lng库房id, 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 批次 = Lngcur批次, 批号 = Str批号, 效期 = Str效期,
        审核人 = People_In, 审核日期 = Date_In, 发药方式 = 发药方式_In, 领用人 = 领药人_In, 汇总发药号 = 汇总发药号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地,
        生产日期 = d_上次生产日期, 批准文号 = v_批准文号
    Where ID = Billid_In;
    --并发操作检查
    If Sql%RowCount = 0 Then
      v_Error := '要发药的药品记录"' || Str药名 || '"不存在，操作中止！';
      Raise Err_Custom;
    End If;
  
    --更改所有已发药处方的配药人为发药人
    Update 药品收发记录
    Set 配药人 = People_In
    Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And 审核人 Is Not Null And Mod(记录状态, 3) = 1;
  
    --更新原批次库存的可用数量
    --更新发药批次库存的可用及实际数量
    If Lnglast批次 <> Lngcur批次 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Dbl实际数量
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lnglast批次;
    
      Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lnglast批次);
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    
      Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lngcur批次);
    End If;
  
    If Bln收费与发药分离 = 1 Then
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量, 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额,
          实际差价 = Nvl(实际差价, 0) - Dbl实际差价
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    Else
      Update 药品库存
      Set 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额, 实际差价 = Nvl(实际差价, 0) - Dbl实际差价
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
    End If;
  
    If Sql%RowCount = 0 Then
      If n_上次采购价 = 0 Then
        If Dbl实际数量 = 0 Then
          Dbl实际数量 := 1;
        End If;
        n_上次采购价 := Round(Dbl成本金额 / Dbl实际数量, 5);
      End If;
    
      If Bln收费与发药分离 = 1 Then
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
        Values
          (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, n_上次供应商id, n_上次采购价, Str批号,
           v_上次产地, Str效期, d_上次生产日期, v_批准文号, n_上次采购价);
      Else
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价)
        Values
          (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, n_上次供应商id, n_上次采购价, Str批号, v_上次产地,
           Str效期, d_上次生产日期, v_批准文号, n_上次采购价);
      End If;
    End If;
  
    Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lngcur批次);
  
    Delete 药品库存
    Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
  
    --更新费用记录的执行状态(已执行)
    Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
    Into Int执行状态
    From 药品收发记录
    Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Null And 记录状态 <> 1 And Mod(记录状态, 3) <> 0;
    Update 住院费用记录
    Set 执行状态 = Int执行状态, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = Date_In
    Where ID = Lng费用id;
  
    --更新未发药品记录(如果未发数为零则删除)
    Select Count(*)
    Into Int未发数
    From 药品收发记录
    Where 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And NO = Strno And 审核人 Is Null And
          Nvl(LTrim(RTrim(摘要)), '小宝') <> '拒发';
  
    If Int未发数 = 0 Then
      Delete 未发药品记录 Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null);
    End If;
  
    --费用审核（重复审核也没有关系）
    If Intautoverify_In = 1 Then
      Select 序号, 病人id, NO
      Into Int序号, Lng病人id, Strno
      From 住院费用记录
      Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In);
    
      Zl_住院记帐记录_Verify(Strno, 操作员编号_In, 操作员姓名_In, Int序号, Lng病人id, Date_In);
    End If;
  
    --处理调价修正
    Zl_药品收发记录_调价修正(Billid_In);
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_部门发药;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
--118445:李业庆,2018-03-06,时价分批无库存发药后库存零售价字段为空处理
Create Or Replace Procedure Zl_药品收发记录_处方发药
(
  Partid_In        In 药品收发记录.库房id%Type,
  Bill_In          In 药品收发记录.单据%Type,
  No_In            In 药品收发记录.No%Type,
  People_In        In 药品收发记录.审核人%Type,
  配药人_In        In 药品收发记录.配药人%Type := Null,
  校验人_In        In 药品收发记录.填制人%Type := Null,
  发药方式_In      In 药品收发记录.发药方式%Type := 1,
  发药时间_In      In 药品收发记录.审核日期%Type := Null,
  操作员编号_In    In 人员表.编号%Type := Null,
  操作员姓名_In    In 人员表.姓名%Type := Null,
  Intdigit_In      In Number := 2,
  Intautoverify_In In Number := 0,
  门诊_In          In Number := 1,
  核查人_In        In 药品收发记录.核查人%Type := Null,
  未取药_In        In 药品收发记录.是否未取药%Type := Null,
  汇总发药号_In    In 药品收发记录.汇总发药号%Type := Null
) Is
  --住院病人
  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, a.记录状态, Nvl(d.是否变价, 0) As 时价
    From 药品收发记录 A, 住院费用记录 B, 未发药品记录 C, 收费项目目录 D
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.药品id = d.Id
    Order By a.药品id;

  --门诊病人
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, b.病人id, b.序号, Nvl(c.处方类型, Nvl(a.注册证号, 0)) 处方类型,
           Nvl(a.零售价, 0) As 零售价, b.No, b.记录性质, a.记录状态, Nvl(d.是否变价, 0) As 时价
    From 药品收发记录 A, 门诊费用记录 B, 未发药品记录 C, 收费项目目录 D
    Where a.单据 = c.单据 And a.No = c.No And Nvl(a.库房id, 0) = Nvl(c.库房id, 0) And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Partid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And
          Nvl(b.执行状态, 0) <> 1 And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.药品id = d.Id
    Order By a.药品id;

  v_Modifybillin  c_Modifybillin%RowType;
  v_Modifybillout c_Modifybillout%RowType;

  --只读变量
  Dbl差价率  Number;
  v_核查日期 药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际金额       药品收发记录.零售金额%Type;
  Dbl成本金额       药品收发记录.成本金额%Type;
  Dbl实际差价       药品收发记录.差价%Type;
  Date操作时间      药品收发记录.审核日期%Type;
  Bln收费与发药分离 Number(1);
  n_平均成本价      药品库存.平均成本价%Type;
  v_填制人          药品收发记录.填制人%Type;
  v_配药人          药品收发记录.配药人%Type;
  v_配药日期        药品收发记录.配药日期%Type;
  v_Error           Varchar2(4000);
  Err_Custom Exception;
  n_时价分批 Number(1) := 0;
Begin
  --取发药时间
  If 发药时间_In Is Null Then
    Select Sysdate Into Date操作时间 From Dual;
  Else
    Date操作时间 := 发药时间_In;
  End If;

  v_核查日期 := Date操作时间;
  Begin
    Select 0 Into Bln收费与发药分离 From 未发药品记录 Where 单据 = Bill_In And NO = No_In And 库房id + 0 = Partid_In;
  Exception
    When Others Then
      Bln收费与发药分离 := 1;
  End;

  --重写已发药处方的配药人
  Update 药品收发记录
  Set 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In), 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间), 汇总发药号 = 汇总发药号_In
  Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Not Null;

  --修正退发药品“配药人”和“配药日期”可能为空的情况
  Begin
    If 配药人_In Is Null Then
      Select 配药人, 配药日期
      Into v_配药人, v_配药日期
      From 药品收发记录
      Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And
            配药人 Is Not Null And Rownum = 1
      Order By 记录状态 Desc;
    
      Update 药品收发记录
      Set 配药人 = v_配药人, 配药日期 = v_配药日期
      Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null) And Mod(记录状态, 3) = 1 And 审核人 Is Null;
    End If;
  Exception
    When Others Then
      v_配药人   := Null;
      v_配药日期 := Null;
  End;

  Begin
    Select 填制人
    Into v_填制人
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Partid_In And 审核日期 Is Null And Rownum = 1
    For Update Nowait;
  Exception
    When Others Then
      v_Error := '已有其他用户在执行发药，不能重复操作！';
      Raise Err_Custom;
  End;

  --重新计算成本价、成本金额、零售金额及差价
  If 门诊_In = 1 Then
    --处理门诊数据
    For v_Modifybillout In c_Modifybillout Loop
      If v_Modifybillout.时价 = 1 And v_Modifybillout.批次 > 0 Then
        n_时价分批 := 1;
      Else
        n_时价分批 := 0;
      End If;
    
      If v_Modifybillout.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillout.药品id, v_Modifybillout.批次, Partid_In), 5);
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillout.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      End If;
    
      Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillout.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillout.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillout.处方类型, 是否未取药 = 未取药_In, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillout.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价,
            平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价), 上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价),
            零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_Modifybillout.零售价, 零售价), 零售价)
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillout.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillout.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价, 平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价),
            上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价),
            零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_Modifybillout.零售价, 零售价), 零售价)
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillout.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价, 零售价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.数量, 0), 0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id,
             n_平均成本价, v_Modifybillout.批号, v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期,
             v_Modifybillout.批准文号, n_平均成本价, Decode(n_时价分批, 1, v_Modifybillout.零售价, Null));
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价, 零售价)
          Values
            (Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次, 1, 0 - Nvl(v_Modifybillout.数量, 0),
             0 - Nvl(v_Modifybillout.金额, 0), 0 - Dbl实际差价, v_Modifybillout.供药单位id, n_平均成本价, v_Modifybillout.批号,
             v_Modifybillout.产地, v_Modifybillout.效期, v_Modifybillout.生产日期, v_Modifybillout.批准文号, n_平均成本价,
             Decode(n_时价分批, 1, v_Modifybillout.零售价, Null));
        End If;
      End If;
    
      Zl_药品库存_可用数量异常处理(Partid_In, v_Modifybillout.药品id, v_Modifybillout.批次);
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillout.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 门诊费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      
      Where NO = v_Modifybillout.No And Mod(记录性质, 10) = v_Modifybillout.记录性质 And 记录状态 <> 2 And 序号 = v_Modifybillout.序号;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_门诊记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillout.序号, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillout.Id);
    End Loop;
  Else
    --处理住院数据
    For v_Modifybillin In c_Modifybillin Loop
      If v_Modifybillin.时价 = 1 And v_Modifybillin.批次 > 0 Then
        n_时价分批 := 1;
      Else
        n_时价分批 := 0;
      End If;
    
      If v_Modifybillin.记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Round(Zl_Fun_Getoutcost(v_Modifybillin.药品id, v_Modifybillin.批次, Partid_In), 5);
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = v_Modifybillin.Id And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      End If;
    
      Dbl成本金额 := Round(n_平均成本价 * Nvl(v_Modifybillin.数量, 0), Intdigit_In);
      --零售金额
      Dbl实际金额 := Nvl(v_Modifybillin.金额, 0);
      --差价
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额、差价、审核人等信息
      Update 药品收发记录
      Set 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 库房id = Partid_In, 配药人 = Decode(配药人_In, Null, 配药人, 配药人_In),
          核查人 = 核查人_In, 核查日期 = v_核查日期, 配药日期 = Decode(配药人_In, Null, 配药日期, Date操作时间),
          填制人 = Decode(校验人_In, Null, 填制人, 校验人_In), 审核人 = Decode(People_In, Null, Zl_Username, People_In),
          审核日期 = Date操作时间, 发药方式 = 发药方式_In, 注册证号 = v_Modifybillin.处方类型, 汇总发药号 = 汇总发药号_In
      Where ID = v_Modifybillin.Id;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0),
            实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0), 实际差价 = Nvl(实际差价, 0) - Dbl实际差价,
            平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价), 上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价),
            零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_Modifybillin.零售价, 零售价), 零售价)
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Nvl(v_Modifybillin.数量, 0), 实际金额 = Nvl(实际金额, 0) - Nvl(v_Modifybillin.金额, 0),
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价, 平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价),
            上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价),
            零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_Modifybillin.零售价, 零售价), 零售价)
        Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybillin.批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价, 零售价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.数量, 0), 0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id, n_平均成本价,
             v_Modifybillin.批号, v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期, v_Modifybillin.批准文号, n_平均成本价,
             Decode(n_时价分批, 1, v_Modifybillin.零售价, Null));
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 平均成本价, 零售价)
          Values
            (Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次, 1, 0 - Nvl(v_Modifybillin.数量, 0),
             0 - Nvl(v_Modifybillin.金额, 0), 0 - Dbl实际差价, v_Modifybillin.供药单位id, n_平均成本价, v_Modifybillin.批号,
             v_Modifybillin.产地, v_Modifybillin.效期, v_Modifybillin.生产日期, v_Modifybillin.批准文号, n_平均成本价,
             Decode(n_时价分批, 1, v_Modifybillin.零售价, Null));
        End If;
      End If;
    
      Zl_药品库存_可用数量异常处理(Partid_In, v_Modifybillin.药品id, v_Modifybillin.批次);
    
      Delete 药品库存
      Where 库房id + 0 = Partid_In And 药品id = v_Modifybillin.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
    
      --更新费用记录的执行状态(已执行)
      Update 住院费用记录
      Set 执行状态 = 1, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行部门id = Partid_In, 执行时间 = Date操作时间
      
      Where ID = v_Modifybillin.费用id;
    
      --费用审核（重复审核也没有关系）
      If Intautoverify_In = 1 Then
        If Bill_In = 9 Then
          Zl_住院记帐记录_Verify(No_In, 操作员编号_In, 操作员姓名_In, v_Modifybillin.序号, v_Modifybillin.病人id, 发药时间_In);
        End If;
      End If;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(v_Modifybillin.Id);
    End Loop;
  End If;

  --更新或删除未发药品记录
  Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And (库房id + 0 = Partid_In Or 库房id Is Null);

  If Bill_In = 8 Then
    Begin
      --移动支付宝项目在发药后动态调用生成推送信息的过程
      Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
        Using 6, No_In || ',' || Partid_In;
    Exception
      When Others Then
        Null;
    End;
  End If;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_处方发药;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品收发记录_更改库房
(
  Partid_In       In 药品收发记录.库房id%Type,
  Bill_In         In 药品收发记录.单据%Type,
  No_In           In 药品收发记录.No%Type,
  Otherstockid_In In 药品收发记录.库房id%Type,
  门诊_In         In Number := 1,
  Date_In         In 药品收发记录.填制日期%Type := Null
) Is
  --重新计算用
  Cursor c_Modifybillout Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 门诊费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null
    Order By a.药品id;

  Cursor c_Modifybillin Is
    Select a.Id, a.药品id, a.入出类别id, a.入出系数, a.费用id, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) 数量, Nvl(a.零售金额, 0) 金额, Nvl(a.批次, 0) 批次,
           a.供药单位id, a.成本价, a.零售价, a.批号, a.产地, a.效期, a.生产日期, a.批准文号, c.是否变价, c.类别
    From 药品收发记录 A, 住院费用记录 B, 收费项目目录 C
    Where a.药品id = c.Id And a.No = No_In And a.单据 = Bill_In And (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And
          Nvl(a.摘要, '小宝') <> '拒发' And a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.审核人 Is Null
    Order By a.药品id;

  --用于修正病人未结费用
  Cursor c_Billout Is
    Select b.实收金额, b.病人id, 0 主页id, 0 病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 门诊费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1
    Order By a.药品id;

  Cursor c_Billin Is
    Select b.实收金额, b.病人id, b.主页id, b.病人病区id, b.病人科室id, b.开单部门id, b.执行部门id, b.收入项目id, b.门诊标志
    From 药品收发记录 A, 住院费用记录 B
    Where a.费用id = b.Id And Nvl(b.执行状态, 0) <> 1 And a.No = No_In And a.单据 = Bill_In And
          (a.库房id + 0 = Otherstockid_In Or a.库房id Is Null) And Nvl(a.摘要, '小宝') <> '拒发' And a.审核人 Is Null And b.记录性质 = 2 And
          b.记录状态 = 1
    Order By a.药品id;

  r_Modifybillout c_Modifybillout%RowType;
  r_Modifybillin  c_Modifybillin%RowType;
  r_Billout       c_Billout%RowType;
  r_Billin        c_Billin%RowType;
  v_Count         Number;
  n_成本价        药品收发记录.成本价%Type;
  n_零售价        药品收发记录.零售价%Type;
Begin
  --增加原库房的可以库存，减现库房的可用库存
  If 门诊_In = 1 Then
    --处理门诊
    For r_Modifybillout In c_Modifybillout Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      Zl_药品库存_可用数量异常处理(Otherstockid_In, r_Modifybillout.药品id, r_Modifybillout.批次);
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillout.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillout.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillout.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillout.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillout.药品id, r_Modifybillout.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillout.成本价;
        End If;
      
        If r_Modifybillout.是否变价 = 1 And r_Modifybillout.批次 > 0 Then
          --药品/卫材时价分批
          n_零售价 := r_Modifybillout.零售价;
        Else
          n_零售价 := Null;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillout.药品id, r_Modifybillout.批次, 1, 0 - Nvl(r_Modifybillout.数量, 0), 0, 0,
           r_Modifybillout.供药单位id, n_成本价, r_Modifybillout.批号, r_Modifybillout.产地, r_Modifybillout.效期,
           r_Modifybillout.生产日期, r_Modifybillout.批准文号, n_零售价, n_成本价);
      End If;
    
      Zl_药品库存_可用数量异常处理(Partid_In, r_Modifybillout.药品id, r_Modifybillout.批次);
    End Loop;
  Else
    --处理住院
    For r_Modifybillin In c_Modifybillin Loop
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) + Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Otherstockid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      Zl_药品库存_可用数量异常处理(Otherstockid_In, r_Modifybillin.药品id, r_Modifybillin.批次);
    
      Update 药品库存
      Set 可用数量 = Nvl(可用数量, 0) - Nvl(r_Modifybillin.数量, 0)
      Where 库房id + 0 = Partid_In And 药品id = r_Modifybillin.药品id And 性质 = 1 And Nvl(批次, 0) = r_Modifybillin.批次;
    
      If Sql%RowCount = 0 Then
        If r_Modifybillin.成本价 Is Null Then
          n_成本价 := Round(Zl_Fun_Getoutcost(r_Modifybillin.药品id, r_Modifybillin.批次, Partid_In), 7);
        Else
          n_成本价 := r_Modifybillin.成本价;
        End If;
      
        If r_Modifybillin.是否变价 = 1 And r_Modifybillin.批次 > 0 Then
          --药品卫材时价分批
          n_零售价 := r_Modifybillin.零售价;
        Else
          n_零售价 := Null;
        End If;
      
        Insert Into 药品库存
          (库房id, 药品id, 批次, 性质, 可用数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号, 零售价, 平均成本价)
        Values
          (Partid_In, r_Modifybillin.药品id, r_Modifybillin.批次, 1, 0 - Nvl(r_Modifybillin.数量, 0), 0, 0,
           r_Modifybillin.供药单位id, n_成本价, r_Modifybillin.批号, r_Modifybillin.产地, r_Modifybillin.效期, r_Modifybillin.生产日期,
           r_Modifybillin.批准文号, n_零售价, n_成本价);
      End If;
    
      Zl_药品库存_可用数量异常处理(Partid_In, r_Modifybillin.药品id, r_Modifybillin.批次);
    End Loop;
  End If;

  --处理发其它药房处方情况，改变库房ID
  If 门诊_In = 1 Then
    --处理门诊
    For r_Billout In c_Billout Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billout.实收金额, 0)
      Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
            Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
            Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Nvl(r_Billout.执行部门id, 0) And
            收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billout.实收金额, 0)
        Where 病人id = r_Billout.病人id And Nvl(主页id, 0) = Nvl(r_Billout.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billout.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billout.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billout.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And
              收入项目id + 0 = r_Billout.收入项目id And 来源途径 + 0 = r_Billout.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billout.病人id, r_Billout.病人科室id, r_Billout.开单部门id, Partid_In, r_Billout.收入项目id, r_Billout.门诊标志,
             Nvl(r_Billout.实收金额, 0));
        End If;
      End If;
    End Loop;
  Else
    --处理住院
    For r_Billin In c_Billin Loop
      --减原库房的未结费用
      Update 病人未结费用
      Set 金额 = Nvl(金额, 0) - Nvl(r_Billin.实收金额, 0)
      Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And
            Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And
            Nvl(执行部门id, 0) = Nvl(r_Billin.执行部门id, 0) And 收入项目id + 0 = r_Billin.收入项目id And 来源途径 + 0 = r_Billin.门诊标志;
    
      If Sql%RowCount <> 0 Then
        --增加现库房的未结费用
        Update 病人未结费用
        Set 金额 = Nvl(金额, 0) + Nvl(r_Billin.实收金额, 0)
        Where 病人id = r_Billin.病人id And Nvl(主页id, 0) = Nvl(r_Billin.主页id, 0) And
              Nvl(病人病区id, 0) = Nvl(r_Billin.病人病区id, 0) And Nvl(病人科室id, 0) = Nvl(r_Billin.病人科室id, 0) And
              Nvl(开单部门id, 0) = Nvl(r_Billin.开单部门id, 0) And Nvl(执行部门id, 0) = Partid_In And 收入项目id + 0 = r_Billin.收入项目id And
              来源途径 + 0 = r_Billin.门诊标志;
      
        If Sql%RowCount = 0 Then
          Insert Into 病人未结费用
            (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
          Values
            (r_Billin.病人id, r_Billin.主页id, r_Billin.病人病区id, r_Billin.病人科室id, r_Billin.开单部门id, Partid_In,
             r_Billin.收入项目id, r_Billin.门诊标志, Nvl(r_Billin.实收金额, 0));
        End If;
      End If;
    End Loop;
  End If;

  Delete From 病人未结费用 Where 金额 = 0;

  If 门诊_In = 1 Then
    Update 门诊费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  Else
    Update 住院费用记录
    Set 执行部门id = Partid_In
    Where ID In
          (Select Distinct 费用id From 药品收发记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In);
  End If;

  --修改该单据所有记录(退药后再代发的情况)
  Update 药品收发记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;

  --修改未发药品记录
  Begin
    Select 1 Into v_Count From 未发药品记录 Where 库房id + 0 = Partid_In And NO = No_In And 单据 = Bill_In;
  Exception
    When Others Then
      v_Count := 0;
  End;

  If v_Count = 0 Then
    Update 未发药品记录 Set 库房id = Partid_In Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  Else
    Delete 未发药品记录 Where NO = No_In And 单据 = Bill_In And 库房id + 0 = Otherstockid_In;
  End If;

  If Date_In Is Not Null Then
    Delete From 病人费用汇总 Where 日期 >= Date_In;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_更改库房;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
--118445:李业庆,2018-03-06,时价分批无库存发药后库存零售价字段为空处理
Create Or Replace Procedure Zl_药品收发记录_批量发药
(
  Billinfo_In   In Varchar2, --格式:"id1,批次1|id2,批次2|....."
  Partid_In     In 药品收发记录.库房id%Type,
  People_In     In 药品收发记录.审核人%Type,
  Date_In       In 药品收发记录.审核日期%Type,
  发药方式_In   In 药品收发记录.发药方式%Type := 3,
  领药人_In     In 药品收发记录.领用人%Type := Null,
  汇总发药号_In In 药品收发记录.汇总发药号%Type := Null,
  Intdigit_In   In Number := 2,
  配药人_In     In 药品收发记录.配药人%Type := Null,
  核查人_In     In 药品收发记录.核查人%Type := Null
) Is
  --只读变量
  v_Infotmp     Varchar2(4000);
  v_Fields      Varchar2(4000);
  n_Billid      药品收发记录.Id%Type;
  n_批次        药品收发记录.批次%Type;
  Lng入出类别id Number(18);
  Int入出系数   Number;
  Int执行状态   Number;
  Int单据       药品收发记录.单据%Type;
  Strno         药品收发记录.No%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Lng费用id     药品收发记录.费用id%Type;
  Dbl差价率     Number;
  v_零售价      药品收发记录.零售价%Type;
  Int未发数     未发药品记录.未发数%Type;
  v_核查日期    药品收发记录.核查日期%Type;
  --可写变量
  Dbl实际数量 药品收发记录.实际数量%Type;
  Dbl实际金额 药品收发记录.零售金额%Type;
  Dbl成本金额 药品收发记录.成本金额%Type;
  Dbl实际差价 药品收发记录.差价%Type;
  --2002-07-31朱玉宝
  --LNGLAST批次 发药前确定的批次(已减可用数量)
  Str药名           Varchar2(200);
  Dbl可用数量       药品收发记录.填写数量%Type;
  Lnglast批次       药品收发记录.批次%Type;
  Lngcur批次        药品收发记录.批次%Type;
  Str批号           药品收发记录.批号%Type;
  Str效期           药品收发记录.效期%Type;
  n_上次供应商id    药品库存.上次供应商id%Type;
  n_上次采购价      药品库存.上次采购价%Type;
  v_上次产地        药品库存.上次产地%Type;
  d_上次生产日期    药品库存.上次生产日期%Type;
  v_批准文号        药品库存.批准文号%Type;
  n_记录状态        药品收发记录.记录状态%Type;
  n_平均成本价      药品库存.平均成本价%Type;
  n_发药方式        药品收发记录.发药方式%Type;
  v_摘要            药品收发记录.摘要%Type;
  Bln收费与发药分离 Number(1);
  v_Error           Varchar2(255);
  Err_Custom Exception;
  n_时价     Number(1) := 0;
  n_时价分批 Number(1) := 0;
Begin
  Select Sysdate Into v_核查日期 From Dual;
  If Billinfo_In Is Null Then
    v_Infotmp := Null;
  Else
    v_Infotmp := Billinfo_In || '|';
  End If;
  While v_Infotmp Is Not Null Loop
    --分解单据ID串
    v_Fields  := Substr(v_Infotmp, 1, Instr(v_Infotmp, '|') - 1);
    n_Billid  := Substr(v_Fields, 1, Instr(v_Fields, ',') - 1);
    n_批次    := Substr(v_Fields, Instr(v_Fields, ',') + 1);
    v_Infotmp := Replace('|' || v_Infotmp, '|' || v_Fields || '|');
  
    --获取该收发记录的单据、药品ID、库房ID,零售金额及实际数量、入出类别ID
    Begin
      Select a.单据, a.No, a.药品id, a.库房id, a.费用id, Nvl(a.零售价, 0), Nvl(a.零售金额, 0), Nvl(a.实际数量, 0) * Nvl(a.付数, 1), a.入出类别id,
             a.入出系数, Nvl(a.批次, 0), a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号, Nvl(a.发药方式, 0), a.摘要, a.记录状态
      Into Int单据, Strno, Lng药品id, Lng库房id, Lng费用id, v_零售价, Dbl实际金额, Dbl实际数量, Lng入出类别id, Int入出系数, Lnglast批次, Str批号, Str效期,
           n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_发药方式, v_摘要, n_记录状态
      From 药品收发记录 A
      Where a.Id = n_Billid And a.审核日期 Is Null
      For Update Nowait;
    
      Select '[' || c.编码 || ']' || c.名称, Nvl(是否变价, 0) 时价
      Into Str药名, n_时价
      From 收费项目目录 C
      Where c.Id = Lng药品id;
    Exception
      When Others Then
        Int单据 := 0;
        v_Error := '已有其他用户在执行发药，不能重复操作！';
        Raise Err_Custom;
    End;
  
    If n_发药方式 = -1 Or v_摘要 = '拒发' Then
      Int单据 := 0;
    End If;
  
    If Int单据 > 0 Then
      If Nvl(n_批次, 0) = 0 Then
        Lngcur批次 := Lnglast批次;
      Else
        Lngcur批次 := Nvl(n_批次, 0);
      End If;
    
      --检查是否已经填写库房
      Bln收费与发药分离 := 0;
      If Lng库房id Is Null Then
        Bln收费与发药分离 := 1;
      End If;
      Lng库房id := Partid_In;
    
      --取该批药品的批号
      Begin
        Select 上次批号, 效期, Nvl(可用数量, 0), 上次供应商id, 上次产地, 上次生产日期, 批准文号, 上次采购价
        Into Str批号, Str效期, Dbl可用数量, n_上次供应商id, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价
        From 药品库存
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      Exception
        When Others Then
          n_上次采购价 := 0;
          Dbl可用数量  := 0;
      End;
    
      --可用数量不足则退出
      If Lngcur批次 <> Nvl(Lnglast批次, 0) Then
        If Dbl可用数量 < Dbl实际数量 And Lngcur批次 <> 0 Then
          v_Error := Str药名 || '的可用数量不足，操作中止！';
          Raise Err_Custom;
        End If;
      End If;
    
      If n_记录状态 = 1 Then
        --原始发药记录，取最新价格
        n_平均成本价 := Round(Zl_Fun_Getoutcost(Lng药品id, Lngcur批次, Lng库房id), 5);
      Else
        --退药再发记录，取原始单据价格
        Select a.成本价
        Into n_平均成本价
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = n_Billid And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And Nvl(a.批次, 0) = Nvl(b.批次, 0) And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
      End If;
    
      Dbl成本金额 := Round(n_平均成本价 * Nvl(Dbl实际数量, 0), Intdigit_In);
      Dbl实际差价 := Round(Dbl实际金额 - Dbl成本金额, Intdigit_In);
    
      --更新药品收发记录的零售金额、成本金额及差价
      Update 药品收发记录
      Set 库房id = Lng库房id, 成本价 = n_平均成本价, 成本金额 = Dbl成本金额, 差价 = Dbl实际差价, 批次 = Lngcur批次, 批号 = Str批号, 效期 = Str效期,
          配药人 = 配药人_In, 核查人 = 核查人_In, 核查日期 = v_核查日期, 审核人 = People_In, 审核日期 = Date_In, 发药方式 = 发药方式_In, 领用人 = 领药人_In,
          汇总发药号 = 汇总发药号_In, 供药单位id = n_上次供应商id, 产地 = v_上次产地, 生产日期 = d_上次生产日期, 批准文号 = v_批准文号
      Where ID = n_Billid;
      --并发操作检查
      If Sql%RowCount = 0 Then
        v_Error := '要发药的药品记录"' || Str药名 || '"不存在，操作中止！';
        Raise Err_Custom;
      End If;
    
      --更新住院费用记录的执行状态(已执行)
      Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 1, 0, 1, 2)
      Into Int执行状态
      From 药品收发记录
      Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Null;
      Update 住院费用记录
      Set 执行状态 = Int执行状态, 执行人 = Decode(People_In, Null, Zl_Username, People_In), 执行时间 = Date_In, 执行部门id = Partid_In
      Where ID = Lng费用id;
    
      --更新未发药品记录(如果未发数为零则删除)
      Select Count(*)
      Into Int未发数
      From 药品收发记录
      Where 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null) And NO = Strno And 审核人 Is Null And
            Nvl(LTrim(RTrim(摘要)), '小宝') <> '拒发';
    
      If Int未发数 = 0 Then
        Delete 未发药品记录 Where NO = Strno And 单据 = Int单据 And (库房id + 0 = Lng库房id Or 库房id Is Null);
      End If;
    
      --更新原批次库存的可用数量
      --更新发药批次库存的可用及实际数量
      If Lnglast批次 <> Lngcur批次 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Dbl实际数量
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lnglast批次;
      
        Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lnglast批次);
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      
        Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lngcur批次);
      End If;
    
      If n_时价 = 1 And Lngcur批次 > 0 Then
        n_时价分批 := 1;
      Else
        n_时价分批 := 0;
      End If;
    
      If Bln收费与发药分离 = 1 Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) - Dbl实际数量, 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额,
            实际差价 = Nvl(实际差价, 0) - Dbl实际差价, 平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价),
            上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价), 零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_零售价, 零售价), 零售价)
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      Else
        Update 药品库存
        Set 实际数量 = Nvl(实际数量, 0) - Dbl实际数量, 实际金额 = Nvl(实际金额, 0) - Dbl实际金额, 实际差价 = Nvl(实际差价, 0) - Dbl实际差价,
            平均成本价 = Decode(平均成本价, Null, n_平均成本价, 平均成本价), 上次采购价 = Decode(上次采购价, Null, n_平均成本价, 上次采购价),
            零售价 = Decode(n_时价分批, 1, Decode(零售价, Null, v_零售价, 零售价), 零售价)
        Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lngcur批次;
      End If;
    
      If Sql%RowCount = 0 Then
        If n_上次采购价 = 0 Then
          If Dbl实际数量 = 0 Then
            Dbl实际数量 := 1;
          End If;
          n_上次采购价 := Round(Dbl成本金额 / Dbl实际数量, 5);
        End If;
      
        If Bln收费与发药分离 = 1 Then
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 效期, 平均成本价, 零售价)
          Values
            (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, Str批号, v_上次产地,
             n_上次供应商id, n_平均成本价, d_上次生产日期, v_批准文号, Str效期, n_平均成本价, Decode(n_时价分批, 1, v_零售价, Null));
        Else
          Insert Into 药品库存
            (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 效期, 平均成本价, 零售价)
          Values
            (Lng库房id, Lng药品id, Lngcur批次, 1, 0 - Dbl实际数量, 0 - Dbl实际金额, 0 - Dbl实际差价, Str批号, v_上次产地, n_上次供应商id, n_平均成本价,
             d_上次生产日期, v_批准文号, Str效期, n_平均成本价, Decode(n_时价分批, 1, v_零售价, Null));
        End If;
      End If;
    
      Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lngcur批次);
    
      Delete 药品库存
      Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
            Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    
      --处理调价修正
      Zl_药品收发记录_调价修正(n_Billid);
    End If;
  End Loop;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_批量发药;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品收发记录_取消发药
(
  Partid_In In 药品收发记录.库房id%Type,
  Bill_In   In 药品收发记录.单据%Type,
  No_In     In 药品收发记录.No%Type,
  门诊_In   In Number := 1
) Is
  Cursor c_Modifybill Is
    Select ID, 药品id, 入出类别id, 入出系数, 费用id, Nvl(实际数量, 0) * Nvl(付数, 1) 数量, Nvl(零售金额, 0) 金额, Nvl(差价, 0) 差价, Nvl(批次, 0) 批次,
           供药单位id, 成本价, 批号, 产地, 效期, 生产日期, 批准文号
    From 药品收发记录
    Where NO = No_In And 单据 = Bill_In And 记录状态 = 1 And 审核人 Is Not Null
    Order By 药品id;

  v_Modifybill c_Modifybill%RowType;

  n_记录性质 门诊费用记录.记录性质%Type;
  v_收费类别 门诊费用记录.收费类别%Type;
Begin
  For v_Modifybill In c_Modifybill Loop
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) + Nvl(v_Modifybill.数量, 0), 实际数量 = Nvl(实际数量, 0) + Nvl(v_Modifybill.数量, 0),
        实际金额 = Nvl(实际金额, 0) + Nvl(v_Modifybill.金额, 0), 实际差价 = Nvl(实际差价, 0) + v_Modifybill.差价
    Where 库房id + 0 = Partid_In And 药品id = v_Modifybill.药品id And 性质 = 1 And Nvl(批次, 0) = v_Modifybill.批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 可用数量, 实际数量, 实际金额, 实际差价, 上次供应商id, 上次采购价, 上次批号, 上次产地, 效期, 上次生产日期, 批准文号)
      Values
        (Partid_In, v_Modifybill.药品id, v_Modifybill.批次, 1, Nvl(v_Modifybill.数量, 0), Nvl(v_Modifybill.数量, 0),
         Nvl(v_Modifybill.金额, 0), v_Modifybill.差价, v_Modifybill.供药单位id, v_Modifybill.成本价, v_Modifybill.批号,
         v_Modifybill.产地, v_Modifybill.效期, v_Modifybill.生产日期, v_Modifybill.批准文号);
    End If;
  
    Zl_药品库存_可用数量异常处理(Partid_In, v_Modifybill.药品id, v_Modifybill.批次);
  
    Delete 药品库存
    Where 库房id + 0 = Partid_In And 药品id = v_Modifybill.药品id And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And
          Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0 And 性质 = 1;
  
    --产生未发药品记录
    Begin
      If 门诊_In = 1 Then
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
          Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, Null, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
          From (Select b.单据, b.No, a.病人id, Null 主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                        c.身份
                 From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
                 Where b.Id = v_Modifybill.Id And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
          Where b.名称(+) = a.身份;
      
        Select 记录性质, 收费类别 Into n_记录性质, v_收费类别 From 门诊费用记录 Where ID = v_Modifybill.费用id;
      
        --修改处方类型
        Zl_Prescription_Type_Update(No_In, n_记录性质, v_Modifybill.药品id, v_收费类别);
      Else
        Insert Into 未发药品记录
          (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数)
          Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, Null, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1
          From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                        c.身份
                 From 住院费用记录 A, 药品收发记录 B, 病人信息 C
                 Where b.Id = v_Modifybill.Id And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
          Where b.名称(+) = a.身份;
      End If;
    Exception
      When Others Then
        Null;
    End;
  End Loop;

  --更新费用记录的执行状态
  If 门诊_In = 1 Then
    Update 门诊费用记录
    Set 执行状态 = 0, 执行部门id = Null
    Where NO = No_In And Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Partid_In;
  
  Else
    Update 住院费用记录
    Set 执行状态 = 0, 执行部门id = Null
    Where ID In (Select Distinct 费用id
                 From 药品收发记录
                 Where NO = No_In And 单据 = Bill_In And 记录状态 = 1 And 审核人 Is Not Null);
  End If;

  --取消发药信息
  Update 药品收发记录
  Set 配药人 = Null, 审核人 = Null, 审核日期 = Null, 发药方式 = Null, 库房id = Null, 供药单位id = Null, 成本价 = Null, 成本金额 = Null, 差价 = Null
  Where NO = No_In And 单据 = Bill_In And 记录状态 = 1 And 审核人 Is Not Null;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_取消发药;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_住院记帐记录_Delete
(
  No_In           住院费用记录.No%Type,
  序号_In         Varchar2,
  操作员编号_In   住院费用记录.操作员编号%Type,
  操作员姓名_In   住院费用记录.操作员姓名%Type,
  记录性质_In     住院费用记录.记录性质%Type := 2,
  操作状态_In     Number := 0,
  输液配药检查_In Number := 1,
  登记时间_In     住院费用记录.登记时间%Type := Sysdate
) As
  --功能：冲销一张住院记帐单据中指定序号行
  --序号：格式如"1,3,5,7,8",或"1:2:33456,3:2,5:2,7:2,8:2",冒号前面的数字表示行号,中间的数字表示退的数量,后面的数字表示配药记录的ID,目前仅在销帐审核时才传入
  --      为空表示冲销所有可冲销行
  --记录性质:    2-人工记帐单,3-自动记帐单
  --输液配药检查:    0-医嘱调用，不检查药品是否进入输液配药中心；1-非医嘱调用，检查药品是否进入配药中心
  --该光标用于销帐指定费用行
  --操作状态_In:0-表示直接销帐;1-表示审核销帐(通过销帐申请-->销帐审核流程)
  --该游标为要退费单据的所有原始记录
  Cursor c_Bill Is
    Select a.Id, a.价格父号, a.序号, a.执行状态, a.记录性质, a.收费类别, a.医嘱序号, a.收费细目id, a.病人id, a.主页id, a.收入项目id, a.开单部门id, a.病人科室id,
           a.执行部门id, a.病人病区id, a.付数, a.数次, m.跟踪在用
    From 住院费用记录 A, 材料特性 M
    Where a.No = No_In And a.记录性质 = 记录性质_In And a.记录状态 In (0, 1, 3) And a.门诊标志 = 2 And a.收费细目id + 0 = m.材料id(+)
    Order By 收费细目id, 序号;

  --该游标用于处理药品库存可用数量
  --不要管费用的执行状态,因为先于此步处理
  Cursor c_Stock(v_序号_In Varchar2) Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
    From 药品收发记录
    Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And
          费用id In (Select ID
                   From 住院费用记录
                   Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And
                         门诊标志 = 2 And (Instr(',' || v_序号_In || ',', ',' || 序号 || ',') > 0 Or v_序号_In Is Null))
    Order By 药品id, 填制日期 Desc;

  r_Stock c_Stock%RowType;
  --该游标用于处理费用记录序号
  Cursor c_Serial Is
    Select 序号, 价格父号
    From 住院费用记录
    Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3)
    Order By 序号;

  Cursor Cr_药品 Is
    Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 0 As 数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
    From 药品收发记录
    Where Rownum <= 1;
  v_药品 Cr_药品%RowType;

  v_医嘱id     病人医嘱记录.Id%Type;
  n_划价       Number;
  v_父号       住院费用记录.价格父号%Type;
  v_序号       Varchar2(2000);
  v_Tmp        Varchar2(4000);
  v_医嘱ids    Varchar2(4000);
  l_药品收发   t_Numlist := t_Numlist();
  l_划价       t_Numlist := t_Numlist();
  l_费用id     t_Numlist := t_Numlist();
  n_付数       Number;
  n_虚拟库房id 药品收发记录.库房id%Type;
  n_其他出库id 药品收发记录.Id%Type;
  n_库房id     药品收发记录.库房id%Type;
  n_返回值     Number;
  --部分退费计算变量
  v_剩余数量 Number;
  v_剩余应收 Number;
  v_剩余实收 Number;
  v_剩余统筹 Number;

  v_准退数量 Number;
  v_退费次数 Number;
  v_应收金额 Number;
  v_实收金额 Number;
  v_统筹金额 Number;
  n_Temp     Number;
  n_部分销帐 Number;
  v_Dec      Number;
  n_Count    Number;
  v_Curdate  Date;
  Err_Item Exception;
  v_Err_Msg        Varchar2(255);
  n_备货卫材       Number;
  n_病人id         病案主页.病人id%Type;
  n_主页id         病案主页.主页id%Type;
  n_审核标志       病案主页.审核标志%Type;
  n_住院状态       病案主页.状态%Type;
  n_病人审核方式   Number(2);
  n_未入科禁止记账 Number(2);
  v_配药id         Varchar2(4000);
  Type Ty_药品 Is Ref Cursor;
  c_药品 Ty_药品; --游标变量

  n_未执行数量 药品收发记录.实际数量%Type;
  n_已执行数量 药品收发记录.实际数量%Type;
Begin
  --销帐审核时,非药品会传入行号的销帐数量
  If Not 序号_In Is Null Then
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := 序号_In || ',';
      While Not v_Tmp Is Null Loop
        v_序号 := v_序号 || ',' || Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
        If Instr(Substr(v_Tmp, Instr(v_Tmp, ':') + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':') - 1), ':') > 0 Then
          v_配药id := v_配药id || ',' ||
                    Substr(v_Tmp, Instr(v_Tmp, ':', 1, 2) + 1, Instr(v_Tmp, ',') - Instr(v_Tmp, ':', 1, 2) - 1);
        End If;
        v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',') + 1);
      End Loop;
      v_序号 := Substr(v_序号, 2);
      If v_配药id Is Not Null Then
        v_配药id := Substr(v_配药id, 2);
      End If;
    Else
      v_序号 := 序号_In;
    End If;
  End If;

  --是否已经全部完全执行(只是整张单据的检查)
  Select Nvl(Count(*), 0), Nvl(Max(病人id), 0), Nvl(Max(主页id), 0)
  Into n_Count, n_病人id, n_主页id
  From 住院费用记录
  Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1 And 门诊标志 = 2;
  If n_Count = 0 Then
    v_Err_Msg := '该单据中的项目已经全部完全执行！';
    Raise Err_Item;
  End If;

  n_病人审核方式   := Nvl(zl_GetSysParameter(185), 0);
  n_未入科禁止记账 := Nvl(zl_GetSysParameter(215), 0);
  If n_病人审核方式 = 1 Or n_未入科禁止记账 = 1 Then
  
    Begin
      Select 审核标志, 状态 Into n_审核标志, n_住院状态 From 病案主页 Where 病人id = n_病人id And 主页id = n_主页id;
    Exception
      When Others Then
        n_审核标志 := 0;
        n_住院状态 := 0;
    End;
    If n_未入科禁止记账 = 1 And n_住院状态 = 1 Then
      v_Err_Msg := '病人未入科,禁止对病人相关费用的操作!';
      Raise Err_Item;
    End If;
  
    If n_病人审核方式 = 1 Then
    
      If Nvl(n_审核标志, 0) = 1 Then
        v_Err_Msg := '该病人目前正在审核费用,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
      If Nvl(n_审核标志, 0) = 2 Then
        v_Err_Msg := '该病人目前已经完成了费用审核,不能进行费用相关调整!';
        Raise Err_Item;
      End If;
    End If;
  End If;

  --未完全执行的项目是否有剩余数量(只是整张单据的检查)
  Select Nvl(Count(*), 0)
  Into n_Count
  From (Select 序号, Sum(数量) As 剩余数量
         From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                From 住院费用记录
                Where NO = No_In And 记录性质 = 记录性质_In And 门诊标志 = 2 And
                      Nvl(价格父号, 序号) In
                      (Select Nvl(价格父号, 序号)
                       From 住院费用记录
                       Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And Nvl(执行状态, 0) <> 1)
                Group By 记录状态, Nvl(价格父号, 序号))
         Group By 序号
         Having Sum(数量) <> 0);
  If n_Count = 0 Then
    v_Err_Msg := '该单据中未完全执行部分项目剩余数量为零,没有可以销帐的费用！';
    Raise Err_Item;
  End If;

  --医嘱费用：检查正在执行的医嘱(注意已执行的情况在下面检查,因为不传 序号_IN 这种情况费用界面已限制)
  If Nvl(操作状态_In, 0) <> 1 Then
    --走销帐申请流程的，不检查医保执行状态
    Select Nvl(Count(*), 0)
    Into n_Count
    From 病人医嘱发送
    Where 执行状态 = 3 And (NO, 记录性质, 医嘱id) In
          (Select NO, 记录性质, 医嘱序号
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 医嘱序号 Is Not Null And
                              (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null));
    If n_Count > 0 Then
      v_Err_Msg := '要销帐的费用中存在对应的医嘱正在执行的情况，不能销帐！';
      Raise Err_Item;
    End If;
  End If;

  ---------------------------------------------------------------------------------
  --先打开药品对应数据集,以确保当前条件下有数据,为了处理并发判断
  --不能在游标条件中取消"审核人 is Null"条件，因为多次退药可能部份又已发
  Open c_Stock(v_序号);

  --公用变量
  Select 登记时间_In Into v_Curdate From Dual;

  --金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_Dec From Dual;

  For c_编目病案 In (Select a.姓名
                 From 病人信息 A, 病案主页 B
                 Where a.病人id = b.病人id And b.编目日期 Is Not Null And
                       (b.病人id, b.主页id) In
                       (Select Distinct 病人id, 主页id
                        From 住院费用记录
                        Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 门诊标志 = 2)) Loop
    v_Err_Msg := '病人『' || c_编目病案.姓名 || '』 已经被病案编目,不能被销帐！';
    Raise Err_Item;
  End Loop;
  v_医嘱ids := Null;
  --循环处理每行费用(收入项目行)
  For r_Bill In c_Bill Loop
    --检查已经存在病案编目的,则不能进行销帐处理
    If Instr(',' || v_序号 || ',', ',' || Nvl(r_Bill.价格父号, r_Bill.序号) || ',') > 0 Or v_序号 Is Null Then
      Select Decode(记录状态, 0, 1, 0) Into n_划价 From 住院费用记录 Where ID = r_Bill.Id;
      If Nvl(r_Bill.执行状态, 0) <> 1 Then
        --求剩余数量,剩余应收,剩余实收
        Select Sum(Nvl(付数, 1) * 数次), Sum(应收金额), Sum(实收金额), Sum(统筹金额)
        Into v_剩余数量, v_剩余应收, v_剩余实收, v_剩余统筹
        From 住院费用记录
        Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Bill.序号;
        n_部分销帐 := 0;
        If v_剩余数量 = 0 Then
          If v_序号 Is Not Null Then
            v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经全部销帐！';
            Raise Err_Item;
          End If;
          --情况：未限定行号,原始单据中的该笔已经全部销帐(执行状态=0的一种可能)
        Else
        
          If Instr(序号_In, ':') > 0 Then
            v_Tmp := ',' || 序号_In;
            v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || r_Bill.序号 || ':') + Length(',' || r_Bill.序号 || ':'));
            v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
            If Instr(v_Tmp, ':') > 0 Then
              v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
            End If;
            v_准退数量 := v_Tmp;
            n_部分销帐 := 1;
          End If;
        
          --准销数量(非药品项目为剩余数量,原始数量)
          If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              v_准退数量 := v_剩余数量;
            End If;
          Else
            --医嘱超期收回时,卫材可能没有发放,但申请销帐的是部分数量,所以要以申请的为准
            If Instr(序号_In, ':') = 0 Or 序号_In Is Null Then
              Select Nvl(Sum(Nvl(付数, 1) * 实际数量), 0), Count(*)
              Into v_准退数量, n_Count
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = r_Bill.Id;
            End If;
          
            --有剩余数量无准退数量的有两种情况：
            --1.不跟踪在用的卫材无对应的收发记录,这时使用剩余数量
            --2.并发操作,此时已发药或发料
            If v_准退数量 = 0 Then
              If r_Bill.收费类别 = '4' Then
                If n_Count > 0 Or Nvl(r_Bill.跟踪在用, 0) = 1 Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发料,须退料后再退费！';
                  Raise Err_Item;
                Else
                  v_准退数量 := v_剩余数量;
                End If;
              Else
                v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已发药,须退药后再退费！';
                Raise Err_Item;
              End If;
            End If;
          End If;
        
          --处理住院费用记录
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --该笔项目第几次销帐
            Select Nvl(Max(Abs(执行状态)), 0) + 1
            Into v_退费次数
            From 住院费用记录
            Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 = 2 And 序号 = r_Bill.序号 And 门诊标志 = 2;
          End If;
        
          --金额=剩余金额*(准退数/剩余数)
          v_应收金额 := Round(v_剩余应收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_实收金额 := Round(v_剩余实收 * (v_准退数量 / v_剩余数量), v_Dec);
          v_统筹金额 := Round(v_剩余统筹 * (v_准退数量 / v_剩余数量), v_Dec);
          If Nvl(n_划价, 0) = 1 Then
            If Nvl(n_部分销帐, 0) = 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
              n_返回值 := 0;
            Else
              --更新数量
              --划价的,先将相关的数据处理在内部表集中
              n_付数 := 0;
              If r_Bill.付数 > 1 Then
                --如果是中药,超期回收肯定是回收的付数,而不是次数.因此,需要检查准退数量是否可以整 除
                If Trunc(v_准退数量 / r_Bill.数次) <> (v_准退数量 / r_Bill.数次) Then
                  v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用为中药,请按付数进行退费！';
                  Raise Err_Item;
                End If;
                n_付数 := Trunc(v_准退数量 / r_Bill.数次);
                If Nvl(r_Bill.付数, 0) - n_付数 < 0 Then
                  v_准退数量 := r_Bill.数次;
                Else
                  v_准退数量 := 0;
                End If;
              End If;
              Update 住院费用记录
              Set 付数 = 付数 - n_付数, 数次 = 数次 - v_准退数量, 应收金额 = Nvl(应收金额, 0) - v_应收金额, 实收金额 = Nvl(实收金额, 0) - v_实收金额,
                  登记时间 = v_Curdate, 统筹金额 = Nvl(统筹金额, 0) - v_统筹金额
              Where ID = r_Bill.Id
              Returning Nvl(数次, 0) * Nvl(付数, 0) Into n_返回值;
            End If;
            If Nvl(n_返回值, 0) <= 0 Then
              l_划价.Extend;
              l_划价(l_划价.Count) := r_Bill.Id;
            End If;
            If r_Bill.医嘱序号 Is Not Null Then
              If Instr(',' || Nvl(v_医嘱ids, '') || ',', ',' || r_Bill.医嘱序号 || ',') = 0 Then
                v_医嘱ids := Nvl(v_医嘱ids, '') || ',' || r_Bill.医嘱序号;
              End If;
              --记录病人医嘱附费对应的医嘱ID(不是主费用)
              If v_医嘱id Is Null Then
                v_医嘱id := r_Bill.医嘱序号;
              End If;
            End If;
          
          End If;
        
          If Nvl(n_划价, 0) = 0 Then
            --划价时,直接更改数量,所以不须查划冲销次数
            --插入退费记录
            Insert Into 住院费用记录
              (ID, NO, 记录性质, 记录状态, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号, 床号, 费别, 病人病区id,
               病人科室id, 收费类别, 收费细目id, 计算单位, 付数, 发药窗口, 数次, 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用, 标准单价, 应收金额, 实收金额, 开单部门id, 开单人,
               执行部门id, 划价人, 执行人, 执行状态, 执行时间, 操作员编号, 操作员姓名, 发生时间, 登记时间, 保险项目否, 保险大类id, 统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊,
               结论, 医疗小组id)
              Select 病人费用记录_Id.Nextval, NO, 记录性质, 2, 序号, 从属父号, 价格父号, 主页id, 病人id, 医嘱序号, 门诊标志, 多病人单, 婴儿费, 姓名, 性别, 年龄, 标识号,
                     床号, 费别, 病人病区id, 病人科室id, 收费类别, 收费细目id, 计算单位, Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, 付数, 1), 发药窗口,
                     Decode(Sign(v_准退数量 - Nvl(付数, 1) * 数次), 0, -1 * 数次, -1 * v_准退数量), 加班标志, 附加标志, 收入项目id, 收据费目, 记帐费用,
                     标准单价, -1 * v_应收金额, -1 * v_实收金额, 开单部门id, 开单人, 执行部门id, 划价人, 执行人, -1 * v_退费次数, 执行时间, 操作员编号_In,
                     操作员姓名_In, 发生时间, v_Curdate, 保险项目否, 保险大类id, -1 * v_统筹金额, 保险编码, 记帐单id, 摘要, 费用类型, 是否急诊, 结论, 医疗小组id
              From 住院费用记录
              Where ID = r_Bill.Id;
          
            --记录病人医嘱附费对应的医嘱ID(不是主费用)
            If v_医嘱id Is Null And r_Bill.医嘱序号 Is Not Null Then
              v_医嘱id := r_Bill.医嘱序号;
            End If;
          
            Update 病人审批项目
            Set 已用数量 = Nvl(已用数量, 0) - v_准退数量
            Where 病人id = r_Bill.病人id And 主页id = r_Bill.主页id And 项目id = r_Bill.收费细目id And Nvl(使用限量, 0) <> 0;
          
            --病人余额
            Update 病人余额
            Set 费用余额 = Nvl(费用余额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And 类型 = 2 And 性质 = 1;
            If Sql%RowCount = 0 Then
              Insert Into 病人余额
                (病人id, 类型, 性质, 费用余额, 预交余额)
              Values
                (r_Bill.病人id, 2, 1, -1 * v_实收金额, 0);
            End If;
          
            --病人未结费用
            Update 病人未结费用
            Set 金额 = Nvl(金额, 0) - v_实收金额
            Where 病人id = r_Bill.病人id And Nvl(主页id, 0) = Nvl(r_Bill.主页id, 0) And Nvl(病人病区id, 0) = Nvl(r_Bill.病人病区id, 0) And
                  Nvl(病人科室id, 0) = Nvl(r_Bill.病人科室id, 0) And Nvl(开单部门id, 0) = Nvl(r_Bill.开单部门id, 0) And
                  Nvl(执行部门id, 0) = Nvl(r_Bill.执行部门id, 0) And 收入项目id + 0 = r_Bill.收入项目id And 来源途径 + 0 = 2;
            If Sql%RowCount = 0 Then
              Insert Into 病人未结费用
                (病人id, 主页id, 病人病区id, 病人科室id, 开单部门id, 执行部门id, 收入项目id, 来源途径, 金额)
              Values
                (r_Bill.病人id, r_Bill.主页id, r_Bill.病人病区id, r_Bill.病人科室id, r_Bill.开单部门id, r_Bill.执行部门id, r_Bill.收入项目id, 2,
                 -1 * v_实收金额);
            End If;
          
            --标记原费用记录
            --执行状态:全部退完(准退数=剩余数)标记为0,否则保持原状态
            If Instr(',4,5,6,7,', r_Bill.收费类别) = 0 Then
              --一般情况非药品和卫材的项目,不存在部分销帐的情况,只有销帐申请和销帐审核时,才会出现部分销帐,所以
              --执行状态只有两种:0.未执行;1已执行;
              --由于在销帐审核过程中将已执行强制改为了2部分执行,因此需要在此处改为1已执行.未执行的不变.
              Update 住院费用记录
              Set 记录状态 = 3, 执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0, Decode(执行状态, 2, 1, 执行状态))
              Where ID = r_Bill.Id;
            Else
              Select Nvl(Sum(Decode(审核人, Null, 1, 0) * Nvl(付数, 1) * 实际数量), 0),
                     Nvl(Sum(Decode(审核人, Null, 0, 1) * Nvl(付数, 1) * 实际数量), 0)
              Into n_未执行数量, n_已执行数量
              From 药品收发记录
              Where NO = No_In And 单据 In (9, 10, 25, 26) And 费用id = r_Bill.Id;
            
              Update 住院费用记录
              Set 记录状态 = 3,
                  执行状态 = Decode(Sign(v_准退数量 - v_剩余数量), 0, 0,
                                 Decode(Sign(n_未执行数量 - v_准退数量), 1, Decode(n_已执行数量, 0, 0, 2), 1))
              Where ID = r_Bill.Id;
            End If;
          End If;
        End If;
      Else
        If v_序号 Is Not Null Then
          v_Err_Msg := '单据中第' || Nvl(r_Bill.价格父号, r_Bill.序号) || '行费用已经完全执行,不能销帐！';
          Raise Err_Item;
        End If;
        --情况:没限定行号,原始单据中包括已经完全执行的
      End If;
    End If;
  End Loop;

  --不存在配药ID,检查该药品是否在输液配药中心
  If v_配药id Is Null And 输液配药检查_In = 1 Then
    For v_费用 In (Select ID
                 From 住院费用记录
                 Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                       (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)) Loop
      Begin
        Select Count(1)
        Into n_Count
        From 输液配药内容 A, 药品收发记录 B
        Where a.收发id = b.Id And b.费用id = v_费用.Id And Instr(',8,9,10,21,24,25,26,', ',' || b.单据 || ',') > 0;
      Exception
        When Others Then
          n_Count := 0;
      End;
      If n_Count <> 0 Then
        v_Err_Msg := '存在已经进入输液配药中心的待销帐药品，无法完成销帐！';
        Raise Err_Item;
      End If;
    End Loop;
  End If;

  n_部分销帐 := 0;
  ---------------------------------------------------------------------------------
  --药品相关处理:主要是对销帐审核有效.(可以是部分)
  For v_费用 In (Select ID, 序号, 收费类别
               From 住院费用记录
               Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 In ('4', '5', '6', '7') And 门诊标志 = 2 And
                     (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null)
               Order By 收费细目id) Loop
    --根据费用ID来进行相关的处理
    v_准退数量 := 0;
    If Instr(序号_In, ':') > 0 Then
      v_Tmp := ',' || 序号_In;
      v_Tmp := Substr(v_Tmp, Instr(v_Tmp, ',' || v_费用.序号 || ':') + Length(',' || v_费用.序号 || ':'));
      v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp || ',', ',') - 1);
      If Instr(v_Tmp, ':') > 0 Then
        v_Tmp := Substr(v_Tmp, 1, Instr(v_Tmp, ':') - 1);
      End If;
      v_准退数量 := v_Tmp;
    End If;
    If v_准退数量 <> 0 Then
      n_部分销帐 := 1;
      n_Temp     := 0;
      --------------------------------------------------------------------------------------
      --检查是否备货记帐卫材,规则如下
      -- a.如果存在存在未审核的其他出库且部分销帐时,直接在原来的基础上更改其他出库数量
      -- b.如果存在存在未审核的其他出库且完全销帐时,直接删除
      -- c.库存处理:还原为虚拟库房的可用数量;发料部门不处理
      -- d.如果已经发了料,这个时间由于其他出库单已经审核,因此就按正常情况流转,库存恢复到发料部门中
      n_虚拟库房id := Null;
      n_其他出库id := Null;
      If v_费用.收费类别 = '4' Then
        Begin
          Select 1, 库房id, ID
          Into n_备货卫材, n_虚拟库房id, n_其他出库id
          From 药品收发记录
          Where 费用id = v_费用.Id And 审核日期 Is Null And 单据 = 21 And Rownum = 1;
        Exception
          When Others Then
            n_备货卫材 := 0;
        End;
      Else
        n_备货卫材 := 0;
      End If;
      --------------------------------------------------------------------------------------
      If v_配药id Is Not Null Then
        Open c_药品 For
          Select /*+ rule*/
           a.Id, a.单据, a.No, a.库房id, a.药品id, a.批次, a.发药方式,
           Decode(a.发药方式, Null, 1, -1, 0, 1) * Nvl(a.付数, 1) * Nvl(a.实际数量, 0) As 数量, a.灭菌效期, a.效期, a.产地, a.批号, a.填制日期,
           a.费用id
          From 药品收发记录 A, Table(f_Str2list(v_配药id)) B, 输液配药内容 C
          Where a.No = No_In And a.单据 In (9, 10, 25, 26) And Mod(a.记录状态, 3) = 1 And a.审核人 Is Null And a.费用id = v_费用.Id And
                a.Id = c.收发id And c.记录id = b.Column_Value
          Order By 填制日期;
      Else
        Open c_药品 For
          Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, Decode(发药方式, Null, 1, -1, 0, 1) * Nvl(付数, 1) * Nvl(实际数量, 0) As 数量,
                 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id
          From 药品收发记录
          Where NO = No_In And 单据 In (9, 10, 25, 26) And Mod(记录状态, 3) = 1 And 审核人 Is Null And 费用id = v_费用.Id
          Order By 填制日期;
      End If;
      Loop
        Fetch c_药品
          Into v_药品;
        Exit When c_药品%NotFound;
        n_Temp := v_药品.数量;
        If v_准退数量 >= n_Temp Then
          l_药品收发.Extend;
          l_药品收发(l_药品收发.Count) := v_药品.Id;
          If Nvl(n_其他出库id, 0) > 0 Then
            l_药品收发.Extend;
            l_药品收发(l_药品收发.Count) := n_其他出库id;
          End If;
          v_准退数量 := v_准退数量 - n_Temp;
        Else
          If v_费用.收费类别 = '7' Then
            --当前行的数量要大
            Update 药品收发记录
            Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                            (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          Else
            Update 药品收发记录
            Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(填写数量, 0) - v_准退数量,
                成本金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                零售金额 =
                 (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
            Where ID = v_药品.Id;
          End If;
          --更新其他出库单
          If Nvl(n_其他出库id, 0) <> 0 Then
            If v_费用.收费类别 = '7' Then
              Update 药品收发记录
              Set 付数 = 1, 实际数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  填写数量 = Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 零售价 -
                              (Decode(付数, Null, 1, 0, 1, 付数) * Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            Else
              Update 药品收发记录
              Set 实际数量 = Nvl(实际数量, 0) - v_准退数量, 填写数量 = Nvl(实际数量, 0) - v_准退数量,
                  成本金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 成本价,
                  零售金额 =
                   (Nvl(实际数量, 0) - v_准退数量) * 零售价,
                  差价 = Round((Nvl(实际数量, 0) - v_准退数量) * 零售价 - (Nvl(实际数量, 0) - v_准退数量) * 成本价, 5)
              Where ID = Nvl(n_其他出库id, 0);
            End If;
          End If;
          n_Temp     := v_准退数量;
          v_准退数量 := 0;
        End If;
        If Nvl(n_备货卫材, 0) = 1 Then
          n_库房id := n_虚拟库房id;
        Else
          n_库房id := v_药品.库房id;
        End If;
      
        If n_库房id Is Not Null Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (n_库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
        
          Zl_药品库存_可用数量异常处理(n_库房id, v_药品.药品id, Nvl(v_药品.批次, 0));
        
          Delete 药品库存
          Where 库房id = n_库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
                Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
        End If;
      
        If Nvl(n_备货卫材, 0) = 1 Then
          Update 药品库存
          Set 可用数量 = Nvl(可用数量, 0) + n_Temp
          Where 库房id = v_药品.库房id And 药品id = v_药品.药品id And Nvl(批次, 0) = Nvl(v_药品.批次, 0) And 性质 = 1;
          If Sql%RowCount = 0 Then
            Insert Into 药品库存
              (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
            Values
              (v_药品.库房id, v_药品.药品id, 1, v_药品.批次, v_药品.效期, n_Temp, v_药品.批号, v_药品.产地, v_药品.灭菌效期);
          End If;
        End If;
      
        If v_准退数量 = 0 Then
          Exit;
        End If;
      End Loop;
      --不跟踪卫材的,不检查:因为不跟噻的话,不会在药品收发记录中存在
      If Nvl(v_准退数量, 0) <> 0 And Not (v_费用.收费类别 = '4' And n_Temp = 0) Then
        --未分配完成,表示此药品可能已经执行.
        v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
        Raise Err_Item;
      End If;
    End If;
  End Loop;

  If n_部分销帐 = 0 Then
    ------------------------------------------------------------------------------------------------------------------------
    --先处理备货材料
    For v_出库 In (Select ID, 单据, NO, 库房id, 药品id, 批次, 发药方式, 付数, 实际数量, 灭菌效期, 效期, 产地, 批号, 填制日期, 费用id, 商品条码, 内部条码
                 From 药品收发记录
                 Where 单据 = 21 And Mod(记录状态, 3) = 1 And 审核人 Is Null And
                       费用id In (Select ID
                                From 住院费用记录
                                Where NO = No_In And 记录性质 = 记录性质_In And 记录状态 In (0, 1, 3) And 收费类别 = '4' And 门诊标志 = 2 And
                                      (Instr(',' || v_序号 || ',', ',' || 序号 || ',') > 0 Or v_序号 Is Null))
                 Order By 药品id, 填制日期 Desc) Loop
      --处理药品库存
      If v_出库.库房id Is Not Null Then
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0)
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期, 商品条码, 内部条码)
          Values
            (v_出库.库房id, v_出库.药品id, 1, v_出库.批次, v_出库.效期,
             Decode(v_出库.发药方式, Null, 1, -1, 0, 1) * Nvl(v_出库.付数, 1) * Nvl(v_出库.实际数量, 0), v_出库.批号, v_出库.产地, v_出库.灭菌效期,
             v_出库.商品条码, v_出库.内部条码);
        End If;
        Delete 药品库存
        Where 库房id = v_出库.库房id And 药品id = v_出库.药品id And Nvl(批次, 0) = Nvl(v_出库.批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
              Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
      l_费用id.Extend;
      l_费用id(l_费用id.Count) := v_出库.费用id;
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := v_出库.Id;
    End Loop;
  
    --药品相关内容
    Fetch c_Stock
      Into r_Stock;
    While c_Stock%Found Loop
    
      --处理药品库存
      If r_Stock.库房id Is Not Null Then
      
        Select Decode(Count(Column_Value), Null, 0, 0, 0, 1)
        Into n_备货卫材
        From Table(l_费用id)
        Where Column_Value = r_Stock.费用id;
      
        Update 药品库存
        Set 可用数量 = Nvl(可用数量, 0) + Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0)
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1;
        If Sql%RowCount = 0 Then
          Insert Into 药品库存
            (库房id, 药品id, 性质, 批次, 效期, 可用数量, 上次批号, 上次产地, 灭菌效期)
          Values
            (r_Stock.库房id, r_Stock.药品id, 1, r_Stock.批次, r_Stock.效期,
             Decode(r_Stock.发药方式, Null, 1, -1, 0, 1) * Nvl(r_Stock.付数, 1) * Nvl(r_Stock.实际数量, 0), r_Stock.批号, r_Stock.产地,
             r_Stock.灭菌效期);
        End If;
      
        Zl_药品库存_可用数量异常处理(r_Stock.库房id, r_Stock.药品id, Nvl(r_Stock.批次, 0));
      
        Delete 药品库存
        Where 库房id = r_Stock.库房id And 药品id = r_Stock.药品id And Nvl(批次, 0) = Nvl(r_Stock.批次, 0) And 性质 = 1 And
              Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
      End If;
    
      --删除药品收发记录(加上并发操作检查:审核人 Is Null)
      --Delete From 药品收发记录 Where ID = r_Stock.ID And 审核人 Is Null;
    
      l_药品收发.Extend;
      l_药品收发(l_药品收发.Count) := r_Stock.Id;
      Fetch c_Stock
        Into r_Stock;
    End Loop;
    Close c_Stock;
  
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
    If Sql%RowCount <> l_药品收发.Count And l_药品收发.Count <> 0 Then
      v_Err_Msg := '要销帐的费用中存在已发的药品或卫材，或已被其他人销帐；这可能是并发操作引起的。';
      Raise Err_Item;
    End If;
  Else
    --删除药品收发记录
    Forall I In 1 .. l_药品收发.Count
      Delete From 药品收发记录 Where ID = l_药品收发(I) And 审核人 Is Null;
  End If;
  --未发药品记录
  Delete From 未发药品记录 A
  Where NO = No_In And 单据 In (9, 10, 25, 26) And Not Exists
   (Select 1
         From 药品收发记录
         Where 单据 = a.单据 And Nvl(库房id, 0) = Nvl(a.库房id, 0) And NO = No_In And Mod(记录状态, 3) = 1 And 审核人 Is Null);

  ---------------------------------------------------------------------------------
  --如果是划价,直接删除费用记录(药品处理后)
  n_Count := l_划价.Count;
  --删除划价记录
  Forall I In 1 .. l_划价.Count
    Delete From 住院费用记录 Where ID = l_划价(I);

  --删除之后再统一调整序号
  If n_Count > 0 Then
    n_Count := 1;
    For r_Serial In c_Serial Loop
      If r_Serial.价格父号 Is Null Then
        v_父号 := n_Count;
      End If;
    
      Update 住院费用记录
      Set 序号 = n_Count, 价格父号 = Decode(价格父号, Null, Null, v_父号)
      Where NO = No_In And 记录性质 = 记录性质_In And 序号 = r_Serial.序号;
    
      Update 住院费用记录
      Set 从属父号 = n_Count
      Where NO = No_In And 记录性质 = 记录性质_In And 从属父号 = r_Serial.序号;
    
      n_Count := n_Count + 1;
    End Loop;
  
  End If;

  --整张单据全部冲完时，删除病人医嘱附费
  For c_医嘱 In (Select Distinct 医嘱序号
               From 住院费用记录
               Where NO = No_In And 记录性质 = 2 And 记录状态 = 3 And 医嘱序号 Is Not Null) Loop
    Select Nvl(Count(*), 0)
    Into n_Count
    From (Select 序号, Sum(数量) As 剩余数量
           From (Select 记录状态, Nvl(价格父号, 序号) As 序号, Avg(Nvl(付数, 1) * 数次) As 数量
                  From 住院费用记录
                  Where 记录性质 = 2 And 医嘱序号 + 0 = c_医嘱.医嘱序号 And NO = No_In
                  Group By 记录状态, Nvl(价格父号, 序号))
           Group By 序号
           Having Sum(数量) <> 0);
  
    If n_Count = 0 Then
      Delete From 病人医嘱附费 Where 医嘱id = c_医嘱.医嘱序号 And 记录性质 = 2 And NO = No_In;
    End If;
  End Loop;

  If v_医嘱ids Is Not Null Then
    --医嘱处理
    --场合_In    Integer:=0, --0:门诊;1-住院
    --性质_In    Integer:=1, --1-收费单;2-记帐单
    --操作_In    Integer:=0, --0:删除划价单;1-收费或记帐;2-退费或销帐
    --No_In      门诊费用记录.No%Type,
    --医嘱ids_In Varchar2 := Null
    v_医嘱ids := Substr(v_医嘱ids, 2);
    Zl_医嘱发送_计费状态_Update(1, 2, 0, No_In, v_医嘱ids);
  Else
    Zl_医嘱发送_计费状态_Update(1, 2, 2, No_In);
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Err_Msg || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_住院记帐记录_Delete;
/

--119342:李业庆,2018-01-03,可用数量异常数据处理
Create Or Replace Procedure Zl_药品收发记录_部门退药
(
  Billid_In     In 药品收发记录.Id%Type,
  People_In     In 药品收发记录.审核人%Type,
  Date_In       In 药品收发记录.审核日期%Type,
  批号_In       In 药品库存.上次批号%Type := Null,
  效期_In       In 药品库存.效期%Type := Null,
  产地_In       In 药品库存.上次产地%Type := Null,
  退药数量_In   In 药品收发记录.实际数量%Type := Null,
  退药库房_In   In 药品收发记录.库房id%Type := Null,
  退药人_In     In 药品收发记录.领用人%Type := Null,
  Intdigit_In   In Number := 2,
  门诊_In       In Number := 2,
  汇总发药号_In In 药品收发记录.汇总发药号%Type := Null
) Is
  --只读变量
  Int记录状态   药品收发记录.记录状态%Type;
  Int执行状态   住院费用记录.执行状态%Type;
  Bln部分退药   Number;
  Lng入出类别id Number(18);
  Strno         药品收发记录.No%Type;
  Int单据       药品收发记录.单据%Type;
  Lng库房id     药品收发记录.库房id%Type;
  Lng药品id     药品收发记录.药品id%Type;
  Dbl实际数量   药品收发记录.实际数量%Type;
  Dbl实际金额   药品收发记录.零售金额%Type;
  Dbl实际成本   药品收发记录.成本金额%Type;
  Dbl实际差价   药品收发记录.差价%Type;
  Lng费用id     药品收发记录.费用id%Type;
  n_零售价      药品收发记录.零售价%Type;
  n_是否变价    Number;
  n_时价分批    Number;

  --20020731 Modified by zyb
  --处理退药时，分批核算性质改变后的处理
  Lng新批次 药品收发记录.批次%Type;
  Lng分批   药品规格.药房分批%Type;
  Lng批次   药品收发记录.批次%Type; --原批次

  Str批号        药品收发记录.批号%Type; --原批号
  Date效期       药品收发记录.效期%Type; --原效期
  n_上次供应商id 药品库存.上次供应商id%Type;
  n_上次采购价   药品库存.上次采购价%Type;
  v_上次产地     药品库存.上次产地%Type;
  d_上次生产日期 药品库存.上次生产日期%Type;
  v_批准文号     药品库存.批准文号%Type;

  n_记录性质   住院费用记录.记录性质%Type;
  v_收费类别   住院费用记录.收费类别%Type;
  n_付数       药品收发记录.付数%Type;
  n_原始数量   药品收发记录.实际数量%Type;
  v_冲销记录id 药品收发记录.Id%Type;
  Err_Custom Exception;
  v_Error    Varchar2(255);
  v_配药确认 药房配药控制.配药确认%Type;
  v_配药     药房配药控制.配药%Type;
  v_排队状态 Number(1);
  v_执行时间 药品收发记录.审核日期%Type;
Begin
  If 退药数量_In Is Not Null Then
    If 退药数量_In = 0 Then
      Return;
    End If;
  End If;

  --获取该收发记录的单据、药品ID、库房ID
  Select a.单据, a.No, a.库房id, a.药品id, a.费用id, a.入出类别id, a.记录状态, Nvl(a.批次, 0), a.批号, a.效期, a.供药单位id, a.产地, a.生产日期, a.批准文号,
         a.成本价, a.付数, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.零售价, Nvl(b.是否变价, 0) 是否变价
  Into Int单据, Strno, Lng库房id, Lng药品id, Lng费用id, Lng入出类别id, Int记录状态, Lng批次, Str批号, Date效期, n_上次供应商id, v_上次产地, d_上次生产日期,
       v_批准文号, n_上次采购价, n_付数, n_原始数量, n_零售价, n_是否变价
  From 药品收发记录 A, 收费项目目录 B
  Where a.药品id = b.Id And a.Id = Billid_In;

  Begin
    Select Nvl(配药确认, 0), Nvl(配药, 0)
    Into v_配药确认, v_配药
    From 药房配药控制
    Where 药房id = Lng库房id And Rownum = 1;
  
  Exception
    When Others Then
      v_配药确认 := 0;
      v_配药     := 0;
      Null;
  End;

  If v_配药确认 = 0 And v_配药 = 0 Then
    v_排队状态 := 2;
  Elsif v_配药确认 = 1 Then
    v_排队状态 := 0;
  Elsif v_配药 = 1 Then
    v_排队状态 := 1;
  End If;

  --获取该笔记录剩余未退数量、金额及差价
  --尽量避免金额及差价未出完的现象
  Select Sum(Nvl(实际数量, 0) * Nvl(付数, 1)), Sum(Nvl(零售金额, 0)), Sum(Nvl(成本金额, 0)), Sum(Nvl(差价, 0))
  Into Dbl实际数量, Dbl实际金额, Dbl实际成本, Dbl实际差价
  From 药品收发记录
  Where 审核人 Is Not Null And NO = Strno And 单据 = Int单据 And 序号 = (Select 序号 From 药品收发记录 Where ID = Billid_In);

  --如果允许退药数为零，表示已退药
  If Dbl实际数量 = 0 Then
    v_Error := '该单据已被其他操作员退药，请刷新后再试！';
    Raise Err_Custom;
  End If;
  If Nvl(退药数量_In, 0) > Dbl实际数量 Then
    v_Error := '该单据已被其他操作员部分退药，请刷新后再试！';
    Raise Err_Custom;
  End If;

  --获取该药品当前是否分批的信息
  Select Nvl(药房分批, 0) Into Lng分批 From 药品规格 Where 药品id = Lng药品id;
  --如果是部分退药，则重新计算零售金额及差价
  Bln部分退药 := 0;
  If Not (退药数量_In Is Null Or Nvl(退药数量_In, 0) = Dbl实际数量) Then
    Bln部分退药 := 1;
  End If;
  If Bln部分退药 = 1 Then
    Dbl实际金额 := Round(Dbl实际金额 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际成本 := Round(Dbl实际成本 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际差价 := Round(Dbl实际差价 * 退药数量_In / Dbl实际数量, Intdigit_In);
    Dbl实际数量 := 退药数量_In;
  End If;

  If n_原始数量 = 退药数量_In Then
    Dbl实际数量 := 退药数量_In / n_付数;
  Else
    n_付数 := 1;
  End If;

  --lng分批:0-不分批;1-分批;2-原分批，现不分批，按不分批处理;3-原不分批，现分批，产生新批次
  If Lng分批 = 0 And Lng批次 <> 0 Then
    --原分批，现不分批，按不分批处理
    Lng分批 := 2;
  Elsif Lng分批 <> 0 And Lng批次 = 0 Then
    --原不分批,现分批,产生新的批次，并在新产生的发药记录中使用
    Lng分批 := 3;
  Else
    If Lng批次 = 0 Then
      Lng分批 := 0;
    Else
      Lng分批 := 1;
    End If;
  End If;
  --判断是否时价分批
  If (Lng分批 = 1 Or Lng分批 = 3) And n_是否变价 = 1 Then
    n_时价分批 := 1;
  Else
    n_时价分批 := 0;
  End If;

  --记录状态的含义有所变化
  --冲销的记录状态        :iif(int记录状态=1,0,1)+1
  --被冲销的记录状态        :iif(int记录状态=1,0,1)+2
  --等待发药的记录状态    :iif(int记录状态=1,0,1)+3

  --产生冲销记录
  Select 药品收发记录_Id.Nextval Into v_冲销记录id From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 外观, 领用人, 供药单位id, 生产日期, 批准文号, 汇总发药号, 发药方式, 注册证号)
    Select v_冲销记录id, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 1, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地,
           批号, 效期, n_付数, -dbl实际数量, -dbl实际数量, 成本价, -dbl实际成本, 扣率, 零售价, -dbl实际金额, -dbl实际差价, 摘要, People_In, Date_In, 配药人,
           People_In, Date_In, 费用id, 单量, 频次, 用法, 发药窗口, 退药库房_In, 退药人_In, 供药单位id, 生产日期, 批准文号, 汇总发药号_In, 发药方式, 注册证号
    From 药品收发记录
    Where ID = Billid_In;

  --如果是部分冲销，则付数填为1，实际数量为付数与实际数量的积
  --产生正常记录以供继续发药
  Select 药品收发记录_Id.Nextval Into Lng新批次 From Dual;
  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 付数, 填写数量, 实际数量, 成本价, 成本金额, 扣率, 零售价, 零售金额,
     差价, 摘要, 填制人, 填制日期, 配药人, 审核人, 审核日期, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号)
    Select Lng新批次, Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 3, Int单据, Strno, 序号, 库房id, 对方部门id, 入出类别id, 入出系数, 药品id,
           Decode(Lng分批, 1, 批次, 3, Lng新批次, 0), Decode(Lng分批, 3, 产地_In, 1, 产地, 产地), Decode(Lng分批, 3, 批号_In, 1, 批号, Null),
           Decode(Lng分批, 3, 效期_In, 1, 效期, Null), n_付数, Dbl实际数量, Dbl实际数量, 成本价, Dbl实际成本, 扣率, 零售价, Dbl实际金额, Dbl实际差价, 摘要,
           填制人, 填制日期, Null, Null, Null, 费用id, 单量, 频次, 用法, 发药窗口, 供药单位id, 生产日期, 批准文号, 注册证号
    From 药品收发记录
    Where ID = Billid_In;

  --更新费用记录的执行状态(0-未执行;1-完全执行;2-部分执行)
  Select Decode(Sum(Nvl(付数, 1) * 实际数量), Null, 0, 0, 0, 2)
  Into Int执行状态
  From 药品收发记录
  Where 单据 = Int单据 And NO = Strno And 费用id = Lng费用id And 审核人 Is Not Null;

  If 门诊_In = 1 Then
    Select 记录性质, 收费类别 Into n_记录性质, v_收费类别 From 门诊费用记录 Where ID = Lng费用id;
  End If;

  If Int执行状态 = 0 Then
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态, 执行人 = Null, 执行时间 = Null Where ID = Lng费用id;
    End If;
  Else
    If 门诊_In = 1 Then
      Update 门诊费用记录
      Set 执行状态 = Int执行状态
      Where NO = Strno And
            序号 = (Select 序号 From 门诊费用记录 Where ID = (Select 费用id From 药品收发记录 Where ID = Billid_In)) And
            Mod(记录性质, 10) = n_记录性质 And 记录状态 <> 2 And 执行部门id = Lng库房id;
    Else
      Update 住院费用记录 Set 执行状态 = Int执行状态 Where ID = Lng费用id;
    End If;
  End If;

  --插入未发药品记录
  Begin
    If 门诊_In = 1 Then
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, Null, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期, c.身份,
                      b.产品合格证
               From 门诊费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    
      --修改处方类型
      Zl_Prescription_Type_Update(Strno, n_记录性质, Lng药品id, v_收费类别);
    Else
      Insert Into 未发药品记录
        (单据, NO, 病人id, 主页id, 姓名, 优先级, 对方部门id, 库房id, 发药窗口, 填制日期, 已收费, 配药人, 打印状态, 未发数, 领药号, 排队状态)
        Select a.单据, a.No, a.病人id, a.主页id, a.姓名, Nvl(b.优先级, 0) 优先级, a.对方部门id, a.库房id, a.发药窗口, a.填制日期, a.已收费, Null, 1, 1,
               a.产品合格证, v_排队状态
        From (Select b.单据, b.No, a.病人id, a.主页id, a.姓名, Decode(a.记录状态, 0, 0, 1) 已收费, b.对方部门id, b.库房id, b.发药窗口, b.填制日期,
                      c.身份, b.产品合格证
               From 住院费用记录 A, 药品收发记录 B, 病人信息 C
               Where b.Id = Billid_In And a.Id = b.费用id + 0 And a.病人id = c.病人id(+)) A, 身份 B
        Where b.名称(+) = a.身份;
    End If;
  Exception
    When Others Then
      Null;
  End;

  --修改原记录为被冲销记录
  Update 药品收发记录 Set 记录状态 = Int记录状态 + Decode(Int记录状态, 1, 0, 1) + 2 Where ID = Billid_In;

  --修改药品库存(反冲库存)
  If Lng分批 <> 3 Then
    Update 药品库存
    Set 实际数量 = Nvl(实际数量, 0) + Dbl实际数量 * n_付数, 实际金额 = Nvl(实际金额, 0) + Dbl实际金额, 实际差价 = Nvl(实际差价, 0) + Dbl实际差价
    Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(批次, 0) = Lng批次;
  
    If Sql%RowCount = 0 Then
      Insert Into 药品库存
        (库房id, 药品id, 批次, 性质, 实际数量, 实际金额, 实际差价, 零售价, 上次批号, 效期, 上次供应商id, 上次采购价, 上次产地, 上次生产日期, 批准文号, 平均成本价)
      Values
        (Lng库房id, Lng药品id, Decode(Lng分批, 2, 0, Lng批次), 1, Dbl实际数量 * n_付数, Dbl实际金额, Dbl实际差价,
         Decode(n_时价分批, 1, n_零售价, Null), Decode(Lng分批, 1, Str批号, Null), Decode(Lng分批, 1, Date效期, Null), n_上次供应商id,
         n_上次采购价, v_上次产地, d_上次生产日期, v_批准文号, n_上次采购价);
    End If;
  
    Zl_药品库存_可用数量异常处理(Lng库房id, Lng药品id, Lng批次);
  Else
    Insert Into 药品库存
      (库房id, 药品id, 批次, 效期, 性质, 实际数量, 实际金额, 实际差价, 零售价, 上次批号, 上次产地, 上次供应商id, 上次采购价, 上次生产日期, 批准文号, 平均成本价)
    Values
      (Lng库房id, Lng药品id, Lng新批次, 效期_In, 1, Dbl实际数量 * n_付数, Dbl实际金额, Dbl实际差价, Decode(n_时价分批, 1, n_零售价, Null), 批号_In,
       产地_In, n_上次供应商id, n_上次采购价, d_上次生产日期, v_批准文号, n_上次采购价);
  End If;

  Delete 药品库存
  Where 库房id + 0 = Lng库房id And 药品id = Lng药品id And 性质 = 1 And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
        Nvl(实际差价, 0) = 0;

  --处理调价修正
  Zl_药品收发记录_调价修正(v_冲销记录id);

  Begin
    --移动支付宝项目在发药后动态调用生成推送信息的过程
    Execute Immediate 'Begin zl_服务窗消息_发送(:1,:2); End;'
      Using 7, Billid_In || ',' || 退药数量_In || ',' || 门诊_In;
  Exception
    When Others Then
      Null;
  End;
Exception
  When Err_Custom Then
    Raise_Application_Error(-20101, '[ZLSOFT]' || v_Error || '[ZLSOFT]');
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_药品收发记录_部门退药;
/

--122412:李业庆,2018-03-06,修改固定重算平均成本价问题
Create Or Replace Procedure Zl_材料收发记录_调价修正(收发id_In In 药品收发记录.Id%Type) Is
  v_单据         药品收发记录.单据%Type;
  v_入出类别id   药品收发记录.入出类别id%Type;
  v_售价精度     Number;
  v_金额精度     Number;
  v_收发id       药品收发记录.Id%Type;
  v_原价         药品收发记录.零售价%Type;
  v_现价         药品收发记录.零售价%Type;
  v_是否变价     收费项目目录.是否变价%Type;
  v_价格id       收费价目.Id%Type;
  v_库房id       药品收发记录.库房id%Type;
  v_药品id       药品收发记录.药品id%Type;
  v_批次         药品收发记录.批次%Type;
  v_实际数量     药品收发记录.实际数量%Type;
  v_修正金额     药品收发记录.零售金额%Type;
  v_入出系数     药品收发记录.入出系数%Type;
  v_执行修正     Number;
  v_审核日期     药品收发记录.审核日期%Type;
  v_零售金额     药品收发记录.零售金额%Type;
  v_差价         药品收发记录.差价%Type;
  v_No           药品收发记录.No%Type;
  n_平均成本价   药品库存.平均成本价%Type;
  n_费用单价精度 Number;
  d_填制日期     药品收发记录.填制日期%Type;
  d_日期         药品收发记录.填制日期%Type;
  v_Billno       药品收发记录.No%Type;
Begin

  --1、售价调剂处理
  --提取单据信息，原价，现价及药价属性
  Select a.单据, a.库房id, a.药品id, Nvl(a.批次, 0) As 批次, Nvl(a.实际数量, 0) * Nvl(a.付数, 1) As 实际数量, a.入出系数, Nvl(a.零售价, 0) 原价, b.现价,
         Nvl(c.是否变价, 0) 是否变价, b.Id As 价格id
  Into v_单据, v_库房id, v_药品id, v_批次, v_实际数量, v_入出系数, v_原价, v_现价, v_是否变价, v_价格id
  From 药品收发记录 A, 收费价目 B, 收费项目目录 C
  Where a.药品id = b.收费细目id And a.药品id = c.Id And
        (Sysdate Between b.执行日期 And b.终止日期 Or Sysdate >= b.执行日期 And b.终止日期 Is Null) And a.Id = 收发id_In;

  --获取金额小数位数
  Select Zl_To_Number(Nvl(zl_GetSysParameter(157), '5')) Into n_费用单价精度 From Dual;
  If v_单据 = 24 Or v_单据 = 25 Or v_单据 = 26 Then
    --发药应该取费用精度，其他业务应该取药品卫材精度中精度
    Select Zl_To_Number(Nvl(zl_GetSysParameter(9), '2')) Into v_金额精度 From Dual;
  Else
    Select Nvl(精度, 2) Into v_金额精度 From 药品卫材精度 Where 性质 = 0 And 类别 = 2 And 内容 = 4 And 单位 = 5;
  End If;
  --定价直接取收费价目中现价
  v_执行修正 := 0;
  If v_是否变价 = 0 Then
    v_执行修正 := 1;
  Else
    --时价药品的现售价，不能从收费价目中取，因为时价调价可能是按库房和批次来调整的
    v_现价 := 0;
  
    If v_批次 > 0 Then
      --时价分批优先从库存表中取，时价不分批则直接在明细表中查调价记录的零售价
      --从库存记录中取现价
      Begin
        Select Nvl(零售价, 0)
        Into v_现价
        From 药品库存
        Where 性质 = 1 And 库房id + 0 = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 = 0 Then
      Begin
        --取原始单据的审核时间
        Select a.审核日期, a.填制日期
        Into v_审核日期, d_填制日期
        From 药品收发记录 A, 药品收发记录 B
        Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And
              a.序号 = b.序号 And (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);
        If v_单据 = 24 Or v_单据 = 25 Or v_单据 = 26 Then
          d_日期 := d_填制日期;
        Else
          d_日期 := v_审核日期;
        End If;
      
        If Months_Between(Sysdate, d_日期) <= 1 Then
          --只处理小于一个月的数据
          --从调价记录中取现零售价
          Select 零售价, 价格id
          Into v_现价, v_价格id
          From (Select 零售价, 价格id
                 From 药品收发记录
                 Where 单据 = 13 And 摘要 = '卫材调价' And 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And
                       审核日期 Between d_日期 And Sysdate
                 Order By 审核日期 Desc)
          Where Rownum = 1;
        End If;
      Exception
        When Others Then
          v_现价 := 0;
      End;
    End If;
  
    If v_现价 > 0 Then
      v_执行修正 := 1;
    End If;
  End If;

  If v_执行修正 = 1 Then
    --发药类单据售价精度为5，其他流通类单据为7
    If v_单据 = 24 Or v_单据 = 25 Or v_单据 = 26 Then
      v_售价精度 := n_费用单价精度;
    Else
      v_售价精度 := 7;
    End If;
  
    --比较原价和现价，不同则处理
    If v_原价 <> Round(v_现价, v_售价精度) Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Select Nextno(147) Into v_Billno From Dual;
    
      Select 类别id Into v_入出类别id From 药品单据性质 Where 单据 = 38;
    
      v_修正金额 := Round(v_入出系数 * (Round(v_现价, v_售价精度) - v_原价) * v_实际数量, v_金额精度);
    
      --产生调价修正记录
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, 填写数量, 实际数量, 成本价, 成本金额, 零售价, 扣率, 零售金额, 差价, 摘要, 填制人,
         填制日期, 库房id, 入出系数, 价格id, 审核人, 审核日期, 费用id)
        Select v_收发id, 1, 13, v_Billno, 序号, v_入出类别id, 药品id, 批次, 批号, 效期, 产地, 付数, Abs(v_实际数量), 0, v_原价, 0,
               Round(v_现价, v_售价精度), 扣率, v_修正金额, v_修正金额, '自动修正调价变动', 审核人, 审核日期, 库房id, 1, v_价格id, 审核人, 审核日期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新药品库存
      Update 药品库存
      Set 实际金额 = Nvl(实际金额, 0) + v_修正金额, 实际差价 = Nvl(实际差价, 0) + v_修正金额
      Where 性质 = 1 And 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = Nvl(v_批次, 0);
    
      --重新计算库存表中的平均成本价
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 性质 = 1 And 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_药品id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 性质 = 1 And 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      End If;
    
      --删除数量、金额、差价为零的情况
      Delete 药品库存
      Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = Nvl(v_批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    
    End If;
  End If;

  --2、成本价调价
  Select 库房id, 药品id, Nvl(批次, 0) 批次, 入出系数 * 实际数量, 入出系数 * 零售金额, 入出系数 * 差价, 成本价
  Into v_库房id, v_药品id, v_批次, v_实际数量, v_零售金额, v_差价, v_原价
  From 药品收发记录
  Where ID = 收发id_In;

  --取原始单据的审核时间
  Select a.审核日期
  Into v_审核日期
  From 药品收发记录 A, 药品收发记录 B
  Where b.Id = 收发id_In And a.单据 = b.单据 And a.No = b.No And a.库房id = b.库房id And a.药品id + 0 = b.药品id And a.序号 = b.序号 And
        (a.记录状态 = 1 Or Mod(a.记录状态, 3) = 0);

  v_执行修正 := 0;
  Begin
    Select 1, 新成本价
    Into v_执行修正, v_现价
    From 成本价调价信息
    Where 库房id + 0 = v_库房id And 药品id + 0 = v_药品id And Nvl(批次, 0) = v_批次 And 执行日期 > v_审核日期 And Rownum = 1
    Order By 执行日期 Desc;
  
  Exception
    When Others Then
      v_执行修正 := 0;
      v_现价     := 0;
    
  End;

  If v_执行修正 = 1 Then
    v_修正金额 := (v_零售金额 - v_差价) - Round(v_现价 * v_实际数量, v_金额精度);
  
    If v_修正金额 <> 0 Then
      Select 药品收发记录_Id.Nextval Into v_收发id From Dual;
      Select b.Id, b.系数
      Into v_入出类别id, v_入出系数
      From 药品单据性质 A, 药品入出类别 B
      Where a.类别id = b.Id And a.单据 = 33 And Rownum < 2;
    
      v_No := Nextno(71, v_库房id);
    
      --产生库存差价调整单
      Insert Into 药品收发记录
        (ID, 记录状态, 单据, NO, 序号, 库房id, 入出类别id, 供药单位id, 入出系数, 药品id, 批次, 产地, 批号, 效期, 填写数量, 零售价, 成本价, 差价, 摘要, 填制人, 填制日期, 审核人,
         审核日期, 生产日期, 批准文号, 单量, 发药方式, 扣率, 灭菌效期, 费用id)
        Select v_收发id, 1, 18, v_No, 1, 库房id, v_入出类别id, 供药单位id, v_入出系数, 药品id, 批次, 产地, 批号, 效期, v_实际数量, v_零售金额, v_差价,
               v_修正金额, '自动修正调价变动', 审核人, 审核日期, 审核人, 审核日期, 生产日期, 批准文号, v_现价, 1, 成本价, 灭菌效期, 收发id_In
        From 药品收发记录
        Where ID = 收发id_In;
    
      --更新库存
      Update 药品库存
      Set 实际差价 = Nvl(实际差价, 0) + v_修正金额, 上次采购价 = v_现价
      Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And 性质 = 1;
    
      --重新计算库存表中的平均成本价
      Update 药品库存
      Set 平均成本价 = Decode(Nvl(批次, 0), 0, Decode((实际金额 - 实际差价) / 实际数量, 0, 上次采购价, (实际金额 - 实际差价) / 实际数量), 上次采购价)
      Where 性质 = 1 And 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次 And Nvl(实际数量, 0) <> 0;
      If Sql%NotFound Then
        Select 成本价 Into n_平均成本价 From 材料特性 Where 材料id = v_药品id;
        Update 药品库存
        Set 平均成本价 = n_平均成本价
        Where 性质 = 1 And 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = v_批次;
      End If;
    
      --删除数量、金额、差价为零的情况
      Delete 药品库存
      Where 库房id = v_库房id And 药品id = v_药品id And Nvl(批次, 0) = Nvl(v_批次, 0) And 性质 = 1 And Nvl(可用数量, 0) = 0 And
            Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And Nvl(实际差价, 0) = 0;
    End If;
  End If;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料收发记录_调价修正;
/

--119720:李业庆,2018-03-07,按批号先进先出
Create Or Replace Function Zl_Actualmoney
(
  费别_In       Varchar2,
  收费细目id_In 费别明细.收费细目id%Type,
  收入项目id_In 费别明细.收入项目id%Type,
  应收金额_In   门诊费用记录.应收金额%Type,
  数量_In       门诊费用记录.数次%Type := 0,
  药房id_In     药品库存.库房id%Type := 0
) Return Varchar2 As
  --功能:根据应收金额按费别进行打折计算
  --参数:
  --     费别_In:病人当前费别，如果是动态费别，值为'费别1,费别2,...'
  --     应收金额_In:应传入加班加价计算之前的真实应收金额
  --     数量_In:售价数量，药品才需传入
  --     药房id_in:药品才需传入
  --返回:费别:实收金额

  n_实收金额 门诊费用记录.实收金额%Type;
  v_费别     门诊费用记录.费别%Type;

  n_Money   门诊费用记录.实收金额%Type;
  n_Rate    Number;
  n_Cost    Number;
  n_Price   Number;
  n_Outmode Number;
  n_数量    Number;
  n_总数量  Number;

  n_Cnt0 Number;
  n_Cnt1 Number;

  Cursor c_Med Is
    Select b.类别, a.指导差价率, Nvl(c.现价, 0) As 售价, Nvl(a.药房分批, 0) As 分批, Nvl(b.是否变价, 0) As 变价
    From 药品规格 A, 收费项目目录 B, 收费价目 C
    Where a.药品id = b.Id And b.Id = c.收费细目id And a.药品id = 收费细目id_In And Sysdate Between c.执行日期 And
          Nvl(c.终止日期, To_Date('3000-01-01', 'YYYY-MM-DD'));
  r_Med c_Med%RowType;

Begin
  n_实收金额 := 应收金额_In;
  If Instr(费别_In, ',') = 0 Then
    v_费别 := 费别_In;
  Else
    v_费别 := Substr(费别_In, 1, Instr(费别_In, ',') - 1);
  End If;
  If Nvl(数量_In, 0) <> 0 Then
    n_Outmode := Nvl(zl_GetSysParameter(150), 0);
  End If;

  For Rs In (Select 费别, 实收比率, 实收金额, 计算方法
             From (Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And a.收费细目id = 收费细目id_In And Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And
                          Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值
                    Union All
                    Select a.费别, Nvl(a.实收比率, 0) As 实收比率, 应收金额_In * Nvl(a.实收比率, 0) / 100 As 实收金额, Nvl(a.计算方法, 0) As 计算方法,
                           b.属性, b.编码
                    From 费别明细 A, 费别 B
                    Where a.费别 = b.名称 And a.收入项目id = 收入项目id_In And Instr(',' || 费别_In || ',', ',' || b.名称 || ',') > 0 And
                          Abs(应收金额_In) Between a.应收段首值 And a.应收段尾值 And Not Exists
                     (Select 1 From 费别明细 C Where c.费别 = a.费别 And c.收费细目id = 收费细目id_In))
             Order By 计算方法, 实收比率, 属性, 编码) Loop
  
    If Rs.计算方法 = 0 And Nvl(n_Cnt0, 0) = 0 Then
      n_Cnt0     := 1; --一种计算方法只取最优惠的一行记录
      n_实收金额 := Rs.实收金额;
      v_费别     := Rs.费别;
    Elsif Rs.计算方法 = 1 And 数量_In <> 0 And Nvl(n_Cnt1, 0) = 0 Then
      n_Cnt1 := 1; --一种计算方法只取最优惠的一行记录
      --药品按成本价加收方式
      Open c_Med;
      Fetch c_Med
        Into r_Med;
      If c_Med%RowCount > 0 Then
        n_Rate := Rs.实收比率 / 100;
      
        If Nvl(药房id_In, 0) = 0 Then
          --没有确定药房时(或分离模式),分批或不分批药品都按指导差价率算
          n_Money := 应收金额_In * (1 - Nvl(r_Med.指导差价率, 0) / 100) * (1 + n_Rate);
          If n_Money < n_实收金额 Then
            n_实收金额 := n_Money;
            v_费别     := Rs.费别;
          End If;
        
        Elsif r_Med.分批 = 0 Then
          Select 应收金额_In * (1 - Nvl(Decode(Sign(Nvl(a.实际金额, 0)), 1, a.实际差价 / a.实际金额, b.指导差价率 / 100), 0)) As 成本金额
          Into n_Cost
          From 药品库存 A, 药品规格 B
          Where a.药品id(+) = b.药品id And a.库房id(+) = 药房id_In And a.性质(+) = 1 And b.药品id = 收费细目id_In;
          If n_Cost <> 0 Then
            n_Money := n_Cost * (1 + n_Rate);
            If n_Money < n_实收金额 Then
              n_实收金额 := n_Money;
              v_费别     := Rs.费别;
            End If;
          End If;
        
        Elsif r_Med.分批 = 1 Then
          n_总数量 := 数量_In;
          n_Money  := 0;
          For r_Stock In (Select Nvl(批次, 0) As 批次, Nvl(可用数量, 0) As 库存,
                                 Nvl(零售价, Nvl(Decode(Nvl(实际数量, 0), 0, 0, 实际金额 / 实际数量), 0)) As 时价, Nvl(实际差价, 0) As 实际差价,
                                 Nvl(实际金额, 0) As 实际金额
                          From 药品库存
                          Where 库房id = 药房id_In And 药品id = 收费细目id_In And Nvl(可用数量, 0) > 0 And 性质 = 1 And
                                (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate))
                          Order By Decode(n_Outmode, 1, 效期, To_Date('2008-08-08', 'yyyy-mm-dd')),
                                   Decode(n_Outmode, 2, 上次批号, Null), Nvl(批次, 0)) Loop
            If n_总数量 = 0 Then
              Exit;
            End If;
            If n_总数量 <= r_Stock.库存 Then
              n_数量 := n_总数量;
            Else
              n_数量 := r_Stock.库存;
            End If;
          
            If r_Med.变价 = 1 Then
              n_Price := r_Stock.时价;
            Else
              n_Price := r_Med.售价;
            End If;
          
            If r_Stock.实际金额 <> 0 Then
              -- 本批次成本价:按库存差价率算
              n_Cost := n_Price * (1 - r_Stock.实际差价 / r_Stock.实际金额);
            Else
              --无库存金额按指导差价率算,无库存的批次在SQL中已排开
              n_Cost := n_Price * (1 - Nvl(r_Med.指导差价率, 0) / 100);
            End If;
          
            If n_Cost <> 0 Then
              n_Money  := n_Money + n_Cost * (1 + n_Rate) * n_数量;
              n_总数量 := n_总数量 - n_数量;
            End If;
          End Loop;
          If n_总数量 = 0 Then
            If n_Money < n_实收金额 Then
              n_实收金额 := n_Money;
              v_费别     := Rs.费别;
            End If;
          End If;
        End If;
        Close c_Med;
      End If;
    End If;
  End Loop;

  Return v_费别 || ':' || n_实收金额;
Exception
  When Others Then
    Return v_费别 || ':' || n_实收金额;
End Zl_Actualmoney;
/

--119720:李业庆,2018-03-07,按批号先进先出
Create Or Replace Function Zl_Calcdrugprice
(
  药房id_In   药品库存.库房id%Type,
  药品id_In   药品库存.药品id%Type,
  数量_In     药品库存.可用数量%Type,
  出库算法_In Number,
  Decprice_In Number,
  Dec_In      Number
) Return Number Is
  --功能:返回变价药品的时价
  --参数:
  --     数量_In 本次需要发送或者是新开药品的数量
  --     出库算法_In 0-按批次先进先出，1-按效期最近先出
  --     Decprice_In 金额小数位数
  --     Dec_In 价格小数位
  n_时价     门诊费用记录.实收金额%Type;
  n_首批时价 门诊费用记录.实收金额%Type;
  n_总金额   Number;
  n_总数量   Number;
  n_当前数量 Number;
  n_Cnt      Number;
Begin
  If 数量_In <= 0 Then
    Return 0;
  End If;
  n_总金额 := 0;
  n_总数量 := 数量_In;
  For Rs In (Select Nvl(批次, 0) As 批次, Nvl(可用数量, 0) As 库存, Nvl(零售价, Nvl(Decode(Nvl(实际数量, 0), 0, 0, 实际金额 / 实际数量), 0)) As 时价
             From 药品库存
             Where 库房id = 药房id_In And 药品id = 药品id_In And Nvl(可用数量, 0) > 0 And 性质 = 1 And
                   (Nvl(批次, 0) = 0 Or 效期 Is Null Or 效期 > Trunc(Sysdate))
             Order By Decode(出库算法_In, 1, 效期, To_Date('2008-08-08', 'yyyy-mm-dd')), Decode(出库算法_In, 2, 上次批号, Null),
                      Nvl(批次, 0)) Loop
    --第一个批次的时价
    n_Cnt := n_Cnt + 1;
    If n_Cnt = 1 Then
      n_首批时价 := Round(Rs.时价, Decprice_In);
    End If;
    If n_总数量 = 0 Then
      Exit;
    End If;
    If n_总数量 <= Rs.库存 Then
      n_当前数量 := n_总数量;
    Else
      n_当前数量 := Rs.库存;
    End If;
    n_总金额 := n_总金额 + Round(n_当前数量 * Round(Rs.时价, Decprice_In), Dec_In);
    n_总数量 := n_总数量 - n_当前数量;
    If n_总数量 = 0 Then
      Exit;
    End If;
  End Loop;
  If n_总数量 <> 0 Then
    -- 库存不够,只涉及一个批次时以首批时价为准，否则以第一批或者平均价都不合适
    If n_Cnt = 1 Then
      n_时价 := n_首批时价;
    Else
      n_时价 := 0;
    End If;
  Else
    If n_Cnt = 1 Then
      n_时价 := n_首批时价;
    Else
      n_时价 := Round(n_总金额 / 数量_In, Decprice_In);
    End If;
  End If;
  Return n_时价;
Exception
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_Calcdrugprice;
/

--123482:李业庆,2018-04-04,保存加成率
Create Or Replace Procedure Zl_材料外购_Insert
(
  No_In         In 药品收发记录.No%Type,
  序号_In       In 药品收发记录.序号%Type,
  库房id_In     In 药品收发记录.库房id%Type,
  供药单位id_In In 药品收发记录.供药单位id%Type,
  材料id_In     In 药品收发记录.药品id%Type,
  产地_In       In 药品收发记录.产地%Type := Null,
  批号_In       In 药品收发记录.批号%Type := Null,
  生产日期_In   In 药品收发记录.生产日期%Type := Null,
  效期_In       In 药品收发记录.效期%Type := Null,
  灭菌日期_In   In 药品收发记录.灭菌日期%Type := Null,
  灭菌效期_In   In 药品收发记录.灭菌效期%Type := Null,
  实际数量_In   In 药品收发记录.实际数量%Type := Null,
  成本价_In     In 药品收发记录.成本价%Type := Null,
  成本金额_In   In 药品收发记录.成本金额%Type := Null,
  扣率_In       In 药品收发记录.扣率%Type := Null,
  零售价_In     In 药品收发记录.零售价%Type := Null,
  零售金额_In   In 药品收发记录.零售金额%Type := Null,
  差价_In       In 药品收发记录.差价%Type := Null,
  零售差价_In   In 药品收发记录.差价%Type := Null,
  摘要_In       In 药品收发记录.摘要%Type := Null,
  注册证号_In   In 药品收发记录.注册证号%Type := Null,
  填制人_In     In 药品收发记录.填制人%Type := Null,
  随货单号_In   In 应付记录.随货单号%Type := Null,
  发票号_In     In 应付记录.发票号%Type := Null,
  发票日期_In   In 应付记录.发票日期%Type := Null,
  发票金额_In   In 应付记录.发票金额%Type := Null,
  填制日期_In   In 药品收发记录.填制日期%Type := Null,
  核查人_In     In 药品收发记录.配药人%Type := Null,
  核查日期_In   In 药品收发记录.配药日期%Type := Null,
  批次_In       In 药品收发记录.批次%Type := 0,
  退货_In       In Number := 1,
  高值材料_In   In Varchar2 := Null,
  商品条码_In   In 药品收发记录.商品条码%Type := Null,
  内部条码_In   In 药品收发记录.内部条码%Type := Null,
  费用id_In     In 药品收发记录.费用id%Type := 0,
  发票代码_In   In 应付记录.发票代码%Type := Null,
  财务审核_In   In Number := 0,
  批准文号_In   In 药品收发记录.批准文号%Type := Null,
  验收结论_In   In 药品收发记录.验收结论%Type := Null,
  加成率_In     In 药品收发记录.频次%Type := Null
) Is
  Err_Item Exception;
  v_Err_Msg Varchar2(200);

  v_No         应付记录.No%Type; --应付记录的NO 
  v_商品名     收费项目目录.名称%Type; --通用名称 
  v_规格       收费项目目录.规格%Type;
  v_产地       收费项目目录.规格%Type;
  v_单位       收费项目目录.计算单位%Type;
  v_Lngid      药品收发记录.Id%Type; --收发ID 
  n_应付id     应付记录.Id%Type; --应付记录的ID 
  n_入出类别id 药品收发记录.入出类别id%Type; --入出类别ID 
  n_入出系数   药品收发记录.入出系数%Type; --入出系数 
  n_批次       药品收发记录.批次%Type := Null; --批次 
  n_库房分批   Integer; --是否分批核算    1:分批；0：不分批 
  n_在用分批   Integer; --是否在用分批       1:分批；0：不分批 
  v_可用数量   药品库存.可用数量%Type;
Begin

  If Not 批准文号_In Is Null And Not 产地_In Is Null Then
    Update 药品生产商对照 Set 批准文号 = 批准文号_In Where 药品id = 材料id_In And 厂家名称 = 产地_In;
    If Sql%RowCount = 0 Then
      Insert Into 药品生产商对照 (药品id, 厂家名称, 批准文号) Values (材料id_In, 产地_In, 批准文号_In);
    End If;
  End If;

  --取该材料的名称 
  v_产地 := '';
  Select 名称, 规格, 计算单位 Into v_商品名, v_规格, v_单位 From 收费项目目录 Where ID = 材料id_In;

  If v_规格 Is Not Null Then
    If Instr(v_规格, '|') <> 0 Then
      v_产地 := Substr(v_规格, Instr(v_规格, '|'));
      v_规格 := Substr(v_规格, Instr(v_规格, '|') - 1);
    End If;
  End If;

  Select 药品收发记录_Id.Nextval Into v_Lngid From Dual;

  Select Nvl(库房分批, 0), Nvl(在用分批, 0) Into n_库房分批, n_在用分批 From 材料特性 Where 材料id = 材料id_In;

  --财务审核直接用传过来的批次
  If 财务审核_In = 0 Then
    If 费用id_In > 0 And 批次_In > 0 Then
      n_批次 := 批次_In;
    Else
      If n_在用分批 = 0 Then
        If n_库房分批 = 1 Then
          Begin
            Select Distinct 0
            Into n_库房分批
            From 部门性质说明
            Where ((工作性质 Like '发料部门') Or (工作性质 Like '制剂室')) And 部门id = 库房id_In;
          Exception
            When Others Then
              n_库房分批 := 1;
          End;
        
          If n_库房分批 = 1 Then
            n_批次 := v_Lngid;
          End If;
        Else
          n_批次 := 0;
        End If;
      Else
        n_批次 := v_Lngid;
      End If;
    End If;
  Else
    n_批次 := 批次_In;
  End If;

  Select b.Id, b.系数
  Into n_入出类别id, n_入出系数
  From 药品单据性质 A, 药品入出类别 B
  Where a.类别id = b.Id And a.单据 = 30 And Rownum < 2;

  Insert Into 药品收发记录
    (ID, 记录状态, 单据, NO, 序号, 库房id, 供药单位id, 入出类别id, 入出系数, 药品id, 批次, 产地, 批号, 生产日期, 效期, 灭菌日期, 灭菌效期, 填写数量, 实际数量, 成本价, 成本金额,
     扣率, 零售价, 零售金额, 差价, 摘要, 填制人, 填制日期, 发药方式, 配药人, 配药日期, 注册证号, 用法, 商品条码, 内部条码, 费用id, 批准文号, 验收结论, 频次)
  Values
    (v_Lngid, 1, 15, No_In, 序号_In, 库房id_In, 供药单位id_In, n_入出类别id, n_入出系数, 材料id_In, Decode(退货_In, -1, 批次_In, n_批次), 产地_In,
     批号_In, 生产日期_In, 效期_In, 灭菌日期_In, 灭菌效期_In, 退货_In * 实际数量_In, 退货_In * 实际数量_In, 成本价_In, 退货_In * 成本金额_In, 扣率_In, 零售价_In,
     退货_In * 零售金额_In, 退货_In * 差价_In, 摘要_In, 填制人_In, 填制日期_In, Decode(退货_In, -1, 1, 0), 核查人_In, 核查日期_In, 注册证号_In, 零售差价_In,
     商品条码_In, 内部条码_In, 费用id_In, 批准文号_In, 验收结论_In, 加成率_In);

  --高值材料信息 
  If Length(高值材料_In) > 0 Then
    Insert Into 收发记录补充信息
      (收发id, 科室, 病人姓名, 住院号, 床号)
    Values
      (v_Lngid, Substr(高值材料_In, 1, Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 1) + 1, Instr(高值材料_In, ',', 1, 2) - Instr(高值材料_In, ',', 1, 1) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 2) + 1, Instr(高值材料_In, ',', 1, 3) - Instr(高值材料_In, ',', 1, 2) - 1),
       Substr(高值材料_In, Instr(高值材料_In, ',', 1, 3) + 1, Length(高值材料_In)));
  End If;

  If 发票号_In Is Not Null Or 随货单号_In Is Not Null Then
  
    Select 应付记录_Id.Nextval Into n_应付id From Dual;
  
    --如果是第一笔明细,则产生应付记录的NO 
    Begin
      Select NO
      Into v_No
      From 应付记录
      Where 系统标识 = 5 And 记录性质 = 0 And 记录状态 = 1 And 入库单据号 = No_In And Rownum < 2;
    Exception
      When Others Then
        v_No := Nextno(67);
    End;
  
    Insert Into 应付记录
      (ID, 记录性质, 记录状态, 项目id, 序号, 单位id, NO, 系统标识, 收发id, 入库单据号, 单据金额, 随货单号, 发票号, 发票日期, 发票金额, 品名, 规格, 产地, 批号, 计量单位, 数量,
       采购价, 采购金额, 填制人, 填制日期, 审核人, 审核日期, 摘要, 库房id, 发票代码)
    Values
      (n_应付id, 0, 1, 材料id_In, 序号_In, 供药单位id_In, v_No, 5, v_Lngid, No_In, 退货_In * 零售金额_In, 随货单号_In, 发票号_In, 发票日期_In,
       退货_In * Decode(发票号_In, Null, 成本金额_In, 发票金额_In), v_商品名, v_规格, v_产地, 批号_In, v_单位, 退货_In * 实际数量_In, 成本价_In,
       退货_In * 成本金额_In, 填制人_In, 填制日期_In, Null, Null, 摘要_In, 库房id_In, 发票代码_In);
  End If;

  --退货时下可用数量 
  If 退货_In = -1 And Nvl(费用id_In, 0) <> 2 Then
    --检查库存 
    Begin
      Select Nvl(可用数量, 0)
      Into v_可用数量
      From 药品库存
      Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = Nvl(批次_In, 0) And 性质 = 1;
    Exception
      When Others Then
        v_可用数量 := 0;
    End;
  
    If v_可用数量 - 实际数量_In < 0 Then
      v_Err_Msg := '[ZLSOFT]第' || 序号_In || '行的可用数量不够,请检查[ZLSOFT]';
      Raise Err_Item;
    End If;
    Update 药品库存
    Set 可用数量 = Nvl(可用数量, 0) - 实际数量_In
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(批次, 0) = 批次_In And 性质 = 1;
    Delete From 药品库存
    Where 库房id = 库房id_In And 药品id = 材料id_In And Nvl(可用数量, 0) = 0 And Nvl(实际数量, 0) = 0 And Nvl(实际金额, 0) = 0 And
          Nvl(实际差价, 0) = 0;
  End If;

Exception
  When Err_Item Then
    Raise_Application_Error(-20101, v_Err_Msg);
  When Others Then
    zl_ErrorCenter(SQLCode, SQLErrM);
End Zl_材料外购_Insert;
/


---------------------------------------------------------------------------------------------------
--更改系统及部件的版本号
-------------------------------------------------------------------------------------------------------

--000000:刘硕,2018-01-16,更新部分信息，未登记问题
Update zlFilesUpgrade
Set 文件说明 = '部件功能:新版LIS通讯程序部件。系统定位:主要处理与仪器接口之间数据交互。缺失后果:不能正常解析仪器数据'
Where Upper(文件名) = 'ZL9LABRECEIV.EXE';
Update Zlfiles
Set 文件说明 = '部件功能:新版LIS通讯程序部件。系统定位:主要处理与仪器接口之间数据交互。缺失后果:不能正常解析仪器数据'
Where Upper(名称) = 'ZL9LABRECEIV.EXE';
--系统版本号
Update zlSystems Set 版本号='10.34.150' Where 编号=&n_System;
--部件版本号

--119656:杨周一,2018-01-18,LIS图片数据转出子程序
Insert Into Zltools.Zlfilesupgrade
  (序号, 加入日期, 安装路径, 文件类型, 文件名, 版本号, 修改日期, 所属系统, 业务部件, Md5, 文件说明, 自动注册, 强制覆盖)
  Select 序号, To_Date('2018-01-18 10:25:54', 'yyyy-mm-dd hh24:mi:ss'), '[APPSOFT]', 0, 'ZLLISPIC2FTPSUB.EXE', Null, Null,
         Null, Null, Null, '部件功能:LIS图片数据转出子程序,缺失会导致LIS图片转出功能无法使用', 0, 0
  From Dual A, (Select Nvl(Max(To_Number(序号)), 0) + 1 序号 From zlFilesUpgrade) B
  Where Not Exists (Select 1 From Zltools.Zlfilesupgrade Where Upper(文件名) = 'ZLLISPIC2FTPSUB.EXE');

Commit;